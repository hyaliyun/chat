import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-9c963016"]]),A=JSON.parse('[{"question":"Given a list of integers `nums`, find the maximum product of any two distinct elements in the list. Return the maximum product. For example, given `nums = [5, 3, -1, 9, -7]`, the maximum product would be `5 * 9 = 45`.","solution":"def max_product(nums): Returns the maximum product of any two distinct elements in the list. # Sort the list nums.sort() # The maximum product could be from the two highest values or two lowest values (in case they are negative) return max(nums[-1] * nums[-2], nums[0] * nums[1])"},{"question":"Given a list of integers `nums`, consider a list of all possible subarrays. Return the length of the shortest subarray whose sum is equal to or greater than a given integer `target`. If no such subarray exists, return 0.","solution":"def min_subarray_len(target, nums): Returns the length of the shortest subarray whose sum is equal to or greater than target. If no such subarray exists, return 0. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"Given an array of integers `arr`, you are to form a sequence by starting from the first element and at each step moving to the next different element (i.e., an element that hasn\'t been visited yet in the current sequence). Your task is to find the length of the longest subsequence that can be formed following this rule. Return _the length of the longest subsequence_ of `arr` where each element in the subsequence is distinct and followed by the next different element in the original array.","solution":"def longest_distinct_subsequence(arr): Returns the length of the longest subsequence of distinct elements by moving to the next different element in the array. Parameters: arr (list): List of integers. Returns: int: Length of the longest subsequence with distinct elements. if not arr: return 0 seen = set() subsequence_length = 0 for num in arr: if num not in seen: seen.add(num) subsequence_length += 1 return subsequence_length"},{"question":"A tropical island is represented by a grid of size `m x n` where each cell contains a certain number of coconuts. You are positioned at the top-left cell of the grid and want to collect coconuts while moving to the bottom-right cell. You can only move either down or right at any point in time. Write an algorithm to find the maximum number of coconuts you can collect on your way. The grid is given as a 2D array `coconuts` where `coconuts[i][j]` represents the number of coconuts in the cell `(i, j)`. Return _the maximum number of coconuts you can collect_.","solution":"def max_coconuts(coconuts): Find the maximum number of coconuts that can be collected while moving from the top-left to the bottom-right of the grid. if not coconuts or not coconuts[0]: return 0 m, n = len(coconuts), len(coconuts[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = coconuts[0][0] # Initialize first row for j in range(1, n): dp[0][j] = dp[0][j-1] + coconuts[0][j] # Initialize first column for i in range(1, m): dp[i][0] = dp[i-1][0] + coconuts[i][0] # Fill the rest of dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + coconuts[i][j] return dp[m-1][n-1]"},{"question":"Given an integer array `data` representing the votes cast in an election, and a positive integer `k`, determine the number of potential winners if a candidate can still receive up to `k` additional votes. The winner is the candidate with the highest vote count. If there is a tie for the highest vote count, there are no winners. Write a function to return the number of candidates who can potentially win the election after receiving up to `k` extra votes. Function signature: `int potentialWinners(vector<int>& data, int k)` Example: Input: `data = [2, 3, 5, 2]`, `k = 3` Output: `2` Explanation: - The candidate with the current highest votes has `5` votes. - Adding up to `k=3` votes to any candidate: - Candidates with indices `0` and `1` can reach a maximum of `5` and `6` votes. - Candidate with index `2` (already has `5` votes) can reach up to `8` votes. - Candidate with index `3` can reach up to `5` votes. - The number of candidates who can potentially win if they receive up to `k` extra votes are the ones who can reach or exceed `6` votes. - Hence, the result is `2`.","solution":"from typing import List def potentialWinners(data: List[int], k: int) -> int: Calculate the number of potential winners in the election given current votes and additional votes. current_max = max(data) potential_winners = 0 for votes in data: if votes + k > current_max: potential_winners += 1 if potential_winners == 0: # In case no one can exceed the current_max, the highest voters are already winners. # We need to check for ties. if data.count(current_max) == 1: return 1 else: return 0 return potential_winners"},{"question":"You are given a list of strings `words` and a string `s` representing a concatenation of an arbitrary order of all words from the list `words`. Each word from the list appears exactly once in the concatenated string `s`. Implement a function to return all possible starting indices of `s` such that sub-strings of a given length `l` are valid words from the list. A sub-string is considered valid if it is from the list `words` and does not overlap with other words. The function should return the indices in ascending order.","solution":"def find_starting_indices(words, s, l): Returns the starting indices in the string s where the substrings of length l are valid words from the list words. word_set = set(words) indices = [] for i in range(0, len(s) - l + 1): if s[i:i+l] in word_set: indices.append(i) return indices"},{"question":"Given a `m x n` grid of integers where each cell represents the height at that point, write an algorithm to determine the water capacity of the grid. Water capacity is defined as the difference between the height of the water and the height of the terrain in cells where the water can be trapped, assuming the borders of the grid prevent water from escaping. Return the total amount of water that can be trapped in the grid.","solution":"import heapq def trap_rain_water(height_map): if not height_map or not height_map[0]: return 0 m, n = len(height_map), len(height_map[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the border cells into the heap for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(heap, (height_map[i][j], i, j)) visited[i][j] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: trapped = max(0, height - height_map[nx][ny]) water_trapped += trapped visited[nx][ny] = True heapq.heappush(heap, (max(height, height_map[nx][ny]), nx, ny)) return water_trapped"},{"question":"Given an integer `n`, return the list of prime numbers less than `n`. Your solution should use the Sieve of Eratosthenes algorithm to ensure optimal performance.","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] primes = [True] * n primes[0] = primes[1] = False for start in range(2, int(n ** 0.5) + 1): if primes[start]: for multiple in range(start*start, n, start): primes[multiple] = False return [num for num, is_prime in enumerate(primes) if is_prime]"},{"question":"Given two integers `a` and `b`, return the smallest **positive integer** that is a multiple of both `a` and `b`. If the smallest multiple does not exist within a reasonable range (i.e., if either `a` or `b` is non-positive), return `-1`.","solution":"import math def smallest_positive_multiple(a, b): Returns the smallest positive integer that is a multiple of both a and b. If a or b is non-positive, returns -1. if a <= 0 or b <= 0: return -1 return abs(a * b) // math.gcd(a, b)"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find whether there exist two distinct indices `i` and `j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is equal to `target`. Return `true` if such indices exist, or `false` otherwise.","solution":"def has_pair_with_abs_difference(nums, target): Check if there are two distinct indices i and j in nums such that the absolute difference between nums[i] and nums[j] is equal to target. Args: nums (list): List of integers. target (int): Target absolute difference. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in nums: if (num + target) in seen or (num - target) in seen: return True seen.add(num) return False"},{"question":"You are given an integer array `heights` representing the heights of students in a class. A subsequence `seq` is defined as an orderly list of students where each subsequent student is taller than the previous one. You need to find and return the length of the longest subsequence that can be formed where each student is strictly taller than the previous student. Return _the length_ of such a subsequence.","solution":"def length_of_lis(heights): Returns the length of the longest increasing subsequence in heights. if not heights: return 0 n = len(heights) # Create a list to store the length of the longest increasing subsequence ending at each index. lis = [1] * n # Iterate through the heights and compute the length of the longest increasing subsequence. for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The maximum value in lis will be the length of the longest increasing subsequence. return max(lis)"},{"question":"Write a function that receives two integers, `start` and `end`, and returns the **sum of all prime numbers** in the inclusive range `[start, end]`. If there are no prime numbers in the given range, the function should return `0`.","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes(start, end): Returns the sum of all prime numbers in the inclusive range [start, end]. If there are no primes in the range, returns 0. return sum(n for n in range(start, end + 1) if is_prime(n))"},{"question":"You are given a binary tree with `n` nodes where each node has a value represented by an integer. You need to perform `q` queries on this tree. Each query consists of two integers, `u` and `v`, representing two nodes in the tree. For each query, find and return the sum of values of all nodes that lie on the path between nodes `u` and `v`, inclusive.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, u, v): if root is None or root.value == u or root.value == v: return root left_lca = find_lca(root.left, u, v) right_lca = find_lca(root.right, u, v) if left_lca and right_lca: return root return left_lca if left_lca else right_lca def path_sum(root, u, v): lca = find_lca(root, u, v) return sum_values_on_path(lca, u) + sum_values_on_path(lca, v) - lca.value def sum_values_on_path(root, target): if root is None: return 0 if root.value == target: return root.value left_sum = sum_values_on_path(root.left, target) right_sum = sum_values_on_path(root.right, target) if left_sum > 0 or right_sum > 0: return root.value + max(left_sum, right_sum) return 0"},{"question":"You have a rectangular grid of size `m x n`, initially filled with water. You are given an array `cells` where `cells[i] = [r_i, c_i]` represents a land cell (`land`) placed at row `r_i` and column `c_i` (0-indexed). Each day, you place one `land` cell on the grid until all the cells are filled. Return the earliest day on which there is a `path` from the top row to the bottom row, where a path consists of connected `land` cells (horizontally or vertically). If no such path exists, return `-1`.","solution":"def earliest_path_day(m, n, cells): Returns the earliest day on which there is a path from the top row to the bottom row. parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] top_roots, bottom_roots = set(), set() for day, (r, c) in enumerate(cells): parent[(r, c)] = (r, c) for dr, dc in dirs: nr, nc = r + dr, c + dc if (nr, nc) in parent: union((r, c), (nr, nc)) if r == 0: top_roots.add(find((r, c))) if r == m - 1: bottom_roots.add(find((r, c))) if any(find(top) in bottom_roots for top in top_roots): return day + 1 return -1"},{"question":"You are given an integer `amount` and an array of integers `coins` representing the available denominations of coins. Write a function to compute the number of combinations that make up that amount. You may assume that you have an infinite number of each kind of coin. Return the number of combinations that make up the given amount. If that amount of money cannot be made up by any combination of the coins, return `0`.","solution":"def coin_change_combinations(amount, coins): Given an amount and an array of coin denominations, this function computes the number of combinations that make up that amount. It uses dynamic programming to solve the problem. :param amount: int - the amount to form using the coin denominations :param coins: List[int] - available denominations of coins :return: int - number of combinations to make the given amount # Initialize a list of zeros with indices representing amounts from 0 to `amount` dp = [0] * (amount + 1) dp[0] = 1 # There\'s one way to make amount 0 - by using no coins for coin in coins: for x in range(coin, amount + 1): dp[x] += dp[x - coin] return dp[amount]"},{"question":"Given a matrix of dimensions `n x n` representing the connections in an undirected, weighted graph, where `matrix[i][j]` contains the weight of the edge between nodes `i` and `j`, and `matrix[i][j] = 0` indicates no direct edge exists between node `i` and node `j`. Design an algorithm to find the shortest path between two nodes `source` and `destination`. Return the length of the shortest path. If there is no path between the `source` and `destination`, return `-1`. The weight on all edges is guaranteed to be positive.","solution":"import heapq import sys def dijkstra_shortest_path(matrix, source, destination): Finds the shortest path between source and destination nodes in an undirected, weighted graph represented by the matrix. Parameters: matrix (list of list of int): 2D list representing the graph source (int): The starting node destination (int): The target node Returns: int: Length of the shortest path. Returns -1 if there is no path. n = len(matrix) dist = [float(\'inf\')] * n dist[source] = 0 priority_queue = [(0, source)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if u == destination: return current_dist for v in range(n): if matrix[u][v] > 0: # There is an edge between u and v alt = current_dist + matrix[u][v] if alt < dist[v]: dist[v] = alt heapq.heappush(priority_queue, (alt, v)) return -1 if dist[destination] == float(\'inf\') else dist[destination]"},{"question":"Implement a `MagicDictionary` class that supports a dictionary of words and the ability to search for words that can be formed by changing exactly one letter in a given word. The class should have the following methods: * `void buildDictionary(String[] dictionary)` – Initializes the dictionary with an array of words. * `boolean search(String searchWord)` – Returns `true` if there is any word in the dictionary that can be formed by changing exactly one letter in `searchWord`, otherwise returns `false`.","solution":"class MagicDictionary: def __init__(self): Initialize a MagicDictionary object. self.dictionary = set() def buildDictionary(self, dictionary): Build a dictionary through a list of words. :param dictionary: List[str] :return: void self.dictionary = set(dictionary) def search(self, searchWord): Returns true if there is any word in the dictionary that can be formed by changing exactly one letter in the given word, return false otherwise. :param searchWord: str :return: bool for word in self.dictionary: if len(word) == len(searchWord): diff_count = 0 for w, s in zip(word, searchWord): if w != s: diff_count += 1 if diff_count > 1: break if diff_count == 1: return True return False"},{"question":"You are given a list of `n` strings called `words` and another string called `order` that represents the order of the alphabet (a permutation of the lowercase English letters). Write a function to determine if the given `words` are sorted in lexicographical order according to the given `order`. Return `True` if the `words` are sorted, and `False` otherwise.","solution":"def is_alien_sorted(words, order): Determines if the given words are sorted according to the provided alien alphabet order. :param words: List of strings :param order: A string representing the alien alphabet order :return: True if words are sorted according to the order, False otherwise order_index = {char: idx for idx, char in enumerate(order)} def compare(word1, word2): for c1, c2 in zip(word1, word2): if order_index[c1] < order_index[c2]: return True elif order_index[c1] > order_index[c2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not compare(words[i], words[i + 1]): return False return True"},{"question":"Given an array of integers `nums` representing the amount of rain in millimeters for each day, design an algorithm to determine the maximum amount of rain that can be collected between two days. The rain can only be collected if there is a day with no rain between the two selected days. For example, if the array is `[3, 0, 2, 5, 0, 1, 6]`, the maximum amount of rain collectible is `5` (between days 2 and 3). Return the maximum amount of rain collectible according to the conditions mentioned. The array will have a length of at least three, and all values will be non-negative integers.","solution":"def max_collectible_rain(nums): Returns the maximum amount of rain that can be collected between two days, given that there is a day with no rain between the two selected days. :param nums: List[int] - Array representing the amount of rain in millimeters for each day :return: int - Maximum amount of rain collectible between two days max_rain = 0 n = len(nums) for i in range(n): if nums[i] == 0: for j in range(i+1, n): if nums[j] == 0: if j - i > 1: rain_sum = max(nums[i+1:j]) if rain_sum > max_rain: max_rain = rain_sum break return max_rain"},{"question":"Given a **0-indexed** integer array `nums`, define the score of a subsequence as the difference between the maximum and minimum elements in that subsequence. An array has a \\"special subsequence\\" if it contains at least `two` elements and the score of the subsequence is equal to a given integer `target`. Return the shortest possible length of any special subsequence of `nums` with score equal to `target`. If no valid subsequence exists, return `-1`.","solution":"def shortest_special_subsequence(nums, target): n = len(nums) if n < 2: return -1 min_len = float(\'inf\') found = False # Loop through each pair of elements (i, j) where i < j for i in range(n): for j in range(i + 1, n): score = abs(nums[j] - nums[i]) if score == target: found = True min_len = min(min_len, j - i + 1) return min_len if found else -1"},{"question":"You are given two **0-indexed** integer arrays, `start` and `end`, each of length `n`, where `start[i]` and `end[i]` represent the start and end points of the `i-th` interval. A point is said to be covered by an interval if it lies between the start and end points of that interval (inclusive). Return _the total number of unique points that are covered by at least one interval_.","solution":"def count_unique_covered_points(start, end): Returns the total number of unique points that are covered by at least one interval. Parameters: start (list of int): The start points of the intervals. end (list of int): The end points of the intervals. Returns: int: The number of unique covered points. covered_points = set() for i in range(len(start)): covered_points.update(range(start[i], end[i] + 1)) return len(covered_points)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You can perform the following operation on `s` as many times as you want: Choose any character that appears at least twice in the string and remove all its occurrences. Return the length of the shortest string that can be obtained by performing the above operation any number of times.","solution":"def shortest_string_length(s): Returns the length of the shortest string that can be obtained by removing all occurrences of characters that appear at least twice. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find all characters that appear exactly once in the string single_occurrence_chars = [char for char, count in char_count.items() if count == 1] # Return the total number of characters that appear exactly once return len(single_occurrence_chars)"},{"question":"Given a string `s` and an integer `k`, return the number of substrings in `s` of length `k` with no repeated characters. You need to efficiently determine the count without generating all possible substrings.","solution":"def count_k_length_substrings_with_no_repeats(s, k): Count the number of substrings of length `k` in `s` that have no repeated characters. :param s: The input string. :param k: The length of the substrings to consider. :return: The number of substrings of length `k` with no repeated characters. if k > len(s): return 0 count = 0 char_map = {} start = 0 for end in range(len(s)): end_char = s[end] if end_char in char_map: char_map[end_char] += 1 else: char_map[end_char] = 1 while char_map[end_char] > 1: start_char = s[start] start += 1 char_map[start_char] -= 1 if char_map[start_char] == 0: del char_map[start_char] if end - start + 1 == k: count += 1 start_char = s[start] start += 1 char_map[start_char] -= 1 if char_map[start_char] == 0: del char_map[start_char] return count"},{"question":"Given an array of integers `arr` and an integer `x`, you are required to find whether there exists a triplet in the array whose sum is equal to `x`. If such a triplet exists, return the indices of the elements forming that triplet in any order. If multiple such triplets exist, return any one of them. If no such triplet exists, return an empty array.","solution":"def find_triplet_sum(arr, x): Finds a triplet in the array whose sum is equal to x and returns the indices of the elements forming that triplet. Args: arr: list of integers x: integer value of the target sum Returns: list of three integers representing the indices of the elements forming the triplet, or an empty list if no such triplet exists. n = len(arr) for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[i] + arr[j] + arr[k] == x: return [i, j, k] return []"},{"question":"You are given a binary tree and an integer `targetSum`. Find all paths in the tree where the sum of the values along the path equals `targetSum`. Return these paths as a list of lists. A path is defined as a sequence of nodes starting from the root down to any leaf. Each node in the sequence must be connected by exactly one edge. The sum of the path is the sum of the node values in the path. A binary tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example: Given `targetSum` = 22 and the following binary tree: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` The function should return: ``` [ [5, 4, 11, 2], [5, 8, 4, 5] ] ``` These are the two paths where the sum of the values along the path equals `targetSum`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == targetSum: result.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"Given a string `s` containing only lowercase English letters, return the number of distinct substrings that can be formed. Substrings that are repeated in the string should be counted only once. Try to achieve this in O(n^2) time complexity by considering all possible substrings and utilizing a data structure that maintains unique entries. For example, given the string `\\"abc\\"`, the substrings are `\\"a\\"`, `\\"b\\"`, `\\"c\\"`, `\\"ab\\"`, `\\"bc\\"`, and `\\"abc\\"`. Since all of them are unique, the result would be `6`. Another example, given the string `\\"aaa\\"`, the substrings are `\\"a\\"`, `\\"a\\"`, `\\"a\\"`, `\\"aa\\"`, `\\"aa\\"`, `\\"aaa\\"`, but the unique substrings are `\\"a\\"`, `\\"aa\\"`, and `\\"aaa\\"`, so the result would be `3`.","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings in the given string s. n = len(s) substrings_set = set() for i in range(n): for j in range(i + 1, n + 1): substr = s[i:j] substrings_set.add(substr) return len(substrings_set)"},{"question":"Write a function that takes in an array of integers `nums` and returns the length of the longest **consecutive elements sequence**. The consecutive elements sequence must be a contiguous subsequence of the original array. The sequence does not need to be sorted in the input array, but the elements in the consecutive sequence should be consecutive when evaluated in increasing order. The time complexity should be better than O(n log n).","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. The time complexity of this solution is O(n) because each element is attempted to be accessed a constant number of times. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums: # Only look for the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a `k x k` `board` of cells represented by `0` (empty) and `1` (occupied), you need to find the size of the largest square sub-grid consisting entirely of `0`s. Each cell in the square must be empty, and it must form a contiguous block on the board. Return an integer representing the side length of the largest possible square of empty cells. If there are no empty cells, return `0`.","solution":"def largest_empty_square(board): Returns the side length of the largest square sub-grid consisting entirely of 0s. :param board: List[List[int]], a k x k board of cells represented by 0 (empty) and 1 (occupied) :return: int, the side length of the largest possible square of empty cells if not board or not board[0]: return 0 k = len(board) dp = [[0] * k for _ in range(k)] max_side = 0 for i in range(k): for j in range(k): if board[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"You are given a linked list where each node contains an integer value. Your task is to write a function that finds the first node of the cycle in the linked list if a cycle is present. If there is no cycle, return `null`. A cycle is detected if a node can be visited more than once by traversing the list continuously. You must solve this problem using O(n) time complexity and O(1) space complexity.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectCycle(head): Detects the first node of the cycle in the linked list if a cycle is present. Uses O(n) time complexity and O(1) space complexity. :param head: ListNode, the head of the linked list :return: ListNode, the node where the cycle begins; or None if there is no cycle if not head or not head.next: return None slow = head fast = head # Detect if a cycle is present using two pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given two strings, `word1` and `word2`. A string `word1` can be transformed into string `word2` using the following operation: you can choose any character in `word1` and replace it with another character. The transformation cost between two characters `c1` and `c2` is defined as the absolute difference between their ASCII values. Return _the minimum transformation cost_ to transform `word1` into `word2`. If the transformation is not possible (i.e., the lengths of `word1` and `word2` are different), return `-1`.","solution":"def min_transformation_cost(word1, word2): Returns the minimum transformation cost to transform word1 into word2, if possible. If the lengths of word1 and word2 are different, returns -1. # Check if the lengths of the words are different if len(word1) != len(word2): return -1 # Calculate the total transformation cost total_cost = 0 for c1, c2 in zip(word1, word2): total_cost += abs(ord(c1) - ord(c2)) return total_cost"},{"question":"Write a function to solve the following problem: You\'re given two integer arrays, `arr1` and `arr2`, sorted in non-decreasing order and containing `m` and `n` elements respectively. Find the median of the two sorted arrays. The overall run-time complexity should be `O(log (m+n))`. Example inputs: `arr1 = [1, 3, 8]`, `arr2 = [7, 9, 10, 11]` Expected output: `8.0`","solution":"def find_median_sorted_arrays(arr1, arr2): Finds the median of two sorted arrays. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: float: Median of the combined sorted arrays. def find_median_util(A, B): m, n = len(A), len(B) if m > n: A, B, m, n = B, A, n, m if n == 0: raise ValueError(\\"Both arrays are empty\\") imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < m and A[i] < B[j-1]: imin = i + 1 elif i > 0 and A[i-1] > B[j]: imax = i - 1 else: if i == 0: max_of_left = B[j-1] elif j == 0: max_of_left = A[i-1] else: max_of_left = max(A[i-1], B[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = B[j] elif j == n: min_of_right = A[i] else: min_of_right = min(A[i], B[j]) return (max_of_left + min_of_right) / 2.0 return find_median_util(arr1, arr2)"},{"question":"You are given a matrix `grid` of `m x n` size consisting of non-negative integers representing the amount of water stored in each cell. The rain water trapped between the cells is determined by the height of the surrounding cells. Write a function that returns the total amount of rain water trapped after a rainfall. You must consider only the cells that can actually trap water and account for the walls formed by cells with higher heights.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False for _ in range(n)] for _ in range(m)] min_heap = [] # Push the boundary cells to the min heap for i in range(m): heapq.heappush(min_heap, (heightMap[i][0], i, 0)) heapq.heappush(min_heap, (heightMap[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(1, n-1): heapq.heappush(min_heap, (heightMap[0][j], 0, j)) heapq.heappush(min_heap, (heightMap[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] water_trapped = 0 while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"You are given an **n-ary tree** where each node has between `0` and `n` children. Each node is represented as a `Node` object with the following properties: - `int val`: the value of the node. - `List<Node> children`: a list of `Node` objects representing the children of this node. You need to serialize the tree into a string and deserialize the string back into the tree. Design and implement the following methods: - `String serialize(Node root)`: Encodes the tree to a single string. The encoded string should be such that it can be used to recreate the original tree structure. - `Node deserialize(String data)`: Decodes the string back into the tree. The serialized and deserialized formats should be efficient and should handle all edge cases of the tree structure.","solution":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def serialize(root): Encodes an n-ary tree to a single string. if not root: return \\"#\\" serialized_str = [] def dfs(node): serialized_str.append(str(node.val)) for child in node.children: dfs(child) serialized_str.append(\\"#\\") # Indicates end of children dfs(root) return \\" \\".join(serialized_str) def deserialize(data): Decodes your encoded data to tree. if not data or data == \\"#\\": return None data_list = data.split() data_iter = iter(data_list) def dfs(): val = next(data_iter) if val == \\"#\\": return None node = Node(int(val)) children = [] while True: child = dfs() if child is None: break children.append(child) node.children = children return node return dfs()"},{"question":"You are given a sorted integer array `nums` that may contain duplicates, and a target value `target`. Write a function to determine the **first** and **last** position of `target` in `nums`. If `target` is not found in the array, return `[-1, -1]`. Your function should run in O(log n) time.","solution":"def search_range(nums, target): Finds the first and last position of target in sorted nums. def find_bound(nums, target, is_first): start, end = 0, len(nums) - 1 bound = -1 while start <= end: mid = (start + end) // 2 if nums[mid] == target: bound = mid if is_first: end = mid - 1 # Look on the left side else: start = mid + 1 # Look on the right side elif nums[mid] < target: start = mid + 1 else: end = mid - 1 return bound first_position = find_bound(nums, target, True) last_position = find_bound(nums, target, False) return [first_position, last_position] if first_position != -1 else [-1, -1]"},{"question":"Given a list of integers `nums`, and an integer `k`, return _the length of the shortest contiguous subarray whose sum is greater than or equal to `k`. If there is no such subarray, return `0`. Note: Your solution must achieve better than O(n^2) time complexity.","solution":"def shortest_subarray_with_sum_at_least_k(nums, k): from collections import deque n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = n + 1 dq = deque() for i in range(n + 1): while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k: result = min(result, i - dq.popleft()) while dq and prefix_sum[i] <= prefix_sum[dq[-1]]: dq.pop() dq.append(i) return result if result <= n else 0"},{"question":"You are given an `m x n` grid filled with non-negative integers representing the altitude of each unit cell in a continent. The ``Pacific`` ocean touches the left and top edges of the grid and the ``Atlantic`` ocean touches the right and bottom edges. Water can flow from a cell to its neighboring cells north, south, east, and west if the neighboring cell\'s altitude is less than or equal to the current cell\'s altitude. Find all cells where water can flow to both the ``Pacific`` and ``Atlantic`` oceans. The result should be returned as a list of grid coordinates (i, j). **Note:** The order of the result does not matter. Both `m` and `n` are less than 150.","solution":"def pacific_atlantic(heights): if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) def dfs(i, j, visited, prev_height): if (i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or heights[i][j] < prev_height): return visited.add((i, j)) for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)]: dfs(i + direction[0], j + direction[1], visited, heights[i][j]) pacific_reachable = set() atlantic_reachable = set() for r in range(m): dfs(r, 0, pacific_reachable, heights[r][0]) dfs(r, n - 1, atlantic_reachable, heights[r][n - 1]) for c in range(n): dfs(0, c, pacific_reachable, heights[0][c]) dfs(m - 1, c, atlantic_reachable, heights[m - 1][c]) return list(pacific_reachable & atlantic_reachable)"},{"question":"You are given a string `s` containing only lowercase English letters. A **palindrome** is a string that reads the same backward as forward. Write a function that returns the length of the longest palindromic substring in `s`. Your implementation should have a linearithmic or better time complexity. Ensure your function finds the longest substring efficiently, and consider edge cases where `s` has a length of 0 or 1.","solution":"def longest_palindromic_substring(s): Returns the length of the longest palindromic substring in the given string s. if not s: return 0 n = len(s) # Initialize the table to store intermediate results dp = [[False] * n for _ in range(n)] max_length = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 for k in range(3, n+1): for i in range(n - k + 1): j = i + k - 1 if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length"},{"question":"Given a string `s` and a string `t`, your task is to find the minimum window in `s` which contains all the characters from `t`. If such a window does not exist, return an empty string. If there are multiple minimal windows, return the one which starts first. Note that when the window contains all characters from `t`, that means the window has at least the same frequency of each character from `t` as it appears in `t`.","solution":"from collections import Counter, defaultdict def min_window(s, t): Returns the minimum window in s which contains all the characters from t. If such a window does not exist, returns an empty string. if not s or not t: return \\"\\" # Dictionary to count all characters in t dict_t = Counter(t) required = len(dict_t) # Left and Right pointer l, r = 0, 0 # Formed is used to keep track of how many unique characters in t # are present in the current window in their desired frequency formed = 0 # Dictionary to count all unique characters in the current window window_counts = defaultdict(int) # (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): # Add one character from the right to the window character = s[r] window_counts[character] += 1 # If the frequency of the current character added equals to the # desired count in t then increment the formed count by 1. if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try and contract the window till the point where it ceases to be \'desirable\'. while l <= r and formed == required: character = s[l] # Save the smallest window until now. if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the `left` pointer is no longer a part of the window. window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 # Move the left pointer ahead, this would help to look for a new window. l += 1 # Keep expanding the window once we are done contracting. r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1] : ans[2] + 1]"},{"question":"Given an array of integers `arr`, return a new array `result` where `result[i]` is the product of all the elements of `arr` except `arr[i]` without using division. You must solve it in O(n) time complexity and O(1) space complexity, except for the output array `result`. Example: Input: arr = [1, 2, 3, 4] Output: [24, 12, 8, 6] Explanation: - The product of all elements except the one at index 0 (1) is 2 * 3 * 4 = 24. - The product of all elements except the one at index 1 (2) is 1 * 3 * 4 = 12. - The product of all elements except the one at index 2 (3) is 1 * 2 * 4 = 8. - The product of all elements except the one at index 3 (4) is 1 * 2 * 3 = 6.","solution":"def product_except_self(arr): Returns a new array where result[i] is the product of all the elements of arr except arr[i]. Parameters: arr (list): List of integers. Returns: list: List of products. n = len(arr) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= arr[i] right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"You are given a linked list where each node contains an integer value. The list may have cycles, meaning that some nodes might link back to previous nodes forming a loop. Given the head of the linked list, return _the node where the cycle begins_. If there is no cycle, return `null`. Write an efficient algorithm with O(n) time complexity and O(1) space complexity.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detect the start of the cycle in a linked list. :type head: ListNode :rtype: ListNode or None if not head or not head.next: return None slow = head fast = head # Detect if there is a cycle using two pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, find the cycle start slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"You are tasked with designing a synchronous messaging application for a small group of users. The application uses an array of strings `messages`, where each string represents a message sent by one of the users. Each message is sent in chronological order. However, due to network delays, some messages might not be received by a user in the exact order they were sent. Your goal is to create a function that takes the array `messages` and rearranges them in the correct chronological order. Each message string is prefixed with a timestamp in the format `[HH:MM:SS]` where `HH` is hours, `MM` is minutes, and `SS` is seconds. Write a function that: 1. Takes an array of strings `messages` as input. 2. Returns the array of messages sorted in ascending order based on their timestamps. For instance, given the following input: ```python messages = [\\"[12:34:56] Hello\\", \\"[12:34:55] Hi\\", \\"[12:35:00] What\'s up?\\", \\"[12:34:57] How are you?\\"] ``` The function should return: ```python [\\"[12:34:55] Hi\\", \\"[12:34:56] Hello\\", \\"[12:34:57] How are you?\\", \\"[12:35:00] What\'s up?\\"] ```","solution":"def sort_messages(messages): Sorts an array of messages based on their timestamps. Parameters: messages (list of str): Array of message strings prefixed with timestamps in the format [HH:MM:SS]. Returns: list of str: Sorted array of messages in ascending order of their timestamps. # Extract timestamp from each message, sort based on it, and return the sorted list of messages. return sorted(messages, key=lambda message: message[1:9])"},{"question":"You are given a list of non-negative integers `nums` that represent the possible stock prices of a company. Each value in `nums` corresponds to a specific time period, with `nums[i]` representing the stock price at time `i`. Determine the maximum possible profit that can be achieved by performing at most two transactions. Note that a transaction consists of buying and then selling one stock. You cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). If it is not possible to achieve any profit, return `0`.","solution":"def max_profit_with_two_transactions(prices): Returns the maximum possible profit with at most two transactions. if not prices: return 0 n = len(prices) # First array contains the max profit until the ith day with at most one transaction left_max_profit = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_max_profit[i] = max(left_max_profit[i - 1], prices[i] - min_price) # Second array contains the max profit from the ith day to the end with at most one transaction right_max_profit = [0] * n max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) right_max_profit[i] = max(right_max_profit[i + 1], max_price - prices[i]) # The maximum sum of left_max_profit and right_max_profit at each day max_profit = 0 for i in range(n): max_profit = max(max_profit, left_max_profit[i] + right_max_profit[i]) return max_profit"},{"question":"A company has a fleet of delivery drones. Each drone can carry a maximum weight. You are provided with an array of integers `packages` where each element represents the weight of a package and an integer `maxWeight`, which is the maximum weight a drone can carry. Your task is to determine the **minimum number of drones** required to deliver all the packages. Each drone can carry multiple packages as long as the total weight does not exceed `maxWeight`. Return the minimum number of drones needed to deliver all the packages. Example: ``` Input: packages = [5, 3, 7, 2, 4, 6], maxWeight = 10 Output: 3 Explanation: The minimum number of drones required can be achieved by the following combinations: - Drone 1: [5, 3, 2] (total weight 10) - Drone 2: [7] (total weight 7) - Drone 3: [4, 6] (total weight 10) ```","solution":"def min_drones(packages, maxWeight): Returns the minimum number of drones required to deliver all the packages with the given max weight constraint. packages.sort(reverse=True) # Sort packages in descending order num_drones = 0 while packages: current_weight = 0 i = 0 while i < len(packages): if current_weight + packages[i] <= maxWeight: current_weight += packages.pop(i) else: i += 1 num_drones += 1 return num_drones"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. A linked list is defined as: ``` struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; ``` Implement the function: ``` ListNode* rotateRight(ListNode* head, int k) ``` that accepts the head of the linked list and the integer `k` and returns the head of the modified list after rotating it `k` places to the right. Note: The rotation should be done in-place without modifying the node values. Manipulate the node references to achieve the desired result.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Compute the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Make the list circular tail.next = head # Find the new head after rotation k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are given a binary tree where each node has a value of `0` or `1`. Each root-to-leaf path represents a binary number starting from the most significant bit. You need to calculate the sum of all the binary numbers represented by the root-to-leaf paths. Return the sum **modulo 10^9 + 7**. A node is a leaf if it has no children. Example: ``` Input: [1,0,1,0,1,0,1] Output: 22 ``` Explanation: ``` The binary numbers represented by the paths are 100, 101, and 110. In decimal, these are 4, 5, and 6 respectively. Adding them together gives 4 + 5 + 6 = 15. ``` So, the output would be 15 % (10^9 + 7) = 22.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: MOD = 10**9 + 7 def dfs(node, current_sum): if not node: return 0 current_sum = (current_sum * 2 + node.val) % MOD if not node.left and not node.right: return current_sum left_sum = dfs(node.left, current_sum) right_sum = dfs(node.right, current_sum) return (left_sum + right_sum) % MOD return dfs(root, 0)"},{"question":"You are given a **0-indexed** string `s`, where each character is either `a` or `b`. Your task is to transform `s` into a palindrome with the minimum number of character replacements. Return _the **minimum** number of replacements needed to make `s` a palindrome._ A **palindrome** is a string that is the same forward and backward.","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of replacements needed to make s a palindrome. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"You are given a string `text` consisting of lowercase English letters and an integer `k`. Your task is to find and return the **length of the longest substring** of `text` that contains at most `k` distinct characters. A **substring** is a contiguous sequence of characters within a string. Implement a function `longestSubstringWithKDistinct(text, k)` that returns an integer representing the length of this longest substring.","solution":"def longestSubstringWithKDistinct(text, k): Returns the length of the longest substring of `text` that contains at most `k` distinct characters. if k == 0: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(text)): char = text[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > k: left_char = text[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a singly linked list, where each node contains an integer value. Write a function `reverseBetween` which reverses the nodes of the list from position `m` to `n`. Do it in one-pass and in-place. Given the head of a singly linked list and two integers `m` and `n`, return the head of the modified list after reversing the nodes between `m` and `n`. **Note:** 1. The positions `m` and `n` are 1-based. 2. You may assume that `1 ≤ m ≤ n ≤ length of the list`.","solution":"class ListNode: def __init__(self, val: int = 0, next=None): self.val = val self.next = next def reverseBetween(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head dummy = ListNode(0) dummy.next = head pre = dummy for _ in range(m - 1): pre = pre.next current = pre.next next = current.next for _ in range(n - m): current.next = next.next next.next = pre.next pre.next = next next = current.next return dummy.next"},{"question":"Given a linked list, split it into `k` consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null if `k` is greater than the length of the list. Return an array of the `k` parts. Examples: 1. Given linked list: 1->2->3, and k = 5, output: [1, 2, 3, null, null] 2. Given linked list: 1->2->3->4, and k = 3, output: [1->2, 3, 4] Implement the `splitListToParts` function to divide the list into `k` parts.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def splitListToParts(head, k): # Count the total number of nodes in the list total_length = 0 current = head while current: total_length += 1 current = current.next # Determine the size of each part and the remainder part_size = total_length // k remainder = total_length % k result = [] current = head for i in range(k): part_head = current prev = None # Determine the number of elements in this part current_part_size = part_size + (1 if i < remainder else 0) for j in range(current_part_size): prev = current if current: current = current.next if prev: prev.next = None result.append(part_head) return result"},{"question":"You are given an unsorted integer array `arr` of length `n` and an integer `k`. Find the `k`th largest element in the array. Note that it is the `k`th largest element in the sorted order, not the `k`th distinct element. Your task is to complete the function `findKthLargest` that takes the integer array `arr` and integer `k` as inputs and returns the `k`th largest element in the array.","solution":"def findKthLargest(arr, k): Finds the k-th largest element in an unsorted integer array. Parameters: arr (list of int): The array of integers. k (int): The k-th position to find the largest element. Returns: int: The k-th largest element in the array. arr.sort(reverse=True) return arr[k-1]"},{"question":"You are given an array of integers `arr` and an integer `k`. The task is to find the smallest window (contiguous subarray) in the array `arr` such that the sum of the elements in this window is greater than or equal to `k`. If there is no such window, return -1. Implement a function that returns the length of the smallest window that meets the condition.","solution":"def smallest_window_with_given_sum(arr, k): Finds the length of the smallest window in arr such that the sum of the elements in this window is greater than or equal to k. Parameters: arr (list of int): The input array of integers. k (int): The target sum. Returns: int: The length of the smallest window with sum >= k. If not found, returns -1. n = len(arr) min_length = float(\'inf\') window_sum, start = 0, 0 for end in range(n): window_sum += arr[end] while window_sum >= k: min_length = min(min_length, end - start + 1) window_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a list of airline tickets represented by pairs of departure and arrival airports `[from, to]`. Reconstruct the itinerary in order using the given list of tickets. All of the tickets belong to a man who departs from `\\"JFK\\"`. Thus, the itinerary must begin with `\\"JFK\\"`, and it is guaranteed that there is a valid itinerary that uses all the tickets exactly once. Your task is to return the reconstruction of the itinerary list. **Note:** If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single sequence.","solution":"from collections import defaultdict import heapq def find_itinerary(tickets): Reconstructs the itinerary in order using the given list of tickets. Parameters: tickets (List[List[str]]): A list of airline tickets represented by pairs of departure and arrival airports [from, to]. Returns: List[str]: The reconstructed itinerary. itinerary = [] graph = defaultdict(list) for frm, to in tickets: heapq.heappush(graph[frm], to) def visit(airport): while graph[airport]: visit(heapq.heappop(graph[airport])) itinerary.append(airport) visit(\'JFK\') return itinerary[::-1]"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n-1`, and a list of edges where `edges[i] = [fromi, toi]` representing a directed edge from `fromi` to `toi`, return _a boolean indicating whether the graph contains a valid topological ordering_. A topological ordering is valid if and only if node `u` appears before node `v` if there is a directed edge from `u` to `v`.","solution":"from collections import deque, defaultdict def has_valid_topological_order(n, edges): Determines if the directed acyclic graph represented by the given edges can have a valid topological ordering. Args: n (int): Number of nodes in the graph. edges (list of list of int): List of edges in the graph where each edge is represented as a list [fromi, toi]. Returns: bool: True if there exists a valid topological ordering, False otherwise. # Create adjacency list and in-degree array graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Initialize the queue with nodes having zero in-degree queue = deque([i for i in range(n) if in_degree[i] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all nodes were visited, then the graph has a valid topological ordering return visited == n"},{"question":"You are given a list of strings `words` where each string consists of lowercase English letters. Two strings `s1` and `s2` are said to be **similar** if: * They are of the same length. * For every letter at position `i` in `s1`, the letter at position `i` in `s2` is either the same or belongs to the same equivalent group. An **equivalent group** is defined by a 2D character array `equiv` where `equiv[i] = [a, b]` denotes that characters `a` and `b` are equivalent. A character can be equivalent to itself. Return _the number of distinct equivalence classes within the list of `words`_ For clarification, two strings belong to the same equivalence class if they are similar according to the given equivalence groups.","solution":"from collections import defaultdict def find_representative(graph, char): # Find the representative parent of the character if graph[char] != char: graph[char] = find_representative(graph, graph[char]) return graph[char] def union(graph, a, b): # Union the sets based on two characters a and b rep_a = find_representative(graph, a) rep_b = find_representative(graph, b) if rep_a != rep_b: graph[rep_b] = rep_a # union the sets def num_similar_groups(words, equiv): # Create a union-find structure to manage equivalence groups graph = {} for word in words: for char in word: graph[char] = char # initially every character is its own parent for a, b in equiv: union(graph, a, b) # union the characters in the same group # Using set for equivalence classes of each word equiv_classes = set() for word in words: # Find the representative for each character in the word rep_word = \'\'.join(sorted(find_representative(graph, char) for char in word)) equiv_classes.add(rep_word) return len(equiv_classes)"},{"question":"Given an array of integers `nums` sorted in non-decreasing order, and an integer `target`, find the two distinct indices `i` and `j` (0-indexed) such that `nums[i] + nums[j]` equals `target`. Return the indices as a tuple `(i, j)` where `i < j`. If no such indices exist, return `(-1, -1)`. Your solution should have a time complexity of O(n) and use constant extra space.","solution":"def two_sum_sorted(nums, target): Finds two distinct indices such that nums[i] + nums[j] == target. :param nums: List of integers sorted in non-decreasing order :param target: Integer target sum :return: Tuple of indices (i, j) or (-1, -1) if no such indices exist left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return left, right elif current_sum < target: left += 1 else: right -= 1 return -1, -1"},{"question":"Given a list of integers `nums`, find the maximum length of a contiguous subarray where the absolute difference between any two elements in this subarray is less than or equal to `k`. Write a function `maxLengthSubarray(nums: List[int], k: int) -> int` that takes in the list `nums` and the integer `k`, and returns the maximum length of such a subarray.","solution":"from typing import List def maxLengthSubarray(nums: List[int], k: int) -> int: Finds the maximum length of a contiguous subarray where the absolute difference between any two elements is less than or equal to k. if not nums: return 0 n = len(nums) max_len = 1 left = 0 for right in range(1, n): while left < right and max(nums[left:right+1]) - min(nums[left:right+1]) > k: left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets. You may return the triplets in any order. The function signature should be: ```python def three_sum(nums: List[int]) -> List[List[int]]: ```","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. nums.sort() # Sort the array triplets = [] length = len(nums) for i in range(length - 2): # Skip the duplicates for the first number if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, length - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: triplets.append([nums[i], nums[left], nums[right]]) # Skip duplicates for the second and third number while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return triplets"},{"question":"Given two integers `n` and `m`, and an array `edges` where `edges[i] = [a, b]` represents an undirected edge between nodes `a` and `b`, determine if it\'s possible to color the nodes of the graph with two colors such that no two adjacent nodes share the same color. Return `true` if it is possible, otherwise `false`.","solution":"def is_bipartite(n, edges): Determines if the graph represented by n nodes and edges is bipartite. from collections import deque # Create adjacency list adj_list = {i: [] for i in range(n)} for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) # Array to store colors, None means uncolored color = [None] * n def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with color 0 while queue: node = queue.popleft() current_color = color[node] for neighbour in adj_list[node]: if color[neighbour] is None: # Assign alternate color color[neighbour] = 1 - current_color queue.append(neighbour) elif color[neighbour] == current_color: # Neighbor has the same color, not bipartite return False return True # Check each component of the graph for node in range(n): if color[node] is None: if not bfs(node): return False return True"},{"question":"You are given a string `s` consisting of only digits. You can swap two adjacent characters in the string at most once. Return the maximum number of unique substrings of length `k` that can be obtained by performing at most one swap. If it\'s not possible to obtain any unique substrings of length `k`, return 0.","solution":"def max_unique_substrings_after_one_swap(s, k): Returns the maximum number of unique substrings of length k that can be obtained by performing at most one swap of adjacent characters in the string s. If it\'s not possible to obtain any unique substrings of length k, returns 0. if k > len(s): return 0 def unique_substrings(string, length): substrings = set() for i in range(len(string) - length + 1): substrings.add(string[i:i+length]) return substrings original_unique_substrings = unique_substrings(s, k) max_unique_counts = len(original_unique_substrings) for i in range(len(s) - 1): # Swap adjacent characters swapped_string = list(s) swapped_string[i], swapped_string[i + 1] = swapped_string[i + 1], swapped_string[i] swapped_string = \\"\\".join(swapped_string) swapped_unique_count = len(unique_substrings(swapped_string, k)) max_unique_counts = max(max_unique_counts, swapped_unique_count) return max_unique_counts"},{"question":"You are given a list of strings `words` and a string `s`. We define a **palindrome pair** to be a pair of indices `(i, j)` such that the concatenation of `words[i]` and `words[j]` forms a palindrome. For example, if `words = [\\"bat\\", \\"tab\\", \\"cat\\"]` and `s = \\"battab\\"`, the valid palindrome pairs are `(0, 1)` and `(1, 0)` because \\"battab\\" is a palindrome. Return the number of distinct **palindrome pairs**. A string is a **palindrome** if it reads the same forward and backward.","solution":"def is_palindrome(word): Helper function to check if a word is a palindrome. return word == word[::-1] def palindrome_pairs(words): Returns the number of distinct palindrome pairs in the list of words. count = 0 for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): count += 1 return count"},{"question":"Given an array of integers `arr`, you need to return a new array `answer` such that `answer[i]` is equal to the product of all the elements of `arr` except `arr[i]`. You must solve it without using division and in `O(n)` time and space complexity.","solution":"def product_except_self(arr): Returns an array such that the element at index i is the product of all elements in arr except arr[i]. Args: arr (list of int): The input array. Returns: list of int: The resultant array with products. n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Fill left_products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right_products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate the final products array result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"You are given a list of strings `words` where each word consists of lowercase English letters. Your task is to find the longest string in `words` that can be constructed by concatenating other strings from the list. If there are multiple possible results, return the lexicographically smallest one. Each word in the list can be used multiple times. For example, given the list `[\\"cat\\", \\"banana\\", \\"dog\\", \\"nana\\", \\"walk\\", \\"walker\\", \\"dogwalker\\"]`, the answer would be \\"dogwalker\\" as it can be formed by concatenating \\"dog\\" and \\"walker\\".","solution":"def can_construct(word, word_set): if word in word_set: return True for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and can_construct(suffix, word_set): return True return False def find_longest_concatenated_word(words): word_set = set(words) words.sort(key=lambda x: (-len(x), x)) for word in words: word_set.remove(word) if can_construct(word, word_set): return word word_set.add(word) return \\"\\" # Example use case words = [\\"cat\\", \\"banana\\", \\"dog\\", \\"nana\\", \\"walk\\", \\"walker\\", \\"dogwalker\\"] print(find_longest_concatenated_word(words)) # Output: \\"dogwalker\\""},{"question":"You are given a 2D grid of integers where each entry represents the altitude of a cell. You can move up, down, left, or right from a cell, but you can only move to another cell if the altitude difference between the current cell and the next cell is at most 1. Your task is to determine if there is a path from the top-left cell to the bottom-right cell. Return `true` if such a path exists, and `false` otherwise.","solution":"def is_path_possible(grid): Determines if there is a path from the top-left to the bottom-right of a grid. Movement is only allowed if the altitude difference between adjacent cells is at most 1. Parameters: grid (list of list of int): 2D grid representing altitudes. Returns: bool: True if a path exists, False otherwise. from collections import deque if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) def is_valid(x, y, nx, ny): return 0 <= nx < rows and 0 <= ny < cols and abs(grid[nx][ny] - grid[x][y]) <= 1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = set() queue = deque([(0, 0)]) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(x, y, nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"You are given a **0-indexed** array of integers `heights` where `heights[i]` represents the height of the `i-th` tree. You can perform operations to increase the height of the trees. An operation consists of choosing an index `i` in `heights` and increasing the height of the tree at that index by `1`. Return _the **minimum** number of operations needed to make_ `heights` _**non-decreasing**_, where `heights[i] <= heights[i+1]` for all `0 <= i < heights.length - 1`.","solution":"def min_operations_to_non_decreasing(heights): Returns the minimum number of operations needed to make the array `heights` non-decreasing. operations = 0 for i in range(1, len(heights)): if heights[i] < heights[i - 1]: operations += (heights[i - 1] - heights[i]) heights[i] = heights[i - 1] return operations"},{"question":"Given a binary tree, determine if it is a valid **binary search tree (BST)**. A **binary search tree** is defined as follows: - The left subtree of a node contains only nodes with keys **less than** the node\'s key. - The right subtree of a node contains only nodes with keys **greater than** the node\'s key. - Both the left and right subtrees must also be binary search trees. You are given the `TreeNode` class with the following definition: class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } Return _true_ if the given tree is a valid BST, otherwise return _false_.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_valid_bst(root, low=float(\'-inf\'), high=float(\'inf\')): # An empty tree is a valid BST if not root: return True # The current node must be in the range (low, high) if root.val <= low or root.val >= high: return False # Recursively check the subtrees with updated ranges return is_valid_bst(root.left, low, root.val) and is_valid_bst(root.right, root.val, high)"},{"question":"Write a function that takes an array of integers `nums` and an integer `k`, and returns an array of the `k` most frequent elements. The result should be sorted by frequency from highest to lowest. If there are multiple elements with the same frequency, sort them by their value in ascending order. Ensure the solution is efficient for large inputs.","solution":"import heapq from collections import Counter def top_k_frequent(nums, k): Returns the k most frequent elements from the array `nums`. The result is sorted by frequency from highest to smallest and by value in case of tie. if not nums or k <= 0: return [] # Count the frequency of each element count = Counter(nums) # Use a heap to find the k most frequent elements # Push to heap with frequency as negative for max heap behaviour heap = [(-freq, num) for num, freq in count.items()] heapq.heapify(heap) result = [] for _ in range(k): result.append(heapq.heappop(heap)[1]) return result"},{"question":"Given an integer array `nums`, you are allowed to add any of its elements to other elements in the same array, but each element can only be added at most once. Your task is to determine if it is possible to make all the elements in the array equal by using the allowed operations. Return `true` if it is possible, otherwise return `false`. For example: - If `nums = [1, 2, 3]`, return `true` (because we can add 1 to 2 to make both 3, then add 1 to the remaining 1 to make all 3). - If `nums = [1, 2, 4]`, return `false` (because it is impossible to make all elements equal). You are given the integer array `nums` of length `n`.","solution":"def can_all_elements_be_equal(nums): Determines if it is possible to make all elements in the array equal by adding any of its elements to other elements in the same array. Each element can only be added to other elements at most once. Parameters: nums (list of int): The input array Returns: bool: True if it is possible to make all elements equal, otherwise False total = sum(nums) n = len(nums) # If the sum of all elements is divisible by the length of the array, return True # Otherwise, return False return total % n == 0"},{"question":"You are given an array `heights` representing the heights of a collection of buildings, each corresponding to the width of `1 unit` on a 2D skyline perspective. The goal is to calculate the **maximum area** of a rectangle formed by one or more adjacent buildings in the array. The function should return the largest rectangular area possible. *Note: The rectangle’s width must be contiguous, and every building within that rectangle must be included in the area calculation.*","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed with contiguous buildings in the skyline. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at the top of the stack, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from the stack and calculate the area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a `0-indexed` integer array `arr` and an integer `val`. You are allowed to perform the following operation multiple times: choose an index `i` such that `0 <= i < arr.length` and subtract `val` from `arr[i]` if `arr[i]` is greater than or equal to `val`. Return _the **minimum** number of operations_ required to make all the elements in the array less than `val`.","solution":"def min_operations(arr, val): Return the minimum number of operations required to make all elements in the array less than `val`. An operation consists of choosing an index `i` such that 0 <= i < arr.length and subtracting `val` from `arr[i]` if `arr[i]` is greater than or equal to `val`. Parameters: arr (list): A list of integers. val (int): A single integer value. Returns: int: The minimum number of required operations. operations = 0 for num in arr: if num >= val: operations += num // val return operations"},{"question":"You are given a list of `n` integers representing the heights of buildings in a city skyline. The sun rises from the left (index 0) and sets to the right (index `n-1`). A building can block the view of a shorter building to its right. Design a program to determine the number of buildings that will have an unobstructed view of the sunrise. A building has an unobstructed view if no taller building is to its left. Return the number of buildings with an unobstructed view of the sunrise.","solution":"def count_unobstructed_views(buildings): Returns the number of buildings that have an unobstructed view of the sunrise. A building has an unobstructed view if no taller building is to its left. :param buildings: List of integers representing the heights of buildings :return: Integer representing the number of buildings having an unobstructed view if not buildings: return 0 unobstructed_count = 1 max_height = buildings[0] for height in buildings[1:]: if height > max_height: unobstructed_count += 1 max_height = height return unobstructed_count"},{"question":"You are given an integer array `heights` representing the height of buildings. The buildings are consecutively placed next to each other with each building occupying `1` unit of width. There is a requirement to arrange banners of unit width on the rooftops of some buildings. The constraint is that no two banners can be placed on rooftops of two consecutive buildings. Return the maximum number of banners that can be placed under these conditions.","solution":"def max_banners(heights): Returns the maximum number of banners that can be placed on the rooftops of buildings such that no two banners are placed consecutively. n = len(heights) if n == 0: return 0 # Initialize dp array where dp[i] represents the maximum number of banners up to the i-th building dp = [0] * (n + 1) # Base cases dp[0] = 0 # No buildings, no banners dp[1] = 1 # One building can have one banner for i in range(2, n + 1): dp[i] = max(dp[i-1], dp[i-2] + 1) return dp[n]"},{"question":"You are given a string `text` consisting of lowercase English letters and a string `pattern` also consisting of lowercase English letters. Your task is to find the length of the shortest substring in `text` that contains all the characters in `pattern` (including duplicates). If no such substring exists, return `-1`. Note that the order of characters in `pattern` does not matter, they just need to be present in any order.","solution":"from collections import Counter def min_window_substring(text, pattern): Returns the length of the shortest substring in text that contains all characters in pattern. If no such substring exists, returns -1. if not pattern or not text or len(pattern) > len(text): return -1 pattern_count = Counter(pattern) required = len(pattern_count) left, right = 0, 0 formed = 0 window_counts = {} min_len = float(\'inf\') min_len_window = (-1, -1) while right < len(text): char = text[right] window_counts[char] = window_counts.get(char, 0) + 1 if char in pattern_count and window_counts[char] == pattern_count[char]: formed += 1 while left <= right and formed == required: char = text[left] if right - left + 1 < min_len: min_len = right - left + 1 min_len_window = (left, right) window_counts[char] -= 1 if char in pattern_count and window_counts[char] < pattern_count[char]: formed -= 1 left += 1 right += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"Given a string `log` consisting of characters \'U\' (uphill), \'D\' (downhill), and \'_\' (flat terrain), representing a path in a mountain hiking trail. Determine the number of valleys encountered during the hike. A valley is defined as any sequence of consecutive steps below sea level, starting with a downhill step that moves you from sea level and ending with an uphill step that moves you back to sea level. Return the total number of valleys in the hiking trail. Note: - Sea level is represented by 0 height. - Each \'U\' increases the height by 1. - Each \'D\' decreases the height by 1. - Each \'_\' maintains the current height.","solution":"def count_valleys(log): Counts the number of valleys in the given hiking trail log. A valley is defined as any sequence of consecutive steps below sea level, starting with a downhill step and ending with an uphill step. Parameters: log (str): A string consisting of \'U\' (uphill), \'D\' (downhill), and \'_\' (flat terrain). Returns: int: The number of valleys encountered during the hike. sea_level = 0 current_level = 0 valleys_count = 0 in_valley = False for step in log: if step == \'U\': current_level += 1 elif step == \'D\': current_level -= 1 if current_level < sea_level: in_valley = True if in_valley and current_level == sea_level: valleys_count += 1 in_valley = False return valleys_count"},{"question":"Given two sorted arrays `nums1` and `nums2` of size `m` and `n`, respectively, return the median of the two sorted arrays. The overall run-time complexity should be `O(log (m+n))`. You may assume `nums1` and `nums2` cannot be both empty. Implement a function: ```python def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: # your code here ``` Your function should return a float representing the median of the two sorted arrays.","solution":"def findMedianSortedArrays(nums1, nums2): Finds the median of two sorted arrays. def find_kth(nums1, s1, nums2, s2, k): if s1 >= len(nums1): return nums2[s2 + k - 1] if s2 >= len(nums2): return nums1[s1 + k - 1] if k == 1: return min(nums1[s1], nums2[s2]) mid1 = float(\'inf\') if s1 + k // 2 - 1 >= len(nums1) else nums1[s1 + k // 2 - 1] mid2 = float(\'inf\') if s2 + k // 2 - 1 >= len(nums2) else nums2[s2 + k // 2 - 1] if mid1 < mid2: return find_kth(nums1, s1 + k // 2, nums2, s2, k - k // 2) else: return find_kth(nums1, s1, nums2, s2 + k // 2, k - k // 2) m, n = len(nums1), len(nums2) total_len = m + n if total_len % 2 == 1: return find_kth(nums1, 0, nums2, 0, total_len // 2 + 1) else: return (find_kth(nums1, 0, nums2, 0, total_len // 2) + find_kth(nums1, 0, nums2, 0, total_len // 2 + 1)) / 2.0"},{"question":"You are given an m x n binary matrix \'grid\'. An island is a group of connected `1`s (connected horizontally or vertically). The grid is completely surrounded by `0`s, and there is exactly one island in the grid. The island does not have any \\"lakes\\", meaning the `1`s inside the island are not surrounded by `0`s. Write an algorithm to find the perimeter of the island. The function signature is: ```python def islandPerimeter(grid: List[List[int]]) -> int: ```","solution":"from typing import List def islandPerimeter(grid: List[List[int]]) -> int: rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Check top if r == 0 or grid[r-1][c] == 0: perimeter += 1 # Check bottom if r == rows-1 or grid[r+1][c] == 0: perimeter += 1 # Check left if c == 0 or grid[r][c-1] == 0: perimeter += 1 # Check right if c == cols-1 or grid[r][c+1] == 0: perimeter += 1 return perimeter"},{"question":"You are given an array `arr` of integers where each element appears exactly twice, except for one element which appears exactly once. Return the element that appears only once. You must solve the problem in linear time and without using extra space that grows with the input size.","solution":"def single_number(arr): Returns the element that appears only once in the array where every other element appears exactly twice. :param arr: List[int] - Array of integers :return: int - The integer that appears only once unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"You are given an array of integers `nums` and an integer `k`. A **subarray** is a contiguous part of an array. A subarray is called **good** if there are **at least** `k` different integers in the subarray. Return the number of **good** subarrays of `nums`. Since the number of subarrays may be too large, return it **modulo** `109 + 7`.","solution":"def countGoodSubarrays(nums, k): from collections import defaultdict n = len(nums) MOD = 10**9 + 7 def atLeastKUnique(k): count = defaultdict(int) unique = 0 total = 0 left = 0 for right in range(n): if count[nums[right]] == 0: unique += 1 count[nums[right]] += 1 while unique >= k: total += n - right count[nums[left]] -= 1 if count[nums[left]] == 0: unique -= 1 left += 1 return total return atLeastKUnique(k) % MOD"},{"question":"Given an `n x n` 2D matrix `a` containing integers, rotate the matrix 90 degrees clockwise in place. This means you need to modify the input matrix within the same memory, without using a separate 2D matrix for the rotation. You can achieve this by first transposing the matrix, and then reversing each row. Return the modified matrix after rotation.","solution":"def rotate_90_degrees_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): The n x n 2D matrix to rotate. Returns: List[List[int]]: The modified matrix after rotation. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given a string representing an arithmetic expression that contains non-negative integers, addition `\'+\'`, subtraction `\'-\'`, multiplication `\'*\'`, and division `\'/\'`, implement a function to compute the result. Note that: * Division is integer division, where the result is the quotient and the remainder is discarded. * The expression is guaranteed to be valid and follows standard precedence rules: parentheses first, then multiplication and division, and finally addition and subtraction. Return the result as a single integer. Example: - For the expression \\"3 + 2 * 2\\", the output should be `7`. - For the expression \\" 3 / 2 \\", the output should be `1`. - For the expression \\" 3 + 5 / 2 \\", the output should be `5`.","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression that contains non-negative integers, addition, subtraction, multiplication, and division (integer division). def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left // right) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"You are given a list of `courses` as `course_list` where each course is a pair of two integers `[a, b]` representing a course `a` that you want to take and a prerequisite course `b` that you must take before `a`. Given a total of `num_courses` courses, define whether it is possible to finish all courses. Return `true` if it is possible to finish all courses, otherwise return `false`.","solution":"from collections import defaultdict, deque def can_finish(num_courses, course_list): Determine if it\'s possible to finish all courses given the prerequisites. :param num_courses: Total number of courses :param course_list: List of pairs [a, b] where b is a prerequisite for a :return: True if it\'s possible to finish all courses, otherwise False # Create an adjacency list for the directed graph adjacency_list = defaultdict(list) # Create an array to track the in-degrees of nodes (courses) in_degrees = [0] * num_courses # Fill the adjacency list and the in-degrees array for dest, src in course_list: adjacency_list[src].append(dest) in_degrees[dest] += 1 # Use a queue to perform a topological sort queue = deque() # Add all nodes with in-degree 0 to the queue for i in range(num_courses): if in_degrees[i] == 0: queue.append(i) # Count of nodes processed count = 0 while queue: node = queue.popleft() count += 1 # Reduce the in-degree of the adjacent nodes for neighbor in adjacency_list[node]: in_degrees[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degrees[neighbor] == 0: queue.append(neighbor) # If count of processed nodes equals the total number of courses, # it means we can finish all courses return count == num_courses"},{"question":"You have a string `s` and an array `distance` of length 26 where `distance[i]` represents the minimum distance between the two occurrences of the `i-th` letter of the alphabet in the string `s`. A string is called valid if for every letter in the string, the given distance is maintained or the letter appears only once. Return `true` if the string is valid and `false` otherwise. The string `s` only contains lowercase English letters.","solution":"def checkDistances(s, distance): Returns True if the string `s` is valid according to the `distance` array, else returns False. # Dictionary to keep track of the first position of each character. char_positions = {} for i, char in enumerate(s): if char in char_positions: # Calculate the distance between the two occurrences expected_distance = distance[ord(char) - ord(\'a\')] actual_distance = i - char_positions[char] - 1 if actual_distance != expected_distance: return False else: char_positions[char] = i return True"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line, where `heights[i]` is the height of the `i-th` student. A group photo can be taken if and only if the students can be reordered such that every student is either strictly taller or strictly shorter than the student to their left and to their right. Return _true_ if it is possible to take such a group photo, and _false_ otherwise.","solution":"def can_take_group_photo(heights): Determine if the students can be reordered to take a group photo such that every student is either strictly taller or strictly shorter than the student to their left and to their right. if len(heights) < 2: return True # A single student or an empty list can always form a valid photo # Sort the list to see if it can be arranged in an alternating up-down pattern heights.sort() for i in range(1, len(heights)): if heights[i] == heights[i - 1]: return False return True"},{"question":"You are given an array of integers `nums` representing a permutation of the numbers from 1 to `n`. You need to reconstruct and return the lexicographically smallest permutation of the numbers from 1 to `n` that a given array `nums` can be rearranged into by swapping two adjacent elements at most once.","solution":"def smallest_permutation(nums): Returns the lexicographically smallest permutation of the numbers from 1 to n by swapping two adjacent elements at most once. n = len(nums) if n <= 1: return nums for i in range(n - 1): if nums[i] > nums[i + 1]: # Swap nums[i] and nums[i+1] nums[i], nums[i + 1] = nums[i + 1], nums[i] break return nums"},{"question":"Given an array of non-negative integers `nums`, you are allowed to modify at most one element of the array to any value. Return _true_ if you can make the array non-decreasing by modifying at most one element, otherwise return _false_. An array is considered non-decreasing if `nums[i] <= nums[i+1]` holds for every `i` (0 <= i < nums.length - 1).","solution":"def check_possibility(nums): Returns true if the array nums can be made non-decreasing by modifying at most one element, otherwise returns false. n = len(nums) count = 0 for i in range(n - 1): if nums[i] > nums[i + 1]: count += 1 if count > 1: return False if i - 1 >= 0 and nums[i - 1] > nums[i + 1]: nums[i + 1] = nums[i] # Modify nums[i+1] to nums[i] else: nums[i] = nums[i + 1] # Modify nums[i] to nums[i+1] return True"},{"question":"Given a string `s` and an integer `k`, you need to create `k` non-empty substrings such that they are non-overlapping and the sum of their lengths is `k`. Return _the **number of distinct ways** to split the string into_ `k` _substrings_.","solution":"from math import comb def ways_to_split(s, k): Returns the number of distinct ways to split the string s into k non-overlapping substrings. n = len(s) if k == 0 or k > n: return 0 return comb(n - 1, k - 1)"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on a 2D plane. You need to find the pair of points that are the farthest from each other based on Euclidean distance. Return the coordinates of these two points. If multiple pairs of points have the same maximum distance, return any one of these pairs.","solution":"from itertools import combinations from math import sqrt def euclidean_distance(point1, point2): return sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2) def farthest_points(points): max_distance = -1 result_pair = () for point1, point2 in combinations(points, 2): distance = euclidean_distance(point1, point2) if distance > max_distance: max_distance = distance result_pair = (point1, point2) return result_pair"},{"question":"You are given a list of `logs`, where each log is a space-separated string representing an event at a company. An event can be of two types: \\"sign-in\\" or \\"sign-out\\". Each log is formatted as \\"<action> <user_id> <timestamp>\\". A user must sign-in before signing out. For example, one valid log might be \\"sign-in u1 10\\", and a corresponding valid log might be \\"sign-out u1 20\\". There can be multiple users and each user can have multiple sign-in/sign-out pairs. Determine the longest continuous duration for which any user was signed-in. If two or more users have the same longest duration, return the one that signed-in first. Return the `user_id` along with the duration in the format (user_id, duration).","solution":"def longest_sign_in_duration(logs): Determine the longest continuous duration for which any user was signed-in. :param logs: List of log strings with format \\"<action> <user_id> <timestamp>\\" :return: Tuple (user_id, duration) sign_in_time = {} durations = {} for log in logs: action, user_id, timestamp = log.split() timestamp = int(timestamp) if action == \\"sign-in\\": sign_in_time[user_id] = timestamp elif action == \\"sign-out\\" and user_id in sign_in_time: duration = timestamp - sign_in_time[user_id] if user_id in durations: durations[user_id] = max(durations[user_id], duration) else: durations[user_id] = duration del sign_in_time[user_id] max_duration = -1 result_user = None for user_id in durations: if durations[user_id] > max_duration: max_duration = durations[user_id] result_user = user_id return (result_user, max_duration)"},{"question":"You are given a list of `n` strings `words` where each string consists of lowercase alphabetical characters. You are also given a string `pattern` that you need to search for within the list. A word in `words` matches the pattern if swapping certain characters in the word can make it equal to the pattern without changing the relative order of any characters. Return a list of all words that match the pattern.","solution":"def find_and_replace_pattern(words, pattern): def matches(word): if len(word) != len(pattern): return False w_to_p = {} p_to_w = {} for w, p in zip(word, pattern): if w not in w_to_p: w_to_p[w] = p if p not in p_to_w: p_to_w[p] = w if w_to_p[w] != p or p_to_w[p] != w: return False return True return [word for word in words if matches(word)]"},{"question":"You are given a **0-indexed** 2D integer array `grid` representing a grid with obstacles and empty spaces. The value `1` represents an obstacle, and the value `0` represents an empty space. Your task is to determine the shortest path from the top-left corner to the bottom-right corner, navigating around obstacles. You may move up, down, left, or right, but you cannot move through obstacles. If there is no valid path, return `-1`. Solve this problem with a time complexity better than `O(m * n)`.","solution":"from collections import deque def shortest_path(grid): Returns the shortest path from the top-left corner to the bottom-right corner of the grid. Each cell in the grid can either be an obstacle (1) or an empty space (0). Moving directions allowed are up, down, left, and right. If there is no valid path, returns -1. # Dimensions of the grid rows, cols = len(grid), len(grid[0]) # Early exit if start or end is blocked if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS; starting from (0, 0) queue = deque([(0, 0, 1)]) # (row, col, distance) # Set to keep track of visited positions visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # Check if we\'ve reached the bottom-right corner if r == rows - 1 and c == cols - 1: return dist # Explore all 4 possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) # If we exhaust the queue without finding the end, return -1 return -1"},{"question":"You are given a list of **weighted edges** representing an undirected graph and an integer `n`, which corresponds to the number of nodes (numbered from `0` to `n-1`). Each edge is represented as a triplet `[u, v, w]` where `u` and `v` denote the two nodes the edge connects, and `w` denotes the weight of that edge. Return _the weight of the **minimum spanning tree**_ (MST) of the graph. If it is not possible to form a MST, return `-1`.","solution":"def find(parent, i): # A utility function to find the parent of an element i if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): # A utility function to do union of two subsets x and y xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(edges, n): result = [] # This will store the resultant MST parent = [] rank = [] i = 0 # An index variable, used for sorted edges e = 0 # An index variable, used for result[] for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) while e < n - 1: if i >= len(edges): return -1 # If edges are exhausted and we didn\'t find enough edges for MST u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost"},{"question":"You are given a list of `n` integers, where `n` is larger than or equal to `3`, representing the vertices of a potential triangle. Your task is to find the maximum perimeter of a non-degenerate triangle that can be formed with the given integers. A triangle is non-degenerate if and only if the sum of any two sides is greater than the third side. Return the maximum perimeter of such a triangle, or `0` if no non-degenerate triangle can be formed.","solution":"def max_perimeter(triangle_vertices): Returns the maximum perimeter of a non-degenerate triangle that can be formed with the given vertices. Parameters: triangle_vertices (list): A list of integers representing the sides. Returns: int: The maximum perimeter of a non-degenerate triangle or 0 if no such triangle can be formed. # Sort the vertices in descending order triangle_vertices.sort(reverse=True) # Iterate through the sorted list to find the maximum perimeter for i in range(len(triangle_vertices) - 2): if triangle_vertices[i] < triangle_vertices[i + 1] + triangle_vertices[i + 2]: return triangle_vertices[i] + triangle_vertices[i + 1] + triangle_vertices[i + 2] return 0"},{"question":"You are given a **0-indexed** string `s` comprising only digits, and a positive integer `k`. You need to determine the **smallest** integer that can be obtained by removing exactly `k` digits from `s`. The result should preserve the relative order of the digits in `s`. For example, given `s = \\"1432219\\"` and `k = 3`, one possible way to remove three digits is to remove the digits `\'4\'`, `\'3\'`, and `\'2\'` to get the smallest number \\"1219\\". Return the smallest number possible as a string after removing exactly `k` digits from `s`.","solution":"def removeKdigits(s, k): Removes exactly k digits from the string s to form the smallest possible integer. :param s: A string comprised of digits :param k: A positive integer representing the number of digits to remove :return: The smallest possible integer as a string after removing k digits stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Join the stack to form the resulting number and strip leading zeros return \\"\\".join(stack).lstrip(\'0\') or \\"0\\""},{"question":"Implement a class `StringManipulator` that supports various string operations. The class should have the following methods: * `StringManipulator(String s)` - Initializes the class with the string `s`. * `int length()` - Returns the length of the string. * `String reverse()` - Returns the reverse of the string. * `String toUpperCase()` - Converts all the characters of the string to uppercase and returns the result. * `boolean isPalindrome()` - Checks if the string is a palindrome. A string is considered a palindrome if it reads the same backward as forward. * `String substring(int start, int end)` - Returns the substring from the `start` index to the `end` index (exclusive). You are not allowed to use any built-in string manipulation functions other than what is required for the initial setup.","solution":"class StringManipulator: def __init__(self, s): self.s = s def length(self): return len(self.s) def reverse(self): reversed_string = \'\' for char in self.s: reversed_string = char + reversed_string return reversed_string def to_upper_case(self): upper_case_string = \'\' for char in self.s: if \'a\' <= char <= \'z\': upper_case_string += chr(ord(char) - 32) else: upper_case_string += char return upper_case_string def is_palindrome(self): n = self.length() for i in range(n // 2): if self.s[i] != self.s[n - i - 1]: return False return True def substring(self, start, end): sub_str = \'\' for i in range(start, end): sub_str += self.s[i] return sub_str"},{"question":"You are given an array of distinct integers `arr` and an integer `d`. A jump consists of moving from index `i` to index `j` such that `0 <= i < j < arr.length` and `arr[i] + d == arr[j]`. Each integer can be used at most once in a jump. Return _the **longest sequence of jumps** possible by following the described jumping rules_. If no valid jump can be made, return 0.","solution":"def longest_jump_sequence(arr, d): Returns the longest sequence of jumps in the array such that each jump increment the current value by d. :param arr: List of distinct integers :param d: Integer jump value :return: Length of the longest sequence of jumps index_map = {val: idx for idx, val in enumerate(arr)} max_length = 0 def find_sequence_length(idx, current_length): nonlocal max_length next_value = arr[idx] + d if next_value in index_map: find_sequence_length(index_map[next_value], current_length + 1) else: max_length = max(max_length, current_length + 1) for i in range(len(arr)): find_sequence_length(i, 0) return max_length"},{"question":"You are given an integer array `arr` of size `n` and an integer `x`. You need to find all **unique quadruplets** `[a, b, c, d]` such that `a + b + c + d = x` and `0 <= a, b, c, d < n`. Return _the number of such unique quadruplets_. Since the answer can be very large, return it **modulo** `109 + 7`. Ensure that your solution handles large input sizes efficiently.","solution":"def count_quadruplets(arr, x): Count the number of unique quadruplets [a, b, c, d] in the array `arr` such that a + b + c + d = x and 0 <= a, b, c, d < len(arr). Return the result modulo 10^9 + 7. from collections import defaultdict MOD = 10**9 + 7 n = len(arr) if n < 4: return 0 quadruplet_count = 0 pair_sum = defaultdict(int) for i in range(1, n - 1): for j in range(i + 1, n): sum_right = arr[i] + arr[j] complement = x - sum_right if complement in pair_sum: quadruplet_count = (quadruplet_count + pair_sum[complement]) % MOD for k in range(0, i): sum_left = arr[k] + arr[i] pair_sum[sum_left] += 1 return quadruplet_count"},{"question":"You are given an array of integers `nums` that contains `n` elements, each in the range `[1, n]`. One number appears twice, and another number is missing. Find and return a vector containing the duplicate number and the missing number. You must not modify the input array and should use constant extra space.","solution":"def find_duplicate_and_missing(nums): Find the duplicate number and the missing number in the array nums. Args: nums (list of int): List of integers where each element is in the range [1, n] and contains n elements. Returns: (duplicate, missing) (tuple of int): Tuple containing the duplicate and missing numbers. n = len(nums) total_sum = sum(range(1, n + 1)) total_square_sum = sum(x * x for x in range(1, n + 1)) actual_sum = sum(nums) actual_square_sum = sum(x * x for x in nums) # Let x be the missing number and y be the duplicate number. # We have: # total_sum = actual_sum + x - y # total_square_sum = actual_square_sum + x^2 - y^2 # => total_square_sum = actual_square_sum + (x - y) * (x + y) diff_sum = total_sum - actual_sum # x - y diff_square_sum = total_square_sum - actual_square_sum # (x - y) * (x + y) sum_xy = diff_square_sum // diff_sum # x + y # Solving for x and y x = (diff_sum + sum_xy) // 2 y = sum_xy - x return (y, x)"},{"question":"You are given a binary tree represented by its root node. Return _the sum of all left leaves_ in the tree. A leave is classified as a left leave if it is the left child of its parent node and it is a leaf (meaning it has no children).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): def is_leaf(node): return node is not None and node.left is None and node.right is None def dfs(node): if node is None: return 0 sum_left_leaves = 0 if is_leaf(node.left): sum_left_leaves += node.left.val else: sum_left_leaves += dfs(node.left) sum_left_leaves += dfs(node.right) return sum_left_leaves return dfs(root)"},{"question":"You are given a binary tree where each node is either `0` or `1`. Each path from the root to a leaf can be interpreted as a binary number. Return the sum of these numbers modulo `10^9 + 7`. A leaf is a node with no children.","solution":"MOD = 10**9 + 7 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_value): if not node: return 0 current_value = (current_value << 1) | node.val if not node.left and not node.right: return current_value return (dfs(node.left, current_value) + dfs(node.right, current_value)) % MOD return dfs(root, 0)"},{"question":"You are given a sequence of integers where each integer appears exactly twice, except for one element that appears exactly once. Write a function to find the element that appears exactly once within the sequence. Your solution should have a linear runtime complexity and use only constant extra space. Return the element that appears exactly once. Note that the input array will always have exactly one such unique element.","solution":"def find_unique(nums): Finds the element that appears exactly once in the array where every other element appears exactly twice. Args: nums: List of integers with exactly one unique integer and other integers appearing twice. Returns: The unique integer that appears only once in the given list. unique_element = 0 for num in nums: unique_element ^= num # XOR operation return unique_element"},{"question":"You are given a binary tree with `n` nodes labeled from `1` to `n`. Each node has a value associated with it, represented by an array `values` where `values[i]` is the value of the `i-th` node. You are also given the `edges` array where `edges[i] = [u, v]` indicates there is an edge between nodes `u` and `v` in the tree. Find and return _the maximum sum of values_ from any path in the tree. A path is defined as a sequence of nodes where each adjacent pair of nodes is connected by an edge, and a path can start and end at any node.","solution":"class TreeNode: def __init__(self, value): self.value = value self.adj = [] def build_tree(n, values, edges): nodes = [TreeNode(values[i]) for i in range(n)] for u, v in edges: nodes[u-1].adj.append(nodes[v-1]) nodes[v-1].adj.append(nodes[u-1]) return nodes[0] def max_path_sum(n, values, edges): root = build_tree(n, values, edges) def dfs(node, parent): max_ending_here = node.value max_path = node.value for neighbor in node.adj: if neighbor == parent: continue child_max, child_max_ending = dfs(neighbor, node) max_path = max(max_path, child_max, max_ending_here + child_max_ending) max_ending_here = max(max_ending_here, max_ending_here + child_max_ending) return max_path, max_ending_here return dfs(root, None)[0]"},{"question":"Given two strings `s` and `t` consisting of only lowercase alphabets, write a function to determine if `s` can be transformed into `t` by performing at most one edit. An edit is defined as: 1. Inserting a character 2. Removing a character 3. Replacing a character","solution":"def is_one_edit_away(s, t): Returns True if string s can be transformed into string t by performing at most one edit. An edit is defined as: inserting a character, removing a character, or replacing a character. len_s = len(s) len_t = len(t) # If the length difference is more than 1, more than one edit is required if abs(len_s - len_t) > 1: return False # When the lengths are the same, we can only replace one character if len_s == len_t: edit_required = False for i in range(len_s): if s[i] != t[i]: if edit_required: return False edit_required = True return True # When the lengths differ by one, we can only insert or remove one character if len_s > len_t: return check_one_edit_insert_remove(t, s) return check_one_edit_insert_remove(s, t) def check_one_edit_insert_remove(shorter, longer): Returns True if shorter can be transformed into longer by inserting or removing exactly one character. i, j = 0, 0 edit_required = False while i < len(shorter) and j < len(longer): if shorter[i] != longer[j]: if edit_required: return False edit_required = True j += 1 # skip one character in the longer string else: i += 1 j += 1 return True"},{"question":"Given a grid of size `n x n` filled with positive integers, you are allowed to move either right or down from any cell, starting from the top-left corner. Write a function to find the minimum path sum from the top-left corner to the bottom-right corner of the grid. Return the minimum path sum.","solution":"def min_path_sum(grid): Returns the minimum path sum to reach the bottom-right corner of the grid. Parameters: grid (list of list of int): The input grid filled with positive integers. Returns: int: The minimum path sum. if not grid or not grid[0]: return 0 n = len(grid) dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][n - 1]"},{"question":"You are given a **0-indexed** string `word`, consisting of lowercase English letters. You need to perform **cyclic shifts** on the string. A cyclic shift moves the last character of the string to the front, the second last character to the second position, and so forth. Given an integer `k`, return the string after performing `k` cyclic shifts. In case `k` is larger than the length of the string, reduce `k` modulo the length of the string to get the equivalent number of shifts. For example, given `word = \\"abcdefg\\"` and `k = 3`, the result should be `\\"efgabcd\\"`.","solution":"def cyclic_shift(word, k): Returns the string after performing k cyclic shifts. n = len(word) k = k % n # Reduce k if k is larger than the length of the string return word[-k:] + word[:-k]"},{"question":"Given a matrix `mat` containing integers where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom, write a function that searches for a target integer `x` and returns a tuple of its coordinates (row, column) if `x` is found. If `x` is not found, return `(-1, -1)`.","solution":"def search_matrix(mat, x): Searches for a target integer `x` in a sorted matrix `mat` and returns the coordinates (row, column) if found. If `x` is not found, returns (-1, -1). :param mat: List[List[int]], 2D list of integers sorted as specified. :param x: int, target integer to search for. :return: Tuple[int, int], coordinates of the target integer. if not mat or not mat[0]: return -1, -1 rows = len(mat) cols = len(mat[0]) # Start from the top right corner i = 0 j = cols - 1 while i < rows and j >= 0: if mat[i][j] == x: return i, j elif mat[i][j] > x: j -= 1 else: i += 1 return -1, -1"},{"question":"You are given an integer array `arr` representing the daily temperature readings. A **heatwave streak** is defined as a period of **two or more contiguous** days such that the temperature on each day within the period is **strictly greater** than the temperature on the preceding day. Return _the total number of **heatwave streaks**_ in the array.","solution":"def count_heatwave_streaks(arr): Returns the total number of heatwave streaks in the array. A heatwave streak is defined as a period of two or more contiguous days where the temperature on each day is strictly greater than the temperature on the preceding day. :param arr: List[int], an integer array representing daily temperature readings. :return: int, total number of heatwave streaks. total_streaks = 0 n = len(arr) if n < 2: return total_streaks streak_length = 0 for i in range(1, n): if arr[i] > arr[i - 1]: streak_length += 1 if streak_length == 1: total_streaks += 1 else: streak_length = 0 return total_streaks"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `threshold`. You need to find a **positive integer divisor** `d` such that, when every element in the array is divided by `d` and rounded up to the nearest integer, the sum of those resulting values is less than or equal to `threshold`. Return _the smallest possible value of d_.","solution":"import math def smallest_divisor(nums, threshold): def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if compute_sum(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"An e-commerce website is implementing a promotion where customers can combine discount coupons but with certain restrictions. Each coupon has a value, and the website wants to ensure that no two coupons used together exceed a certain total value. You are given an array `coupons` where `coupons[i]` represents the value of the `ith` coupon, and an integer `maxValue` which is the maximum allowed combined value of any two coupons. Design a class `CouponCombiner` and implement the following methods: * `CouponCombiner(int[] coupons, int maxValue)` Initializes the object with the given list of coupon values and the maximum allowed combined value. * `boolean canCombine(int a, int b)` Returns whether coupon `a` can be combined with coupon `b` without exceeding the maximum allowed combined value. Here, `a` and `b` are indexes in the `coupons` array. * `int maxCouponValue()` Returns the maximum value of any single coupon. Your implementation should efficiently handle multiple queries to check if coupons can be combined and retrieve the maximum coupon value, matching the e-commerce website\'s promotion policy.","solution":"class CouponCombiner: def __init__(self, coupons, maxValue): Initialize the CouponCombiner with a list of coupons and a maximum allowed combined value. :param coupons: List[int], list of coupon values. :param maxValue: int, maximum allowed combined value for any two coupons. self.coupons = coupons self.maxValue = maxValue def canCombine(self, a, b): Check if the coupons at index `a` and `b` can be combined without exceeding maximum allowed combined value. :param a: int, index of the first coupon. :param b: int, index of the second coupon. :return: bool, True if the combined value of the two coupons is less than or equal to maxValue, False otherwise. if not (0 <= a < len(self.coupons) and 0 <= b < len(self.coupons)): raise ValueError(\\"Coupon indexes are out of bounds\\") return self.coupons[a] + self.coupons[b] <= self.maxValue def maxCouponValue(self): Return the maximum value of any single coupon. :return: int, maximum value of any single coupon. return max(self.coupons) # Example usage: # combiner = CouponCombiner([5, 10, 15, 20], 25) # print(combiner.canCombine(0, 1)) # True # print(combiner.maxCouponValue()) # 20"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. A **k-length substring** of `s` is any substring with exactly `k` characters. Return _the number of distinct **k-length substrings** of `s`_. If `k` is greater than the length of `s`, return `0`. Ensure your solution is efficient with respect to both time and space complexity.","solution":"def num_distinct_k_length_substrings(s, k): Returns the number of distinct k-length substrings of s. If k is greater than the length of s, returns 0. :param s: A string consisting of lowercase English letters. :param k: An integer, the length of substrings to consider. :return: An integer, the number of distinct k-length substrings. if k > len(s): return 0 substrings = set(s[i:i+k] for i in range(len(s) - k + 1)) return len(substrings)"},{"question":"You are given a binary string `s` and an integer `x`. You can perform the following operation at most once: choose any index `i` (0-based) and replace the character at `i` with `1`. After performing the operation (or choosing not to perform it), your goal is to find the length of the longest contiguous substring of `1`s in the modified string. Return _the length of the longest contiguous substring of `1`s_ in the resulting string.","solution":"def longest_contiguous_one(s, x): Given a binary string s and an integer x, this function finds the length of the longest contiguous substring of 1\'s that can be obtained by changing at most one character to 1. :param s:str: Binary string :param x:int: A placeholder, not used in this particular implementation :return: int: Length of the longest contiguous substring of 1\'s # To store the maximum length encountered max_len = 0 # Dynamic array to store lengths between \'0\'s lengths = [] # Length of current contiguous segment of \'1\'s curr_len = 0 for char in s: if char == \'1\': curr_len += 1 else: if curr_len > 0: lengths.append(curr_len) curr_len = 0 lengths.append(0) # adding the last contiguous segment of \'1\'s if exists if curr_len > 0: lengths.append(curr_len) # if we had only \'1\'s initially if \'0\' not in s: return len(s) # If there were no \'1\'s in the string if \'1\' not in s: return 1 # Calculate the max length we can have by changing one \'0\' to \'1\' for i in range(len(lengths)): if lengths[i] == 0: left_len = lengths[i - 1] if i > 0 else 0 right_len = lengths[i + 1] if i < len(lengths) - 1 else 0 # Check combination of current \'0\' to \'1\' max_len = max(max_len, left_len + 1 + right_len) return max_len"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `i`-th tree in a row of trees. A tree is considered **visible** if there are no taller or equal height trees to its right. Return _the number of visible trees_. Note: A tree that is on the far right of the row is always considered visible.","solution":"def count_visible_trees(heights): Returns the number of visible trees in the row. A tree is considered visible if there are no taller or equal height trees to its right. Parameters: heights (list): A list of integers representing the heights of the trees. Returns: int: The number of visible trees. if not heights: return 0 visible_count = 0 max_height_so_far = -1 for height in reversed(heights): if height > max_height_so_far: visible_count += 1 max_height_so_far = height return visible_count"},{"question":"Given a string `s` and an array of integers `indices` of the same length, transform the string according to the following rule: for every valid index `i`, the character `s[i]` should be moved to `indices[i]`. Return the transformed string. It is guaranteed that the given indices form a valid permutation of `0` to `len(s) - 1`.","solution":"def restore_string(s, indices): Returns the transformed string according to the given indices. :param s: str - The original string. :param indices: List[int] - The indices to which each character in the string should be moved. :return: str - The transformed string. # Initialize a list with the same length as the input string restored = [\'\'] * len(s) # Iterate over the characters in the string and their respective indices for i, index in enumerate(indices): restored[index] = s[i] # Join the list into a single string and return return \'\'.join(restored)"},{"question":"Given a binary tree, write a function to return the **inorder traversal** of its nodes\' values. You need to implement the traversal iteratively. The function should return a list of node values as they appear in inorder.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values. :param root: TreeNode, the root of the binary tree :return : List[int], the values in inorder traversal result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result"},{"question":"Given two strings `s1` and `s2`, determine whether they are **isomorphic**. Two strings `s1` and `s2` are isomorphic if the characters in `s1` can be replaced to get `s2`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Implement the function `boolean isIsomorphic(String s1, String s2)`.","solution":"def isIsomorphic(s1, s2): Determine if two strings s1 and s2 are isomorphic. if len(s1) != len(s2): return False # Dictionaries to store mappings of characters s1_to_s2_mapping = {} s2_to_s1_mapping = {} for c1, c2 in zip(s1, s2): if c1 in s1_to_s2_mapping: if s1_to_s2_mapping[c1] != c2: return False else: s1_to_s2_mapping[c1] = c2 if c2 in s2_to_s1_mapping: if s2_to_s1_mapping[c2] != c1: return False else: s2_to_s1_mapping[c2] = c1 return True"},{"question":"You are given a **0-indexed** string array `words` containing `n` words. You are also given an array `queries`, where `queries[i] = [prefix, suffix]`. The answer to the `ith` query is the length of the longest word in `words` that starts with the string `prefix` and ends with the string `suffix`. If no such word exists, the answer should be `-1`. Return _an array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query.","solution":"def longest_word(words, queries): Returns an array of the lengths of the longest words in `words` that start with `prefix` and end with `suffix` for each query in `queries`. result = [] for prefix, suffix in queries: max_length = -1 for word in words: if word.startswith(prefix) and word.endswith(suffix): max_length = max(max_length, len(word)) result.append(max_length) return result"},{"question":"A company conducts a ping-pong tournament where `n` players compete against each other. Each player is assigned a unique ID from `1` to `n`. You are given the results of the matches in an array `matches`, where `matches[i] = [winneri, loseri]` indicates that player `winneri` defeated player `loseri` in a match. The company wants to determine which players are the best and which players are the worst. A player is considered one of the best if they have not lost any matches, and they are considered one of the worst if they have lost all their matches. Return an array of two lists: the first list contains the IDs of the best players sorted in ascending order, and the second list contains the IDs of the worst players sorted in ascending order. If there are no best or worst players, return an empty list for that category.","solution":"def find_best_and_worst_players(n, matches): Finds the best and worst players in a ping-pong tournament. Parameters: n (int): Number of players matches (list): List of match results where each match is represented as [winner, loser] Returns: list: A list of two lists where the first list contains the IDs of the best players sorted in ascending order, and the second list contains the IDs of the worst players sorted in ascending order. won_count = [0] * (n + 1) lost_count = [0] * (n + 1) for winner, loser in matches: won_count[winner] += 1 lost_count[loser] += 1 best_players = [player for player in range(1, n + 1) if lost_count[player] == 0] worst_players = [player for player in range(1, n + 1) if won_count[player] == 0 and lost_count[player] > 0] return [sorted(best_players), sorted(worst_players)]"},{"question":"You are given two **0-indexed** integer arrays `startTime` and `endTime` representing the start and end times of `n` intervals, where `startTime[i]` and `endTime[i]` denote the start and end of the `i-th` interval, respectively. An interval `[a, b)` overlaps an interval `[c, d)` if they have any point in common, i.e., `a < d` and `c < b`. Return _the **maximum** number of intervals that overlap at any point in time._","solution":"def maxOverlappingIntervals(startTime, endTime): Returns the maximum number of intervals that overlap at any point in time. events = [] for start, end in zip(startTime, endTime): events.append((start, 1)) # Start event events.append((end, -1)) # End event events.sort() max_overlap = 0 current_overlap = 0 for event in events: current_overlap += event[1] max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"You are given an array `events` where each event occurs at a specific time `t`. Each entry in the array `events` is a pair of integers `[startTime, endTime]` which represents an event that starts at `startTime` and ends at `endTime`. A person can attend an event if their current time is less than or equal to the `startTime` of the event. The person leaves the event exactly at `endTime` and can only attend the next event if the `startTime` of the next event is greater than or equal to the `currentTime` when they leave the previous event. Determine the maximum number of events that a person can attend. The list `events` is not sorted in any particular order.","solution":"def max_events(events): Returns the maximum number of events a person can attend. if not events: return 0 # Sort events primarily by their end time, and secondarily by their start time events.sort(key=lambda x: (x[1], x[0])) current_time = 0 event_count = 0 for start, end in events: if current_time <= start: # Attend this event current_time = end event_count += 1 return event_count"},{"question":"Given an integer array `nums`, return an array `result` of length `nums.length` where `result[i]` is the number of distinct elements in the subarray `nums[i...len(nums)-1]` (0-indexed) with the last element always being `nums[len(nums)-1]`. A **subarray** is a contiguous non-empty sequence of elements within an array, and `nums[i...len(nums)-1]` denotes a subarray starting from index `i` to the end of the array.","solution":"def distinct_elements_in_subarrays(nums): Returns an array where each element is the number of distinct elements in the subarray nums[i...len(nums)-1]. result = [0] * len(nums) seen_elements = set() for i in reversed(range(len(nums))): seen_elements.add(nums[i]) result[i] = len(seen_elements) return result"},{"question":"You are given an integer array `nums` and an integer `k`. We call an array interval a contiguous subarray containing `k` elements. `k`-interval sum is the sum of the elements within that interval. Create a function that returns the maximum `k`-interval sum in the `nums` array. If there are no such intervals, return 0.","solution":"def max_k_interval_sum(nums, k): Returns the maximum k-interval sum in the nums array. If nums is empty or k is greater than the length of nums, return 0. if not nums or k > len(nums): return 0 max_sum = float(\'-inf\') current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` which consists of lowercase letters. You need to perform a series of operations to make the string \\"sorted\\" (in ascending alphabetical order). In each operation, you can choose one character and move it to the front of the string. Return the minimum number of operations required to sort the string \\"s\\".","solution":"def min_operations_to_sort_string(s): Returns the minimum number of operations required to sort the string `s` in ascending alphabetical order. sorted_string = \'\'.join(sorted(s)) operation_count = 0 current_index = 0 for char in sorted_string: found_at = s.find(char, current_index) if found_at != -1: current_index = found_at + 1 else: operation_count += 1 # The number of operations required is the number of characters out of order return operation_count # Running this function should sort the string `s` with minimum operations # For example, min_operations_to_sort_string(\\"dcab\\") returns 2"},{"question":"Given a `m x n` grid containing integers, you need to find the maximum sum of any rectangle within the grid. The rectangle must be made up of at least one element. Your task is to write a function that returns the maximum possible sum considering all possible rectangles that can be formed within the grid.","solution":"def max_sum_rectangle(grid): Returns the maximum sum of any rectangle within the given grid. if not grid or not grid[0]: return 0 max_sum = float(\'-inf\') rows, cols = len(grid), len(grid[0]) for left in range(cols): row_sum = [0] * rows for right in range(left, cols): for i in range(rows): row_sum[i] += grid[i][right] current_max = max_subarray_sum(row_sum) max_sum = max(max_sum, current_max) return max_sum def max_subarray_sum(arr): Helper function to find the maximum sum of any contiguous subarray. curr_sum = max_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"You are given an integer array `arr` of length `n` and an integer `m`. Your task is to find the **minimum length of a contiguous subarray** of `arr` whose **sum** is **greater than or equal** to `m`. If there is no such subarray, return `0`. For example, given `arr = [2, 1, 5, 2, 8]` and `m = 7`, the minimum length of a contiguous subarray whose sum is at least `7` is `1` with the subarray `[8]`.","solution":"def min_length_subarray(arr, m): Finds the minimum length of a contiguous subarray of `arr` whose sum is greater than or equal to `m`. If there is no such subarray, returns 0. Parameters: arr (List[int]): The input array of integers. m (int): The target sum. Returns: int: The minimum length of a contiguous subarray with sum at least `m` or 0 if no such subarray exists. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= m: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a list of integers `nums` and a target integer `target`. Each integer in `nums` represents a different coin denomination, and you can use each coin denomination an unlimited number of times. Return the minimum number of coins required to make the `target` amount. If it is not possible to make the `target` amount using the given denominations, return `-1`. For example, given the list `nums = [1, 2, 5]` and `target = 11`, the minimum number of coins required would be `3` because `11 = 5 + 5 + 1`. Consider all possible denominations and target values that fall within reasonable computational limits.","solution":"def min_coins(nums, target): Returns the minimum number of coins required to make the target amount using the given coin denominations. If it\'s not possible to make the target amount, returns -1. # Initialize the DP array with a value larger than any possible number of coins dp = [float(\'inf\')] * (target + 1) dp[0] = 0 # Base case: no coins are needed to make 0 amount for coin in nums: for x in range(coin, target + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Take the minimum of including the current coin or not return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"Given an array of `n` integers, implement a class `ArrayOperations` that supports the following operations: 1. `addElement(int value)`: Adds the integer `value` to the end of the array. 2. `removeElement(int value)`: Removes the first occurrence of the integer `value` from the array. If the value does not exist in the array, the operation should do nothing. 3. `findMedian()`: Returns the median of all elements currently in the array. The median is the middle element when the elements are sorted in ascending order. If the array has an even number of elements, the median is the average of the two middle elements. Ensure the operations are optimized for efficiency.","solution":"class ArrayOperations: def __init__(self): self.array = [] def addElement(self, value): self.array.append(value) self.array.sort() def removeElement(self, value): try: self.array.remove(value) except ValueError: pass # If the value does not exist, do nothing def findMedian(self): n = len(self.array) if n == 0: return None if n % 2 == 1: # Odd number of elements return float(self.array[n // 2]) else: # Even number of elements mid1 = self.array[n // 2 - 1] mid2 = self.array[n // 2] return (mid1 + mid2) / 2"},{"question":"Given an integer array `nums` and an integer `k`, return the maximum sum of `k` consecutive elements in the array. If `nums` has fewer than `k` elements, return `-1`. Try to solve the problem in O(n) time complexity.","solution":"def max_sum_of_k_consecutive(nums, k): Returns the maximum sum of k consecutive elements in the array nums. If nums has fewer than k elements, returns -1. n = len(nums) if n < k: return -1 max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a `0-indexed` integer array `elevations` of length `n` where `elevations[i]` denotes the elevation level of the `i-th` location in a sequence of mountains. You are to build a road such that it starts at any location and ends at any location, forming a contiguous path. The road must be built in a way that each subsequent location in this path is either at the same level or at a higher elevation compared to the previous one. Return _the **length** of the longest such path you can build._","solution":"def longest_increasing_path(elevations): Returns the length of the longest increasing path in the given elevations list. if not elevations: return 0 max_length = 1 current_length = 1 for i in range(1, len(elevations)): if elevations[i] >= elevations[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given a binary search tree (BST), write a function to find the kth smallest element in it. The BST is represented by its root node, and you are given an integer k which denotes the position (1-indexed) of the smallest element to return. Note that it is guaranteed that k is valid, i.e., 1 ≤ k ≤ number of nodes in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. def inorder_traversal(node): if node: yield from inorder_traversal(node.left) yield node.val yield from inorder_traversal(node.right) generator = inorder_traversal(root) for _ in range(k): kth_value = next(generator) return kth_value"},{"question":"Given an array of integers `heights` representing the heights of students in a line. Each student can see the scenery if there are no taller students directly standing in front of them. Return the number of students that can see the scenery. A student is considered as seeing the scenery if their height is greater than all students before them in the line. For example, given the array `heights = [4, 3, 2, 3, 1]`, the students that can see the scenery will be those at indices `0` and `2`, as these heights are 4 and 3, respectively.","solution":"def can_see_scenery(heights): Returns the number of students that can see the scenery. :param heights: List[int] - List of integers representing the heights of students :return: int - Number of students that can see the scenery count = 0 max_height = float(\'-inf\') for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a string `s` consisting of lowercase letters, and you are tasked with finding the lexicographically smallest subsequence of `s` that contains all the distinct characters of `s` exactly once. To solve this problem, implement the function `smallestSubsequence(s: str) -> str` that takes a string `s` as input and returns the lexicographically smallest subsequence which includes each distinct character from `s` exactly once. # Example: ``` Input: s = \\"cbacdcbc\\" Output: \\"acdb\\" ``` # Constraints: - 1 <= s.length <= 1000 - `s` consists of lowercase English letters.","solution":"def smallestSubsequence(s: str) -> str: last_occurrence = {ch: i for i, ch in enumerate(s)} stack = [] added = set() for i, ch in enumerate(s): if ch in added: continue while stack and ch < stack[-1] and i < last_occurrence[stack[-1]]: removed = stack.pop() added.remove(removed) stack.append(ch) added.add(ch) return \'\'.join(stack)"},{"question":"You are given a string `s` and an array of indices `indices`. `indices` is a permutation of numbers from `0` to `s.length - 1`. You need to shuffle the string such that the character at the `i`-th position moves to `indices[i]` in the shuffled string. Return the shuffled string.","solution":"def restore_string(s, indices): Shuffles the string `s` such that the character at the i-th position moves to `indices[i]` in the shuffled string. Parameters: s (str): The input string to be shuffled. indices (List[int]): The permutation of indices. Returns: str: The shuffled string. shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"Given a list of non-negative integers representing the amount of profit for each day and an integer `k` representing the maximum number of transactions you can make, return _the **maximum profit** you can achieve by making at most `k` transactions_. A transaction is defined as buying and then selling one share of the stock. You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).","solution":"def maxProfit(k, profits): Returns the maximum profit that can be achieved by making at most k transactions. :param k: The maximum number of transactions allowed. :param profits: A list of non-negative integers representing the daily profits. :return: The maximum profit. if not profits or k == 0: return 0 n = len(profits) if k >= n // 2: return sum(x - y for x, y in zip(profits[1:], profits[:-1]) if x > y) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -profits[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], profits[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - profits[j]) return dp[k][-1]"},{"question":"Given a list of `n` integers and an integer `k`, partition the list such that: - All elements less than `k` come before elements equal to `k`, which must come before elements greater than `k`. - Relative ordering of elements in each partition should be preserved. Return the modified list.","solution":"def partition_list(arr, k): Partition the list such that all elements less than k come before elements equal to k, which must come before elements greater than k. Relative ordering of elements in each partition is preserved. less_than_k = [] equal_to_k = [] greater_than_k = [] for num in arr: if num < k: less_than_k.append(num) elif num == k: equal_to_k.append(num) else: greater_than_k.append(num) return less_than_k + equal_to_k + greater_than_k"},{"question":"You are given a string `inputStr` consisting of alphanumeric characters and symbols. A **valid password** is defined as one that meets the following criteria: - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character (non-alphanumeric). You need to create a function that checks whether the given `inputStr` is a valid password according to the above criteria or not. Return `True` if it is a valid password, else return `False`.","solution":"import string def is_valid_password(inputStr): Returns True if inputStr is a valid password based on the defined criteria, else returns False. has_upper = any(char.isupper() for char in inputStr) has_lower = any(char.islower() for char in inputStr) has_digit = any(char.isdigit() for char in inputStr) has_special = any(char in string.punctuation for char in inputStr) return has_upper and has_lower and has_digit and has_special"},{"question":"Given an integer array `nums`, move all `0`s to the end of the array while maintaining the relative order of the non-zero elements. _Modify the array in-place and do not return anything from your function._","solution":"def move_zeroes(nums): Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. Args: nums (List[int]): The array of integers to modify in-place. non_zero_index = 0 # Move non-zero elements to the front for i in range(len(nums)): if nums[i] != 0: nums[non_zero_index] = nums[i] non_zero_index += 1 # Fill the remaining positions with zeros for i in range(non_zero_index, len(nums)): nums[i] = 0"},{"question":"You are given a 2D integer matrix `grid` of size `m x n` and an integer `threshold`. Each cell in the `grid` represents the elevation of a point within a region. A region is defined as a group of connected cells with elevation values greater or equal to `threshold`. Two cells are considered connected if they are adjacent horizontally or vertically (not diagonally). Determine the number of distinct regions in the grid where all cells have elevations greater or equal to `threshold`. Return the number of such regions.","solution":"def num_regions_above_threshold(grid, threshold): Returns the number of distinct regions in the grid where all cells have elevations greater or equal to the threshold. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] < threshold: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) regions = 0 for i in range(m): for j in range(n): if grid[i][j] >= threshold and not visited[i][j]: regions += 1 dfs(i, j) return regions"},{"question":"Implement a class `MaxStack` that supports the following operations: * `void push(int x)` - Pushes `x` onto the stack. * `int pop()` - Removes the element on the top of the stack and returns it. * `int top()` - Returns the element on the top of the stack. * `int getMax()` - Retrieves the maximum element in the stack without removing it. ```python class MaxStack: def __init__(self): Initialize your data structure here. # Your code here def push(self, x: int) -> None: # Your code here def pop(self) -> int: # Your code here def top(self) -> int: # Your code here def getMax(self) -> int: # Your code here ``` **Example:** ``` MaxStack maxStack = new MaxStack(); maxStack.push(5); maxStack.push(1); maxStack.push(5); print(maxStack.top()); -> 5 print(maxStack.popMax()); -> 5 print(maxStack.top()); -> 1 print(maxStack.peekMax()); -> 5 print(maxStack.pop()); -> 1 print(maxStack.top()); -> 5 ``` **Note:** - Methods `top`, `pop`, and `getMax` must run in constant time.","solution":"class MaxStack: def __init__(self): Initialize your data structure here. self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if self.stack: value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def top(self) -> int: if self.stack: return self.stack[-1] def getMax(self) -> int: if self.max_stack: return self.max_stack[-1]"},{"question":"You are given an integer array `nums` representing the numbers on a number line, and a positive integer `k`. You can choose any number from the array and add or subtract `k` from it. You need to find the minimum possible difference between the maximum and minimum values in the array after performing the operation any number of times on each element. Return _the minimum possible difference_.","solution":"def min_difference_with_operations(nums, k): Returns the minimum possible difference between the maximum and minimum values in the array after performing the add/subtract operations any number of times. if not nums: return 0 min_val = min(nums) max_val = max(nums) # By adding or subtracting k, we can adjust the min and max values within # the range of [min_val + k, max_val - k] if min_val + k <= max_val - k. # However, if min_val + k > max_val - k, the values would overlap leading to # the minimum difference to be 0. return max(0, (max_val - k) - (min_val + k))"},{"question":"Given a 2D integer array `grid` where each cell represents a height at that location, precisely one water drop is placed at cell `(0, 0)`. Water can flow to neighboring cells directly north, south, east, or west if the neighboring cell\'s height is lower than the current cell\'s height. Determine the number of unique cells the water can flow to starting from `(0, 0)`. Return the count of these cells.","solution":"def can_flow_to(grid): Determine the number of unique cells the water can flow to starting from (0, 0). :param grid: List[List[int]], a 2D integer array representing the heights. :return: int, number of unique cells the water can flow to. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) visited = set() direction_vectors = [(-1, 0), (1, 0), (0, -1), (0, 1)] # north, south, west, east def dfs(r, c): visited.add((r, c)) for dr, dc in direction_vectors: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and (new_r, new_c) not in visited: if grid[new_r][new_c] < grid[r][c]: dfs(new_r, new_c) dfs(0, 0) return len(visited) - 1 # subtract 1 to exclude the starting cell (0, 0)"},{"question":"A **peak element** in an array is an element that is strictly greater than its neighbors. Given an integer array `nums`, where 1 ≤ `nums.length` ≤ 1000, find a **peak element** and return its index. The array may contain multiple peak elements, in that case return the index to any of the peak elements. You may imagine that `nums[-1]` and `nums[nums.length]` are negative infinity (-∞).","solution":"def find_peak_element(nums): This function finds a peak element in the array and returns its index. A peak element is an element that is strictly greater than its neighbors. :param nums: List of integers representing the array. :return: Index of a peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"Given a string `s` containing only lowercase letters, find and return the first non-repeating character in `s`. If all characters are repeating, return \'_\'.","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating, returns \'_\'. from collections import Counter # Count the occurrence of each character in the string count = Counter(s) # Find and return the first non-repeating character for char in s: if count[char] == 1: return char # All characters are repeating return \'_\'"},{"question":"You are given an integer array `cars`, where `cars[i]` represents the speed of the `i-th` car in a race. The ranking of cars in the race is defined such that the car with a higher speed ranks higher. If two cars have the same speed, they tie and share the same rank. Your task is to return an array of integers where the `i-th` integer represents the rank of the `i-th` car. For example, given `cars = [100, 200, 200, 150]`, the output should be `[4, 1, 1, 3]` because the second and third cars tie for rank 1, the fourth car is ranked 3rd, and the first car is ranked 4th.","solution":"def rank_cars(cars): Returns the ranks of cars based on their speeds. If two cars have the same speed, they share the same rank. # Create a list of (speed, index) tuples indexed_cars = [(speed, i) for i, speed in enumerate(cars)] # Sort the list by speed in descending order indexed_cars.sort(reverse=True, key=lambda x: x[0]) # Create an array to store the rank of each car ranks = [0] * len(cars) # Initialize the rank and previous speed variables rank = 1 prev_speed = indexed_cars[0][0] for i, (speed, index) in enumerate(indexed_cars): if speed != prev_speed: rank = i + 1 ranks[index] = rank prev_speed = speed return ranks"},{"question":"Given an array `arr` of integers where every integer appears an even number of times except for exactly **two** integers which appear an odd number of times, return _the two integers that appear an odd number of times_. The result should be in ascending order. You should implement your solution in linear time and constant space.","solution":"def find_two_odd_numbers(arr): Find two numbers that appear an odd number of times in the array. Return them in ascending order. xor_result = 0 # XOR all elements to get xor_result which is the XOR of the two odd occurring numbers for num in arr: xor_result ^= num # Find the rightmost set bit in xor_result set_bit_no = xor_result & -xor_result # Initialize the two odd occurring numbers x = 0 y = 0 # Divide elements into two groups and XOR separately for num in arr: if num & set_bit_no: x ^= num # XOR of first set else: y ^= num # XOR of second set # x and y are the two numbers that appear an odd number of times return sorted([x, y])"},{"question":"Given a list of `n` integers, `arr`, and an integer `m`, shift the elements of the list to the right by `m` positions without using any extra space (in-place). If `m` is larger than `n`, you should consider `m = m % n`. Return the modified list after the shift.","solution":"def shift_right(arr, m): Shifts elements of the list arr to the right by m positions. If m is larger than the length of the list, m is considered as m % len(arr). Args: arr (list): The list to be shifted. m (int): Number of positions to shift. Returns: list: The list after shifting elements to the right. n = len(arr) if n == 0: return arr m = m % n # consider m as m % n arr[:] = arr[-m:] + arr[:-m] return arr"},{"question":"You are given a binary tree and a target node. Return the value of the nearest leaf node to the target node in the binary tree. For simplicity, you can assume that the binary tree only has unique values, and both the tree and the target node exist. A leaf node is a node with no children.","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_closest_leaf(root, target): if not root: return None def dfs(node, parent=None): if node: node.parent = parent if node.left: dfs(node.left, node) if node.right: dfs(node.right, node) queue = deque() visited = set() def add_to_queue(node): queue.append(node) visited.add(node) dfs(root) # Find the target node def find_target(node, target): if not node: return None if node.val == target: return node left = find_target(node.left, target) if left: return left return find_target(node.right, target) target_node = find_target(root, target) add_to_queue(target_node) while queue: node = queue.popleft() if (node.left is None and node.right is None): return node.val for neighbour in (node.left, node.right, node.parent): if neighbour and neighbour not in visited: add_to_queue(neighbour)"},{"question":"You are given a singly linked list where each node contains an integer value. Design a method to remove the N-th node from the end of the list and return its head. The list must retain its structure and connectivity after the removal. Implement the following method: * `ListNode removeNthFromEnd(ListNode head, int n)` - Removes the N-th node from the end of the list and returns the head of the modified list. You can assume that the given `head` will never be `null`, and `1 <= n <= length of the linked list`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): dummy = ListNode(0) dummy.next = head first = dummy second = dummy for i in range(n + 1): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next"},{"question":"You are given a string `instructions` consisting only of the characters `\'G\'`, `\'L\'`, and `\'R\'`. `\'G\'` means go straight 1 unit, `\'L\'` means turn 90 degrees to the left, and `\'R\'` means turn 90 degrees to the right. The robot starts at `(0, 0)` facing north. Your task is to determine if the robot is bounded within a circle after executing the `instructions` repeatedly forever. Return `true` if it is bounded within a circle, and `false` otherwise.","solution":"def isRobotBounded(instructions): Determines if the robot is bounded within a circle after executing the given instructions repeatedly forever. :param instructions: A string representing the sequence of instructions. :return: A boolean indicating if the robot is bounded within a circle. # Directions are in the order: north, east, south, west directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] x, y, direction_index = 0, 0, 0 # Start at (0, 0) facing north (index 0) for instruction in instructions: if instruction == \'G\': x += directions[direction_index][0] y += directions[direction_index][1] elif instruction == \'L\': direction_index = (direction_index + 3) % 4 elif instruction == \'R\': direction_index = (direction_index + 1) % 4 # The robot is bounded in a circle if it returns to (0, 0) # or it\'s not facing north (direction_index != 0) return (x == 0 and y == 0) or direction_index != 0"},{"question":"You are given two strings `s` and `t` consisting of lowercase letters. You can select any substring of `s` and rearrange the characters in that substring. Determine if you can transform `s` into `t` by applying the aforementioned operation at most once. Return `true` if it is possible to transform `s` into `t`, and `false` otherwise.","solution":"def can_transform(s, t): Determines if `s` can be transformed into `t` by rearranging any single substring of `s` at most once. Args: s (str): The original string. t (str): The target string. Returns: bool: True if `s` can be transformed into `t` by rearranging any single substring of `s` at most once, False otherwise. if len(s) != len(t): return False from collections import Counter # Check if both strings have the same character counts s_counter = Counter(s) t_counter = Counter(t) return s_counter == t_counter"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to find the longest substring containing only unique characters and return its length. If the string is empty, return 0. Your task is to implement a function that executes this requirement efficiently.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. :param s: A string consisting of lowercase English letters. :return: Length of the longest substring with unique characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a 2D integer array `grid` consisting of `0`s and `1`s. A cell is called **lucky** if in its row and column there is no other `1` present. Return _a list of all lucky cells\' coordinates_ where each coordinate is represented as a list `[r, c]` in **ascending order** by row and, within each row, by column.","solution":"def lucky_cells(grid): Returns a list of the coordinates of all lucky cells in the grid. A lucky cell is one where there is no other `1` in its row or column. The coordinates are sorted in ascending order by row and, within each row, by column. Args: grid: List[List[int]]: 2D list where each element is either 0 or 1. Returns: List[List[int]]: List of list of ints representing the coordinates of lucky cells. num_rows = len(grid) num_cols = len(grid[0]) lucky_cells = [] for r in range(num_rows): for c in range(num_cols): if grid[r][c] == 1: row_check = all(grid[r][i] == 0 for i in range(num_cols) if i != c) col_check = all(grid[i][c] == 0 for i in range(num_rows) if i != r) if row_check and col_check: lucky_cells.append([r, c]) return sorted(lucky_cells)"},{"question":"You are given an array of integers `heights` representing a landscape, where `heights[i]` is the height of the point `i`. Rainwater will be trapped between the heights. Your task is to compute the maximum amount of water that can be trapped after raining. The water is only trapped between points that are higher than the surrounding points. Considering the heights array `heights` of length `n`, return the maximum amount of water that can be trapped between the points, given that each unit width of the terrain can hold as much water as the height of the smaller boundary at each end.","solution":"def trap(height): Computes the maximum amount of water that can be trapped between the heights. Args: height (List[int]): A list of non-negative integers representing the height of various points. Returns: int: Maximum amount of water that can be trapped. if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = 0, 0 water_trapped = 0 while left < right: if height[left] < height[right]: if height[left] >= left_max: left_max = height[left] else: water_trapped += left_max - height[left] left += 1 else: if height[right] >= right_max: right_max = height[right] else: water_trapped += right_max - height[right] right -= 1 return water_trapped"},{"question":"Given an array `nums` consisting of `n` non-negative integers, you are allowed to perform the following operation exactly once: 1. Select a non-empty subarray and reverse it. After performing the operation, return the maximum possible value of the sum of the `nums` array. A subarray is a contiguous part of an array. For example, given the array `nums = [1, 2, 3, 4]`, if you select the subarray `[2, 3]` and reverse it, the resulting array would be `[1, 3, 2, 4]`, and the sum would be `1 + 3 + 2 + 4 = 10`. If the array `nums = [2, 3, 6]`, reversing the subarray `[3, 6]` results in `[2, 6, 3]`, and the sum of the array remains `2 + 6 + 3 = 11`. Return the maximum sum you can obtain after performing the operation exactly once.","solution":"def maximum_possible_sum(nums): Return the maximum possible sum of the nums array after reversing exactly one non-empty subarray. n = len(nums) total_sum = sum(nums) # Edge case: if the array has only one element, the sum is already maximum if n == 1: return total_sum # Initializing to a very small number max_gain = float(\'-inf\') # Calculate potential gains by reversing each possible subarray for i in range(n): for j in range(i, n): # Gain when reversing subarray nums[i:j+1] gain = sum(nums[i:j+1][::-1]) - sum(nums[i:j+1]) max_gain = max(max_gain, gain) return total_sum + (max_gain if max_gain > 0 else 0)"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. You have to modify the list in-place and return the modified list\'s head. Note that you should take into account that `k` might be greater than the length of the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotates the linked list to the right by k places. if not head or not head.next or k == 0: return head # Find the length of the linked list current = head length = 1 while current.next: current = current.next length += 1 # Make the linked list circular current.next = head # Find the new tail: length - k % length - 1, and the new head: length - k % length k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circular link new_tail.next = None return new_head"},{"question":"You are given a string `s` and a list of integer `indices` of the same length. The string `s` is shuffled such that the character at the `i-th` position moves to `indices[i]` in the shuffled string. Return the restored string. For example, if `s = \\"code\\"` and `indices = [3, 2, 1, 0]`, the function should return `\\"edoc\\"`.","solution":"def restore_string(s, indices): Restores the string `s` based on the given `indices`. Args: s (str): The shuffled string. indices (List[int]): The list of indices indicating the original positions of characters in `s`. Returns: str: The restored string. restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"A **binary tree** is a data structure in which each node has at most two children, referred to as the left child and the right child. A **leaf** is a node with no children. You are given the root of a binary tree. For each leaf in the binary tree, find the depth of the leaf and return the sum of these depths. The depth of a node is the number of edges from the root to that node. Note that the root node is at depth 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaf_depths(root): def dfs(node, depth): if not node: return 0 if not node.left and not node.right: return depth return dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 0)"},{"question":"Given a string `s` consisting of only lowercase letters, return a list of all the characters that appear more than once in the string along with their frequency. The characters in the list should be sorted in ascending order based on their frequency. If two characters have the same frequency, the character that appears earlier in the alphabet should come first. For instance, if `s = \\"aabbccdde\\"` the output should be `[[\'b\', 2], [\'a\', 2], [\'d\', 2], [\'c\', 2]]`.","solution":"def find_repeated_characters(s): Returns a list of characters that appear more than once in the string `s` along with their frequency, sorted by frequency in ascending order and by alphabetical order if frequencies are the same. from collections import Counter counts = Counter(s) repeated_chars = [[char, freq] for char, freq in counts.items() if freq > 1] repeated_chars.sort(key=lambda x: (x[1], x[0])) return repeated_chars"},{"question":"Given a list of integers `arr` and a target integer `target`, return the **number of pairs** of integers in the list that sum up to the target value. Each pair should be counted only once, where the order of the integers in the pair does not matter. You may assume that each input would have exactly one solution, and you may not use the same element twice.","solution":"def count_pairs_with_sum(arr, target): Returns the number of unique pairs of integers in the list that sum up to the target value. seen = set() pairs = set() for num in arr: compliment = target - num if compliment in seen: pairs.add(tuple(sorted([num, compliment]))) seen.add(num) return len(pairs)"},{"question":"You are given a list of `n` integers `height` representing the heights of building blocks. Create an array `water` where `water[i]` represents the maximum amount of water that can be trapped on top of the i-th block after it rains. A block can trap water if and only if there are taller blocks on both its left and right sides. Return the total amount of water trapped across all blocks in the `height` array.","solution":"def trap(height): Returns the total amount of water trapped across all blocks in the height array. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped for i in range(n): water[i] = min(left_max[i], right_max[i]) - height[i] return sum(water)"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. The task is to distribute all `nums` into `k` non-empty subsets such that the difference between the maximum sum of any subset and the minimum sum of any subset is minimized. Return the minimized difference between the maximum and minimum subset sums.","solution":"def minimize_subset_sum_difference(nums, k): Distributes the numbers into k non-empty subsets such that the difference between the maximum sum of any subset and the minimum sum of any subset is minimized. Parameters: nums (list of int): List of non-negative integers. k (int): The number of subsets to divide into. Returns: int: The minimized difference between the maximum and minimum subset sums. if not nums or k == 0: return 0 total_sum = sum(nums) def possible_to_divide(target): partitions = [0] * k nums.sort(reverse=True) def backtrack(index): if index == len(nums): return True for i in range(k): if partitions[i] + nums[index] <= target: partitions[i] += nums[index] if backtrack(index + 1): return True partitions[i] -= nums[index] if partitions[i] == 0: break return False return backtrack(0) left, right = max(nums), total_sum while left < right: mid = (left + right) // 2 if possible_to_divide(mid): right = mid else: left = mid + 1 return left"},{"question":"A company wants to implement a Dynamic Pricing system for their e-commerce platform. The platform sells a series of products where each product has a base price and can go on sale with a certain discount percentage. Your task is to implement the `Pricing` class that manages the prices of these products efficiently. * `Pricing(int[] basePrices)` Initializes the `Pricing` object with an array of integers `basePrices`, where `basePrices[i]` is the base price of the product with id `i`. * `void applyDiscount(int productId, int discountPercentage)` Applies a discount of `discountPercentage` (an integer from `0` to `100`) to the product with the given id. * `int getPrice(int productId)` Returns the current price of the product with the given id after applying any active discount. You may assume that `basePrices` will always have at least one element and `getPrice`/`applyDiscount` calls will always be valid.","solution":"class Pricing: def __init__(self, basePrices): Initializes the Pricing object with an array of integers basePrices. self.basePrices = basePrices self.discounts = [0] * len(basePrices) # Initialize discounts to 0 for all products def applyDiscount(self, productId, discountPercentage): Applies a discount of discountPercentage to the product with the given id. self.discounts[productId] = discountPercentage def getPrice(self, productId): Returns the current price of the product with the given id after applying any active discount. basePrice = self.basePrices[productId] discountPercentage = self.discounts[productId] discountAmount = (discountPercentage / 100) * basePrice return int(basePrice - discountAmount)"},{"question":"You are given a **semicolon-separated** string `timePoints` representing a list of 24-hour format times. Each time is in the format \\"HH:MM\\". Find the minimum difference in minutes between any two time points in the list. Return _the **minimum** difference in minutes between any two time points in the list_.","solution":"def findMinDifference(timePoints): Returns the minimum difference in minutes between any two time points in the list. minutes = [] # Convert each time point to minutes since start of day for time in timePoints: hours, mins = map(int, time.split(\':\')) minutes.append(hours * 60 + mins) # Sort the list of minutes minutes.sort() # Initialize min_diff to the maximum possible value: i.e., the circular difference between # the last and first time points. min_diff = 1440 + minutes[0] - minutes[-1] # Calculate the minimum difference between consecutive time points for i in range(1, len(minutes)): min_diff = min(min_diff, minutes[i] - minutes[i - 1]) return min_diff"},{"question":"Given a matrix `mat` where each row is sorted in non-decreasing order, return _the **smallest** common element in all rows_. If there is no common element, return `-1`. A common element in all rows is an integer that appears in each row of the matrix. Each row may contain duplicates.","solution":"def smallestCommonElement(mat): Returns the smallest common element across all rows of the matrix. If no common element is found, returns -1. if not mat: return -1 from collections import Counter # Initialize counter to count element frequency across all rows counter = Counter() # Number of rows in matrix num_rows = len(mat) # Update counter with elements from each row for row in mat: counter.update(set(row)) # Check for the smallest element that appears in all rows for element in sorted(counter.keys()): if counter[element] == num_rows: return element return -1"},{"question":"Given a string `s`, you need to reverse the vowels in `s`. The vowels are `\\"a\\"`, `\\"e\\"`, `\\"i\\"`, `\\"o\\"`, and `\\"u\\"`, and they can appear in both lowercase and uppercase. Return the modified string where the vowels are reversed, but the positions of the non-vowel characters remain unchanged.","solution":"def reverse_vowels(s): Returns the string with the vowels reversed, while the positions of the non-vowel characters remain unchanged. vowels = \'aeiouAEIOU\' s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 elif s_list[right] not in vowels: right -= 1 else: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list)"},{"question":"You are planning a hiking trip and want to prepare a nutritional meal plan. You have `n` food items, and each food item has a certain number of calories. You want to create a meal plan such that the total calorie intake is as close as possible to `targetCalories`. Given an array `foods` where `foods[i]` is the calorie count of the `ith` food item, and an integer `targetCalories`, return _the minimum difference_ between the total calories of the chosen meal plan and `targetCalories`. You may choose any number of food items (including none), and each food item can be chosen at most once.","solution":"def minimum_calorie_difference(foods, targetCalories): Returns the minimum difference between the total calories of the chosen meal plan and targetCalories. :param foods: List[int], list of calories of each food item :param targetCalories: int, the target calorie intake :return: int, the minimum difference n = len(foods) total_calories = sum(foods) dp = [[False] * (total_calories + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_calories + 1): if dp[i - 1][j]: dp[i][j] = True if j + foods[i - 1] <= total_calories: dp[i][j + foods[i - 1]] = True min_diff = float(\'inf\') for s in range(total_calories + 1): if dp[n][s]: min_diff = min(min_diff, abs(targetCalories - s)) return min_diff"},{"question":"You are given a string `s` that consists of lowercase English letters. You need to encode this string by replacing each group of consecutive identical letters with the letter followed by the count of its repetition. If the count of a letter is `1`, it should be represented as just the letter itself. Return the encoded string. For example, the string \\"aaabbcaaa\\" would be encoded as \\"a3b2ca3\\".","solution":"def encode_string(s): Encodes the string by replacing each group of consecutive identical letters with the letter followed by the count of its repetition. If the count of a letter is 1, it should be represented as just the letter itself. :param s: The input string consisting of lowercase English letters. :return: The encoded string. if not s: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str += s[i - 1] if count > 1: encoded_str += str(count) count = 1 # Don\'t forget to add the last group encoded_str += s[-1] if count > 1: encoded_str += str(count) return encoded_str"},{"question":"You are given a list of words `words` containing `n` strings. The list of words is considered sorted if all the strings are in increasing order according to lexicographical order. You are required to check if the list is sorted and, if not, output the indices of the first pair of words which are out of order. If the list is sorted, return an integer value `-1`. Assume that each word consists of lowercase English letters only. For example, given the input list `words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]`, you would return `-1` because the list is sorted. But for `words = [\\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\"]`, you would return `[1, 2]` because \\"banana\\" and \\"apple\\" are not in the correct order.","solution":"def check_sorted(words): Checks if the given list of words is sorted in lexicographical order. Returns -1 if the list is sorted. Returns the indices of the first pair of words which are out of order if the list is not sorted. for i in range(len(words) - 1): if words[i] > words[i + 1]: return [i, i + 1] return -1"},{"question":"Given a string `s` which consists of lowercase letters and non-letter characters, write a function to reverse only the letters while leaving the non-letter characters in their original positions. Return the reversed string.","solution":"def reverse_only_letters(s): Reverses only the letters in the string while leaving non-letter characters in their original positions. :param s: A string with lowercase letters and non-letter characters :type s: str :return: A string with letters reversed and non-letters in original positions :rtype: str # Extract letters and reverse them letters = [char for char in s if char.isalpha()] letters.reverse() # Result list to build the final string result = [] letter_index = 0 # Construct the result string based on the original positions for char in s: if char.isalpha(): result.append(letters[letter_index]) letter_index += 1 else: result.append(char) return \'\'.join(result)"},{"question":"Write a function `longestConsecutiveSubsequence` that takes an unsorted array of integers `nums` and returns the length of the longest consecutive elements sequence. Your algorithm should run in `O(n)` complexity. The sequence does not need to be in numerical order within the original array, but it must be a consecutive increasing sequence. For example, given the array `nums = [100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore, the function should return its length `4`. Implement the `longestConsecutiveSubsequence` function: ```python def longestConsecutiveSubsequence(nums): # Your code here ``` - The function should accept a list of integers `nums` and return an integer representing the length of the longest consecutive sequence. - Ensure that your solution achieves a time complexity of `O(n)` using a suitable algorithm or data structure.","solution":"def longestConsecutiveSubsequence(nums): Returns the length of the longest consecutive elements sequence in the given unsorted array. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # Only start counting if `num` is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"A company has a list of `n` projects labeled from `0` to `n-1`. Each project can have zero or more dependencies represented as a list of pairs `[a, b]` where project `a` must be completed before project `b` can begin. Write a function to determine if it is possible to complete all the projects given the dependencies. If it is possible, return _a list of projects in the order they should be completed_. If it is not possible, return _an empty list_.","solution":"from collections import defaultdict, deque def find_order(num_projects, dependencies): Determine the order in which projects should be completed given dependencies. :param num_projects: Number of projects :param dependencies: List of dependencies, where each dependency is a pair [a, b] meaning project a must be completed before project b :return: A list of projects in the order they should be completed, or an empty list if it is not possible to complete all projects # Build adjacency list and calculate in-degrees adj_list = defaultdict(list) in_degree = [0] * num_projects for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Find all the projects with no incoming edges zero_in_degree_queue = deque([i for i in range(num_projects) if in_degree[i] == 0]) topological_order = [] while zero_in_degree_queue: project = zero_in_degree_queue.popleft() topological_order.append(project) # Decrease the in-degree of neighboring nodes for neighbor in adj_list[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the topological_sort contains all the projects, it is possible to complete all projects if len(topological_order) == num_projects: return topological_order else: return []"},{"question":"You are given a **0-indexed** array `words` of strings. A string is considered \\"balanced\\" if every letter it contains appears the same number of times. Return an array of the same length as `words` where each element is `true` if the corresponding string in `words` is balanced or `false` otherwise.","solution":"def is_balanced_word(word): Checks if a word is balanced. A word is balanced if each character appears the same number of times. from collections import Counter char_count = Counter(word) counts = list(char_count.values()) return all(count == counts[0] for count in counts) def check_balanced_words(words): Given a list of words, this function returns a list of booleans indicating if each word is balanced. return [is_balanced_word(word) for word in words]"},{"question":"You are given a list of `tasks`, where each task is represented by an integer `id`, and a list of `dependencies` where each dependency is a pair of tasks `[a, b]` indicating that task `a` needs to be completed before task `b`. Return the order in which to complete the tasks to satisfy all dependencies, or return an empty list if it is impossible to complete all tasks due to circular dependencies. Tasks have unique IDs and it is guaranteed that there are no duplicate dependencies.","solution":"from collections import defaultdict, deque def find_task_order(tasks, dependencies): Given a list of tasks and dependencies, return the order of tasks to complete all tasks with given dependencies, or an empty list if it is impossible due to circular dependencies. Args: tasks (list): List of unique task IDs. dependencies (list): List of dependencies where a dependency [a, b] means task a needs to be completed before task b. Returns: list: The order in which to complete the tasks, or an empty list if circular dependencies detected. # Graph initialization graph = defaultdict(list) in_degree = {task: 0 for task in tasks} # Dictionary to track in-degrees # Build the graph for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Queue initialization with tasks having 0 in-degree queue = deque([task for task in tasks if in_degree[task] == 0]) order = [] while queue: task = queue.popleft() order.append(task) for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If order contains all tasks, return it; otherwise, return an empty list return order if len(order) == len(tasks) else []"},{"question":"Given an array of integers `nums`, return _the **longest subsequence** of consecutive elements_. A **consecutive element** is defined as an element `x` such that `x + 1` or `x - 1` is also present in the array. Your solution should be efficient, aiming for linear time complexity.","solution":"def longest_consecutive_subsequence(nums): Returns the longest subsequence of consecutive elements. if not nums: return [] num_set = set(nums) longest_seq = [] for num in nums: if num - 1 not in num_set: # start of a new sequence current_num = num current_seq = [current_num] while current_num + 1 in num_set: current_num += 1 current_seq.append(current_num) if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"Given a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, the second node even, and so on. Note that the relative order inside both the odd and even groups should remain as it was in the input. You may assume the linked list is non-empty and contains at least one node.","solution":"# Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): Groups all the nodes with odd indices together followed by the nodes with even indices and returns the reordered list. if not head or not head.next: return head # Initialize two pointers: one for odd index nodes and one for even index nodes. odd = head even = head.next even_head = even # to connect the end of odd-index nodes to the start of even-index nodes. while even and even.next: odd.next = odd.next.next # Points to the next odd indexed node even.next = even.next.next # Points to the next even indexed node odd = odd.next even = even.next odd.next = even_head # Connect the end of odd-indexed list to the start of even-indexed list. return head"},{"question":"Given a string `s` consisting of lowercase English letters, set a limit `k` on the number of distinct letters in the string. Modify the string such that the length of the longest substring containing at most `k` distinct letters is maximized. Return the length of that substring.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct letters. :param s: A string consisting of lowercase English letters :param k: An integer representing the limit on the number of distinct letters :return: The length of the longest substring with at most k distinct letters if k == 0 or not s: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): char = s[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > k: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of positive integers representing the height of each tree in a row where the trees must remain in the original order. Each day, you are allowed to cut a single tree down and remove it from the row, with the condition that no two adjacent trees have the same height after removal. Write a function to determine the minimum number of days required to ensure that no two adjacent trees have the same height. If it’s not possible to achieve this condition, return -1.","solution":"def min_days_to_unique_heights(trees): Determines the minimum number of days required to ensure that no two adjacent trees have the same height. If it’s not possible to achieve this condition, returns -1. # Early low-length check cases if not trees: return 0 if len(trees) == 1: return 0 days = 0 n = len(trees) # Check for each tree if it can be removed to satisfy the condition i = 0 while i < len(trees) - 1: if trees[i] == trees[i + 1]: days += 1 if i + 2 < n: trees.pop(i + 1) else: trees.pop(i) else: i += 1 # Verify all adjacent trees have different heights (final check) for i in range(1, len(trees)): if trees[i] == trees[i - 1]: return -1 return days"},{"question":"Given a binary tree, implement an algorithm to serialize and deserialize it. Serialization is the process of converting a tree to a single string representation, while deserialization is the process of converting the string back to the original tree structure. Implement the `Codec` class: * `serialize(root)` which takes the root of the binary tree and returns the serialized string representation of the tree. * `deserialize(data)` which takes a serialized string representation of the tree and returns the root of the deserialized binary tree. You may assume that the binary tree consists of integer values, and it is a complete binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. def dfs(node): if not node: result.append(\'#\') return result.append(str(node.val)) dfs(node.left) dfs(node.right) result = [] dfs(root) return \',\'.join(result) def deserialize(self, data): Decodes your encoded data to tree. def dfs(): if vals[self.index] == \'#\': self.index += 1 return None node = TreeNode(int(vals[self.index])) self.index += 1 node.left = dfs() node.right = dfs() return node vals = data.split(\',\') self.index = 0 return dfs()"},{"question":"Given a list of integers `heights` representing the heights of students standing in a line, you are required to return the minimum number of students that need to be moved such that the line becomes **non-decreasing** by height. In other words, find the minimum number of indices i in `heights` such that if you remove the students at these indices, the remaining students are in non-decreasing order of their height.","solution":"def min_students_to_move(heights): Returns the minimum number of students that need to be moved for the line to become non-decreasing in height. n = len(heights) # If the list is empty or has only one student, no need to move any student if n <= 1: return 0 # Create an array to store the length of the longest increasing subsequence (LIS) until each index lis = [1] * n # Calculate the LIS for each index for i in range(1, n): for j in range(0, i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest non-decreasing subsequence longest_non_decreasing_subseq = max(lis) # The minimum number of students to move is the total number of students # minus the length of the longest non-decreasing subsequence return n - longest_non_decreasing_subseq"},{"question":"You are given a **positive** integer `k` and an array of integers `nums`. Your task is to determine **if there is** a **subarray** of `nums` (contiguous elements) which sums up to `k`. Return _a boolean value_ `true` _if such a subarray exists, otherwise_ `false`.","solution":"def subarray_sum(nums, k): Determines if there is a subarray of nums which sums up to k. Args: nums: list of integers k: target sum (integer) Returns: bool: True if there exists a subarray that sums up to k, otherwise False. current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_dict: return True sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1 return False"},{"question":"You are given a string `s` containing only lowercase English letters. A substring is called a \\"good substring\\" if there are no repeated characters within the substring. Your task is to find the length of the longest \\"good substring\\" that can be made from `s`. Implement a function that takes `s` as input and returns the length of the longest \\"good substring\\". If the string is empty, return `0`.","solution":"def length_of_longest_good_substring(s): Finds the length of the longest \'good substring\' where no characters are repeated. Parameters: s (str): The input string containing only lowercase English letters Returns: int: Length of the longest good substring n = len(s) max_len = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: # Move the start to the right of the same character last found start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an array of integers `nums` where `nums[i]` represents the ith person\'s position in a group. Each person can either be in group A or group B. A conflict occurs if two people who dislike each other are in the same group. Given an array `dislikes` where `dislikes[i] = [a, b]` indicates that the ith person `a` dislikes person `b`, return `true` if it is possible to split everyone into two groups such that no two people who dislike each other are in the same group. Otherwise, return `false`.","solution":"def possible_bipartition(n, dislikes): from collections import defaultdict, deque def bfs(node): queue = deque([node]) color[node] = 1 while queue: curr = queue.popleft() for neighbor in graph[curr]: if color[neighbor] == 0: color[neighbor] = -color[curr] queue.append(neighbor) elif color[neighbor] == color[curr]: return False return True graph = defaultdict(list) for a, b in dislikes: graph[a].append(b) graph[b].append(a) color = [0] * (n + 1) for i in range(1, n + 1): if color[i] == 0: if not bfs(i): return False return True"},{"question":"You are given a **0-indexed** integer array `nums`. In one operation, you can increment or decrement any element of `nums` by `1`. You want to make all the elements in `nums` equal. Return _the minimum number of operations needed to make all elements of_ `nums` _the same_.","solution":"def min_operations(nums): Returns the minimum number of operations needed to make all elements of nums the same. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"You are given a grid `grid` of size `m x n` consisting of non-negative integers. The grid represents a city where `grid[i][j]` is the cost of crossing the cell `(i, j)`. You start at the top-left corner of the grid and you want to reach the bottom-right corner of the grid in such a way that the total cost is minimized. You can move right or down from a cell at any point. Return the minimum cost to reach the bottom-right corner.","solution":"def minPathSum(grid): Calculates the minimum path sum from top-left to bottom-right of a grid by only moving right or down at each step. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row and first column with their respective # cumulative sums since there\'s only one way to reach those cells. for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] # Build the cumulative cost for each cell by choosing the minimum path sum # from either the cell above or the cell to the left. for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) # The bottom-right corner will have the minimum path sum. return grid[m - 1][n - 1]"},{"question":"You are given a string `s` that contains lowercase English letters and can include underscores (`_`). An underscore can replace any single lowercase English letter, potentially creating multiple valid words. Your task is to return the list of all possible distinct strings formed after replacing every underscore in `s` with a lowercase English letter. The strings in the returned list should be in lexicographical order. If there are no underscores, return the original string in a list. The input will guarantee at least one underscore in the string.","solution":"from itertools import product def generate_strings(s): Given a string \'s\' with underscores, return all possible strings by replacing each underscore with any lowercase English letter. positions = [i for i, char in enumerate(s) if char == \'_\'] if not positions: return [s] replacements = product(\'abcdefghijklmnopqrstuvwxyz\', repeat=len(positions)) results = [] for replacement in replacements: string_list = list(s) for pos, char in zip(positions, replacement): string_list[pos] = char results.append(\\"\\".join(string_list)) return sorted(results)"},{"question":"You are given an integer array `nums` consisting of `2n` elements where `n` is a positive integer. You need to arrange these elements into `n` pairs such that the sum of the minimum values of each pair is maximized. Return the maximized sum of the paired minimums. For example, for the array `nums = [1,4,3,2]`, you can form the pairs (1,2) and (3,4). The sum of the minimum values of these pairs is `1 + 3 = 4`, which is the maximum possible in this case.","solution":"def arrayPairSum(nums): Given an integer array of 2n elements, this function returns the maximized sum of the minimum values of n pairs. nums.sort() return sum(nums[::2])"},{"question":"Given a collection of intervals, merge all overlapping intervals. Each interval is represented as an array of two integers `[start, end]`. Your function should return an array of the merged intervals in ascending order by their start time.","solution":"def merge_intervals(intervals): Merges all overlapping intervals. Args: intervals (List[List[int]]): A list of intervals, where each interval is represented as [start, end]. Returns: List[List[int]]: A list of merged intervals in ascending order by their start time. if not intervals: return [] # Sort the intervals based on the start times intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged"},{"question":"You are given an array of positive integers `nums` and an integer `x`. You can decrease or increase each element in `nums` by at most `x` units. Determine if it is possible to make all elements in the array equal after performing the allowed modifications. Return `true` if it is possible, or `false` otherwise.","solution":"def can_make_elements_equal(nums, x): Determine if it is possible to make all elements in the array `nums` equal by increasing or decreasing each element by at most `x` units. Parameters: nums (list): list of positive integers x (int): the maximum units each element can be increased or decreased Returns: bool: True if it\'s possible to make all elements equal, False otherwise min_val = min(nums) max_val = max(nums) # We can make all elements equal if the difference between # the max and min values is less than or equal to 2 times x return (max_val - min_val) <= 2 * x"},{"question":"You are given a grid of size `n * m` where each cell can be one of three states: `0` representing an empty cell, `1` representing a wall, and `2` representing a target cell. Your task is to determine the minimum number of steps required to move from the top-left corner of the grid to the nearest target cell (represented by `2`). You can only move up, down, left, or right, and you cannot move through walls (represented by `1`). If it is impossible to reach any target cell, return `-1`.","solution":"from collections import deque def min_steps_to_target(grid): Returns the minimum number of steps required to move from the top-left corner of the grid to the nearest target cell (represented by `2`). Return `-1` if it is impossible. n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Possible movements (up, down, left, right) visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, column, steps) visited[0][0] = True if grid[0][0] == 2: return 0 while queue: row, col, steps = queue.popleft() for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < m and not visited[r][c] and grid[r][c] != 1: if grid[r][c] == 2: return steps + 1 visited[r][c] = True queue.append((r, c, steps + 1)) return -1 # If no path found"},{"question":"You are given an array of strings called `words` where each word consists of lowercase English letters. A word `w1` is a prefix of another word `w2` if and only if `w2` starts with `w1`. Return _the **longest word** in `words` that is a **prefix** of at least one other word_ in `words`. If there are multiple such words of the same length, return the one that appears **first** in the array. If no such word exists, return an empty string `\\"\\"`.","solution":"def longest_prefix_word(words): Returns the longest word in `words` that is a prefix of at least one other word in `words`. If there are multiple such words of the same length, returns the one that appears first. If no such word exists, returns an empty string. words_set = set(words) longest_word = \\"\\" for word in words: for i in range(1, len(word)): if word[:i] in words_set: if len(word[:i]) > len(longest_word): longest_word = word[:i] elif len(word[:i]) == len(longest_word): longest_word = word[:i] if words.index(word[:i]) < words.index(longest_word) else longest_word return longest_word"},{"question":"Given an array of integers `nums`, write a function that finds the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to a given integer `limit`. Example: ```python Input: nums = [8, 2, 4, 7], limit = 4 Output: 2 Input: nums = [10, 1, 2, 4, 7, 2], limit = 5 Output: 4 Input: nums = [4, 2, 2, 2, 4, 4, 2, 2], limit = 0 Output: 3 ``` **Constraints**: - 1 <= nums.length <= 10^5 - -10^9 <= nums[i] <= 10^9 - 0 <= limit <= 10^9","solution":"def longest_subarray(nums, limit): Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to the given limit. from collections import deque max_d = deque() min_d = deque() left = 0 max_length = 0 for right in range(len(nums)): while max_d and nums[right] > max_d[-1]: max_d.pop() while min_d and nums[right] < min_d[-1]: min_d.pop() max_d.append(nums[right]) min_d.append(nums[right]) while max_d[0] - min_d[0] > limit: if max_d[0] == nums[left]: max_d.popleft() if min_d[0] == nums[left]: min_d.popleft() left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `heights` representing the heights of buildings and a positive integer `limit`. You are allowed to remove buildings such that the difference between the heights of any two adjacent buildings is less than or equal to `limit`. Return _the minimum number of buildings that need to be removed to satisfy this condition_.","solution":"def min_removals_to_satisfy_limit(heights, limit): n = len(heights) if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if abs(heights[i] - heights[j]) <= limit: dp[i] = max(dp[i], dp[j] + 1) max_valid_length = max(dp) return n - max_valid_length"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. You can make one operation to remove a contiguous subarray from `nums` such that the sum of the remaining elements in the array is equal to `target`. Return the length of the smallest subarray that can be removed to achieve this. If it is impossible, return `-1`.","solution":"def minSubarrayLength(nums, target): total_sum = sum(nums) # If the total sum is already equal to the target if total_sum == target: return 0 subarray_sum_needed = total_sum - target if subarray_sum_needed < 0: return -1 left = 0 current_sum = 0 min_length = float(\'inf\') for right in range(len(nums)): current_sum += nums[right] while current_sum > subarray_sum_needed and left <= right: current_sum -= nums[left] left += 1 if current_sum == subarray_sum_needed: min_length = min(min_length, right - left + 1) return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting only of lowercase alphabetical characters. Your task is to determine if it is possible to make the two strings **identical** by at most one **swapping** of two characters within one of the strings. Return _true_ if it is possible to make the strings identical with at most one swap, otherwise return _false_. **Note**: A swap involves choosing two positions in one of the strings and exchanging the characters at these positions.","solution":"def are_one_swap_away(s1, s2): Determines if two strings can be made identical with at most one character swap. if s1 == s2: return True diff_indices = [] for i in range(len(s1)): if s1[i] != s2[i]: diff_indices.append(i) if len(diff_indices) > 2: return False if len(diff_indices) != 2: return False i, j = diff_indices return s1[i] == s2[j] and s1[j] == s2[i]"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to return _the maximum possible sum of the elements of an exactly `k` size subarray that can be formed in the array_. If the array has fewer than `k` elements, return `-1`. Note that subarray in this context means a contiguous part of the array. For example, given `nums = [2, 1, 5, 1, 3, 2]` and `k = 3`, the subarray `[5, 1, 3]` has the maximum sum which is `9` so the function should return `9`.","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of an exactly k size subarray from the list nums. If the array has fewer than k elements, return -1. if len(nums) < k: return -1 max_sum = cur_sum = sum(nums[:k]) for i in range(k, len(nums)): cur_sum += nums[i] - nums[i - k] max_sum = max(max_sum, cur_sum) return max_sum"},{"question":"Write a function that takes two strings `s1` and `s2`, which represent two large non-negative integers. The function should return a string representing their product. You should not convert the inputs to integers directly because they can be very large. Implement the multiplication manually using the technique similar to how we multiply numbers on paper.","solution":"def multiply_strings(s1, s2): Multiplies two large non-negative integers represented as strings. if s1 == \\"0\\" or s2 == \\"0\\": return \\"0\\" len1, len2 = len(s1), len(s2) result = [0] * (len1 + len2) s1 = s1[::-1] s2 = s2[::-1] for i in range(len1): for j in range(len2): result[i + j] += int(s1[i]) * int(s2[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"Given a list of non-negative integers `heights`, each representing the height of a bar at a specific index, where the width of each bar is 1, compute _the **maximum area** of a rectangle formed by the bars_. The rectangle must be contiguous, meaning the bars included in the rectangle are next to each other. For example, given the heights `[2, 1, 5, 6, 2, 3]`, the maximum area is `10` (formed by the bars `5` and `6`).","solution":"def largest_rectangle_area(heights): Returns the maximum area of a rectangle formed by the bars in `heights`. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an integer array `nums` of length `n`, return _the maximum sum you can obtain by selecting non-adjacent elements from the array_. You are not allowed to select consecutive elements, and each element can be selected at most once. Implement a function `maxSumNonAdjacent(nums: List[int]) -> int` that returns the maximum sum obtainable. # Example ``` Input: nums = [2, 1, 4, 9] Output: 11 Input: nums = [3, 2, 5, 10, 7] Output: 15 ``` # Constraints - `1 <= nums.length <= 1000` - `-1000 <= nums[i] <= 1000`","solution":"def maxSumNonAdjacent(nums): Given an integer array nums, return the maximum sum obtainable by selecting non-adjacent elements. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) # dp[i] will store the maximum sum of non-adjacent elements from nums[0] to nums[i] dp = [0] * n dp[0] = max(0, nums[0]) dp[1] = max(dp[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given an array representing a mountain, where the array elements initially increase up to a peak, then decrease. Your task is to find the peak element, which is the maximum element in the array. However, the array doesn\'t guarantee to be well-formed (increasing then decreasing), and you need to account for edge cases. You should implement a function that returns the index of the peak element. If there are multiple peaks, return the index of any one of the peaks.","solution":"def find_peak(arr): Returns the index of a peak element in the array. :param arr: List[int] - The input array representing a mountain. :return: int - Index of one of the peak elements. if not arr: return -1 left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"Given an array of `n` distinct integers, your task is to determine if there is a subset of these integers that sums to a given target value `k`. Return `true` if such a subset exists, otherwise return `false`.","solution":"def subset_sum(arr, k): Determine if there is a subset of the array `arr` that sums to `k`. :param arr: List of distinct integers :param k: Target sum to find in the subsets of `arr` :return: True if a subset with sum `k` exists, otherwise False n = len(arr) dp = [[False] * (k + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, k + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][k]"},{"question":"Given two strings `s1` and `s2`, write a function that determines if `s2` can be obtained by rotating `s1` some number of times. For example, if `s1` is `\\"abcd\\"` and `s2` is `\\"cdab\\"`, then `s2` is a rotation of `s1` because rotating `\\"abcd\\"` by 2 positions to the right results in `\\"cdab\\"`. Note that the function should be case sensitive. If `s2` can be obtained by rotating `s1`, return `true`, otherwise return `false`.","solution":"def is_rotation(s1, s2): Determines if s2 can be obtained by rotating s1 some number of times. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"You are given an `m x n` grid filled with non-negative numbers representing the weight of gold in each cell. Your goal is to find a path from the top-left corner to the bottom-right corner which minimizes the sum of the weights of the cells along the path. You can only move to the right or down from a given cell. Return the minimum sum of weights along such a path.","solution":"def min_path_sum(grid): Returns the minimum sum of weights along the path from the top-left corner to the bottom-right corner of a grid where you can only move to the right or down from a given cell. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `k`. Your task is to remove exactly `k` characters from the string such that the resultant string has the **maximum** possible number of distinct characters. Return _the length of the resultant string_.","solution":"def max_distinct_length_after_removals(s, k): Returns the length of the resultant string after removing exactly k characters to maximize the number of distinct characters. from collections import Counter # Step 1: Count the frequency of each character in the string freq = Counter(s) # Step 2: Convert the frequency dictionary to a list of (character, frequency) pairs freq_items = sorted(freq.items(), key=lambda item: item[1]) # Step 3: Remove characters with the lowest frequency until k removals are done removed_count = 0 distinct_chars = len(freq_items) for char, count in freq_items: if removed_count + count <= k: removed_count += count distinct_chars -= 1 else: break # Step 4: Calculate the length of the resultant string resultant_length = len(s) - k return resultant_length if resultant_length >= distinct_chars else distinct_chars"},{"question":"You are given an integer array `heights` representing the heights of people standing in a queue. Implement a function to determine the minimum number of adjacent swaps necessary to sort the array in non-decreasing order of heights, where each swap can only involve elements that are in consecutive positions in the array. Return _the minimum number of adjacent swaps needed to sort the array._","solution":"def count_swaps(arr): Returns the minimum number of adjacent swaps needed to sort the array. n = len(arr) swaps = 0 for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return swaps"},{"question":"You are given a list of `n` integers representing the stock prices of a company over `n` consecutive days. You can complete at most one transaction, which means you can buy one and sell one share of the stock over the given period. Return **the maximum profit** you can achieve from this transaction. If you cannot achieve any profit, return `0`.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy-sell transaction. :param prices: List of stock prices over n consecutive days :type prices: list :return: Maximum profit from a single transaction :rtype: int if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given a binary array `data`, return the minimum number of swaps required to group all `1`s present in the array together in any place in the array. You can only swap the positions of the elements within the array. The function should return an integer representing the minimum number of swaps needed.","solution":"def min_swaps_to_group_ones(data): Returns the minimum number of swaps required to group all 1\'s together in the array. n = len(data) total_ones = sum(data) if total_ones == 0 or total_ones == n: return 0 max_ones_in_window = 0 current_ones_in_window = 0 for i in range(total_ones): if data[i] == 1: current_ones_in_window += 1 max_ones_in_window = current_ones_in_window for i in range(total_ones, n): if data[i] == 1: current_ones_in_window += 1 if data[i - total_ones] == 1: current_ones_in_window -= 1 max_ones_in_window = max(max_ones_in_window, current_ones_in_window) return total_ones - max_ones_in_window"},{"question":"Given an array of positive integers `arr` and an integer `target`, find the length of the shortest subarray whose sum is at least `target`. If there is no such subarray, return `0` instead. A **subarray** is a contiguous part of an array. Use the sliding window technique to solve this problem efficiently.","solution":"def min_subarray_len(arr, target): Returns the length of the shortest subarray where the sum is at least \'target\'. If there is no such subarray, returns 0. Uses the sliding window technique. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"Write a function that takes a string `s` and returns all anagrams of a given target string `t` present in `s`. An anagram is a rearrangement of all the characters in `t`. The result should be a list of starting indices of the anagrams found in `s`. The output list should be sorted in ascending order of indices. For example, given `s = \\"cbaebabacd\\"` and `t = \\"abc\\"`, the function should return `[0, 6]` since the substrings starting at indices `0` (\\"cba\\") and `6` (\\"bac\\") are anagrams of `t` (\\"abc\\").","solution":"def find_anagrams(s, t): from collections import Counter result = [] t_counter = Counter(t) window_counter = Counter(s[:len(t) - 1]) for i in range(len(t) - 1, len(s)): start_index = i - len(t) + 1 window_counter[s[i]] += 1 if window_counter == t_counter: result.append(start_index) window_counter[s[start_index]] -= 1 if window_counter[s[start_index]] == 0: del window_counter[s[start_index]] return sorted(result)"},{"question":"Given an array of integers nums and an integer k, return the maximum length of a subarray that sums to k. If no such subarray exists, return 0. A subarray is a contiguous part of an array.","solution":"def max_subarray_len(nums, k): Returns the maximum length of a subarray that sums to k. :param nums: List[int] - List of integers :param k: int - Target sum :return: int - Maximum length of subarray that sums to k sum_map = {} curr_sum = 0 max_len = 0 for i in range(len(nums)): curr_sum += nums[i] if curr_sum == k: max_len = i + 1 if (curr_sum - k) in sum_map: max_len = max(max_len, i - sum_map[curr_sum - k]) if curr_sum not in sum_map: sum_map[curr_sum] = i return max_len"},{"question":"Given a binary tree, return the inorder traversal of its nodes\' values but exclude nodes with a value of `0`. The inorder traversal means visiting the left subtree first, then the root node, and finally the right subtree. Do not use recursion; instead, utilize an iterative approach with the help of a stack.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values, excluding nodes with a value of 0. Args: root (TreeNode): The root of the binary tree. Returns: List[int]: The inorder traversal of the tree excluding nodes with value 0. stack = [] current = root result = [] while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() if current.val != 0: result.append(current.val) current = current.right return result"},{"question":"You are given a string `s` and an integer `k`. You need to divide the string `s` into `k` contiguous substrings such that each substring is non-empty and the product of the lengths of these `k` substrings is maximized. Return _the **maximum** possible product of the lengths of the `k` substrings._ If it is not possible to divide the string into `k` non-empty substrings, return `-1`.","solution":"def max_product_of_lengths(s, k): Returns the maximum possible product of the lengths of k contiguous non-empty substrings. If it\'s not possible to divide the string s into k non-empty substrings, return -1. n = len(s) if k > n: return -1 base_len = n // k extra = n % k lengths = [base_len] * k for i in range(extra): lengths[i] += 1 product = 1 for length in lengths: product *= length return product"},{"question":"You are given an `m x n` binary matrix `grid` which represents a map of `1`s (land) and `0`s (water). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write a function to count the number of islands. An island is defined as a group of `1`s connected vertically or horizontally, but not diagonally. **Function Signature:** ```python def numIslands(grid: List[List[int]]) -> int: ```","solution":"def numIslands(grid): Returns the number of islands in the given m x n binary matrix grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. if not grid or not grid[0]: return 0 def dfs(grid, r, c): grid[r][c] = 0 for x, y in [(r-1,c), (r+1,c), (r,c-1), (r,c+1)]: if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: dfs(grid, x, y) islands = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: dfs(grid, r, c) islands += 1 return islands"},{"question":"You are given an integer array `arr` of size `n` which can be rotated. Your task is to find the index of the smallest element in the array. The array might have been rotated at some pivot unknown to you beforehand (i.e., an original sorted array might have been rotated by some number of positions). Assume there are no duplicate elements in the array. Return _the index of the smallest element_.","solution":"def find_min_index(arr): Finds the index of the smallest element in the rotated sorted array. Parameters: arr (list): A list of integers which is a rotated sorted array. Returns: int: The index of the smallest element in the array. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 # Check if middle element is greater than the rightmost element if arr[mid] > arr[right]: left = mid + 1 else: right = mid return left"},{"question":"You are given an integer array `arr` representing the prices of items on successive days. You can perform at most one transaction (i.e., buy one and sell one item). Write a function to find the maximum profit you can achieve by buying on one day and selling on another later day. If no profit can be made, return 0.","solution":"def max_profit(arr): Finds the maximum profit that can be achieved by buying on one day and selling on another later day. Parameters: arr (list of int): List of prices of items on successive days. Returns: int: Maximum profit or 0 if no profit can be made. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"Given an array of integers `nums`, your task is to determine if you can partition the array into consecutive subsequences of length at least 3. A subsequence is defined as a sequence that appears in the same relative order but not necessarily consecutively. For example, `[1, 2, 3]` and `[2, 3, 4, 5]` are consecutive subsequences. Write a function to check if such a partitioning is possible and return `true` or `false`.","solution":"from collections import Counter, defaultdict def is_possible(nums): Determine if it is possible to partition the array into consecutive subsequences of length at least 3. Parameters: nums (List[int]): List of integers Returns: bool: Returns True if partitioning is possible, otherwise False. if not nums: return False count = Counter(nums) end_count = defaultdict(int) for num in nums: if count[num] == 0: continue elif end_count[num - 1] > 0: end_count[num - 1] -= 1 end_count[num] += 1 elif count[num + 1] > 0 and count[num + 2] > 0: count[num + 1] -= 1 count[num + 2] -= 1 end_count[num + 2] += 1 else: return False count[num] -= 1 return True"},{"question":"A sequence of numbers is called a **Fibonacci-like sequence** if it satisfies the following conditions: 1. The sequence contains at least three elements. 2. The elements of the sequence are such that `A[i] = A[i-1] + A[i-2]` for all `i` >= 2. Given a list of positive integers `arr`, return _the length of the longest Fibonacci-like subsequence of `arr`_. If no such sequence exists, return `0`. A subsequence is derived from another sequence `arr` by deleting some or no elements without changing the order of the remaining elements.","solution":"def lenLongestFibSubseq(arr): Returns the length of the longest Fibonacci-like subsequence of arr. If no such sequence exists, return 0. if len(arr) < 3: return 0 indices = {x: i for i, x in enumerate(arr)} longest = {} max_len = 0 for k in range(len(arr)): for j in range(k): if arr[k] - arr[j] in indices and indices[arr[k] - arr[j]] < j: i = indices[arr[k] - arr[j]] if (i, j) in longest: longest[j, k] = longest[i, j] + 1 else: longest[j, k] = 3 max_len = max(max_len, longest[j, k]) return max_len"},{"question":"Given a binary tree, return the _bottom-up level order traversal_ of its nodes\' values. (i.e., from left to right, level by level from leaf to root). Each level should be represented as a separate sub-array inside a parent array.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_bottom(root): Returns the bottom-up level order traversal of the binary tree nodes\' values. if not root: return [] result = deque() queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level) return list(result)"},{"question":"You are given an array of integers `nums` where each integer is either `0` (representing water) or `1` (representing land). You want to count the number of islands in `nums`. An island is formed by grouping all the adjacent `1`s connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write an algorithm that returns the number of islands.","solution":"def num_islands(grid): Given a 2D grid of \'1\'s (land) and \'0\'s (water), count the number of islands. :param grid: List[List[int]] :return: int if not grid: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # mark as visited dfs(i + 1, j) # down dfs(i - 1, j) # up dfs(i, j + 1) # right dfs(i, j - 1) # left count = 0 for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == 1: count += 1 dfs(i, j) return count"},{"question":"You are given a list of integers `nums` and an integer `target`. Return _the **length** of the **longest subsequence** of `nums` that sums up to_ `target`. A subsequence is derived from the list by deleting some or no elements without changing the order of the remaining elements. If no such subsequence can be found, return `-1`.","solution":"def longest_subsequence_sum(nums, target): Returns the length of the longest subsequence of nums that sums up to target. If no such subsequence is found, returns -1. from itertools import combinations max_length = -1 for i in range(len(nums) + 1): for combo in combinations(nums, i): if sum(combo) == target: max_length = max(max_length, len(combo)) return max_length"},{"question":"Given a list of `n` integers, determine the length of the longest subsequence such that the difference between adjacent elements in this subsequence is either `1` or `-1`.","solution":"def longest_subsequence(nums): Returns the length of the longest subsequence such that the difference between adjacent elements is either 1 or -1. Args: nums: A list of integers Returns: An integer representing the length of the longest subsequence if not nums: return 0 max_length = 1 curr_length = 1 for i in range(1, len(nums)): if abs(nums[i] - nums[i - 1]) == 1: curr_length += 1 max_length = max(max_length, curr_length) else: curr_length = 1 return max_length"},{"question":"You are given a tree (i.e., a connected, undirected graph with no cycles) with `n` nodes labeled from `1` to `n`. Each node has a certain value. You are also given `q` queries, each asking for the sum of node values in the subtree of a specified node. Write a function `sumOfSubtreeValues(tree, values, queries)` where `tree` is a list of tuples representing the edges between nodes, `values` is a list of integers representing the value at each node, and `queries` is a list of integers where each integer represents the root of a subtree for which you need to compute the sum of node values. Return a list of integers where each element is the answer to the corresponding query.","solution":"def sumOfSubtreeValues(tree, values, queries): from collections import defaultdict, deque def bfs_calculate_subtree_sums(n, tree, values): graph = defaultdict(list) for u, v in tree: graph[u].append(v) graph[v].append(u) subtree_sum = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): visited[node] = True current_sum = values[node - 1] for neighbor in graph[node]: if not visited[neighbor]: current_sum += dfs(neighbor) subtree_sum[node] = current_sum return current_sum for i in range(1, n + 1): if not visited[i]: dfs(i) return subtree_sum n = len(values) subtree_sum = bfs_calculate_subtree_sums(n, tree, values) result = [] for query in queries: result.append(subtree_sum[query]) return result"},{"question":"You are given an integer array `arr` and an integer `k`. Return _the length of the longest subarray where the number of occurrences of any element is at most_ `k`. A **subarray** is a contiguous sequence of elements within an array.","solution":"from collections import defaultdict def longest_subarray_with_at_most_k_occurrences(arr, k): Returns the length of the longest subarray where the number of occurrences of any element is at most k. left = 0 freq = defaultdict(int) max_length = 0 for right in range(len(arr)): freq[arr[right]] += 1 while freq[arr[right]] > k: freq[arr[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `nums`, where each element in the array represents the amount of money at each house. You are a thief planning to rob houses along a street. However, you cannot rob two adjacent houses because doing so would alert the police. Instead, create a strategy to maximize the total amount of money you can rob. Return _the maximum amount of money you can rob without alerting the police_.","solution":"def rob(nums): Given an array of integers representing the amount of money at each house, this function returns the maximum amount of money you can rob without alerting the police. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) prev1, prev2 = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): current = max(prev1 + nums[i], prev2) prev1 = prev2 prev2 = current return prev2"},{"question":"A matrix `mat` of size `n x n` consists of positive integers. You can perform any of the following operations any number of times: - Swap any two elements in the same row. - Swap any two elements in the same column. Given an integer `k`, determine the minimum possible value of the element at the cell `(k, k)` after performing the allowed operations. The result should be the element that remains at the specified cell after reaching the minimum possible configuration. Return that minimum value.","solution":"def min_value_at_kk(mat, n, k): Given a matrix `mat` of size `n x n` and an integer `k`, determines the minimum possible value of the element at the cell `(k, k)` after performing allowed operations any number of times. :param mat: List of List of integers representing the matrix :param n: Integer representing the size of the matrix :param k: Integer representing the cell to minimize :return: Integer representing the minimum value at cell (k, k) # Collect all the values that can be brought into (k, k) possible_values = set() # k-th row and k-th column for i in range(n): possible_values.add(mat[k][i]) possible_values.add(mat[i][k]) # Return the minimum value from these possible values return min(possible_values)"},{"question":"You are given two integer arrays `arr1` and `arr2` of length `n`, representing the coordinates of points in a 2D plane. The `i`-th point in this plane has coordinates `(arr1[i], arr2[i])`. Your task is to find a pair of distinct points such that the distance between them is minimized, and return the indices of these two points as a list `[i, j]` with `i < j`. The distance between two points `(x1, y1)` and `(x2, y2)` is calculated as `|x1 - x2| + |y1 - y2|`, where `|a|` denotes the absolute value of `a`. If there are multiple pairs with the same minimum distance, you may return any of them.","solution":"def min_distance_pair(arr1, arr2): Finds the pair of distinct points such that the distance between them is minimized. Returns the indices of these two points as a list [i, j] with i < j. n = len(arr1) min_distance = float(\'inf\') min_pair = None for i in range(n): for j in range(i + 1, n): distance = abs(arr1[i] - arr1[j]) + abs(arr2[i] - arr2[j]) if distance < min_distance: min_distance = distance min_pair = [i, j] return min_pair"},{"question":"You are given two **0-indexed** integer arrays `startTime` and `endTime`, each of length `n`, representing the start and end times of `n` tasks. Task `i` starts at `startTime[i]` and ends at `endTime[i]`. You are also given an integer `queryTime`. Write a function that returns the number of tasks that are active at `queryTime`. A task is considered active at `queryTime` if `startTime[i] <= queryTime <= endTime[i]`.","solution":"def count_active_tasks(startTime, endTime, queryTime): Returns the number of tasks that are active at the given queryTime. A task is considered active at queryTime if startTime[i] <= queryTime <= endTime[i]. Parameters: startTime (list of int): List of start times of tasks. endTime (list of int): List of end times of tasks. queryTime (int): The query time to check for active tasks. Returns: int: The number of active tasks at queryTime. return sum(1 for start, end in zip(startTime, endTime) if start <= queryTime and queryTime <= end)"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to write a function that returns the node values in zigzag level order traversal of the tree. (i.e., from left to right, then right to left for the next level and alternate between). For example, given a tree like this: ``` 3 / 9 20 / 15 7 ``` The zigzag level order traversal would be: ``` [ [3], [20, 9], [15, 7] ] ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] results = [] nodes = deque([root]) left_to_right = True while nodes: level = deque() for _ in range(len(nodes)): node = nodes.popleft() if left_to_right: level.append(node.val) else: level.appendleft(node.val) if node.left: nodes.append(node.left) if node.right: nodes.append(node.right) results.append(list(level)) left_to_right = not left_to_right return results"},{"question":"You are given a string `s` consisting of lowercase alphabets and a dictionary of words `dict` consisting of unique lowercase words. Your task is to find and return the length of the longest word in the dictionary that is a subsequence of `s`. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Note: Your solution should be efficient and consider both the length of the string `s` and the size of the dictionary.","solution":"def is_subsequence(s, t): Check if t is a subsequence of s. it = iter(s) return all(char in it for char in t) def longest_subsequence(s, words): Returns the length of the longest word in the dictionary that is a subsequence of s. max_length = 0 for word in words: if is_subsequence(s, word): max_length = max(max_length, len(word)) return max_length"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` denotes the value of the `i`th element. You are allowed to reverse at most one subarray (contiguous section) of `nums` to form a new array. Determine if there exists such a subarray that, when reversed, makes the entire array `nums` **non-decreasing**. Return _`true` if it is possible, otherwise return `false`_.","solution":"def can_be_non_decreasing_by_reversing_subarray(nums): Determines if there is a subarray that can be reversed to make the entire array non-decreasing. :param nums: List of integers. :return: True if possible, False otherwise. n = len(nums) # Find the first out-of-order element from the left start = 0 while start < n - 1 and nums[start] <= nums[start + 1]: start += 1 if start == n - 1: # The array is already non-decreasing return True # Find the first out-of-order element from the right end = n - 1 while end > 0 and nums[end] >= nums[end - 1]: end -= 1 # Reverse the subarray nums[start:end+1] nums[start:end+1] = reversed(nums[start:end+1]) # Check if the entire array is now non-decreasing for i in range(n - 1): if nums[i] > nums[i + 1]: return False return True"},{"question":"You are given an array of integers `nums` representing a deck of cards, where each card has a unique integer value. You can shuffle the deck by swapping any two cards. Your goal is to sort the deck in ascending order using the minimum number of swaps. Write a function `minSwapsToSort(nums)` that takes in this array and returns the minimum number of swaps needed to sort the deck.","solution":"def minSwapsToSort(nums): Returns the minimum number of swaps required to sort the array nums. # Pair the elements with their indices indexed_nums = list(enumerate(nums)) # Sort the list by the array values indexed_nums.sort(key=lambda x: x[1]) # Visited array to keep track of visited elements visited = [False] * len(nums) swaps = 0 for i in range(len(nums)): # If already visited or in the right place, skip it if visited[i] or indexed_nums[i][0] == i: continue # Find number of nodes in this cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True # Next node j = indexed_nums[j][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"A social media platform represents users and their connections as an **undirected** graph with `m` nodes, numbered from `1` to `m`. Each node has an `influence` value, given by a **1-indexed** integer array `influences` of length `m` where `influences[i]` denotes the influence of node `i`. You are also given a 2D integer array `connections` where `connections[j] = [uj, vj]` denotes an **undirected** edge connecting users `uj` and `vj`. A user **clique** is a subset of users where every two distinct users are connected by an edge. The influence of a user clique is defined as the **sum** of the influences of the users in the clique. Return _the **maximum influence** of any clique of size `k`_. If there is no clique of size `k`, return `-1`.","solution":"from itertools import combinations def max_influence_of_clique(m, influences, connections, k): graph = {i: set() for i in range(1, m + 1)} for u, v in connections: graph[u].add(v) graph[v].add(u) max_influence = -1 nodes = list(range(1, m + 1)) for clique in combinations(nodes, k): if all(v in graph[u] for u, v in combinations(clique, 2)): max_influence = max(max_influence, sum(influences[i - 1] for i in clique)) return max_influence"},{"question":"You are given two **0-indexed** integer arrays `start` and `end` of length `n`, where `start[i]` represents the starting day of the `i-th` project and `end[i]` represents the ending day of the `i-th` project. You are also given an integer `k` representing the maximum number of projects you can work on. Your objective is to choose the maximum number of non-overlapping projects such that no two chosen projects overlap and you can work on at most `k` projects at the same time. Two projects `i` and `j` are considered overlapping if `start[i] <= end[j]` and `start[j] <= end[i]`. Return _the maximum number of non-overlapping projects you can work on under the given constraints_.","solution":"def max_non_overlapping_projects(start, end, k): projects = sorted(zip(end, start)) count = 0 last_end = -1 intervals = [] for e, s in projects: if s > last_end: if count < k: last_end = e count += 1 intervals.append((s, e)) else: for idx, (cur_s, cur_e) in enumerate(intervals): if cur_s > last_end: intervals[idx] = (s, e) last_end = min(e, last_end) break return count"},{"question":"You are given a **0-indexed** array of integers `arr` and an integer `m`. You need to rearrange the elements of `arr` such that the absolute difference between any two consecutive elements is at most `m`. Return _the lexicographically smallest arrangement of_ `arr` _that satisfies the condition_.","solution":"def rearrange_array(arr, m): Rearrange the array such that the absolute difference between any two consecutive elements is at most m. The output should be the lexicographically smallest arrangement that satisfies the condition. arr.sort() # Start with sorting the array to get lexicographically smallest arrangement # Check if the sorted array satisfies the condition, if not, attempt to rearrange for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > m: return [] # If it\'s impossible to rearrange, return empty list return arr"},{"question":"Given a list of integers `arr` and an integer `threshold`, you need to determine the minimum integer value `divisor` such that the sum of the division results of the array elements by this `divisor` is less than or equal to `threshold`. Each result of the division should be rounded up to the nearest integer. For example, if an element in the array is `5` and the divisor is `2`, the result of the division should be `3` (since 5 divided by 2 is 2.5, rounded up to 3). Return _the minimum divisor_ that fits these conditions.","solution":"import math def smallest_divisor(arr, threshold): def get_sum_of_divisions(divisor): return sum(math.ceil(x / divisor) for x in arr) low, high = 1, max(arr) while low < high: mid = (low + high) // 2 if get_sum_of_divisions(mid) > threshold: low = mid + 1 else: high = mid return low"},{"question":"You are given a list of strings `words` and an integer `k`. Each string in `words` represents a distinct word. Construct the longest string `s` by concatenating exactly `k` words from the list such that no letter occurs more than once in `s`. Return the length of the longest possible string `s`. If it is not possible to construct such a string, return `0`.","solution":"from itertools import combinations def longest_unique_string_length(words, k): Returns the length of the longest string that can be formed by concatenating exactly k words from the list `words` such that no letter occurs more than once in the string. If it\'s not possible to form such a string, returns 0. def is_unique(s): return len(s) == len(set(s)) max_length = 0 for combo in combinations(words, k): combined = \'\'.join(combo) if is_unique(combined): max_length = max(max_length, len(combined)) return max_length"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums2` into `nums1` as one sorted array. Assume that `nums1` has enough space (size that is greater or equal to `m + n`) to hold additional elements from `nums2`. Modify `nums1` in place.","solution":"def merge(nums1, m, nums2, n): Merges two sorted lists, nums1 and nums2, where nums1 has sufficient space to include all elements of nums2. The function modifies nums1 in place to include all its original elements in sorted order along with elements from nums2. :param nums1: List[int] - first sorted list with enough space to hold elements of nums2. :param m: int - number of initial elements in nums1. :param nums2: List[int] - second sorted list. :param n: int - number of elements in nums2. # Index for the last element in nums1 that we consider while merging last = m + n - 1 # Pointers for nums1 and nums2 i = m - 1 j = n - 1 # Merge nums1 and nums2 starting from the last element in each while j >= 0: if i >= 0 and nums1[i] > nums2[j]: nums1[last] = nums1[i] i -= 1 else: nums1[last] = nums2[j] j -= 1 last -= 1"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to find the sum of every node in the tree which have both children present. Consider the following definition of a binary tree node: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write the function: ```python def sum_of_nodes_with_two_children(root: TreeNode) -> int: ``` The function should return the sum of values of all nodes that have both left and right children in the binary tree rooted at `root`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_nodes_with_two_children(root: TreeNode) -> int: if root is None: return 0 sum_val = 0 if root.left is not None and root.right is not None: sum_val += root.val sum_val += sum_of_nodes_with_two_children(root.left) sum_val += sum_of_nodes_with_two_children(root.right) return sum_val"},{"question":"You need to design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the `WordDictionary` class: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word into the data structure. * `boolean search(String word)` Returns `true` if there is any string in the data structure that matches the given word, otherwise it returns `false`. A word could contain the \'.\' character to represent any one letter. Note: * You may assume that all inputs are consist of lowercase letters a-z. * You may assume that all inputs are valid words. * You may assume that add and search could be called many times in a row.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"Given an integer array `arr`, return _an array_ `result` _such that_ `result[i]` _is equal to the product of all the elements of_ `arr` _except_ `arr[i]`. You must do this without using division and in linear time.","solution":"def product_except_self(arr): Returns an array such that result[i] is equal to the product of all the elements of arr except arr[i]. length = len(arr) result = [1] * length # Calculate products of elements to the left of each index left_product = 1 for i in range(length): result[i] = left_product left_product *= arr[i] # Calculate products of elements to the right of each index and multiply it to the corresponding left products right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"You are given a **0-indexed** integer array `height` representing the height of a terrain at each point. It is raining, and water can fill any low points between higher terrains. Any water spilled over the array boundaries is lost. Your task is to determine the amount of water that will be trapped after the rain. Return the total amount of trapped water.","solution":"def trap(height): Calculates the amount of rainwater trapped between the terrains after raining. :param height: List[int] - the heights of the terrain :return: int - the total amount of trapped rainwater if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are provided an `n x n` matrix `grid`. Write a function that checks if there exists at least one \\"1\\" on the main diagonal of the matrix. The main diagonal runs from the top-left corner to the bottom-right corner of the matrix. Return `true` if there is at least one \\"1\\" on the main diagonal, otherwise, return `false`. _Write a function:_ ```python def has_one_on_diagonal(grid: List[List[int]]) -> bool: # Your code here ``` _Example:_ ``` Input: grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] Output: true ``` _Explanation:_ There is a \\"1\\" on the main diagonal in the second row and second column.","solution":"from typing import List def has_one_on_diagonal(grid: List[List[int]]) -> bool: Checks if there is at least one \\"1\\" on the main diagonal of the matrix. n = len(grid) for i in range(n): if grid[i][i] == 1: return True return False"},{"question":"You are given an array of integers `arr` and an integer `x`. You are allowed to perform the following operation any number of times: choose any two indices `i` and `j` such that `arr[i] + arr[j] == x` (and `i != j`), then remove `arr[i]` and `arr[j]` from the array. Your task is to determine the maximum number of operations you can perform on the array. Return _the maximum number of operations_.","solution":"def max_operations(arr, x): Determines the maximum number of operations that can be performed on an array such that each operation involves removing two elements that sum up to x. Args: arr: List[int] - A list of integers. x: int - The target sum for each operation. Returns: int - The maximum number of operations that can be performed. from collections import Counter count = Counter(arr) operations = 0 for num in count: complement = x - num if complement in count: if num == complement: operations += count[num] // 2 else: pairs = min(count[num], count[complement]) operations += pairs count[num] -= pairs count[complement] -= pairs return operations"},{"question":"Given a string `s` representing a valid parentheses expression, remove the minimum number of parentheses (either \'(\' or \')\', in any positions) so that the resulting parentheses string is valid and return any valid string. A valid parentheses string is defined as: 1. An empty string or any string that does not contain any parentheses. 2. A string that has equal number of opening and closing parentheses and each opening parenthesis has a corresponding closing parenthesis in the correct order. For example: - Given `\\"()())()\\"`, the result could be `\\"()()()\\"` or `\\"(())()\\"`. - Given `\\"(a)())()\\"`, the result could be `\\"(a)()()\\"` or `(a())()`. - Given `\\")(\\"`, the result could be `\\"\\"`.","solution":"def remove_invalid_parentheses(s): Remove the minimum number of parentheses to make the input string valid. def remove_invalid(s, open_paren, close_paren): balance = 0 result = [] for char in s: if char == open_paren: balance += 1 elif char == close_paren: if balance == 0: continue balance -= 1 result.append(char) return \'\'.join(result) # 1st pass to remove invalid closing parentheses result = remove_invalid(s, \'(\', \')\') # 2nd pass to remove invalid opening parentheses in the reversed string result = remove_invalid(result[::-1], \')\', \'(\') return result[::-1]"},{"question":"Consider a collection of `n` unique integers from `1` to `n+1`, except one number which is missing. Write a function that takes an unordered list of `n` elements and finds the missing number. You must achieve a time complexity of O(n). Do not use extra space, other than a few constant extra variables. Return the missing number.","solution":"def find_missing_number(nums): Given a list of unique integers from 1 to n+1 except one missing number, find the missing number. Parameters: nums (list): A list of unique integers from 1 to n+1 except one missing number. Returns: int: The missing number. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"You are given a list of integers `nums` and an integer `target`. You are allowed to swap two elements in `nums` at most once. Return _true_ if you can obtain a list where the sum of its elements is equal to `target` by performing at most one swap; otherwise, return _false_. Note that the order of the elements must remain the same apart from the single swap.","solution":"def can_obtain_target_sum(nums, target): Returns True if you can obtain a list where the sum of its elements is equal to \'target\' by performing at most one swap. current_sum = sum(nums) diff = target - current_sum if diff == 0: return True n = len(nums) seen = set() for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j] - nums[i] - diff in seen) or (nums[j] + nums[i] - nums[j] - diff in seen): return True seen.add(nums[i]) seen.add(nums[j]) return False"},{"question":"You are given two non-empty arrays of integers, `water` and `plants`, where `water[i]` represents the amount of water available at the `i-th` tank and `plants[i]` represents the amount of water needed by the `i-th` plant. There are `n` tanks and `n` plants placed in a linear arrangement. Each plant can only be watered by the tank at the same position or by tanks to its left. Write a function that determines the minimum number of tanks you need to use to water all the plants. If it is not possible to water all the plants with the given tanks, return -1.","solution":"def min_tanks_to_water_plants(water, plants): Determines the minimum number of tanks needed to water all the plants. Parameters: water (list): List of integers representing the water available at each tank. plants (list): List of integers representing the water needed by each plant. Returns: int: Minimum number of tanks needed to water all plants or -1 if not possible. n = len(water) total_water = 0 for i in range(n): total_water += water[i] if total_water >= plants[i]: total_water -= plants[i] else: return -1 return n"},{"question":"You are given a **0-indexed** 2D integer array `meetings`, where `meetings[i] = [starti, endi]` represents a meeting from `starti` to `endi` (both inclusive). You need to schedule all these meetings in a single conference room without any overlap. If scheduling is possible, return the maximum number of meetings that can be attended. If it is not possible to schedule all meetings, return `-1`. Meetings are attended in a non-overlapping manner, meaning a meeting can start exactly when another one ends.","solution":"def max_meetings(meetings): Returns the maximum number of meetings that can be attended without overlap. If it is not possible to schedule all meetings, returns -1. # Sort meetings by their end times meetings.sort(key=lambda x: x[1]) last_end_time = -1 count = 0 for meeting in meetings: start, end = meeting if start >= last_end_time: # Attend this meeting last_end_time = end count += 1 else: # Overlap detected, return -1 return -1 return count"},{"question":"Given an array of non-negative integers `arr`, you are allowed to choose any two indices `i` and `j` such that `i != j` and set `arr[i] = arr[i] + arr[j]`. Your goal is to maximize the value of the minimum element in the array after performing the operation at most once. Return _the maximum possible value of the minimum element_ in the array after at most one operation.","solution":"def maximize_min_element(arr): Returns the maximum possible value of the minimum element in the array after performing at most one operation. if len(arr) <= 1: return arr[0] if arr else 0 # Handle edge case for empty or single element array # Sort the array to easily access minimum and second minimum elements sorted_arr = sorted(arr) # Compute the new minimum if we combine the two smallest elements new_min = sorted_arr[0] + sorted_arr[1] # Return the maximum of the new minimum and the second smallest element, # which is the original second smallest element in the sorted array return max(new_min, sorted_arr[1])"},{"question":"Given a `str` representing a string of parentheses, where each opening parenthesis `(` has a corresponding closing parenthesis `)`, determine the **minimum number** of moves required to make the parentheses string balanced. Each move consists of inserting a single parenthesis at any position within the string. Return the _minimum number of moves_ required to balance the given parentheses string. Example: - Input: `str = \\"(()))\\"` - Output: 1 Explanation: By adding a `(` at the start or a `)` at the end, the string becomes balanced.","solution":"def min_moves_to_balance_parentheses(s): open_count = 0 close_needed = 0 for char in s: if char == \'(\': open_count += 1 else: if open_count == 0: close_needed += 1 else: open_count -= 1 return open_count + close_needed"},{"question":"Design a class that simulates a timer capable of handling multiple concurrent countdowns. Each timer should be uniquely identified by an ID. The timer system has the following features: - **Adding** a new timer with a specified countdown time in seconds. - **Ticking** all active timers by advancing the countdowns by one second. - **Checking** if a specific timer has finished or how many seconds are remaining. Implement the `MultiTimer` class: - `MultiTimer()` Initializes the timer system. - `void addTimer(int id, int countdownTime)` Adds a new timer with unique `id` and initializes its countdown to `countdownTime` seconds. - `void tick()` Advances the countdowns of all active timers by one second. - `int checkTimer(int id)` Returns the remaining seconds for the timer with `id`. If the timer has finished, return `0`. If the timer does not exist, return `-1`.","solution":"class MultiTimer: def __init__(self): self.timers = {} def addTimer(self, id, countdownTime): if id not in self.timers: self.timers[id] = countdownTime def tick(self): for id in self.timers: if self.timers[id] > 0: self.timers[id] -= 1 def checkTimer(self, id): if id in self.timers: return max(0, self.timers[id]) return -1"},{"question":"Given a binary tree, write a function `deepestLeavesSum` that returns the sum of the values of its deepest leaves. A leaf is a node with no children, and the depth of a node is the number of edges in the path from the root node to the node. Implement the `deepestLeavesSum` method: - `int deepestLeavesSum(TreeNode root)` Where `TreeNode` is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` The function should take a single argument, the root of the binary tree, and return the sum of the deepest leaves\' values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Returns the sum of the values of the deepest leaves. if not root: return 0 from collections import deque queue = deque([root]) level_sum = 0 while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"A directed graph is represented by an adjacency list, where the list at the nth index contains the vertices to which vertex `n` is directly connected. Given such a graph and an integer `n`, write a function to determine if there exists a **cycle** that includes the vertex `n`. If a cycle exists, return `true`; otherwise, return `false`. The graph does not contain any self-loops or multiple edges.","solution":"def has_cycle(graph, n): Determines if there exists a cycle that includes the vertex `n`. :param graph: List[List[int]] - The adjacency list of the directed graph. :param n: int - The vertex to check for a cycle inclusion. :return: bool - True if a cycle includes vertex `n`, False otherwise. visited = [False] * len(graph) rec_stack = [False] * len(graph) def dfs(v): visited[v] = True rec_stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False return dfs(n)"},{"question":"You are given an integer array `heights` representing the heights of a group of people standing in a line. Each person `i` can see in front of them if there is no taller person in between. We define the \\"visibility count\\" of each person as the number of people they can see, including themselves. For example, given `heights = [2, 1, 4, 3, 5]`, the visibility count for each person is `[1, 1, 3, 1, 5]` because: - Person at index 0 (height 2) can see themselves and no one else. - Person at index 1 (height 1) can see themselves and no one else. - Person at index 2 (height 4) can see persons at index 1 (height 1) and 0 (height 2) besides themselves. - Person at index 3 (height 3) can see themselves and no one else as person at index 2 (height 4) blocks the view. - Person at index 4 (height 5) can see all persons as no one is taller in between (index 3 (height 3) and 2 (height 4)). Return _an array representing the visibility count of each person in the given line_.","solution":"def visibility_count(heights): Returns an array representing the visibility count of each person in the given line. n = len(heights) visibility = [0] * n for i in range(n): count = 1 # Include the person themselves for j in range(i - 1, -1, -1): if heights[j] > heights[i]: break count += 1 visibility[i] = count return visibility"},{"question":"Given a `0-indexed` integer array `nums` containing `n` integers, return the length of the longest subsequence such that the difference between consecutive elements is exactly `d`. A subsequence is a sequence derived by deleting some or none of the elements in the array without changing the order of the remaining elements. If no such subsequence exists, return 0.","solution":"def longest_subsequence(nums, d): Returns the length of the longest subsequence such that the difference between consecutive elements is exactly `d` in the given integer array `nums`. if not nums: return 0 # Dictionary to store the length of subsequence ending with the value of the key dp = {} max_len = 0 for num in nums: if num - d in dp: dp[num] = dp[num - d] + 1 else: dp[num] = 1 max_len = max(max_len, dp[num]) return max_len"},{"question":"Given a class schedule represented as an array of intervals `schedule` where `schedule[i] = [start_i, end_i]` represents the start and end times of the `ith` class, determine if a student can attend all classes without any overlaps. Return _`true` if the student can attend all classes without conflict, otherwise return `false`_. For example, if the input is `schedule = [[9, 10], [10, 11], [11, 12]]`, the output should be `true` since there are no overlapping intervals. If the input is `schedule = [[9, 10], [9:30, 10:30], [10:45, 11:45]]`, the output should be `false` due to overlapping intervals.","solution":"def can_attend_all_classes(schedule): Determine if a student can attend all classes without any overlaps. :param schedule: List of intervals representing class start and end times. :type schedule: List[List[int]] :return: True if a student can attend all classes without conflict, otherwise False. :rtype: bool if not schedule: return True # Sort the intervals by their start time schedule.sort() # Check for overlapping intervals for i in range(1, len(schedule)): if schedule[i][0] < schedule[i-1][1]: # Overlapping case return False return True"},{"question":"Given a list of positive integers `nums`, return the length of the longest contiguous subarray where the difference between the maximum and minimum elements in that subarray is less than or equal to 1. __Example:__ ``` Input: nums = [8, 2, 4, 7] Output: 2 Explanation: The longest subarray is [4, 7] with a difference of 3, which is greater than 1. The next longest subarray is [2, 4], with a difference of 2 which is also greater than 1. The correct answer is [2, 2] which is a subarray length of 1 having the max-min difference less than or equal to 1. ``` The resulting longest subarray for the given example would be [8, 8] which has the minimum difference of 0 making the answer 1.","solution":"def longest_subarray(nums): Returns the length of the longest contiguous subarray where the difference between the maximum and minimum elements in that subarray is less than or equal to 1. from collections import deque min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right, value in enumerate(nums): while min_deque and value < min_deque[-1]: min_deque.pop() while max_deque and value > max_deque[-1]: max_deque.pop() min_deque.append(value) max_deque.append(value) while max_deque[0] - min_deque[0] > 1: if nums[left] == min_deque[0]: min_deque.popleft() if nums[left] == max_deque[0]: max_deque.popleft() left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to select a substring of `s` such that the count of each character in the substring is at most `k`. Your task is to determine the length of the longest substring that meets this condition. If no such substring exists, return `0`.","solution":"def longest_substring_with_k_repeats(s, k): Returns the length of the longest substring where each character count is at most k. from collections import defaultdict start, max_len = 0, 0 char_count = defaultdict(int) for end in range(len(s)): char_count[s[end]] += 1 while any(count > k for count in char_count.values()): char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given two strings `s` and `goal`, both of which contain only lowercase English letters. Your task is to determine if you can obtain string `goal` by rotating the string `s` any number of times. Return `true` if you can obtain `goal` by rotating `s`, otherwise return `false`. Note that a rotation means taking characters from the front of the string and moving them to the back while preserving their relative order.","solution":"def can_become_goal(s, goal): Determine if the string \'goal\' can be obtained by rotating the string \'s\' any number of times. :param s: The original string to rotate. :param goal: The target string to match by rotating \'s\'. :return: True if \'goal\' can be obtained by rotating \'s\', otherwise False. if len(s) != len(goal): return False doubled_s = s + s return goal in doubled_s"},{"question":"Given a binary tree, populate each node\'s `next` pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. You may only use constant extra space.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Populate each node\'s next pointer with the next right node using level order traversal. if not root: return None # Initialize the current node of the current level current = root # We use a dummy node to start the level dummy = TreeNode() prev = dummy while current: while current: if current.left: prev.next = current.left prev = prev.next if current.right: prev.next = current.right prev = prev.next current = current.next # Move to the next level current = dummy.next dummy.next = None prev = dummy return root"},{"question":"You are given a **0-indexed** integer array `nums` where `nums[i]` represents the number of gifts in a house on a street. You can pick exactly one house and start collecting gifts from that house. Once you pick a house, you can only move to the next house to the right. If you reach the end of the street, you cannot collect gifts from any more houses. However, after collecting gifts from the house `nums[i]`, the number of gifts in the house is reduced by half (rounded down to the nearest integer). You continue picking gifts from the subsequent houses based on the updated values. Your task is to return _the maximum number of gifts you can collect starting from any house on the street_.","solution":"def max_gifts(nums): Given a list of integers where each integer represents the number of gifts in a house on a street, return the maximum number of gifts you can collect starting from any house on the street. For each house, the number of gifts is halved and rounded down to the nearest integer after you collect the gifts. n = len(nums) max_gifts_collected = 0 for i in range(n): gifts_collected = 0 for j in range(i, n): gifts_collected += nums[j] nums[j] //= 2 max_gifts_collected = max(max_gifts_collected, gifts_collected) return max_gifts_collected"},{"question":"Given a binary tree, write a function to find the **level order traversal** of the tree. The **level order traversal** of a tree is defined as visiting all nodes at depth 0, then all nodes at depth 1, and so on. Return the traversal in the form of a list of lists, where each sublist contains the nodes at each level from left to right. Note that the input will be the root of the tree, and the tree can have any structure, including being empty.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_length = queue.__len__() current_level = [] for _ in range(level_length): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":": Implement a method to serialize and deserialize a binary tree. You need to design a class `Codec` with two methods: * `String serialize(TreeNode root)` which takes the root of a binary tree and returns a string serialized representation of the tree. * `TreeNode deserialize(String data)` which takes a string serialized representation of a binary tree and returns the root of the tree. Your implementation should ensure that the serialized format can be used to recreate the original tree structure exactly. Use pre-order traversal as the chosen method for serializing the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. def preorder(node): if node is None: return [\'#\'] return [str(node.val)] + preorder(node.left) + preorder(node.right) return \' \'.join(preorder(root)) def deserialize(self, data): Decodes your encoded data to tree. def build_tree(values): value = next(values) if value == \'#\': return None node = TreeNode(int(value)) node.left = build_tree(values) node.right = build_tree(values) return node values = iter(data.split()) return build_tree(values)"},{"question":"A building has `n` floors, and you have `k` identical eggs. You want to find the highest floor from which you can drop an egg without breaking it, using the minimum number of attempts. An attempt is defined as dropping an egg from a floor. If the egg breaks, it cannot be used again. If the egg does not break, it can be used in subsequent attempts. Write a function `superEggDrop(k, n)` that returns the minimum number of attempts needed to find the highest floor from which you can drop an egg without breaking it.","solution":"def superEggDrop(k, n): Returns the minimum number of attempts needed to find the highest floor from which an egg can be dropped without breaking, given k eggs and n floors. # DP table where dp[i][j] denotes the minimum number of attempts needed # with i eggs and j floors. dp = [[0] * (n + 1) for _ in range(k + 1)] # We need 0 attempts for 0 floors and 1 attempt for 1 floor for i in range(1, k + 1): dp[i][0] = 0 dp[i][1] = 1 # We need j attempts for 1 egg and j floors for j in range(1, n + 1): dp[1][j] = j # Fill the rest of the dp table for i in range(2, k + 1): for j in range(2, n + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): res = 1 + max(dp[i - 1][x - 1], dp[i][j - x]) dp[i][j] = min(dp[i][j], res) return dp[k][n]"},{"question":"Given a list of `n` tasks where each task has a start and finish time, determine the maximum number of tasks that can be completed by a single person without overlapping. Each task is represented as a pair of integers `[start, finish]` where `start` is the starting time and `finish` is the finishing time. Return the maximum number of non-overlapping tasks that can be completed.","solution":"def max_non_overlapping_tasks(tasks): Determines the maximum number of non-overlapping tasks. Args: tasks (List[List[int]]): A list of tasks represented by [start, finish] pairs. Returns: int: The maximum number of non-overlapping tasks. if not tasks: return 0 # Sort tasks by their finishing time tasks.sort(key=lambda x: x[1]) # Initialize the count of maximum tasks and the end time of last selected task max_tasks = 0 end_time = float(\'-inf\') for task in tasks: if task[0] >= end_time: # If the task start time is greater than or equal to end_time, select the task end_time = task[1] max_tasks += 1 return max_tasks"},{"question":"You are given a **0-indexed** array of integers, `nums`, that represents the scores of a shooting competition. There are `n` shooting targets and each target `i` has a score value `nums[i]`. The score is **non-negative** and can be zero. A **consecutive scoring segment** is defined as a contiguous subarray of `nums` and its score is the sum of the values within the subarray. Return _the maximum score of any consecutive scoring segment in `nums`. If all elements are zeros, the highest score segment is considered to be zero.","solution":"def max_consecutive_score(nums): Returns the maximum score of any consecutive scoring segment in nums. if not nums: return 0 max_current = max_global = nums[0] for i in range(1, len(nums)): max_current = max(nums[i], max_current + nums[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a list of `n` non-negative integers representing the heights of vertical lines drawn on an `x`-axis, where the `i-th` line is drawn from `(i, 0)` to `(i, heights[i])`. Find two lines that together with the `x-axis` form a container, such that the container contains the most water. Your function should return _the maximum amount of water a container can store_. Remember, you may not slant the container; it must be a vertical pair of lines. Consider that the width of the container is the distance between the two lines, and the height is the smaller of the two lines.","solution":"def max_area(heights): Returns the maximum amount of water a container can store. left, right = 0, len(heights) - 1 max_water = 0 while left < right: h = min(heights[left], heights[right]) width = right - left max_water = max(max_water, h * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a string `s` and an array of strings `words`. Determine if `words` can be formed by non-overlapping substrings of `s` concatenated in order. Each word in `words` must appear as it is in `s` and maintain the sequence given in `words`, but they must not overlap in the original string `s`. Return `true` if `words` can be formed by non-overlapping substrings of `s`, otherwise return `false`.","solution":"def can_form_from_substrings(s, words): Determines if the words can be formed by non-overlapping substrings of s in order. Args: s (str): The main string. words (list of str): List of words to check. Returns: bool: True if words can be formed, else False. start_idx = 0 for word in words: start_idx = s.find(word, start_idx) if start_idx == -1: return False start_idx += len(word) return True"},{"question":"You are provided an integer array `heights` representing the height of buildings along a street. Each building has a width of 1. Determine the rightmost building from where the sun would be completely unobstructed by any taller building to its right. A building is said to be unobstructed if all the buildings to its right are shorter than itself. Return the index of this building. If there are multiple such buildings, return the rightmost one.","solution":"def find_unobstructed_building(heights): Find the rightmost building that is not obstructed by any taller building to its right. :param heights: List of integers representing building heights :return: The index of the rightmost unobstructed building max_height = -1 unobstructed_index = -1 for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height: max_height = heights[i] unobstructed_index = i return unobstructed_index"},{"question":"You are given an m x n matrix `grid` consisting of non-negative integers. A robot is initially located at the top-left corner (0, 0) and can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner (m - 1, n - 1) of the grid. The robot can collect coins located in the cells it passes through. The goal is to maximize the number of coins collected when the robot reaches the bottom-right corner. Write a function `maxCoins(grid: List[List[int]]) -> int` to determine the maximum number of coins the robot can collect on its way to the bottom-right corner of the grid.","solution":"from typing import List def maxCoins(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"A DNA sequence is composed of a series of nucleotides abbreviated as \'A\', \'C\', \'G\', and \'T\'. Sometimes, due to errors in sequencing, random mutations happen. Given a DNA string `sequence`, and an integer `k`, determine the maximum number of times any substring of length `k` appears in the given sequence. Return the length of this substring if it exists, or `0` if the sequence is shorter than `k`.","solution":"def max_substring_occurrences(sequence, k): Determines the maximum number of times any substring of length k appears in the given sequence. Args: sequence (str): The DNA sequence composed of \'A\', \'C\', \'G\', \'T\'. k (int): The length of the substrings to consider. Returns: int: The maximum number of times any substring of length k appears in the sequence. if len(sequence) < k: return 0 substring_count = {} for i in range(len(sequence) - k + 1): substring = sequence[i:i+k] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return max(substring_count.values())"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge these two strings alternately to form a single resultant string. If one string is longer than the other, append the additional characters of the longer string to the end of the merged result. For example, if `word1 = \\"abc\\"` and `word2 = \\"pqr\\"`, the merged string should be `\\"apbqcr\\"`. If `word1 = \\"ab\\"` and `word2 = \\"pqrs\\"`, the merged string should be `\\"apbqrs\\"`. Write a function `mergeAlternately(String word1, String word2)` that returns the merged string.","solution":"def mergeAlternately(word1, word2): Returns a string by merging two input strings alternately. If one string is longer than the other, append the additional characters of the longer string at the end. merged_string = [] len1, len2 = len(word1), len(word2) max_len = max(len1, len2) for i in range(max_len): if i < len1: merged_string.append(word1[i]) if i < len2: merged_string.append(word2[i]) return \'\'.join(merged_string)"},{"question":"You are given a binary tree with `n` nodes. Each node in the tree has a value assigned to it. We define the **beauty** of a path as the sum of the values of the nodes along that path. A path starts at one node and ends at another and does not necessarily pass through the root. Find the path with the maximum **beauty** in the tree. Return _the **maximum beauty** among all possible paths in the binary tree._","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Return the maximum beauty among all possible paths in the binary tree. A path is defined as a sequence of nodes starting and ending at any two nodes in the tree. def get_maximum_path(node): nonlocal max_sum if not node: return 0 left = max(0, get_maximum_path(node.left)) # Only take positive contributions right = max(0, get_maximum_path(node.right)) current_path_sum = node.val + left + right max_sum = max(max_sum, current_path_sum) return node.val + max(left, right) max_sum = float(\'-inf\') get_maximum_path(root) return max_sum"},{"question":"Write a function that takes a string `s` consisting of lowercase and uppercase ASCII characters and returns the same string with all the vowels removed. Vowels in the English language are \'a\', \'e\', \'i\', \'o\', \'u\' and their uppercase counterparts.","solution":"def remove_vowels(s): Removes all vowels from the given string `s`. Args: s (str): Input string consisting of lowercase and uppercase ASCII characters. Returns: str: String with all vowels removed. vowels = \\"aeiouAEIOU\\" return \'\'.join([char for char in s if char not in vowels])"},{"question":"You are given an array `scores` of `n` integers where `scores[i]` represents the score of the `i`-th student in an exam. You need to assign ranks to the students. The rank for the `i`-th student is 1 plus the number of students who have a higher score than `scores[i]`. Return an array `ranks` where `ranks[i]` is the rank of the `i`-th student. For example, if `scores = [50, 90, 80, 70]`, then the `ranks` array would be `[4, 1, 2, 3]` since 50 is the lowest (rank 4), 90 is the highest (rank 1), 80 has one higher score (rank 2), and 70 has two higher scores (rank 3).","solution":"def assign_ranks(scores): Assign ranks based on the scores of the students. Args: scores (list): List of integers representing the scores of the students. Returns: list: List of integers representing the ranks of the students. sorted_scores = sorted(scores, reverse=True) ranks = [] for score in scores: rank = sorted_scores.index(score) + 1 ranks.append(rank) return ranks"},{"question":"Design a function named `isValidSudoku` that takes a 9x9 2D list `board` as input and returns `true` if the board represents a valid Sudoku configuration and `false` otherwise. A valid Sudoku configuration must satisfy the following conditions: - Each row must contain the digits from 1 to 9 without repetition. - Each column must contain the digits from 1 to 9 without repetition. - Each of the nine 3x3 sub-boxes of the grid must contain the digits from 1 to 9 without repetition. Note that empty cells are indicated by the character `\'.\'`.","solution":"def isValidSudoku(board): Check if a given 9x9 Sudoku board is valid. :param board: List[List[str]] - 9x9 2D list representing the Sudoku board :return: bool - True if the board is valid, False otherwise def is_valid_unit(unit): unit = [i for i in unit if i != \'.\'] return len(unit) == len(set(unit)) # Check rows for row in board: if not is_valid_unit(row): return False # Check columns for col in zip(*board): if not is_valid_unit(col): return False # Check 3x3 sub-boxes for i in range(0, 9, 3): for j in range(0, 9, 3): sub_box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_unit(sub_box): return False return True"},{"question":"Given an integer array `heights` representing the heights of students standing in a line, implement the function `findUnsortedSubarray(heights: List[int]) -> int`. This function should return the length of the shortest contiguous subarray that, if sorted, would result in the whole array being sorted in non-decreasing order. If the entire array is already sorted, return `0`.","solution":"from typing import List def findUnsortedSubarray(heights: List[int]) -> int: Returns the length of the shortest contiguous subarray that, if sorted, would result in the whole array being sorted in non-decreasing order. If the entire array is already sorted, returns 0. n = len(heights) if n <= 1: return 0 start, end = -1, -1 max_seen, min_seen = -float(\'inf\'), float(\'inf\') # Find the end boundary of the unsorted subarray for i in range(n): if heights[i] < max_seen: end = i else: max_seen = heights[i] # Find the start boundary of the unsorted subarray for i in range(n-1, -1, -1): if heights[i] > min_seen: start = i else: min_seen = heights[i] if start == -1: # array is already sorted return 0 return end - start + 1"},{"question":"You are given a **0-indexed** array `nums` consisting of integers. Each integer in the array appears **exactly twice**, except for one unique element that appears **only once**. Your task is to find the unique element. Implement a function that returns _the integer that appears only once in the array_.","solution":"def find_unique_element(nums): Returns the integer that appears only once in an array where every other integer appears exactly twice. :param nums: List[int] :return: int unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"You are given an array of `strings words` and a string `target`. Your task is to determine if the `target` can be formed by concatenating exactly two distinct strings from the array `words` in any order. Return `true` if it is possible, otherwise return `false`.","solution":"def can_form_target(words, target): for i in range(len(words)): for j in range(len(words)): if i != j and words[i] + words[j] == target: return True return False"},{"question":"You are given a 2D integer grid `grid` of dimensions `m` x `n`. Initially, every cell is uninfected (0). However, there is one infected cell (1) that will spread the infection to its neighboring cells (up, down, left, and right) in each unit of time. Return the minimum number of units of time required to infect all cells in the grid. If it is impossible to infect all cells, return `-1`.","solution":"from collections import deque def min_time_to_infect(grid): Returns the minimum number of units of time required to infect all cells in the grid. If it is impossible to infect all cells, return -1. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) queue = deque() total_cells = rows * cols infected_count = 0 # Find all initially infected cells and count them for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c)) infected_count += 1 if infected_count == total_cells: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] time_units = 0 # BFS to spread infection while queue: for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0: grid[nr][nc] = 1 queue.append((nr, nc)) infected_count += 1 if queue: time_units += 1 return time_units if infected_count == total_cells else -1"},{"question":"You are given a **0-indexed** 2D integer array `grid` containing land (1) and water (0) cells. The cells are connected **orthogonally** (horizontally or vertically). A group of connected **land cells** forms an island. The `perimeter` of an island is the number of edges that are adjacent to water (or the grid boundary). Return the _perimeter of the island_ that contains the most number of land cells. For example, given the grid: ```python [ [0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0] ] ``` The island in the grid has a perimeter of `16`.","solution":"def max_island_perimeter(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0: return 1 if grid[r][c] == -1: return 0 grid[r][c] = -1 perimeter = 0 perimeter += dfs(r+1, c) perimeter += dfs(r-1, c) perimeter += dfs(r, c+1) perimeter += dfs(r, c-1) return perimeter max_perim = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_perim = max(max_perim, dfs(r, c)) return max_perim"},{"question":"Given a sorted array of distinct integers `arr` and an integer `k`, return the `k`th smallest element in the array that is not present in `arr`. For example, given the array `arr = [2, 3, 4, 7, 11]` and `k = 5`, the 5th smallest element not in the array is `9`. Return the element as an integer.","solution":"def find_kth_missing_element(arr, k): Returns the kth smallest element in the array that is not present in arr. missing_count = 0 current = 1 idx = 0 while missing_count < k: if idx < len(arr) and arr[idx] == current: idx += 1 else: missing_count += 1 if missing_count < k: current += 1 return current"},{"question":"Design a data structure that supports the following operations: `insert`, `delete`, `get_random`, and `get_random_from_unique_elements`. You should ensure the following: 1. `insert(val)` - Inserts an integer `val` into the data structure. 2. `delete(val)` - Deletes a single instance of integer `val` from the data structure, if it exists. 3. `get_random()` - Returns a random integer from the current elements within the data structure. Each element must have the same probability of being returned. 4. `get_random_from_unique_elements()` - Returns a random integer from the current unique elements within the data structure. Each unique element must have the same probability of being returned. Hints: - Consider the use of a dictionary for efficient insertions and deletions. - To retrieve random elements, consider maintaining lists or sets of the current elements and unique elements respectively.","solution":"import random class RandomizedCollection: def __init__(self): Initialize your data structure here. self.data = [] self.data_dict = {} self.unique_elements = set() def insert(self, val: int) -> None: Inserts an item val to the collection. self.data.append(val) self.data_dict[val] = self.data_dict.get(val, 0) + 1 self.unique_elements.add(val) def delete(self, val: int) -> None: Deletes a single instance of val from the collection. if val in self.data_dict: self.data_dict[val] -= 1 self.data.remove(val) if self.data_dict[val] == 0: del self.data_dict[val] self.unique_elements.remove(val) def get_random(self) -> int: Get a random element from the collection. return random.choice(self.data) def get_random_from_unique_elements(self) -> int: Get a random element from the unique elements of the collection. return random.choice(list(self.unique_elements))"},{"question":"You are given a sorted array of distinct integers `arr` and a target value `target`. Write a function that finds the index of the first occurrence of `target` in `arr`. If `target` is not present in `arr`, return `-1`. The solution should aim to achieve a time complexity better than O(n). Example 1: ``` Input: arr = [-1, 0, 3, 5, 9, 12], target = 9 Output: 4 ``` Example 2: ``` Input: arr = [-1, 0, 3, 5, 9, 12], target = 2 Output: -1 ```","solution":"def binary_search(arr, target): Returns the index of the first occurrence of target in arr. If target is not present in arr, return -1. Parameters: arr (list): A sorted list of distinct integers. target (int): The target value to search for in arr. Returns: int: The index of the first occurrence of target, or -1 if target is not found. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given an array of integers `heights` representing the height of trees in a forest, determine the maximum number of trees you can see when standing at the first tree (index `0`) and looking towards the last tree (index `n-1`). You can only see a tree if all shorter trees in the same line of sight are also visible. In other words, a tree at position `i` is visible if there is no taller tree between the first tree and the tree at position `i`. Return the maximum number of visible trees.","solution":"def max_visible_trees(heights): Determine the maximum number of trees that can be seen when standing at the first tree and looking towards the last tree. Parameters: heights (list): A list of integers representing the heights of the trees. Returns: int: The maximum number of visible trees. if not heights: return 0 max_height = heights[0] count = 1 for height in heights[1:]: if height >= max_height: count += 1 max_height = height return count"},{"question":"Given a list of integers `heights`, where each element represents the height of a person, return the minimum number of moves required to arrange the list in increasing order by height. A **move** consists of picking any person from the list and moving them to any other position in the list.","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of moves required to sort the list in increasing order by height. sorted_heights = sorted(heights) lcs_length = longest_common_subsequence(heights, sorted_heights) return len(heights) - lcs_length def longest_common_subsequence(array1, array2): Helper function to find the length of the longest common subsequence between two arrays. m, n = len(array1), len(array2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if array1[i - 1] == array2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a sequence of integers `arr` (of potentially arbitrary length) and an integer `k`. You need to determine if there is a subset of `arr` whose sum is exactly `k`. Return `true` if such a subset exists, otherwise return `false`.","solution":"def subset_sum(arr, k): Determines if there is a subset of `arr` whose sum is exactly `k`. :param arr: List of integers :param k: Integer :return: Boolean indicating if such a subset exists n = len(arr) # Create a table to store results of subproblems dp = [[False] * (k + 1) for _ in range(n + 1)] # Initialize dp[0][0] to True, as we can make sum 0 with an empty set dp[0][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = dp[i-1][j] # Exclude the current element if j >= arr[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - arr[i-1]] # Include the current element return dp[n][k]"},{"question":"You are given a linked list `head` and an integer `m`. Write a function to reverse the nodes of the linked list in groups of `m`, and return the modified list. If there are fewer than `m` nodes left at any point, leave them as they are.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head = None ptr = head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) if head: head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given an integer array `nums` of length `n`. Your task is to find the length of the shortest subarray that, if sorted in non-decreasing order, would result in the entire array being sorted in non-decreasing order. If the array is already sorted, return `0`.","solution":"def findUnsortedSubarray(nums): Finds the length of the shortest subarray which, if sorted, results in the whole array being sorted in non-decreasing order. # Create copies of the array and sort one sorted_nums = sorted(nums) # Find the first and last positions where nums and sorted_nums differ start = 0 while start < len(nums) and nums[start] == sorted_nums[start]: start += 1 if start == len(nums): # If the entire array is already sorted return 0 end = len(nums) - 1 while end > start and nums[end] == sorted_nums[end]: end -= 1 # Length of the subarray to sort return end - start + 1"},{"question":"Given a string that contains only lowercase alphabetical characters, design an algorithm to perform the following operations efficiently: reverse a specified segment within the string and find the frequency of a specific character within a given segment. Implement the `StringManipulator` class: * `StringManipulator(String s)` initializes the object with the string `s`. * `void reverseSegment(int start, int end)` reverses the substring within the range `[start, end]` (inclusive). * `int charFrequency(int start, int end, char ch)` returns the frequency of character `ch` in the substring within the range `[start, end]` (inclusive).","solution":"class StringManipulator: def __init__(self, s): Initializes the object with the given string. :param s: The initial string to manipulate. self.s = s def reverseSegment(self, start, end): Reverses the substring within the range [start, end] (inclusive). :param start: Starting index of the segment to reverse. :param end: Ending index of the segment to reverse. if start < 0 or end >= len(self.s) or start > end: raise ValueError(\\"Invalid indices\\") # Convert string to list to perform in-place operations s_list = list(self.s) while start < end: s_list[start], s_list[end] = s_list[end], s_list[start] start += 1 end -= 1 self.s = \'\'.join(s_list) def charFrequency(self, start, end, ch): Returns the frequency of character `ch` in the substring within the range [start, end] (inclusive). :param start: Starting index of the segment to check. :param end: Ending index of the segment to check. :param ch: The character to count within the segment. :return: Frequency of the character `ch` within the segment. if start < 0 or end >= len(self.s) or start > end: raise ValueError(\\"Invalid indices\\") segment = self.s[start:end+1] return segment.count(ch)"},{"question":"Given an array of integers `nums` and a target integer `k`, write a function to determine if the array contains two distinct elements such that their absolute difference is exactly `k`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def contains_elements_with_difference(nums, k): Determines if there are two distinct elements in nums with an absolute difference of k. Args: nums (list of int): List of integers. k (int): Target absolute difference. Returns: bool: True if such a pair exists, otherwise False. nums_set = set(nums) for num in nums: if (num + k in nums_set and num + k != num) or (num - k in nums_set and num - k != num): return True return False"},{"question":"Given two strings `s1` and `s2`, write a function that determines if `s2` can be formed by rearranging the characters of `s1` and possibly adding some characters. Return `true` if `s2` can be formed, otherwise return `false`.","solution":"from collections import Counter def can_form_by_rearranging_and_adding(s1, s2): Determines if s2 can be formed by rearranging the characters of s1 and possibly adding some characters. Args: s1 (str): The original string. s2 (str): The string to be formed. Returns: bool: True if s2 can be formed, otherwise False. count_s1 = Counter(s1) count_s2 = Counter(s2) for char in count_s2: if count_s1[char] < count_s2[char]: return False return True"},{"question":"You are given an integer array `savings` where `savings[i]` is the amount of money saved by the `i-th` person. You are also given a target `T` which represents the total amount of money that needs to be saved. You want to find the minimum number of people required to accumulate at least the target `T`. If it is impossible to reach the target `T`, return `-1`. Each person\'s savings can be used only once. Return _the minimum number of people needed to reach the target `T`._","solution":"def min_people_to_target(savings, T): Calculates the minimum number of people required to save at least target T. Parameters: - savings (List[int]): List of savings of each person. - T (int): The target amount to be saved. Returns: - int: Minimum number of people needed to reach or exceed the target. # Sort the savings in descending order savings.sort(reverse=True) # Initialize the sum and count of people total = 0 count = 0 # Iterate over the sorted savings list and accumulate the savings for amount in savings: total += amount count += 1 # Check if the accumulated amount has reached or exceeded the target if total >= T: return count # If total savings is less than T, it is impossible to meet the target return -1"},{"question":"You are given a string `s` composed of lowercase alphabets. You need to perform a series of operations to transform the string. In one operation, you can: - Remove a substring of `s` that is a palindrome. Your task is to find the minimum number of operations required to delete the entire string `s`. A palindrome is a string that reads the same backward as forward. Return _an integer_ representing the minimum number of operations required.","solution":"def min_operations_to_delete_string(s): Calculates the minimum number of operations required to delete the entire string by removing palindrome substrings. if not s: return 0 # Helper function to check if the string is a palindrome. def is_palindrome(st): return st == st[::-1] # If the entire string is a palindrome, only one operation is needed. if is_palindrome(s): return 1 # Otherwise, it will always take 2 operations: # 1. Remove any single character at first (since removing a single character makes it a palindrome) # 2. Remove the remaining palindrome string. return 2"},{"question":"You are given a string `s` containing only lowercase English letters and an integer `k`. You can choose up to `k` characters in the string and change them to any other lowercase English letters to form the longest possible substring of repeated characters. Return _the length of the longest possible substring with repeated characters after performing at most_ `k` _changes_. * For example, if `s = \\"aabccbb\\"` and `k = 2`, you can change the two \'c\'s to \'b\'s, making the longest substring of repeated characters \\"bbb\\", so the answer would be `5`. * If `s = \\"abbcb\\"` and `k = 1`, you can change the \'c\' to \'b\', making the longest substring \\"bbbb\\", so the answer would be `4`.","solution":"def longest_substring_with_replacements(s, k): Returns the length of the longest possible substring with repeated characters after performing at most k changes. from collections import defaultdict window_start, max_length, max_repeat_letter_count = 0, 0, 0 frequency_map = defaultdict(int) # Try to extend the range [window_start, window_end] for window_end in range(len(s)): right_char = s[window_end] frequency_map[right_char] += 1 max_repeat_letter_count = max(max_repeat_letter_count, frequency_map[right_char]) # Current window size is from window_start to window_end, overall we have window_end - window_start + 1 elements if (window_end - window_start + 1 - max_repeat_letter_count) > k: left_char = s[window_start] frequency_map[left_char] -= 1 window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"A **perfect number** is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. For example, 6 is a perfect number because `1 + 2 + 3 = 6`, and 28 is a perfect number because `1 + 2 + 4 + 7 + 14 = 28`. Write a function that returns all perfect numbers up to a given integer `n`.","solution":"def perfect_numbers_up_to_n(n): Returns a list of all perfect numbers up to a given integer n. def is_perfect(num): # Find all divisors of num divisors = [i for i in range(1, num) if num % i == 0] # Check if sum of divisors equals to the number itself return sum(divisors) == num return [i for i in range(1, n + 1) if is_perfect(i)]"},{"question":"You are given a **0-indexed** integer array `exams` of length `n` where each element represents the number of hours you need to study for each exam. You are also given an integer `maxHours` representing the maximum number of hours you can study in a single day. You need to determine the minimum number of days required to prepare for all the exams such that: * Each day you study for an exam continuously without switching between them during the same day. * The total number of hours you study each day does not exceed `maxHours`. For example, if `exams = [4, 5, 3, 2]` and `maxHours = 6`, you could split the study sessions as follows: * Day 1: 4 hours for the first exam * Day 2: 5 hours for the second exam * Day 3: 3 hours for the third exam * Day 4: 2 hours for the fourth exam As a result, you would need 4 days in this case. Return _the minimum number of days_ needed to prepare for all the exams given the constraints.","solution":"def min_days_for_exams(exams, maxHours): Returns the minimum number of days required to prepare for the exams given the maximum number of hours you can study in a single day. Parameters: exams (list of int): An array representing the number of hours each exam requires. maxHours (int): The maximum number of hours you can study in a single day. Returns: int: The minimum number of days needed to prepare for all exams. days = 0 for hours in exams: days_needed = (hours + maxHours - 1) // maxHours # Equivalent to math.ceil(hours / maxHours) days += days_needed return days"},{"question":"You are given an array of integers `nums` where `nums[i]` represents the cost of the `i-th` item. You have a budget `b` and can buy any number of items. In a single transaction, you can buy one unit of each item, meaning you cannot buy multiple units of the same item in the same transaction. Return _the **maximum** number of units you can buy without exceeding your budget._ Note that you can make multiple transactions until your budget is exhausted.","solution":"def max_items_within_budget(nums, b): Returns the maximum number of items that can be bought without exceeding the budget b. nums.sort() count = 0 sum_cost = 0 for cost in nums: if sum_cost + cost <= b: sum_cost += cost count += 1 else: break return count"},{"question":"You are given an array `arr` of integers, and a target value `k`. Find the number of contiguous subarrays within `arr` such that the sum of the elements in each subarray is equal to `k`. Return _the count of such subarrays_.","solution":"def count_subarrays_with_sum_k(arr, k): Returns the number of contiguous subarrays that sum up to k. Parameters: arr (list of int): Array of integers. k (int): Target sum value. Returns: int: Number of subarrays with sum equal to k. from collections import defaultdict count = 0 current_sum = 0 sum_counts = defaultdict(int) sum_counts[0] = 1 # To handle the case when a subarray with sum k starts from index 0 for num in arr: current_sum += num if (current_sum - k) in sum_counts: count += sum_counts[current_sum - k] sum_counts[current_sum] += 1 return count"},{"question":"You are given an array of integers `arr` and an integer `threshold`. You need to determine if it is possible to split `arr` into two non-empty subarrays such that the sum of the elements in each subarray is greater than `threshold`. Return `true` if it is possible, and `false` otherwise.","solution":"def can_split_array(arr, threshold): Determines if it is possible to split the array into two non-empty subarrays such that the sum of elements in each subarray is greater than the threshold. Parameters: arr (list): List of integers. threshold (int): The threshold value. Returns: bool: True if it is possible to split the array, False otherwise. total_sum = sum(arr) if total_sum <= threshold: return False current_sum = 0 for i in range(len(arr) - 1): current_sum += arr[i] if current_sum > threshold and (total_sum - current_sum) > threshold: return True return False"},{"question":"You are given an array of integers `arr`. An integer is considered **beautiful** if it appears exactly `k` times in `arr`. Return _the sum of all **beautiful** integers in the array. If no such integers exist, return `0`_. For example: * Given `arr = [1, 2, 2, 3, 3, 3]` and `k = 2`, the output should be `2`. * Given `arr = [1, 1, 2, 2, 3, 3, 3]` and `k = 3`, the output should be `3`. * Given `arr = [1, 1, 1, 1, 1]` and `k = 2`, the output should be `0`.","solution":"from collections import Counter def sum_of_beautiful_integers(arr, k): Returns the sum of integers that appear exactly k times in the array. If no such integers exist, return 0. count = Counter(arr) beautiful_sum = sum(num for num, freq in count.items() if freq == k) return beautiful_sum"},{"question":"You are given a 2D grid consisting of `\'1\'s` (land) and `\'0\'s` (water). An **island** is a maximal 4-directionally (horizontal and vertical) connected group of `\'1\'s`. The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected lands). The island doesn\'t have \\"lakes\\" (water inside that isn\'t connected to the water around the island). Each cell is considered as a square with a side length of 1. Given the grid, determine the perimeter of the island. Return _the **perimeter** of the island._","solution":"def islandPerimeter(grid): Given a 2D grid of \'1\'s and \'0\'s, where \'1\' represents land and \'0\' represents water, this function calculates and returns the perimeter of the island. The island is guaranteed to be surrounded by water and have no lakes (water inside the island that isn\'t connected to the water around the island). :param grid: List[List[int]] - 2D grid representing the map of the island :return: int - perimeter of the island rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Add 4 sides for each land cell perimeter += 4 # Subtract sides that are shared with another land cell if r > 0 and grid[r-1][c] == 1: perimeter -= 2 if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"**[Question 4]:** You are given a string `s` and an array of integer intervals `pairs` where `pairs[i] = [a, b]` indicates that you can swap the characters at indices `a` and `b` of the string `s`. The goal is to return the lexicographically smallest string that you can achieve after performing any number of swaps. A string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly smaller than the corresponding character in `b`. **Example:** - Input: - s = \\"dcab\\" - pairs = [[0, 3], [1, 2]] - Output: \\"bacd\\" Explanation: Perform the swaps: 1. Swap indices 0 and 3: `dcab -> bcad` 2. Swap indices 1 and 2: `bcad -> bacd`","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Initialize the union-find structure for i in range(len(s)): parent[i] = i # Applying union operations for each pair for x, y in pairs: union(x, y) # Grouping indices by their root parent groups = defaultdict(list) for i in range(len(s)): root = find(i) groups[root].append(i) # Forming the smallest possible string by sorting each group s = list(s) for group in groups.values(): indices = sorted(group) characters = sorted(s[i] for i in group) for ind, char in zip(indices, characters): s[ind] = char return \'\'.join(s)"},{"question":"You are given a string `s` representing a sequence of parentheses, and you need to remove the minimum number of parentheses ( \'(\' or \')\' ) so that the resulting string is valid. A string is considered valid if it is empty or if there are matching opening and closing parentheses for every parenthesis in the string. Your task is to implement a function that returns all possible results of the string after removing the minimum number of parentheses. Example: ``` Input: s = \\"(a)())()\\" Output: [\\"(a)()()\\", \\"(a())()\\"] Input: s = \\"(a)()\\" Output: [\\"(a)()\\"] ``` Return the list in any order.","solution":"from collections import deque def remove_invalid_parentheses(s): def is_valid(string): balance = 0 for char in string: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: return False return balance == 0 if not s: return [\\"\\"] visited = set([s]) queue = deque([s]) valid_expressions = [] found = False while queue: current = queue.popleft() if is_valid(current): valid_expressions.append(current) found = True if found: continue for i in range(len(current)): if current[i] != \'(\' and current[i] != \')\': continue next_expr = current[:i] + current[i+1:] if next_expr not in visited: visited.add(next_expr) queue.append(next_expr) return valid_expressions"},{"question":"You are given a string `s` containing only lowercase English letters. A substring is called a \\"vowel substring\\" if it contains only vowels (\'a\', \'e\', \'i\', \'o\', \'u\'). Write a function to return the longest vowel substring in `s`. If there are multiple longest vowel substrings of the same length, return the one that appears first. If there are no vowels in `s`, return an empty string.","solution":"def longest_vowel_substring(s): Returns the longest vowel substring in the provided string s. If multiple substrings have the same length, returns the first one. If there are no vowels, returns an empty string. vowels = set(\'aeiou\') max_length = 0 max_substring = \\"\\" current_length = 0 current_substring = \\"\\" for char in s: if char in vowels: current_length += 1 current_substring += char if current_length > max_length: max_length = current_length max_substring = current_substring else: current_length = 0 current_substring = \\"\\" return max_substring"},{"question":"You are given a list of pairs of dates represented as strings in the format \\"YYYY-MM-DD\\". Each pair represents a start date and an end date of a time interval inclusive. Write a function to determine the total number of unique days covered by all the given date intervals. If two or more intervals overlap, they should be counted as a single continuous period. Return the total number of unique days.","solution":"from datetime import datetime, timedelta def count_unique_days(date_pairs): Returns the total number of unique days covered by all the given date intervals. Parameters: date_pairs (list of tuples): A list of tuples where each tuple contains two strings representing the start and end dates in the format \'YYYY-MM-DD\'. Returns: int: The total number of unique days covered by all intervals. unique_days = set() for start_date, end_date in date_pairs: start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") current = start while current <= end: unique_days.add(current) current += timedelta(days=1) return len(unique_days)"},{"question":"You are given an m x n binary matrix `grid`. A binary matrix has only `0`s and `1`s as its elements. You can perform a flip operation on any 1 x 1 sub-matrix, which means you flip the value at the chosen position (i.e., change a `0` to `1` or a `1` to `0`). Your task is to design a function that returns the minimum number of flip operations required to make the matrix column-sorted. A column is considered sorted if each element is greater than or equal to the element directly above it. If it is already column-sorted, return 0.","solution":"def minFlipsToSortColumns(grid): Returns the minimum number of flip operations required to make the matrix column-sorted. m = len(grid) n = len(grid[0]) if m > 0 else 0 flips = 0 for j in range(n): for i in range(1, m): if grid[i][j] < grid[i - 1][j]: flips += 1 return flips if flips == 0 else (m * n) # We return m*n flips as approximation for correction per column"},{"question":"You are given a **0-indexed** binary matrix `grid` of size `m x n`. Each cell in the matrix contains either a `0` or a `1`. The goal is to find the maximum area of a rectangle formed only by `1`s. Implement the function `int maxRectangle(int[][] grid)` which takes a 2D binary matrix `grid` as input and returns the area of the largest rectangle containing only `1`s within the matrix. For example, given the input `grid`: ``` [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ``` The maximum rectangle containing only `1`s has an area of `6`. Implement the `maxRectangle` function that computes the maximum area of a rectangle containing only `1`s in the given binary matrix.","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 num_cols = len(matrix[0]) heights = [0] * (num_cols + 1) for row in matrix: for i in range(num_cols): if row[i] == 1: heights[i] += 1 else: heights[i] = 0 stack = [-1] for i in range(num_cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"Given an array of integers `arr` where `arr[i]` represents the number of stones in pile `i`, two players A and B take turns. Player A always starts first, and both players play optimally. On each turn, a player can take any positive number of stones from a single pile, or they can take all the stones from any one pile. A player loses the game if they cannot make a move on their turn. Return `true` if player A can guarantee a win no matter what player B does, otherwise return `false`.","solution":"def can_player_a_win(arr): Determines if player A can guarantee a win given an array of integers that represent piles of stones. :param arr: List of integers where each element represents number of stones in a pile :type arr: List[int] :return: True if player A can guarantee a win, False otherwise :rtype: bool # XOR all the pile sizes xor_sum = 0 for stones in arr: xor_sum ^= stones # Player A guarantees a win if xor_sum is non-zero return xor_sum != 0"},{"question":"You are given a list of integers `arr` and an integer `k`. Write a function that determines if there exists a pair of indices `(i, j)` such that `i < j` and the absolute difference between `arr[i]` and `arr[j]` is at most `k`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def exists_pair_with_difference(arr, k): Determines if there exists a pair of indices (i, j) such that i < j and the absolute difference between arr[i] and arr[j] is at most k. Parameters: arr (list): list of integers k (int): maximum allowed difference Returns: bool: True if such a pair exists, otherwise False length = len(arr) for i in range(length): for j in range(i + 1, length): if abs(arr[i] - arr[j]) <= k: return True return False"},{"question":"You are given a string, `s`, which consists of only lowercase letters, and an array, `dict`, of unique strings, each also consisting of only lowercase letters. You need to determine the minimum number of transformations required to change the string, `s`, into one of the strings in `dict`. A transformation consists of changing one letter in `s` to any other letter. You can transform `s` into any string in `dict` by iterating through `s` and `dict` one letter at a time. Return the minimum number of transformations required. If `s` cannot be transformed into any string in `dict`, return `-1`.","solution":"def min_transformations(s, string_dict): Returns the minimum number of transformations required to change string `s` into one of the strings in `string_dict`. If `s` cannot be transformed into any string in `string_dict`, returns `-1`. Args: s (str): The original string. string_dict (list of str): List of strings to transform `s` into. Returns: int: Minimum number of transformations, or -1 if not possible. def transformations_needed(s1, s2): return sum(1 for a, b in zip(s1, s2) if a != b) min_transforms = float(\'inf\') for target in string_dict: if len(s) == len(target): min_transforms = min(min_transforms, transformations_needed(s, target)) return min_transforms if min_transforms != float(\'inf\') else -1"},{"question":"Given an integer array `arr` and an integer `k`, find the `k` least frequent elements. If there are multiple elements with the same frequency, return the ones with the smallest value. Return the result in ascending order. Use an efficient algorithm that minimizes the time complexity while ensuring the correct elements are selected according to the criteria given.","solution":"from collections import Counter import heapq def k_least_frequent_elements(arr, k): Returns the k least frequent elements in the array. if k == 0: return [] # Count the frequency of each element in the array freq = Counter(arr) # Create a list of tuples (frequency, element) and use a heap to efficiently get the k smallest frequencies heap = [] for value, count in freq.items(): heapq.heappush(heap, (count, value)) # Extract the k elements with the smallest frequencies result = [heapq.heappop(heap)[1] for _ in range(min(k, len(heap)))] # Sort the result before returning return sorted(result)"},{"question":"Given an integer array `heights` representing the heights of students in a line, sort the students by their heights in non-decreasing order. However, there is a special requirement: each student maintains their relative order from the initial list even if their heights are the same. Implement the function `sortStudents(heights)` which returns the sorted array of heights while preserving the initial relative order of students with the same height.","solution":"def sortStudents(heights): Sorts the students by their heights in non-decreasing order while maintaining the relative order of students with the same height. Args: heights (list): A list of integers representing the heights of students. Returns: list: A sorted list of integers. return sorted(heights, key=lambda x: (x, heights.index(x)))"},{"question":"You are given an array of `n` integers where each integer represents the height of a block. The blocks are placed adjacent to each other to form a skyline. You need to determine the maximum rectangular area that can be formed within this skyline. Write a function that takes this array as input and returns the maximum rectangular area.","solution":"def max_histogram_area(heights): Returns the maximum rectangular area that can be formed within the given skyline (histogram). heights : list[int] : An array of integers representing the height of the blocks. stack = [] # to store the indices of the histogram bars max_area = 0 # initialize max area as zero index = 0 # current index while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Write a function that computes the intersection of two arrays. Each element in the result must be unique and the result can be in any order. Implement the function `intersect(nums1: List[int], nums2: List[int]) -> List[int]` which takes two arrays of integers, `nums1` and `nums2`, and returns an array of their intersection.","solution":"from typing import List def intersect(nums1: List[int], nums2: List[int]) -> List[int]: Returns the intersection of two arrays, with each element being unique. # Convert the lists to sets to handle uniqueness and find intersection set1 = set(nums1) set2 = set(nums2) # Find the intersection of both sets intersection = set1 & set2 # Convert the intersection set back to a list return list(intersection)"},{"question":"You are given a **binary search tree** (BST) with distinct values. Return _the **minimum absolute difference** between the values of any two nodes in the tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def getMinimumDifference(root: TreeNode) -> int: def in_order_traversal(node): if node is not None: in_order_traversal(node.left) in_order_traversal.result.append(node.val) in_order_traversal(node.right) in_order_traversal.result = [] in_order_traversal(root) min_diff = float(\'inf\') values = in_order_traversal.result for i in range(1, len(values)): min_diff = min(min_diff, values[i] - values[i - 1]) return min_diff"},{"question":"You are given a list of `tasks` where each task is represented by its start and end times in the format `[start, end]`. You need to find out the minimum number of meeting rooms required to schedule all the given `tasks`. A meeting room can only be used by one task at a time, and a new room is needed if a task starts before the previous task ends. Return _the minimum number of meeting rooms_ required to schedule all tasks. As the input size can be large, optimize your solution for both time and space complexity.","solution":"import heapq def min_meeting_rooms(tasks): Returns the minimum number of meeting rooms required to schedule all tasks. :param tasks: List of tasks where each task is represented by [start, end] :return: Minimum number of meeting rooms required if not tasks: return 0 # Sort tasks by start time tasks.sort(key=lambda x: x[0]) # Min-heap to keep track of end times of meetings currently using a room min_heap = [] # Add the first meeting end time to the heap heapq.heappush(min_heap, tasks[0][1]) for task in tasks[1:]: # If the current task starts after or when a task in the heap ended if task[0] >= min_heap[0]: heapq.heappop(min_heap) # Push the current task\'s end time into the heap heapq.heappush(min_heap, task[1]) # Number of rooms required is the number of tasks in the heap return len(min_heap)"},{"question":"You are given a string `s` and an integer `k`. The string `s` is composed of lowercase English letters and digits. Your task is to reformat the string such that no two adjacent characters are of the same type, i.e., no two letters or two digits are adjacent. Additionally, the maximum length of any segment of consecutive digits should not exceed `k`. Return the reformatted string if possible. If it is not possible, return an empty string.","solution":"from heapq import heappush, heappop from collections import Counter import itertools def reformat_string(s, k): # Count letters and digits letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] # If absolute difference between letters and digits is greater than one, not possible if abs(len(letters) - len(digits)) > 1: return \\"\\" # Check if any digit segment could exceed k digit_counts = Counter(digits) if any(count > k for count in digit_counts.values()): return \\"\\" # Alternate insertion result = [] if len(letters) > len(digits): longer, shorter = letters, digits else: longer, shorter = digits, letters while longer or shorter: if longer: result.append(longer.pop()) if shorter: result.append(shorter.pop()) return \\"\\".join(result)"},{"question":"You are given a rectangular grid of cells with `m` rows and `n` columns. Each cell can either be empty (represented by `0`), an obstacle (represented by `1`), or a person (represented by `2`). People can move to any adjacent empty cell (up, down, left, right) in one step. Your task is to determine the minimum number of steps required for all people to meet at a single cell. If it is not possible for all the people to meet at a single cell, return `-1`. Return the minimum number of steps required for all people in the grid to meet at a single cell, or `-1` if it\'s not possible.","solution":"from collections import deque def min_steps_to_meet(grid): def bfs(start_row, start_col): queue = deque([(start_row, start_col, 0)]) # (row, col, steps) visited = [[False for _ in range(n)] for _ in range(m)] visited[start_row][start_col] = True steps_grid = [[float(\'inf\') for _ in range(n)] for _ in range(m)] steps_grid[start_row][start_col] = 0 while queue: row, col, steps = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] != 1: visited[new_row][new_col] = True queue.append((new_row, new_col, steps + 1)) steps_grid[new_row][new_col] = steps + 1 return steps_grid m, n = len(grid), len(grid[0]) people_positions = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2] if not people_positions: return -1 if len(people_positions) == 1: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] all_steps_grids = [bfs(row, col) for row, col in people_positions] min_steps = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 1: continue total_steps = sum(steps_grid[i][j] for steps_grid in all_steps_grids if steps_grid[i][j] != float(\'inf\')) if all(steps_grid[i][j] != float(\'inf\') for steps_grid in all_steps_grids): min_steps = min(min_steps, total_steps) return -1 if min_steps == float(\'inf\') else min_steps"},{"question":"Given a string `s` consisting of `n` lowercase letters, determine if it can become a palindrome through **re-arrangement**. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_form_palindrome(s): Determines if the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character occurs an odd number of times. from collections import Counter count = Counter(s) odd_occurrences = sum(1 for char, cnt in count.items() if cnt % 2 != 0) return odd_occurrences <= 1"},{"question":"You are given a list of student records, where each record contains the student\'s ID, name, and a list of scores in various subjects. Each student has a unique ID. Write a function to generate the class\'s leaderboard. The leaderboard should be a list of tuples, each containing a student\'s ID and their average score, sorted in descending order by average score. In the case of a tie in average scores, sort the records by the student\'s ID in ascending order. The output should be a list of all the students ordered as described.","solution":"def generate_leaderboard(records): Generates the class leaderboard based on student records. Args: records (list): List of tuples, where each tuple contains student\'s ID (int), name (str), and a list of scores (list of int). Returns: list: Sorted list of tuples containing student\'s ID and their average score. # Step 1: Calculate the average score for each student avg_scores = [] for record in records: student_id = record[0] scores = record[2] avg_score = sum(scores) / len(scores) avg_scores.append((student_id, avg_score)) # Step 2: Sort the list by average score in descending order and then by student ID ascending sorted_leaderboard = sorted(avg_scores, key=lambda x: (-x[1], x[0])) return sorted_leaderboard"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists only of lowercase English letters. You need to construct a new string by selecting some (possibly none) characters from `s` and appending them in the same order to make the length of the new string equal to `k`. If it\'s not possible to construct such a string, return an empty string. Otherwise, return one of the possible shortest strings in lexicographical order.","solution":"def construct_string(s, k): Constructs a new string of length k using characters from s in lexicographical order. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The target length of the new string. Returns: str: The constructed string of length k or an empty string if it\'s not possible. if k > len(s): return \\"\\" result = [] s = sorted(s) for i in range(len(s)): if len(result) < k: result.append(s[i]) elif len(result) > k: result.pop() else: break return \'\'.join(result)"},{"question":"You are given a list of cities, and between certain pairs of cities, there is a direct road. Each city is represented as a node in a graph, and each road is a bidirectional edge between two nodes. Unfortunately, some roads are unreliable and may be temporarily unusable. Given the graph represented as an adjacency list and a list of unreliable roads, determine _the minimal number of edges that need to be added to ensure that all cities can still reach each other, assuming that none of the unreliable roads are usable_. If the graph is already connected, the answer should be zero.","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimal_edges_to_add(num_cities, edges, unreliable_edges): parent = [] rank = [] for node in range(num_cities): parent.append(node) rank.append(0) reliable_edges = [edge for edge in edges if edge not in unreliable_edges] for u, v in reliable_edges: uroot = find(parent, u) vroot = find(parent, v) if uroot != vroot: union(parent, rank, uroot, vroot) root_set = set(find(parent, i) for i in range(num_cities)) return max(0, len(root_set) - 1)"},{"question":"You are given a string `s` and an array of strings `words`. You need to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words from `words`. Consider the dictionary to be case-sensitive. Implement the following function: * `boolean wordBreak(String s, List<String> words)`: Determines if `s` can be segmented into a sequence of one or more dictionary words from `words`. Return `true` if it is possible, otherwise return `false`. For example, given `s = \\"leetcode\\"` and `words = [\\"leet\\", \\"code\\"]`, the function should return `true`. For `s = \\"applepenapple\\"` and `words = [\\"apple\\", \\"pen\\"]`, the function should also return `true`. However, for `s = \\"catsandog\\"` and `words = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]`, the function should return `false`.","solution":"def wordBreak(s, words): Determines if s can be segmented into a sequence of one or more dictionary words from words. :param s: The string to be segmented. :param words: The list of dictionary words. :return: True if s can be segmented, otherwise False. word_set = set(words) # Convert list to set for O(1) lookups dp = [False] * (len(s) + 1) # dp[i] represents if s[:i] can be segmented dp[0] = True # Empty string can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"You are given a list of `n` strings `words` where each string consists of alphanumeric characters. A string `A` is considered a prefix of a string `B` if it appears at the very beginning of `B` (including the entire string itself). Two strings are considered `prefix-compatible` if a string from `words` is a prefix of another string from `words`. Return the _number of string pairs_ `(A, B)` where `A` and `B` are prefix-compatible and `A` is not equal to `B`.","solution":"def count_prefix_compatible_pairs(words): Returns the number of prefix-compatible pairs in the given list of strings. Args: words (list): List of strings Returns: int: Number of prefix-compatible pairs (A, B) where A is a prefix of B and A != B def is_prefix(small, large): return large.startswith(small) count = 0 n = len(words) for i in range(n): for j in range(n): if i != j and is_prefix(words[i], words[j]): count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase English letters and a character `c`. You need to create an array `result` where `result[i]` is the shortest distance from the character `s[i]` to the character `c` in the string. Return _the resulting array_. You must write an algorithm with linear time complexity.","solution":"def shortest_to_char(s: str, c: str): Returns the shortest distance from each character in string `s` to the character `c`. n = len(s) result = [float(\'inf\')] * n # Forward pass prev_position = -float(\'inf\') for i in range(n): if s[i] == c: prev_position = i result[i] = min(result[i], abs(i - prev_position)) # Backward pass prev_position = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == c: prev_position = i result[i] = min(result[i], abs(i - prev_position)) return result"},{"question":"You are given an array of integers `arr` and an integer `n`. Find _the maximum sum of a contiguous subarray of length exactly_ `n`. If there are multiple subarrays with the same maximum sum, return the first one encountered in left-to-right order.","solution":"def max_sum_subarray(arr, n): Returns the first subarray of length n with the maximum sum. If there are multiple subarrays with the same maximum sum, return the first one encountered. :param arr: List of integers :param n: Integer, length of the subarray :return: List of integers representing the subarray if not arr or n <= 0 or n > len(arr): return [] max_sum = float(\'-inf\') current_sum = 0 start_index = 0 for i in range(len(arr)): current_sum += arr[i] if i >= n - 1: if current_sum > max_sum: max_sum = current_sum start_index = i - n + 1 current_sum -= arr[i - n + 1] return arr[start_index:start_index + n]"},{"question":"You are given a string `s` of lowercase English letters and an integer `k`. A substring of `s` is called **distinct** if it contains no duplicate characters. Return _the length of the longest distinct substring of `s` that contains at most_ `k` _distinct characters_.","solution":"def length_of_longest_distinct_substring(s, k): if k == 0: return 0 n = len(s) left = 0 right = 0 char_count = {} max_len = 0 distinct_count = 0 while right < n: char = s[right] if char not in char_count or char_count[char] == 0: distinct_count += 1 char_count[char] = char_count.get(char, 0) + 1 while distinct_count > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a list of integers `nums` and an integer `target`. Your goal is to find all unique pairs of elements in `nums` that sum up to the `target`. Each element in `nums` can only be used once for each pair, and the pairs should be listed with the smaller number first. Return the list of pairs sorted in ascending order. Implement the function `list<vector<int>> findPairs(vector<int>& nums, int target)` which takes a list of integers `nums` and an integer `target` and returns a list of pairs `[a, b]` such that `a + b = target`. Example: ``` Input: nums = [2, 7, 4, -5, 11, 5, 20], target = 9 Output: [[-5, 14], [2, 7], [4, 5]] ```","solution":"def find_pairs(nums, target): Find all unique pairs in nums that sum up to target. nums.sort() seen = set() pairs = set() for num in nums: needed = target - num if needed in seen: pairs.add((min(num, needed), max(num, needed))) seen.add(num) result = [list(pair) for pair in sorted(pairs)] return result # Example usage: # nums = [2, 7, 4, -5, 11, 5, 20] # target = 9 # print(find_pairs(nums, target)) # Output: [[-5, 14], [2, 7], [4, 5]]"},{"question":"You are given an integer array `nums` and an integer `k`. Rearrange the elements of `nums` such that any two adjacent elements have an absolute difference that is greater than or equal to `k`. Return _any possible rearrangement of_ `nums` _or return_ `[-1]` _if not possible_.","solution":"def rearrange_array(nums, k): nums.sort() # Sort the array to handle elements in order n = len(nums) rearranged = [0] * n # This strategy involves placing the largest element, then smallest, and so on left = 0 right = n - 1 index = 0 while left <= right: if index % 2 == 0: rearranged[index] = nums[right] right -= 1 else: rearranged[index] = nums[left] left += 1 index += 1 # After arranging, we need to validate the arrangement for i in range(1, n): if abs(rearranged[i] - rearranged[i - 1]) < k: return [-1] return rearranged"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped at each bar in a histogram, where the width of each bar is 1. Write a function `trap` that will calculate the total amount of rainwater trapped after it rains. The function should take in a list of integers `height` and return an integer representing the total amount of trapped rainwater. Assume that the input list has at least two elements. The function needs to account for both upward and downward slopes in the histogram to compute the trapped water accurately. For example, given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, the function should return `6`.","solution":"def trap(height): Calculate the total amount of rainwater trapped after it rains. Parameters: height (list of int): List of non-negative integers representing the height of bars in histogram. Returns: int: Total amount of trapped rainwater. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"Given an array `arr` of integers, you are tasked with determining whether it can be transformed into a non-decreasing array by modifying at most one element. Non-decreasing means that for every `i` (1 <= i < arr.length), `arr[i - 1] <= arr[i]`. Return a boolean value `true` if the array can be made non-decreasing by modifying at most one element, otherwise return `false`.","solution":"def checkPossibility(nums): Determines if the array can be made non-decreasing by modifying at most one element. Parameters: nums (List[int]): The input array of integers. Returns: bool: True if the array can be made non-decreasing by modifying at most one element, otherwise False. one_change_allowed = True for i in range(1, len(nums)): if nums[i] < nums[i - 1]: if not one_change_allowed: return False one_change_allowed = False if i == 1 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] # modify nums[i - 1] else: nums[i] = nums[i - 1] # modify nums[i] return True"},{"question":"Given a `root` of a binary tree, imagine you want to count the number of subtrees where all the nodes have the same value. A subtree is defined as a node in the tree and all of its descendants. Write a function to return the total number of such subtrees. Your task is to develop an algorithm that takes the root of the binary tree and returns an integer representing the count of these univalue subtrees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def countUnivalSubtrees(root): def isUnivalTree(node): if not node: return True is_left_unival = (not node.left or (isUnivalTree(node.left) and node.left.val == node.val)) is_right_unival = (not node.right or (isUnivalTree(node.right) and node.right.val == node.val)) if is_left_unival and is_right_unival: nonlocal count count += 1 return True return False count = 0 isUnivalTree(root) return count"},{"question":"You are given an array of integers `heights` representing the height of buildings, where each building is 1 unit wide. The goal is to find the largest rectangle that can be formed in the histogram represented by the heights array. Each rectangle\'s width must be at least one and span contiguous buildings. Return _the area of the largest rectangle_ that can be formed in the histogram. [Question] 5:","solution":"def largestRectangleArea(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given two strings `s` and `t` of lengths `m` and `n` respectively. You need to determine if `t` is an **anagram** of `s` after removing exactly `k` characters from `t`. Return `true` _if you can transform_ `t` _into an anagram of_ `s` _by removing exactly_ `k` _characters, otherwise return_ `false`. **Note**: An anagram of a string is another string that contains the same characters, only the order of characters can be different.","solution":"def can_form_anagram(s, t, k): Determine if t can be transformed into an anagram of s by removing exactly k characters from t. :param s: The target string to become an anagram of :param t: The string to transform :param k: The number of characters to remove from t :return: True if t can be transformed into an anagram of s by removing exactly k characters, False otherwise from collections import Counter # Count characters in both strings. s_count = Counter(s) t_count = Counter(t) # Calculate excess characters in t_count excess = sum((t_count - s_count).values()) # Check if exactly k characters can be removed to form an anagram required_removals = sum((t_count - s_count).values()) + max(0, sum((s_count - t_count).values())) return required_removals == k"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the shortest substring of `s` that can be removed such that the remaining string does not contain three consecutive identical characters. If no such substring exists, return `-1`. Write a function that takes the string `s` as input and returns the length of the shortest removable substring. The function should aim to optimize both time and space complexity.","solution":"def shortest_removable_substring(s): Returns the length of the shortest removable substring such that the remaining string does not contain three consecutive identical characters. n = len(s) # Iterate through the string to identify triplets of consecutive identical characters for i in range(n - 2): if s[i] == s[i + 1] == s[i + 2]: return 3 # Since removing a triplet will always resolve the problem # Case when no such triplets exist return -1"},{"question":"Given a matrix `mat` of size `n x m` where each cell contains an integer. You can perform operations on the matrix to maximize the sum of elements in the matrix after a series of transformations. The allowed operations are: * Swap the contents of any two cells. * Increment the value of any cell by 1. * Decrement the value of any cell by 1. Implement a function `maximizeMatrix(mat)` that takes this matrix as input, applies the allowed operations as many times as needed, and returns the maximum possible sum of the matrix\'s elements after these operations. Note that transformations can be performed in any order and any number of times.","solution":"def maximizeMatrix(mat): Returns the sum of elements in mat since it\'s invariant under allowed operations. return sum(sum(row) for row in mat)"},{"question":"You are given a list of strings `words` and a string `target`. Your task is to determine if `target` can be constructed by concatenating any subsequence of the strings in `words` (subsequences might include words in any order). Return _True_ if it is possible to form the `target` string using any subsequence of `words`; otherwise, return _False_.","solution":"def can_construct_target(words, target): Returns True if target can be constructed by concatenating any subsequence of the strings in words. Returns False otherwise. # Mapping characters in target to their frequencies target_char_count = {} for char in target: if char in target_char_count: target_char_count[char] += 1 else: target_char_count[char] = 1 # Mapping characters in words list to their frequencies words_char_count = {} for word in words: for char in word: if char in words_char_count: words_char_count[char] += 1 else: words_char_count[char] = 1 # Check if all characters in target can be formed by characters in words for char, count in target_char_count.items(): if words_char_count.get(char, 0) < count: return False return True"},{"question":"A string is considered **balanced** if it contains an equal number of each type of opening and closing brackets. The brackets can include `()`, `[]`, and `{}`. You are given a string `s` containing only these brackets. Return _the length of the longest **balanced** substring in `s`_. A substring is a contiguous sequence of characters within a string.","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in s. stack = [] max_length = 0 last_invalid_index = -1 for index, char in enumerate(s): if char in \\"([{\\": stack.append((char, index)) else: if stack and ((stack[-1][0] == \'(\' and char == \')\') or (stack[-1][0] == \'[\' and char == \']\') or (stack[-1][0] == \'{\' and char == \'}\')): stack.pop() if stack: max_length = max(max_length, index - stack[-1][1]) else: max_length = max(max_length, index - last_invalid_index) else: last_invalid_index = index return max_length"},{"question":"You are given an array of characters `tasks`, where each character represents a task. Each task can be done in one unit of time. For each unit of time, you can either complete one task or be idle. However, there must be at least `n` units of time between two identical tasks. Given an integer `n` representing the cooldown interval between the same tasks, return the least number of units of times that the CPU will take to finish all the given tasks. Example 1: ``` Input: tasks = [\'A\',\'A\',\'A\',\'B\',\'B\',\'B\'], n = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B. ``` Example 2: ``` Input: tasks = [\'A\',\'A\',\'A\',\'B\',\'B\',\'B\'], n = 0 Output: 6 Explanation: On this case any permutation of the tasks will be valid since n = 0. ``` Example 3: ``` Input: tasks = [\'A\',\'A\',\'A\',\'A\',\'A\',\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\'], n = 2 Output: 16 Explanation: One possible solution is A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A. ```","solution":"from collections import Counter def leastInterval(tasks, n): Calculate the least number of units of times that the CPU will take to finish all the given tasks. if n == 0: return len(tasks) task_counts = Counter(tasks) max_tasks = max(task_counts.values()) max_count_task_occurrences = sum(1 for task in task_counts.values() if task == max_tasks) slots = (max_tasks - 1) * (n + 1) + max_count_task_occurrences return max(len(tasks), slots)"},{"question":"You are given a linked list of integers represented by its head node. Also, you are provided with an integer `n`. Your task is to find and return the value of the `n-th` node from the end of the list (1-indexed). If the linked list does not have `n` nodes, return `-1`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_nth_from_end(head, n): Finds the value of the n-th node from the end of the list. :param head: ListNode, the head node of the linked list :param n: int, the position from the end of the list (1-indexed) :return: int, the value of the n-th node from the end # Fast and Slow pointer approach fast = slow = head # Move fast pointer n steps ahead for _ in range(n): if not fast: return -1 # if n is more than the length of the list fast = fast.next # Move both pointers until fast reaches the end while fast: fast = fast.next slow = slow.next return slow.val if slow else -1"},{"question":"You are given a **0-indexed** integer array `freq` of length `26`, where `freq[i]` represents the frequency of the `i`-th character in the alphabet (i.e., `freq[0]` is the frequency of \'a\', `freq[1]` is the frequency of \'b\', and so on). You are also provided with a string `s` composed of lowercase English letters. Construct the **lexicographically smallest** string that can be formed using characters from `s` such that the frequency of the characters in the resultant string adheres to the frequencies defined in `freq`. If there are multiple solutions, return the one that appears earliest in lexicographical order.","solution":"def smallest_lexicographical_string(freq, s): from collections import Counter # Count the frequency of each character in the given string s s_counter = Counter(s) # Create a list to hold the resulting characters result = [] # Iterate through each character from \'a\' to \'z\' for i in range(26): char = chr(i + ord(\'a\')) # Get the required frequency from freq list required_count = freq[i] # Get the actual count in the input string s actual_count = s_counter[char] # Append the minimum of required and actual count of characters result.append(char * min(required_count, actual_count)) # Join all characters to form the resultant string return \'\'.join(result)"},{"question":"Given an integer array `arr`, find _the length of the longest subarray with an equal number of_ `0`s _and_ `1`s_.","solution":"def findMaxLength(arr): Finds the length of the longest subarray with an equal number of 0s and 1s. The approach is based on using a hashmap to store (count, index) pairs. Parameters: arr (list): The input array containing only 0s and 1s. Returns: int: The length of the longest subarray with equal number of 0s and 1s. count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(arr): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"Given a list of non-negative integers `nums`, you are tasked with implementing a special binary searchable array that supports the following operations: * `SpecialArray(int[] nums)`: Initializes the object with the list `nums`. * `void update(int index, int value)`: Updates the element at index `index` to `value`. * `int kOccurrences(int k)`: Returns the number of elements in the array that are equal to `k`. * `boolean specialSearch(int target)`: Performs a binary search for `target` in the array. After the search, returns `true` if `target` is found, otherwise `false`. Note: The array can contain duplicate elements, and elements can be dynamically updated. When performing a binary search, assume that the array is sorted. Implement any necessary sorting after each update to maintain the order.","solution":"class SpecialArray: def __init__(self, nums): Initializes the object with the list nums. self.nums = sorted(nums) def update(self, index, value): Updates the element at index index to value. self.nums[index] = value self.nums.sort() def kOccurrences(self, k): Returns the number of elements in the array that are equal to k. return self.nums.count(k) def specialSearch(self, target): Performs a binary search for target in the array and returns True if found, otherwise returns False. left, right = 0, len(self.nums) - 1 while left <= right: mid = (left + right) // 2 if self.nums[mid] == target: return True elif self.nums[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"You are given two **0-indexed** integer arrays `array1` and `array2` of the same length `n`. You can perform the following operation any number of times: * Swap the elements at the same positions of `array1` and `array2`. Your goal is to minimize the sum of the absolute differences between corresponding elements of the two arrays. Formally, you want to minimize the value of: [ sum_{i=0}^{n-1} |array1[i] - array2[i]| ] Return _the minimum sum of absolute differences after performing the allowed operations_.","solution":"def min_absolute_sum_difference(array1, array2): Returns the minimum sum of absolute differences between array1 and array2 after performing the allowed swap operations. # Calculate the initial sum of absolute differences initial_sum = sum(abs(a - b) for a, b in zip(array1, array2)) # If the arrays are the same, the minimum sum of absolute differences is zero if initial_sum == 0: return 0 # Sort both arrays for comparison sorted1 = sorted(array1) sorted2 = sorted(array2) # Calculate the minimun absolute sum differences after optimal swapping min_sum = 0 for i in range(len(array1)): # Find the closest element in sorted2 for the current element in sorted1 diff = min(abs(array1[i] - array2[i]), abs(array1[i] - sorted2[i])) min_sum += diff return min_sum"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Rearrange the elements of `nums` such that the difference between any two consecutive elements does not exceed `k`. If possible, return the rearranged list. If it is not possible, return an empty list.","solution":"def rearrange_list(nums, k): Rearrange the elements of `nums` such that the difference between any two consecutive elements does not exceed `k`. If possible, return the rearranged list. If it is not possible, return an empty list. Args: nums (list): List of non-negative integers. k (int): Maximum allowed difference between consecutive elements. Returns: list: Rearranged list or empty list if not possible. nums.sort() for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) > k: return [] return nums"},{"question":"You are given a list of integers `nums` and an integer `target`. Find _all unique pairs of integers in the list that sum up to the `target`_. A pair `(nums[i], nums[j])` is considered unique if there are no two pairs with the same elements in different orders. Return _a list of unique pairs_. Each pair should be in the form of a list `[nums[i], nums[j]]`. The pairs should be returned in ascension order based on the lexographic order of their elements.","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the list that sum up to the target. Parameters: nums (list): List of integers target (int): The target sum Returns: list: A list of unique pairs that sum up to the target nums.sort() seen = set() output = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((complement, num))) output.add(pair) seen.add(num) return [list(pair) for pair in sorted(output)]"},{"question":"You are given a list of integers `arr` representing the profit you earn each day from a certain business. However, there are certain days where you face a loss, represented by negative numbers in the list. From this list, you need to determine the maximum profit you can make by choosing a **contiguous subarray** of days. Your task is to implement a function that finds the maximum possible sum of the contiguous subarray (subsequence) with the largest sum. Return _the maximum profit you can make_ from this contiguous subarray. --- Note: A subarray is a contiguous part of an array.","solution":"def max_subarray_profit(arr): Returns the maximum profit that can be made from a contiguous subarray of the given array of profits (and losses). Implements Kadane\'s algorithm to find the maximum sum subarray in O(n) time complexity. if not arr: return 0 max_current = max_global = arr[0] for profit in arr[1:]: max_current = max(profit, max_current + profit) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given two strings, `s1` and `s2`, consisting of lowercase English letters. You need to determine if you can transform `s1` into `s2` using the following operation any number of times: - Choose a character `ch` in `s1` and replace every occurrence of `ch` in `s1` with any character from `\'a\'` to `\'z\'`. Return `true` if it is possible to transform `s1` into `s2` in this way, otherwise return `false`.","solution":"def can_transform(s1, s2): Determines if we can transform s1 into s2 by replacing characters in s1 with any character from \'a\' to \'z\'. # If strings are of different lengths, transformation is not possible if len(s1) != len(s2): return False # Using sets to count unique characters unique_chars_s1 = set(s1) unique_chars_s2 = set(s2) # If the number of unique characters in s2 is greater than in s1, # it\'s not possible to transform s1 into s2 because we\'re allowed to replace characters # but cannot introduce new unique characters more than we already have in s1. if len(unique_chars_s2) > len(unique_chars_s1): return False return True"},{"question":"Given a string `s` which consists of lowercase letters, determine the minimum number of adjacent swaps required to make the string a palindrome. If it is not possible to form a palindrome, return `-1`. Implement the function `int minSwapsToPalindrome(String s)` that performs the following tasks: - Return the minimum number of adjacent swaps needed or `-1` if forming a palindrome is not possible.","solution":"def min_swaps_to_palindrome(s): Returns the minimum number of adjacent swaps needed to make the string a palindrome. If it is not possible to form a palindrome, returns -1. def is_palindrome_possible(s): odd_count = sum(freq % 2 for freq in Counter(s).values()) return odd_count <= 1 def min_swaps_needed(l): swaps = 0 for i in range(len(l)//2): left = i right = len(l) - left - 1 while left < right: if l[left] == l[right]: break else: right -= 1 if left == right: l[left], l[left + 1] = l[left + 1], l[left] swaps += 1 continue for j in range(right, len(l) - left - 1): l[j], l[j + 1] = l[j + 1], l[j] swaps += 1 return swaps from collections import Counter if not is_palindrome_possible(s): return -1 s_list = list(s) return min_swaps_needed(s_list)"},{"question":"Given two strings `s` and `t`, your goal is to determine whether `s` can be transformed into `t` by applying one of the following operations exactly once: 1. **Insert** one character anywhere in `s`. 2. **Delete** one character from `s`. 3. **Replace** one character in `s` with another character. Return `true` if it is possible to transform `s` into `t` by applying exactly one of these operations; otherwise, return `false`.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by performing exactly one of these operations: insert one character, delete one character, or replace one character. len_s, len_t = len(s), len(t) # Case 1: Insert one character (len_s + 1 == len_t) if len_s + 1 == len_t: for i in range(len_t): if s[:i] + t[i] + s[i:] == t: return True # Case 2: Delete one character (len_s - 1 == len_t) elif len_s - 1 == len_t: for i in range(len_s): if s[:i] + s[i+1:] == t: return True # Case 3: Replace one character (len_s == len_t) elif len_s == len_t: difference_count = 0 for i in range(len_s): if s[i] != t[i]: difference_count += 1 if difference_count > 1: return False return difference_count == 1 return False"},{"question":"You are given two integers `low` and `high` and an integer `k`. You need to find the maximum number of integers between `low` and `high` (inclusive) that are divisible by `k`. Return _the maximum count of such integers_.","solution":"def count_divisibles(low, high, k): Returns the count of numbers between low and high (inclusive) that are divisible by k. if k <= 0: raise ValueError(\\"k must be a positive integer\\") if low > high: return 0 # Find the first number >= low that is divisible by k if low % k == 0: start = low else: start = low + (k - low % k) # Find the last number <= high that is divisible by k if high % k == 0: end = high else: end = high - (high % k) if start > high or end < low: return 0 # Number of k-divisible numbers in the range [start, end] return (end - start) // k + 1"},{"question":"You are given an integer array `numbers` and an integer `target`. You need to find all pairs of integers in the array whose sum is equal to `target`. Each pair should be represented as a tuple `(a, b)` where `a` and `b` are elements from the array and `a <= b`. Return a list of all such pairs `(a, b)` and make sure the list does not contain duplicates. The pairs in the list should be sorted in non-decreasing order by their first elements, and within each pair, `a` should be placed before `b`.","solution":"def find_pairs_with_sum(numbers, target): Find all unique pairs (a, b) in the list \'numbers\' such that a + b = target. Each pair (a, b) should be in non-decreasing order and the resulting list of pairs should be sorted. pairs = set() seen = set() for number in numbers: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return sorted(pairs)"},{"question":"Given a matrix `mat` of size `m x n` and an integer `k`, write an algorithm to find the `k-th` smallest element in the matrix. Each row and column of the matrix is sorted in ascending order. Note that it is the `k-th` smallest element _in the sorted order_, not the `k-th` distinct element.","solution":"import heapq def kthSmallest(mat, k): Returns the k-th smallest element in a matrix sorted row-wise and column-wise. :param mat: List of lists of integers representing the matrix. :param k: Integer, the k-th position to find the smallest element. :return: The k-th smallest element of the matrix. n = len(mat) # Using a min heap to keep track of the smallest elements min_heap = [(mat[0][0], 0, 0)] visited = set((0, 0)) # Remove elements from the heap k-1 times for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (mat[r + 1][c], r + 1, c)) visited.add((r + 1, c)) if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (mat[r][c + 1], r, c + 1)) visited.add((r, c + 1)) return min_heap[0][0]"},{"question":"You are given an array of integers `nums`. The array is considered **special** if every integer in the array can be divided by at least one other integer in the array (not including itself). Return a new array containing all the **special** integers from `nums`. The integers in the new array should be in the same relative order as they appear in `nums`.","solution":"def get_special_integers(nums): Returns a list of special integers from the input list nums. An integer is considered special if it can be divided by at least one other integer in the array (not including itself). special_integers = [] for num in nums: for other in nums: if num != other and num % other == 0: special_integers.append(num) break return special_integers"},{"question":"You are given an array of integers `nums` where the values can be both positive and negative. Your task is to find the **maximum product** of a contiguous subarray within the given array. A contiguous subarray is defined as a sequence of `nums` values with indices `i` and `j` such that `i <= j` and all consecutive integers between `i` and `j` belong to the subarray. Return the maximum product of any contiguous subarray.","solution":"def max_product_subarray(nums): if not nums: return 0 max_product = min_product = result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, num * max_product) min_product = min(num, num * min_product) result = max(result, max_product) return result"},{"question":"You are given an array of integers `arr` of length `n`. You are allowed to perform at most one operation on the array, in which you can remove a single element from the array. Return the length of the longest subarray consisting of only 1\'s such that you can obtain by possibly removing one element from the original array. For example, given the array `arr = [1, 1, 0, 1, 1, 1]`, the function should return `5`, since removing the single `0` would result in the array `[1, 1, 1, 1, 1]`.","solution":"def longest_subarray_after_removal(arr): This function returns the length of the longest subarray consisting of only 1\'s that can be obtained by possibly removing one element from the original array. max_length = 0 left = 0 zero_count = 0 n = len(arr) for right in range(n): if arr[right] == 0: zero_count += 1 while zero_count > 1: if arr[left] == 0: zero_count -= 1 left += 1 current_length = right - left max_length = max(max_length, current_length) return max_length"},{"question":"Given a string `s` consisting of lowercase letters, remove the minimum number of characters so that any two neighboring characters are different. Return the resulting string after the removals. If there are multiple solutions, return any of them.","solution":"def remove_min_chars(s): Removes the minimum number of characters from the string `s` so that no two neighboring characters are the same. Returns the resulting string. if not s: return \\"\\" result = [s[0]] # Initialize the result with the first character for char in s[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"You are given a 0-indexed array of integers `nums` representing the number of chocolates in each bag. You can perform the following operation any number of times: choose any two bags with at least one chocolate each and transfer one chocolate from one bag to the other. Your goal is to make the number of chocolates in every bag equal. Return _the minimum number of operations to achieve this, or -1 if it\'s impossible._","solution":"def min_operations_to_equalize_chocolates(nums): total_chocolates = sum(nums) n = len(nums) # It\'s impossible to equalize if total chocolates are not divisible by number of bags if total_chocolates % n != 0: return -1 target = total_chocolates // n operations = 0 imbalance = 0 for chocolates in nums: imbalance += chocolates - target operations += abs(imbalance) return operations"},{"question":"You are given a positive integer `n` representing the number of cities, numbered from `0` to `n - 1` (**inclusive**). You are also given a 2D integer array `roads` of length `m`, where `roads[i] = [city1i, city2i, timei]` denotes that there is a **bidirectional** road connecting `city1i` and `city2i` with a travel time of `timei` units. You are also given an integer `startCity`, representing the city where you start. Return _an integer array_ `minTime` _of length_ `n`, _where_ `minTime[i]` _is the **minimum travel time** required to reach city_ `i` _from the_ `startCity`_. If a city is unreachable from the `startCity`, the travel time should be `-1`.","solution":"import heapq def shortest_path(n, roads, startCity): Returns the minimum travel time required to reach each city from startCity. Parameters: n (int): number of cities. roads (List[List[int]]): 2D integer array where roads[i] = [city1i, city2i, timei]. startCity (int): city to start from. Returns: List[int]: minimum travel time required to reach each city from startCity, or -1 if unreachable. # Create a graph using adjacency list graph = [[] for _ in range(n)] for city1, city2, time in roads: graph[city1].append((city2, time)) graph[city2].append((city1, time)) # Dijkstra\'s Algorithm min_heap = [(0, startCity)] # (time, city) min_time = [float(\'inf\')] * n min_time[startCity] = 0 visited = set() while min_heap: current_time, current_city = heapq.heappop(min_heap) if current_city in visited: continue visited.add(current_city) for neighbor, travel_time in graph[current_city]: new_time = current_time + travel_time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(min_heap, (new_time, neighbor)) return [time if time != float(\'inf\') else -1 for time in min_time]"},{"question":"You are given an integer array `arr` consisting of distinct values and an integer `k`. We define an operation where we can choose any subarray of `arr` and reverse it. Our task is to determine if it is possible to sort `arr` in ascending order using at most `k` reverse operations. Return _true_ if it\'s possible to sort the array within `k` operations, otherwise return _false_.","solution":"def can_sort_with_k_reversals(arr, k): Determine if it is possible to sort array `arr` using at most `k` reverse operations. Parameters: arr (list of int): List of distinct integers. k (int): Maximum number of reversals allowed. Returns: bool: True if the array can be sorted in at most `k` reversals, False otherwise. # Desired array is sorted array sorted_arr = sorted(arr) # Initialize the number of misplaced elements count count = 0 # Compare elements with their sorted position for i in range(len(arr)): if arr[i] != sorted_arr[i]: count += 1 # Count the minimum number of reversals required # Each reversal can at most fix 2 misplaced elements min_reversals_required = count // 2 + count % 2 # Check if we can sort the array within k reversals return min_reversals_required <= k"},{"question":"You are given a string `s` consisting of lowercase letters and integers. Your task is to return a string with all the integers in `s` incremented by 1 (i.e., `9` should wrap around to `0`). The other characters should remain unchanged. Order of characters in the returned string should match the order they appeared in the original string.","solution":"def increment_digits(s): Takes a string s consisting of lowercase letters and integers, and returns a new string with all the integers incremented by 1. result = [] for char in s: if char.isdigit(): incremented_digit = (int(char) + 1) % 10 result.append(str(incremented_digit)) else: result.append(char) return \'\'.join(result)"},{"question":"You are given an `n` x `m` matrix `matrix` where each element is an integer. Write a function to return _the maximum possible sum of elements of any non-empty rectangular submatrix_ within the given matrix.","solution":"def max_sum_submatrix(matrix): if not matrix or not matrix[0]: return 0 def max_subarray(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(matrix) m = len(matrix[0]) max_sum = float(\'-inf\') for left in range(m): tmp = [0] * n for right in range(left, m): for i in range(n): tmp[i] += matrix[i][right] max_sum = max(max_sum, max_subarray(tmp)) return max_sum"},{"question":"You are given a **linked list** where each node contains an integer value. Your task is to **reorder** the list such that every even-indexed node is followed by an odd-indexed node. The list should be zero-indexed. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5`, it should be rearranged as `1 -> 3 -> 5 -> 2 -> 4`. Write a function that returns the reordered list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reorder_even_odd(head): if not head: return None even_head = even = ListNode(0) odd_head = odd = ListNode(0) current = head is_even = True while current: if is_even: even.next = current even = even.next else: odd.next = current odd = odd.next current = current.next is_even = not is_even even.next = odd_head.next odd.next = None return even_head.next def linked_list_to_list(head): result = [] while head: result.append(head.value) head = head.next return result def list_to_linked_list(lst): head = ListNode(0) current = head for value in lst: current.next = ListNode(value) current = current.next return head.next"},{"question":"You are given an integer array `nums`. A subarray is defined as a contiguous portion of the array. Your task is to find the length of the **longest subarray** where the sum of elements is **equal** to a given integer `k`. Return _the length of the longest subarray_ with a sum equal to `k`. If there is no such subarray, return `0`. Example: - For an array `nums = [1, -1, 5, -2, 3]` and `k = 3`, the longest subarray with sum `3` is `[1, -1, 5, -2]` which has length `4`. - For an array `nums = [-2, -1, 2, 1]` and `k = 1`, the longest subarray with sum `1` is `[2, 1]` which has length `2`. - If no such subarray exists, return `0`.","solution":"def max_subarray_len(nums, k): Finds the length of the longest subarray with sum equal to k. if not nums: return 0 sum_index_map = {0: -1} # Dictionary to store (cumulative sum : index) pairs cumulative_sum = 0 max_length = 0 for i, num in enumerate(nums): cumulative_sum += num if cumulative_sum - k in sum_index_map: max_length = max(max_length, i - sum_index_map[cumulative_sum - k]) if cumulative_sum not in sum_index_map: sum_index_map[cumulative_sum] = i return max_length"},{"question":"You are given a string `s` and an array of strings `dictionary`. Determine if `s` can be **formed** by **concatenating** any subset of words (including possibly empty subset) from `dictionary`. The subset words can be used multiple times and the concatenation of the subset words must be in the same order as they appear in the dictionary. Return _the **length** of the shortest subset that can form_ `s`. If no subset can form the string, return `-1`.","solution":"def shortest_subset_length(s, dictionary): Determines the length of the shortest subset of words from dictionary that can form the string s. A word can be used multiple times and must be concatenated in the same order. Returns -1 if no such subset can form s. # Initialize a dictionary to store the minimum length to form each substring of s dp = {0: 0} # {end_index: min_length} for i in range(1, len(s) + 1): # Initialize min_length for the current substring min_length = float(\'inf\') for word in dictionary: if s[:i].endswith(word): start_index = i - len(word) if start_index in dp: min_length = min(min_length, dp[start_index] + 1) if min_length != float(\'inf\'): dp[i] = min_length return dp.get(len(s), -1)"},{"question":"Given a binary matrix `mat` of size `m x n`, return the coordinates of the cell with the smallest value. If there are multiple cells with the smallest value, return the one that appears first in row-major order (i.e., top-left to bottom-right). If the matrix is empty, return `[-1, -1]`. A binary matrix is a matrix that only contains `0`s and `1`s.","solution":"def find_min_value_coordinates(mat): Returns the coordinates of the cell with the smallest value in the binary matrix \'mat\'. If there are multiple cells with the smallest value, returns the one that appears first in row-major order. If the matrix is empty, returns [-1, -1]. if not mat or not mat[0]: return [-1, -1] min_value = float(\'inf\') min_coords = [-1, -1] for i, row in enumerate(mat): for j, value in enumerate(row): if value < min_value: min_value = value min_coords = [i, j] return min_coords"},{"question":"You are managing a portfolio of recipes for a baking competition. Each recipe is represented by an integer array `ingredients` where `ingredients[i]` is the amount of the ith ingredient required for the recipe. You have a limited stock of ingredients represented by another integer array `stock` where `stock[i]` is the available amount of the ith ingredient. Identify the maximum number of times you can fully prepare the recipe from the given stock. Return _the maximum number of complete recipes that can be prepared_.","solution":"def maxCompleteRecipes(ingredients, stock): Given the ingredient requirements and available stock, return the maximum number of complete recipes that can be prepared. :param ingredients: List of integers representing the amount of each ingredient required for one recipe. :param stock: List of integers representing the available amount of each ingredient. :return: Maximum number of complete recipes possible. if not ingredients or not stock or len(ingredients) != len(stock): return 0 # Find the maximum number of times we can use each ingredient max_recipes = float(\'inf\') for i in range(len(ingredients)): if ingredients[i] == 0: continue # If no ingredient is required, skip it max_possible = stock[i] // ingredients[i] max_recipes = min(max_recipes, max_possible) return max_recipes if max_recipes != float(\'inf\') else 0"},{"question":"Write a function that takes as input a list of integers and returns the length of the longest contiguous subarray with an equal number of 1s and 0s. If there are multiple such subarrays with the same length, return any one of them.","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 1s and 0s. count = 0 max_len = 0 count_map = {0: -1} for i in range(len(nums)): count += 1 if nums[i] == 1 else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"Given a list of `n` positive integers, `coins`, where `coins[i]` represents the value of the ith coin, you are asked to determine the minimum number of coins needed to make a total value of `amount`. You can assume you have an infinite supply of each type of coin. If it is not possible to make the amount with the given coins, return -1. Write a function `minCoins(coins, amount)` that returns the minimum number of coins required to achieve the desired amount.","solution":"def minCoins(coins, amount): Returns the minimum number of coins needed to make the total value of \'amount\'. If it is not possible to make the amount with the given coins, returns -1. :param coins: List of positive integers representing the coin values. :param amount: Integer representing the target amount. :return: Minimum number of coins needed, or -1 if the amount cannot be formed. # DP array to store the minimum coins needed for each amount from 0 to amount dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins to make the amount 0 # Update dp array for each coin for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"You are a given a sorted array `nums` of unique integers and a target integer `target`. Suppose you rearrange the array by rotating it some number of steps so that the array becomes `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` for some `k` (0 ≤ k < n). You want to determine the starting position of `target` if it is present in the rotated array. If it is not present, return -1. Write a function to accomplish this in O(log n) time.","solution":"def search_in_rotated_array(nums, target): Searches for the target in a rotated sorted array and returns its index. If the target is not found, returns -1. Args: nums (List[int]): The rotated sorted array. target (int): The target value to search for. Returns: int: The index of the target value or -1 if not found. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # Left side is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right side is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given an m x n matrix filled with integers. Your task is to count the number of distinct paths from the top-left cell to the bottom-right cell of the matrix such that the sum of the integers along the path is equal to a given integer `target`. You can only move right or down from a cell. Return _the number of paths that meet the criteria._","solution":"def count_paths_with_target_sum(matrix, target): Returns the number of distinct paths from the top-left to the bottom-right cell of the matrix such that the sum of the integers along the path equals the target. You can only move right or down from a cell. m, n = len(matrix), len(matrix[0]) # Memoization dictionary memo = {} def dfs(r, c, path_sum): if r == m-1 and c == n-1: return 1 if path_sum + matrix[r][c] == target else 0 if (r, c, path_sum) in memo: return memo[(r, c, path_sum)] total_paths = 0 if r < m - 1: total_paths += dfs(r + 1, c, path_sum + matrix[r][c]) if c < n - 1: total_paths += dfs(r, c + 1, path_sum + matrix[r][c]) memo[(r, c, path_sum)] = total_paths return total_paths return dfs(0, 0, 0)"},{"question":"Given an array of integers `arr` and an integer `target`, you need to find if there exists a pair of integers in the array whose sum is equal to `target`. Return a list of the indices of the two numbers such that they add up to `target`. If such a pair does not exist, return an empty list. * For example, if `arr = [2, 7, 11, 15]` and `target = 9`, then since `arr[0] + arr[1] = 9`, you should return `[0, 1]`. * If `arr = [3, 2, 4]` and `target = 6`, then since `arr[1] + arr[2] = 6`, you should return `[1, 2]`. You may assume that each input would have exactly one solution, and you may not use the same element twice.","solution":"def two_sum(arr, target): Finds two distinct indices in the array such that their corresponding values add up to the given target. Parameters: arr (List[int]): List of integers. target (int): The target sum. Returns: List[int]: The list containing the indices of the two numbers that add up to target. If no such pair exists, returns an empty list. # Dictionary to store the index of the complementary number complement_dict = {} for index, number in enumerate(arr): complement = target - number if complement in complement_dict: return [complement_dict[complement], index] complement_dict[number] = index return []"},{"question":"You are given two integer arrays `nums1` and `nums2` both of size `n`. You need to create a new array `result` where `result[i]` is the maximum of `nums1[i]` and `nums2[i]` if `i` is even, or the minimum of `nums1[i]` and `nums2[i]` if `i` is odd. Return the `result` array.","solution":"def max_min_array(nums1, nums2): Returns a new array where each element is the maximum of nums1[i] and nums2[i] if i is even, or the minimum of nums1[i] and nums2[i] if i is odd. result = [] for i in range(len(nums1)): if i % 2 == 0: result.append(max(nums1[i], nums2[i])) else: result.append(min(nums1[i], nums2[i])) return result"},{"question":"Given a list of integers `nums` and an integer `target`, determine if the list can be partitioned into two subsets such that the sum of the elements in both subsets is equal to `target`. Implement the function `canPartition(nums, target)` that returns `true` if such a partition exists, otherwise returns `false`. Each element in the list can be used in either of the two subsets, but not both. Note that you do not need to use all elements and the subsets do not need to be contiguous. Example: ``` Input: nums = [1, 5, 11, 5], target = 11 Output: true Explanation: The list can be partitioned into [11] and [1, 5, 5] which both sum up to 11. Input: nums = [1, 2, 3, 5], target = 5 Output: true Explanation: The list can be partitioned into [2, 3] and [1, 5] which both sum up to 5. ``` Constraints: * You may assume the sum of elements in `nums` will not exceed `1000`. * Each number in `nums` is a positive integer and does not exceed `100`.","solution":"def canPartition(nums, target): Determine if the list can be partitioned into two subsets such that the sum of the elements in both subsets is equal to the target. :param nums: List[int] - List of positive integers. :param target: int - The target sum of the subsets. :return: bool - True if such a partition exists, otherwise False. n = len(nums) dp = [[False for _ in range(target + 1)] for _ in range(n + 1)] # Always possible to get a sum of 0 with no elements for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][target]"},{"question":"Given a list of integers `nums`, rearrange the list so that all the even integers appear before all the odd integers. The relative order of the even integers and odd integers should be preserved. Implement the function `rearrangeEvenOdd(nums)`, which takes a list of integers `nums` and returns the rearranged list. For example, given `nums = [3, 1, 2, 4]`, the function should return `[2, 4, 3, 1]`.","solution":"def rearrangeEvenOdd(nums): Rearrange the list so that all the even integers appear before all the odd integers. The relative order of the even integers and odd integers should be preserved. Args: nums (list): List of integers. Returns: list: Rearranged list with all even numbers before odd numbers. # Create two lists - one for evens and one for odds evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] # Concatenate the evens and odds lists return evens + odds"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the first unique character in the string. A unique character is one that appears only once in the string. If there is no such character, return an empty string. Implement a function `first_unique_char(s: str) -> str` to achieve this. For example, given the string `\\"swiss\\"`, the first unique character is `\\"w\\"`. If the input string is `\\"aabbcc\\"`, the function should return an empty string.","solution":"def first_unique_char(s: str) -> str: Returns the first unique character in the string s. # Frequency dictionary to count occurrences of each character char_frequency = {} # Loop through the string to fill the frequency dictionary for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Loop through the string again to find the first unique character for char in s: if char_frequency[char] == 1: return char # If no unique character found, return an empty string return \\"\\""},{"question":"Given an integer `n`, return the length of the longest sequence of 1s in its binary representation after flipping at most one 0 to 1. The input integer `n` is a non-negative integer and fits within the range of a **32-bit** signed integer.","solution":"def longest_sequence_of_1s(n): Returns the length of the longest sequence of 1s in the binary representation of the integer n after flipping at most one 0 to 1. # Convert to binary string binary = bin(n)[2:] # If n is 0 or consists only of 1s if \'0\' not in binary: return len(binary) # Split the binary string by 0s to find the sequences of 1s sequences = binary.split(\'0\') # Initialize the max length to 1 as we can always flip one 0 to 1 max_length = 1 for i in range(len(sequences)): # Sum the lengths of the current sequence of 1s and the next if i + 1 < len(sequences): # Add the length of the next sequence of 1s, plus one 0 flipped to 1 max_length = max(max_length, len(sequences[i]) + len(sequences[i + 1]) + 1) return max_length"},{"question":"Given a list of `n` integers, determine if you can split the list into two non-empty sublists such that the sum of the integers in each sublist is equal. If it is possible, return `True`; otherwise, return `False`. Note that the order of elements cannot be changed and each element must be included in one of the two sublists.","solution":"def can_split_equal_sum(lst): Determines if a list can be split into two non-empty sublists with equal sums. Parameters: lst (list of int): The list of integers. Returns: bool: True if the list can be split into two sublists with equal sums, False otherwise. total_sum = sum(lst) # If the total sum is odd, it is not possible to split into two equal sum parts if total_sum % 2 != 0: return False # We are looking for a subset with sum equal to half of total sum target_sum = total_sum // 2 current_sum = 0 # Iterate through the list to check if we can find a point to split for num in lst: current_sum += num if current_sum == target_sum: return True return False"},{"question":"You are given an integer array `arr` where each element is either a `1` (representing land) or a `0` (representing water). The array represents a strip of land in the sea. Land cells that are adjacent to water cells (or are on the boundary of the array) are considered **coastal** land cells. Write a function to count and return the number of coastal land cells in the array. **Note** that a land cell is considered coastal if it is immediately next to water on **either side** or is at the start or end of the array if it’s a land cell.","solution":"def count_coastal_cells(arr): Counts the number of coastal land cells in the array. Parameters: arr (list): A list of integers where each element is either 1 (land) or 0 (water). Returns: int: The count of coastal land cells. coastal_count = 0 n = len(arr) for i in range(n): if arr[i] == 1: if i == 0 or i == n - 1 or arr[i-1] == 0 or arr[i+1] == 0: coastal_count += 1 return coastal_count"},{"question":"Given a string `s` containing only lowercase alphabetic characters, determine if it is possible to split `s` into two non-empty substrings such that the first substring is a palindrome and the second substring is an anagram of a palindrome. Return `true` if such a split is possible, otherwise return `false`. For example, in `s = \\"aabb\\"` the string can be split into \\"aa\\" and \\"bb\\", where \\"aa\\" is a palindrome and \\"bb\\" is an anagram of a palindrome.","solution":"def can_split_string(s): def is_palindrome(sub): return sub == sub[::-1] def can_form_palindrome(sub): from collections import Counter count = Counter(sub) odd_count = sum(1 for cnt in count.values() if cnt % 2 != 0) return odd_count <= 1 n = len(s) for i in range(1, n): first_part = s[:i] second_part = s[i:] if is_palindrome(first_part) and can_form_palindrome(second_part): return True return False"},{"question":"Given a 2D binary matrix representing a grid of \'0\'s (water) and \'1\'s (land), return _the size of the largest island_. An island is a group of \'1\'s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water.","solution":"def largest_island(grid): Returns the size of the largest island of \'1\'s in the grid. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited size = 1 # Count current cell # Explore all 4 directions size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given a binary tree where each node contains an integer value. return the rightmost node value at each level of the tree. Assume the tree is populated using the given `TreeNode` class: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` For example, for the following tree: ``` 1 / 2 3 5 4 ``` The binary tree [1, 2, 3, null, 5, null, 4] would return [1, 3, 4]. Implement the function `rightSideView`: ```python def rightSideView(root: \'TreeNode\') -> List[int]: # Your code here ``` This function should return a list of integers representing the rightmost node at each level of the tree.","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = [root] right_view = [] while queue: # Number of nodes at current level level_length = len(queue) for i in range(level_length): node = queue.pop(0) # If it\'s the last node in current level, add to right view if i == level_length - 1: right_view.append(node.val) # Add child nodes in the queue for the next level if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given an integer array `prices` where `prices[i]` represents the price of a given stock on the `i`-th day, and an integer `fee` representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each buy and sell. You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Return _the **maximum** profit you can achieve._ ```python def maxProfit(prices: List[int], fee: int) -> int: # Your code here ```","solution":"from typing import List def maxProfit(prices: List[int], fee: int) -> int: Calculate the maximum profit achievable given stock prices and transaction fee. if not prices: return 0 n = len(prices) cash, hold = 0, -prices[0] for i in range(1, n): # Calculate the maximum cash if we don\'t hold the stock cash = max(cash, hold + prices[i] - fee) # Calculate the maximum hold value if we hold the stock hold = max(hold, cash - prices[i]) return cash"},{"question":"Given a list of integers `nums` where each integer represents the price of a stock on a given day, return _the maximum profit you can achieve by buying and selling the stock_. You are only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock). Note that you cannot sell a stock before you buy one.","solution":"def max_profit(nums): Returns the maximum profit that can be achieved by buying and selling the stock once. if not nums or len(nums) < 2: return 0 min_price = float(\'inf\') max_profit = 0 for price in nums: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You have a rectangular n x m grid with some cells blocked. You start at the top-left corner of the grid (0, 0) and want to get to the bottom-right corner (n-1, m-1). You can only move right or down. Given a 2D integer array `grid` representing the grid, where `1` represents a blocked cell and `0` represents an open cell, return _the number of unique paths from the top-left to the bottom-right corner_. If there is no possible path, return `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right corner in a grid with obstacles. :param grid: 2D integer array where 1 represents a blocked cell and 0 an open cell :return: number of unique paths if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] # Initialization dp[0][0] = 1 - grid[0][0] # Fill first row for j in range(1, m): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill first column for i in range(1, n): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the rest of dp array for i in range(1, n): for j in range(1, m): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"You are given an unsorted integer array `arr` and an integer `x`. Your task is to return _any_ `subarray` of `arr` such that the sum of the elements in the subarray is exactly `x`. A subarray is a **contiguous** part of the array. If such a subarray does not exist, return an empty array. For example, given `arr = [1, 2, 3, 4, 5]` and `x = 9`, one possible subarray is `[2, 3, 4]`, since `2 + 3 + 4 = 9`.","solution":"def find_subarray_with_sum(arr, x): Finds a subarray with the sum exactly x. Parameters: arr (list of int): The input array of integers. x (int): The target sum. Returns: list of int: The subarray which sums up to x. Returns an empty list if no such subarray exists. curr_sum = 0 start = 0 sum_map = {} for end in range(len(arr)): curr_sum += arr[end] if curr_sum == x: return arr[start:end+1] if curr_sum - x in sum_map: return arr[sum_map[curr_sum - x] + 1:end + 1] sum_map[curr_sum] = end return []"},{"question":"Consider a directed graph represented by an adjacency list, where each node has a unique integer identifier from `0` to `n-1` and may have edges directed towards other nodes. Given the list of edges and a starting node `start`, determine whether there exists a path from the `start` node to every other node in the graph. Return `true` if such a path exists for all nodes and `false` otherwise.","solution":"def can_reach_all_nodes(n, edges, start): Determines if all nodes are reachable from the start node. :param n: Number of nodes in the graph :param edges: List of directed edges in the graph :param start: Starting node :return: True if all nodes are reachable from the start node, False otherwise from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) for src, dst in edges: adj_list[src].append(dst) # Perform BFS or DFS to see which nodes are reachable from start visited = [False] * n queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Check if all nodes were visited return all(visited)"},{"question":"You are given an array of integers `nums` and an integer `k`. Write a function to _find the length of the longest subsequence that appears in the same relative order as in `nums` and has a sum less than or equal to `k`_. A subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Return the length of the longest such subsequence.","solution":"def longest_subsequence_with_sum(nums, k): Find the length of the longest subsequence that appears in the same relative order as in nums and has a sum less than or equal to k. :param nums: List of integers. :param k: Integer representing the maximum sum limit. :return: Length of the longest subsequence with sum less than or equal to k. # Initialize a table to store the DP values dp = [[0 for _ in range(k + 1)] for _ in range(len(nums) + 1)] # Loop through each element and fill the DP table for i in range(1, len(nums) + 1): for j in range(k + 1): if nums[i - 1] <= j: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1) else: dp[i][j] = dp[i - 1][j] return dp[len(nums)][k]"},{"question":"Given a `m x n` integer matrix `matrix`, return _the minimum sum of any path from the top-left cell to the bottom-right cell_. You can only move either down or right at any point in time. * For example, consider the matrix `[[1,3,1],[1,5,1],[4,2,1]]`. The function should return `7` because the path `1→3→1→1→1` yields the minimum sum `7`.","solution":"def min_path_sum(matrix): Returns the minimum sum of any path from the top-left cell to the bottom-right cell of a given m x n integer matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize the dp array with the same dimensions as the matrix dp = [[0] * n for _ in range(m)] # Fill in the dp array with the minimum path sums for i in range(m): for j in range(n): if i == 0 and j == 0: dp[i][j] = matrix[i][j] elif i == 0: dp[i][j] = dp[i][j-1] + matrix[i][j] elif j == 0: dp[i][j] = dp[i-1][j] + matrix[i][j] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"You are given a list of `tasks` where each task is represented by a pair of integers `[start, end]`. Each task must be executed during its own time window such that the task starts at `start` and ends at `end`. You need to find out if it is possible to schedule all the tasks without any overlaps. Return `true` if it is possible to schedule all tasks without any overlaps, otherwise return `false`.","solution":"def can_schedule_all_tasks(tasks): Determine if it\'s possible to schedule all tasks without any overlaps. Args: tasks (list of pairs of int): List of tasks represented by [start, end]. Returns: bool: `True` if it\'s possible to schedule all tasks without any overlaps, `False` otherwise. # Sort the tasks based on the start time tasks.sort(key=lambda x: x[0]) # Go through the sorted list and check for overlaps for i in range(1, len(tasks)): # If the start time of the current task is less than the end time of the previous task, there\'s an overlap if tasks[i][0] < tasks[i-1][1]: return False return True"},{"question":"You are given a string `S` that consists of digits from `0` to `9` and a digit `d`. Your task is to find the minimum possible value by deleting exactly one occurrence of the digit `d` from `S`. Return the resulting string after deleting one occurrence of `d`. If there are no instances of `d` in `S`, return the original string. If deleting one occurrence of `d` would result in an empty string, return \\"0\\".","solution":"def delete_digit(S, d): Returns the minimum possible value by deleting exactly one occurrence of the digit d from S. If there are no instances of d in S, returns the original string. If deleting one occurrence of d would result in an empty string, returns \\"0\\". index_to_remove = S.find(d) if index_to_remove == -1: return S new_string = S[:index_to_remove] + S[index_to_remove + 1:] if not new_string: return \\"0\\" return new_string"},{"question":"You have a binary tree defined as follows: - Every node has 3 attributes - `value`, `left`, and `right`, where `value` is the integer value of the node, and `left` and `right` are the node\'s left and right children, respectively. - A subtree of the binary tree is defined as any node and all its descendants. Implement a function to find the number of subtrees in which all the nodes have the same `value`. Return the total number of such subtrees in the binary tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_unival_subtrees(root): Counts the number of unival (universal value) subtrees in a binary tree. def is_unival_tree(node, parent_value): nonlocal count if node is None: return True # Check left and right subtrees left_unival = is_unival_tree(node.left, node.value) right_unival = is_unival_tree(node.right, node.value) # If either left or right subtree is not unival, this subtree can\'t be unival if not left_unival or not right_unival: return False # If both left and right subtrees are unival, and the current node matches the parent value count += 1 # Current node forms a unival subtree return node.value == parent_value count = 0 is_unival_tree(root, None) return count"},{"question":"You are given a list of integers `nums` of length `n` where each integer is in the range `1` to `n` inclusive. Some integers appear **twice** and others appear **once**. Find all the integers that appear **twice** in `nums`. You must solve the problem without using extra space or altering the elements of the array. Return _the list of integers that appear twice_. # Example: **Input**: `nums = [4,3,2,7,8,2,3,1]` **Output**: `[2, 3]`","solution":"def findDuplicates(nums): Returns a list of integers which appear twice in the given list \'nums\'. result = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: result.append(abs(nums[i])) else: nums[index] = -nums[index] # Restore the array to its original state for i in range(len(nums)): nums[i] = abs(nums[i]) return result"},{"question":"Given an array of integers `arr` and an integer `x`, return the maximum length of a subarray with a sum of exactly `x`. If there isn\'t one, return 0.","solution":"def max_subarray_length(arr, x): Returns the maximum length of a subarray with a sum of exactly x. :param arr: List[int] - The input array of integers :param x: int - The target sum :return: int - The maximum length of the subarray with sum exactly x prefix_sum = 0 prefix_sum_dict = {0: -1} # To handle the case when subarray starts from index 0 max_len = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum - x in prefix_sum_dict: max_len = max(max_len, i - prefix_sum_dict[prefix_sum - x]) if prefix_sum not in prefix_sum_dict: prefix_sum_dict[prefix_sum] = i return max_len"},{"question":"You are given two integer arrays `nums1` and `nums2` representing the digit sequences of two numbers. Each digit is stored in reverse order, and each of their nodes contains a single digit. You need to add the two numbers and return the sum as a linked list where each node contains a single digit, also in reverse order. For instance, given: - `nums1 = [2, 4, 3]` and `nums2 = [5, 6, 4]` (which represent the numbers 342 and 465 respectively) Return: - A linked list representing the number 807 where each digit is stored in reverse order, i.e., `[7, 0, 8]`. Create a class `Solution` and implement the following method: - `ListNode addTwoNumbers(ListNode l1, ListNode l2)` Where `ListNode` is the structure for a node in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current, carry = dummy, 0 while l1 or l2 or carry: val1 = (l1.val if l1 else 0) val2 = (l2.val if l2 else 0) carry, out = divmod(val1 + val2 + carry, 10) current.next = ListNode(out) current = current.next l1 = (l1.next if l1 else None) l2 =( l2.next if l2 else None) return dummy.next"},{"question":"Given a string `s` consisting of only lowercase English letters, determine if you can rearrange the letters of `s` to form a valid palindrome. A palindrome is a word that reads the same backward as forward. If such an arrangement exists, return `true`, otherwise return `false`. A valid palindrome can be formed if and only if: - All characters in the string occur an even number of times, allowing them to be mirrored around a central point, or - All but one character occur an even number of times (the character that occurs an odd number of times will be the central character in the palindrome). Ensure your algorithm runs efficiently, considering the potential length of `s`.","solution":"def can_form_palindrome(s): Determines if the characters of the string s can be rearranged to form a palindrome. # Count the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with odd frequency counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can form a palindrome if there is at most one character with an odd count return odd_count <= 1"},{"question":"You are given a list of `data` containing `n` non-negative integers. Your task is to find the longest contiguous subarray such that the difference between the maximum and minimum values in this subarray is less than or equal to a given integer `k`. Return _the length of that subarray_.","solution":"def longest_subarray(data, k): Finds the length of the longest contiguous subarray such that the difference between the maximum and minimum values in this subarray is less than or equal to k. Parameters: data (list): List of non-negative integers. k (int): The maximum allowed difference between the highest and lowest value in the subarray. Returns: int: Length of the longest contiguous subarray. from collections import deque if not data: # edge case if the data list is empty return 0 min_deque = deque() # to store indices of the smallest elements in a window max_deque = deque() # to store indices of the largest elements in a window left = 0 max_length = 0 for right in range(len(data)): while min_deque and data[min_deque[-1]] >= data[right]: min_deque.pop() min_deque.append(right) while max_deque and data[max_deque[-1]] <= data[right]: max_deque.pop() max_deque.append(right) while data[max_deque[0]] - data[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a 2D grid of size `m x n` representing a maze. Each cell in the grid can either be empty (`0`) or blocked (`1`). You start at the top-left corner of the maze and your goal is to reach the bottom-right corner. You can only move up, down, left, or right through empty cells. Write a function `int uniquePaths(int[][] maze)` that returns the number of unique paths from the top-left corner to the bottom-right corner, moving only through empty cells and without crossing any blocked cells. If there is no valid path, return 0. Note that the start and end positions are always empty cells.","solution":"def uniquePaths(maze): Returns the number of unique paths from the top-left corner to the bottom-right corner of a maze represented by 2D grid (m x n) where each cell can be either empty (0) or blocked (1). m = len(maze) n = len(maze[0]) if maze[0][0] == 1 or maze[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if maze[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a directed graph that consists of `n` nodes labeled from `0` to `n-1` and `m` directed edges. Each edge has a weight assigned to it. You need to determine the shortest path from a given starting node `start` to an ending node `end`. If there is no path from `start` to `end`, return `-1`. You are provided with: - An integer `n`, representing the number of nodes. - An integer `m`, representing the number of directed edges. - A list of edges `edges`, where each edge is represented as a triplet of integers `(u, v, w)` indicating a directed edge from node `u` to node `v` with weight `w`. - Two integers `start` and `end`, representing the starting and ending nodes respectively. Return _the length of the shortest path between the nodes `start` and `end`_, or `-1` if no such path exists.","solution":"import heapq def shortest_path(n, m, edges, start, end): Calculate the shortest path from start to end in a directed graph using Dijkstra\'s algorithm. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): List of (u, v, w) where u is the start node, v is the end node, and w is the weight. start (int): The starting node. end (int): The ending node. Returns: int: Length of the shortest path or -1 if no path exists. # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Dijkstra\'s algorithm pq = [(0, start)] # (distance, node) distances = {i: float(\'inf\') for i in range(n)} distances[start] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[end] if distances[end] != float(\'inf\') else -1"},{"question":"Given an array of integers `nums` representing a contiguous subarray of length `n` of an infinite array formed by repeating the elements of `nums` infinitely, return _the maximum sum of any subarray of length `n` of this infinite array_. If the array is empty, return 0. For example, given `nums = [1, 2, 3, 4, 5]`, return the maximum sum of any subarray of length `n` formed from repeating `nums` infinitely.","solution":"def max_subarray_sum(nums): Returns the maximum sum of any subarray of length n of an infinite array formed by repeating the elements of nums infinitely. If nums is empty, returns 0. if not nums: return 0 max_current = max_global = sum(nums) n = len(nums) for i in range(1, n): max_current = max_current - nums[-i] + nums[-i % n] max_global = max(max_global, max_current) return max_global"},{"question":"You are given an array of integers `heights` that represents the height of individuals standing in a line. Starting with an empty line, you can insert each individual into the line such that no two consecutive individuals have a height difference greater than `k`. Your task is to determine the maximum number of individuals that can be placed in the line following this rule. Write a function that takes in the array `heights` and the integer `k`, and returns the maximum number of individuals that can be arranged in the line.","solution":"def max_individuals(heights, k): Determines the maximum number of individuals from the heights array that can be arranged in the line such that no two consecutive individuals have a height difference greater than k. if not heights: return 0 # Sort the heights sorted_heights = sorted(heights) # Initialize the count of individuals count = 1 # Initialize the previous height prev_height = sorted_heights[0] for height in sorted_heights[1:]: if height - prev_height <= k: count += 1 prev_height = height return count"},{"question":"A company has a list of employees\' data, where each employee is represented by their `id` and a list of `ids` of their respective direct subordinates. An employee can have several direct subordinates, and these subordinates can, in turn, have their own subordinates, forming a hierarchical structure within the company. Given an employee\'s id `target_id` and a list of employees\' data in the format `employee_data`, return the total importance value for this employee and all their subordinates. Each employee\'s data is represented as a dictionary with `id`, `importance`, and `subordinates` keys. The importance value of an employee is a sum of their importance and the importance of their subordinates.","solution":"def get_employee_importance(employee_data, target_id): Calculate the total importance value for the given employee and their subordinates. :param employee_data: List of dictionaries, each representing an employee with \'id\', \'importance\', and \'subordinates\' keys. :param target_id: Integer, the ID of the target employee whose total importance value is to be computed. :return: Integer, the total importance value for the target employee including their subordinates. # Convert the employee data into a dictionary for quick access by ID employee_dict = {emp[\'id\']: emp for emp in employee_data} def dfs(emp_id): # Access the employee\'s data using their ID employee = employee_dict[emp_id] # Start with the employee\'s own importance total_importance = employee[\'importance\'] # Accumulate the importance of all subordinates recursively for sub_id in employee[\'subordinates\']: total_importance += dfs(sub_id) return total_importance # Start DFS from the target employee ID return dfs(target_id)"},{"question":"You are given a list of integers representing the heights of a series of buildings. The goal is to determine the maximum amount of water that can be trapped between the buildings after raining. Each building\'s width is considered to be 1. Given an array `heights` of n non-negative integers representing the building heights where the width of each building is 1, compute the maximum amount of water it can trap. For example, given `heights = [0,1,0,2,1,0,1,3,2,1,2,1]`, the amount of water that can be trapped is `6`. Return _the maximum amount of water that can be trapped between the buildings after raining_.","solution":"def trap(heights): Returns the maximum amount of water that can be trapped between buildings. :param heights: List[int], a list of non-negative integers representing the height of buildings. :return: int, the maximum amount of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given a binary string `s` representing a row of seats where `1` represents a person sitting and `0` represents an empty seat. Determine the maximum distance from any empty seat to the nearest occupied one. If there are multiple seats with the same maximum distance, return the index of the leftmost one. If the string contains no empty seats, return -1.","solution":"def max_dist_to_closest(s: str) -> int: Given a binary string representing a row of seats where \'1\' is occupied and \'0\' is empty, returns the index of the empty seat that has the maximum distance to the nearest occupied seat. n = len(s) if \'0\' not in s: return -1 left = [-1] * n right = [-1] * n # Fill left distance array distance = float(\'inf\') for i in range(n): if s[i] == \'1\': distance = 0 else: if distance != float(\'inf\'): distance += 1 left[i] = distance # Fill right distance array distance = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == \'1\': distance = 0 else: if distance != float(\'inf\'): distance += 1 right[i] = distance # Find the maximum distance max_distance = -1 index_with_max_distance = -1 for i in range(n): if s[i] == \'0\': min_distance = min(left[i], right[i]) if min_distance > max_distance: max_distance = min_distance index_with_max_distance = i return index_with_max_distance"},{"question":"Given the `head` of a singly linked list, reverse the linked list and return the reversed list. Implement the `reverseList` function: * `ListNode* reverseList(ListNode* head)` where `ListNode` is a struct (or class) for a node in a singly linked list, defined as: ```cpp struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; ``` The function should return the new head of the reversed list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses a singly linked list and returns the head of the reversed list. prev = None current = head while current: next_temp = current.next current.next = prev prev = current current = next_temp return prev"},{"question":"Given a 2D integer array representing a matrix `mat` where each cell contains either a `0` or a `1`. Each cell with a `1` represents a person standing at that cell. Calculate the maximum distance between any two `1`s in the matrix, where the distance between two cells `(x1, y1)` and `(x2, y2)` is defined as the maximum of the absolute differences of their row and column indices, i.e., `max(|x2 - x1|, |y2 - y1|)`. If there are less than two `1`s in the matrix, return `-1`.","solution":"def max_distance_between_ones(mat): Calculates the maximum distance between any two \'1\'s in the matrix. The distance between two cells (x1, y1) and (x2, y2) is given by max(|x2 - x1|, |y2 - y1|). If there are less than two \'1\'s in the matrix, returns -1. :param mat: 2D list of integers :return: integer # List to store positions of \'1\'s ones = [(i, j) for i in range(len(mat)) for j in range(len(mat[0])) if mat[i][j] == 1] if len(ones) < 2: return -1 # Less than two \'1\'s in the matrix max_distance = 0 for i in range(len(ones)): for j in range(i + 1, len(ones)): x1, y1 = ones[i] x2, y2 = ones[j] distance = max(abs(x2 - x1), abs(y2 - y1)) max_distance = max(max_distance, distance) return max_distance"},{"question":"Given a list of strings `words` and a string `target`, write a function to determine if `target` can be constructed by concatenating elements of the list `words` (elements can be reused). Return a boolean value indicating whether the target string can be formed. Example: - Input: `words = [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"]`, `target = \\"abcdef\\"` - Output: `true` Explanation: The `target` \\"abcdef\\" can be formed by concatenating \\"abc\\" and \\"def\\".","solution":"def can_construct_from_words(words, target): memo = {} def can_construct(s): if s in memo: return memo[s] if s == \\"\\": return True for word in words: if s.startswith(word): suffix = s[len(word):] if can_construct(suffix): memo[s] = True return True memo[s] = False return False return can_construct(target)"},{"question":"You are given an **n-ary tree** where each node contains a value and an array of children nodes. You need to determine the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Return _the maximum depth of the n-ary tree_. **Note:** A leaf is a node with no children nodes.","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def maxDepth(root): Determines the maximum depth of an n-ary tree. :param root: Root node of the n-ary tree. :return: Maximum depth of the tree. if root is None: return 0 if not root.children: return 1 return 1 + max(maxDepth(child) for child in root.children)"},{"question":"You are given an array of integers `heights` representing the heights of a group of buildings. Each building\'s width is `1`. We want to find the largest rectangle that can be formed by any number of contiguous buildings (including just one building). Implement a function to calculate the area of the largest rectangle that can be formed within the given set of buildings. Return the area of the largest rectangle. ```python def largest_rectangle_area(heights: List[int]) -> int: # Your code here ``` For example: ``` Input: heights = [2,1,5,6,2,3] Output: 10 Input: heights = [2,4] Output: 4 ```","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: This function calculates the area of the largest rectangle that can be formed within the given set of buildings. The width of each building is 1. stack = [] max_area = 0 index = 0 while index < len(heights): # If this building is higher than the building on the stack, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top height from the stack and calculate the area with it as the smallest (or minimum height) building top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the height area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining buildings from the stack and calculate the area with each popped building while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"Given two strings `s` and `t`, return the minimum number of operations required to convert `s` into `t`. You are allowed to perform three types of operations on a string: 1. **Insert a character** 2. **Delete a character** 3. **Replace a character**. The function should return an integer representing the minimum number of operations needed to transform the string `s` into string `t`. For example, the minimum number of operations required to convert `\\"horse\\"` into `\\"ros\\"` is 3 (replace \'h\' with \'r\', delete \'o\', delete \'e\').","solution":"def min_distance(s, t): Return the minimum number of operations required to convert s into t. Operations allowed: Insert a character, Delete a character, Replace a character. m, n = len(s), len(t) # Create a DP table to memoize results dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming empty string to current length string for i in range(m + 1): dp[i][0] = i # delete all characters in s for j in range(n + 1): dp[0][j] = j # insert all characters in t # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # delete from s dp[i][j - 1] + 1, # insert into s dp[i - 1][j - 1] + 1) # replace in s return dp[m][n]"},{"question":"Implement a data structure `CustomHashMap` that simulates the functionality of a hash map without using any built-in map or dictionary structures. Your `CustomHashMap` should support the following operations: * `void put(int key, int value)` Inserts a key-value pair into the hash map. If the key already exists, update the corresponding value. * `int get(int key)` Returns the value to which the specified key is mapped, or `-1` if this map contains no mapping for the key. * `void remove(int key)` Removes the key and its corresponding value if the key exists in the map. The `CustomHashMap` should handle collisions using chaining (i.e., each position in the hash map holds a list of key-value pairs). Make sure to design for an average-case constant time complexity for each of the methods.","solution":"class CustomHashMap: def __init__(self, size=1000): Initialize your data structure here with a default size. self.size = size self.buckets = [[] for _ in range(size)] def _hash(self, key): Generate a hash for the given key. return key % self.size def put(self, key, value): Insert a (key, value) pair into the hash map. If the key already exists, update the value. hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) def get(self, key): Retrieve the value associated with the given key, or -1 if the key is not found. hash_key = self._hash(key) bucket = self.buckets[hash_key] for k, v in bucket: if k == key: return v return -1 def remove(self, key): Remove the (key, value) pair associated with the given key, if it exists. hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] return"},{"question":"Write a function `mergeSortedArrays(int[] nums1, int m, int[] nums2, int n)` that takes in two sorted integer arrays `nums1` and `nums2`, and two integers `m` and `n`. The array `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to 0 and should be ignored. The function should merge `nums2` into `nums1` and return the merged sorted array that has a length of `m + n`. The final sorted array should not be returned by a new array, but instead should be stored inside the array `nums1`. **Example:** ``` Input: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3 Output: [1, 2, 2, 3, 5, 6] ```","solution":"def mergeSortedArrays(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2. The resulting merged sorted array should be stored in nums1 which has a length of m + n. # Start from the end of both arrays i = m - 1 j = n - 1 k = m + n - 1 # Traverse both arrays from the end and copy the largest elements to the end of nums1 while i >= 0 and j >= 0: if nums1[i] > nums2[j]: nums1[k] = nums1[i] i -= 1 else: nums1[k] = nums2[j] j -= 1 k -= 1 # Copy the remaining elements of nums2, if any while j >= 0: nums1[k] = nums2[j] j -= 1 k -= 1 return nums1"},{"question":"Given an array of integers `arr` of length `n` and an integer `target`, return _the **length** of the **longest subarray** of `arr` the sum of whose elements equals_ `target`. If there is no such subarray, return `0`.","solution":"def longest_subarray_with_sum(arr, target): Returns the length of the longest subarray of arr whose elements sum to the target value. prefix_sum_map = {} prefix_sum = 0 max_length = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum == target: max_length = i + 1 if (prefix_sum - target) in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[prefix_sum - target]) if prefix_sum not in prefix_sum_map: prefix_sum_map[prefix_sum] = i return max_length"},{"question":"Given a string `s` consisting of lowercase alphabets, return a list of all the distinct permutations of the characters in the string. The permutations in the list should appear in lexicographical order. ---","solution":"from itertools import permutations def distinct_permutations(s): Returns a list of all distinct permutations of the characters in the string s in lexicographical order. perms = set(permutations(s)) sorted_perms = sorted([\'\'.join(p) for p in perms]) return sorted_perms"},{"question":"Given a binary tree, implement a function `rightSideView(root)` that returns the values of the nodes you can see ordered from top to bottom if you stand on the right side of the tree. The function should return an array of these values. For example, given the binary tree represented as `[1, 2, 3, null, 5, null, 4]`, the right side view would be `[1, 3, 4]`. Note that you are only allowed to access the values of the nodes, not the tree structure itself.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes you can see ordered from top to bottom if you stand on the right side of the tree. if not root: return [] result = [] current_level = [root] while current_level: # add the last element of current level to the result result.append(current_level[-1].val) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return result"},{"question":"Given a binary tree, write a function that collects and returns a list of nodes situated at each level of the tree from top to bottom. The tree is represented as a structure of nodes where each node contains an integer value, as well as pointers to its left and right children. You need to return the list of lists containing the values of nodes at each level. If the tree is empty, return an empty list.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order(root): Returns a list of lists containing the values of nodes at each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"You are given a string `s` and an integer `k`. Decompose the string `s` into the minimum number of substrings such that each substring contains at most `k` distinct characters. Return the number of such substrings.","solution":"def min_substrings_with_k_distinct_chars(s, k): Decomposes the string s into the minimum number of substrings such that each substring contains at most k distinct characters. Returns the number of such substrings. :param s: Input string :param k: Maximum number of distinct characters allowed in each substring :return: Number of substrings if k == 0: return len(s) substr_count = 0 left = 0 while left < len(s): right = left unique_chars = set() while right < len(s) and (len(unique_chars) < k or (len(unique_chars) == k and s[right] in unique_chars)): unique_chars.add(s[right]) right += 1 substr_count += 1 left = right return substr_count"},{"question":"Write a function that takes an integer array `heights` representing the heights of buildings and an integer `k` representing the number of steps you can climb at a time. Assume you start at the first building (index 0) and you can only move to the next building if the height difference between the current building and the next one is less than or equal to `k`. Return the maximum number of buildings you can reach. If it is not possible to move to any more buildings, return the total number of buildings you reached.","solution":"def max_buildings_reached(heights, k): Returns the maximum number of buildings that can be reached given the heights of buildings and step limits. Parameters: heights (list): A list of integers representing the heights of buildings. k (int): Maximum steps that can be climbed at a time. Returns: int: The maximum number of buildings reached. if not heights: return 0 count = 1 # We always start at the first building for i in range(1, len(heights)): if abs(heights[i] - heights[i-1]) <= k: count += 1 else: break return count"},{"question":"You are given a list of integers `nums`. Implement a function to segregate the list such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers should be maintained. Return the re-ordered list.","solution":"def segregate_even_odd(nums): Given a list of integers nums, segregate the list such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers should be maintained. :param nums: List[int] - A list of integers :return: List[int] - The re-ordered list with evens before odds evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"You are given an m x n integer matrix `grid` where each cell can either be `0` (representing water) or `1` (representing land). An island is a maximal group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Write a function to determine the number of distinct islands. An island is considered distinct if and only if one island does not have the same shape as another (i.e., rotated or reflected shapes are considered the same). Return the number of distinct islands.","solution":"def numDistinctIslands(grid): def dfs(x, y, origin): if not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or grid[x][y] == 0: return grid[x][y] = 0 # mark as visited path_signature.append((x - origin[0], y - origin[1])) # record relative position for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, origin) unique_island_shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, (i, j)) unique_island_shapes.add(tuple(path_signature)) return len(unique_island_shapes)"},{"question":"You are provided with an integer array `accounts` where `accounts[i]` represents the balance of the `i-th` customer\'s account. You want to check if it is possible to transfer money between accounts so that all customers end up with the same balance. You are allowed to transfer any amount of money from one account to another. Return `true` if it is possible to equalize the balances of all accounts, otherwise return `false`.","solution":"def can_equalize_balances(accounts): Returns true if it is possible to transfer money between accounts to make all balances equal. :param accounts: List of integer account balances :return: Boolean indicating whether equalization is possible if not accounts: return True total_balance = sum(accounts) num_accounts = len(accounts) # It is possible to equalize balances if total balance is divisible by number of accounts return total_balance % num_accounts == 0"},{"question":"You are given an array `nums` of integers and an integer `k`. Your task is to determine the length of the longest subsequence such that the difference between the maximum and minimum values in the subsequence is at most `k`. Return the length of the subsequence. A subsequence is derived by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_subsequence(nums, k): if not nums: return 0 nums.sort() max_length = 1 left = 0 for right in range(1, len(nums)): while nums[right] - nums[left] > k: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a list of integers `nums` representing a collection of durations (in minutes) for different tasks you must complete. Each task `i` has a duration `nums[i]`. You must complete all tasks but can work for a maximum of `k` consecutive minutes before you must take a break. You must take a break of exactly `b` minutes after every `k` minutes of work. Determine the minimum number of breaks required to complete all tasks. Return _the **minimum** number of breaks needed to complete all the tasks in the list_.","solution":"def min_breaks(nums, k, b): Determines the minimum number of breaks required to complete all tasks. Parameters: nums (list of int): A list of integers representing the duration of each task in minutes. k (int): Maximum number of consecutive minutes one can work before a break. b (int): The duration of the break in minutes. Returns: int: The minimum number of breaks required. total_duration = sum(nums) if total_duration == 0: return 0 breaks = (total_duration - 1) // k return breaks"},{"question":"Given an array of integers `arr`, find a pair of indices `i` and `j` (where `i != j`) such that the absolute difference between `arr[i]` and `arr[j]` is the smallest. Return _the pair of indices_ `(i, j)` _as a tuple_. If there are multiple pairs with the same minimal absolute difference, any of them can be returned.","solution":"def smallest_difference_pair_indices(arr): Find a pair of indices (i, j) such that the absolute difference between arr[i] and arr[j] is the smallest. Arguments: arr -- A list of integers. Returns: A tuple (i, j) of indices where the absolute difference between arr[i] and arr[j] is the smallest. # Initialize minimum difference as infinity and pair of indices as (-1, -1) min_diff = float(\'inf\') min_pair = (-1, -1) # Sort the array while keeping track of the original indices sorted_indices = sorted(range(len(arr)), key=lambda x: arr[x]) # Compare each pair of consecutive elements in the sorted array for k in range(len(arr) - 1): i = sorted_indices[k] j = sorted_indices[k + 1] diff = abs(arr[i] - arr[j]) # If a new minimum difference is found, update min_diff and min_pair if diff < min_diff: min_diff = diff min_pair = (i, j) return min_pair"},{"question":"Given a `List` of integers representing the number of steps required to reach the next highest step from the current step, determine the minimum number of steps required to climb from the ground (index 0) to the top (last index). You can either climb to the next step or skip one step at a time. Your task is to implement a function `minStepsToTop(List<Integer> steps)` that returns the minimum number of steps to reach the top. For example, given the list `[1, 2, 0, 1]`, the function should return `2` since you can take steps `[1 -> 2 -> top]`. Note that each element in the list represents the number of steps needed to climb up from the current step, and you can choose to move one step or skip to the next step directly.","solution":"def minStepsToTop(steps): Returns the minimum number of steps required to reach the top of the list. Args: steps (list of int): A list of integers where each element represents the number of steps required to move from that step. Returns: int: The minimum number of steps required to reach the top. n = len(steps) if n == 1: return 0 # Initialize a table to store the minimum number of steps to reach each position dp = [float(\'inf\')] * n dp[0] = 0 for i in range(1, n): dp[i] = min(dp[i], dp[i - 1] + 1) if i > 1: dp[i] = min(dp[i], dp[i - 2] + 1) return dp[-1] # Testing the function print(minStepsToTop([1, 2, 0, 1])) # Output: 2 print(minStepsToTop([1])) # Output: 0 print(minStepsToTop([1, 1, 1, 1, 1])) # Output: 2"},{"question":"You are given a **0-indexed** integer array `nums`. You are allowed to modify the array by removing any of its elements. Your task is to find the minimum number of elements to remove such that the remaining array is **sorted in strictly decreasing order**. * For example, given the array `[5, 3, 4, 2, 1]`, you need to remove `1` element to get a strictly decreasing sequence of `[5, 4, 2, 1]`. Return _an integer representing the minimum number of elements that need to be removed_. **Note:** * The array may contain duplicates. * There can be multiple correct answers, return any.","solution":"def min_removals_to_decreasing(nums): n = len(nums) # If the array is empty or has one element, it is already sorted in strictly decreasing order if n <= 1: return 0 # Longest Decreasing Subsequence (LDS) array lds = [1] * n # Compute LDS values in reverse order for i in range(n - 2, -1, -1): for j in range(n - 1, i, -1): if nums[i] > nums[j]: lds[i] = max(lds[i], 1 + lds[j]) # The reason we subtract the length of the longest decreasing subsequence from total elements longest_decreasing_subsequence_length = max(lds) return n - longest_decreasing_subsequence_length"},{"question":"Given an integer array `arr`, an integer `x` and another integer `y`, return the sum of all unique elements in the array that are divisible by either `x` or `y`. Elements are considered unique based on their first occurrence in the array and any repeated instances should be ignored for the sum calculation. For example, if the array is `[2, 3, 6, 2, 5]`, `x` is `2` and `y` is `3`, the result should be the sum of `2` and `3` and `6`, which are `2 + 3 + 6 = 11`.","solution":"def sum_unique_divisibles(arr, x, y): Returns the sum of all unique elements in the array `arr` that are divisible by either `x` or `y`. Elements are considered unique based on their first occurrence in the array and any repeated instances are ignored for the sum calculation. unique_elements = set() for num in arr: if num not in unique_elements and (num % x == 0 or num % y == 0): unique_elements.add(num) return sum(unique_elements)"},{"question":"Given a binary search tree (BST), rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. Return the new root of the rearranged tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def increasingBST(root): Rearranges the given binary search tree (BST) so that the leftmost node becomes the root and every node has no left child and only one right child. def inorder(node): if not node: return inorder(node.left) nodes.append(node) inorder(node.right) nodes = [] inorder(root) for i in range(len(nodes) - 1): nodes[i].left = None nodes[i].right = nodes[i + 1] # The last node should have no left or right child nodes[-1].left = None nodes[-1].right = None return nodes[0]"},{"question":"Write a function that takes a string representing a mathematical expression in Reverse Polish notation (RPN) and evaluates it. Valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression. The division between two integers should truncate toward zero. It is guaranteed that the given RPN expression is always valid. The function should return the result of the expression as an integer. Example: - Input: `[\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]` - Output: `9` - Explanation: ((2 + 1) * 3) = 9","solution":"def evaluate_rpn(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (list of str): The RPN expression to evaluate. Returns: int: The result of the RPN expression. stack = [] operators = {\'+\', \'-\', \'*\', \'/\'} for token in expression: if token not in operators: stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # truncate toward zero return stack[0]"},{"question":"You are given an array of integers `nums` representing piles of stones, each pile indexed from `0` to `n-1`. You can merge two adjacent piles into one pile by paying a cost equal to the total number of stones in the two piles. The resultant pile\'s index will be the smaller one. For example, merging piles `nums[i]` and `nums[i+1]` will cost `nums[i] + nums[i+1]` and the new pile at index `i` will have `nums[i] + nums[i+1]` stones. The process is repeated until only one pile remains. Return the minimum cost to merge all piles into one.","solution":"def min_cost_to_merge_piles(nums): if len(nums) == 1: return 0 import heapq heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_pile = heapq.heappop(nums) second_pile = heapq.heappop(nums) merge_cost = first_pile + second_pile total_cost += merge_cost heapq.heappush(nums, merge_cost) return total_cost"},{"question":"Write a function that takes a string `s` and returns _the character that appears the most frequently in `s`. If there are multiple characters with the same highest frequency, return the character that appears first in the string_. You may assume that the input string will have at least one character.","solution":"def most_frequent_char(s): Returns the character that appears the most frequently in `s`. If there are multiple characters with the same highest frequency, returns the character that appears first in the string. from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) for char in s: if char_count[char] == max_freq: return char"},{"question":"Given a directed graph represented by a list of edges, where each edge is a tuple `(u, v)` indicating a directed edge from node `u` to node `v`, return `true` if the graph contains a cycle, and `false` otherwise. Each node in the graph is represented as an integer starting from `0` up to `n-1`, where `n` is the number of nodes. Note that the graph may consist of multiple components.","solution":"def has_cycle(n, edges): Determine if a directed graph contains a cycle. :param n: Number of nodes in the graph. :param edges: List of tuples representing directed edges in the graph. :return: True if the graph contains a cycle, False otherwise. from collections import defaultdict, deque # Build graph adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() rec_stack = set() def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in graph[v]: if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in range(n): if node not in visited: if dfs(node): return True return False"},{"question":"You are given an array `tasks` where `tasks[i]` represents the amount of time required to complete the `i-th` task. You have `k` workers, and each worker can work on exactly one task at a time. Design an algorithm to assign tasks to workers such that the maximum time taken by any worker to complete their tasks is minimized. Return the minimum possible value of this maximum time. Implement the `TaskScheduler` class: * `TaskScheduler(int[] tasks, int k)` Initializes the object with the array `tasks` and the integer `k`. * `int minimizeMaxTime()` Returns the minimized maximum time any worker spends on tasks.","solution":"from typing import List import heapq class TaskScheduler: def __init__(self, tasks: List[int], k: int): self.tasks = tasks self.k = k def minimizeMaxTime(self) -> int: # If the number of workers is greater than or equal to the number of tasks, # the maximum time any worker spends will be equal to the time of the largest task. if self.k >= len(self.tasks): return max(self.tasks) # Minimize the maximum working time using a binary search approach low, high = max(self.tasks), sum(self.tasks) # Function to check if a given `mid` can be achieved def canDistribute(mid): workers = 1 current_time = 0 for task in self.tasks: if current_time + task > mid: workers += 1 current_time = task if workers > self.k: return False else: current_time += task return True # Binary search to find the minimum possible maximum time while low < high: mid = (low + high) // 2 if canDistribute(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a string `s` which contains only lowercase English letters. Define an operation that removes the leftmost and rightmost characters of the string. You need to determine the _minimum number of operations required to make the string a valid palindrome_ (a string that reads the same forwards and backwards). If it\'s impossible to make `s` a palindrome through the specified operation, return `-1`. Return the minimum number of operations required or `-1` if it is not achievable.","solution":"def min_operations_to_palindrome(s): Returns the minimum number of specified operations required to make the string `s` a palindrome. If it is not possible, return -1. if s == s[::-1]: return 0 original = s operations = 0 while len(s) > 1: if s[0] == s[-1]: s = s[1:-1] else: s = original break if s == s[::-1]: return operations + 1 operations += 1 return -1"},{"question":"You are given a **0-indexed** array of integers `nums` and an integer `target`. Your task is to form the largest possible **concatenated** string by choosing elements from `nums` such that their combined total is less than or equal to `target`. Each element can be used only once and their individual values need not be consecutive in the original array. Return the largest possible concatenated string configuration. If there are multiple configurations to achieve the largest string, return **any of them**.","solution":"def largest_concatenated_string(nums, target): Returns the largest possible concatenated string by choosing elements from nums such that their total is <= target. nums.sort(reverse=True) # Sort numbers in descending order concatenated_string = \\"\\" current_sum = 0 for num in nums: if current_sum + num <= target: concatenated_string += str(num) current_sum += num return concatenated_string"},{"question":"Given an integer array `sequence`, you need to determine if it is possible to obtain a strictly increasing subsequence of length 3 by removing at most one element from the array. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_find_increasing_subsequence_of_length_3(sequence): n = len(sequence) if n < 3: return False left_min = [float(\'inf\')] * n right_max = [float(\'-inf\')] * n left_min[0] = sequence[0] for i in range(1, n): left_min[i] = min(left_min[i-1], sequence[i]) right_max[n-1] = sequence[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], sequence[i]) for i in range(1, n-1): if left_min[i-1] < sequence[i] < right_max[i+1]: return True return False"},{"question":"Write a function that takes a binary search tree (BST) and a range [low, high] as inputs and returns the sum of values of all the nodes with a value in the inclusive range [low, high]. A binary search tree is a tree in which each node has at most two children, and the left child’s value is less than its parent’s value while the right child’s value is greater than its parent’s value. Your function should visit the minimal number of nodes to achieve the result. The input is given as the root node of the BST and the two integers low and high.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_bst(root, low, high): Returns the sum of values of all the nodes with a value in the inclusive range [low, high]. if not root: return 0 total = 0 if low <= root.val <= high: total += root.val if root.val > low: total += range_sum_bst(root.left, low, high) if root.val < high: total += range_sum_bst(root.right, low, high) return total"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find two distinct elements in the array whose sum equals the target value. Return the indices of these two elements as a list `[index1, index2]` where `index1 < index2`. You may assume that each input would have exactly one solution, and you may not use the same element twice. The solution can be returned in any order.","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, returns the indices of the two distinct elements such that their sum is equal to target. Args: nums : List[int] - List of integers target : int - Target sum Returns: List[int] - List of two indices whose elements sum to target. Indices are in ascending order. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern `p` consisting of distinct lowercase English letters. The task is to find and return the _start indices of all occurrences of `p`\'s anagrams in `s`_. An anagram of a pattern is a permutation of its characters. The output should be in ascending order of indices.","solution":"def find_anagrams(s, p): from collections import Counter result = [] len_s, len_p = len(s), len(p) if len_s < len_p: return result p_counter = Counter(p) s_counter = Counter(s[:len_p-1]) for i in range(len_p - 1, len_s): s_counter[s[i]] += 1 # include new character in the window if s_counter == p_counter: result.append(i - len_p + 1) # append starting index of the anagram # remove the oldest character from the window s_counter[s[i - len_p + 1]] -= 1 if s_counter[s[i - len_p + 1]] == 0: del s_counter[s[i - len_p + 1]] return result"},{"question":"Given an integer array `arr` of size `n`, return a new array `result` where `result[i]` is equal to the **sum** of all the **unique** elements in `arr` except `arr[i]`. If the array is empty, return an empty array. For example, if `arr` is `[1, 2, 3, 2]`, the `result` should be `[5, 4, 3, 4]` because: - Excluding `arr[0] = 1`: Sum of unique elements = 2 + 3 = 5 - Excluding `arr[1] = 2`: Sum of unique elements = 1 + 3 = 4 - Excluding `arr[2] = 3`: Sum of unique elements = 1 + 2 = 3 - Excluding `arr[3] = 2`: Sum of unique elements = 1 + 3 = 4","solution":"def unique_sum_excluding_element(arr): Given an integer array `arr`, return a new array `result` where `result[i]` is equal to the sum of all the unique elements in `arr` except `arr[i]`. if not arr: return [] unique_elements = list(set(arr)) result = [] for i in range(len(arr)): sum_unique_excluding_current = sum(e for e in unique_elements if e != arr[i]) result.append(sum_unique_excluding_current) return result"},{"question":"You are given a binary tree root node and an integer targetSum. Your task is to find all paths in the tree where the sum of the values in the path equals targetSum. Each path must start at the root and end at a leaf node. Return a list of all such paths. Each path should be represented as a list of the node values in their respective order. For example, given the binary tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` and the target sum `22`, the paths would be: - [5, 4, 11, 2] Return the list of all these paths in the form described.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): def find_paths(node, current_sum, path, result): if not node: return current_sum += node.val path.append(node.val) if not node.left and not node.right and current_sum == target_sum: result.append(list(path)) else: find_paths(node.left, current_sum, path, result) find_paths(node.right, current_sum, path, result) path.pop() result = [] find_paths(root, 0, [], result) return result"},{"question":"Given a linked list, remove the `n`-th node from the end of the list and return its head. For example, given a linked list `1 -> 2 -> 3 -> 4 -> 5` and `n = 2`, the linked list after removing the second node from the end would be `1 -> 2 -> 3 -> 5`. Note that `n` will always be a valid integer such that there will be at least `n` nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the list and returns its head. dummy = ListNode(0, head) slow = fast = dummy # Move fast n+1 steps ahead for _ in range(n + 1): fast = fast.next # Move both slow and fast until fast reaches the end while fast: slow = slow.next fast = fast.next # Slow will now be at the node before the one to be deleted slow.next = slow.next.next return dummy.next"},{"question":"You are given a matrix `rooms` representing a list of rooms in a building. Each room is a list of keys to other rooms. Some rooms may have keys to access other rooms and some rooms may not. Initially, all rooms are locked except for room `0`. You can move between rooms only if you have the key for that room. Return _true_ if you can visit all the rooms, otherwise return _false_. Note that you can assume the following: - There are no duplicate keys in the rooms. - The keys will always be integers within the range of the number of rooms.","solution":"def can_visit_all_rooms(rooms): Given a list of rooms where each room contains a list of keys to other rooms, returns True if all rooms can be visited. visited = [False] * len(rooms) visited[0] = True # Start with room 0, which is unlocked stack = [0] # Start the stack with the first room while stack: room = stack.pop() for key in rooms[room]: if not visited[key]: visited[key] = True stack.append(key) return all(visited)"},{"question":"You are given an array of positive integers `coins` representing the values of different coins in a row. Each coin can be either heads (represented by an even number) or tails (represented by an odd number). You need to determine the minimum number of operations required to make all the coins show the same side (either all heads or all tails). In one operation, you can flip a single coin to its opposite side (i.e., change an even number to an odd number or vice versa). Return _the minimum number of operations required_.","solution":"def min_operations_to_uniform_coins(coins): Returns the minimum number of operations required to make all the coins show the same side. Either all heads (even numbers) or all tails (odd numbers). even_count = sum(1 for coin in coins if coin % 2 == 0) odd_count = len(coins) - even_count # Total coins minus even coins gives odd coin count return min(even_count, odd_count) # Test cases to verify the solution print(min_operations_to_uniform_coins([1, 2, 3, 5, 6])) # Expected output: 2 print(min_operations_to_uniform_coins([2, 4, 6, 8])) # Expected output: 0 print(min_operations_to_uniform_coins([1, 3, 5, 7])) # Expected output: 0 print(min_operations_to_uniform_coins([1, 2, 3, 4, 5])) # Expected output: 2 print(min_operations_to_uniform_coins([2, 3, 4, 5, 6])) # Expected output: 2"},{"question":"You are given a `2D` grid of size `n x m` representing a rectangular `field`, where each cell in the grid contains an integer that represents the `height of the terrain` at that position. You can walk from a cell if the `adjacent cell` (up, down, left, or right) has a height that is `less than or equal to the current cell`. Your goal is to reach from the `top-left corner` of the grid to the `bottom-right corner`. Write a function that returns _the **minimum effort** required to walk from the `top-left to the bottom-right` corner_. The effort is defined as the `maximum absolute difference in heights` between two consecutive cells during your path.","solution":"import heapq def minimumEffortPath(heights): rows, cols = len(heights), len(heights[0]) # Dijkstra-like approach with a min-heap to keep track of the minimum effort path def dijkstra(): heap = [(0, 0, 0)] # (effort, x, y) efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while heap: effort, x, y = heapq.heappop(heap) if x == rows - 1 and y == cols - 1: return effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: current_effort = max(effort, abs(heights[nx][ny] - heights[x][y])) if current_effort < efforts[nx][ny]: efforts[nx][ny] = current_effort heapq.heappush(heap, (current_effort, nx, ny)) return dijkstra()"},{"question":"You are tasked with building a reservation system for a library. The library has different types of rooms that can be booked: study rooms, meeting rooms, and conference halls. Each room type has a fixed number of rooms available. Implement the `LibraryReservationSystem` class: * `LibraryReservationSystem(int study, int meeting, int conference)` Initializes the object of the `LibraryReservationSystem` class. The number of rooms for each type are given as part of the constructor. * `bool bookRoom(int roomType)` Checks whether there is an available room of `roomType` for booking. `roomType` can be of three kinds: study, meeting, or conference, which are represented by `1`, `2`, and `3` respectively. If there is no room available of the requested type, return `false`. Otherwise, book the room and return `true`.","solution":"class LibraryReservationSystem: def __init__(self, study, meeting, conference): Initializes the LibraryReservationSystem object with the number of rooms for each type. :param study: Number of study rooms available. :param meeting: Number of meeting rooms available. :param conference: Number of conference halls available. self.room_count = { 1: study, 2: meeting, 3: conference } def bookRoom(self, roomType): Books a room of the given type if available. :param roomType: Type of the room to be booked (1 for study, 2 for meeting, 3 for conference) :return: True if a room is booked, False otherwise. if self.room_count.get(roomType, 0) > 0: self.room_count[roomType] -= 1 return True else: return False"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You need to perform exactly `k` operations on the string, where in each operation, you can swap any two adjacent characters. Return the lexicographically smallest string you can obtain after exactly `k` swaps. For example, if `s = \\"cba\\"` and `k = 1`, the possible strings after one swap are \\"bca\\" and \\"cab\\", and the lexicographically smallest string is \\"bca\\". [Question] 5:","solution":"def smallest_string_after_k_swaps(s, k): Returns the lexicographically smallest string after exactly k adjacent swaps. Args: s: str - input string consisting of lowercase alphabets. k: int - number of swap operations. Returns: str - lexicographically smallest string after exactly k swaps. # Base case: if k is 0, the string cannot be changed if k == 0: return s n = len(s) char_list = list(s) for i in range(k): for j in range(n - 1): if char_list[j] > char_list[j + 1]: # Swap adjacent characters if they are out of order char_list[j], char_list[j + 1] = char_list[j + 1], char_list[j] break # Only one swap per iteration of the outer loop return \\"\\".join(char_list)"},{"question":"You are given a list of `n` integers, `heights`, representing the heights of some buildings in a row. Each building can create a shadow of height equal to its own height directly to its right. However, the shadow of a building is blocked by any taller or equal-height building to its immediate right. Return _the maximum height of any shadow that is not blocked by another building._ Note that the shadow is only counted if it is not blocked by an equal or taller building to its immediate right.","solution":"def max_unblocked_shadow(heights): Returns the maximum height of any shadow that is not blocked by another building. Args: heights (list): A list of integers representing the heights of buildings. Returns: int: The maximum height of an unblocked shadow. if not heights: return 0 max_height = 0 max_unblocked = 0 # Traverse the list from right to left for height in reversed(heights): if height > max_height: max_unblocked = height if height > max_unblocked else max_unblocked max_height = max(max_height, height) return max_unblocked"},{"question":"Given a string `s` containing a mix of alphabets and digits, identify and return the longest contiguous substring that contains only digits. If there are multiple such substrings of the same length, return the one that appears first. For example, if the input string is `\\"abc1234def567\\"`, the output should be `\\"1234\\"`.","solution":"def longest_digit_substring(s): Returns the longest contiguous substring of s that contains only digits. If there are multiple substrings of the same length, the first one is returned. longest = \\"\\" current = \\"\\" for char in s: if char.isdigit(): current += char if len(current) > len(longest): longest = current else: current = \\"\\" return longest"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. You need to determine if there exist three numbers in `nums` whose sum is equal to `target`. Return `true` if such a triplet exists, otherwise return `false`. For example, given `nums = [1, 2, 3, 4, 5]` and `target = 9`, the function should return `true` because the triplet (2, 3, 4) sums up to 9. However, for `target = 20`, the function should return `false` as no such triplet exists in the array.","solution":"def three_sum(nums, target): Determines if there exist three numbers in nums that sum to the target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: bool: True if such a triplet exists, False otherwise. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given an array of integers `arr`, and an integer `target`, return the **minimum length** of a contiguous subarray of which the **sum** is greater than or equal to `target`. If there is no such subarray, return `0`. **Example:** ```python Input: arr = [2,3,1,2,4,3], target = 7 Output: 2 ``` Explanation: The subarray [4,3] has the minimal length under the problem constraint. Implement the function `minSubArrayLen(target: int, arr: List[int]) -> int` which accepts an integer and a list of integers and returns the minimal length of a contiguous subarray satisfying the specified condition.","solution":"from typing import List def minSubArrayLen(target: int, arr: List[int]) -> int: n = len(arr) left = 0 min_length = float(\'inf\') current_sum = 0 for right in range(n): current_sum += arr[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a **0-indexed** integer array `prices`, where `prices[i]` represents the price of the `ith` item in a store. You also have a `budget` which represents the total amount of money you can spend. Your task is to find the **maximum number of items** you can buy without exceeding your `budget`. You may assume that you can buy only one unit of each item. Return _the **maximum** number of items you can buy within the given budget_.","solution":"def max_items_within_budget(prices, budget): Finds the maximum number of items that can be bought without exceeding the provided budget. Parameters: prices (list of int): List of item prices. budget (int): The total amount of money that can be spent. Returns: int: The maximum number of items that can be bought within the budget. # Sort prices to try buying the cheapest items first prices.sort() total_spent = 0 items_bought = 0 for price in prices: if total_spent + price <= budget: total_spent += price items_bought += 1 else: break return items_bought"},{"question":"Given an integer array `nums` that contains `n` unique integers, write a function to determine if there exists a triplet `(a, b, c)` in the array such that `a`, `b`, and `c` are consecutive numbers (i.e., `b = a + 1` and `c = b + 1`). Return `true` if such a triplet exists and `false` otherwise. **Example:** ``` Input: nums = [5, 7, 2, 4, 6, 1, 3] Output: true Explanation: The triplet (4, 5, 6) exists in the array. ``` ``` Input: nums = [8, 10, 4, 6] Output: false Explanation: There is no such triplet in the array. ``` **Note:** - The array `nums` must contain exactly `n` unique integers where `1 <= n <= 10^4`.","solution":"def contains_consecutive_triplet(nums): Determines if there exists a triplet (a, b, c) in the array such that a, b, and c are consecutive numbers (i.e., b = a + 1 and c = b + 1). :param nums: List of unique integers. :return: True if such a triplet exists, False otherwise. nums_set = set(nums) for num in nums_set: if (num + 1 in nums_set) and (num + 2 in nums_set): return True return False"},{"question":"You are given a list of integers representing the prices of a stock on consecutive days. You can complete at most one transaction, i.e., buy one share of the stock and sell one share of the stock. Develop a function that determines the maximum profit you can achieve given this list of prices. If no profit is achievable, return 0. The function should have a time complexity of O(n) and a space complexity of O(1).","solution":"def max_profit(prices): Given a list of stock prices where prices[i] is the price of a given stock on day i, return the maximum profit you can achieve from completing at most one transaction (i.e., buy one and sell one share of the stock). If no profit can be achieved, return 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given a list of `tickets` where each ticket represents a journey from one city to another city [from, to]. You need to reconstruct the itinerary in order and return it. All the tickets form a valid itinerary. Start at \\"JFK\\" airport and follow the lexicographically smallest route when there are multiple cities to visit from the same airport. The input list `tickets` is represented as follows: * `[[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]]` The output should be: * `[\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"]` Create a function that returns the reconstructed itinerary in a list in the correct order.","solution":"from collections import defaultdict import heapq def find_itinerary(tickets): Reconstructs the itinerary according to the given tickets. tickets: A list of [from, to] pairs representing the flights. Returns a list representing the reconstructed itinerary. graph = defaultdict(list) for from_city, to_city in tickets: heapq.heappush(graph[from_city], to_city) result = [] def visit(airport): while graph[airport]: next_airport = heapq.heappop(graph[airport]) visit(next_airport) result.append(airport) visit(\'JFK\') return result[::-1]"},{"question":"Given an array of integers `heights` representing the heights of buildings in a street, determine the maximum number of buildings that can see the sunset. The buildings are assumed to be facing west, such that you can only see the sunset if there are no taller buildings to the west. Return _the number of buildings that have an unobstructed view of the sunset._","solution":"def count_sunset_buildings(heights): Returns the number of buildings that have an unobstructed view of the sunset. A building can see the sunset if it is taller than all the buildings to its west. :param heights: List of building heights. :return: Number of buildings with an unobstructed view. max_height_so_far = 0 count = 0 for height in heights: if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"You are given a 2D grid of integers where each cell represents the elevation at that point. You are also given an integer `effortLimit`. Your task is to determine if there is a path from the top-left corner of the grid to the bottom-right corner such that the maximum elevation change between any two consecutive cells on the path is less than or equal to `effortLimit`. You may move up, down, left, or right. Return `true` if such a path exists, and `false` otherwise.","solution":"from collections import deque def canReachWithEffort(grid, effortLimit): Determines if there is a path from the top-left to the bottom-right of the grid such that the maximum elevation difference between consecutive cells is less than or equal to effortLimit. :param grid: List[List[int]], the 2D grid of integers representing elevations :param effortLimit: int, the maximum allowable elevation change between two consecutive cells :return: bool, whether such a path exists rows, cols = len(grid), len(grid[0]) # Direction vectors for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS Initialization queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # Check if we\'ve reached the bottom-right corner if x == rows - 1 and y == cols - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= effortLimit: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"You are given two strings, `str1` and `str2`. Your task is to determine if `str1` can be rearranged to form `str2`. In other words, check if the two strings are anagrams of each other. An anagram of a string is the rearrangement of its characters to form another string using all the original characters exactly once. Return `true` if `str1` can be rearranged to form `str2`, and `false` otherwise.","solution":"def are_anagrams(str1, str2): Determines if str1 can be rearranged to form str2. Returns True if they are anagrams (i.e. rearrangements of each other), otherwise False. return sorted(str1) == sorted(str2)"},{"question":"In a given city, there are `n` houses arranged in a straight line. Each house `i` (0 ≤ i < n) has a certain amount of money `money[i]` stashed inside. Due to security systems, you cannot rob two adjacent houses - if you rob house `i`, you cannot rob house `i-1` or house `i+1`. Given a list `money` representing how much money each house contains, return the maximum amount of money you can rob tonight without alerting the security system.","solution":"def rob_houses(money): Returns the maximum amount of money that can be robbed without alerting the security systems. :param money: List[int] representing the amount of money in each house. :return: int, the maximum amount of money that can be robbed. if not money: return 0 if len(money) == 1: return money[0] n = len(money) dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. An island is a maximal 4-directionally connected group of `1`s. A **bridge** is defined as a continuous sequence of `0`s connecting two islands where a bridge can start and end horizontally or vertically adjacent to the `1`s of the islands. The goal is to find the length of the shortest bridge that can be built to connect any two of the islands. Return the length of the shortest bridge. **Example:** ``` Input: grid = [[0,1],[1,0]] Output: 1 Input: grid = [[0,1,0],[0,0,0],[0,0,1]] Output: 2 ``` **Constraints:** - `m == grid.length` - `n == grid[i].length` - `2 <= m, n <= 100` - `grid[i][j]` can only be `0` or `1` - There are exactly `two` islands in the grid.","solution":"from collections import deque def shortestBridge(grid): Find the shortest bridge (number of 0s) needed to connect two islands in the grid. def in_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if in_bounds(x + dx, y + dy): yield x + dx, y + dy def bfs_find_island(): for r in range(len(grid)): for c in range(len(grid[r])): if grid[r][c] == 1: queue = deque([(r, c)]) component = set() while queue: x, y = queue.popleft() if (x, y) not in component: component.add((x, y)) for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1: queue.append((nx, ny)) return component def bfs_shortest_bridge(source): queue = deque([(x, y, 0) for x, y in source]) visited = set(source) while queue: x, y, d = queue.popleft() for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: if grid[nx][ny] == 1: return d queue.append((nx, ny, d + 1)) visited.add((nx, ny)) island1 = bfs_find_island() for x, y in island1: grid[x][y] = 2 # Marking island1 cells to avoid revisiting return bfs_shortest_bridge(island1)"},{"question":"Given an integer array `arr`, and an integer `k`, determine if there exists a contiguous subarray of length at least 2 that sums up to a multiple of `k`, that is, sums up to `n*k` where `n` is an integer. Return _true_ if such a subarray exists; otherwise, return _false_.","solution":"def checkSubarraySum(arr, k): Determines if there exists a contiguous subarray of length at least 2 that sums up to a multiple of k. if not arr or len(arr) < 2: return False prefix_sum = 0 prefix_sum_mod = {0: -1} # to handle the case when the subarray starting from index 0 for i in range(len(arr)): prefix_sum += arr[i] mod = prefix_sum % k if k != 0 else prefix_sum if mod in prefix_sum_mod: if i - prefix_sum_mod[mod] > 1: return True else: prefix_sum_mod[mod] = i return False"},{"question":"Given a **0-indexed** integer array `nums` of size `n`, calculate the smallest subarray length such that the sum of the elements within this subarray is greater than or equal to a given integer `target`. Your function should return the length of this subarray, or `0` if no such subarray exists.","solution":"def min_subarray_len(target, nums): Returns the smallest length of a subarray of nums such that the sum of the elements in the subarray is greater than or equal to target. Returns 0 if no such subarray exists. :param target: int, target sum :param nums: List[int], list of integers :return: int, smallest subarray length or 0 n = len(nums) min_length = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a string representing a mathematical expression containing digits and the operators `+`, `-`, `*`, and ` /`. The expression does not contain any parentheses. Implement an algorithm to evaluate the mathematical expression and return the result as an integer. The integer division should truncate toward zero.","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing digits and the operators +, -, *, / and return the result as an integer. Integer division should truncate toward zero. def operate(a, b, operator): if operator == \'+\': return a + b elif operator == \'-\': return a - b elif operator == \'*\': return a * b elif operator == \'/\': # Integer division should truncate towards zero return int(a / b) num = 0 stack = [] sign = \'+\' n = len(expression) for i in range(n): if expression[i].isdigit(): num = num * 10 + int(expression[i]) if (not expression[i].isdigit() and expression[i] != \' \') or i == n - 1: if sign == \'+\' or sign == \'-\': if sign == \'+\': stack.append(num) else: stack.append(-num) elif sign == \'*\': stack[-1] = stack[-1] * num elif sign == \'/\': stack[-1] = int(stack[-1] / num) sign = expression[i] num = 0 return sum(stack)"},{"question":"You are given an integer array `nums` and an integer `k`. In one operation, you can pick any element from `nums` and replace it with any other integer. Return the maximum possible sum of the array elements after performing the operation at most `k` times. Ensure that your algorithm is efficient and handles edge cases appropriately.","solution":"def max_array_sum_after_k_operations(nums, k): Returns the maximum possible sum of the array elements after performing the operation at most k times. In one operation, any element in nums can be replaced with any other integer. # If k is zero, no operations can be performed if k == 0: return sum(nums) # Sort the array to prioritize replacing the smallest elements sorted_nums = sorted(nums) # Initialize variables to keep track of the sum and operations performed total_sum = sum(nums) operations_performed = 0 index = 0 while operations_performed < k and index < len(sorted_nums): # Remove the smallest element and replace it total_sum -= sorted_nums[index] # Replace with a maximum possible value total_sum += float(\'inf\') operations_performed += 1 index += 1 return total_sum"},{"question":"Given the head of a singly-linked list, where each node contains a single integer digit (0-9), construct a new singly-linked list representing the sum of this linked list with another provided singly-linked list in reverse order. The digits are stored in reverse order, and each of their nodes contains a single digit. Return the head of the new linked list. For example, if the input linked lists represent the numbers `243` (2 -> 4 -> 3) and `564` (5 -> 6 -> 4), the output should be a linked list representing the number `807` (7 -> 0 -> 8).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists and returns the sum as a new linked list. Each linked list node contains a single digit and the digits are stored in reverse order. dummy_head = ListNode() current = dummy_head carry = 0 while l1 is not None or l2 is not None or carry != 0: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 sum_val = val1 + val2 + carry carry = sum_val // 10 current.next = ListNode(sum_val % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next return dummy_head.next"},{"question":"You are given a **0-indexed** integer array `nums` which consists of `n` distinct numbers ranging from `1` to `n`, and an integer `target`. Your task is to return _the **indices** of the two numbers in `nums` that add up to the_ `target`. Return the indices in **ascending order**. If such a pair does not exist, return an empty array.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to target. Parameters: nums (list of int): A list of distinct integers ranging from 1 to n. target (int): The target sum. Returns: list of int: Indices of the two numbers adding up to the target in ascending order, or an empty list if no such pair exists. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"Given a binary tree, you need to serialize and deserialize it. Serialization is the process of converting a tree to a string representation so that it can be easily stored or transmitted, and deserialization is the process of converting the string representation back to the original tree structure. Your task is to implement the `Codec` class with the following methods: * `String serialize(TreeNode root)`: Encodes a tree to a single string. * `TreeNode deserialize(String data)`: Decodes the encoded data to a tree. To preserve the tree structure in the serialization, you should use pre-order traversal, including `null` pointers as `\'#\'`. The `TreeNode` class for the binary tree is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example: ```python # Serialize and Deserialize Example # Given the binary tree [1, 2, 3, null, null, 4, 5] # 1 # / # 2 3 # / # 4 5 codec = Codec() root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = codec.serialize(root) # Should return a string representation like \\"1 2 # # 3 4 # # 5 # #\\" deserializedRoot = codec.deserialize(serialized) ``` **Note:** You may assume that the input does not contain any duplicate values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. def serialize_helper(node): if not node: return [\\"#\\"] return [str(node.val)] + serialize_helper(node.left) + serialize_helper(node.right) return \' \'.join(serialize_helper(root)) def deserialize(self, data): Decodes your encoded data to tree. def deserialize_helper(values): value = values.pop(0) if value == \\"#\\": return None node = TreeNode(int(value)) node.left = deserialize_helper(values) node.right = deserialize_helper(values) return node values = data.split() return deserialize_helper(values)"},{"question":"Given a string `s`, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Consider the string to be a sequence of words separated by spaces. A word is defined as a contiguous sequence of non-space characters. Your task is to implement a function that performs this operation in-place without allocating extra space for another array. For example, given the input `\\"Let\'s take LeetCode contest\\"`, the output should be `\\"s\'teL ekat edoCteeL tsetnoc\\"`.","solution":"def reverse_words_in_place(s): Reverses the order of characters in each word within a sentence while still preserving whitespace and initial word order. words = s.split(\\" \\") reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"You are given an `m x n` binary grid `grid` which represents a map of \'1\'s (land) and \'0\'s (water). An **island** is a maximal group of connected \'1\'s (land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Return the number of distinct islands in the grid. Two islands are considered distinct if and only if one island is not equal to another after rotations (90, 180, or 270 degrees) and flips (horizontal or vertical). For example, consider the following input grid: ``` grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"1\\",\\"1\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\"] ] ``` In this case, there are three distinct islands.","solution":"def num_distinct_islands(grid): def dfs(i, j, di, dj): if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \'1\': grid[i][j] = \'0\' shape.append((di, dj)) # record relative position for x, y, D in [(0, 1, \'R\'), (0, -1, \'L\'), (1, 0, \'D\'), (-1, 0, \'U\')]: dfs(i + x, j + y, di + x, dj + y) def normalize(shape): transformations = [] for r in range(4): new_shape = [(x, y) for x, y in shape] if r > 0: new_shape = [(y, -x) for x, y in new_shape] for flip in (lambda x, y: (x, y), lambda x, y: (x, -y), lambda x, y: (-x, y), lambda x, y: (-x, -y)): transformations.append(sorted(flip(x, y) for x, y in new_shape)) return min(transformations) distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': shape = [] dfs(i, j, 0, 0) distinct_islands.add(tuple(normalize(shape))) return len(distinct_islands)"},{"question":"Given a 2D binary grid `grid` where `0` represents water and `1` represents land, an island is a group of `1`\'s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Write a function that returns _the number of distinct islands_. An island is considered distinct if and only if one is not equal to another (by shape), even if they are rotated or flipped.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the given 2D binary grid. Parameters: grid (List[List[int]]): 2D binary grid where 0 represents water and 1 represents land. Returns: int: Number of distinct islands based on their shapes. def dfs(x, y, direction): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 shape.append(direction) # Explore all four directions dfs(x + 1, y, \'d\') # move down dfs(x - 1, y, \'u\') # move up dfs(x, y + 1, \'r\') # move right dfs(x, y - 1, \'l\') # move left shape.append(\'b\') # backtrack distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, \'o\') # mark the starting point distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"You are given an array of integers `heights` representing the heights of different buildings, and an integer `stones` representing the number of stones you can use to increase the height of any building. Each stone can increase the height of a building by exactly 1 unit. Your goal is to equalize the heights of all buildings as much as possible by using the given stones. Return the difference between the maximum and minimum heights of the buildings after using the stones optimally. Note that it\'s not always possible to make all buildings the same height.","solution":"def min_height_difference(heights, stones): Returns the minimum possible difference between the tallest and shortest building heights after using the stones optimally. heights.sort() while stones > 0: min_height = heights[0] max_height = heights[-1] range_of_heights = max_height - min_height if range_of_heights == 0: break heights[0] += 1 stones -= 1 heights.sort() # Resort the list to keep the smallest height at the start return heights[-1] - heights[0]"},{"question":"You are given the `root` of a binary search tree (BST). Write a function to find the node with the **maximum sum of a subtree**. A subtree is defined as a node plus all of its descendants. Return _the maximum sum of any subtree in the given binary search tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_subtree(root): Returns the maximum sum of any subtree in the given binary search tree. def dfs(node): if not node: return 0, float(\'-inf\') left_sum, left_max_sum = dfs(node.left) right_sum, right_max_sum = dfs(node.right) current_sum = node.val + left_sum + right_sum max_sum = max(current_sum, left_max_sum, right_max_sum) return current_sum, max_sum return dfs(root)[1]"},{"question":"Given a linked list of integers `head`, return _the linked list where every node\'s value is replaced with the greatest value among the values of all the nodes that follow that node_.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def replace_with_greatest(head: ListNode) -> ListNode: Replace each node\'s value with the greatest value among the values of all the nodes that follow that node. Args: head: ListNode - The head of the linked list. Returns: ListNode - The modified linked list. if not head: return None # Start from the end of the list and keep track of the maximum value found prev = None current = head max_val = float(\'-inf\') while current: next_node = current.next current.next = prev prev = current current = next_node head = prev current = head while current: original_val = current.val current.val = max_val max_val = max(max_val, original_val) current = current.next prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node head = prev return head"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a field. Each cell in the grid contains either an obstacle represented by a `1` or empty space represented by a `0`. You start at the top-left corner of the grid (position `(0, 0)`) and your goal is to reach the bottom-right corner (position `(m-1, n-1)`). You can only move in four possible directions: up, down, left, or right and you cannot move into cells with obstacles. Return _the length of the shortest path from the top-left corner to the bottom-right corner, or `-1` if no such path exists_. **Note that**: - If the starting cell or the ending cell contains an obstacle, return `-1`. - The path length is the number of cells in the path, including the starting and ending cells. - You can revisit cells if necessary but should not count them multiple times in the path length.","solution":"from collections import deque def shortest_path_in_grid(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid. If no such path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set((0, 0)) while queue: row, col, length = queue.popleft() if row == m - 1 and col == n - 1: return length for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, length + 1)) visited.add((new_row, new_col)) return -1"},{"question":"Given a list of integers `tasks` representing the amount of time each task takes, and an integer `n` representing the cooldown period between two same tasks, return the _minimum time required to finish all tasks_ if you can execute tasks in any order, but must wait for `n` units of time before executing the same task again.","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum time required to finish all tasks with the given cooldown period. :param tasks: List[int] - a list of integers representing the time each task takes. :param n: int - the cooldown period between the same tasks. :return: int - the minimum time required to finish all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_task_frequency = max(task_counts.values()) count_max_frequency = sum(1 for count in task_counts.values() if count == max_task_frequency) intervals = (max_task_frequency - 1) * (n + 1) + count_max_frequency return max(intervals, len(tasks))"},{"question":"Given a binary tree, write a function to determine the total number of nodes that have at least one child. The tree is represented as a list of tuples `(node, left_child, right_child)`, where `node` is the value of the parent node, `left_child` is the value of the left child (or `None` if there is no left child), and `right_child` is the value of the right child (or `None` if there is no right child). Each child node will also appear as the first element of one of the tuples unless it is `None`.","solution":"def count_nodes_with_children(tree): Returns the number of nodes that have at least one child in the given binary tree. :param tree: List of tuples (node, left_child, right_child) :returns: Integer count of nodes with at least one child. if not tree: return 0 count = 0 for node, left_child, right_child in tree: if left_child is not None or right_child is not None: count += 1 return count"},{"question":"You are given a directory structure represented as a list of strings `paths` where each string contains a comma-separated sequence of folder names starting from the root. Each string represents a path from the root to a specific folder/file. Return a list of lists representing the directory tree structure in a hierarchical manner. The directory structure should be returned as a list where each element is a nested list representing subdirectories and files within the parent directory. For instance, given: ``` paths = [ \\"root,subdir1,file1.txt\\", \\"root,subdir1,file2.txt\\", \\"root,subdir2,subsubdir1,file3.txt\\" ] ``` The output should be: ``` [ \\"root\\", [ [\\"subdir1\\", [\\"file1.txt\\", \\"file2.txt\\"]], [\\"subdir2\\", [ [\\"subsubdir1\\", [\\"file3.txt\\"]] ]] ] ] ```","solution":"def build_directory_tree(paths): def insert_path(node, path_parts): if not path_parts: return next_part = path_parts.pop(0) if next_part not in node: node[next_part] = {} insert_path(node[next_part], path_parts) def build_tree(node): if not node: return [] result = [] for key, sub_node in sorted(node.items()): result.append([key, build_tree(sub_node)]) return result root = {} for path in paths: path_parts = path.split(\\",\\") insert_path(root, path_parts) # Assuming there\'s always one root element in the provided paths root_name = next(iter(root)) return [root_name, build_tree(root[root_name])] # Example usage: # paths = [ # \\"root,subdir1,file1.txt\\", # \\"root,subdir1,file2.txt\\", # \\"root,subdir2,subsubdir1,file3.txt\\" # ] # print(build_directory_tree(paths))"},{"question":"You are given a list of integers `intervals` representing the time intervals of tasks you need to complete, where `intervals[i] = [start_i, end_i]` denotes the start time and end time of the `i-th` task. Each task requires a continuous interval of time, and you can only work on one task at a time. Your goal is to find out the maximum number of non-overlapping tasks you can complete. Return _the maximum number of non-overlapping tasks you can complete._ Note: - Tasks that end exactly when another task starts are considered non-overlapping. - The tasks are not necessarily sorted by their start or end times.","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals that can be completed. if not intervals: return 0 # Sort the intervals based on their end times intervals.sort(key=lambda x: x[1]) # Keep track of the end time of the last added interval end_time = float(\'-inf\') count = 0 for interval in intervals: if interval[0] >= end_time: # If the start time of the current interval is after or exactly at the end time # of the last added interval, we can add this interval end_time = interval[1] count += 1 return count"},{"question":"You are given a string `formula` representing a chemical formula, which consists of lowercase letters, uppercase letters, and digits. The formula follows standard chemical notation, where an uppercase letter begins an element\'s symbol, which may optionally follow with a lowercase letter. A number indicates the count of atoms for the preceding element. Parentheses may enclose part of the formula, with a number following the parentheses indicating the number of times that group of elements should be repeated. Return a dictionary with the count of each element in the formula. Example input: `formula = \\"H2O\\"` Example output: `{\\"H\\": 2, \\"O\\": 1}`","solution":"from collections import defaultdict def count_of_atoms(formula): def parse(): stack = [defaultdict(int)] i, n = 0, len(formula) while i < n: if formula[i] == \'(\': stack.append(defaultdict(int)) i += 1 elif formula[i] == \')\': i += 1 i_start = i while i < n and formula[i].isdigit(): i += 1 multiplier = int(formula[i_start:i] or 1) top = stack.pop() for el, count in top.items(): stack[-1][el] += count * multiplier else: i_start = i i += 1 while i < n and formula[i].islower(): i += 1 element = formula[i_start:i] i_start = i while i < n and formula[i].isdigit(): i += 1 count = int(formula[i_start:i] or 1) stack[-1][element] += count return stack.pop() return dict(parse())"},{"question":"You are given a 2D grid representing a park, where each cell is either empty (represented by `0`) or contains a tree (represented by `1`). You need to find the **smallest rectangle** that encloses all the trees and return the coordinates of this rectangle. The rectangle is defined by its top-left and bottom-right corner coordinates. The function should return an array of four integers `[r1, c1, r2, c2]`, where `(r1, c1)` is the top-left coordinate and `(r2, c2)` is the bottom-right coordinate. If there are no trees, return an empty array.","solution":"def find_smallest_rectangle(park): Find the smallest rectangle that encloses all the trees in the park. Parameters: park (list of list of int): 2D grid representing the park Returns: list: coordinates of the rectangle in the format [r1, c1, r2, c2] if not park or not any(any(row) for row in park): return [] num_rows = len(park) num_cols = len(park[0]) min_row, max_row = float(\'inf\'), float(\'-inf\') min_col, max_col = float(\'inf\'), float(\'-inf\') for r in range(num_rows): for c in range(num_cols): if park[r][c] == 1: if r < min_row: min_row = r if r > max_row: max_row = r if c < min_col: min_col = c if c > max_col: max_col = c return [min_row, min_col, max_row, max_col]"},{"question":"You are given a string `s` which represents a sequence of characters. You need to create a **balanced binary tree** from the characters of the string such that the characters appear in the same order. A binary tree is balanced if the length of the left and right subtrees of every node differs by at most one. The characters from `s` will be inserted level-wise starting from the root and moving left to right at each level. The tree continues to be constructed in this manner until all characters have been inserted. Return the **preorder traversal** of the constructed binary tree as a string. The preorder traversal of a tree is a depth-first traversal where, for each node, you visit the node itself first, then recursively traverse the left subtree, and finally, recursively traverse the right subtree.","solution":"class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def build_balanced_tree(s): if not s: return None nodes = [TreeNode(char) for char in s] root = nodes[0] queue = [root] index = 1 while index < len(nodes): current = queue.pop(0) if index < len(nodes): current.left = nodes[index] queue.append(current.left) index += 1 if index < len(nodes): current.right = nodes[index] queue.append(current.right) index += 1 return root def preorder_traversal(root): if not root: return \\"\\" return root.val + preorder_traversal(root.left) + preorder_traversal(root.right) def preorder_from_string(s): root = build_balanced_tree(s) return preorder_traversal(root)"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters. A **good substring** is a substring that contains no repeated characters. Return _the maximum length of a good substring_ in `s`. If no such substring exists, return 0.","solution":"def max_length_of_good_substring(s): Returns the maximum length of a good substring in the given string s. A good substring is a substring with all unique characters. max_len = 0 start = 0 char_index = {} for end in range(len(s)): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given an array of integers, `arr`, where each element appears exactly twice except for one element which appears exactly once. Write a function to find the element that appears only once. Implement an efficient algorithm to achieve this in linear time complexity and constant space complexity.","solution":"def find_single_element(arr): Returns the element that appears only once in the array. Every other element appears exactly twice. result = 0 for num in arr: result ^= num return result"},{"question":"You are given an array of non-negative integers `nums`, where each integer represents a maximum number of steps you can jump forward from that position. Your goal is to determine if you can reach the last index starting from the first index. Implement a function `canJump(int[] nums)` that returns `true` if you can reach the last index, otherwise returns `false`. For example, given `nums = [2,3,1,1,4]`, the output should be `true` because you can jump 1 step from index 0 to 1, then 3 steps to the last index. Given `nums = [3,2,1,0,4]`, the output should be `false` because no matter how you jump, you will always end up at index 3 and be stuck.","solution":"def canJump(nums): Determines if you can reach the last index. Parameters: nums (List[int]): List of non-negative integers representing maximum steps. Returns: bool: True if you can reach the last index, otherwise False. max_reachable_index = 0 for i, num in enumerate(nums): if i > max_reachable_index: return False max_reachable_index = max(max_reachable_index, i + num) return True"},{"question":"You are given two integers `a` and `b`, and you need to find the sum of all prime numbers between `a` and `b` (both inclusive). Write a function that accepts two integers as input and returns the sum of the prime numbers within the given range. For example, if the input integers are `a = 10` and `b = 20`, the prime numbers between 10 and 20 are `[11, 13, 17, 19]` and their sum is `60`.","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_primes(a, b): Returns the sum of all prime numbers between a and b (inclusive). if a > b: a, b = b, a return sum(i for i in range(a, b + 1) if is_prime(i))"},{"question":"You are given a string `s` which consists of lowercase English letters. You are allowed to delete any number of characters from `s` to obtain a sub-sequence. A sub-sequence is a sequence derived from another sequence by deleting some elements without changing the order of the remaining elements. Your task is to determine the **minimum number of characters** that need to be deleted from `s` such that the resulting sub-sequence is a palindrome. A palindrome is a string that reads the same backward as forward. Return _the **minimum number of deletions** required to make `s` a palindrome_.","solution":"def min_deletions_to_palindrome(s): def longest_palindromic_subseq(s): n = len(s) # Create a 2D array to store the lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # All substrings with length 1 are palindromic for i in range(n): dp[i][i] = 1 # Build the table for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] longest_palindromic_length = longest_palindromic_subseq(s) return len(s) - longest_palindromic_length"},{"question":"Implement a program that simulates the game of \\"Life\\", which is a two-dimensional cellular automaton devised by the British mathematician John Horton Conway in 1970. The board is made up of an `m x n` grid of cells, where each cell has an initial state: live (represented by a `1`) or dead (represented by a `0`). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following rules: * Any live cell with fewer than two live neighbors dies as if caused by under-population. * Any live cell with two or three live neighbors lives on to the next generation. * Any live cell with more than three live neighbors dies, as if by over-population. * Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_ of the board.","solution":"def gameOfLife(board): Simulates one iteration of the Game of Life. Args: board (list[list[int]]): 2D grid representing the board Returns: None directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] rows, cols = len(board), len(board[0]) next_board = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = 0 for dr, dc in directions: if 0 <= r + dr < rows and 0 <= c + dc < cols: if board[r + dr][c + dc] == 1: live_neighbors += 1 if board[r][c] == 1 and (live_neighbors == 2 or live_neighbors == 3): next_board[r][c] = 1 elif board[r][c] == 0 and live_neighbors == 3: next_board[r][c] = 1 for r in range(rows): for c in range(cols): board[r][c] = next_board[r][c]"},{"question":"Given an m x n matrix `board` containing `\'X\'` and `\'O\'` (the letter O), capture all regions surrounded by `\'X\'`. A region is captured by flipping all `\'O\'`s into `\'X\'`s in that surrounded region. A region is surrounded if there are no `\'O\'`s on the border of the board. More formally, a region is surrounded if all of the `\'O\'`s in that region are surrounded by `\'X\'`s either horizontally or vertically. Return the modified board after filling in all surrounded regions. Example: Input: board = [ [\'X\', \'X\', \'X\', \'X\'], [\'X\', \'O\', \'O\', \'X\'], [\'X\', \'X\', \'O\', \'X\'], [\'X\', \'O\', \'X\', \'X\'] ] Output: [ [\'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\'], [\'X\', \'O\', \'X\', \'X\'] ] Explanation: Surrounded regions should not be on the border, which means that any \'O\' on the border of the board are not flipped to \'X\'. Any \'O\' that is not on the border and is not connected to an \'O\' on the border will be flipped to \'X\'.","solution":"def solve(board): Captures all regions surrounded by \'X\' in-place. if not board or not board[0]: return rows, cols = len(board), len(board[0]) def dfs(x, y): if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != \'O\': return board[x][y] = \'B\' dfs(x - 1, y) dfs(x + 1, y) dfs(x, y - 1) dfs(x, y + 1) for i in range(rows): dfs(i, 0) dfs(i, cols - 1) for j in range(cols): dfs(0, j) dfs(rows - 1, j) for i in range(rows): for j in range(cols): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'B\': board[i][j] = \'O\'"},{"question":"Given a string `s` containing only lowercase alphabet characters, return _a list containing the starting indices of all anagrams of a given string `p` within `s`_. An anagram is a permutation of a word, meaning all the characters of the word are present in the same frequency. For example, if `p = \\"ab\\"`, an anagram might look like `\\"ab\\"` or `\\"ba\\"`. Note that the output order does not matter.","solution":"from collections import Counter def find_anagrams(s, p): Returns a list containing the starting indices of all anagrams of the string `p` within the string `s`. p_count = Counter(p) s_count = Counter() result = [] p_len = len(p) for i in range(len(s)): s_count[s[i]] += 1 if i >= p_len: if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"You are given a string `s` consisting of lowercase letters. An anagram rearrangement of `s` can be obtained by randomly shuffling its letters. Return the minimum number of characters that need to be changed to make `s` an anagram of another given string `t` of the same length, which also consists of lowercase letters. If it is impossible to do so, return -1.","solution":"def min_changes_to_anagram(s, t): Given two strings s and t of the same length, returns the minimum number of characters that need to be changed to make s an anagram of t. If impossible, return -1. if len(s) != len(t): return -1 from collections import Counter count_s = Counter(s) count_t = Counter(t) changes_needed = 0 for char in count_s: if char in count_t: required = max(0, count_s[char] - count_t[char]) else: required = count_s[char] changes_needed += required return changes_needed"},{"question":"You are given a 2D grid of size `m x n` representing a map where `0` represents water and `1` represents land. An island is a group of `1`\'s (land) connected 4-directionally (horizontal or vertical). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land). The island doesn\'t have \\"lakes\\", meaning the water inside the island is not connected to the water around the island. You have to **enclose** the island with a border of water. Put a border of `0`s all around the island. You may assume all four edges of the grid are surrounded by water. Return _the_ `m x n` _grid after enclosing the island with a border of water_.","solution":"def enclose_island(grid): m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 1: return grid[x][y] = -1 # Mark the land as visited # Visit all 4-directionally connected lands dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) # Find the starting point of the island and mark the entire island for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j) break else: continue break # Add a border of water (0s) around the marked island for i in range(m): for j in range(n): if grid[i][j] == -1: # Part of the island if any([ i == 0, i == m-1, j == 0, j == n-1, grid[i-1][j] == 0 or grid[i+1][j] == 0, grid[i][j-1] == 0 or grid[i][j+1] == 0, ]): grid[i][j] = 0 else: grid[i][j] = 1 return grid"},{"question":"You are given a string of digits `s` representing a decimal number. Your task is to insert commas into the string to separate the number into groups of three digits, starting from the right side of the number. For example, if the input is `\\"1234567\\"`, the output should be `\\"1,234,567\\"`. Write a function that takes the input string `s` and returns the formatted string with commas as thousand separators.","solution":"def format_with_commas(s): Takes a string of digits and returns it formatted with commas as thousand separators. if not s.isdigit(): raise ValueError(\\"Input must be a string of digits\\") return \'{:,}\'.format(int(s))"},{"question":"Given a string `s` representing an arithmetic expression that may contain open and closed parentheses, addition `+`, subtraction `-`, and integers, write a function to evaluate the expression and return the result as an integer. The given expression is always valid and follows the standard rules for arithmetic operations. The integer values in the expression are non-negative.","solution":"def evaluate_expression(s): def evaluate(tokens): stack = [] num = 0 sign = 1 result = 0 for token in tokens: if token.isdigit(): num = num * 10 + int(token) elif token == \'+\': result += sign * num num = 0 sign = 1 elif token == \'-\': result += sign * num num = 0 sign = -1 elif token == \'(\': stack.append(result) stack.append(sign) result = 0 sign = 1 elif token == \')\': result += sign * num num = 0 result *= stack.pop() # sign before the parenthesis result += stack.pop() # result calculated before the parenthesis return result + sign * num return evaluate(list(s.replace(\' \', \'\')))"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to determine whether the array can be partitioned into `k` non-empty subsets whose sums are all equal. Return `true` if such a partition is possible, otherwise, return `false`. Implement a function `canPartitionKSubsets(arr, k)` that performs this check.","solution":"def canPartitionKSubsets(arr, k): Determines if the array can be partitioned into k non-empty subsets with equal sums. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) def backtrack(start, k, current_sum): if k == 0: return True if current_sum == target_sum: return backtrack(0, k-1, 0) for i in range(start, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if backtrack(i+1, k, current_sum + arr[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the **length of the longest path** between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. **Example**: Given a binary tree ``` 1 / 2 3 / 4 5 ``` The diameter of this tree is `3`, as the longest path is `4 -> 2 -> 1 -> 3` or `5 -> 2 -> 1 -> 3`, which have length `3`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Compute the diameter of a binary tree. The diameter is defined as the length of the longest path between any two nodes. def height_and_diameter(node): if not node: return 0, 0 # height, diameter left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) current_height = max(left_height, right_height) + 1 # The diameter that passes through this node current_diameter = left_height + right_height # The largest diameter is either from the left subtree, right subtree or passing through this node max_diameter = max(current_diameter, left_diameter, right_diameter) return current_height, max_diameter _, diameter = height_and_diameter(root) return diameter"},{"question":"Given a list of `n` employees, each represented by their unique ID, and their respective ratings stored in a list of tuples where each tuple contains an employee ID and their rating. The goal is to identify and return the ID of the employee with the highest rating. The input will be a list of tuples `ratings`, where each tuple contains two integers `[employeeID, rating]`. If there is a tie (i.e., multiple employees have the highest rating), return the ID of the employee with the smallest ID among those tied for the highest rating. The function should have the following signature: `def get_top_employee(ratings: List[Tuple[int, int]]) -> int:` Return _the ID of the employee with the highest rating_.","solution":"from typing import List, Tuple def get_top_employee(ratings: List[Tuple[int, int]]) -> int: Returns the ID of the employee with the highest rating. In the case of a tie, returns the smallest employee ID. if not ratings: raise ValueError(\\"Ratings list cannot be empty\\") # Find the maximum rating max_rating = max(ratings, key=lambda x: x[1])[1] # Filter employees with the maximum rating top_employees = [employee[0] for employee in ratings if employee[1] == max_rating] # Return the employee with the smallest ID among the top employees return min(top_employees)"},{"question":"You are given an `m x n` binary matrix `grid`. An island is a group of `1`\'s (representing land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with the value `1` in the island. Return _the area of the largest island in the `grid`_. Use depth-first search (DFS) to solve the problem.","solution":"def max_area_of_island(grid): Returns the area of the largest island in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return 0 grid[r][c] = 0 return 1 + dfs(r-1, c) + dfs(r+1, c) + dfs(r, c-1) + dfs(r, c+1) max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"You are given two integer arrays `arr1` and `arr2`, and an integer `d`. Find the number of elements in `arr1` such that there is no element in `arr2` within a distance of `d` from it. The distance between two integers `a` and `b` is defined as `|a - b|`. Return _the count of such elements in `arr1`_.","solution":"def find_the_distance_value(arr1, arr2, d): def is_within_distance(a, arr, d): for b in arr: if abs(a - b) <= d: return True return False count = 0 for a in arr1: if not is_within_distance(a, arr2, d): count += 1 return count"},{"question":"You are given a **perfect binary tree**, represented by its root node. A perfect binary tree is a type of binary tree in which every internal node has exactly two children and all leaf nodes are at the same level. Write a function to **connect** the next right pointers of each node to point to its next right node. If there is no next right node, the next right pointer should be set to `NULL`. Initially, all next right pointers are set to `NULL`. After connecting the next right pointers, return the root of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Connects the next pointers of each node in a perfect binary tree. if not root: return root # Start with the root node leftmost = root while leftmost.left: # Iterate through the current level head = leftmost while head: # Connect the left child to the right child head.left.next = head.right # Connect the right child to the next left child if available if head.next: head.right.next = head.next.left # Move to the next node in the current level head = head.next # Move to the next level leftmost = leftmost.left return root"},{"question":"New Question 4: Consider a **0-indexed** integer array `ratings` of length `n` where `ratings[i]` represents the rating value of the `i-th` student. You are to distribute books to these students such that: 1. Each student receives at least one book. 2. Students with a higher rating get more books than their adjacent peers with a lower rating. Return _the minimum number of books you need to distribute to this class of students_. # Example: ```plaintext Input: ratings = [1,0,2] Output: 5 Explanation: You can distribute books in the following way: [2,1,2] ``` ```plaintext Input: ratings = [1,2,2] Output: 4 Explanation: You can distribute books in the following way: [1,2,1] The first student gets 1 book, the second student gets 2 books, and the third student gets 1 book, because the second student\'s rating is higher than the first student\'s but not higher than the third student\'s. ```","solution":"def min_books(ratings): n = len(ratings) books = [1] * n # Left to right for i in range(1, n): if ratings[i] > ratings[i-1]: books[i] = books[i-1] + 1 # Right to left for i in range(n-2, -1, -1): if ratings[i] > ratings[i+1]: books[i] = max(books[i], books[i+1] + 1) return sum(books)"},{"question":"Given a string `s` that consists of digits only, we can insert a plus (\'+\') or minus (\'-\') sign between any two consecutive digits, and we can evaluate the resulting expression in the usual sequence of operations. Return the **maximum possible result** that can be obtained by evaluating all possible expressions formed by adding binary operators between the digits.","solution":"def max_possible_result(s): Given a string consisting of digits, returns the maximum possible result by inserting \'+\' or \'-\' between any two consecutive digits. # Initialize the result to the first digit as an integer result = int(s[0]) # Traverse through the string from the second character onwards for i in range(1, len(s)): # Always maximize the result by adding the digit result += int(s[i]) return result"},{"question":"You are given an integer array `nums` and an integer `k`. Return an array of the maximum values of each subarray of length `k` in `nums`. If `nums` is empty or `k` is greater than the length of `nums`, return an empty array.","solution":"from collections import deque def max_sliding_window(nums, k): Returns an array of the maximum values of each subarray of length k in nums. if not nums or k == 0 or k > len(nums): return [] result = [] dq = deque() for i in range(len(nums)): if dq and dq[0] == i - k: dq.popleft() while dq and nums[dq[-1]] < nums[i]: dq.pop() dq.append(i) if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"Given a directed graph with `n` nodes labeled `0` to `n-1`, represented by an adjacency matrix `graph`. The entry `graph[i][j]` is `1` if there is a directed edge from node `i` to node `j`, and `0` otherwise. Your task is to determine if the graph contains a cycle. Return `true` if there is a cycle, otherwise return `false`.","solution":"def has_cycle(graph): Determine if the directed graph contains a cycle. Parameters: - graph: List[List[int]], an adjacency matrix representation of the directed graph Returns: - bool: True if the graph contains a cycle, False otherwise def dfs(node, visited, recStack): visited[node] = True recStack[node] = True for neighbor, is_edge in enumerate(graph[node]): if is_edge: if not visited[neighbor] and dfs(neighbor, visited, recStack): return True elif recStack[neighbor]: return True recStack[node] = False return False n = len(graph) visited = [False] * n recStack = [False] * n for node in range(n): if not visited[node]: if dfs(node, visited, recStack): return True return False"},{"question":"You are given an array `edges` where `edges[i] = [a, b]` indicates there is an undirected edge between nodes `a` and `b` in a graph. Given an integer `n` representing the number of nodes in the graph labeled from `0` to `n-1`, return _the number of **connected components** in the graph_. A **connected component** is a set of nodes in which each node is reachable from any other node in the same set. --- This new question maintains the style, complexity, length, and tone of the existing set, focusing on graph connectivity which complements the tree and string manipulation themes already present.","solution":"def count_components(n, edges): Returns the number of connected components in an undirected graph. :param n: Integer, the number of nodes :param edges: List of pairs representing edges in the graph :return: Integer, the number of connected components def dfs(node, visited, adjacency_list): stack = [node] while stack: curr = stack.pop() for neighbor in adjacency_list[curr]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) adjacency_list = [[] for _ in range(n)] for a, b in edges: adjacency_list[a].append(b) adjacency_list[b].append(a) visited = [False] * n count = 0 for i in range(n): if not visited[i]: count += 1 visited[i] = True dfs(i, visited, adjacency_list) return count"},{"question":"Given a 2D matrix `grid` of integers, where each element represents the height of a block, determine the surface area of the 3D shape formed by these blocks. The shape created by stacking the blocks on top of each other is such that it completely fills the grid. You need to calculate the total surface area visible from all six sides (top, bottom, and four sides). Note: The height of the blocks is always >= 0.","solution":"def surface_area(grid): rows = len(grid) cols = len(grid[0]) area = 0 for i in range(rows): for j in range(cols): if grid[i][j] > 0: area += 2 # top and bottom surface area # Add sides area while considering adjacent height difference area += grid[i][j] # front area += grid[i][j] # back area += grid[i][j] # left area += grid[i][j] # right if i > 0: area -= min(grid[i][j], grid[i-1][j]) # overlap with the block above if i < rows - 1: area -= min(grid[i][j], grid[i+1][j]) # overlap with the block below if j > 0: area -= min(grid[i][j], grid[i][j-1]) # overlap with the block to the left if j < cols - 1: area -= min(grid[i][j], grid[i][j+1]) # overlap with the block to the right return area"},{"question":"**[Question 4]:** A game includes a rectangular grid of cells with each cell being either empty or blocked. You are given a `m x n` grid `grid` representing the status of each cell (`0` for empty, `1` for blocked). A player starts at the top-left cell and wants to reach the bottom-right cell. The player can move to an empty cell in one of the four possible directions (up, down, left, right) but cannot move into a blocked cell or outside the grid boundaries. Determine if there is a path from the top-left cell to the bottom-right cell. Return `true` if such a path exists and `false` if it does not.","solution":"from collections import deque def has_path(grid): Determines if there is a path from the top-left to the bottom-right in a given grid. :param grid: List[List[int]] where 0 represents an empty cell and 1 represents a blocked cell :return: Boolean value indicating if a path from top-left to bottom-right exists # Check for an empty grid or start/end being blocked if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Initialize queue for BFS queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # Check if we\'ve reached the bottom-right corner if x == m-1 and y == n-1: return True # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) # If queue is empty, no path was found return False"},{"question":"You are given a binary tree in the form of an integer array `tree` where the parent-child relationship is represented by indices. For any node at index `i`, its left child is located at index `2*i + 1` and its right child is located at index `2*i + 2`. Some nodes might be missing, represented by `-1` in the array. Your task is to determine if it is possible to transform this binary tree into a binary search tree (BST) by rearranging the values of the nodes while keeping the structure of the tree unchanged. Return `true` if it is possible, otherwise return `false`.","solution":"def can_transform_to_bst(tree): Determines if it is possible to transform the binary tree into a binary search tree by rearranging the values of the nodes while keeping the structure of the tree unchanged. :param tree: List[int], input list representation of a binary tree where `-1` represents missing nodes. :return: bool, True if transformation is possible, False otherwise. def in_order_traversal(tree, index, result): if index >= len(tree) or tree[index] == -1: return in_order_traversal(tree, 2 * index + 1, result) # left child result.append(tree[index]) in_order_traversal(tree, 2 * index + 2, result) # right child # Perform in-order traversal and collect only the valid nodes (discarding -1) elements_in_order = [] in_order_traversal(tree, 0, elements_in_order) # Remove -1 from elements_in_order elements_in_order = [x for x in elements_in_order if x != -1] # Check if it is possible to rearrange `elements_in_order` in such a way that it forms a strictly increasing sequence. n = len(elements_in_order) sorted_elements = sorted(elements_in_order) return n == len(set(sorted_elements))"},{"question":"You are given a **directed acyclic graph (DAG)** represented as an adjacency list `graph`, where `graph[i]` is a list of all nodes `j` such that there is a directed edge from node `i` to node `j`. Each edge has a positive integer weight. You are also provided two nodes `start` and `end`. Write a function to return the **length of the shortest path** from `start` to `end`. If there is no path from `start` to `end`, return `-1`. The graph nodes are numbered from `0` to `n-1`.","solution":"import heapq def shortest_path_dag(graph, start, end): Finds the shortest path in a weighted directed acyclic graph from start to end. :param graph: List[List[(int, int)]], where graph[i] is a list of (node, weight) pairs. :param start: int, the starting node. :param end: int, the end node. :return: int, the length of the shortest path from start to end. If no path exists, returns -1. n = len(graph) dist = [float(\'inf\')] * n dist[start] = 0 min_heap = [(0, start)] while min_heap: current_dist, u = heapq.heappop(min_heap) if u == end: return current_dist if current_dist > dist[u]: continue for v, weight in graph[u]: new_dist = current_dist + weight if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(min_heap, (new_dist, v)) return -1 if dist[end] == float(\'inf\') else dist[end]"},{"question":"Given an array of integers `nums` representing the number of coins in each pile, and an integer `k` representing the total number of coins you are allowed to remove, return the minimum possible total number of coins remaining in the piles after `k` coins have been removed. You may choose to remove any number of coins from any pile in each operation.","solution":"import heapq def min_remaining_total(nums, k): Returns the minimum possible total number of coins remaining in the piles after removing k coins. :param nums: List[int], list of integers representing the number of coins in each pile :param k: int, total number of coins allowed to be removed :return: int, minimum total number of coins remaining max_heap = [-num for num in nums] heapq.heapify(max_heap) while k > 0: max_value = -heapq.heappop(max_heap) removed = min(max_value, k) max_value -= removed heapq.heappush(max_heap, -max_value) k -= removed return -sum(max_heap)"},{"question":"You are given a non-negative integer array `nums`. In one operation, you can choose any index `i` where `0 <= i < nums.length` and change `nums[i]` to `nums[i] + 1` or `nums[i] - 1`. Return the minimum number of operations required to make all the elements in `nums` equal.","solution":"def min_operations_to_make_equal(nums): Returns the minimum number of operations required to make all elements in nums equal. if not nums: return 0 median = sorted(nums)[len(nums) // 2] operations = sum(abs(num - median) for num in nums) return operations # Example input # nums = [1, 2, 3] # The median is 2. We can make all elements equal to 2 in 2 operations: # change 1 to 2 in 1 operation and change 3 to 2 in 1 operation, total 2 operations. # Therefore, min_operations_to_make_equal([1, 2, 3]) should return 2."},{"question":"You are given a **0-indexed** integer array `candies` where `candies[i]` is the number of candies in the `i`-th pile. Two players, Alice and Bob, take turns picking any number of candies from any single pile, with Alice going first. The player who cannot make a move loses the game. Both players play optimally. Assume both start with an empty collection, and when a player takes candies from a pile, the pile is no longer available for future turns. Determine whether Alice can win the game given the initial configuration of the `candies` array. Return `true` if Alice can guarantee a win, or `false` otherwise.","solution":"def alice_can_win(candies): Determines whether Alice can guarantee a win in the given game. Args: candies (list): A list where each element represents the number of candies in a pile. Returns: bool: True if Alice can guarantee a win, False otherwise. # XOR of all candy piles xor_sum = 0 for pile in candies: xor_sum ^= pile # Alice wins if the XOR of all elements is not 0 return xor_sum != 0"},{"question":"You are given an array of integers, `arr`, and an integer `target`. Your task is to find the length of the shortest subarray whose sum is greater than or equal to `target`. If no such subarray exists, return 0. Example: For an array `arr = [2, 3, 1, 2, 4, 3]` and `target = 7`, the shortest subarray with sum `>= 7` is `[4, 3]`, so the function should return 2.","solution":"def min_subarray_len(arr, target): n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"Given an integer array `nums`, you need to design an algorithm to find the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. Implement the `KthLargestElement` class: * `KthLargestElement(int[] nums)` initializes the object with the given integer array `nums`. * `int findKthLargest(int k)` returns the k-th largest element in the array.","solution":"class KthLargestElement: def __init__(self, nums): self.nums = nums def findKthLargest(self, k): Returns the k-th largest element in the array. return sorted(self.nums, reverse=True)[k-1]"},{"question":"Given a `2D` binary grid representing a map of `\'1\'s` (land) and `\'0\'s` (water), return _the number of islands_. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Implement the function `int numIslands(vector<vector<char>>& grid)`, where `grid` is the `2D` binary grid. **Example:** ```cpp Input: grid = [ [\'1\', \'1\', \'1\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'0\', \'0\'] ] Output: 1 ``` ```cpp Input: grid = [ [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'1\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'1\', \'1\'] ] Output: 3 ```","solution":"def numIslands(grid): Returns the number of islands in the given 2D binary grid. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != \'1\': return grid[x][y] = \'0\' # mark as visited # recursively visit all neighboring cells dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': dfs(i, j) num_islands += 1 return num_islands"},{"question":"Given a string `s`, determine if it is **valid**. A string is considered valid if all characters of the string appear the same number of times or if you can remove just one character at one point in the string and the resultant string will have all characters with the same frequency. Return `true` if the string is valid, otherwise return `false`.","solution":"def is_valid_string(s): from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count the frequency of these frequencies freq_of_freq = Counter(freq.values()) # If there\'s only one frequency, it\'s already valid if len(freq_of_freq) == 1: return True # If there are more than 2 different frequencies, it\'s not valid if len(freq_of_freq) > 2: return False # There should be only two frequencies here freq1, freq2 = freq_of_freq.keys() count1, count2 = freq_of_freq.values() # Check for the conditions where it can be valid: # 1. One frequency should be 1 and it appears only once -> remove one character # 2. Difference between the two frequencies should be 1 and the higher frequency appears only once -> remove one character if (freq1 == 1 and count1 == 1) or (freq2 == 1 and count2 == 1): return True if (abs(freq1 - freq2) == 1) and (freq1 > freq2 and count1 == 1 or freq2 > freq1 and count2 == 1): return True return False"},{"question":"You are given a list of strings `words` and a string `pattern`. Determine if the pattern appears as a subsequence in all of the strings within the list. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return a list of booleans where each boolean corresponds to whether the pattern is a subsequence of the respective word in `words`. Example: ```python words = [\\"abcde\\", \\"ace\\", \\"aec\\", \\"bdf\\"] pattern = \\"ace\\" # Output: [True, True, False, False] ```","solution":"def is_subsequence(pattern, word): Determine if the pattern is a subsequence of the word. it = iter(word) return all(char in it for char in pattern) def is_pattern_in_all_words(words, pattern): Determine if the pattern is a subsequence in each word in the words list. return [is_subsequence(pattern, word) for word in words]"},{"question":"Given an integer array `arr` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. This means that every element in the array will be shifted `k` positions to the right, with the elements wrapping around to the beginning as needed. Return the rotated array. For example, given `arr = [1, 2, 3, 4, 5, 6, 7]` and `k = 3`, you should return `[5, 6, 7, 1, 2, 3, 4]`.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of integers to be rotated. k (int): Number of steps to rotate the array to the right. Returns: list: Rotated array. n = len(arr) k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"You are given a list of `n` integers representing the heights of `n` buildings. You want to move from the leftmost building to the rightmost building. In one step, you can move from building `i` to building `i+1` if the height of building `i` is less than or equal to the height of building `i+1`. Additionally, you can choose to jump over a single building if the height of the next building is greater than the current building. Determine the minimum number of steps required to move from the leftmost building to the rightmost building. The jump counts as a single step. Return the minimum number of steps.","solution":"def min_steps_to_reach_rightmost(buildings): Returns the minimum number of steps required to move from the leftmost building to the rightmost building. Parameters: buildings (list): The list of heights of the buildings. Returns: int: The minimum number of steps required. n = len(buildings) if n <= 1: return 0 steps = 0 i = 0 while i < n - 1: if buildings[i] <= buildings[i + 1]: i += 1 elif i + 2 < n and buildings[i + 2] >= buildings[i]: i += 2 else: i += 1 steps += 1 return steps"},{"question":"You are given a list of `n` items, each with a positive integer weight. You are also given a list `capacity` of `m` bags, where `capacity[j]` represents the maximum weight the `j-th` bag can hold. You need to distribute all items into the bags such that no bag exceeds its maximum weight capacity. Each item can only be placed in one bag. Return _the **maximum number of items** that can be distributed into the bags while respecting the weight limits._","solution":"def max_items_distribution(weights, capacities): Returns the maximum number of items that can distributed into the bags without exceeding their capacity. :param weights: List[int], list of weights of the items :param capacities: List[int], list of capacities of the bags :return: int, maximum number of items that can be distributed # Sort weights of items and capacities of bags to facilitate the greedy approach weights.sort() capacities.sort() item_index = 0 bag_index = 0 items_distributed = 0 while item_index < len(weights) and bag_index < len(capacities): if weights[item_index] <= capacities[bag_index]: # if the item can fit into the current bag, distribute it items_distributed += 1 item_index += 1 bag_index += 1 else: # move to the next bag since the current one cannot fit the item bag_index += 1 return items_distributed"},{"question":"You are developing a function to simulate a basic banking system. The system supports three main operations: deposit, withdraw, and transfer between accounts. You are given a list of initial balances for a set of accounts and a sequence of operations to perform on these accounts. Each account is indexed starting from 1. Each operation is given as a list in one of the following formats: - `[\\"Deposit\\", account, amount]`: Deposit the specified `amount` of money into the `account`. - `[\\"Withdraw\\", account, amount]`: Withdraw the specified `amount` of money from the `account`, if possible. - `[\\"Transfer\\", fromAccount, toAccount, amount]`: Transfer the specified `amount` of money from `fromAccount` to `toAccount`, if possible. Implement a function that processes these operations and returns the final state of the account balances. If any withdraw or transfer operation cannot be performed due to insufficient funds, it should be ignored. The function signature is as follows: ```python def process_transactions(balances: List[int], transactions: List[List[str]]) -> List[int]: ``` where: - `balances` is a list of integers representing the initial balance of each account. - `transactions` is a list of lists, each representing an operation in the format specified above. Return the final state of the account balances after performing all the operations.","solution":"from typing import List def process_transactions(balances: List[int], transactions: List[List[str]]) -> List[int]: for transaction in transactions: if transaction[0] == \\"Deposit\\": account, amount = transaction[1] - 1, transaction[2] balances[account] += amount elif transaction[0] == \\"Withdraw\\": account, amount = transaction[1] - 1, transaction[2] if balances[account] >= amount: balances[account] -= amount elif transaction[0] == \\"Transfer\\": from_account, to_account, amount = transaction[1] - 1, transaction[2] - 1, transaction[3] if balances[from_account] >= amount: balances[from_account] -= amount balances[to_account] += amount return balances"},{"question":"Given an integer array `nums`, return _the number of **unique triplets**_ `(nums[i], nums[j], nums[k])` _such that_ `i, j, k` _are all distinct and_ `nums[i] + nums[j] + nums[k] == target`_, where_ `target` _is an integer_. Note that the order of the triplets does not matter, and the same set of integers cannot be counted more than once.","solution":"def three_sum_unique_triplets(nums, target): Given an integer array nums and a target value, return the number of unique triplets (nums[i], nums[j], nums[k]) such that i, j, k are all distinct and nums[i] + nums[j] + nums[k] == target. nums.sort() triplets_set = set() n = len(nums) for i in range(n - 2): l, r = i + 1, n - 1 while l < r: triplet_sum = nums[i] + nums[l] + nums[r] if triplet_sum == target: triplets_set.add((nums[i], nums[l], nums[r])) l += 1 r -= 1 elif triplet_sum < target: l += 1 else: r -= 1 return len(triplets_set)"},{"question":"You are given a grid with `m` rows and `n` columns, represented by a two-dimensional list. Each cell in the grid contains a non-negative integer, where each integer represents the cost to pass through that cell. You need to find a path from the top-left cell to the bottom-right cell that minimizes the total cost. You can only move either down or right at any point in time. Return the minimum total cost to reach the bottom-right cell from the top-left cell. The grid is guaranteed to have at least one row and one column.","solution":"def minPathSum(grid): Returns the minimum total cost to reach the bottom-right cell from the top-left cell in a grid with given costs, only moving down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the first cell with the value of the first cell in the grid dp[0][0] = grid[0][0] # Fill the first row (can only move from the left cell) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only move from the cell above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the minimum path sum return dp[m - 1][n - 1]"},{"question":"You are given a string `s` and an array `indices` of the same length. The array `indices` is a permutation of the numbers from `0` to `s.length - 1`. Your task is to write a function that returns a new string where the character at the `i`th position of the new string is the character at the `indices[i]` position of the original string `s`. Reconstruct the string according to the array `indices` and return it.","solution":"def restore_string(s, indices): Restores a string based on the given indices mapping. Parameters: s (str): The original string. indices (list[int]): A list of integers indicating the new positions of each character. Returns: str: The restored string. restored = [\'\'] * len(s) for i, idx in enumerate(indices): restored[idx] = s[i] return \'\'.join(restored)"},{"question":"Given an integer matrix `grid` of dimensions `m x n` representing a field of various crops and an integer `t`, return the maximum sum of crops collected in any submatrix of size `t x t`. A submatrix is defined as a contiguous block within the matrix. Each cell in the matrix contains a non-negative integer representing the yield of crops at that position.","solution":"def max_sum_submatrix(grid, t): Returns the maximum sum of crops collected in any submatrix of size t x t. if not grid or not grid[0] or t <= 0: return 0 m, n = len(grid), len(grid[0]) if t > m or t > n: return 0 max_sum = 0 for i in range(m - t + 1): for j in range(n - t + 1): current_sum = 0 for a in range(t): for b in range(t): current_sum += grid[i + a][j + b] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a binary tree with `n` nodes where nodes are numbered from `1` to `n`. Each node has a value associated with it. Also given are two integers `targetSum` and `k`. Your task is to write a function to determine if there is a path of exactly `k` edges in the tree such that the sum of values along the path equals `targetSum`. Return `true` if there exists such a path, otherwise return `false`. Write a function: ```python def hasPathSumKEdges(root: TreeNode, targetSum: int, k: int) -> bool: ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def hasPathSumKEdges(root: TreeNode, targetSum: int, k: int) -> bool: if not root: return False def dfs(node, currentSum, currentEdges): if not node: return False currentSum += node.value if currentEdges == k and currentSum == targetSum: return True if currentEdges >= k: # if more than k edges, this path is not valid return False left = dfs(node.left, currentSum, currentEdges + 1) if left: return True right = dfs(node.right, currentSum, currentEdges + 1) return right return dfs(root, 0, 0)"},{"question":"Write a function that takes in a string `inputString` containing alphanumeric characters and returns the **longest palindrome** that can be formed using the characters of `inputString`. *For example, given `inputString = \\"abccccdd\\"`, the longest palindrome that can be formed is `\\"dccaccd\\"`, and given `inputString = \\"a\\"`, the longest palindrome is `\\"a\\"`. If multiple palindromes of the same length can be formed, return any one of them*.","solution":"def longest_palindrome(inputString): from collections import Counter # Count frequencies of each character freq = Counter(inputString) # To form a palindrome, characters should ideally be in pairs palindrome_length = 0 odd_char_used = False # Count pairs and identify if one odd character can be in the middle for char_count in freq.values(): # Add the largest even number less than or equal to char_count palindrome_length += char_count // 2 * 2 if char_count % 2 == 1: odd_char_used = True # If there\'s any character which can be used as the center character for the palindrome if odd_char_used: palindrome_length += 1 return palindrome_length"},{"question":"Given a list of `n` integers, `nums`, where every integer appears **exactly three times** except for one integer which appears **exactly once**, return the single integer that appears exactly once. Your algorithm should have a linear runtime complexity and use **only constant extra space**.","solution":"def singleNumber(nums): Returns the single integer that appears exactly once in a list where every other integer appears exactly three times. Parameters: nums (list): List of integers Returns: int: The single integer that appears exactly once ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given an integer array `arr` where each element represents the height at that position. The array has a \\"valley\\" pattern, where the height decreases to a minimum point and then increases, i.e. there exists an index `i` (0 <= i < arr.length) such that the elements to the left of `i` are in decreasing order, and the elements to the right of `i` are in increasing order. Determine if the given array `arr` forms a valid valley. Return `true` if the array forms a valid valley, otherwise return `false`.","solution":"def is_valid_valley(arr): if len(arr) < 3: # A valid valley must have at least 3 elements return False n = len(arr) i = 0 # Find the decreasing part while i < n - 1 and arr[i] > arr[i + 1]: i += 1 # If i reaches either end, it\'s not a valid valley if i == 0 or i == n - 1: return False # Check the increasing part while i < n - 1 and arr[i] < arr[i + 1]: i += 1 # If we reached the end, arr is a valid valley return i == n - 1"},{"question":"You are given an array of integers `nums` where elements are ordered in a specific way such that for every `i` (0 <= i < nums.length / 2), the element at index `2*i` is less than or equal to the element at index `2*i+1`. Your task is to convert the array into a \\"wiggle\\" sequence where `nums[0] <= nums[1] >= nums[2] <= nums[3] ...` without changing the positions of any elements. Return the resulting array in its \\"wiggle\\" sequence form. Note that you only need to return one valid arrangement adhering to the \\"wiggle\\" property.","solution":"def wiggle_sort(nums): Modify nums in-place to become a wiggle sequence. for i in range(1, len(nums)): if i % 2 == 1: if nums[i] < nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] else: if nums[i] > nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] return nums"},{"question":"You are given a matrix `mat` where each row is sorted in strictly increasing order. Return _the smallest common element_ in all rows. If there is no common element, return `-1`. **Note**: 1. `mat[i]` is sorted in strictly increasing order. 2. The matrix dimensions are `m x n` where `m` is the number of rows and `n` is the number of columns.","solution":"def smallest_common_element(mat): This function finds the smallest common element in all rows of a matrix `mat`. If there is no common element, it returns `-1`. if not mat: return -1 element_count = {} num_rows = len(mat) # Traverse through each row for row in mat: for elem in row: if elem not in element_count: element_count[elem] = 1 elif element_count[elem] < num_rows: # Increase count only if it hasn\'t been counted for all rows yet element_count[elem] += 1 # Check for common elements in rows for elem in sorted(element_count): if element_count[elem] == num_rows: return elem return -1"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return an array of the values of the nodes you can see ordered from top to bottom. Each node in the tree has a `TreeNode` class where `TreeNode.val` is the value of the node, `TreeNode.left` is the left child of the node, and `TreeNode.right` is the right child of the node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes visible from the right side of the binary tree. if not root: return [] result = [] queue = [(root, 0)] while queue: node, depth = queue.pop(0) if len(result) == depth: result.append(node.val) if node.right: queue.append((node.right, depth + 1)) if node.left: queue.append((node.left, depth + 1)) return result"},{"question":"You are given a string `s` consisting of lowercase letters and the character `*` which acts as a wildcard that can represent any single character. You need to return the **number of distinct subsequences** of `s` that can be formed by replacing each `*` with any lowercase letter. For example, if `s = \\"a*b\\"`, the distinct subsequences would include \\"ab\\", \\"aab\\", \\"abb\\", etc. If `s = \\"c*de*f\\"`, some of the distinct subsequences are \\"cdef\\", \\"cadef\\", \\"cbdef\\", and so on. Note that each wildcard can be replaced with any of the 26 lowercase letters, and you cannot change the order of characters in `s`. Return _the total number of distinct subsequences_ modulo (10^9 + 7).","solution":"MOD = 10**9 + 7 def num_distinct_subsequences(s): Returns the number of distinct subsequences that can be formed by replacing each \'*\' with any lowercase letter :param s: Input string :return: Number of distinct subsequences modulo 10^9 + 7 count_star = s.count(\'*\') return pow(26, count_star, MOD)"},{"question":"Given two strings `s1` and `s2`, return a new string formed by interleaving the characters of `s1` and `s2` alternately. If one string is longer than the other, append the additional characters to the end of the interleaved string. For example, if `s1 = \\"abc\\"` and `s2 = \\"pqr\\"`, the result should be `\\"apbqcr\\"`. If `s1 = \\"ab\\"` and `s2 = \\"pqrs\\"`, the result should be `\\"apbqrs\\"`. Return the interleaved string.","solution":"def interleave_strings(s1, s2): Returns a new string formed by interleaving the characters of s1 and s2 alternately. If one string is longer than the other, append the additional characters to the end of the interleaved string. interleaved = [] len_s1, len_s2 = len(s1), len(s2) max_len = max(len_s1, len_s2) for i in range(max_len): if i < len_s1: interleaved.append(s1[i]) if i < len_s2: interleaved.append(s2[i]) return \'\'.join(interleaved)"},{"question":"You are given a list of integers representing the amount of time each task takes to complete. You are also given an integer `k` representing the number of identical machines available to process these tasks. Each machine can process exactly one task at a time. Your goal is to determine the minimum time required to complete all tasks, given that the tasks can be assigned to any of the `k` machines. Return the minimum time needed to complete all tasks. **Note**: - The tasks can be assigned to the machines in any order. - Each task must be completed by a single machine.","solution":"def min_time_to_complete_tasks(tasks, k): Determines the minimum time required to complete all tasks using k machines. Parameters: tasks (list): List of integers where each integer represents the time taken by a task. k (int): Number of identical machines available. Returns: int: Minimum time required to complete all tasks. if k == 0: raise ValueError(\\"Number of machines cannot be zero.\\") # If there are more machines than tasks, the longest single task time determines the answer. if k >= len(tasks): return max(tasks) # Sort tasks in descending order to distribute workload more effectively. tasks.sort(reverse=True) # Initialize k machines with zero workload. machines = [0] * k # Distribute tasks to the machines with the least current workload. for task in tasks: # Assign this task to the machine with the least current workload. machines[0] += task # Re-sort the machines to keep least workload machine at the front. machines.sort() # The maximum time in any machine will be the minimum time to complete all tasks. return max(machines)"},{"question":"You are given a directed acyclic graph represented by an integer `n` (the number of nodes) and an array `edges` where `edges[i] = [ui, vi]` indicates that there is a directed edge from node `ui` to node `vi`. Your task is to find the number of unique paths from node `0` to node `n-1`. Since the number of paths can be very large, return the number of unique paths **modulo** `10^9 + 7`. If there is no path from `0` to `n-1`, return `0`.","solution":"def count_unique_paths(n, edges): MOD = 10**9 + 7 from collections import defaultdict, deque # Create graph and count in-degrees graph = defaultdict(list) in_degrees = [0] * n for u, v in edges: graph[u].append(v) in_degrees[v] += 1 # Topological order using Kahn\'s algorithm (BFS) queue = deque([i for i in range(n) if in_degrees[i] == 0]) top_order = [] while queue: node = queue.popleft() top_order.append(node) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) if len(top_order) != n: return 0 # Graph is not a DAG # Initialize path count for each node path_count = [0] * n path_count[0] = 1 # Start from node 0 # Calculate number of paths using topological order for node in top_order: for neighbor in graph[node]: path_count[neighbor] = (path_count[neighbor] + path_count[node]) % MOD return path_count[n - 1]"},{"question":"Given an array of integers `arr`, your task is to find the maximum sum of any non-empty subarray of `arr`. A subarray is a contiguous part of an array.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray of arr. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given two non-empty strings `word1` and `word2` consisting of lowercase letters. You need to find the length of the longest subsequence that can be derived from both strings `word1` and `word2`. A subsequence is derived by deleting some or no characters of a string without changing the order of the remaining characters. Return _an integer representing the length of the longest common subsequence_.","solution":"def longest_common_subsequence(word1, word2): Returns the length of the longest common subsequence of the two given strings. m = len(word1) n = len(word2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"Given an integer array `nums` sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Implement the function `removeDuplicates(nums: List[int]) -> int` that returns the length of the modified array and modifies the input array in-place. The elements beyond the returned length should not be considered. For example: - Given `nums = [1,1,1,2,2,3]`, the function should modify `nums` to be `[1,1,2,2,3,_]` and return `length = 5`. - Given `nums = [0,0,1,1,1,1,2,3,3]`, the function should modify `nums` to be `[0,0,1,1,2,3,3,_,_,_]` and return `length = 7`.","solution":"from typing import List def removeDuplicates(nums: List[int]) -> int: Removes duplicates in-place such that each unique element appears at most twice. Modifies the input array and returns the new length. if len(nums) <= 2: return len(nums) write_index = 2 for read_index in range(2, len(nums)): if nums[read_index] != nums[write_index - 2]: nums[write_index] = nums[read_index] write_index += 1 return write_index"},{"question":"You are given a string `str`, containing digits from `0` to `9`. Your task is to return the smallest number possible after removing exactly `k` digits from the string. The output should be in string format with no leading zeros. If the resultant number is empty, return `\\"0\\"`.","solution":"def remove_k_digits(num, k): Returns the smallest number possible after removing exactly k digits from the string num. if k == len(num): return \\"0\\" stack = [] for digit in num: while stack and k > 0 and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0 after the loop ends stack = stack[:-k] if k else stack # Removing leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \\"0\\""},{"question":"You are given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Write a function to calculate the maximum profit you can achieve from this transaction. If no profit can be achieved, return `0`. Implement the `StockTrader` class: * `StockTrader(int[] prices)` Initializes the `prices` array. * `int getMaxProfit()` Returns the maximum profit that can be achieved. If no profit is possible, it returns `0`.","solution":"class StockTrader: def __init__(self, prices): self.prices = prices def getMaxProfit(self): Returns the maximum profit that can be achieved. If no profit is possible, returns 0. if not self.prices or len(self.prices) < 2: return 0 min_price = self.prices[0] max_profit = 0 for price in self.prices[1:]: profit = price - min_price max_profit = max(max_profit, profit) min_price = min(min_price, price) return max_profit"},{"question":"You are given an integer array `arr[]` of size `n`. The task is to find the first positive integer that is missing from the array, i.e., the smallest positive integer that does not exist in the array. Implement a function to achieve this with an optimal time and space complexity. Return _the smallest positive integer that is missing from the array_.","solution":"def first_missing_positive(arr): This function finds the smallest positive integer that is missing from the array. The function operates in O(n) time and O(1) extra space. :param arr: List[int] - A list of integers. :return: int - The smallest positive integer that is missing from the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"Given a string `num` representing a large integer, return _the largest-valued odd integer (as a string) that is a non-empty substring of `num`, or an empty string if no odd integer exists._ A substring is defined as a contiguous sequence of characters within the string. Note that an odd integer is an integer which is not divisible by 2.","solution":"def largest_odd_substring(num): Returns the largest-valued odd integer (as a string) that is a non-empty substring of `num`, or an empty string if no odd integer exists. for i in range(len(num) - 1, -1, -1): if int(num[i]) % 2 != 0: return num[:i+1] return \\"\\""},{"question":"Given a list of integers `nums` and an integer `target`, return the pair of indices `(i, j)` such that the sum of `nums[i]` and `nums[j]` equals `target` and `i < j`. Each input has exactly one solution, and you may not use the same element twice. You can return the answer in any order.","solution":"def two_sum(nums, target): Returns a pair of indices (i, j) such that nums[i] + nums[j] == target and i < j. Args: nums: List of integers. target: Integer representing the target sum. Returns: Tuple of two integers representing the indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"You are given an unordered list of `n` integers. An integer `p` is called the pivot of the list if, after sorting the list, `p` is the middle element of the sorted list (i.e., the element that would be at the (n//2 + 1)-th position if the list was 1-indexed). Return the index of the pivot `p` in the original list. If there are multiple pivots, return the smallest index. If the list is empty, return `-1`.","solution":"def find_pivot_index(lst): Returns the index of the pivot element in the original list. The pivot is defined as the middle element after sorting the list. If there are multiple pivots, returns the smallest index. If the list is empty, returns -1. if not lst: return -1 sorted_lst = sorted(lst) pivot = sorted_lst[len(sorted_lst) // 2] for i, num in enumerate(lst): if num == pivot: return i return -1"},{"question":"You are given a string `s` representing a sentence. The sentence contains words and spaces. A word is defined as a sequence of alphanumeric characters, and spaces separate these words. Write a function that returns a new string where the words appear in **reverse order** from the original string `s`. Note that the order of the characters within a word remains unchanged, and string `s` may contain leading or trailing spaces or multiple spaces between words.","solution":"def reverse_words(s): Reverse the order of words in the given string \'s\'. :param s: A string representing a sentence with words and spaces. :return: A new string with words in reverse order. words = s.strip().split() reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"You are given an integer array `arr` and an integer `start`. You can move from index `i` to index `i + arr[i]` or index `i - arr[i]` where `i` is the current index. Return `true` if you can reach any index with value `0`, and `false` otherwise. Note that you cannot leap outside the bounds of the array. If you cannot move, you simply stop at that index.","solution":"def canReach(arr, start): Determines if it\'s possible to reach any index with value 0 in the array. :param arr: List of integers :param start: Starting index :return: Boolean indicating if it\'s possible to reach an index with value 0 n = len(arr) visited = [False] * n stack = [start] while stack: index = stack.pop() if arr[index] == 0: return True if visited[index]: continue visited[index] = True # Calculate new positions pos_forward = index + arr[index] pos_backward = index - arr[index] # If within bounds and not visited, add to stack if 0 <= pos_forward < n and not visited[pos_forward]: stack.append(pos_forward) if 0 <= pos_backward < n and not visited[pos_backward]: stack.append(pos_backward) return False"},{"question":"A company is analyzing its sales data over a period of `n` days. Each day\'s sales are represented by an integer in the array `sales`. A \\"profit span\\" of a day is the number of consecutive days (ending on that day) over which the sales are non-decreasing. In other words, for each day `i`, the profit span is the length of the longest subarray ending at `i` such that `sales[j] <= sales[j + 1]` for each `j` from the start of the subarray to `i - 1`. Given the array `sales`, return an array where the `i-th` element is the profit span for day `i`.","solution":"def profit_spans(sales): Returns an array where the i-th element is the profit span for day `i`. n = len(sales) spans = [1] * n # Initialize all spans to 1 for i in range(1, n): if sales[i] >= sales[i - 1]: spans[i] = spans[i - 1] + 1 else: spans[i] = 1 return spans"},{"question":"Write a function that takes a 2D list `grid` representing a grid of integers and returns the maximum sum of elements in any single row or column. The function should make use of efficient traversals to ensure a minimal runtime. The grid can have different numbers of rows and columns, but every element in the grid is a non-negative integer.","solution":"def max_sum(grid): Returns the maximum sum of elements in any single row or column. Parameters: grid (list of list of ints): A 2D list representing a grid of non-negative integers. Returns: int: The maximum sum of elements in any single row or column. if not grid or not grid[0]: return 0 max_row_sum = 0 num_rows = len(grid) num_cols = len(grid[0]) # Calculate the max sum of any row. for row in grid: max_row_sum = max(max_row_sum, sum(row)) # Calculate the max sum of any column. max_col_sum = 0 for col in range(num_cols): col_sum = sum(grid[row][col] for row in range(num_rows)) max_col_sum = max(max_col_sum, col_sum) return max(max_row_sum, max_col_sum)"},{"question":"You are given a 2D integer array `flights` where `flights[i] = [departurei, arrivali]` indicates that there is a one-way flight from city `departurei` to city `arrivali`. You are also given a positive integer `k` representing the maximum number of flights you are willing to take. Return _the minimum number of flights required to travel from city `0` to city `k`, or -1 if it is not possible to travel from city `0` to city `k` within the given limit_. [Question] 4:","solution":"from collections import deque, defaultdict def min_flights(flights, k): Returns the minimum number of flights required to travel from city 0 to city k, or -1 if it is not possible within the given limit. # Create a graph from the flights information graph = defaultdict(list) for departure, arrival in flights: graph[departure].append(arrival) # Use BFS to find the shortest path queue = deque([(0, 0)]) # (current city, number of flights taken) visited = set((0, 0)) while queue: current_city, num_flights = queue.popleft() # If we have reached the destination city if current_city == k: return num_flights # Add the neighbors to the queue for neighbor in graph[current_city]: if (neighbor, num_flights + 1) not in visited: queue.append((neighbor, num_flights + 1)) visited.add((neighbor, num_flights + 1)) # If there is no way to reach city k return -1"},{"question":"Given a string `s` consisting of lower case English letters and brackets, remove the minimal number of brackets so that the string is valid and contains balanced brackets. The resulting string should be the longest possible valid string. A string is considered valid if it contains matching opening and closing brackets in the correct order. Return the modified string.","solution":"def min_remove_to_make_valid(s: str) -> str: Removes the minimal number of brackets to make the string valid. Returns the longest possible valid string. stack = [] s = list(s) for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: s[i] = \'\' while stack: s[stack.pop()] = \'\' return \'\'.join(s)"},{"question":"You are given a **2D** integer array `events` where `events[i] = [starti, endi]` represents the time interval `[starti, endi]` during which the `i-th` event takes place. Additionally, you are given an integer `k`, representing the maximum number of events you can attend. An event can be attended if and only if it does not overlap with any other events you have already attended. Your task is to find the maximum number of events that you can attend given the constraint. If `k` is greater than the number of non-overlapping events, you can only attend as many as are non-overlapping. Return an integer representing the maximum number of events you can attend.","solution":"from typing import List def max_events_attend(events: List[List[int]], k: int) -> int: # Step 1: Sort events by their end times events.sort(key=lambda x: x[1]) # Step 2: Initialize variables attended_events = 0 last_end_time = -1 # Step 3: Iterate over sorted events for start, end in events: if start > last_end_time: attended_events += 1 last_end_time = end if attended_events == k: break return attended_events"},{"question":"You are given a list of integers `height` representing the height of buildings in a cityscape, where the width of each building is 1. Compute the maximum amount of water that can be trapped between the buildings after a rainfall. The amount of water trapped between two buildings is determined by the height of the shorter building a Write a function `maxWaterTrapped(height: List[int]) -> int` that takes the list of building heights and returns the maximum amount of water trapped between them. # Example: ``` Input: height = [4,2,0,3,2,5] Output: 9 Explanation: | | | # | | # # | | # # # | |#| 0123456 The maximum amount of water trapped is represented by 9 units. ```","solution":"from typing import List def maxWaterTrapped(height: List[int]) -> int: Calculates the maximum amount of water that can be trapped between buildings. Parameters: height (List[int]): List of integers representing the heights of the buildings. Returns: int: The maximum amount of water that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 max_water = 0 left_max, right_max = height[left], height[right] while left < right: if height[left] <= height[right]: left += 1 left_max = max(left_max, height[left]) max_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) max_water += right_max - height[right] return max_water"},{"question":"Given a 2D grid of integers representing an elevation map where the amount of water trapped after raining can be determined, return the total amount of water that can be trapped. Each cell in the grid has a certain height, and water can only be trapped in the valleys of the grid. Assume the borders of the grid are walls that cannot trap water themselves. **Function Signature:** ```python def trapRainWater(heightMap: List[List[int]]) -> int: pass ``` **Input:** - A 2D list `heightMap` representing the elevations, where `heightMap[i][j]` is the height of the terrain at coordinate (i, j). **Output:** - An integer representing the total amount of water that can be trapped after raining. **Constraints:** - The grid dimensions and elevation values are subject to appropriate limits ensuring the problem\'s feasibility in terms of solution development and computational resources required.","solution":"from heapq import heappush, heappop from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: if not heightMap or not heightMap[0]: return 0 n, m = len(heightMap), len(heightMap[0]) if n <= 2 or m <= 2: return 0 visited = [[False] * m for _ in range(n)] heap = [] # Push all border cells into heap and mark them as visited for i in range(n): heappush(heap, (heightMap[i][0], i, 0)) heappush(heap, (heightMap[i][m-1], i, m-1)) visited[i][0] = True visited[i][m-1] = True for j in range(m): heappush(heap, (heightMap[0][j], 0, j)) heappush(heap, (heightMap[n-1][j], n-1, j)) visited[0][j] = True visited[n-1][j] = True water_trapped = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"Given an array of integers `arr`, return an array where each element is replaced by the product of all the elements except itself. For example, given the input array `[1, 2, 3, 4]`, the output should be `[24, 12, 8, 6]`.","solution":"def product_except_self(arr): Returns an array where each element is replaced by the product of all the elements except itself. :param arr: List of integers :return: List of integers with the above condition length = len(arr) if length == 0: return [] result = [1] * length left_product = 1 for i in range(length): result[i] *= left_product left_product *= arr[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"You are given an integer array `heights` representing the heights of students in a line and an array `indices` representing the positions of students that should be swapped. Implement a function that swaps the heights of students at the given positions and returns the array after all swaps are performed. Each element in the `indices` array is a 2-element array where the first element is the index of the first student to swap and the second element is the index of the second student to swap. Note that all swaps are independent and should be applied to the original array in the provided order.","solution":"def swap_heights(heights, indices): Swaps the heights of students at the given positions in the indices array. :param heights: List[int] - List of students\' heights. :param indices: List[List[int]] - List of pairs of indices to swap. :return: List[int] - List of students\' heights after swaps. for i, j in indices: heights[i], heights[j] = heights[j], heights[i] return heights"},{"question":"You are given a linked list where each node contains an integer value. Your task is to return the linked list with duplicate values removed. The values should only remain if they appear exactly once in the original linked list. The order of the elements in the resulting linked list should be the same as their original order. Return the head of the modified list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove all elements that have duplicates in the linked list. Only elements that are unique in the linked list should be retained. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified list. if not head: return head # First pass: count occurrences of each value current = head count = {} while current: count[current.val] = count.get(current.val, 0) + 1 current = current.next # Second pass: create a new list with elements that appear exactly once dummy = ListNode(0) current = head new_current = dummy while current: if count[current.val] == 1: new_current.next = ListNode(current.val) new_current = new_current.next current = current.next return dummy.next"},{"question":"Given an array of integers `arr`, return the length of the longest contiguous subarray that contains only `ones` after performing at most one removal of a single element from the array. A contiguous subarray is defined as close as possible without any interruption between the elements. ``` Example: Input: arr = [1,1,0,1,1,1] Output: 5 Explanation: After removing the 0 at index 2, the longest contiguous subarray with only 1s is [1,1,1,1,1], which has length 5. ```","solution":"def longest_subarray_with_one_removal(arr): Finds the length of the longest contiguous subarray that contains only ones after performing at most one removal of a single element from the array. max_length = 0 zero_count = 0 left = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > 1: if arr[left] == 0: zero_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"Given a string `s` consisting of lowercase letters, remove the minimum number of characters from the string so that any two adjacent characters are not the same. Return _the resulting string after the removals_. For example: - Input: `\\"abccba\\"` - Output: `\\"abcba\\"`","solution":"def remove_min_characters(s): Removes the minimum number of characters from the string so that no two adjacent characters are the same. if len(s) < 2: return s result = [s[0]] # Initialize result list with the first character for i in range(1, len(s)): if s[i] != result[-1]: # If the current character is not the same as the last character in result result.append(s[i]) return \'\'.join(result)"},{"question":"You are given an integer `n` representing the number of cities in a country, labeled from `0` to `n - 1`. The cities are connected by some number of bidirectional roads where roads[i] = [ai, bi] denotes a road connecting city ai with city bi. You need to plan a trip and visit all the cities exactly once starting and ending in any city of your choice. However, due to recent storms, some roads have been heavily damaged, making them temporarily unusable. You are given a **0-indexed** 2D integer array `damagedRoads` where `damagedRoads[j] = [uj, vj]` indicates that the road between city `uj` and city `vj` is unusable. Return _a **boolean**_ `canCompleteTrip` which is `true` if it is possible to visit all the cities exactly once with the existing (unusable) roads, or `false` if it is not possible.","solution":"def canCompleteTrip(n, roads, damagedRoads): Determines whether you can complete the trip visiting all cities exactly once. :param n: number of cities :param roads: list of all existing roads as pairs [ai, bi] :param damagedRoads: list of damaged roads as pairs [uj, vj] :return: boolean indicating whether the trip is possible or not from collections import defaultdict, deque graph = defaultdict(list) # Remove damaged roads, effectively making them unusable by not adding them to the graph damaged_set = set(tuple(road) for road in damagedRoads) for road in roads: if tuple(road) not in damaged_set and tuple(road[::-1]) not in damaged_set: graph[road[0]].append(road[1]) graph[road[1]].append(road[0]) def is_connected(): visited = set() queue = deque([0]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n # Initial check to see if all cities are connected if not is_connected(): return False # Check for Eulerian path or circuit which is needed to visit all cities exactly once odd_degree_cities = sum(1 for node in graph if len(graph[node]) % 2 != 0) # Eulerian circuit (all vertices have even degree): can start and end at the same node # Eulerian path (exactly two vertices have odd degree): can start and end at different nodes return odd_degree_cities == 0 or odd_degree_cities == 2"},{"question":"You are given an integer array `depths` where `depths[i]` represents the depth of the `i-th` well in a village. A pipeline system is being planned such that it minimizes the total length of pipelines needed to connect all the wells. A pipeline can connect two wells `i` and `j` with a cost equal to `|depths[i] - depths[j]|`, the absolute difference between their depths. Your task is to find the minimum cost to connect all the wells in the village with pipelines. Return the minimum total pipeline length required.","solution":"def minPipelineCost(depths): Returns the minimum cost to connect all the wells in the village. if not depths: return 0 depths.sort() min_cost = 0 for i in range(1, len(depths)): min_cost += depths[i] - depths[i-1] return min_cost"},{"question":"Given an array of integers `arr`, your task is to find and return _the maximum possible sum of any non-empty subarray (contiguous sequence of elements)_ of `arr`. A subarray is defined as a contiguous subsequence of the array. Note: Your solution must have a linear runtime complexity.","solution":"def max_subarray_sum(arr): This function finds the maximum sum of any non-empty subarray. :param arr: List of integers :return: Integer, the maximum sum of any non-empty subarray if not arr: # edge case: if arr is empty return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a list of intervals `intervals` where each interval is represented as a tuple `(start, end)` and you need to perform an operation on these intervals. The operation is to merge all overlapping intervals and return the merged intervals in a list. Return the list containing the merged intervals such that no two intervals overlap and the intervals are sorted in ascending order based on the start of the intervals.","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of merged non-overlapping intervals in sorted order. Args: intervals (list of tuples): List of intervals where each interval is represented as a tuple (start, end). Returns: List of tuples: List of merged intervals sorted in ascending order by start. if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # If intervals overlap, merge them by updating the end time current_end = max(current_end, end) else: # If they don\'t overlap, add the current interval to the list and start a new one merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"You are given an undirected graph with `n` nodes and `m` edges. Each node is labeled from `1` to `n`. You need to determine if the graph is bipartite, which means the graph can be colored using two colors such that no two adjacent nodes have the same color. The graph is given as an array of edges, where each edge is represented as a pair `[u, v]` indicating that there is an undirected edge between nodes `u` and `v`. Return _a boolean value indicating whether the graph is bipartite_.","solution":"def is_bipartite_graph(n, edges): def bfs(start, color): queue = [start] color[start] = 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if color[neighbor] == -1: # Not colored yet color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) # Color array, -1 means not colored yet color = [-1] * (n + 1) for node in range(1, n + 1): if color[node] == -1: if not bfs(node, color): return False return True"},{"question":"You are given an array of integers `nums` and an integer `k`. Return the maximum possible sum of a non-empty subsequence of `nums` such that the greatest common divisor (GCD) of the elements of the subsequence is exactly `k`. A **subsequence** is a sequence derived from the array by deleting some or no elements without changing the order of the remaining elements. The **GCD** of a sequence of numbers is the largest integer that divides all the numbers in the sequence.","solution":"from math import gcd from functools import reduce def gcd_of_list(lst): return reduce(gcd, lst) def max_sum_subsequence_with_gcd(nums, k): valid_nums = [num for num in nums if num % k == 0] max_sum = 0 def helper(temp, index): nonlocal max_sum if temp and gcd_of_list(temp) == k: max_sum = max(max_sum, sum(temp)) for i in range(index, len(valid_nums)): helper(temp + [valid_nums[i]], i + 1) helper([], 0) return max_sum # Example usage: # nums = [2, 4, 8, 16] # k = 2 # max_sum_subsequence_with_gcd(nums, k)"},{"question":"Given an array of integers representing the **cost** of a marketing campaign for each day, and an integer `budget`, determine the maximum number of consecutive days the campaign can run without the total cost exceeding the budget. You can assume that costs are non-negative. Return the maximum number of consecutive days.","solution":"def max_consecutive_days(costs, budget): Determines the maximum number of consecutive days the campaign can run without the total cost exceeding the budget. Parameters: costs (List[int]): A list of integers representing the cost of the marketing campaign for each day. budget (int): An integer representing the budget. Returns: int: The maximum number of consecutive days. n = len(costs) max_days = 0 current_sum = 0 start = 0 for end in range(n): current_sum += costs[end] while current_sum > budget: current_sum -= costs[start] start += 1 max_days = max(max_days, end - start + 1) return max_days"},{"question":"You are given a **non-empty** array of integers `arr` representing a non-negative integer where each element in the array is a single digit. Write a function to increment the integer by one and return the result as a similar array of digits. The digits are stored in the natural order, meaning the most significant digit is at the beginning of the array. You may assume the integer does not contain any leading zero, except the number 0 itself.","solution":"def increment_integer(arr): Increment the integer represented by the array of digits by one. n = len(arr) # Start from the last digit of the array for i in reversed(range(n)): if arr[i] < 9: arr[i] += 1 return arr arr[i] = 0 # If all digits are 9, we need to add an extra 1 at the beginning return [1] + [0] * n"},{"question":"You are given an integer array `nums` where each integer represents a different type of coin and its value. You are also given an integer `amount` representing a total amount of money. Write a function that computes the minimum number of coins needed to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin. Your solution should have a computational complexity of `O(n * amount)`, where `n` is the number of different coins.","solution":"def coin_change(coins, amount): Given a list of coin denominations and an amount, compute the minimum number of coins needed to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. # Initialize a list to store the minimum number of coins needed for each amount from 0 to amount. dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Iterate over all amounts from 1 to \'amount\'. for i in range(1, amount + 1): # Check each coin. for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) # Return -1 if dp[amount] is still infinity, meaning it\'s impossible to form that amount. # Otherwise, return the minimum number of coins needed for the given amount. return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"You are given a **2D** grid of size `m x n` filled with non-negative integers. Determine if there is a path from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)` such that the sum of the values along the path is **even**. You may only move either down or right at any point in time. Return `true` if such a path exists, otherwise return `false`.","solution":"def is_even_path(grid): m, n = len(grid), len(grid[0]) dp = [[False]*n for _ in range(m)] dp[0][0] = (grid[0][0] % 2 == 0) for i in range(m): for j in range(n): if i > 0: dp[i][j] |= (dp[i-1][j] and (grid[i][j] % 2 == 0)) if j > 0: dp[i][j] |= (dp[i][j-1] and (grid[i][j] % 2 == 0)) return dp[m-1][n-1]"},{"question":"Write a function `int maxProfit(vector<int>& prices, int fee)` that takes as input an array `prices` where `prices[i]` represents the price of a given stock on the `i-th` day, and a non-negative integer `fee` representing a transaction fee. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times), but you need to pay the transaction fee for each transaction. Note that you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Return the maximum profit you can achieve from these transactions.","solution":"def maxProfit(prices, fee): Calculates the maximum profit that can be achieved from the given prices considering the transaction fee. :param prices: List[int] - list of prices on respective days :param fee: int - transaction fee :return: int - maximum profit n = len(prices) if n < 2: return 0 cash = 0 # Profit if we do not have a stock hold = -prices[0] # Profit if we have a stock for i in range(1, n): cash = max(cash, hold + prices[i] - fee) hold = max(hold, cash - prices[i]) return cash"},{"question":"You are given an array of integers `arr` and an integer `k`. Perform exactly `k` operations to maximize the sum of the array. In one operation, you can choose any element of the array and define its new value as `-arr[i]`. Return _the maximum possible sum of the array after exactly_ `k` _operations_.","solution":"def maximize_sum_after_k_operations(arr, k): Performs exactly k operations to maximize the sum of the array. In one operation, we can choose any element and define its new value as -arr[i]. Returns the maximum possible sum of the array after exactly k operations. arr.sort() # Sort the array to make operations on smallest values first for i in range(k): if arr[i % len(arr)] < 0: arr[i % len(arr)] = -arr[i % len(arr)] # Perform operation on the smallest value else: break # If the smallest value is non-negative, no further operations are useful return sum(arr)"},{"question":"Given an array of integers `arr`, find the maximum `k`-length subsequence with the largest sum. A subsequence is a sequence derived by deleting some or no elements from the array without changing the order of the remaining elements. Return _the largest possible sum of such a subsequence_. For example, if the array is `[3, -1, 4, 1, 2]` and `k` is `3`, the return value would be `9` since the subsequence `[3, 4, 2]` has the largest sum among all subsequences of length 3.","solution":"def max_k_length_subsequence(arr, k): Returns the maximum sum of a k-length subsequence with the largest sum. if k <= 0 or not arr or k > len(arr): return 0 # Sort the array in descending order and take the sum of the first k elements sorted_arr = sorted(arr, reverse=True) return sum(sorted_arr[:k])"},{"question":"You are given a string `colors` of length `n`, where each character is either `\'R\'` (red), `\'G\'` (green), or `\'B\'` (blue). The string represents a row of `n` bulbs, and you need to assign a unique integer to each bulb such that no two adjacent bulbs have consecutive integers. Your goal is to find the minimum number of unique integers needed to achieve this assignment. Return _an integer representing the minimum number of unique integers needed_. For example, if `colors = \\"RGBGR\\"`, the minimum number of unique integers needed is `3`. Note that two bulbs are considered adjacent if their positions in the string are consecutive.","solution":"def min_unique_integers(colors): Returns the minimum number of unique integers needed such that no two adjacent bulbs have consecutive integers. n = len(colors) # If the string length is 1, we only need 1 unique integer if n == 1: return 1 # At minimum, we will need three unique integers since we have three colors return 3"},{"question":"A bag contains a large number of different types of candies, where each type of candy has a different sweetness level. You are given an array `candies` of length `n`, where `candies[i]` represents the sweetness level of the `i-th` candy. You are also given an integer `k`, which represents the maximum number of candies you can select. Your goal is to maximize the total sweetness level of the candies selected. Return the **maximum** total sweetness level you can achieve by selecting at most `k` candies. You must solve the problem by using an efficient algorithm for selection.","solution":"def maximize_sweetness(candies, k): Returns the maximum total sweetness level by selecting at most k candies. :param candies: List[int] - List of sweetness levels of each candy. :param k: int - Maximum number of candies that can be selected. :return: int - The maximum total sweetness level. # Sort the candies in descending order based on sweetness level. candies.sort(reverse=True) # Select the top k candies (or less if k is more than available candies) to maximize sweetness. return sum(candies[:k])"},{"question":"You are given an array of integers `nums`, where each integer appears either once or twice. Your task is to find all the integers that appear twice. Return the integers as an array in ascending order. Your solution should have a time complexity of O(n).","solution":"def find_duplicates(nums): Returns the integers that appear twice in the given list nums, sorted in ascending order. num_count = {} duplicates = [] # Count the occurrences of each number for num in nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 # Collect the numbers that appear exactly twice for num, count in num_count.items(): if count == 2: duplicates.append(num) return sorted(duplicates)"},{"question":"Given an integer array `nums`, rearrange the elements such that all negative numbers appear before all positive numbers. Numbers within the same category should maintain their relative order. Implement the rearrangement **in place** and do not return anything. For example, given the array `nums = [-1, 2, -3, 4, 5, -6]`, the array should be rearranged to `[-1, -3, -6, 2, 4, 5]`.","solution":"def rearrange_numbers(nums): This function rearranges the elements of nums such that all negative numbers appear before all positive numbers. Numbers within the same category should maintain their relative order. This function modifies nums in place and returns nothing. negative = [] positive = [] for num in nums: if num < 0: negative.append(num) else: positive.append(num) nums[:] = negative + positive"},{"question":"Given a binary string `s`, a **flip operation** is defined as choosing any subsegment of `s` and toggling all the bits in that subsegment (i.e., changing 0 to 1 and 1 to 0). Return the minimum number of flip operations needed to make the binary string alternating. A binary string is **alternating** if no two adjacent characters are the same. For example, the strings \\"0101\\" and \\"1010\\" are alternating, while \\"0110\\" and \\"1001\\" are not.","solution":"def min_flips_to_alternating(s): Given a binary string s, return the minimum number of flip operations needed to make s alternating. n = len(s) # Define target patterns alt1 = \\"\\".join([\\"0\\" if i % 2 == 0 else \\"1\\" for i in range(n)]) alt2 = \\"\\".join([\\"1\\" if i % 2 == 0 else \\"0\\" for i in range(n)]) # Calculate flips for both patterns flips1 = sum(s[i] != alt1[i] for i in range(n)) flips2 = sum(s[i] != alt2[i] for i in range(n)) # Return the minimum flips needed return min(flips1, flips2)"},{"question":"You are given two arrays `arr1` and `arr2` which represent two sequences of integers. You need to create a new sequence by alternating the elements from `arr1` and `arr2`. If one sequence is longer than the other, append the remaining elements of the longer sequence to the end of the new sequence. Write a function that returns the new sequence.","solution":"def alternate_arrays(arr1, arr2): Creates a new sequence by alternating the elements of arr1 and arr2. If one array is longer, append the remaining elements to the end. result = [] i, j = 0, 0 len1, len2 = len(arr1), len(arr2) while i < len1 and j < len2: result.append(arr1[i]) result.append(arr2[j]) i += 1 j += 1 while i < len1: result.append(arr1[i]) i += 1 while j < len2: result.append(arr2[j]) j += 1 return result"},{"question":"You are given an integer array `arr` and an integer `k`. A subarray is defined as a contiguous segment of the array. Consider the sum of the elements of a subarray to be the score of that subarray. Return _the **kth** largest score of a subarray_. Note that the score of a subarray (i, j) is defined as the sum of `arr[i] + arr[i + 1] + ... + arr[j]`.","solution":"import heapq def kthLargestSum(arr, k): Returns the kth largest sum of a subarray. n = len(arr) # Create a min heap to store the k largest sums min_heap = [] # Traverse through the array and compute subarray sums for start in range(n): subarray_sum = 0 for end in range(start, n): subarray_sum += arr[end] # If the heap has less than k elements, push the current sum if len(min_heap) < k: heapq.heappush(min_heap, subarray_sum) # If the heap is full and current sum is larger than the smallest sum in the heap, replace the smallest sum elif subarray_sum > min_heap[0]: heapq.heapreplace(min_heap, subarray_sum) # The top element of the heap is the kth largest sum return min_heap[0]"},{"question":"You are given a linked list where each node contains an integer value. Design a function, `removeConsecutiveSumToZero(head)`, which removes consecutive sequences of nodes that sum up to zero from the linked list. The function should return the head of the modified linked list. For example, consider the linked list: `1 -> 2 -> -3 -> 3 -> 1`. The resulting linked list after removing sequences that sum to zero would be: `3 -> 1`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeConsecutiveSumToZero(head): Remove consecutive sequences of nodes that sum up to zero from the linked list. dummy = ListNode(0) dummy.next = head prefix_sum = 0 sum_map = {0: dummy} current = head while current: prefix_sum += current.val if prefix_sum in sum_map: prev = sum_map[prefix_sum] sum_val_check = prefix_sum node = prev.next while node != current.next: sum_val_check += node.val if node != current: sum_map.pop(sum_val_check, None) node = node.next prev.next = current.next else: sum_map[prefix_sum] = current current = current.next return dummy.next"},{"question":"You are given a matrix represented by a two-dimensional array `grid` of size `m x n`, where each cell contains a non-negative integer. You are also given an integer `k`. Starting from the top-left cell, you need to find a path to the bottom-right cell where you can only move **right** or **down**. A path\'s \\"sum modulo `k`\\" is defined as the sum of all integers along the path taken, modulo `k`. Return the maximum possible \\"sum modulo `k`\\" achievable by any path from the top-left cell to the bottom-right cell. For example, given the grid `[[1,3,2],[4,2,5],[7,1,6]]` and `k = 5`, possible paths and their sum mod `k` are as follows: - Path `1 -> 3 -> 2 -> 5 -> 6` has a sum of `17`, which gives `2` when taken mod `k = 5`. - Path `1 -> 4 -> 7 -> 1 -> 6` has a sum of `19`, which gives `4` when taken mod `k = 5`. Thus, the maximum possible sum modulo `5` is `4`, and this should be returned.","solution":"def max_path_sum_mod_k(grid, k): m, n = len(grid), len(grid[0]) dp = [[None] * n for _ in range(m)] dp[0][0] = [grid[0][0] % k] for i in range(m): for j in range(n): if i == 0 and j == 0: continue current_values = set() if i > 0: for value in dp[i - 1][j]: current_values.add((value + grid[i][j]) % k) if j > 0: for value in dp[i][j - 1]: current_values.add((value + grid[i][j]) % k) dp[i][j] = list(current_values) return max(dp[-1][-1])"},{"question":"You are given an integer `n`. You need to construct an array `arr` of length `n` such that: - Each element in `arr` is a unique integer between `1` and `2n` (inclusive). - The absolute difference between any two consecutive elements should be distinct. Return the array `arr`. If there are multiple possible arrays, return any of them. If no such array exists, return an empty array.","solution":"def construct_array(n): if n == 0: return [] if n == 1: return [1] arr = [] left, right = 1, 2 * n for i in range(n): if i % 2 == 0: arr.append(left) left += 1 else: arr.append(right) right -= 1 return arr"},{"question":"You are given a string `s` which consists of only lowercase letters. You need to return the longest palindrome that can be built with the letters of `s`. Letters can be rearranged, but a character can appear in the palindrome at most as many times as it appears in `s`. If there are multiple solutions, you can return any of them.","solution":"from collections import Counter def longest_palindrome(s): Returns the length of the longest palindrome that can be built with the letters of `s`. char_counts = Counter(s) length = 0 odd_found = False for count in char_counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"Given an integer array `arr` of size `n`, you need to determine the maximum product of any three distinct elements in the array. If the array has fewer than three elements, return 0. The product may be extremely large, so consider potential integer overflow in your calculations. Return the maximum product as an integer.","solution":"import heapq def max_product_of_three(arr): Returns the maximum product of any three distinct elements in the array. If the array has fewer than three elements, return 0. n = len(arr) if n < 3: return 0 # Find the three largest numbers and the two smallest numbers three_largest = heapq.nlargest(3, arr) two_smallest = heapq.nsmallest(2, arr) # The maximum product of three numbers can be one of these two: # 1. Product of the three largest numbers # 2. Product of the two smallest numbers and the largest number (in case we have two large negative numbers) max_product = max(three_largest[0] * three_largest[1] * three_largest[2], two_smallest[0] * two_smallest[1] * three_largest[0]) return max_product"},{"question":"You are given a grid consisting of `m` rows and `n` columns, where each cell contains an integer representing the cost to travel through that cell. You need to find the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move to the right or down from any cell in the grid. Implement a function to calculate the minimum cost. * ```python def minPathCost(grid: List[List[int]]) -> int: ```","solution":"from typing import List def minPathCost(grid: List[List[int]]) -> int: Returns the minimum cost path from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"You are given a **0-indexed** 2D integer array `flights` where `flights[i] = [src, dst, cost]` indicates that there is a flight from city `src` to city `dst` with a cost of `cost`. You are also given an integer `n` representing the number of cities, and two integers `start` and `k`. You need to find the cheapest price from city `start` to all other cities with a maximum of `k` stops. Return an integer array where the `i-th` element is the minimum cost to reach city `i` from city `start` with at most `k` stops. If city `i` is not reachable within `k` stops, the value should be `-1`.","solution":"from heapq import heappop, heappush import sys def find_cheapest_price(n, flights, start, k): Returns the minimum cost to reach each city from city `start` with at most `k` stops. # Building the graph graph = {i: [] for i in range(n)} for src, dst, cost in flights: graph[src].append((dst, cost)) # Priority Queue to keep track of (cost, current_node, stops) pq = [(0, start, 0)] # Costs array to store minimum costs min_costs = [float(\'inf\')] * n min_costs[start] = 0 while pq: curr_cost, curr_node, stops = heappop(pq) if stops > k: continue for neighbor, price in graph[curr_node]: new_cost = curr_cost + price if new_cost < min_costs[neighbor]: min_costs[neighbor] = new_cost heappush(pq, (new_cost, neighbor, stops + 1)) return [cost if cost != float(\'inf\') else -1 for cost in min_costs]"},{"question":"Given an array `heights` representing the height of buildings along a street, return _an array representing the **skyline** of these buildings_, where each element in the returned array contains three integers `[left, height, right]` representing the position of the left edge, the height at that edge, and the position of the right edge of each building. The **skyline** should be represented as a series of rectangles that outline the union of the buildings in silhouette. Two buildings can overlap and form a continuous structure. The input will contain at least one building.","solution":"import heapq def get_skyline(buildings): Returns the skyline formed by \'buildings\'. The skyline is a list of triplets [left, height, right]. # Define a list to hold all events (start and end of buildings) events = [] for left, right, height in buildings: events.append((left, -height, right)) # Building starting event events.append((right, 0, 0)) # Building ending event # Sort events by position; start events before end events if they are the same position events.sort() # Result array to hold the skyline result = [] # Max-Heap to keep track of building heights and their end points heap = [(0, float(\'inf\'))] # (height, end) for x, h, r in events: # Remove the buildings from the heap that are ended before current x position while heap[0][1] <= x: heapq.heappop(heap) if h != 0: heapq.heappush(heap, (h, r)) max_height = -heap[0][0] # If the highest building changes, this is a critical point if not result or result[-1][1] != max_height: result.append([x, max_height]) return result"},{"question":"You are given a `rows x cols` binary matrix filled with `0`s and `1`s. A **rectangle** is a portion of the matrix where all elements are `1`. A rectangle can have any size, but the width and height of the rectangle must be at least 1. Implement a function `maximalRectangle` that finds the **area** of the largest rectangle containing only `1`s in the given matrix and returns its area. For example, given the following matrix: ``` [ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ] ``` The largest rectangle containing only `1`s has an area of `6`.","solution":"def maximalRectangle(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (cols + 1) for row in range(rows): for col in range(cols): if matrix[row][col] == \'1\': heights[col] += 1 else: heights[col] = 0 stack = [-1] for i in range(cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"Given a string `s` and an integer array `indices` of the same length, where `indices[i]` represents the position to which the character `s[i]` should be moved, return _the shuffled string_.","solution":"def shuffle_string(s, indices): Shuffles the string s according to the indices array. Parameters: s (str): The input string to be shuffled. indices (list of int): The list of indices that represents the new positions of the characters. Returns: str: The shuffled string. shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"You are given a **0-indexed** integer array `nums` representing the initial conditions of a line of houses. Each element in the array represents the amount of money stored in that house. On one special night, a thief plans to rob the houses along that street. However, the thief cannot rob two adjacent houses because security alarms connected to adjacent houses will trigger each other. Write a function that returns the **maximum amount of money** the thief can rob without triggering the alarms. Your function should ensure that the amount of money robbed is the highest possible while following the adjacent-robbery restriction.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering alarms from adjacent houses. Parameters: nums (list): A list of integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] # Dynamic programming approach n = len(nums) dp = [0] * n dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]) return dp[-1]"},{"question":"Write a function that takes a list of non-negative integers representing the amount of rainwater at different elevations on a terrain. The function should compute the maximum amount of rainwater that can be trapped between the elevations after raining. Return the maximum amount of water that can be trapped. For example, given the list `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the function should return `6`.","solution":"def trap(height): Computes the maximum amount of trapped rainwater. Args: height (List[int]): A list of non-negative integers representing the elevation map. Returns: int: The maximum amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a list of `n` integers representing the heights of `n` buildings, each building being located at the unit distance from the next one. The goal is to select and remove some buildings such that the remaining buildings\' heights form a strictly increasing sequence. However, you can only remove at most `k` buildings. Return _the maximum number of buildings that can be retained with their heights forming a strictly increasing sequence_. Hints: Use dynamic programming or persistence segment tree for this problem to handle the constraints efficiently within given limits.","solution":"def max_increasing_buildings(heights, k): Returns the maximum number of buildings that can be retained such that their heights form a strictly increasing sequence by removing at most k buildings. from bisect import bisect_left n = len(heights) dp = [1] * n # Compute lengths of the longest increasing subsequences ending at each position using dynamic programming for i in range(n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) max_len_array = max(dp) max_kept_buildings = 0 for i in range(n): retained_buildings = [heights[i]] current_removal = 0 for j in range(i + 1, n): if heights[j] > retained_buildings[-1]: retained_buildings.append(heights[j]) else: current_removal += 1 if current_removal > k: break if current_removal <= k: max_kept_buildings = max(max_kept_buildings, len(retained_buildings)) return max_kept_buildings"},{"question":"You are given an array of strings `operations` where each string represents an operation on an initially empty stack. The operations are as follows: - `\\"Push X\\"`: Push the integer `X` onto the stack. - `\\"Pop\\"`: Remove the element on the top of the stack. - `\\"Top\\"`: Get the element on the top of the stack. Return the results of the `Top` operations in the order they were called. If an operation is not possible (e.g., \\"Pop\\" or \\"Top\\" on an empty stack), ignore that operation. Example input: ``` operations = [\\"Push 1\\", \\"Push 2\\", \\"Top\\", \\"Pop\\", \\"Top\\"] ``` Example output: ``` [2, 1] ```","solution":"def process_operations(operations): Processes a list of stack operations and returns the results of \'Top\' operations. Args: operations (list of str): List of stack operations in the format \'Push X\', \'Pop\', \'Top\'. Returns: list: Results of \'Top\' operations in the order they were called. stack = [] result = [] for operation in operations: if operation.startswith(\\"Push\\"): _, value = operation.split() stack.append(int(value)) elif operation == \\"Pop\\": if stack: stack.pop() elif operation == \\"Top\\": if stack: result.append(stack[-1]) return result"},{"question":"A **matrix diagonal traversal** is a traversal along the diagonals of a matrix from the bottom-left to the top-right. In such a traversal, you start from the bottom-left element and repeatedly move towards the top-right, visiting all elements along each diagonal, until you reach the top-right element. For example, the traversal of a `3x3` matrix begins with the bottom-left element, then moves to the elements at `(2,1)` and `(1,2)`, and so on. Given a `m x n` matrix, return the elements of the matrix in diagonal traversal order. Adjust the implementation to handle matrices of varying sizes robustly.","solution":"def diagonal_traversal(matrix): Returns the elements of the matrix in diagonal traversal order. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of int: A list containing the elements of the matrix in diagonal traversal order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for d in range(m + n - 1): if d < m: row = m - 1 - d col = 0 else: row = 0 col = d - m + 1 diagonal = [] while row < m and col < n: diagonal.append(matrix[row][col]) row += 1 col += 1 result.extend(diagonal) return result"},{"question":"Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example: ``` Input: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. ``` Constraints: * `2 <= nums.length <= 10^4` * `-10^9 <= nums[i] <= 10^9` * `-10^9 <= target <= 10^9` * Only one valid answer exists.","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. :param nums: List[int] :param target: int :return: List[int] num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"You are given a **0-indexed** integer array `nums` which contains positive integers. Determine if there exist two distinct indices `i` and `j` such that `nums[i]` is a multiple of `nums[j]` (that is, `nums[i] % nums[j] == 0`). Return `true` if there exist such indices, otherwise return `false`.","solution":"def contains_multiple(nums): Determine if there exist two distinct indices i and j such that nums[i] is a multiple of nums[j]. :param nums: List[int] - a list of positive integers :return: bool - True if there exist the indices i and j, otherwise False length = len(nums) for i in range(length): for j in range(length): if i != j and nums[i] % nums[j] == 0: return True return False"},{"question":"Implement a function to perform **stack-based string manipulation** with the following operations: * `void push(char c)`: Pushes the character `c` onto the stack. * `char pop()`: Removes and returns the character on the top of the stack. If the stack is empty, return `\'0\'`. * `String getCurrentState()`: Returns the current string representation of the stack with all characters in the order they were pushed. * `String reverse()`: Reverses the characters in the stack and returns the reversed string without modifying the current state of the stack. You need to implement the class `StringStack` containing the above functions to manage the stack and perform these operations effectively. The initial stack should be empty.","solution":"class StringStack: def __init__(self): self.stack = [] def push(self, c): Pushes the character `c` onto the stack. self.stack.append(c) def pop(self): Removes and returns the character on the top of the stack. If the stack is empty, returns `\'0\'`. if self.stack: return self.stack.pop() return \'0\' def getCurrentState(self): Returns the current string representation of the stack with all characters in the order they were pushed. return \'\'.join(self.stack) def reverse(self): Reverses the characters in the stack and returns the reversed string without modifying the current state of the stack. return \'\'.join(reversed(self.stack))"},{"question":"You are given a class `Book` that represent a book in a library. Each book has a unique `bookId` and a string `title`. Implement the `Library` class which handles the operations of adding a book, removing a book, and searching for a book. Implement the `Library` class: * `Library()` Initializes the object. * `void addBook(int bookId, String title)` Adds a book with the given `bookId` and `title` to the library. * `void removeBook(int bookId)` Removes the book with the given `bookId` from the library. * `String searchBook(String title)` Returns a list of `bookId`s for books in the library whose title contains the given `title` string as a substring, in ascending order. If no such book is found, returns an empty list. **Follow up:** How would you optimize the search operation if the number of books in the library is very large?","solution":"class Book: def __init__(self, bookId, title): self.bookId = bookId self.title = title class Library: def __init__(self): self.books = {} def addBook(self, bookId, title): if bookId not in self.books: self.books[bookId] = Book(bookId, title) def removeBook(self, bookId): if bookId in self.books: del self.books[bookId] def searchBook(self, title): result = [bookId for bookId, book in self.books.items() if title in book.title] return sorted(result)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings, where `heights[i]` is the height of the `i-th` building. An observer is standing on the rooftop of the building at index `0`. From this rooftop, the observer can see another building if all the buildings between the observer and that building are of lesser height than that building. Return the list of indices of the buildings that the observer can see from rooftop `0`. The list should be in ascending order of indices.","solution":"def can_see_buildings(heights): Returns the indices of buildings that can be seen from the rooftop of the building at index 0. parameters: heights (List[int]): Height of buildings returns: List[int]: Indices of buildings that can be seen visible_buildings = [] max_height = heights[0] for i in range(1, len(heights)): if heights[i] > max_height: visible_buildings.append(i) max_height = heights[i] return visible_buildings"},{"question":"Given an array `points` where each `points[i] = [xi, yi]` represents a point on the Cartesian plane. Determine whether there exists a subset of points that can form a straight line. Return `true` if such a subset exists, and `false` otherwise. Each point is unique and the subset should contain at least 2 points.","solution":"def check_straight_line(points): Determine whether there exists a subset of points in the given array that can form a straight line. :param points: List of points, where each point is a list with x and y coordinates. :return: Boolean indicated if a subset of points can form a straight line. if len(points) < 2: return False # Calculate the initial slope between the first two points (x0, y0), (x1, y1) = points[0], points[1] dx = x1 - x0 dy = y1 - y0 for i in range(2, len(points)): x, y = points[i] # Compare the slope of current point with the first segment if dx * (y - y0) != dy * (x - x0): return False return True"},{"question":"Given a string `s` consisting of lowercase letters, arrange the characters of the string such that all occurrences of each character appear together. Return any valid arrangement of the string. For example, given `s = \\"aaabbcccc\\"`, one possible result could be `\\"aaabbbcccc\\"`. If there are multiple valid answers, return any of them.","solution":"from collections import defaultdict def arrange_characters_together(s): Arrange the characters of the string such that all occurrences of each character appear together. Parameters: - s (str): Input string consisting of lowercase letters Returns: - str: A string where all occurrences of each character appear together char_count = defaultdict(int) for char in s: char_count[char] += 1 result = [] for char, count in char_count.items(): result.append(char * count) return \'\'.join(result)"},{"question":"You are given two strings `s1` and `s2` of length `n` consisting of lowercase alphabets. You may perform the following operation on either of the strings any number of times: choose any two adjacent characters and swap them. Return `true` if you can transform `s1` into `s2` by performing any number of swaps, otherwise return `false`.","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by performing any number of adjacent swaps. Args: s1 (str): the first string. s2 (str): the second string. Returns: bool: True if s1 can be transformed into s2, otherwise False. return sorted(s1) == sorted(s2)"},{"question":"You are given an array of integers `heights` representing a queue of students standing in line. The students are ordered by the rule that a shorter student must stand behind a taller or equally tall student. Write a function to determine the minimum number of students that must be removed from the queue so that the remaining students are standing in non-decreasing order of height. Return the number of students that should be removed.","solution":"def min_students_to_remove(heights): Determines the minimum number of students to remove so that the remaining students are in non-decreasing order of height. :param heights: List[int] - the list of students\' heights in the queue :return: int - the minimum number of students to remove def lis_length(sequence): if not sequence: return 0 # Create an array to store the length of the longest increasing subsequence ending at each index dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] >= sequence[j]: dp[i] = max(dp[i], dp[j] + 1) # Find the maximum value in dp return max(dp) # Length of the longest non-decreasing subsequence longest_non_decreasing_subseq_len = lis_length(heights) # The minimum number of students to remove return len(heights) - longest_non_decreasing_subseq_len"},{"question":"A company\'s employee records are stored in a binary tree where each node represents an employee with a unique id, and each node can have up to two child nodes representing direct reports. The structure of the tree follows the manager-subordinate hierarchy, with the root node being the CEO. You are given the `root` of this binary tree and an integer `employee_id`. Write a function that, given the `root` of the tree and the `employee_id`, returns a list of ids representing the path from the root (CEO) to the specified employee. If the employee is not found within the company tree, return an empty list. The function signature is: ```python def find_path_to_employee(root: TreeNode, employee_id: int) -> List[int]: ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, id: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.id = id self.left = left self.right = right def find_path_to_employee(root: TreeNode, employee_id: int) -> List[int]: def find_path(node: TreeNode, employee_id: int, path: List[int]) -> bool: if node is None: return False path.append(node.id) if node.id == employee_id: return True if (find_path(node.left, employee_id, path) or find_path(node.right, employee_id, path)): return True path.pop() return False path = [] if find_path(root, employee_id, path): return path else: return []"},{"question":"You are given two integer arrays `startTime` and `endTime`, and an integer array `profit` where `startTime[i]`, `endTime[i]`, and `profit[i]` denote the start time, end time, and profit of the `i-th` job respectively. You are also given an integer `maxEndTime`, which denotes the maximum end time of any job you are allowed to take. Your task is to find the maximum profit you can achieve if you are only able to perform non-overlapping jobs within the given end time constraint. Note that you can perform multiple jobs as long as they do not overlap, and their end time does not exceed `maxEndTime`. Return the maximum profit you can achieve.","solution":"def job_scheduling(startTime, endTime, profit, maxEndTime): Returns the maximum profit achievable by selecting non-overlapping jobs within the given end time constraint. n = len(startTime) jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) dp = [0] * (maxEndTime + 1) for i in range(n): for t in range(maxEndTime, jobs[i][1] - 1, -1): if t >= jobs[i][1]: dp[t] = max(dp[t], dp[jobs[i][0]] + jobs[i][2]) return max(dp)"},{"question":"You are given a **0-indexed** array of integers `nums`. In one operation, you can **move** all elements of the array one position to the right, with the last element moving to the first position. Determine the minimum number of operations required so that the array `nums` becomes **non-decreasing**. Return _the minimum number of operations needed or `-1` if it is not possible_.","solution":"def min_operations_to_non_decreasing(nums): Determines the minimum number of operations required to make the array non-decreasing by rotating the array elements. If it\'s not possible, returns -1. def is_non_decreasing(arr): Helper function to check if an array is non-decreasing. for i in range(1, len(arr)): if arr[i] < arr[i - 1]: return False return True n = len(nums) for k in range(n): if is_non_decreasing(nums[k:] + nums[:k]): return k return -1"},{"question":"You are given a list of integers `arr` representing the heights of a row of buildings. Starting from the leftmost building, you want to find the maximum number of buildings you can see. A building is **blocked** if there is another building taller or of equal height in front of it when moving from the left to the right. Return _the maximum number of buildings visible from the leftmost building_.","solution":"def max_visible_buildings(arr): Returns the maximum number of buildings visible from the leftmost building. Parameters: arr (List[int]): A list of integers representing the heights of buildings. Returns: int: The maximum number of buildings visible from the leftmost building. if not arr: return 0 visible_count = 1 max_height = arr[0] for height in arr[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"Given a balanced binary search tree (BST) with `n` nodes, perform an in-order traversal and return the `k`-th smallest element in the BST. You are given the root of the BST and an integer `k`, where `1 <= k <= n`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Perform in-order traversal and return the k-th smallest element in the BST. def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) in_order_list = in_order_traversal(root) return in_order_list[k-1]"},{"question":"You are given an array `heights` representing the heights of buildings in a cityscape (with an assumed 1-unit width per building). Write a function that returns the **maximum rectangle area** that can be formed using the buildings. The rectangle must be aligned along the buildings and utilize the height of the buildings in the array. The input for the function is a single list of integers `heights`, where each integer represents the height of a building. Your task is to find the largest rectangular area possible by selecting any number of contiguous buildings represented by heights in the array.","solution":"def largest_rectangle_area(heights): Function to calculate the largest rectangle area in a histogram. stack = [] max_area = 0 heights.append(0) # Append a zero to handle the end boundaries for i, h in enumerate(heights): while stack and heights[stack[-1]] >= h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() # Restore the original heights array return max_area"},{"question":"Given a list of `n` integers, a \\"peak\\" element is an element that is strictly greater than its neighbors. Write a program to find a peak element in the list. If the list contains multiple peaks, return the index of any one of the peak elements. The input list will always contain at least one peak element. The algorithm should have a time complexity of O(log n).","solution":"def find_peak_element(nums): Finds any peak element\'s index in the list `nums`. A peak element is defined as an element that is strictly greater than its neighbors. :param nums: List[int] - list of integers :return: int - index of any one peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"You are given an array `nums` of integers, where `nums[i]` represents the position of the `i`-th person in a line. Each person can only move to a position such that the distance between the person\'s original and new positions is at most `k` units. Calculate the minimum number of moves required to sort the array in non-decreasing order. Each move consists of a person swapping their position with an adjacent person. Return _the minimum number of moves required to sort the array_.","solution":"def count_inversions_and_sort(nums): if len(nums) < 2: return nums, 0 mid = len(nums) // 2 left, left_inversions = count_inversions_and_sort(nums[:mid]) right, right_inversions = count_inversions_and_sort(nums[mid:]) merged, split_inversions = merge_and_count(left, right) total_inversions = left_inversions + right_inversions + split_inversions return merged, total_inversions def merge_and_count(left, right): merged = [] inversions = 0 i = 0 j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 inversions += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, inversions def min_moves_to_sort(nums, k): # We just find the number of inversions here _, inversions = count_inversions_and_sort(nums) return inversions"},{"question":"You are given an array of integers `arr` where `arr[i]` represents the elevation of the `i`-th position along a hiking path. The rain water can be trapped between different elevations. Your task is to calculate the total unit of water that can be trapped after a rain. Return the total amount of trapped water. Example: - Input: arr = [0,1,0,2,1,0,1,3,2,1,2,1] - Output: 6","solution":"def trap_water(arr): Calculate the total units of water that can be trapped after a rain. Parameters: arr (list): List of integers representing elevation. Returns: int: Total units of trapped water. if len(arr) == 0: return 0 left_max = [0] * len(arr) right_max = [0] * len(arr) left_max[0] = arr[0] for i in range(1, len(arr)): left_max[i] = max(left_max[i-1], arr[i]) right_max[-1] = arr[-1] for i in range(len(arr) - 2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) water_trapped = 0 for i in range(len(arr)): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"Given a **non-negative** integer `n`, return _the number of steps required to reduce `n` to zero_. In one step, you can either subtract `1` from `n` if `n` is odd, or divide `n` by `2` if `n` is even.","solution":"def number_of_steps(n): Returns the number of steps required to reduce n to zero. In one step, if n is odd, subtract 1; if n is even, divide by 2. steps = 0 while n > 0: if n % 2 == 0: n //= 2 else: n -= 1 steps += 1 return steps"},{"question":"Given a list of `nums` representing integers, write a function that divides these integers into two parts: the smallest `k` integers and the rest. Rearrange these two parts such that the smallest `k` integers are at the beginning, and the rest of the integers are at the end. Return the rearranged list. The order of integers within each part should be preserved. For example, given `nums = [3, 1, 4, 1, 5, 9, 2]` and `k = 3`, the result should be `[1, 1, 2, 3, 4, 5, 9]`.","solution":"def rearrange_list(nums, k): Rearranges the list such that the smallest k integers are at the beginning, and the rest of the integers are at the end. The order within the parts is preserved. :param nums: List of integers to be rearranged. :param k: Number of smallest integers to place at the beginning. :return: Rearranged list of integers. if k >= len(nums): return sorted(nums) sorted_nums = sorted(nums) smallest_k = sorted_nums[:k] remaining = sorted_nums[k:] result = smallest_k + remaining return result"},{"question":"You are given a **directed graph** with `n` nodes labeled from `0` to `n-1` and an array `edges` where each `edges[i] = [u_i, v_i]` represents a directed edge from node `u_i` to node `v_i`. In this graph, each node can point to itself using a self-loop. A **path **in the graph is a sequence of nodes where each consecutive pair of nodes is connected by a directed edge. A **cycle** in the graph is a path that starts and ends at the same node, with at least one edge. Return _the longest cycle in the graph as a list of node labels forming the cycle_. If there are multiple longest cycles, return any of them. If there is no cycle, return an empty list.","solution":"def longest_cycle(n, edges): Finds the longest cycle in a directed graph. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of directed edges where each edge is represented by a pair [u, v]. Returns: List[int]: The longest cycle in the graph as a list of node labels. If there is no cycle, returns an empty list. from collections import defaultdict, deque def find_cycle(graph, start_node): stack = [] visited = set() current_path = set() path_index_map = {} def dfs(node): if node in visited: if node in current_path: cycle_start_index = path_index_map[node] return stack[cycle_start_index:] if cycle_start_index < len(stack) else None return None visited.add(node) current_path.add(node) stack.append(node) path_index_map[node] = len(stack) - 1 for neighbor in graph[node]: cycle = dfs(neighbor) if cycle: return cycle stack.pop() current_path.remove(node) return None return dfs(start_node) # Build the graph from the edges list graph = defaultdict(list) for u, v in edges: graph[u].append(v) max_cycle = [] for i in range(n): cycle = find_cycle(graph, i) if cycle and len(cycle) > len(max_cycle): max_cycle = cycle return max_cycle"},{"question":"A theme park has `n` rides, each offering a different level of thrill. The level of thrill for each ride is represented by an integer array `thrill` where `thrill[i]` is the thrill level of the `i-th` ride. A customer has a certain tolerance to thrill levels, given by an integer `thrillTolerance`. Each customer plans to go on as many rides as possible without the cumulative thrill level exceeding their `thrillTolerance`. Implement the `Customer` class: * `Customer(int thrillTolerance)` Initializes the object with the customer\'s `thrillTolerance`. * `int getMaxRides(int[] thrill)` Returns the maximum number of rides the customer can enjoy without exceeding their thrill tolerance. The rides must be taken in the order they appear in the `thrill` array, and a ride is not taken if the cumulative thrill level exceeds the tolerance.","solution":"class Customer: def __init__(self, thrillTolerance): self.thrillTolerance = thrillTolerance def getMaxRides(self, thrill): Returns the maximum number of rides the customer can enjoy without exceeding their thrill tolerance. Args: thrill (list of int): List of thrill levels for each ride. Returns: int: Maximum number of rides the customer can take. total_thrill = 0 rides_count = 0 for ride_thrill in thrill: if total_thrill + ride_thrill <= self.thrillTolerance: total_thrill += ride_thrill rides_count += 1 else: break return rides_count"},{"question":"You are given a string `s` and an array of strings `words`. Determine if it is possible to form the string `s` by concatenating words from the `words` array in any order. Each word in the `words` array can be used multiple times. Return `true` if it is possible to form the string `s` and `false` otherwise.","solution":"def can_form_string(s, words): Determine if it is possible to form the string `s` by concatenating words from the `words` array in any order. Each word in the `words` array can be used multiple times. from collections import Counter, deque def can_construct(s, word_dict): queue = deque([s]) while queue: current = queue.popleft() if current == \\"\\": return True for word in words: if current.startswith(word): next_state = current[len(word):] if next_state not in word_dict: queue.append(next_state) word_dict[next_state] = True return False word_dict = {} return can_construct(s, word_dict)"},{"question":"You are given an array of integers `nums`, and you are tasked with arranging the numbers into the smallest possible number. For instance, given an array `[3, 30, 34, 5, 9]`, return the integer `3033459`. The result should also be returned as a string. Write a function `smallestNumber(nums)` that returns this smallest number formed by the integers in the array. Note: The result may contain leading zeros, but it should still be considered as a valid number in string format (e.g., \\"000\\" is valid).","solution":"from functools import cmp_to_key def smallestNumber(nums): Returns the smallest possible number formed by arranging the integers in the array `nums`. def compare(a, b): if a + b < b + a: return -1 elif a + b > b + a: return 1 else: return 0 # Convert each number to a string str_nums = list(map(str, nums)) # Sort numbers based on their string comparison str_nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers result = \'\'.join(str_nums) # Remove leading zeros return result if result[0] != \'0\' else \'0\'"},{"question":"You are given an array of `n` integers called `weights`, where `weights[i]` represents the weight of the `i-th` item. Your task is to divide these items into two subsets, such that the difference between the sum of weights in the two subsets is minimized. Return the minimized difference. For example, given an array `weights = [1, 6, 11, 5]`, the output should be `1`. This is because we can split the array into subsets `[1, 6, 5]` and `[11]`, where the difference between the sum of weights (12 - 11) is 1. Note that there could be multiple valid split solutions, but the goal is to find the smallest possible difference.","solution":"def find_min_difference(weights): This function returns the minimized difference between the sums of two subsets of the given weights. total_sum = sum(weights) n = len(weights) target = total_sum // 2 # dp[i] will be True if a sum i can be formed with the subset of weights dp = [False] * (target + 1) dp[0] = True # Update the dp array with weights for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(target, -1, -1): if dp[i]: return abs(total_sum - 2 * i)"},{"question":"A company is planning to enhance its internal communication system by implementing a hierarchical organizational chart. You are given `n` employees labeled from `0` to `n-1`, and a list of `manager` relationships where `manager[i]` is the immediate manager of employee `i`. If employee `i` does not have a manager, `manager[i]` is `-1`. The company wants to establish a method to send messages up the chain of command until it reaches the highest authority (an employee with no manager). Write a function that takes in the list `manager` and returns the time it takes for the message to reach the highest authority. The transmission of a message from one employee to their manager takes a constant time of `1` unit. Your function should return the maximum time it will take for any employee\'s message to reach the highest authority.","solution":"def time_to_reach_highest_authority(manager): Returns the maximum time it will take for any employee\'s message to reach the highest authority. n = len(manager) memo = [-1] * n # memo[i] will store the time to reach the highest authority from employee i def dfs(emp): if manager[emp] == -1: # if employee has no manager return 0 if memo[emp] != -1: # if already computed return memo[emp] memo[emp] = 1 + dfs(manager[emp]) return memo[emp] max_time = 0 for emp in range(n): max_time = max(max_time, dfs(emp)) return max_time"},{"question":"You are given an integer array `heights` representing the heights of skyscrapers in a city. Each skyscraper blocks the view of the buildings that are behind it and shorter than or equal to it in height. The goal is to determine the number of buildings that each skyscraper blocks. Specifically, for each skyscraper `i` in the array `heights`, a skyscraper `j` is said to be blocked by `i` if `j` appears after `i` in the array and `heights[j] <= heights[i]`. Return an array of the same length where each element contains the number of skyscrapers blocked by the respective skyscraper in `heights`.","solution":"def blocked_skyscrapers(heights): Returns an array of the number of skyscrapers blocked by each respective skyscraper in the heights array. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] <= heights[i]: count += 1 else: break result[i] = count return result"},{"question":"You are given an `n x n` matrix representing a 2D grid of rooms, where `-1` represents a wall or an obstacle, `0` represents a gate, and `inf` represents an empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be left as `inf`. The distance is defined as the number of steps you must take to reach the gate. Write a function that updates the given 2D grid `rooms` with the distances to the nearest gate. You may assume `inf` is a large enough number such that it represents infinity.","solution":"def walls_and_gates(rooms): if not rooms or not rooms[0]: return from collections import deque INF = float(\'inf\') rows, cols = len(rooms), len(rooms[0]) queue = deque() for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and rooms[nr][nc] == INF: rooms[nr][nc] = rooms[r][c] + 1 queue.append((nr, nc))"},{"question":"You are given a maze represented by a 2D grid where a cell is either a wall (denoted by `1`) or a free space (denoted by `0`). You can start at any free space in the grid. Determine whether you can reach the last row of the grid by only moving up, down, left, or right through the free spaces. Write a function: ```python def can_reach_last_row(grid: List[List[int]]) -> bool: # Your code here ``` where: - `grid` is a list of lists of integers representing the maze (2D grid) with `0` and `1`. Return `True` if it is possible to reach any cell in the last row from any starting free space in the grid, otherwise return `False`.","solution":"from typing import List def can_reach_last_row(grid: List[List[int]]) -> bool: def dfs(x, y): if x == len(grid) - 1: # Reached last row return True visited[x][y] = True # Directions: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and grid[new_x][new_y] == 0 and not visited[new_x][new_y]: if dfs(new_x, new_y): return True return False for i in range(len(grid[0])): if grid[0][i] == 0: # Start from every free space in the first row visited = [[False] * len(grid[0]) for _ in range(len(grid))] if dfs(0, i): return True return False"},{"question":"Given an integer `n`, return the number of ways to climb a staircase of `n` steps, where each time you can either climb 1 or 2 steps. Implement a function `int climbStairs(int n)` that computes and returns this number.","solution":"def climbStairs(n): Returns the number of ways to climb a staircase of n steps, where each time you can either climb 1 or 2 steps. if n <= 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"Given an integer array `arr`, return the length of the longest increasing subsequence (LIS) in the array. A subsequence is a sequence that can be derived by deleting some or no elements (without changing the order of the remaining elements). Your solution should have a time complexity better than `O(n^2)`.","solution":"import bisect def length_of_lis(arr): Returns the length of the longest increasing subsequence in the array arr. if not arr: return 0 lis = [] for num in arr: pos = bisect.bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"You are provided with a 2D grid of integers representing a map of land and water, where `1` represents land, and `0` represents water. Your task is to find the **size of the largest island** (connected group of `1`s) in the grid. You may assume that all four neighboring cells (up, down, left, right) are connected. Implement the following method: * `int largestIsland(int[][] grid)`: returns the size of the largest island in the grid. For example: ``` Input: grid = [[1, 0, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 0, 1, 1]] Output: 4 ```","solution":"def largestIsland(grid): Finds the size of the largest island in the grid. An island is a group of 1s connected vertically or horizontally. Parameters: grid (list of list of int): 2D grid representing the map of land (1) and water (0) Returns: int: The size of the largest island def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != 1: return 0 grid[x][y] = -1 # Mark the cell as visited size = 1 size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"Given an array of integers `arr`, a \\"peak\\" element is an element that is strictly greater than its neighbors. An array element is defined as a peak if it is greater than the next element and the previous element. Given such an array, return _the index of any one of its peak elements._","solution":"def find_peak_element(arr): Returns the index of any one peak element in the array. A peak element is an element that is greater than its neighbors. if not arr: return -1 # to handle empty input list n = len(arr) if n == 1: return 0 # the only element is the peak if arr[0] > arr[1]: return 0 if arr[n-1] > arr[n-2]: return n-1 for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: return i return -1 # no peak found"},{"question":"You are given a 2D integer array, `operations`. For each `operations[i]`, where `operations[i] = [ai, bi, x, y, d]`, you need to determine if it is possible to perform `d` steps, starting from a point `(ai, bi)` in a grid, such that you land on a point `(x, y)` exactly after `d` steps. Each step can be taken in one of the four cardinal directions: up, down, left, or right, moving exactly one unit distance per step. Return a boolean array `results` where `results[i]` is the result of the `ith` query `operations[i]`.","solution":"def can_reach_destination(operations): results = [] for op in operations: ai, bi, x, y, d = op manhattan_distance = abs(x - ai) + abs(y - bi) if manhattan_distance <= d and (d - manhattan_distance) % 2 == 0: results.append(True) else: results.append(False) return results"},{"question":"A developer is working on a version control system that tracks changes to code with timestamps. Each time a code update is made, the system logs the update with a timestamp. You are given two arrays: `timestampsA` and `timestampsB`, where `timestampsA[i]` and `timestampsB[i]` represent the `i-th` update\'s timestamp from user A and user B respectively. The timestamps are in chronological order. An update can be considered significant if its difference from the previous update\'s timestamp from the same user is no less than a given threshold `T`. Your task is to identify the user who has the maximum number of significant updates. If both users have the same maximum number of significant updates, return \\"tie\\". If the user\'s list of updates is empty or they have no significant updates, their count is considered zero. Return _the user (`\\"A\\"` or `\\"B\\"`) with the maximum number of significant updates, or \\"tie\\" if both users have the same number of significant updates._","solution":"def significant_updates(timestampsA, timestampsB, T): Returns the user with the maximum number of significant updates or \\"tie\\" if both have the same number. Args: timestampsA: List[int] - list of timestamps for user A. timestampsB: List[int] - list of timestamps for user B. T: int - threshold for a significant update. Returns: str - \\"A\\", \\"B\\", or \\"tie\\". def count_significant_updates(timestamps, T): if not timestamps: return 0 count = 0 for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i-1] >= T: count += 1 return count significantA = count_significant_updates(timestampsA, T) significantB = count_significant_updates(timestampsB, T) if significantA > significantB: return \\"A\\" elif significantB > significantA: return \\"B\\" else: return \\"tie\\""},{"question":"Given a non-empty array of integers `nums` representing the pre-order traversal of a binary search tree (BST), construct the binary search tree and return its root. The binary search tree must be constructed such that it maintains the properties of a BST: left child nodes are less than their parent node, and right child nodes are greater than their parent node. Note that a BST constructed from its pre-order traversal is unique.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Constructs a binary search tree from its pre-order traversal list. if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, child = None, TreeNode(value) while stack and stack[-1].val < value: node = stack.pop() if node: node.right = child else: stack[-1].left = child stack.append(child) return root def tree_to_preorder_list(root): Given a tree root, return its pre-order traversal as a list. if root is None: return [] return [root.val] + tree_to_preorder_list(root.left) + tree_to_preorder_list(root.right)"},{"question":"You are given a matrix `mat` of size `n x m` consisting of non-negative integers. Find the length of the longest path in the matrix such that each step moves to an adjacent cell (up, down, left, right) and the value in the next cell is exactly one greater than the current cell. Return _the length of the longest path_ found.","solution":"def longest_increasing_path(mat): if not mat or not mat[0]: return 0 n, m = len(mat), len(mat[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] memo = [[-1] * m for _ in range(n)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and mat[nx][ny] == mat[x][y] + 1: max_path = max(max_path, 1 + dfs(nx, ny)) memo[x][y] = max_path return max_path max_length = 0 for i in range(n): for j in range(m): max_length = max(max_length, dfs(i, j)) return max_length"},{"question":"You are given a `string s` consisting of lowercase alphabet characters. You need to determine _the length of the longest subsequence of s_ where each character is lexicographically larger than the previous character. Each character in the subsequence must be distinct. Return _the length of this longest subsequence_.","solution":"def longest_increasing_subsequence_length(s): Returns the length of the longest subsequence of s where each character is lexicographically larger than the previous character. The subsequence must have distinct characters. unique_characters = set(s) return len(unique_characters)"},{"question":"You are given an array of integers `arr` of length `n` and an integer `m`. You need to divide the array into exactly `m` non-overlapping contiguous subarrays such that the maximum sum of any subarray is minimized. Return _the minimum possible value of the maximum sum of the subarrays._","solution":"def split_array(nums, m): Divide the array into m non-overlapping subarrays such that the maximum sum of any subarray is minimized. :param nums: List[int] - The array of integers to be split :param m: int - The number of subarrays :return: int - The minimum possible value of the maximum sum of the subarrays def is_valid(nums, m, mid): count, current_sum = 1, 0 for num in nums: current_sum += num if current_sum > mid: count += 1 current_sum = num if count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a 2D grid `m x n` where each cell is either `0` (empty) or `1` (blocked). You start from the top-left corner of the grid and your goal is to reach the bottom-right corner. You can only move right or down. Write a function to count the number of unique paths that you can take to reach the bottom-right corner from the top-left corner. Return the number of unique paths. Note that the starting and ending positions are always empty.","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a grid from the top-left to the bottom-right corner, where some cells are obstacles (denoted by 1). :param grid: List[List[int]] - A 2D grid with 0s and 1s (0 = empty, 1 = blocked) :return: int - Number of unique paths if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1]"},{"question":"Given an array of integers `arr`, return the sum of the minimum value in each subarray of `arr`. Since the answer may be large, return it modulo `10^9 + 7`.","solution":"def sum_of_subarray_mins(arr): Return the sum of the minimum value in each subarray of arr, modulo 10^9 + 7. MOD = 10**9 + 7 n = len(arr) left = [0] * n right = [0] * n stack = [] # Calculate left limits for i in range(n): count = 1 while stack and stack[-1][0] > arr[i]: count += stack.pop()[1] left[i] = count stack.append((arr[i], count)) stack = [] # Calculate right limits for i in range(n-1, -1, -1): count = 1 while stack and stack[-1][0] >= arr[i]: count += stack.pop()[1] right[i] = count stack.append((arr[i], count)) result = 0 for i in range(n): result = (result + arr[i] * left[i] * right[i]) % MOD return result"},{"question":"You are given a grid with `m` rows and `n` columns. Each cell in the grid contains a non-negative integer representing the cost to step on the cell. You are currently at the top-left cell (0, 0) and want to reach the bottom-right cell (m-1, n-1). You can only move either down or right at any point in time. Return the minimum cost path from the top-left to the bottom-right corner. The grid is represented as a 2D array `costs`. Implement the `minCostPath` function: * `int minCostPath(vector<vector<int>>& costs)`: This function should take a 2D array `costs` representing the grid and return the minimum cost to traverse from the top-left cell to the bottom-right cell. The function should implement a dynamic programming approach to ensure optimal performance.","solution":"def minCostPath(costs): if not costs or not costs[0]: return 0 m, n = len(costs), len(costs[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = costs[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + costs[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + costs[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + costs[i][j] return dp[m-1][n-1]"},{"question":"Given a list of integers `arr`, your task is to determine the length of the longest subsequence such that every element in the subsequence is strictly greater than all previous elements in the subsequence. This is also known as the Longest Increasing Subsequence (LIS) problem. Return the length of the LIS found in the input list `arr`. Note that the subsequence elements do not need to be contiguous in the original list. Steps to solve the problem: 1. Initialize an empty list `lis` to store the smallest possible tail element of increasing subsequences with various lengths. 2. Iterate over each element in the array. 3. For each element, use binary search to determine the position where it can replace or extend the elements in the `lis` list to maintain the increasing order. 4. If the current element is greater than the largest element in `lis`, it extends the longest subsequence found so far. 5. Otherwise, replace the appropriate element in `lis` to keep it as the smallest possible value while maintaining the increasing order. 6. The length of the `lis` list at the end is the length of the longest increasing subsequence. For example: - Input: `arr = [10, 9, 2, 5, 3, 7, 101, 18]` - Output: `4` (The Longest Increasing Subsequence is [2, 3, 7, 18], which has length 4)","solution":"from bisect import bisect_left def length_of_lis(arr): Returns the length of the longest increasing subsequence in the given list of integers. if not arr: return 0 lis = [] for num in arr: pos = bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"A company has a large dataset of employee records, where each record contains an employee\'s **name**, **age**, **department**, and **salary**. You are given a list of these records represented as dictionaries and an integer `k`. Write a function to return the top `k` departments with the highest average salary. If two departments have the same average salary, their order in the output should be determined by the lexicographical order of their department names. For example, given the list of employee records: ``` python [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, {\\"name\\": \\"Bob\\", \\"age\\": 35, \\"department\\": \\"Human Resources\\", \\"salary\\": 90000}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"department\\": \\"Engineering\\", \\"salary\\": 110000}, {\\"name\\": \\"David\\", \\"age\\": 40, \\"department\\": \\"Marketing\\", \\"salary\\": 100000}, {\\"name\\": \\"Eve\\", \\"age\\": 29, \\"department\\": \\"Marketing\\", \\"salary\\": 105000}, ] ``` and `k=2`, your function should return: ``` python [\\"Engineering\\", \\"Marketing\\"] ```","solution":"def top_k_departments_with_highest_avg_salary(records, k): Returns the top k departments with the highest average salary. If two departments have the same average salary, their order should be determined by their lexicographical order. :param records: List of employee records, where each record is a dictionary :param k: Number of top departments to return :return: List of top k departments from collections import defaultdict import heapq # Dictionary to store the total salary and count of employees for each department department_salary_map = defaultdict(lambda: {\'total_salary\': 0, \'count\': 0}) for record in records: department = record[\'department\'] salary = record[\'salary\'] department_salary_map[department][\'total_salary\'] += salary department_salary_map[department][\'count\'] += 1 # List to store (average_salary, department_name) tuples avg_salary_list = [] for department, salary_data in department_salary_map.items(): avg_salary = salary_data[\'total_salary\'] / salary_data[\'count\'] avg_salary_list.append((avg_salary, department)) # Sort the list by average salary (descending) and then by department name (ascending) avg_salary_list.sort(key=lambda x: (-x[0], x[1])) # Extract top k department names top_k_departments = [dept_name for _, dept_name in avg_salary_list[:k]] return top_k_departments"},{"question":"You are tasked with building software that monitors network traffic. You are given an **0-indexed** list of integers representing the packets received each second. You need to identify periods of consistent traffic where each packet received is the same. Your goal is to count the number of contiguous periods where the same number of packets are received. Given an array of integers `packets`, return the number of contiguous periods where each period consists of packet counts that are all the same. For example, given `packets = [1, 1, 2, 2, 3, 3, 3]`, there are four such periods: [1, 1], [2, 2], [3, 3], and [3, 3, 3].","solution":"def count_contiguous_periods(packets): if not packets: return 0 count = 1 current_packet = packets[0] for i in range(1, len(packets)): if packets[i] != packets[i - 1]: count += 1 return count"},{"question":"You are given an array of integers `nums` and an integer `target`. The array `nums` is **0-indexed** and **sorted** in non-decreasing order. Find the **starting index** and **ending index** of a given `target` value. If `target` is not present in `nums`, return `[-1, -1]`. Your algorithm\'s runtime complexity must be in the order of `O(log n)`. _Return a tuple containing the starting and ending index of the `target` in the array `nums`._","solution":"def search_range(nums, target): Returns the starting and ending index of the target in a sorted list. If the target is not found, returns [-1, -1]. :param nums: List[int] - sorted list of integers :param target: int - the target value to search for :return: List[int] - the starting and ending index of the target def binary_search_left(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = binary_search_left(nums, target) right_idx = binary_search_right(nums, target) if left_idx <= right_idx and left_idx < len(nums) and nums[left_idx] == target: return [left_idx, right_idx] else: return [-1, -1]"},{"question":"You are working on a text editor that provides a special operation called **capitalizeWord**. This operation takes a string and capitalizes the first letter of each word. Given a string `text`, implement a function to perform this operation. A word is defined as a sequence of non-space characters. The function should also remove any extra spaces between words such that there is exactly one space separating words in the returned string. You should assume that input text does not have leading or trailing whitespace before the operation. Return the modified string after applying the **capitalizeWord** operation.","solution":"def capitalizeWord(text): Returns a string where the first letter of each word is capitalized and extra spaces between words are removed. words = text.split() capitalized_words = [word.capitalize() for word in words] return \' \'.join(capitalized_words)"},{"question":"Given a list of `n` integers representing coin denominations and an integer amount representing a total sum of money, design an algorithm to determine the minimum number of coins needed to make up that amount. If it is not possible to make up the amount with the given denominations, return `-1`. You may assume that you have an infinite number of each denomination.","solution":"def coinChange(coins, amount): Determine the minimum number of coins needed to make up the given amount. If it is not possible to make up the amount with the given coin denominations, return -1. Args: coins: List[int] - List of integers representing coin denominations. amount: int - Integer representing the total sum of money. Returns: int - Minimum number of coins needed to make up the amount, or -1 if not possible. dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"Given a string `s`, return _the number of palindromic substrings in it_. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. The input string may contain both lower-case and upper-case letters. Implement the function `int countPalindromicSubstrings(String s)` which returns the number of palindrome substrings in the input string `s`.","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string s. def is_palindrome(substring): return substring == substring[::-1] count = 0 for i in range(len(s)): for j in range(i, len(s)): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"You are given a 2D grid of size `m x n` where each cell is either a `1` (representing land) or a `0` (representing water). An island is a maximal 4-directionally connected group of `1`\'s. There are no islands in the corners of the grid. A bridge can be built between two islands by flipping at most one water cell (`0`) to land (`1`). Return _the **minimum distance** needed to connect an island to another island via a bridge_. The **distance** is defined as the number of cells in the shortest path between two islands including the bridge.","solution":"from collections import deque def min_bridge_distance(grid): m, n = len(grid), len(grid[0]) def get_islands(): islands = [] visited = [[False] * n for _ in range(m)] def dfs(x, y, island): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < m and 0 <= j < n and not visited[i][j] and grid[i][j] == 1: visited[i][j] = True island.append((i, j)) stack.extend([(i-1, j), (i+1, j), (i, j-1), (i, j+1)]) for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: island = [] dfs(i, j, island) islands.append(island) return islands def bfs(start_points, target_island): queue = deque(start_points) visited = set(start_points) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if (nx, ny) in target_island: return steps if (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 islands = get_islands() if len(islands) < 2: return 0 island1, island2 = islands[0], islands[1] return min(bfs(island1, set(island2)), bfs(island2, set(island1)))"},{"question":"Given an `m x n` matrix `mat` containing integers, return _the next permutation_ of the matrix in lexicographical order. The next permutation is the next lexicographically greater permutation of the matrix. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here, the matrix is treated as a flattened array for permutation purposes.","solution":"def next_permutation(matrix): This function takes an m x n matrix and transforms it into its next lexicographical permutation in-place. If no such permutation exists, it rearranges it to the lowest possible order. def next_perm(nums): # Find the rightmost element which is smaller than its next element. i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # If such element does not exist, reverse the entire array to get the lowest order. if i == -1: nums.reverse() return # Find the rightmost element which is greater than nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Reverse the part of the array after i nums[i + 1:] = reversed(nums[i + 1:]) # Flatten the matrix into a 1D list flat_list = [item for sublist in matrix for item in sublist] # Apply next permutation next_perm(flat_list) # Reconstruct the matrix it = iter(flat_list) for i in range(len(matrix)): for j in range(len(matrix[0])): matrix[i][j] = next(it) # Example usage: # mat = [[1, 2], [3, 4]] # next_permutation(mat) # print(mat) # Output should be [[1, 2], [4, 3]]"},{"question":"You are given a string `s` and an array of strings `dictionary`. The string `s` can be formed by inserting a certain number of characters (possibly zero) at any positions in each string `word` in `dictionary`. However, you can insert different characters at different positions for different words but you cannot rearrange `[word]`\'s letters. A `word` is said to be a subsequence of `s` if and only if you can delete some characters from `s`. Return the longest string in `dictionary` that can be formed by inserting characters in `s`. If there are multiple results, return the string that appears first in the `dictionary`.","solution":"def find_longest_word(s, dictionary): def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) # Sort dictionary by length in descending order and lexicographically dictionary.sort(key=lambda x: (-len(x), x)) for word in dictionary: if is_subsequence(word, s): return word return \\"\\""},{"question":"A string `s` is said to be a \\"happy prefix\\" if it is both a prefix and a suffix (excluding the entire string). Given a string `s`, write a function to find the longest happy prefix of `s`. If no such prefix exists, return an empty string. Examples: - Input: `s = \\"level\\"` Output: `\\"l\\"` - Input: `s = \\"ababab\\"` Output: `\\"abab\\"` - Input: `s = \\"abcdef\\"` Output: `\\"\\"`","solution":"def longest_happy_prefix(s): Returns the longest happy prefix which is both a prefix and suffix (excluding the entire string). n = len(s) lps = [0] * n length = 0 i = 1 while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return s[:lps[-1]] # Example Usage: # print(longest_happy_prefix(\\"level\\")) # Output: \\"l\\" # print(longest_happy_prefix(\\"ababab\\")) # Output: \\"abab\\" # print(longest_happy_prefix(\\"abcdef\\")) # Output: \\"\\""},{"question":"Given a list of integers `nums` and an integer `k`, rotate the list to the right by `k` steps, where `k` is non-negative. Return the rotated list.","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps. Args: nums (List[int]): The list of integers to rotate. k (int): The number of steps to rotate the list. Returns: List[int]: The rotated list. if not nums: return [] k = k % len(nums) return nums[-k:] + nums[:-k]"},{"question":"You are given a list of non-negative integers representing the amount of time each task takes to complete, and an integer `n` representing the cooling period between two same tasks. Each task must be completed without interruption. In each unit of time, exactly one task can be executed or the system can stay idle if no task is available to execute. Your goal is to determine the minimum number of units of time required to complete all the given tasks. Return _the minimum time units needed to complete the task list_ while following the cooling period rule.","solution":"from collections import Counter import heapq def least_interval(tasks, n): Returns the minimum number of units of time required to complete all tasks if not tasks: return 0 # Count the frequency of tasks task_counts = Counter(tasks) # Create a max heap based on task counts max_heap = [-cnt for cnt in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: i, temp = 0, [] # Execute as many as `n + 1` tasks while i <= n: if max_heap: cnt = heapq.heappop(max_heap) if cnt < -1: temp.append(cnt + 1) time += 1 if not max_heap and not temp: break i += 1 for item in temp: heapq.heappush(max_heap, item) return time"},{"question":"A directed, weighted graph is represented by a 2D array `graph` where graph[i] contains a list of pairs `(neighbor, weight)` indicating that there is an edge from node `i` to `neighbor` with weight `weight`. Given the `graph`, a source node `src`, and a destination node `dest`, implement a function `shortestPath(int[][] graph, int src, int dest)` that returns the shortest path from `src` to `dest` in the graph. If there is no path from `src` to `dest`, return `-1`. The function should use Dijkstra\'s algorithm to find the shortest path.","solution":"import heapq def shortestPath(graph, src, dest): Returns the shortest path from src to dest using Dijkstra\'s algorithm. If there is no path, returns -1. # Number of nodes in the graph n = len(graph) # Distance array to keep track of minimum distance to each node dist = [float(\'inf\')] * n dist[src] = 0 # Priority queue to process nodes by distance pq = [(0, src)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) # If we have reached the destination if u == dest: return current_dist # If the distance is greater than the already found minimum distance if current_dist > dist[u]: continue # Explore neighbors for neighbor, weight in graph[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If destination is unreachable return -1"},{"question":"You are given a list of integers representing the heights of students standing in a line. You need to determine the minimum number of students that must be removed to make the remaining students\' heights strictly increasing. Return this minimum number.","solution":"def minimum_removals_to_make_increasing(heights): Returns the minimum number of students that must be removed to make the remaining students\' heights strictly increasing. if not heights: return 0 n = len(heights) dp = [1] * n # dp[i] will hold the length of the longest increasing subsequence ending at index i # Compute lengths of all LIS ending at each point for i in range(1, n): for j in range(0, i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence from the array lis_length = max(dp) # Minimum number of removals needed min_removals = n - lis_length return min_removals"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` contains only lower-case English letters. You need to form a new string by reordering the characters in `s` according to the given `indices` array. Specifically, if `indices[i] = j`, then the `i`th character in the original string `s` will be the `j`th character in the new string. Return the new reordered string.","solution":"def restore_string(s, indices): Reorder the characters of the string s according to the given indices array. Parameters: s (str): The input string. indices (List[int]): The list of indices indicating character positions in the reordered string. Returns: str: The reordered string. if len(s) != len(indices): raise ValueError(\\"The length of the string and the indices array must be the same.\\") # Create a list of the same length as `s` initialized with empty strings reordered_string = [\'\'] * len(s) # Place each character at its new position for index, char in zip(indices, s): reordered_string[index] = char # Join the list to form the final string return \'\'.join(reordered_string)"},{"question":"Write a `WordDictionary` class that supports two operations: - `void addWord(String word)` Adds a word into the data structure. - `boolean search(String word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. A word could contain the dot character `\'.\'` to represent any one letter. Example: - `addWord(\\"bad\\")` - `addWord(\\"dad\\")` - `addWord(\\"mad\\")` - `search(\\"pad\\")` -> `false` - `search(\\"bad\\")` -> `true` - `search(\\".ad\\")` -> `true` - `search(\\"b..\\")` -> `true`","solution":"class WordDictionary: def __init__(self): self.words = {} def addWord(self, word: str) -> None: if len(word) not in self.words: self.words[len(word)] = [] self.words[len(word)].append(word) def search(self, word: str) -> bool: word_len = len(word) if word_len not in self.words: return False for candidate in self.words[word_len]: if all(wc == \'.\' or wc == cc for wc, cc in zip(word, candidate)): return True return False"},{"question":"Given an integer array `arr` and an integer `k`, you are allowed to reverse the order of elements in any subarray of size `k` or smaller. Return the lexicographically smallest array that can be obtained by applying the aforementioned operation at most once.","solution":"def lexicographically_smallest_after_reverse(arr, k): Returns the lexicographically smallest array that can be obtained by reversing a subarray of size k or smaller at most once. n = len(arr) smallest_arr = arr[:] for i in range(n): for j in range(i, min(i + k, n)): subarray = arr[i:j+1][::-1] new_arr = arr[:i] + subarray + arr[j+1:] if new_arr < smallest_arr: smallest_arr = new_arr return smallest_arr"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', you can perform the following operation any number of times: Choose a non-empty substring consisting of only one unique character and remove it from the string. Your goal is to minimize the number of operations required to make the string empty. Return _the minimum number of operations needed to make the string empty_.","solution":"def min_operations(s: str) -> int: Return the minimum number of operations needed to make the string empty. Each operation consists of removing a contiguous substring of identical characters. if not s: return 0 operations = 1 for i in range(1, len(s)): if s[i] != s[i-1]: operations += 1 return operations"},{"question":"A string `s` is called **univalued** if all its characters are the same. You are given a string `s` consisting of only **lowercase English letters**. Your task is to return the length of the longest univalued substring of `s`. For example, for the string \\"leetcode\\" the longest univalued substring is \\"ee\\", which has a length of 2.","solution":"def longest_univalued_substring(s): Returns the length of the longest univalued substring of s. Parameters: s (str): A string consisting of only lowercase English letters. Returns: int: The length of the longest univalued substring. if not s: return 0 max_len = 1 current_char = s[0] current_len = 1 for i in range(1, len(s)): if s[i] == current_char: current_len += 1 max_len = max(max_len, current_len) else: current_char = s[i] current_len = 1 return max_len"},{"question":"You are given two non-negative integers `a` and `b` representing the number of 0-bits and 1-bits, respectively. Return any binary string of length `a + b` that contains exactly `a` 0-bits and `b` 1-bits, and where no two 1-bits are adjacent. If no such binary string exists, return an empty string.","solution":"def generate_binary_string(a, b): Generate a binary string of length a + b that contains exactly a \'0\'s and b \'1\'s where no two \'1\'s are adjacent. If no such binary string exists, return an empty string. if b > (a + 1): return \\"\\" result = [] while a > 0 or b > 0: if b > a: result.append(\'1\') b -= 1 if b > 0: result.append(\'0\') a -= 1 else: if a > 0: result.append(\'0\') a -= 1 if b > 0: result.append(\'1\') b -= 1 return \'\'.join(result)"},{"question":"You are given an integer array `heights` representing the heights of different buildings standing in a row and an integer `k`. A building is said to have a scenic view if there are no buildings taller than it to its right. Return the number of buildings that have a scenic view. Note that the rightmost building always has a scenic view.","solution":"def count_scenic_buildings(heights, k): Returns the number of buildings that have a scenic view. Parameters: heights (list of int): A list of integers representing the heights of buildings. k (int): An additional parameter (not used in the computation). Returns: int: The number of buildings with a scenic view. if not heights: return 0 count = 0 max_height = 0 for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"Suppose you have a list of integers `arr`. Implement a function `findMaximumXOR(arr)` that returns the maximum XOR of any two elements in the list. **Note** that: * XOR between two integers is a bitwise operation where the ith bit of the result is `1` if the ith bits of the operands are different and `0` if they are the same.","solution":"def findMaximumXOR(arr): Given a list of integers, returns the maximum XOR of any two elements in the list. max_xor = 0 mask = 0 for i in range(32)[::-1]: mask |= (1 << i) found = {num & mask for num in arr} start = max_xor | (1 << i) for prefix in found: if start ^ prefix in found: max_xor = start break return max_xor"},{"question":"Max is hosting a dinner party and wants to ensure that there are enough unique dishes for his guests. He has a list of `dishes` of length `m`, where each dish is represented by its name in a string. Max wants to find the maximum number of unique dishes he can prepare from the list, but he also knows that he can only prepare up to `k` dishes due to time and resource constraints. Given the list of dishes and the integer `k`, return the maximum number of unique dishes Max can prepare for his party. Example: Input: `dishes = [\\"apple pie\\", \\"salad\\", \\"burger\\", \\"salad\\", \\"apple pie\\", \\"soup\\"]`, `k = 3` Output: `3`","solution":"def max_unique_dishes(dishes, k): Returns the maximum number of unique dishes that can be prepared given the list of dishes and the constraint k. Parameters: dishes (list): A list of strings representing the names of dishes. k (int): The maximum number of dishes that can be prepared. Returns: int: The maximum number of unique dishes that can be prepared. unique_dishes = set(dishes) return min(len(unique_dishes), k)"},{"question":"Given an integer array `arr` of size `n`, find all the leaders in the array. An element is a leader if it is greater than all the elements to its right. The rightmost element is always a leader. Return the leaders in an array sorted in the same order as they appear in the input array.","solution":"def find_leaders(arr): This function takes an integer array as input and returns a list of leader elements. An element is a leader if it is greater than all the elements to its right. Args: arr (list): The input list of integers. Returns: list: A list of leader elements. if not arr: return [] leaders = [] max_from_right = arr[-1] leaders.append(max_from_right) for i in range(len(arr) - 2, -1, -1): if arr[i] > max_from_right: leaders.insert(0, arr[i]) max_from_right = arr[i] return leaders"},{"question":"You are given a **binary tree** with `n` nodes numbered from `0` to `n - 1`. Each node has a `value` assigned to it. Your task is to find the **path** from the root to any leaf such that the **sum of values** along the path is maximized. Return _the **maximum** sum of values_ along any such path. If there are multiple paths with the same maximum sum, return the path that appears first in a preorder traversal. If the tree is empty, return `0`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root): def helper(node): if not node: return (0, []) if not node.left and not node.right: return (node.value, [node.value]) left_sum, left_path = helper(node.left) right_sum, right_path = helper(node.right) if left_sum > right_sum: return (left_sum + node.value, [node.value] + left_path) else: return (right_sum + node.value, [node.value] + right_path) if not root: return 0 max_sum, path = helper(root) return max_sum"},{"question":"You are given a list of positive integers `heights`, where each integer represents the height of a building. Each building is of uniform width `1`. You want to add water such that each building can hold water up to the height of the lowest neighboring buildings. Calculate the maximum amount of water that can be trapped after raining. Use an algorithm that runs in `O(n)` time.","solution":"def trap(height): Given a list of heights, calculates the total amount of water that can be trapped after raining. :param height: List[int] - A list of integers representing heights of the buildings. :return: int - The total units of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"You are given a list of strings, `words`, and a character, `target`. Each string in `words` contains only lowercase alphabet characters. Return _a new list of strings that have the same length as `target` and meet the following condition_: Each character in the string appears the same number of times as the `target` character in `target`. If no such string is found, return an empty list.","solution":"def find_matching_words(words, target): from collections import Counter target_counter = Counter(target) target_length = len(target) result = [] for word in words: if len(word) == target_length and Counter(word) == target_counter: result.append(word) return result"},{"question":"You are given two integers `x` and `y` which represent the coordinates of a point in a 2D cartesian plane. Your task is to determine whether this point lies inside a circle with center at the origin `(0, 0)` and radius `r`. Return `true` _if the point lies inside the circle_ (including on the circumference), otherwise return `false`.","solution":"def is_point_in_circle(x, y, r): Determines whether the point (x, y) lies inside or on the border of the circle with center at the origin (0, 0) and radius r. return x**2 + y**2 <= r**2"},{"question":"You are given two strings `s1` and `s2` that represent two large non-negative integers. Write a function to return a string representing their product. Function Signature: ```python def multiply_large_numbers(s1: str, s2: str) -> str ``` - **Parameters**: - `s1`: A string representing a large non-negative integer. - `s2`: A string representing a large non-negative integer. - **Returns**: - A string representing the product of the two large numbers represented by `s1` and `s2`. - **Example**: ```python multiply_large_numbers(\\"123\\", \\"456\\") # returns \\"56088\\" ```","solution":"def multiply_large_numbers(s1: str, s2: str) -> str: Multiplies two large non-negative integers represented as strings and returns the product as a string. # If either number is zero, the product is zero. if s1 == \\"0\\" or s2 == \\"0\\": return \\"0\\" # Initialize the result as a list of zeros. result = [0] * (len(s1) + len(s2)) # Reverse both strings to facilitate multiplication from right to left. s1 = s1[::-1] s2 = s2[::-1] # Multiply each digit and add it to the result. for i in range(len(s1)): for j in range(len(s2)): result[i + j] += int(s1[i]) * int(s2[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeros and convert list back to a string. while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine if there exist three distinct elements in `nums` such that the sum of the three elements is equal to `target`. Return `true` if such a combination exists, otherwise return `false`.","solution":"def three_sum(nums, target): Determines if there exist three distinct elements in nums such that their sum equals target. :param nums: List of integers. :param target: Integer target sum. :return: True if such a combination exists, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You have a list of `n` points in a 2D plane, each represented by `[x, y]`. Your goal is to find the point such that the sum of the Manhattan distances from this point to all other points is minimized. The Manhattan distance between two points `[x1, y1]` and `[x2, y2]` is defined as `|x1 - x2| + |y1 - y2|`. Return the coordinates of this optimal point. If there are multiple points with the same minimum sum, return any one of them.","solution":"def min_total_manhattan_dist(points): Finds the point that minimizes the total sum of Manhattan distances to all other points in the given list `points`. Args: points (List[List[int]]): List of points where each point is [x, y] Returns: List[int]: The coordinates of the optimal point that minimizes the total Manhattan distance. def find_median(arr): arr.sort() length = len(arr) mid = length // 2 return arr[mid] if length % 2 != 0 else arr[mid - 1] x_coords = [point[0] for point in points] y_coords = [point[1] for point in points] optimal_x = find_median(x_coords) optimal_y = find_median(y_coords) return [optimal_x, optimal_y]"},{"question":"You are given a string `s` of lower case Latin characters. You need to group the characters in `s` such that each group contains the same characters. Return an array of strings, where each string represents a group of characters. The strings in the array should appear in the same relative order as they first appeared in the input string. For example, given the input string `\\"bbacaab\\"`, the expected output would be `[\\"bb\\", \\"aa\\", \\"c\\", \\"b\\"]`, as \'b\' appears first and is grouped, followed by the first appearance and grouping of \'a\', then \'c\', and the final \'b\' again at the end. Return the array of grouped strings.","solution":"def group_characters(s): Groups characters in the input string s such that each group contains the same characters while maintaining the order of their first appearance. Args: s (str): Input string of lower case Latin characters. Returns: List[str]: List of grouped characters. if not s: return [] grouped_chars = [] current_char_group = s[0] for char in s[1:]: if char == current_char_group[0]: current_char_group += char else: grouped_chars.append(current_char_group) current_char_group = char grouped_chars.append(current_char_group) return grouped_chars"},{"question":"Given an array of integers `arr` and an integer `k`, you need to find whether it is possible to divide the array into `k` non-empty subsets whose sums are all equal. Return `true` if it is possible, otherwise return `false`.","solution":"from typing import List def can_partition_k_subsets(arr: List[int], k: int) -> bool: def backtrack(i, k, subset_sum, subset_target, visited): if k == 0: return True if subset_sum == subset_target: return backtrack(0, k - 1, 0, subset_target, visited) for j in range(i, len(arr)): if not visited[j] and subset_sum + arr[j] <= subset_target: visited[j] = True if backtrack(j + 1, k, subset_sum + arr[j], subset_target, visited): return True visited[j] = False return False total_sum = sum(arr) if total_sum % k != 0: return False subset_target = total_sum // k visited = [False] * len(arr) return backtrack(0, k, 0, subset_target, visited)"},{"question":"Design an algorithm that takes a **list of transactions** in the form of `(user, amount)` and then compiles a final balance report for each user. Each transaction identifies the user and the amount they either gain or lose in that transaction. Implement the following two methods: * `void addTransaction(string user, int amount)` - takes the user\'s name and the transaction amount, updating their balance accordingly. * `map<string, int> getBalances()` - returns a map of all users and their final balances after all transactions have been processed. Example: ```python trx = Transactions() trx.addTransaction(\\"Alice\\", 50) trx.addTransaction(\\"Bob\\", -20) trx.addTransaction(\\"Alice\\", -10) balances = trx.getBalances() # Outputs: {\\"Alice\\": 40, \\"Bob\\": -20} ```","solution":"class Transactions: def __init__(self): self.balances = {} def addTransaction(self, user, amount): Takes the user\'s name and the transaction amount, updating their balance accordingly. if user in self.balances: self.balances[user] += amount else: self.balances[user] = amount def getBalances(self): Returns a map of all users and their final balances after all transactions have been processed. return self.balances"},{"question":"You are given an integer array `nums` and a positive integer `k`. An integer `x` is said to be a **peak element** if it is greater than or equal to both its neighbors. For an array of length `n`, consider its bounds to have negative infinity values. Find and return the **count** of peak elements in the array and their **indices** as a list of tuples, where each tuple contains the **value** and **index** of a peak element. The list of tuples should be sorted by their indices in ascending order.","solution":"def find_peaks(nums, k): peaks = [] n = len(nums) for i in range(n): left = nums[i - 1] if i - 1 >= 0 else float(\'-inf\') right = nums[i + 1] if i + 1 < n else float(\'-inf\') if nums[i] >= left and nums[i] >= right: peaks.append((nums[i], i)) return len(peaks), sorted(peaks, key=lambda x: x[1])"},{"question":"In a city, there\'s a unique path from the starting point (0, 0) to the destination point (m-1, n-1) in an `m x n` grid. The path can only move to the right or downward at any point in time. Some of the cells could be obstacles which are marked as `1` and other cells are known to be open which are marked as `0`. Given the grid, determine the number of possible unique paths from the start to the destination point considering the obstacles. If there are no possible paths, return `0`. Implement the function `uniquePathsWithObstacles(grid: List[List[int]]) -> int` that returns the number of unique paths. # Example: - Input: `grid = [[0,0,0],[0,1,0],[0,0,0]]` - Output: `2` # Note: - `m` and `n` will be at most `100`.","solution":"def uniquePathsWithObstacles(grid): if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a positive integer array `nums` and an integer target `T`. Your goal is to determine if there exists a **non-empty subsequence** of `nums` such that the sum of its elements is precisely `T`. A **subsequence** is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Write a function that takes in the array `nums` and the integer `T`, and returns `true` if such a subsequence exists, and `false` otherwise.","solution":"def can_sum_to_target(nums, T): Determines if there exists a non-empty subsequence of nums that sums to T. Parameters: nums (list): A list of positive integers. T (int): The target sum that subsequence should have. Returns: bool: True if such a subsequence exists, False otherwise. n = len(nums) dp = [False] * (T + 1) dp[0] = True for num in nums: for t in range(T, num - 1, -1): if dp[t - num]: dp[t] = True return dp[T]"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to find the value of the deepest node (the node that is farthest from the root). If there are multiple nodes with the same depth, return the leftmost one. The binary tree is represented by a reference to the root node. The tree may be empty, in which case the function should return `null`. Your function should run in O(n) time complexity, where n is the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root): Finds the value of the deepest node (farthest from the root) in the binary tree. If multiple nodes have the same depth, the leftmost one is returned. If the tree is empty, `null` is returned. if not root: return None from collections import deque queue = deque([(root, 0)]) # (node, depth) deepest_node_val = root.val max_depth = 0 while queue: node, depth = queue.popleft() if depth > max_depth: deepest_node_val = node.val max_depth = depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return deepest_node_val"},{"question":"Imagine you are working on a real-time messaging application that supports two key operations: posting messages and retrieving the most recent messages. You\'ll need to design a `MessageSystem` class with the following methods: * `void postMessage(int userId, string message)`: Records a message posted by a user identified by `userId`. * `List<string> getRecentMessages(int userId, int k)`: Returns the `k` most recent messages posted by the user identified by `userId`. If the user has posted fewer than `k` messages, return all of their messages in the order they were posted.","solution":"class MessageSystem: def __init__(self): self.user_messages = {} def postMessage(self, userId, message): if userId not in self.user_messages: self.user_messages[userId] = [] self.user_messages[userId].append(message) def getRecentMessages(self, userId, k): if userId not in self.user_messages: return [] return self.user_messages[userId][-k:][::-1] # Return last k messages in reverse order"},{"question":"Write a function that takes a string `s` as input, representing a sentence, and returns the same sentence with each word reversed while preserving whitespace and initial word order. Note, words are defined as a sequence of characters separated by space(s). For example, given `s = \\"This is an example\\"`, the function should return \\"sihT si na elpmaxe\\".","solution":"def reverse_words(sentence): Reverses each word in the sentence while preserving whitespace and order of words. Args: sentence (str): The original sentence. Returns: str: The sentence with each word reversed. # Split the sentence into words words = sentence.split(\' \') # Reverse each word and join them with a space reversed_words = [word[::-1] for word in words] # Join the reversed words with a space to form the final sentence reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"Given a **sorted** array of integers `arr` and an integer `x`, find _the pair of integers in the array whose difference is equal to_ `x`. _If there are multiple such pairs, return **any** one of them. If no such pair exists, return an **empty** pair._ The integers in the pair should appear in ascending order.","solution":"def find_pair_with_difference(arr, x): Returns a pair of integers from the sorted array \'arr\' whose difference is \'x\'. If no such pair exists, returns an empty pair. left, right = 0, 1 while right < len(arr): diff = arr[right] - arr[left] if diff == x and left != right: return (arr[left], arr[right]) elif diff < x: right += 1 else: left += 1 return ()"},{"question":"You have an array `arr` consisting of `n` integers that represents the amount of money distributed in `n` houses. Your task is to rob the maximum amount of money without alerting the police. The constraint here is that if you rob two adjacent houses, the police will be notified. Given the array `arr`, return the maximum amount of money you can rob without alerting the police.","solution":"def rob(arr): Returns the maximum amount of money that can be robbed without alerting the police. You cannot rob two adjacent houses. :param arr: List[int] - the list of amounts of money in each house :return: int - the maximum amount of money that can be robbed if not arr: return 0 n = len(arr) if n == 1: return arr[0] # Dynamic programming approach dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"A company is tracking product sales over time. They record the sale of each product as a tuple `(timestamp, product_id, price, quantity)`. Given a list of these tuples and a time range `[start_time, end_time]`, return the total revenue generated for each product within the given time range. Revenue is calculated as the product of `price` and `quantity` for each sale transaction within the specified range. Write the function `total_revenue(sales, start_time, end_time)` that returns a dictionary where the keys are the product_ids and the values are the total revenue for each product within the time range. The input list of sales is sorted by timestamp.","solution":"def total_revenue(sales, start_time, end_time): Calculate the total revenue for each product within the given time range. Parameters: sales (list of tuples): List of sales where each sale is represented as a tuple (timestamp, product_id, price, quantity). start_time (int/float): Start of the time range. end_time (int/float): End of the time range. Returns: dict: A dictionary with product_ids as keys and their total revenue as values. revenue = {} for timestamp, product_id, price, quantity in sales: if start_time <= timestamp <= end_time: if product_id not in revenue: revenue[product_id] = 0 revenue[product_id] += price * quantity return revenue"},{"question":"A group of friends is planning a trip and wants to rent cars to get around. There are `k` types of cars available, and each type `j` can hold `capacity[j]` persons. The group consists of `n` people and they want to fit exactly `n` people in the rented cars. Each car can be rented multiple times. Write a function `minNumCars(capacity, k, n)` to compute the minimum number of cars they need to rent such that all n people are accommodated. If it\'s not possible to fit exactly `n` people, return `-1`. The function should take in the following parameters: - `capacity`: a list of integers where `capacity[j]` represents the seating capacity of car type `j`. - `k`: an integer representing the number of distinct car types. - `n`: an integer representing the total number of people. **Note**: There is an unlimited number of each type of car, but all n people must be exactly accommodated.","solution":"def minNumCars(capacity, k, n): Returns the minimum number of cars needed to accommodate exactly n people. If it\'s not possible to fit exactly n people, return -1. :param capacity: List[int] - a list where capacity[j] is the seating capacity of car type j. :param k: int - the number of distinct car types. :param n: int - the total number of people. :return: int - the minimum number of cars needed, or -1 if not possible to fit exactly n people. # dp[i] will be storing the minimum number of cars needed to accommodate i people dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Base case: It takes 0 cars to accommodate 0 people. for i in range(1, n + 1): for j in range(k): if capacity[j] <= i: dp[i] = min(dp[i], dp[i - capacity[j]] + 1) return dp[n] if dp[n] != float(\'inf\') else -1"},{"question":"A string `sequence` is called a *k-repeating string* if there is a string `x` with a length of at most `sequence` divided by `k` and `sequence` is the concatenation of `x` repeated `k` times. For example, `\\"ababab\\"` is a `3-repeating string` as it is the concatenation of `\\"ab\\"` three times. Given a string `sequence` and an integer `k`, return `true` if `sequence` is a `k-repeating string`, otherwise, return `false`.","solution":"def is_k_repeating_string(sequence, k): Determines if the given string `sequence` is a k-repeating string. Args: sequence (str): The string to check. k (int): The integer k. Returns: bool: True if `sequence` is a k-repeating string, False otherwise. if k <= 0: return False n = len(sequence) if n % k != 0: return False substring_length = n // k substring = sequence[:substring_length] return sequence == substring * k"},{"question":"You are given two positive integers represented as strings `num1` and `num2`, both having no leading zeroes. Your task is to implement a function that returns a string representing the product of `num1` and `num2`. Write a function `multiplyStrings` that takes in two strings, `num1` and `num2`, and returns their product as a string. You are not allowed to use any built-in Python library functions that directly perform multiplication on large integers. **Example:** ```plaintext Input: num1 = \\"123\\", num2 = \\"456\\" Output: \\"56088\\" ``` **Notes:** - The input numbers are non-negative. - The result should also not have any leading zeros except when the result is \\"0\\".","solution":"def multiplyStrings(num1: str, num2: str) -> str: # Handle edge case where either number is \\"0\\" if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" m, n = len(num1), len(num2) product = [0] * (m + n) # Reverse both the strings to make it easier to handle the carry num1, num2 = num1[::-1], num2[::-1] for i in range(m): for j in range(n): # Multiply digits and add result to the corresponding position product[i + j] += int(num1[i]) * int(num2[j]) # Handle carry product[i + j + 1] += product[i + j] // 10 product[i + j] %= 10 # Convert product to string and reverse it back product = product[::-1] # Skip leading zeros start = 0 while start < len(product) and product[start] == 0: start += 1 return \'\'.join(map(str, product[start:])) or \\"0\\""},{"question":"You have a list of `projects`, each represented by a unique integer ID. You are given an array `dependencies` where `dependencies[i] = [project1, project2]` indicates that project1 must be completed before project2 can be started. Write a function to determine the order of execution for the projects such that all dependencies are met. If there is no valid order, return an empty list. If multiple valid orders exist, return any one of them.","solution":"from collections import defaultdict, deque def find_order(projects, dependencies): Determines the order of execution for the projects such that all dependencies are met. Args: projects: List[int] - List of unique project IDs. dependencies: List[List[int]] - List of dependencies where [project1, project2] means project1 must be done before project2. Returns: List[int] - A valid order of project execution or an empty list if no valid order exists. # Create an adjacency list and a dictionary to keep track of the in-degrees. adjacency_list = defaultdict(list) in_degree = {project: 0 for project in projects} # Build the graph and in-degree for pre, post in dependencies: adjacency_list[pre].append(post) in_degree[post] += 1 # Initialize a queue with projects that have in-degree of 0 queue = deque([project for project in projects if in_degree[project] == 0]) order = [] while queue: current = queue.popleft() order.append(current) # Decrease the in-degree of the neighbors for neighbor in adjacency_list[current]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If the order contains all projects, return it; otherwise, return an empty list if len(order) == len(projects): return order else: return []"},{"question":"You are given an array of integers `nums` and an integer `target`. You can perform the following operation as many times as you want: 1. Choose any two elements in the array and remove them. 2. Insert their sum back into the array. Your task is to determine whether you can perform these operations in such a way that exactly one element remains in the array, and that element is equal to the given `target`. Return `true` if it is possible, or `false` otherwise.","solution":"def can_form_target(nums, target): Determines if it is possible to perform operations to leave exactly one element in the array equal to the target. Args: nums (list of int): The array of integers. target (int): The target integer. Returns: bool: True if it\'s possible to obtain the target, otherwise False. current_sum = sum(nums) if current_sum < target: return False return (current_sum - target) % 2 == 0"},{"question":"Given an array of `n` integers, return the length of the **longest arithmetic subsequence** in the array. An arithmetic subsequence is one where the difference between consecutive elements is the same. For example, in the array `[1, 7, 10, 13, 14, 19]`, the longest arithmetic subsequence is `[1, 7, 13, 19]` with a common difference of `6`. [Question] 4: Similar to the example array, write a function that takes an array of `n` integers and returns the length of the longest arithmetic subsequence in the given array.","solution":"from collections import defaultdict def longest_arith_seq_length(arr): if not arr: return 0 n = len(arr) if n <= 1: return n dp = [defaultdict(int) for _ in range(n)] max_length = 2 for i in range(n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"Given an array of integers `nums`, return the **running sum** of `nums`. The running sum of an array is defined as `runningSum[i] = sum(nums[0]…nums[i])`. Return the array `runningSum` that contains the running sum of `nums` for each index `i`.","solution":"def running_sum(nums): Returns the running sum of nums. running_total = 0 running_sums = [] for num in nums: running_total += num running_sums.append(running_total) return running_sums"},{"question":"Given an array of strings `words` and a string `target`, determine if the `target` can be constructed by concatenating two distinct strings from the `words` array. Return `True` if it is possible, otherwise return `False`. The two strings used to form the `target` must be different elements from the `words` array.","solution":"def can_construct_target(words, target): Determines if the target can be constructed by concatenating two distinct strings from the words array. :param words: List of strings :param target: The target string to construct :return: True if the target can be constructed, otherwise False word_set = set(words) for word in words: prefix, suffix = target[:len(word)], target[len(word):] if prefix == word and suffix in word_set and suffix != word: return True return False"},{"question":"You are given an array `heights` of integers representing the heights of a group of people standing in a line. The array is listed from left to right in the order of their position. A person `i` can see another person `j` if `heights[j]` is taller than or equal to `heights[i]` and there are no taller people between them. For each person in the array, calculate how many other people they can see to their right. Return an array of the same length where the value at each index `i` is the number of people `i` can see to their right.","solution":"def count_visible_people(heights): Given a list of heights, returns a list where each element is the count of people a person can see to their right. n = len(heights) result = [0] * n for i in range(n): max_height = heights[i] for j in range(i + 1, n): if heights[j] >= max_height: result[i] += 1 max_height = heights[j] return result"},{"question":"A company is developing a new calendar application and needs a functionality to manage event scheduling. Each event has a start time and end time, and the application should be able to handle overlapping events without conflicts. Design a class `MyCalendar` to implement the following methods: - `MyCalendar()`: Initializes the calendar object. - `boolean book(int start, int end)`: Schedules a new event if it does not conflict with any existing events in the calendar. If it does not conflict, the event is added to the calendar and the method returns `true`. Otherwise, the method returns `false`. An event is defined by its start and end times `[start, end)`, where `start` is inclusive and `end` is exclusive. Event `A` conflicts with event `B` if `A`\'s start time is less than `B`\'s end time and `A`\'s end time is greater than `B`\'s start time. Write the `MyCalendar` class using the method signatures provided.","solution":"class MyCalendar: def __init__(self): self.events = [] def book(self, start, end): for event in self.events: if not (end <= event[0] or start >= event[1]): return False self.events.append((start, end)) return True"},{"question":"You are given two lists: `projects` and `dependencies`. The `projects` list contains unique project IDs, while the `dependencies` list contains pairs of project IDs where the first project is dependent on the completion of the second project. Write a function to find a valid order in which to complete all the projects. If no such order exists, return an empty list. Note that if multiple valid orders exist, you may return any of them.","solution":"def find_project_order(projects, dependencies): from collections import defaultdict, deque # Create the graph and indegree count graph = defaultdict(list) indegree = {project: 0 for project in projects} for dependency in dependencies: next_project, prerequisite = dependency graph[prerequisite].append(next_project) indegree[next_project] += 1 # Using a queue to keep track of projects with no prerequisites queue = deque([project for project in projects if indegree[project] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == len(projects): return order else: return []"},{"question":"Given an array of unique integers `nums` sorted in an increasing order, you are asked to find the smallest positive integer that is not present in the array `nums` and is also larger than the last element in `nums`. Return this smallest positive integer. If such an integer does not exist, return the last element in the array incremented by one.","solution":"def find_smallest_missing_positive(nums): Finds the smallest positive integer that is not present in the array nums and is also larger than the last element in nums. Args: nums (List[int]): A list of unique integers sorted in increasing order. Returns: int: The smallest positive integer that is not in nums and is larger than the last element in nums. if not nums: return 1 last_element = nums[-1] return last_element + 1"},{"question":"You are given a string `s` consisting of lowercase characters, and an array `queries` where each query is a pair of integers `[left, right]`. For each query, find the number of distinct characters in the substring `s[left:right]` (inclusive). Implement a function that processes and answers all the queries efficiently.","solution":"def distinct_characters_in_substrings(s, queries): This function receives a string s and a list of queries. Each query is a pair of integers [left, right]. For each query, the function returns the number of distinct characters in the substring s[left:right+1]. results = [] for left, right in queries: substring = s[left:right+1] distinct_count = len(set(substring)) results.append(distinct_count) return results"},{"question":"Given two integers `x` and `y`, find a pair of integers `(a, b)` such that `1 <= a <= x` and `1 <= b <= y`, where the values of `a` and `b` are prime numbers and the value of `a * b` is maximum. Return the pair `(a, b)`. If there are multiple pairs with the same product, return the pair with the smallest `a`. If no such pair exists, return `(-1, -1)`.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_max_prime_pair(x, y): primes_x = [i for i in range(1, x + 1) if is_prime(i)] primes_y = [i for i in range(1, y + 1) if is_prime(i)] max_product = -1 result_pair = (-1, -1) for a in primes_x: for b in primes_y: product = a * b if product > max_product or (product == max_product and a < result_pair[0]): max_product = product result_pair = (a, b) return result_pair"},{"question":"You are given a **0-indexed** array `nums` of integers. Write a function that returns _the displaced duplicates_. A displaced duplicate is an element that appears at least twice in the array, but not in consecutive positions. For each displaced duplicate, return its first and second positions in the format of a pair, as well as all such pairs in the order they appear in the array. If there are no such duplicates, return an empty list of pairs.","solution":"def displaced_duplicates(nums): Returns displaced duplicates in the form of pairs of their first and second positions. Parameters: nums (list): A 0-indexed array of integers. Returns: list: List of tuples containing pairs of first and second positions of displaced duplicates. seen = {} result = [] for i, num in enumerate(nums): # Check if we have seen this number before if num in seen: # Add the pair only if it\'s not consecutive if seen[num] != i - 1: result.append((seen[num], i)) else: # Update the position if it\'s consecutive seen[num] = i else: # Store the first occurrence of the number seen[num] = i return result"},{"question":"Given an `n x n` grid where each cell contains an integer representing the elevation at that point, you are a hiker starting from the top-left corner (0, 0) and you want to reach the bottom-right corner (n-1, n-1). You can only move right or down. Calculate the minimum effort required for your hike. The effort is defined as the maximum absolute difference in elevations between two consecutive cells in your chosen path. Return the minimum effort you need to reach the bottom-right corner of the grid.","solution":"import heapq def min_elevation_effort(grid): Returns the minimum effort required for the hike. n = len(grid) if n == 0: return 0 def get_neighbors(x, y): for dx, dy in [(1, 0), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: yield nx, ny def dijkstra(): pq = [(0, 0, 0)] # (effort, x, y) efforts = [[float(\'inf\')] * n for _ in range(n)] efforts[0][0] = 0 while pq: effort, x, y = heapq.heappop(pq) if x == n - 1 and y == n - 1: return effort for nx, ny in get_neighbors(x, y): new_effort = max(effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(pq, (new_effort, nx, ny)) return dijkstra()"},{"question":"You are given an array `heights` representing the heights of `n` people in a line. The heights are taken in arbitrary order and there are no duplicate heights. Your task is to reorder the array in such a way that each person is taller than the person directly in front of them and shorter than the person directly behind them. The first position in the array should have the shortest person while the last position should have the tallest. Return the reordered array of heights.","solution":"def reorder_heights(heights): Reorders an array of heights so that each person is taller than the one in front and shorter than the one behind. Args: heights (list of int): A list of heights of n people, where each height is unique. Returns: list of int: The reordered list of heights. return sorted(heights)"},{"question":"You are given a linked list where each node contains an integer value. Write a function that returns the head of the linked list after sorting it in ascending order using merge sort. The function should preserve the original structure and only rearrange the node values.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head): if not head or not head.next: return head # Find the middle of the linked list slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None # Recursively split and sort both halves left = merge_sort_linked_list(head) right = merge_sort_linked_list(mid) # Merge sorted halves return merge(left, right) def merge(left, right): dummy = ListNode() tail = dummy while left and right: if left.val < right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next tail.next = left or right return dummy.next"},{"question":"You are given a list of `wordList` which consists of unique words, and two words called `beginWord` and `endWord` (both not in `wordList`). You need to seek the shortest transformation sequence from `beginWord` to `endWord`, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the `wordList`. Note that `beginWord` is not included in the transformation sequence, but must be used as the first step of the transformation. If there is no such transformation sequence, return 0. The transformation sequence from `beginWord` to `endWord` should be the shortest one possible and must only change one letter at a time.","solution":"from collections import deque, defaultdict def word_ladder_length(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord, or 0 if such a sequence does not exist. if endWord not in wordList: return 0 # Pre-process the words in wordList to create a dictionary of all combinations of words with wildcards. L = len(beginWord) all_combo_dict = defaultdict(list) for word in wordList: for i in range(L): all_combo_dict[word[:i] + \\"*\\" + word[i+1:]].append(word) # BFS starting queue = deque([(beginWord, 1)]) visited = set(beginWord) while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == endWord: return level + 1 if word not in visited: visited.add(word) queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] return 0"},{"question":"You are given a list of `n` books, where each book has a unique integer `pages[i]` representing the number of pages in the `i`th book. You want to distribute these books to `k` students such that each student gets at least one book and the maximum number of pages assigned to any student is minimized. Each book must be assigned to exactly one student. Return _the minimum possible value of the maximum number of pages assigned to a student_.","solution":"def is_feasible(pages, n, k, max_pages): students_required = 1 current_pages = 0 for i in range(n): if current_pages + pages[i] > max_pages: students_required += 1 current_pages = pages[i] if students_required > k: return False else: current_pages += pages[i] return True def min_max_pages(pages, n, k): if n < k: return -1 start = max(pages) end = sum(pages) result = end while start <= end: mid = (start + end) // 2 if is_feasible(pages, n, k, mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"You are tasked with designing a data structure that efficiently maintains a collection of integers and supports the following operations: * `void add(int num)`: Adds the integer `num` to the collection. * `bool contains(int num)`: Returns `true` if the integer `num` is present in the collection, otherwise returns `false`. * `void remove(int num)`: Removes the integer `num` from the collection if it is present. * `double getMedian()`: Returns the median of all elements in the collection. If the total number of elements is odd, the median is the middle value. If the total number of elements is even, the median is the average of the two middle values. Implement the `IntegerCollection` class with the above operations. The class should ensure that all operations have optimal time complexities for efficiency.","solution":"import bisect class IntegerCollection: def __init__(self): self.nums = [] def add(self, num: int): bisect.insort(self.nums, num) def contains(self, num: int) -> bool: index = bisect.bisect_left(self.nums, num) return index < len(self.nums) and self.nums[index] == num def remove(self, num: int): index = bisect.bisect_left(self.nums, num) if index < len(self.nums) and self.nums[index] == num: self.nums.pop(index) def getMedian(self) -> float: n = len(self.nums) if n == 0: raise ValueError(\\"Collection is empty\\") if n % 2 == 1: return float(self.nums[n // 2]) else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2"},{"question":"A valid parentheses string is either empty (\\"\\"), or \\"(\\", A, \\")\\", where A is a valid parentheses string, or A and B (AB), where A and B are valid parentheses strings. A valid parentheses string can also be nested multiple times, like \\"(())\\" or \\"()()\\" but still be valid. Given an integer `n`, generate all combinations of well-formed parentheses of length `2n`. Return the combinations in any order.","solution":"def generate_parentheses(n): Generate all combinations of well-formed parentheses of length 2n. :param n: Integer, number of pairs of parentheses :return: List of strings, all combinations of well-formed parentheses def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. We define a \\"substring of consistent characters\\" as a substring where the difference between the highest and lowest alphabetical characters\' values is at most `k`. Return the length of the longest substring of consistent characters from `s`. If no such substring exists, return `0`.","solution":"def longest_consistent_substring(s, k): Returns the length of the longest substring of consistent characters from s where the difference between the highest and lowest alphabetical characters\' values is at most k. :param s: A string consisting of lowercase alphabets :param k: An integer representing the allowed difference between the highest and lowest characters in the substring :return: Length of the longest substring of consistent characters n = len(s) max_length = 0 start = 0 while start < n: min_char = max_char = s[start] end = start while end < n and ord(max_char) - ord(min_char) <= k: end += 1 if end < n: min_char = min(min_char, s[end]) max_char = max(max_char, s[end]) max_length = max(max_length, end - start) start += 1 return max_length"},{"question":"You are given a list of non-negative integers `nums` representing the number of stones in each pile and an integer `k`. You can merge exactly `k` consecutive piles into one pile, and the cost of merging these piles is equal to the total number of stones in the k piles. Return the minimum cost to merge all piles into one pile. If it is impossible to merge all piles into one pile, return `-1`.","solution":"def mergeStones(piles, k): import sys from functools import lru_cache n = len(piles) if (n - 1) % (k - 1) != 0: return -1 prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i+1] = prefix_sum[i] + piles[i] @lru_cache(None) def dp(i, j, m): if i == j: return 0 if m == 1 else sys.maxsize if m == 1: return dp(i, j, k) + prefix_sum[j+1] - prefix_sum[i] min_cost = sys.maxsize for t in range(i, j, k - 1): min_cost = min(min_cost, dp(i, t, 1) + dp(t + 1, j, m - 1)) return min_cost return dp(0, n-1, 1)"},{"question":"You are given two arrays `colors1` and `colors2` of the same length, representing the color of shirts worn by students in two different classes on the same day. Each color is represented by an integer. You want to determine the smallest window length in which all unique colors of `colors1` appear in the same relative order in `colors2`. Return the length of this smallest window. If no such window exists, return `-1`. For instance, if `colors1 = [1, 2, 3]` and `colors2 = [7, 1, 9, 2, 3, 4]`, the smallest window in which all colors of `colors1` appear in the same order in `colors2` is `[1, 9, 2, 3]`, so the output should be `4`.","solution":"def smallest_window(colors1, colors2): Returns the length of the smallest window in colors2 where all elements of colors1 appear in the same relative order. If no such window exists, returns -1. n = len(colors1) m = len(colors2) # Corner case: if colors1 is empty or colors2 is smaller than colors1 if n == 0 or m < n: return -1 left_includes = {i: {} for i in range(n)} right = 0 window_len = float(\'inf\') for right in range(m): current_color = colors2[right] if current_color == colors1[0]: left_includes[0][right] = 1 for i in range(1, n): for left_idx in left_includes[i-1].keys(): if colors2[right] == colors1[i]: distance = left_includes[i-1][left_idx] + (right - left_idx) if right not in left_includes[i]: left_includes[i][right] = distance else: left_includes[i][right] = min(left_includes[i][right], distance) for right_idx in left_includes[n-1].keys(): window_len = min(window_len, left_includes[n-1][right_idx]) return window_len if window_len != float(\'inf\') else -1"},{"question":"Given a binary tree, imagine each node has an additional pointer called `next` pointing to the next node at the same level. The last node at each level\'s `next` pointer should be set to `None`. Implement a function `connect` that takes the root of the binary tree and connects the `next` pointers as described. The class definition of a tree node could be provided as: ``` python class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next ``` For example: - Given the binary tree: ``` 1 / 2 3 / 4 5 7 ``` - Your function should connect the `next` pointers as follows: ``` 1 -> None / 2 -> 3 -> None / 4 -> 5 -> 7 -> None ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Connects the next pointers of nodes at the same level in a binary tree. :param root: TreeNode, the root of the binary tree. if not root: return # Initialize a pointer to traverse nodes at the current level. current = root dummy = TreeNode(0) # Dummy node to keep track of the next level\'s head. while current: # Use tail to build the next level\'s linked list. tail = dummy while current: if current.left: tail.next = current.left tail = tail.next if current.right: tail.next = current.right tail = tail.next current = current.next # Move to the next level. current = dummy.next dummy.next = None"},{"question":"You are given a list of `n` tasks labeled from `0` to `n - 1` and an array prerequisites where `prerequisites[i] = [ai, bi]` means that you must complete task `ai` before you can complete task `bi`. Write a function to determine if it is possible to finish all tasks. If it is possible, return any ordering of the tasks that meets the prerequisites. If it is not possible, return an empty list.","solution":"from collections import defaultdict, deque def find_task_order(num_tasks, prerequisites): Determines if it is possible to finish all tasks with given prerequisites and returns an order of tasks. :param num_tasks: int - Number of tasks :param prerequisites: List[List[int]] - List of prerequisites :return: List[int] - Ordered list of tasks or empty list if not possible # Create adjacency list and indegree array adj_list = defaultdict(list) indegree = [0] * num_tasks # Build the graph for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] += 1 # Queue for tasks having no prerequisites zero_indegree_queue = deque([i for i in range(num_tasks) if indegree[i] == 0]) top_order = [] while zero_indegree_queue: task = zero_indegree_queue.popleft() top_order.append(task) for neighbor in adj_list[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If top_order contains all tasks, return the order, otherwise return empty list if len(top_order) == num_tasks: return top_order else: return []"},{"question":"You are given a 2D integer matrix `grid` of size `m x n`, where each cell has either a 0 or a 1. You are also given an integer `steps`. Your task is to determine the maximum number of 1\'s you can collect starting from any cell in the grid and moving exactly `steps` moves. In one move, you can move one cell up, down, left, or right. You cannot move outside the grid or visit a cell more than once in any path. Return _the maximum number of 1\'s you can collect with exactly_ `steps` _moves._","solution":"def max_ones(grid, steps): Determines the maximum number of 1\'s that can be collected in \'steps\' moves starting from any cell. rows, cols = len(grid), len(grid[0]) def dfs(x, y, steps_remaining): if steps_remaining == 0: return grid[x][y] max_ones_collected = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] original_value = grid[x][y] grid[x][y] = -1 # Mark the cell as visited for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != -1: max_ones_collected = max(max_ones_collected, dfs(nx, ny, steps_remaining - 1)) grid[x][y] = original_value # Restore the original value return max_ones_collected + original_value max_ones_overall = 0 for i in range(rows): for j in range(cols): if steps == 0: max_ones_overall = max(max_ones_overall, grid[i][j]) else: max_ones_collected = dfs(i, j, steps) max_ones_overall = max(max_ones_overall, max_ones_collected) return max_ones_overall"},{"question":"You are given a string `s` consisting of lowercase English letters. We want to construct a new string by reorganizing the characters so that no two adjacent characters are the same. Return _the reorganized string_. If it is not possible to reorganize the string in such a way, return an **empty** string. The input string `s` can be arranged to ensure that there are no adjacent characters that are the same only if no character occurs more than `(len(s) + 1) // 2` times.","solution":"import heapq from collections import Counter def reorganize_string(s): Returns a reorganized string where no two adjacent characters are the same. If it\'s not possible to reorganize, returns an empty string. # Counter to count frequency of each character count = Counter(s) max_count = (len(s) + 1) // 2 if any(freq > max_count for freq in count.values()): return \\"\\" # Max-heap to store characters with their frequencies as negative values max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \'\' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char return \'\'.join(result)"},{"question":"You are given an array of integers `arr` and an integer `val`. Write a function that moves all instances of `val` in `arr` to the end of the array while maintaining the relative order of the other elements. Return the modified array. Do this in-place without making a copy of the array.","solution":"def move_element_to_end(arr, val): Moves all instances of val in arr to the end of the array while maintaining the relative order of the other elements. Args: arr (list of int): The array of integers. val (int): The value to move to the end of the array. Returns: list of int: The modified array with all instances of val moved to the end. last_non_val_index = 0 for i in range(len(arr)): if arr[i] != val: arr[last_non_val_index], arr[i] = arr[i], arr[last_non_val_index] last_non_val_index += 1 return arr"},{"question":"You are given a list of non-negative integers `nums` and an integer `s`. Find the **longest** contiguous subarray such that the product of all the elements in this subarray is less than `s`. Return the **length** of this subarray. If no such subarray exists, return `0`.","solution":"def longest_subarray_with_product_less_than_s(nums, s): Returns the length of the longest contiguous subarray where the product of its elements is less than s. if s <= 1: return 0 product = 1 left = 0 max_length = 0 for right in range(len(nums)): product *= nums[right] while product >= s and left <= right: product //= nums[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of **only** the letters `\'X\'` and `\'O\'`. An **island** is a group of `\'X\'`s connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Return _the number of islands_ in the grid.","solution":"def num_islands(grid): Returns the number of islands in the grid. :param grid: List[List[str]] : 2D grid containing \'X\' and \'O\' :return: int: Number of islands in the grid if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): if (r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == \'O\' or (r, c) in visited): return visited.add((r, c)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: dfs(r + dr, c + dc) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'X\' and (r, c) not in visited: island_count += 1 dfs(r, c) return island_count"},{"question":"Given an array of integers `arr` and an integer `k`, return the maximum possible value of the minimum value of each subarray of length `k`. In other words, divide the array into subarrays of length `k` and find the minimum value in each subarray, then return the maximum value among these minimum values. If the array cannot be divided into subarrays of exactly length `k`, return `-1`.","solution":"def max_min_of_subarrays(arr, k): Returns the maximum possible value of the minimum value in each subarray of length `k`. Parameters: arr (list): A list of integers. k (int): Length of each subarray. Returns: int: Maximum value of the minimum values of subarrays of length `k`, or -1 if not possible. # Edge case: If k is larger than the length of array, return -1 if k > len(arr): return -1 # List to store minimum values of each subarray mins = [] # Traverse the array for i in range(len(arr) - k + 1): # Find the minimum value of the current subarray min_val = min(arr[i:i + k]) mins.append(min_val) # Return the maximum value among the minimum values return max(mins)"},{"question":"You are given an array `arr` of integers, where some elements appear twice and others appear once. Return _an array of all the integers that appear only **once**_. Each element in the result must appear as it did in the original array. You must solve this problem with a linear runtime complexity and use only constant extra space.","solution":"def find_unique_elements(arr): Returns a list of elements that appear only once in the array. :param arr: List of integers with some elements appearing twice and some once. :return: List of integers that appear only once in the same order as they appear in the input array. # Creating a dictionary to store count of each element element_count = {} for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 # Creating a list to store elements that appear only once unique_elements = [num for num in arr if element_count[num] == 1] return unique_elements"},{"question":"Given a string `word` and a string `letters`, return `true` if `word` can be formed using the characters in `letters` and `false` otherwise. Each character in `letters` can only be used once.","solution":"def can_form_word(word, letters): Returns True if `word` can be formed using characters from `letters`, otherwise returns False. Each character in `letters` can only be used once. from collections import Counter word_counter = Counter(word) letters_counter = Counter(letters) for char in word_counter: if word_counter[char] > letters_counter.get(char, 0): return False return True"},{"question":"Given a list of `n` integers `arr`, find a subset of the integers such that the sum of the subset\'s elements is as close as possible to a given number `S` without exceeding it. Return the subset with the elements in sorted order. Note that all integers are distinct. If there are multiple subsets with the same sum, return the one with the smallest number of elements. If there are still multiple solutions, return any of them.","solution":"def find_subset(arr, S): Finds a subset of the integers such that the sum of the subset\'s elements is as close as possible to a given number `S` without exceeding it. Returns the subset with the elements in sorted order. All integers are distinct. This function uses dynamic programming to solve the problem. n = len(arr) dp = [0] * (S + 1) parent = [-1] * (S + 1) # Sort the array to process elements in a sorted order. arr.sort() for num in arr: for j in range(S, num - 1, -1): if dp[j] < dp[j - num] + num: dp[j] = dp[j - num] + num parent[j] = num closest_sum = max(range(S + 1), key=lambda x: dp[x]) subset = [] while closest_sum > 0 and parent[closest_sum] != -1: subset.append(parent[closest_sum]) closest_sum -= parent[closest_sum] return sorted(subset)"},{"question":"You are given an integer `n` and a 2D list `matrix` of size `n x n` where each element is either `1` (indicating land) or `0` (indicating water). An island is a group of adjacent lands connected horizontally or vertically. Write a function that returns the **number of distinct islands** in the `matrix`.","solution":"def num_islands(matrix): if not matrix: return 0 n = len(matrix) visited = [[False]*n for _ in range(n)] def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= n or matrix[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) count = 0 for i in range(n): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"Mike is training for a marathon and practices on a long straight road consisting of consecutive mile markers numbered from 1 to n. He wants to run a total of `k` miles, but he prefers routes that avoid running the same segment more than once. As a result, he has decided to only choose segments of the road such that the distance between the starting marker and the ending marker is exactly `k` miles. Given the total number of mile markers `n` and the distance `k`, determine the number of distinct starting mile markers Mike can choose from. Note that the starting mile marker must be between 1 and `n-k` inclusive. Return the count of such valid starting mile markers.","solution":"def count_start_markers(n, k): Given n mile markers and the distance k, return the number of distinct starting mile markers so that the distance between the starting and ending marker is exactly k miles. Parameters: n (int): The total number of mile markers. k (int): The distance of the route in miles. Returns: int: The count of valid starting mile markers. # Check the difference between the total mile markers and the distance if k >= n: return 0 return n - k"},{"question":"You are given a `2D` grid of size `m x n` representing a map where `1` represents land and `0` represents water. A **lake** is defined as a connected group of `0`s (horizontal or vertical). You need to find the size of the largest lake present in the grid (the number of `0`s in the largest connected group). Return _the size of the largest lake in the grid_. If there are no lakes, return `0`.","solution":"def largest_lake(grid): Returns the size of the largest lake in the grid. A lake is a connected group of 0\'s (horizontal or vertical). :param grid: List of lists representing the 2D grid :return: Size of the largest lake if not grid: return 0 m, n = len(grid), len(grid[0]) visited = set() def dfs(x, y): if (x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0 or (x, y) in visited): return 0 visited.add((x, y)) size = 1 # Current cell is part of the lake size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size largest_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 0 and (i, j) not in visited: lake_size = dfs(i, j) largest_size = max(largest_size, lake_size) return largest_size"},{"question":"Given an array of integers `arr`, return the smallest integer that is not present in the array. The array may contain duplicates and can include negative numbers. Your solution should run in O(n) time complexity.","solution":"def smallest_missing_integer(arr): Returns the smallest integer that is not present in the array # Filtering out non-positive integers and creating a set of the array elements positive_set = set(num for num in arr if num > 0) # Starting from 1, check the smallest missing positive integer smallest_missing = 1 while smallest_missing in positive_set: smallest_missing += 1 return smallest_missing"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. An **arithmetic slice** of `arr` is a subarray of at least length 3 and has a common difference between consecutive elements such that `arr[i+1] - arr[i] == arr[i+2] - arr[i+1]`. Return _the number of arithmetic slices in the array_ `arr`.","solution":"def number_of_arithmetic_slices(arr): Returns the number of arithmetic slices in the array arr. n = len(arr) if n < 3: return 0 count = 0 current_len = 0 # This will track the length of the current arithmetic slice for i in range(2, n): if arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]: current_len += 1 count += current_len # Add the current length, which determines the number of new slices ending at i else: current_len = 0 # Reset if the current sequence breaks return count"},{"question":"You are given a `list of integers` named `nums`. You can perform the following operation any number of times: - Choose any two adjacent elements in the list and swap them. Determine the minimum number of such swaps required to sort the list in non-decreasing order. Return _the minimum number of swaps needed to sort `nums`_.","solution":"def min_swaps_to_sort(nums): Calculates and returns the minimum number of swaps required to sort the list in non-decreasing order. n = len(nums) sorted_nums = sorted(nums) index_dict = {value: idx for idx, value in enumerate(nums)} swaps = 0 for i in range(n): while nums[i] != sorted_nums[i]: swap_idx = index_dict[sorted_nums[i]] nums[i], nums[swap_idx] = nums[swap_idx], nums[i] index_dict[nums[swap_idx]] = swap_idx index_dict[nums[i]] = i swaps += 1 return swaps"},{"question":"You are given two integers `m` and `n`, representing the dimensions of a grid. You are also given an array `positions` where each position is a pair of integers `[r, c]` representing the coordinates of each cell that needs to be filled in the grid. Initially, the grid is empty and only the positions mentioned in the array are to be filled to create islands. An island is a group of 1\'s (filled cells) connected 4-directionally (horizontal or vertical). After each given position is added to the grid, return the number of islands formed. You must complete this process after adding every position in the given `positions` array. Create a function that returns the list of the number of islands after each addition from the `positions` array.","solution":"def numIslands2(m, n, positions): Returns the number of islands after each addition of positions. def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootx = find(parent, x) rooty = find(parent, y) if rootx != rooty: if rank[rootx] > rank[rooty]: parent[rooty] = rootx elif rank[rootx] < rank[rooty]: parent[rootx] = rooty else: parent[rooty] = rootx rank[rootx] += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] parent = {} rank = {} island_count = 0 result = [] for r, c in positions: if (r, c) in parent: result.append(island_count) continue parent[(r, c)] = (r, c) rank[(r, c)] = 0 island_count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if (nr, nc) in parent: if find(parent, (nr, nc)) != find(parent, (r, c)): union(parent, rank, (nr, nc), (r, c)) island_count -= 1 result.append(island_count) return result"},{"question":"Given a binary tree, return an array representing the level order traversal of its nodes\' values.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"You are given a string `s` consisting of **lowercase alphabets**. A character in the string can be classified as `happy` if there is a **same** character to its **left** or **right**. Your task is to determine whether **all** characters in the string `s` are `happy` or not. If they are, return `True`; otherwise, return `False`.","solution":"def are_all_characters_happy(s): Returns whether all characters in the string `s` are happy or not. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: bool: True if all characters are happy, False otherwise. n = len(s) for i in range(n): if (i > 0 and s[i] == s[i-1]) or (i < n-1 and s[i] == s[i+1]): continue return False return True"},{"question":"Given an array of integers `nums` and an integer `m`, you need to determine if you can split the array into `m` non-empty continuous subarrays, such that the largest sum of any subarray is minimized. Return _the minimized value of the largest sum of the `m` subarrays_.","solution":"def splitArray(nums, m): def can_split(nums, m, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `n` airports `airports` and a list of `m` one-way flights `flights` where `flights[i]` is a tuple `(a, b)` representing a flight from airport `a` to airport `b`. You are also given an integer `k`. Define the **reachability count** of an airport as the number of other airports that can be reached from that airport within `k` flights. Return an array of length `n` where the `i-th` element is the **reachability count** of the `i-th` airport in the given list `airports`.","solution":"from collections import deque, defaultdict def reachability_count(airports, flights, k): n = len(airports) graph = defaultdict(list) # Construct adjacency list for a, b in flights: graph[a].append(b) def bfs(start): queue = deque([(start, 0)]) visited = set() reach_count = 0 while queue: current, depth = queue.popleft() if current in visited or depth > k: continue visited.add(current) if depth > 0: reach_count += 1 for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, depth + 1)) return reach_count reachability_counts = [] for airport in airports: reachability_counts.append(bfs(airport)) return reachability_counts"},{"question":"Implement a task scheduling system that helps organize and manage tasks with specific dependencies. Each task has a unique integer identifier and can depend on the completion of other tasks. Your goal is to determine an order in which all tasks can be completed, given their dependencies. If it is impossible to complete all tasks due to a cyclical dependency, return an empty list. Implement the `TaskScheduler` class: * `void addTask(int taskId)` Adds a new task with the given `taskId` if it doesn\'t already exist. * `void addDependency(int fromTaskId, int toTaskId)` Adds a dependency from `fromTaskId` to `toTaskId`, meaning that `toTaskId` cannot be started until `fromTaskId` is completed. * `List<Integer> getExecutionOrder()` Returns a list representing the order in which tasks should be executed. If it is not possible to complete all tasks due to a cyclical dependency, return an empty list.","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): self.tasks = set() self.dependencies = defaultdict(list) self.in_degrees = defaultdict(int) def addTask(self, taskId: int): if taskId not in self.tasks: self.tasks.add(taskId) self.in_degrees[taskId] = 0 def addDependency(self, fromTaskId: int, toTaskId: int): if fromTaskId in self.tasks and toTaskId in self.tasks: self.dependencies[fromTaskId].append(toTaskId) self.in_degrees[toTaskId] += 1 def getExecutionOrder(self): queue = deque([task for task in self.tasks if self.in_degrees[task] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for dependent in self.dependencies[current]: self.in_degrees[dependent] -= 1 if self.in_degrees[dependent] == 0: queue.append(dependent) if len(order) == len(self.tasks): return order else: return []"},{"question":"Given an array of integers `heights` representing the height of buildings, return the maximum number of buildings that have an unobstructed view to the west. A building has an unobstructed view if there are no taller buildings to its left.","solution":"def max_unobstructed_views(heights): Given an array of integers `heights` representing the height of buildings, return the maximum number of buildings that have an unobstructed view to the west. A building has an unobstructed view if there are no taller buildings to its left. # Initialize max_height to zero and count to zero max_height = 0 count = 0 # Iterate through the buildings from left to right for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given an integer array `arr` of length `n` representing positions of `n` stones placed in a row. You are also given a starting position denoted by array index `start`. You want to determine the minimum number of jumps needed to reach the end of the row where a stone is placed. Each jump can either move right to a stone located at most `k` positions away or can involve skipping over exactly `k` positions to another stone. If it is not possible to reach the end, return -1. Write a function to solve this problem and return the minimum number of jumps needed to reach the end or `-1` if it is not possible.","solution":"from collections import deque def min_jumps_to_end(arr, start, k): Determines the minimum number of jumps to reach the end of the array where stones are placed or -1 if not possible. Parameters: arr (list of int): Positions of the stones. start (int): Starting position. k (int): Maximum allowed jump distance. Returns: int: Minimum number of jumps to reach the end or -1 if not possible. n = len(arr) if start >= n: return -1 # Early exit if already at the end if start == n - 1: return 0 queue = deque([(start, 0)]) # (current position, current jumps) visited = set([start]) while queue: current, jumps = queue.popleft() for i in range(current + 1, min(current + k + 1, n)): if i not in visited and arr[i] == 1: if i == n - 1: return jumps + 1 queue.append((i, jumps + 1)) visited.add(i) return -1"},{"question":"You are given a list of integers `nums` where each integer is in the range from `1` to `n` inclusive and appears exactly once, except for one integer that appears twice, and one integer that is missing from the list. Return an array of two elements: the first element is the integer that appears twice, and the second element is the integer that is missing. Ensure your algorithm runs in linear time and uses only constant extra space.","solution":"def find_error_nums(nums): Returns the duplicated integer and the missing integer in the list. n = len(nums) sum_n = n * (n + 1) // 2 # Sum of first \'n\' natural numbers sum_nums = sum(nums) # Sum of the numbers in the list sum_set_nums = sum(set(nums)) # Sum of unique numbers in the list duplicate = sum_nums - sum_set_nums missing = sum_n - sum_set_nums return [duplicate, missing]"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. A building with height `heights[i]` can trap water if there are taller buildings on both its left and right side. The trapped water\'s amount for building `i` is min(maxLeft[i], maxRight[i]) - heights[i], where `maxLeft[i]` is the maximum height on the left of building `i` and `maxRight[i]` is the maximum height on the right. Write a function that returns the total volume of water trapped between buildings after it rains.","solution":"def trap_water(heights): Returns the total amount of water that can be trapped between buildings after it rains. :param heights: List[int] :return: int if not heights: return 0 n = len(heights) max_left = [0] * n max_right = [0] * n max_left[0] = heights[0] for i in range(1, n): max_left[i] = max(max_left[i-1], heights[i]) max_right[n-1] = heights[n-1] for i in range(n-2, -1, -1): max_right[i] = max(max_right[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(max_left[i], max_right[i]) - heights[i] return water_trapped"},{"question":"Given an array of integers `nums`, return the length of the longest subsequence that can be derived by deleting some or no elements such that the elements appear in **non-decreasing order**. Note that \\"subsequence\\" refers to a sequence obtained by deleting some or no elements without changing the order of the remaining elements. For example, given the array `nums = [10, 9, 2, 5, 3, 7, 101, 18]`, the longest subsequence in non-decreasing order is `[2, 3, 7, 18]`, so the function should return `4`.","solution":"def length_of_longest_non_decreasing_subsequence(nums): Returns the length of the longest subsequence that can be derived by deleting some or no elements such that the elements appear in non-decreasing order. Parameters: nums (List[int]): A list of integers. Returns: int: The length of the longest non-decreasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] will be the length of the longest subsequence that ends with nums[i] for i in range(1, n): for j in range(i): if nums[i] >= nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a **0-indexed** integer array `arr`, you need to perform the following operations exactly once: 1. Divide the array into two contiguous non-empty subarrays `left` and `right`. 2. Compute the sum of elements in both subarrays. 3. Find the absolute difference between the sums of `left` and `right`. Return the **minimum absolute difference** achievable from any possible division of the array.","solution":"def min_absolute_difference(arr): Returns the minimum absolute difference between the sums of two contiguous non-empty subarrays. # Compute the total sum of the array total_sum = sum(arr) # Initialize left sum to 0 and minimum absolute difference to a large value left_sum = 0 min_abs_diff = float(\'inf\') # Iterate through the array to find the point of division for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum min_abs_diff = min(min_abs_diff, abs(left_sum - right_sum)) return min_abs_diff"},{"question":"You are given an array of integers `candies` where `candies[i]` represents the number of candies in the `i-th` pile. Each day, you can choose one pile of candies and eat a certain number of candies from it. The number of candies you eat from a chosen pile on a particular day must be chosen according to the rule: you can eat `1`, `2`, or `k` (where `k` is any integer) candies, as long as `k` candies are less than the total number in that pile on that day. After you eat candies from a pile, if there are any candies left, you move on to the next day. Return _the minimum number of days required to eat all the candies in all piles_.","solution":"def min_days_to_eat_all_candies(candies): Returns the minimum number of days required to eat all the candies in all piles where on each day you can eat 1, 2, or k (k < current pile size) candies from one chosen pile. days = 0 for pile in candies: days += pile return days"},{"question":"You are given a list of integers `arr` and an integer `x`. A **distance** between two integers `a` and `b` is defined as the absolute difference `|a - b|`. Your task is to return the **minimum** sum of distances between `x` and all integers in the list `arr`.","solution":"def min_sum_of_distances(arr, x): Returns the minimum sum of distances between an integer x and all integers in the list arr. return sum(abs(a - x) for a in arr)"},{"question":"A **special subsequence** of a string is a subsequence where no two consecutive characters are the same. Given a string `s`, return the length of the longest special subsequence of `s`.","solution":"def longest_special_subsequence(s): Returns the length of the longest special subsequence of s where no two consecutive characters are the same. if not s: return 0 # Initialize length of longest special subsequence longest_length = 1 prev_char = s[0] for char in s[1:]: if char != prev_char: longest_length += 1 prev_char = char return longest_length"},{"question":"You are given a string `s` consisting of lowercase English letters and the character `#` which acts as a backspace. The task is to determine the final string after processing all the backspaces: - Iterate through the string from left to right. - For each `#` encountered, remove the character before it (if any). - Remove the `#` itself. Return the final processed string. For example, given the input string `s = \\"a#bc#d\\"`, the output should be `\\"bd\\"`.","solution":"def process_backspaces(s): Processes a string with backspace characters (#) and returns the final string. Args: s (str): The input string containing lowercase English letters and \'#\' character. Returns: str: The processed string after removing characters as specified by backspaces. result = [] for char in s: if char == \'#\': if result: result.pop() # Remove the last character in result if it\'s not empty else: result.append(char) # Add current character to result return \'\'.join(result)"},{"question":"You are given an array `tasks` where `tasks[i] = [starti, endi, efficiencyi]` represents a task that starts at `starti`, ends at `endi`, and has an `efficiencyi` value associated with it. You are also given an integer `maxTasks` which represents the maximum number of tasks that can be processed. You need to schedule these tasks in such a way that the total efficiency of the processed tasks is maximized without overlapping any tasks. Note that a task is considered non-overlapping with another if the end time of one task is less than or equal to the start time of the other. Return the **maximum total efficiency** that can be achieved by scheduling at most `maxTasks` without any overlap.","solution":"def maxEfficiency(tasks, maxTasks): from functools import lru_cache # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) @lru_cache(None) def dp(i, k): if i < 0 or k == 0: return 0 # Do not include i-th task max_eff = dp(i - 1, k) # Find the last non-conflicting task j = i - 1 while j >= 0 and tasks[j][1] > tasks[i][0]: j -= 1 # Include i-th task max_eff = max(max_eff, tasks[i][2] + dp(j, k - 1)) return max_eff return dp(len(tasks) - 1, maxTasks)"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of students standing in a line. Each student `i` can see the student immediately in front of them if `heights[i] < heights[i+1]`. Write an algorithm to calculate the number of students who can see the student immediately in front of them. Return _the total count of such students_.","solution":"def count_students_that_see_next(heights): Returns the number of students who can see the student immediately in front of them. count = 0 for i in range(len(heights) - 1): if heights[i] < heights[i + 1]: count += 1 return count"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return _all possible sentences_ you can form by concatenating words from the `wordDict` such that each word is used exactly once. Each word in the dictionary can only be used once in the sentence. Formed sentences should be space-separated sequences of dictionary words. Return the sentences in **any order**. *Example*: If `s = \\"catsanddog\\"` and `wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]`, a possible output is `[\\"cat sand dog\\", \\"cats and dog\\"]`.","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> List[str]: def backtrack(start): if start == len(s): return [[]] # return empty list as part of the recursive call if start in memo: return memo[start] result = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in wordDict: for sub_sentence in backtrack(end): result.append([word] + sub_sentence) memo[start] = result return result word_set = set(wordDict) memo = {} sentences = backtrack(0) return [\' \'.join(sentence) for sentence in sentences]"},{"question":"You have a list of integers `heights` representing the height of buildings along a straight line. Each `heights[i]` is a building of height `heights[i]` meters located at position `i`. You want to process this list to determine the number of buildings that have a clear view to the west. A building has a clear view to the west if all the buildings to its left are shorter than it. Return _the total number of buildings that have a clear view to the west_.","solution":"def count_buildings_with_west_view(heights): Return the number of buildings with a clear view to the west. A building has a clear view to the west if all the buildings to its left are shorter than it. :param heights: List of integers representing the height of buildings. :return: Integer representing the number of buildings with a clear view to the west. count = 0 current_max = float(\'-inf\') for height in heights: if height > current_max: count += 1 current_max = height return count"},{"question":"You are given an integer array `heights` representing the heights of buildings in a skyline. The array is indexed from `0` to `n-1`, where `n` is the number of buildings. The pandemic has caused some buildings to disappear, leaving gaps in the skyline. Your task is to determine the maximum rectangular area that can be formed using the heights of these buildings, where the rectangle spans one or more consecutive buildings and the height of the rectangle is the height of the shortest building within those boundaries. Return the area of the largest rectangle in the skyline.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the skyline. Args: heights (list[int]): List of integers representing building heights. Returns: int: Largest rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a grid representing a city map where each cell is a building denoted by \'B\' or an empty space denoted by \'E\'. The grid consists of `n` rows and `m` columns. You can build a special underground tunnel network that connects any two buildings \'B\'. The network can move left, right, up, or down and passes through empty spaces \'E\'. The cost of the network is the number of empty spaces \'E\' it goes through. Given the grid, return the minimum cost required to connect any two buildings, or return `-1` if it is not possible to connect any two buildings. The input grid is represented by a 2D array `grid` where `grid[i][j]` is either \'B\' or \'E\'.","solution":"from collections import deque def min_tunnel_cost(grid): Returns the minimum cost required to connect any two buildings in the grid through empty spaces \'E\', or -1 if it is not possible. n, m = len(grid), len(grid[0]) buildings = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == \'B\'] if len(buildings) < 2: return -1 def bfs(start): visited = [[False] * m for _ in range(n)] queue = deque([(start[0], start[1], 0)]) # (i, j, cost) visited[start[0]][start[1]] = True while queue: i, j, cost = queue.popleft() for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: if 0 <= x < n and 0 <= y < m and not visited[x][y]: if grid[x][y] == \'B\': return cost if grid[x][y] == \'E\': visited[x][y] = True queue.append((x, y, cost + 1)) return float(\'inf\') min_cost = float(\'inf\') for building in buildings: min_cost = min(min_cost, bfs(building)) return -1 if min_cost == float(\'inf\') else min_cost"},{"question":"Given a sorted array of `n` integers `arr` and a positive integer `k`, find the `k`-th smallest element in the array such that the element is unique in the array. If there are fewer than `k` unique elements, return `-1`.","solution":"def kth_unique_element(arr, k): Returns the k-th unique element in the sorted array `arr`. If there are fewer than k unique elements, returns -1. unique_elements = [] # to store unique elements n = len(arr) # Traverse sorted array arr and collect unique elements for i in range(n): if (i == 0 or arr[i] != arr[i-1]) and (i == n-1 or arr[i] != arr[i+1]): unique_elements.append(arr[i]) if len(unique_elements) < k: return -1 return unique_elements[k-1]"},{"question":"Given an `m x n` grid `grid` of integers, a **path** from the top-left to the bottom-right corner is any sequence of cells such that you only move down or right at any point in time. The **minimum path sum** from top-left to bottom-right is the sum of the values of the cells along the path. Write a function that returns the minimum path sum. You may assume that `m` and `n` will be at least 1.","solution":"def minPathSum(grid): Calculates the minimum path sum from top-left to bottom-right in a grid. :param grid: List[List[int]], the input grid of integers :return: int, the minimum path sum m = len(grid) n = len(grid[0]) # Initialize dp table for i in range(1, n): grid[0][i] += grid[0][i - 1] for i in range(1, m): grid[i][0] += grid[i - 1][0] # Fill the dp table for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"You are given an array of integers `arr` where `arr[i]` represents the height of plant `i` in a garden. You can perform the following operation as many times as necessary: choose two adjacent plants, and if their difference in height is greater than or equal to `d`, prune the taller plant to be exactly `d` units taller than the shorter plant (though you don\'t have to prune it if it\'s already within the limit). Return the _minimum number of prunes necessary_ to ensure that the height difference between every pair of adjacent plants is less than `d`.","solution":"def min_prunes_to_ensure_height_difference(arr, d): Returns the minimum number of prunes necessary to ensure that the height difference between every pair of adjacent plants is less than d. prunes = 0 for i in range(len(arr) - 1): while arr[i+1] - arr[i] >= d: arr[i+1] = arr[i] + d - 1 prunes += 1 return prunes"},{"question":"Write a function that takes a positive integer `n` and returns a list of all the factorial numbers (i.e., numbers that are the factorial of integers) less than or equal to `n`. A number is considered a factorial number if it can be written as `k!` where `k` is a non-negative integer. The factorial of a non-negative integer `k` is `k! = k * (k - 1) * (k - 2) * ... * 1` with `0! = 1`.","solution":"def factorial_numbers(n): Returns a list of all factorial numbers less than or equal to n. if n < 1: return [] factorials = [] i = 1 fact = 1 while fact <= n: factorials.append(fact) i += 1 fact *= i return factorials"},{"question":"Given an array of integers `arr` and an integer `k`, return the number of subarrays (continuous subarrays) in which the difference between the maximum and minimum element is at most `k`. A subarray is a contiguous non-empty sequence of elements within an array.","solution":"def subarrays_within_range(arr, k): Returns the number of subarrays in which the difference between the maximum and minimum element is at most k. n = len(arr) count = 0 for i in range(n): min_val = arr[i] max_val = arr[i] for j in range(i, n): min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if max_val - min_val <= k: count += 1 else: break return count"},{"question":"Given an integer array `points` representing the coordinates of points on a number line, return the **minimum number of moves** required to make all the points equal. A move involves incrementing or decrementing a point by 1. Each move changes a single point by one unit at a time.","solution":"def min_moves_to_equal_points(points): Given an integer array points, return the minimum number of moves required to make all the points equal. A move involves incrementing or decrementing a point by 1. Parameters: points (list): List of integer coordinates on a number line. Returns: int: Minimum number of moves required. # To minimize the moves, choose the median of the coordinates, # as the median minimizes the sum of absolute deviations. points.sort() median = points[len(points) // 2] # Calculate total moves required to bring all points to the median moves = sum(abs(point - median) for point in points) return moves"},{"question":"You are given a list of `n` integers representing the heights of students standing in a line from left to right. Your task is to determine the number of students that are visible from the right side of the line. A student is visible if their height is greater than all the students standing to their right. Return the number of visible students from the right side of the line.","solution":"def count_visible_students(heights): Returns the count of students visible from the right. if not heights: return 0 count = 1 max_height = heights[-1] for height in reversed(heights[:-1]): if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a **calendar** that can store events on specific dates and also perform some operations like adding, deleting, and fetching events. Implement the `Calendar` class: * `Calendar()` Initializes the calendar with no events. * `void addEvent(String date, String event)` Adds an `event` on the given `date`. If there are already existing events on that date, the new event is added to the list of events for that date. * `void removeEvent(String date, String event)` Removes a specific `event` on the given `date`. If the event does not exist on the given date, do nothing. * `List<String> getEvents(String date)` Returns a list of all events on the given `date`. If there are no events on that date, return an empty list. Note that the `date` will be represented as a string in the format \\"YYYY-MM-DD\\".","solution":"class Calendar: def __init__(self): self.calendar = {} def addEvent(self, date, event): if date not in self.calendar: self.calendar[date] = [] self.calendar[date].append(event) def removeEvent(self, date, event): if date in self.calendar: if event in self.calendar[date]: self.calendar[date].remove(event) if not self.calendar[date]: # Remove the date if no events left del self.calendar[date] def getEvents(self, date): if date in self.calendar: return self.calendar[date] return [] # Example usage: # cal = Calendar() # cal.addEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") # cal.addEvent(\\"2023-10-10\\", \\"Meeting\\") # cal.removeEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") # events = cal.getEvents(\\"2023-10-10\\")"},{"question":"You are given an array of integers `nums`, and an integer `k`. We want to create the largest possible number by concatenating the integers in `nums` (in any order). However, you can only use exactly `k` elements from `nums`. Return the largest possible number as a string representation. Example: - Input: nums = [3, 30, 34, 5, 9], k = 2 - Output: \\"95\\" Note: The result must be a string, not an integer, as the concatenated number can be very large.","solution":"from functools import cmp_to_key def largestNumber(nums, k): def compare(x, y): # Compare concatenations of the two numbers in both possible orders if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all numbers to strings for concatenation comparison nums_str = list(map(str, nums)) # Sort the numbers based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Take the first k numbers from the sorted list top_k = nums_str[:k] # Return the concatenated result, ensuring it is a string return \'\'.join(top_k)"},{"question":"You are given an array of `intervals` where `intervals[i] = [start_i, end_i]` represent intervals on a timeline. A new interval is inserted into the list and might overlap with existing intervals. Merge all the overlapping intervals and return the list of intervals in sorted order by their start points.","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals. if not intervals: return [] # Sort the intervals by the starting point intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or if there is no overlap with the last interval in merged if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is an overlap, merge the current interval merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"You are given a list of integers `nums` which represent the heights of buildings in a city skyline from left to right. A building\'s height can hold up to that many units of water above it. You are also given an integer `rainAmount` that represents the total amount of water from a rainfall. Your task is to determine how much water each building will hold after the rainfall, assuming that water can overflow from one building to another but cannot spill over the edges of the city skyline. If a building is taller than the amount of water above it, it will not hold additional water exceeding its height. Return an array of integers representing the amount of water above each building after the rainfall.","solution":"def calculate_water_levels(nums, rainAmount): Returns an array of water levels above each building after the rainfall. n = len(nums) water = [0] * n total_capacity = sum(nums) # if rainAmount is more than the total_capacity, set rainAmount to total_capacity rainAmount = min(rainAmount, total_capacity) while rainAmount > 0: for i in range(n): if rainAmount > 0: # find the minimum capacity the building can hold min_capacity = min(nums[i] - water[i], rainAmount) # update the water held water[i] += min_capacity # decrease the rainAmount rainAmount -= min_capacity return water"},{"question":"You are given an array `arrival` representing the arrival times of trains at a station (in minutes from midnight) and an array `departure` representing the departure times of those trains. The task is to find the minimum number of platforms required at the station so that no train has to wait. Implement the function `minimumPlatformsRequired(arrival: List[int], departure: List[int]) -> int` to solve the problem.","solution":"def minimumPlatformsRequired(arrival, departure): Returns the minimum number of platforms required at the station so that no train has to wait. if not arrival or not departure: return 0 arrival.sort() departure.sort() n = len(arrival) platforms_needed = 1 max_platforms = 1 i = 1 j = 0 while (i < n and j < n): if arrival[i] <= departure[j]: platforms_needed += 1 i += 1 if platforms_needed > max_platforms: max_platforms = platforms_needed else: platforms_needed -= 1 j += 1 return max_platforms"},{"question":"You are given a list of tasks represented by characters and an integer `n` representing the cooldown period between the same tasks. The objective is to find the minimum time required to complete all tasks. Each task takes 1 unit of time and must be performed one at a time. The cooldown period `n` dictates that the same task can only be executed again after at least `n` units of time have passed since its last execution. If there are no tasks available to execute during the cooldown period, remain idle. * Example: Tasks: `[\'A\', \'A\', \'A\', \'B\', \'B\', \'B\']`, `n = 2` Minimum time required: 8 (Sequence: A -> B -> idle -> A -> B -> idle -> A -> B) Return _the minimum time required to complete all tasks_ based on the given constraints.","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum time required to complete all tasks given the cooldown period `n`. task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = list(task_counts.values()).count(max_count) part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"You are given an array of integers `heights` representing the heights of students in a class. You need to arrange them in a non-decreasing order. Return the minimum number of changes required to turn `heights` into a non-decreasing order array. A change consists of moving one student to a different place in the array. For example, given `heights = [5, 3, 4, 2, 1]`, the answer should be 3, because we can move 3 to the first position, 4 to the second position, and 1 to the third position to get a non-decreasing order array: `[3, 4, 5, 2, 1]`. The minimum changes required will be 3.","solution":"def min_changes_to_sort_heights(heights): n = len(heights) if n == 0: return 0 sorted_heights = sorted(heights) # We will find the longest common subsequence (LCS) between heights and sorted_heights. # The minimum number of changes required will be the length of the array minus the length of the LCS. dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): if heights[i] == sorted_heights[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) lcs_length = dp[n][n] return n - lcs_length"},{"question":"Given an integer `num`, repeatedly add all its digits until the result has only one digit. For example: * If `num` is 38, you subtract 3 + 8 = 11, then 1 + 1 = 2. * If `num` is 123, you subtract 1 + 2 + 3 = 6. Return _the final single digit_ result.","solution":"def add_digits(num): Repeatedly add all digits of num until the result has only one digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"Given a `matrix` of integers where each row is sorted in ascending order and each column is sorted in ascending order, write a function to find _the kth smallest element in the matrix_.","solution":"def kth_smallest(matrix, k): Returns the kth smallest element in a sorted matrix. import heapq # Initialize a min-heap min_heap = [] # Push the first element of each row into the heap # Along with the row and column information for r in range(min(k, len(matrix))): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the smallest element from the heap k times number_count, number = 0, 0 while number_count < k: number, r, c = heapq.heappop(min_heap) number_count += 1 if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return number"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. A singly linked list is a linear data structure where each element (node) points to the next, and the last node points to null. Each node contains a value and a reference to the next node in the sequence. Maintain the list\'s structure while reversing the order of its elements.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list. :param head: ListNode, the head of the singly linked list. :return: ListNode, the head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given a 2D integer matrix `grid` where each cell contains a value, which represents the cost of passing through that cell. You can move in four possible directions: up, down, left, or right, but only to we could cells that have the same value. Your task is to determine if there exists a path from the top-left cell to the bottom-right cell such that all cells along the path have the same value. Implement the function `boolean isPath(int[][] grid)` that returns `true` if such a path exists, and `false` otherwise.","solution":"from collections import deque def is_path(grid): Determines if there exists a path from the top-left cell to the bottom-right cell such that all cells along the path have the same value. :param grid: List[List[int]] - 2D list of integers :return: bool - True if such a path exists, else False if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) target_value = grid[0][0] visited = set() directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(r, c): queue = deque([(r, c)]) visited.add((r, c)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == target_value: visited.add((nx, ny)) queue.append((nx, ny)) return False return bfs(0, 0)"},{"question":"Given an array of integers `arr`, find the maximum length of a subarray that contains only even numbers. Return the _maximum length if such a subarray exists_, otherwise return `0`.","solution":"def max_length_even_subarray(arr): Returns the maximum length of a subarray that contains only even numbers. If no such subarray exists, returns 0. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"You are given a **positive** integer `n` and an array `edges` where `edges[i] = [a, b]` represents a bidirectional edge between nodes `a` and `b`. The nodes range from `1` to `n`, and you need to determine if the graph is a **tree**. A tree is defined as a connected, acyclic graph. Return _`true`_ if the graph is a tree, otherwise return _`false`_.","solution":"def is_tree(n, edges): Determine if the given graph is a tree. :param n: int - Number of nodes. :param edges: List[List[int]] - List of bidirectional edges. :return: bool - True if the graph is a tree, otherwise False. if len(edges) != n - 1: return False from collections import defaultdict, deque adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) visited = set() def bfs(start_node): queue = deque([start_node]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in adj_list[node]: if neighbor not in visited: queue.append(neighbor) bfs(1) return len(visited) == n"},{"question":"You are given a binary string `s` which consists only of characters \'0\' and \'1\'. Your goal is to find the length of the longest contiguous subarray that contains an equal number of \'0\'s and \'1\'s. Implement a function that returns this length. If no such subarray exists, return 0.","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 0\'s and 1\'s. Parameters: nums (str): A binary string consisting of \'0\'s and \'1\'s. Returns: int: Length of the longest contiguous subarray with equal number of 0\'s and 1\'s. # Dictionary to store the first occurrence of each count count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): # Update count: +1 for 1 and -1 for 0 count += 1 if num == \'1\' else -1 if count in count_map: # If the count has been seen before, it means there is a subarray from # the previous index to the current index with equal number of 0\'s and 1\'s max_length = max(max_length, i - count_map[count]) else: # Otherwise, store the index for this count count_map[count] = i return max_length"},{"question":"You are given an array of positive integers `nums` representing the amount of money each house on a street has. There is a thief who wants to rob the maximum amount of money without alerting the police. The thief cannot rob two adjacent houses, as this would trigger an alarm. Write a function that determines the maximum amount of money the thief can rob without alerting the police. Return the maximum amount of money the thief can rob.","solution":"def rob(nums): Determine the maximum amount of money the thief can rob without alerting the police. :param nums: List[int] :return: int if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given an array of strings `words` representing a list of words. You need to find and return the longest word in `words` that can be constructed one character at a time by other words in `words`. If there are multiple possible results, return the one that is lexicographically smallest. If no word can be constructed, return an empty string. For example, given `words = [\\"w\\",\\"wo\\",\\"wor\\",\\"worl\\",\\"world\\"]`, the longest word that can be constructed is \\"world\\".","solution":"def longest_word(words): Find the longest word that can be built one character at a time by other words in words. :param words: List of strings :return: Longest word that can be built one character at a time words.sort() word_set, longest = set([\'\']), \'\' for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) > len(longest): longest = word return longest"},{"question":"You are given an array of integers `targets` and an integer `startPos`. An array element represents the target position you need to reach from `startPos`. You can perform the following operations: 1. Move to an adjacent position by adding or subtracting 1 from your current position. 2. Teleport to exactly the position `2 * startPos - currentPos`. Determine the minimum number of moves required to reach **each** target position from the array starting from `startPos`. Return an array of the minimum moves for each target position in the order they appear in `targets`.","solution":"from collections import deque def min_moves(targets, startPos): Determines the minimum number of moves required to reach each target position from startPos. def bfs(target): queue = deque([(startPos, 0)]) # (currentPos, currentMoves) visited = set([startPos]) while queue: currentPos, moves = queue.popleft() if currentPos == target: return moves # Move to adjacent positions next_positions = [currentPos + 1, currentPos - 1] # Teleport teleport_pos = 2 * startPos - currentPos next_positions.append(teleport_pos) for next_pos in next_positions: if next_pos not in visited: visited.add(next_pos) queue.append((next_pos, moves + 1)) return [bfs(target) for target in targets]"},{"question":"You are given a list of `n` integers, `arr`, representing the heights of `n` buildings in a row, where the `i-th` building has a height `arr[i]`. The rain water trapped between the buildings is defined as follows: for each building `i`, the amount of water that can be trapped on top of it is determined by the minimum of the highest buildings to its left and right, minus its own height. You need to find out the total volume of rain water that can be trapped in between these buildings. Return the total trapped rain water volume.","solution":"def trap_rain_water(heights): Returns the total amount of trapped rain water given the heights of buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped rain water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"Given an array of `n` integers, where each integer represents the power level of a superhero, you are required to form the Power Group. The Power Group is defined as the maximum contiguous subarray within the original array, such that the sum of the power levels in the subarray is less than or equal to a given integer `P`. Return the length of the longest Power Group that you can form.","solution":"def longest_power_group(arr, P): Returns the length of the longest contiguous subarray such that the sum of the subarray is less than or equal to P. max_len = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > P: current_sum -= arr[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given two strings `s1` and `s2`. You can delete characters from either string to make them equal. Design an algorithm that computes the minimum number of deletions required to make `s1` and `s2` the same. Return _the minimum number of deletions needed to make the two strings equal_.","solution":"def min_deletions_to_make_equal(s1, s2): Returns the minimum number of deletions required to make the two strings equal. m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp table (similar to LCS problem dynamic programming solution) for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of Longest Common Subsequence (LCS) lcs_length = dp[m][n] # Minimum deletions is total length of both strings minus twice the LCS length min_deletions = (m - lcs_length) + (n - lcs_length) return min_deletions"},{"question":"You are given `tasks`, an array of positive integers representing the duration of tasks you need to complete, and an integer `cooldown` representing the number of intervals that must pass before the same task can be executed again. Your goal is to find out the minimum intervals required to complete all tasks. Each interval can either be a task execution or an idle period. Return the minimum number of intervals needed to complete all tasks while respecting the cooldown restriction.","solution":"from collections import Counter def min_intervals(tasks, cooldown): Calculate the minimum intervals required to complete all tasks with a given cooldown period. :param tasks: List of integers representing task durations :param cooldown: Integer, cooldown periods required between same task :return: Integer, minimum intervals required to complete all tasks task_counts = Counter(tasks) max_frequency = max(task_counts.values()) max_count = sum(1 for task, count in task_counts.items() if count == max_frequency) intervals = (max_frequency - 1) * (cooldown + 1) + max_count return max(intervals, len(tasks))"},{"question":"You are organizing an art gallery exhibit which opens at `09:00` AM and closes at `06:00` PM every day. You are given several booking requests formatted as strings with the start and end times of each booking. Each booking request is represented by a pair of 24-hour formatted times (e.g., \\"13:00-15:00\\" represents a booking request from 1:00 PM to 3:00 PM). Write a function that takes a list of such booking strings and returns _the maximum number of non-overlapping bookings that can be scheduled within the gallery\'s operating hours._ If a booking request falls completely or partially outside the operating hours, it should be ignored.","solution":"def maximum_non_overlapping_bookings(bookings): Returns the maximum number of non-overlapping bookings within the gallery\'s operating hours. :param bookings: List of booking strings in the format \\"HH:MM-HH:MM\\" :return: Maximum number of non-overlapping bookings # Define gallery operating hours in minutes from 00:00 opening_time = 540 # 9:00 AM closing_time = 1080 # 6:00 PM # Convert booking times to minutes from 00:00 converted_bookings = [] for booking in bookings: start_str, end_str = booking.split(\'-\') start_time = int(start_str[:2]) * 60 + int(start_str[3:]) end_time = int(end_str[:2]) * 60 + int(end_str[3:]) if start_time >= opening_time and end_time <= closing_time: converted_bookings.append((start_time, end_time)) # Sort bookings by their end time converted_bookings.sort(key=lambda x: x[1]) # Select non-overlapping bookings count = 0 last_end_time = 0 for start, end in converted_bookings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"Given a binary tree where each node contains an integer value, consider a path defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The **path sum** of a path is the sum of the node values in the path. An **even-odd alternating path** is a path where the nodes have alternating even and odd values. For example, if a path contains nodes with values `[2, 3, 6]`, then it is considered an even-odd alternating path. Write a function to find the length of the longest even-odd alternating path in the given tree. The length of the path is defined as the number of nodes in the path. If there are no such paths, return 0. The function should take the root of the binary tree as input and return an integer representing the length of the longest even-odd alternating path.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_even_odd_alternating_path(root): def dfs(node, parent_value, path_length): if not node: return path_length # Check if current node continues the even-odd alternating path is_alternating = (node.val % 2) != (parent_value % 2) new_length = path_length + 1 if is_alternating else 1 # Debug: Print the path explored if is_alternating: print(f\\"Node {node.val} continues the alternating path. New length: {new_length}.\\") else: print(f\\"Node {node.val} does not alternate. Resetting path length.\\") # Traverse left and right children left_length = dfs(node.left, node.val, new_length) right_length = dfs(node.right, node.val, new_length) return max(new_length, left_length, right_length) return dfs(root, root.val ^ 1, 0) if root else 0"},{"question":"Given a list of `n` strings, where each string consists of lowercase alphabets, you need to group the anagrams together. Two strings are considered anagrams if they can be formed by rearranging the same characters. Return a list of lists, where each sublist is a group of anagram strings in no particular order. Consider the following example for better understanding: Example: Input: [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together from a list of strings. Parameters: strs (List[str]): List of strings. Returns: List[List[str]]: List of lists where each sublist contains anagrams. anagrams = defaultdict(list) for s in strs: # Sorting the string to find the anagrams sorted_str = \'\'.join(sorted(s)) anagrams[sorted_str].append(s) return list(anagrams.values())"},{"question":"Given an array of strings `words`, each string consisting of lowercase English letters, return _the number of pairs of distinct indices_ `(i, j)` _such that the concatenation of_ `words[i] + words[j]` _forms a palindrome_.","solution":"def is_palindrome(s): Check if the given string s is a palindrome. return s == s[::-1] def palindrome_pairs(words): Returns the number of pairs of distinct indices (i, j) such that the concatenation of words[i] + words[j] forms a palindrome. count = 0 n = len(words) for i in range(n): for j in range(n): if i != j and is_palindrome(words[i] + words[j]): count += 1 return count"},{"question":"Given a string `s` representing a sequence of characters from a programming language, remove all comments from the string. In the language, there are two types of comments: 1. Line comments, starting with `//` and ending at the end of the line. 2. Block comments, starting with `/*` and ending with `*/`. Return the string after removing all comments, ensuring that the code maintains its structure. Note that the string `s` may contain nested block comments, and you should handle any necessary string manipulations to correctly identify and remove comments.","solution":"def remove_comments(s): Removes line and block comments from the input string. Line comments start with // and end at the end of the line. Block comments start with /* and end with */ and can be nested. result = [] i = 0 n = len(s) while i < n: if s[i:i+2] == \'//\': i += 2 while i < n and s[i] != \'n\': i += 1 elif s[i:i+2] == \'/*\': nest_level = 1 i += 2 while i < n and nest_level > 0: if s[i:i+2] == \'/*\': nest_level += 1 i += 2 elif s[i:i+2] == \'*/\': nest_level -= 1 i += 2 else: i += 1 else: result.append(s[i]) i += 1 return \'\'.join(result)"},{"question":"A librarian needs a system to manage the collection of books in the library. Each `book` is represented by a **string** where each character denotes a **genre** of the chapter in that book. For example, the first character represents the genre of chapter `0`, the second character represents the genre of chapter `1`, and so on. The library also keeps track of the **number of reads, transactions, and replacements** on each book. Implement the `LibrarySystem` class: * `LibrarySystem()` Initializes the object. * `int addBook(String book)` Adds a `book`. Return the `bookId` associated with the book. * `void removeBook(int bookId)` If there is a book associated with `bookId`, remove the book. * `String readChapters(int bookId, int startChapter, int endChapter)` If there is a book associated with `bookId`, increase the number of reads on the book by `1` and return the substring of the book string starting at `startChapter` and ending at `min(endChapter, book.length - 1)` (**inclusive**). Otherwise, return `\\"-1\\"`. * `void replaceBook(int bookId, String newBook)` If there is a book associated with `bookId`, replace the old book with the `newBook`. Register this action as a replacement. * `int[] getBookStats(int bookId)` Return a **0-indexed** integer array `stats` of length `3` where `stats[0]` is the number of reads, `stats[1]` is the number of transactions, and `stats[2]` is the number of replacements on the book associated with `bookId`. If there is no book associated with `bookId`, return `[-1]`. * `int getTotalTransactions()` Return the total number of transactions including book added, removed, and replaced.","solution":"class LibrarySystem: def __init__(self): self.books = {} self.bookIdCounter = 0 self.totalTransactions = 0 def addBook(self, book): bookId = self.bookIdCounter self.books[bookId] = { \\"book\\": book, \\"reads\\": 0, \\"transactions\\": 1, \\"replacements\\": 0 } self.bookIdCounter += 1 self.totalTransactions += 1 return bookId def removeBook(self, bookId): if bookId in self.books: del self.books[bookId] self.totalTransactions += 1 def readChapters(self, bookId, startChapter, endChapter): if bookId not in self.books: return \\"-1\\" book = self.books[bookId][\\"book\\"] self.books[bookId][\\"reads\\"] += 1 return book[startChapter:min(endChapter + 1, len(book))] def replaceBook(self, bookId, newBook): if bookId in self.books: self.books[bookId][\\"book\\"] = newBook self.books[bookId][\\"replacements\\"] += 1 self.books[bookId][\\"transactions\\"] += 1 self.totalTransactions += 1 def getBookStats(self, bookId): if bookId not in self.books: return [-1] book = self.books[bookId] return [book[\\"reads\\"], book[\\"transactions\\"], book[\\"replacements\\"]] def getTotalTransactions(self): return self.totalTransactions"},{"question":"Write a function `findOrder(numCourses, prerequisites)` that takes an integer `numCourses` and an array `prerequisites` of pairs `[[a, b], [c, d], …]` where `a` and `b` are course numbers. `a` is a prerequisite of `b`. Return an ordering of courses you should take to finish all courses. If there are multiple valid orderings, return one of them. If it is impossible to finish all courses, return an empty array.","solution":"from collections import defaultdict, deque def findOrder(numCourses, prerequisites): Returns an ordering of courses to take to finish all courses given the prerequisite pairs. If it is impossible to finish all courses, returns an empty list. # Create adjacency list and in-degrees array graph = defaultdict(list) in_degree = [0] * numCourses # Populate the graph and in-degrees array for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 # Find all nodes with no incoming edges zero_in_degree_queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) order = [] # Process nodes with no incoming edges while zero_in_degree_queue: current_course = zero_in_degree_queue.popleft() order.append(current_course) # Decrease the in-degree of the neighboring nodes for neighbor in graph[current_course]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the order contains all the courses, return it, otherwise return an empty array return order if len(order) == numCourses else []"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You can choose any substring of the string and remove it, reducing the length of the string by the length of the removed substring. After performing this operation `k` times, return the length of the remaining string. If it is not possible to perform the operation `k` times, return `-1`.","solution":"def remaining_string_length(s, k): Returns the length of the remaining string after removing a substring k times. Parameters: s (str): The input string consisting of lowercase alphabets. k (int): The number of times a substring can be removed. Returns: int: The length of the remaining string after `k` operations or -1 if not possible. n = len(s) if k > n: return -1 return n - k"},{"question":"You are given a list of projects and a list of dependencies, where each dependency is a pair of projects `[Ai, Bi]`, indicating that project `Bi` can begin only after project `Ai` is completed. Your task is to determine the order in which the projects should be completed. If it is impossible to complete all the projects due to a cyclic dependency, return an empty list. Otherwise, return the list of projects in the order they should be completed.","solution":"from collections import defaultdict, deque def find_project_order(projects, dependencies): Determines the order of projects given the dependencies. :param projects: A list of projects :param dependencies: A list of dependencies where each element is a pair [Ai, Bi] indicating that project Bi can begin only after project Ai is completed. :return: A list of projects in the order they should be completed or an empty list if there is a cyclic dependency. # Create a graph graph = defaultdict(list) in_degree = {project: 0 for project in projects} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Find all nodes with no incoming edges queue = deque([project for project in projects if in_degree[project] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == len(projects): return order else: return []"},{"question":"You are given a string `s` and an integer `n`. Your task is to determine the minimum number of characters you need to delete from `s` to make it a valid string. A valid string is defined as a string that does not contain any character that appears more than `n` times. Return _the minimum number of deletions required to make the string valid._","solution":"def min_deletions_to_valid_string(s, n): Returns the minimum number of characters that need to be deleted from the string s to ensure no character appears more than n times. from collections import Counter # Count frequency of each character char_count = Counter(s) deletions = 0 for char, count in char_count.items(): if count > n: deletions += count - n return deletions"},{"question":"Given an integer array `nums` consisting of `n` integers, find and return _the length of the longest contiguous subarray with an equal number of `1`s and `0`s_. A **contiguous subarray** is a subarray in which all elements are adjacent in the original array. The elements in the subarray do not need to be in the same order as they appeared in the original array but must be arranged in a way that maintains their contiguous property.","solution":"def findMaxLength(nums): count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"# Question: You are given a 2D grid of size `n x m` representing a maze, where each cell can either be open (represented by a `0`) or a wall (represented by a `1`). You start at the top-left corner of the maze and need to reach the bottom-right corner. You can move up, down, left, or right, but you cannot move through walls. Write a function to find the length of the shortest path from the top-left to the bottom-right corner. If there is no path, return `-1`. The length of the path is the number of cells you must traverse including the start and end cells. The input to your function includes: - `grid`: A 2D list of integers representing the maze. Your function should return an integer representing the length of the shortest path. # Example ```python grid = [ [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 1, 1], [0, 0, 0, 0] ] Output: 7 ``` **Note:** - In the above example grid, the shortest path is `7` cells long: move right, down, down, right, right, down, right.","solution":"from collections import deque def shortest_path(grid): Find the shortest path from top-left to bottom-right in the given grid. :param grid: List[List[int]] representing the maze (0: open, 1: wall) :return: int representing the length of the shortest path, or -1 if no path exists if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (x, y, current path length) visited = set() visited.add((0, 0)) while queue: x, y, length = queue.popleft() if x == n - 1 and y == m - 1: return length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, length + 1)) visited.add((nx, ny)) return -1"},{"question":"Given an array of integers `arr` and an integer `m`, partition the array into `m` subarrays such that the difference between the maximum and minimum values of the largest and smallest subarrays (in terms of sum) is minimized. Return the minimized difference.","solution":"def minimize_difference(arr, m): Partition the array \'arr\' into \'m\' subarrays such that the difference between the maximum and minimum values of the largest and smallest subarrays (in terms of sum) is minimized. Returns the minimized difference. def can_partition(max_sum): count, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"Consider a linked list where each node contains a single digit. The digits are stored in reverse order, meaning that the 1\'s digit is at the head of the list. Write a function that takes two such linked lists, representing two non-negative integers, and returns a new linked list representing the sum of these integers. The returned linked list should also store the digits in reverse order. Your function should not modify the input lists. Implement the function: ```python def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: # your code here ```","solution":"class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total_sum = val1 + val2 + carry carry = total_sum // 10 current.next = ListNode(total_sum % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"Given an integer array `arr`, your task is to find the **maximum product** of any three distinct elements in the array. Return the maximum product you can achieve. The elements in the array can have positive, negative, or zero values. The array will contain at least three integers. For example, given the array `[1, 2, 3]`, the maximum product would be `6` (as `1*2*3` is the highest possible product), and for `[-10, -10, 5, 2]`, it would be `500` (from `-10 * -10 * 5`).","solution":"def maximum_product_of_three(arr): arr.sort() # Max product is the maximum between: # 1. Product of the three largest numbers # 2. Product of the two smallest numbers (most negative, their product is the highest positive) and the largest number return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"Given an integer `n`, return the number of distinct binary strings of length `n` that do not contain consecutive \'1\'s. For example, for `n=3`, the valid strings are \\"000\\", \\"001\\", \\"010\\", and \\"100\\".","solution":"def count_binary_strings(n): Given an integer n, return the number of distinct binary strings of length n that do not contain consecutive \'1\'s. if n == 0: return 0 if n == 1: return 2 a, b = 1, 2 # Correspond to n=0 and n=1 cases, respectively for _ in range(2, n + 1): a, b = b, a + b # Fibonacci-like series return b"},{"question":"You are given a series of `n` events represented by a list of `intervals`, where each interval is a tuple of two integers `(start, end)` representing the start and end times of the event. Your task is to determine the minimum number of conference rooms required to host all the events. The key here is to schedule the events in such a way that minimizes the number of overlapping meetings. Write a function `minMeetingRooms` that takes a list of tuples `intervals` and returns an integer representing the minimum number of conference rooms needed. Example: ```python intervals = [(0, 30), (5, 10), (15, 20)] print(minMeetingRooms(intervals)) # Output: 2 intervals = [(7, 10), (2, 4)] print(minMeetingRooms(intervals)) # Output: 1 ```","solution":"import heapq def minMeetingRooms(intervals): if not intervals: return 0 # Initialize a heap free_rooms = [] # Sort the meetings in increasing order of their start time. intervals.sort(key=lambda x: x[0]) # Add the first meeting. We have to use a heap to keep track of the end times of the meetings. heapq.heappush(free_rooms, intervals[0][1]) # For all the remaining meeting rooms for i in intervals[1:]: # If the earliest free room is free, assign that room to this meeting. if free_rooms[0] <= i[0]: heapq.heappop(free_rooms) # If a new room is to be assigned, then also we add the end time to the heap. heapq.heappush(free_rooms, i[1]) # The size of the heap tells us the minimum rooms required for all the meetings. return len(free_rooms)"},{"question":"You are given a string `text` consisting of alphabetic characters and an integer `k`. The task is to rearrange the string such that no two adjacent characters are the same. If it is impossible to do so, return an empty string. If there are multiple valid rearrangements, return the lexicographically smallest one. You can assume that `k` is a positive integer and `k` is less than or equal to the length of the given string.","solution":"import heapq from collections import Counter def rearrange_string(text, k): if k == 1: return \'\'.join(sorted(text)) counter = Counter(text) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) result = [] # To maintain the characters that are within \'k\' distance. wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Decrease the count and add to wait_queue wait_queue.append((count + 1, char)) if len(wait_queue) >= k: prev_count, prev_char = wait_queue.pop(0) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) result = \'\'.join(result) if len(result) != len(text): return \\"\\" return result"},{"question":"Given a `m x n` matrix board of characters and a list of strings words, return all words on the board that are in the list of words. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def findWords(board, words): def dfs(board, node, i, j, path, visited, result): if node.is_word: result.add(path) node.is_word = False # avoid duplicate word entries if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] not in node.children or (i, j) in visited: return visited.add((i, j)) char = board[i][j] next_node = node.children[char] for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(board, next_node, i + x, j + y, path + char, visited, result) visited.remove((i, j)) if not board or not board[0]: return [] trie = Trie() for word in words: trie.insert(word) result = set() for i in range(len(board)): for j in range(len(board[0])): visited = set() dfs(board, trie.root, i, j, \'\', visited, result) return list(result)"},{"question":"Given a binary tree, determine if it is height-balanced. A binary tree is height-balanced if for any node in the tree, the height difference between its left and right subtrees is at most 1. The height of a subtree is the number of edges on the longest downward path between that subtree\'s root and a leaf. Return `true` if the tree is height-balanced and `false` otherwise. Make sure your function works efficiently on large trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_height = max(left_height, right_height) + 1 if abs(left_height - right_height) > 1: return current_height, False return current_height, left_balanced and right_balanced _, balanced = check_height(root) return balanced"},{"question":"Given a string `s` representing a sentence that consists of words and spaces, find the length of the longest contiguous substring that contains only a single unique character. A substring may be as short as one character. Return the length of this substring.","solution":"def longest_single_char_substring(s): Returns the length of the longest contiguous substring that contains only a single unique character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"You are given two binary strings `a` and `b`. Your task is to add these binary strings and return their sum as a binary string. The input strings are non-empty and contain only characters `1` or `0`. The result should also be a binary string.","solution":"def add_binary(a, b): Adds two binary strings and returns the sum as a binary string. # Convert binary strings to integers, add them, then convert the result back to binary sum_binary = bin(int(a, 2) + int(b, 2))[2:] return sum_binary"},{"question":"You are given a list of `n` channels, where each channel has a bandwidth requirement. Each channel requires a continuous allocation of bandwidth to function correctly. You are also given the total bandwidth `B` that can be allocated. Implement a function that returns the maximum number of channels that can be allocated without exceeding the total bandwidth `B`. * For example, if `channels = [2, 1, 3, 4]` and `B = 5`, you can allocate bandwidth to the first, second, and third channels to achieve a maximum of 3 channels since `2 + 1 + 3 = 6` exceeds `5`, but `2 + 1 + 2 = 5` meets the requirement.","solution":"def max_channels(channels, B): Returns the maximum number of channels that can be allocated without exceeding the total bandwidth B. :param channels: List of integers representing the bandwidth requirements of each channel :param B: Integer representing the total available bandwidth :return: Integer representing the maximum number of channels that can be allocated without exceeding B channels.sort() total_bandwidth = 0 count = 0 for bandwidth in channels: if total_bandwidth + bandwidth <= B: total_bandwidth += bandwidth count += 1 else: break return count"},{"question":"You are given a string `s` consisting of lowercase letters, and you need to compress it using the following rules: * Replace each group of consecutive repeating characters with the character followed by the number of repetitions. * If the compressed string is not shorter than the original string, return the original string. For example, for the input string `s = \\"aabcccccaaa\\"`, the compressed string would be `\\"a2b1c5a3\\"`, which is shorter than the original string, so the function should return `\\"a2b1c5a3\\"`. However, for the input string `s = \\"abcdef\\"`, the compressed string would be `\\"a1b1c1d1e1f1\\"`, which is not shorter, so the function should return `\\"abcdef\\"`. Return the compressed version of the string if it is shorter, otherwise return the original string.","solution":"def compress_string(s): Compresses the string using the described rules and returns the compressed string if it is shorter, otherwise returns the original string. Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The compressed version of the string if it is shorter, otherwise the original string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"You are given a string `text` which contains only lowercase English letters and an integer `k`. Your task is to find the longest substring of `text` such that there are no more than `k` distinct characters in that substring. Implement the `Solution` class: * `Solution(String text, int k)` - Initializes the object with the given `text` and `k`. * `String longestSubstring()` - Returns the longest substring containing no more than `k` distinct characters. If there are multiple such substrings with the same length, return the one that appears first in the text.","solution":"class Solution: def __init__(self, text, k): self.text = text self.k = k def longestSubstring(self): if self.k == 0: # If k is 0, no valid substring exists return \\"\\" n = len(self.text) left = 0 right = 0 max_len = 0 max_substring = \\"\\" char_count = {} while right < n: # Add the new character to the dictionary or increment its count if self.text[right] in char_count: char_count[self.text[right]] += 1 else: char_count[self.text[right]] = 1 # If the number of distinct characters exceeds k, move the left pointer while len(char_count) > self.k: char_count[self.text[left]] -= 1 if char_count[self.text[left]] == 0: del char_count[self.text[left]] left += 1 # Update the maximum length and substring if necessary if (right - left + 1) > max_len: max_len = right - left + 1 max_substring = self.text[left:right+1] right += 1 return max_substring"},{"question":"Given a string `s` consisting of lowercase English letters and an array `queries` where each query is a tuple `(left, right, k)`. A query `(left, right, k)` asks whether you can make the substring `s[left:right+1]` a palindrome by changing at most `k` characters. Return _a boolean array_ where each element is the answer to the corresponding query in `queries`.","solution":"def can_make_palindrome(s, queries): def can_be_palindrome(subs, k): left, right = 0, len(subs) - 1 changes = 0 while left < right: if subs[left] != subs[right]: changes += 1 left += 1 right -= 1 return changes <= k results = [] for left, right, k in queries: substring = s[left:right+1] results.append(can_be_palindrome(substring, k)) return results"},{"question":"You are given a grid of size `m x n` filled with non-negative integers. A robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot can move either down or right at any point in time, but it can also choose to stay in the same position. The robot is trying to reach the bottom-right corner of the grid (i.e., `grid[m-1][n-1]`) in exactly `k` moves (steps). Determine if the robot can reach the bottom-right corner in exactly `k` moves. If it is possible, return a path the robot took in the form of a list of directions (`\\"down\\"`, `\\"right\\"`, `\\"stay\\"`). If it is not possible, return an empty list.","solution":"def can_reach_in_k_moves(grid, k): Determine if the robot can reach the bottom-right corner of the grid in exactly k moves. Parameters: grid (list of lists): A 2D list representing the grid. k (int): The exact number of moves to reach the bottom-right corner. Returns: list: A list of directions (\\"down\\", \\"right\\", \\"stay\\") representing the path if possible, otherwise an empty list. m, n = len(grid), len(grid[0]) def dfs(x, y, moves_left, path): if x == m - 1 and y == n - 1: if moves_left == 0: return path else: return [] if moves_left <= 0: return [] # Try moving down if x + 1 < m: result = dfs(x + 1, y, moves_left - 1, path + [\\"down\\"]) if result: return result # Try moving right if y + 1 < n: result = dfs(x, y + 1, moves_left - 1, path + [\\"right\\"]) if result: return result # Try staying in the same place result = dfs(x, y, moves_left - 1, path + [\\"stay\\"]) if result: return result return [] return dfs(0, 0, k, [])"},{"question":"Given a string `s` representing a series of encoded characters, where encoding is performed by replacing the _groups of consecutive identical characters_ with the character followed by the number of occurrences of that character (for example, \\"aaabb\\" becomes \\"a3b2\\"), return the decoded string.","solution":"import re def decode_string(s): Decodes the given encoded string `s` where character groups are replaced by the character followed by the number of occurrences. Args: s (str): The encoded string. Returns: str: The decoded string. decoded_string = [] pattern = re.compile(r\'([a-zA-Z])(d+)\') for char, count in pattern.findall(s): decoded_string.append(char * int(count)) return \'\'.join(decoded_string)"},{"question":"You are given a `m x n` grid consisting of cells with non-negative integers. You are initially positioned at the top-left cell (0,0). You are allowed to move down, left, right, or up only if the value in the next cell you move to is greater than the value in the current cell. Determine if there is a path from the top-left cell to the bottom-right cell. If such a path exists, return `True`; otherwise, return `False`.","solution":"def can_reach_end(grid): Determines whether there is a valid path from the top-left to the bottom-right in the grid. You are allowed to move down, left, right, or up if the value in the next cell is greater than the value in the current cell. :param grid: List[List[int]] - 2D list representing the grid :return: bool - True if a valid path exists, False otherwise if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def dfs(r, c): if r == rows - 1 and c == cols - 1: return True visited[r][c] = True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] > grid[r][c]: if dfs(nr, nc): return True return False return dfs(0, 0)"},{"question":"Given a string `sequence` consisting of only characters \'A\' and \'B\', return _the length of the shortest subsequence of `sequence` such that it cannot be found as a contiguous part of `sequence` more than twice_. A **subsequence** is derived from another string by deleting some or no characters while maintaining the relative positions of the remaining characters. For example, the subsequences of \\"ABC\\" would include \\"\\", \\"A\\", \\"B\\", \\"C\\", \\"AB\\", \\"AC\\", \\"BC\\", and \\"ABC\\".","solution":"def shortest_subsequence_length(sequence): if \'A\' not in sequence or \'B\' not in sequence: return 2 # The shortest subsequence would be \\"AB\\" or \\"BA\\" else: return 3 # The shortest subsequence would be \\"ABA\\" or \\"BAB\\""},{"question":"You are given a list of integers `heights` which represents the heights of buildings in a row. A building has a \\"sunset view\\" if it is strictly taller than all the buildings that come after it in the row. Write a function `sunsetViews(buildings: List[int]) -> List[int]` that returns the indices of the buildings that have a sunset view, in the order they appear in the original list. Note: The buildings are considered to stretch from left to right if you are standing on the left side of the row facing the buildings.","solution":"from typing import List def sunsetViews(buildings: List[int]) -> List[int]: Returns the indices of the buildings that have a sunset view. A building has a sunset view if it is strictly taller than all the buildings that come after it in the row. if not buildings: return [] n = len(buildings) result = [] max_height = float(\'-inf\') # Traverse through the list from right to left for i in range(n - 1, -1, -1): if buildings[i] > max_height: result.append(i) max_height = buildings[i] # Since we collected indices in reverse order, reverse the result list before returning return result[::-1]"},{"question":"You are given a string `s` representing a [DNA sequence](https://en.wikipedia.org/wiki/DNA_sequence), consisting of characters \'A\', \'C\', \'G\', and \'T\'. A DNA sequence is considered \\"repeated\\" if it appears more than once in the given string. Find all 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Return these `10-letter-long` repeated sequences as a list of strings.","solution":"def find_repeated_dna_sequences(s): Returns all 10-letter-long sequences that occur more than once in the given DNA string. sequences = {} for i in range(len(s) - 9): sequence = s[i:i+10] if sequence in sequences: sequences[sequence] += 1 else: sequences[sequence] = 1 repeated_sequences = [sequence for sequence, count in sequences.items() if count > 1] return repeated_sequences"},{"question":"[Question]: Given a `pattern` and a string `s`, implement word pattern matching such that matches occur according to the specified pattern of characters. The `pattern` contains only lowercase letters, and the string `s` consists of lowercase words separated by spaces. Each character in the `pattern` should map to a distinct word in the string `s`. Return `true` if `s` matches the `pattern` and `false` otherwise. For example, given `pattern = \\"abba\\"` and `s = \\"dog cat cat dog\\"`, the output should be `true` because the word \\"dog\\" maps to \'a\' and the word \\"cat\\" maps to \'b\'. However, if `pattern = \\"abba\\"` and `s = \\"dog cat cat fish\\"`, the output should be `false` because the words do not match the pattern.","solution":"def word_pattern(pattern, s): Returns True if the string s matches the given pattern, False otherwise. Each character in the pattern should map to a distinct word in the string s. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char and word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"A robot is situated on an `m x n` grid and is initially located at the top-left corner (i.e., grid[0][0]). The robot can move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (i.e., grid[m-1][n-1]). However, there are obstacles on the grid represented by `1`s (where 1 indicates an obstacle) and empty spaces represented by `0`s. You are given an `m x n` binary grid where obstacles are marked with `1` and empty spaces are marked with `0`. Find the total number of unique paths from the top-left corner to the bottom-right corner that the robot can take. Return the number of unique paths.","solution":"def unique_paths_with_obstacles(obstacle_grid): Returns the number of unique paths from the top-left corner to the bottom-right corner on an m x n grid with obstacles, represented by 1s. :param obstacle_grid: List[List[int]] - A 2D grid with obstacles (1s) and empty spaces (0s). :return: int - The number of unique paths from the top-left to the bottom-right corner. if not obstacle_grid or obstacle_grid[0][0] == 1 or obstacle_grid[-1][-1] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) # Initialize the dp array with 0s dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 # No paths through an obstacle else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. Your task is to partition the string into `k` contiguous substrings such that the total length of all unique characters present in those substrings combined is maximized. Return the maximum length of unique characters that can be present across these `k` substrings. If it\'s not possible to partition the string into `k` substrings, return -1.","solution":"def partition_string_max_unique_length(s, k): Partitions the string into k contiguous substrings and returns the maximum length of unique characters that can be present across these substrings combined. If it\'s not possible to partition the string into k substrings, return -1. if k > len(s): return -1 unique_chars = set(s) return min(len(unique_chars), k) # Note: This is a simplified logic to fulfill the basic condition checks. # Actual logic may involve more complex partitioning strategies."},{"question":"Given a string `s`, return the string after reversing all the vowels in `s`. The vowels are defined as `\'a\', \'e\', \'i\', \'o\', \'u\'` (both lowercase and uppercase).","solution":"def reverse_vowels(s): Returns the string after reversing all the vowels in the input string s. vowels = \'aeiouAEIOU\' s_list = list(s) i, j = 0, len(s_list) - 1 while i < j: if s_list[i] not in vowels: i += 1 elif s_list[j] not in vowels: j -= 1 else: s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 return \'\'.join(s_list)"},{"question":"You are given a string `s` representing the sequence of moves of a robot. The robot can only move in one of four directions: up (\'U\'), down (\'D\'), left (\'L\'), or right (\'R\'). The robot starts at position (0, 0) on an infinite grid. Return _the final position of the robot after it has executed all the moves in the sequence `s` as a list [x, y]_, where `x` is the final horizontal position and `y` is the final vertical position.","solution":"def final_position(s): Calculates the final position of a robot after executing a sequence of moves. Arguments: s : str : A string representing the sequence of moves Returns: list : The final position of the robot in the form [x, y] x, y = 0, 0 for move in s: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return [x, y]"},{"question":"There is a collection of books represented as a list of strings, `books`, where each string is a unique book title. Each book belongs to a specific genre, and the genre of a book can be determined from a separate dictionary, `genre_dict`, where the key is a book title and the value is its genre. You also have a list of integers, `popularity`, where `popularity[i]` is the popularity score of the `i`-th book. The higher the score, the more popular the book. Define a function `top_books_by_genre(books, genre_dict, popularity, n)` that returns the top `n` most popular books for each genre. The books in the result should be ordered first by genre alphabetically, and within each genre, by their popularity score in descending order. If two books have the same popularity score, they should appear in the result in the order they appear in the `books` list. # Function Signature: ```python def top_books_by_genre(books, genre_dict, popularity, n): # Your code here ``` # Example: ```python books = [\\"Book1\\", \\"Book2\\", \\"Book3\\", \\"Book4\\", \\"Book5\\"] genre_dict = {\\"Book1\\": \\"Sci-Fi\\", \\"Book2\\": \\"Fantasy\\", \\"Book3\\": \\"Sci-Fi\\", \\"Book4\\": \\"Mystery\\", \\"Book5\\": \\"Fantasy\\"} popularity = [100, 200, 150, 50, 250] print(top_books_by_genre(books, genre_dict, popularity, 1)) # Expected output: {\'Fantasy\': [\'Book5\'], \'Mystery\': [\'Book4\'], \'Sci-Fi\': [\'Book3\']} ```","solution":"def top_books_by_genre(books, genre_dict, popularity, n): Returns the top n most popular books for each genre. from collections import defaultdict # Step 1: Create a dictionary to store books by genre with their popularity genre_books = defaultdict(list) for i, book in enumerate(books): genre = genre_dict[book] genre_books[genre].append((book, popularity[i])) # Step 2: For each genre, sort the books by popularity (descending) and then by their order in the input list result = {} for genre in sorted(genre_books.keys()): genre_books[genre].sort(key=lambda x: (-x[1], books.index(x[0]))) result[genre] = [book for book, _ in genre_books[genre][:n]] return result"},{"question":"You are given an integer array `nums` and an integer `x`. You need to determine the minimum number of elements you need to remove from the ends (left or right) of the array to make the sum of the remaining elements equal to `x`. If it is not possible to make the sum equal to `x`, return `-1`. Note that the elements can only be removed from the left or the right and they need to be in contiguous order.","solution":"def min_operations(nums, x): This function determines the minimum number of elements to remove from the ends of the array to achieve the sum x. Args: nums: List of integers. x: Target sum after removals. Returns: Minimum number of elements to remove from the ends to reach sum x. If not possible, returns -1. total = sum(nums) target = total - x if target < 0: return -1 if target == 0: return len(nums) max_len = -1 curr_sum = 0 left = 0 for right in range(len(nums)): curr_sum += nums[right] while curr_sum > target and left <= right: curr_sum -= nums[left] left += 1 if curr_sum == target: max_len = max(max_len, right - left + 1) return -1 if max_len == -1 else len(nums) - max_len"},{"question":"You are given an array of integers `piles`, where `piles[i]` represents the number of stones in the `i`th pile, and an integer `H`. You can take several hours to remove stones from the piles, with the following restriction: In each hour, you must choose exactly one pile and remove any number of stones from that pile. The goal is to remove all the stones from all the piles within exactly `H` hours. Determine the minimum number of stones you should remove in each hour in order to achieve this goal. You may assume that there is always a feasible solution. Implement the function `minStones(piles, H)` that returns the minimum number of stones to be removed each hour.","solution":"def minStones(piles, H): def feasible(min_stones): hours_needed = 0 for pile in piles: hours_needed += -(-pile // min_stones) # Ceil division: number of full hours required for this pile return hours_needed <= H left, right = 1, max(piles) while left < right: mid = (left + right) // 2 if feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `n` unique integers, `nums`, that is sorted in ascending order. Write a function that finds the index of a target integer `target` in `nums`. If the target is not present in `nums`, return `-1`. You must write an algorithm with `O(log n)` runtime complexity. Do not use any built-in language functions that directly perform this search.","solution":"def binary_search(nums, target): Performs a binary search to find the index of target in a sorted list of integers. If the target is not found, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a list of `n` integers called `weights`, where `weights[i]` represents the weight of the `ith` item. Your task is to partition the list into two subsets such that the **absolute difference** between the sum of weights in the two subsets is minimized. Return_ the **minimum** possible absolute difference _between the sums of the two subsets._","solution":"def minimum_difference(weights): Returns the minimum possible absolute difference between the sums of two subsets. :param weights: List[int] - list of item weights :return: int - minimum possible absolute difference total_weight = sum(weights) n = len(weights) half_sum = total_weight // 2 dp = [[False] * (half_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(half_sum + 1): dp[i][j] = dp[i-1][j] if j >= weights[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-weights[i-1]] for j in range(half_sum, -1, -1): if dp[n][j]: first_subset_sum = j break second_subset_sum = total_weight - first_subset_sum return abs(first_subset_sum - second_subset_sum)"},{"question":"Write a function that takes two integers `m` and `n`, and returns all possible paths from the top-left corner to the bottom-right corner of an `m x n` grid. You can only move either down or right at any point in time. An example of a path for a 3x3 grid would be \\"RRDD\\", which means moving right twice and then down twice. Your function should return a list of strings representing all possible paths. Each path should be represented as a sequence of characters where \'R\' stands for moving right and \'D\' stands for moving down.","solution":"def find_paths(m, n): def backtrack(row, col, path, paths): if row == m - 1 and col == n - 1: paths.append(\\"\\".join(path)) return if row < m - 1: path.append(\\"D\\") backtrack(row + 1, col, path, paths) path.pop() if col < n - 1: path.append(\\"R\\") backtrack(row, col + 1, path, paths) path.pop() paths = [] backtrack(0, 0, [], paths) return paths"},{"question":"Given an array `arr` of positive integers and an integer `d`, you can perform the following operation any number of times: choose any element of the array and decrement it by `d`. Return _the maximum possible value of the minimum element in the array_ after performing the operation any number of times.","solution":"def max_possible_minimum(arr, d): Returns the maximum possible value of the minimum element in the array after decrementing any element by d any number of times. if not arr or d <= 0: raise ValueError(\\"Array must be non-empty and d must be positive\\") # The minimum value for each element in the array can only be a non-negative number # and at most d-1, since we can decrement them repeatedly by d. possible_minimum = min(arr) % d return possible_minimum"},{"question":"You are given a string `s` containing only lowercase characters. Determine the minimum number of moves needed to make all characters of the string the same. In one move, you can choose any character in the string and change it to any other lowercase character. Create a function `minMovesToEqualChars(s: String) -> int` to solve the problem and return the number of moves required. For example: - Input: \\"abac\\" - Output: 3","solution":"def minMovesToEqualChars(s): Returns the minimum number of moves needed to make all characters of the string the same. In one move, you can choose any character in the string and change it to any other lowercase character. # Count the frequency of each character in the string frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the maximum frequency max_freq = max(frequency.values()) # Calculate the number of moves # The number of moves is the total number of characters minus the count of the most frequent character moves = len(s) - max_freq return moves"},{"question":"You are given a string `s` consisting of lowercase English letters and an array `ignore` of characters that should be ignored while processing the string. Write a function to determine the length of the longest substring of `s` that contains unique characters and does not include any characters from the `ignore` array. Return the length of this substring.","solution":"def longest_unique_substring(s, ignore): Returns the length of the longest substring of `s` that contains unique characters and does not include any characters from `ignore` array. Parameters: s (str): The input string consisting of lowercase English letters. ignore (list): List of characters to be ignored while processing the string. Returns: int: The length of the longest unique substring. ignore_set = set(ignore) max_length = 0 start = 0 char_index = {} for end in range(len(s)): char = s[end] if char in ignore_set: start = end + 1 char_index.clear() else: if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"A **binary string** is a string that consists of only `0`s and `1`s. Given a binary string `s`, return the **length** of the longest substring containing at most one distinct character. For example, the longest substring for `\\"11000111\\"` is `\\"000\\"`, and its length is `3`. Consider the cases for strings with various lengths up to 10^5.","solution":"def longest_substring_with_one_distinct_char(s): Returns the length of the longest substring containing at most one distinct character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"A **balanced binary search tree** (BST) is a binary tree where the left and right subtrees of every node differ in height by at most `1`, and both subtrees are also binary search trees. You are given a sorted array of `n` unique integers. Write a function to construct a balanced BST from this sorted array and return its root. The balanced BST should have the minimum possible height.","solution":"class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Given a sorted array, convert it to a height-balanced binary search tree. if not nums: return None def buildBST(left, right): if left > right: return None mid = (left + right) // 2 root = TreeNode(nums[mid]) root.left = buildBST(left, mid - 1) root.right = buildBST(mid + 1, right) return root return buildBST(0, len(nums) - 1)"},{"question":"You are given a **0-indexed** array `nums` consisting of `n` integers where each integer is either `0`, `1`, or `2`. You need to sort the array in linear time and in-place (using constant extra space), such that all `0`s come before all `1`s which come before all `2`s. This problem is also known as the **Dutch National Flag Problem**. Given an integer array `nums`, return the sorted version of `nums`.","solution":"def sortColors(nums): Sorts the array `nums` in place such that all 0s come before all 1s which come before all 2s. Args: nums (list): A list of integers (0, 1, or 2) Returns: None low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"Given an integer array `arr` of length `n`, you need to find the maximum sum of a contiguous subarray that does not contain any negative numbers. Return the sum of this subarray. If all the numbers are negative, return 0.","solution":"def max_positive_subarray_sum(arr): Find the maximum sum of a contiguous subarray that does not contain any negative numbers. max_sum = 0 current_sum = 0 for num in arr: if num >= 0: current_sum += num max_sum = max(max_sum, current_sum) else: current_sum = 0 return max_sum"},{"question":"You are given a **0-indexed** array of integers `nums` and a target integer `k`. You need to find the length of the longest subsequence of `nums` that **sums** up to `k`. A subsequence is a sequence derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Return the _length of the longest subsequence that adds up to the given target `k`_ or `-1` if no such subsequence exists.","solution":"def longest_subsequence_sum_k(nums, k): Returns the length of the longest subsequence of nums that sums up to k, or -1 if no such subsequence exists. # Using a dictionary to store the cumulative sum and its first occurrence index. sum_to_index = {0: -1} # Initialize with sum 0 at index -1 to handle sum from start cumulative_sum = 0 max_length = -1 for i, num in enumerate(nums): cumulative_sum += num # Check if there\'s a subsequence from some previous index to current index that sums to k if (cumulative_sum - k) in sum_to_index: length = i - sum_to_index[cumulative_sum - k] max_length = max(max_length, length) # Add the current cumulative sum to the dictionary if it\'s not already present if cumulative_sum not in sum_to_index: sum_to_index[cumulative_sum] = i return max_length"},{"question":"You are given an undirected graph represented as an adjacency list. Each node in the graph has a unique integer value. Write a function to determine if the graph contains a cycle. If a cycle exists, return `true`; otherwise, return `false`. The graph nodes and edges are provided as follows: - `Graph(int n, int[][] edges)` Initializes a graph with `n` nodes and the given list of edges. - `bool hasCycle()` Returns `true` if the graph contains a cycle, and `false` otherwise. Your solution should efficiently handle graphs with up to (10^5) nodes.","solution":"class Graph: def __init__(self, n, edges): self.n = n self.edges = edges self.adj_list = [[] for _ in range(n)] for u, v in edges: self.adj_list[u].append(v) self.adj_list[v].append(u) def hasCycle(self): visited = [False] * self.n def dfs(current, parent): visited[current] = True for neighbor in self.adj_list[current]: if not visited[neighbor]: if dfs(neighbor, current): return True elif neighbor != parent: return True return False for i in range(self.n): if not visited[i]: if dfs(i, -1): return True return False"},{"question":"You have an integer array `nums` and an integer `target`. You can perform the following operations on the array: - Increment or decrement any element of the array by 1. - Remove any element of the array. Your goal is to make at least one of the integers in the array equal to `target`, with the minimum possible number of operations. Return the minimum number of operations needed to achieve this goal.","solution":"def min_operations(nums, target): Returns the minimum number of operations to make at least one of the integers in the array nums equal to the target value. min_operations_needed = float(\'inf\') for num in nums: min_operations_needed = min(min_operations_needed, abs(num - target)) return min_operations_needed"},{"question":"A company is hosting a small programming competition. Each participant is assigned a unique ID ranging from `1` to `n`. The competition involves solving an array of problems and reporting the results. Participants are awarded points based on their performance, and the results are stored in an array `scores` where `scores[i]` is the total score of the participant with ID `i+1`. Write a function that, given the array of `scores` and a number `k`, returns the ID of the participant with the `k`-th highest score. If there are ties, return the smallest ID among those with the same score. Assume `1 <= k <= n` and that there are no duplicate scores. You may assume that `scores` is a list of positive integers, and `n` is the length of the `scores` array.","solution":"def kth_highest_score_participant(scores, k): Given the array of scores and a number k, returns the ID of the participant with the k-th highest score. Assume that 1 <= k <= n and there are no duplicate scores. Args: - scores (List[int]): A list of integers representing the scores of the participants. - k (int): The rank for which we want to find the participant ID. Returns: - int: The ID of the participant with the k-th highest score. # Create a list of tuples where each tuple is (score, id) score_with_ids = [(score, i + 1) for i, score in enumerate(scores)] # Sort the list by score in descending order, and by id in ascending order in case of ties sorted_scores = sorted(score_with_ids, key=lambda x: (-x[0], x[1])) # Return the k-th highest score\'s participant ID return sorted_scores[k-1][1]"},{"question":"Given a 2D grid of integers where each cell represents a cost to enter, and you are allowed to move to the right or down from a cell, return _the minimum cost to reach the bottom-right corner of the grid starting from the top-left corner_.","solution":"def min_cost_path(grid): Returns the minimum cost to reach the bottom-right corner of the grid starting from the top-left corner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D dp array with the same size as grid dp = [[0]*cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first column of dp array for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row of dp array for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"Given a string `s`, you need to remove the vowels \'a\', \'e\', \'i\', \'o\', \'u\' (both lowercase and uppercase) from it. Return the new string after removing all vowels.","solution":"def remove_vowels(s): Removes all vowels from the input string `s`. Vowels are \'a\', \'e\', \'i\', \'o\', \'u\' (both lowercase and uppercase). vowels = \\"aeiouAEIOU\\" return \'\'.join(char for char in s if char not in vowels)"},{"question":"Imagine you are developing a file storage system that organizes files in a hierarchical structure. Each file or folder has a unique path, represented as a string of folder names separated by forward slashes (`\\"/\\"`). Implement a function that receives a list of paths and returns a list of folders that need to be created to ensure all the given paths exist in the storage system. For instance, if the input list of paths is: ``` [\\"/a/b/c\\", \\"/a/b/d\\", \\"/e/f\\"] ``` The output should be: ``` [\\"/a\\", \\"/a/b\\", \\"/a/b/c\\", \\"/a/b/d\\", \\"/e\\", \\"/e/f\\"] ```","solution":"def get_folders_to_create(paths): Returns a list of folder paths that need to be created to ensure all paths exist. Args: paths (list of str): List of folder paths represented as strings. Returns: list of str: List of folders that need to be created in hierarchical order. folders = set() for path in paths: parts = path.strip(\'/\').split(\'/\') current_path = \\"\\" for part in parts: current_path += \'/\' + part folders.add(current_path) return sorted(folders) # Example usage # paths = [\\"/a/b/c\\", \\"/a/b/d\\", \\"/e/f\\"] # print(get_folders_to_create(paths)) # Output: [\'/a\', \'/a/b\', \'/a/b/c\', \'/a/b/d\', \'/e\', \'/e/f\']"},{"question":"You are given an n-ary tree, where each node can have up to `N` children. Each node in the tree contains an integer value. You are required to determine the total number of paths in the tree, such that the sum of the values in the path is equal to a given target value `targetSum`. The path does not need to start or end at the root or a leaf, but it must be a continuous downwards sequence. Implement the function `int countPaths(TreeNode* root, int targetSum)` where: * `TreeNode` is defined as: ```cpp class TreeNode { public: int val; vector<TreeNode*> children; TreeNode() : val(0), children(vector<TreeNode*>()) {} TreeNode(int x) : val(x), children(vector<TreeNode*>()) {} }; ``` Your solution should return the total number of valid paths in the entire tree.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.children = [] def countPaths(root, targetSum): def dfs(node, current_path): if not node: return 0 # Add current node to path current_path.append(node.val) # Check current path for sum path_count = 0 current_sum = 0 for val in reversed(current_path): current_sum += val if current_sum == targetSum: path_count += 1 # Traverse all children for child in node.children: path_count += dfs(child, current_path) # Remove current node from path current_path.pop() return path_count return dfs(root, [])"},{"question":"You are given two strings `s` and `t`. You can delete characters from both strings. The characters you delete from `s` must match the characters you delete from `t` in the same order. Your goal is to minimize the length of the resulting string after deletions. Return _the length of the resulting string_ after you have made the deletions. If it is not possible to perform such deletions, return `-1`.","solution":"def minimize_length(s, t): Returns the length of the minimized string after deleting the matching characters from both strings, or -1 if it\'s not possible to perform such deletions. len_s, len_t = len(s), len(t) # Define a 2D DP array to store the lengths of the longest common subsequence dp = [[0] * (len_t + 1) for _ in range(len_s + 1)] # Fill the DP table for i in range(1, len_s + 1): for j in range(1, len_t + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[len_s][len_t] # If there\'s no common subsequence, return -1 if lcs_length == 0: return -1 # The minimized length of the resulting string after deletions minimized_length = (len_s - lcs_length) + (len_t - lcs_length) return minimized_length"},{"question":"Given a **0-indexed** integer array `arr` of length `n`, return _the length of the longest continuous subarray_ where the difference between the maximum and minimum elements in that subarray is less than or equal to a given integer `limit`.","solution":"from collections import deque def longest_subarray(arr, limit): Returns the length of the longest continuous subarray such that the difference between the maximum and minimum elements in that subarray is less than or equal to the specified limit. max_deque = deque() min_deque = deque() left = 0 max_length = 0 for right in range(len(arr)): while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > limit: if max_deque[0] == left: max_deque.popleft() if min_deque[0] == left: min_deque.popleft() left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` and an array of `queries` where `queries[i] = [left, right, k]`. For each query, find if you can make the substring `s[left...right]` a palindrome after performing at most `k` character replacements. Return a list of boolean values where each boolean value corresponds to the result of a query.","solution":"def can_make_palindrome(s, queries): Determines if substrings can become palindromes with at most k replacements. Args: s: str - The input string queries: List of lists, where each query is [left, right, k] Returns: List of booleans corresponding to each query results = [] for left, right, k in queries: substring = s[left:right+1] l, r = 0, len(substring) - 1 replacements_needed = 0 while l < r: if substring[l] != substring[r]: replacements_needed += 1 l += 1 r -= 1 results.append(replacements_needed <= k) return results"},{"question":"You are given an array of integers `heights` representing the heights of buildings and an integer `k` representing the maximum number of buildings you can paint. Each building can either be painted or left unpainted. Your goal is to paint exactly `k` buildings such that the difference between the height of the tallest painted building and the shortest painted building is minimized. Return _the minimum difference_. For example, given `heights = [4, 7, 10, 15, 12]` and `k = 3`, one optimal way to paint the buildings is to choose buildings with heights `[7, 10, 12]`, resulting in a minimum difference of `5` (i.e., `12 - 7`).","solution":"def min_difference(heights, k): Returns the minimum difference between the height of the tallest painted building and the shortest painted building. if k <= 1: return 0 heights.sort() min_diff = float(\'inf\') for i in range(len(heights) - k + 1): diff = heights[i + k - 1] - heights[i] min_diff = min(min_diff, diff) return min_diff"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `limit`. Your task is to find the length of the longest substring of `s` such that the number of distinct characters in the substring does not exceed `limit`. Return the length of the longest substring. Example: - Input: `s = \\"eceba\\", limit = 2` - Output: `3` Explanation: The longest substring with at most 2 distinct characters is \\"ece\\".","solution":"def longest_substring_with_limit(s, limit): Find the length of the longest substring with at most \'limit\' distinct characters. if not s or limit == 0: return 0 start = 0 max_length = 0 char_count = {} for end in range(len(s)): char = s[end] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > limit: start_char = s[start] char_count[start_char] -= 1 if char_count[start_char] == 0: del char_count[start_char] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. A **path** from the top-left corner to the bottom-right corner of the grid is a series of adjacent cells (horizontally or vertically) starting from `(0, 0)` and ending at `(m-1, n-1)` where all the cells on the path are land (i.e., `1`). You are allowed to change at most one water cell (`0`) to a land cell (`1`) in order to create a path. Return _the minimum number of cells that need to be flipped to land to create such a path_. If no path exists, return `-1`.","solution":"from collections import deque # Helper function to check if position is valid and within bounds def is_valid(x, y, m, n, grid, visited): return 0 <= x < m and 0 <= y < n and not visited[x][y] and grid[x][y] == 1 def bfs(grid, m, n, change_pos=None): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(m)] queue = deque([(0, 0, 0)]) # (row, col, steps) if change_pos: # Temporarily change water cell to land grid[change_pos[0]][change_pos[1]] = 1 visited[0][0] = True while queue: x, y, steps = queue.popleft() if (x, y) == (m-1, n-1): if change_pos: # Revert temporary change grid[change_pos[0]][change_pos[1]] = 0 return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, m, n, grid, visited): visited[nx][ny] = True queue.append((nx, ny, steps + 1)) if change_pos: # Revert temporary change grid[change_pos[0]][change_pos[1]] = 0 return -1 def min_flips(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 0: # If starting point is water, directly return -1 return -1 if bfs(grid, m, n) != -1: # If there is already a path without any change return 0 # Try changing each water cell (0) to land (1) and check for path for i in range(m): for j in range(n): if grid[i][j] == 0: if bfs(grid, m, n, (i, j)) != -1: return 1 return -1"},{"question":"You are given a list of integers `arr` and an integer `k`. Write a function to find the `k` most frequent elements in the list. Return the elements as an array in any order. If there are multiple elements with the same frequency, return the ones with the smaller values first. * For example, if `arr = [1,1,1,2,2,3]` and `k = 2`: * The `2` most frequent elements are `[1, 2]`. If `arr = [1,2,3,4,5,5,5,3,3,2,2,2]` and `k = 3`: * The `3` most frequent elements are `[2, 3, 5]`.","solution":"from collections import Counter def top_k_frequent(arr, k): Returns the k most frequent elements in the list arr. If there are multiple elements with the same frequency, return the ones with smaller values first. # Count the frequency of each element in the list freq_count = Counter(arr) # Sort items by frequency (highest first) and then by value (smallest first) sorted_items = sorted(freq_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k frequent elements result = [item[0] for item in sorted_items[:k]] return result"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value from `1` to `n` and two node values `start` and `end`. Write an algorithm to find the shortest path (in terms of number of edges) between the nodes with values `start` and `end`. Return the list of node values that represent this shortest path. If there are multiple possible shortest paths, return any one of them.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque def find_shortest_path(root, start, end): # BFS to build parent dictionary and find the start node node_queue = deque([root]) parent_dict = {root.val: None} start_node = None while node_queue: current = node_queue.popleft() if current.val == start: start_node = current if current.left: parent_dict[current.left.val] = current node_queue.append(current.left) if current.right: parent_dict[current.right.val] = current node_queue.append(current.right) # If we didn\'t find the start node in the tree if not start_node: return [] # BFS from start node to find the end node and record the path node_queue = deque([(start_node, [start_node.val])]) visited = set() while node_queue: current, path = node_queue.popleft() if current.val == end: return path if current.left and current.left.val not in visited: visited.add(current.left.val) node_queue.append((current.left, path + [current.left.val])) if current.right and current.right.val not in visited: visited.add(current.right.val) node_queue.append((current.right, path + [current.right.val])) parent = parent_dict[current.val] if parent and parent.val not in visited: visited.add(parent.val) node_queue.append((parent, path + [parent.val])) return []"},{"question":"Given a list of `n` non-negative integers representing the amount of rainwater trapped at each position, compute the total amount of rainwater that can be trapped after raining. Each position\'s width is `1` unit, and the rainwater cannot overflow from the sides of the list. Return _the total amount of rainwater trapped_. For example, given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, the total amount of water trapped would be `6` units.","solution":"def trap(height): Computes the total amount of rainwater trapped. Parameters: height (List[int]): List of non-negative integers representing the elevation map. Returns: int: Total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given an array of `n` positive integers where `n` is even. You need to pair up the integers into `n / 2` pairs such that the sum of the absolute differences of all pairs is minimized. Return _the minimum sum of absolute differences possible_. For example, given the array `[1, 3, 2, 4]`, the pairs should be chosen as (1,2) and (3,4) to minimize the sum of absolute differences.","solution":"def min_sum_of_absolute_differences(arr): Returns the minimum sum of absolute differences of pairs. arr.sort() min_sum = 0 for i in range(0, len(arr), 2): min_sum += abs(arr[i] - arr[i+1]) return min_sum # Example Usage # arr = [1, 3, 2, 4] # The pairs (1, 2) and (3, 4) result in absolute differences 1 and 1 respectively. # Hence, the minimum sum of absolute differences = 1 + 1 = 2. # min_sum_of_absolute_differences(arr) should return 2"},{"question":"Given an `m x n` matrix `mat` of integers, return _the **k-th** smallest element in a sorted order (sorted in ascending order) from the matrix_. Note that the matrix is sorted row-wise and column-wise. You must develop an algorithm that works efficiently for large matrices.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted order in the given m x n row-wise and column-wise sorted matrix. # Initializing a min-heap min_heap = [] # Populate the heap with the first element of each row (element, row index, column index) for r in range(min(len(matrix), k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-the min element `k` times while k > 0: element, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"Given a non-empty 2D array `grid` representing a piece of land where `1` represents land and `0` represents water, an island is defined as a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the `grid` are surrounded by water. Determine the size of the largest island in the `grid`. Return _the size of the largest island_.","solution":"def largest_island(grid): This function takes a 2D grid and returns the size of the largest island in the grid. An island is defined as a group of 1s (land) connected 4-directionally (horizontal or vertical). if not grid: return 0 nrows, ncols = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= nrows or y < 0 or y >= ncols or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited by setting it to 0 size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(nrows): for j in range(ncols): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given a list of words `words` and a pattern `pattern`. You need to find all the words in `words` that match the given `pattern`. A word matches the pattern if there exists a bijective mapping between characters in the word and characters in the pattern such that every character in the pattern maps to exactly one character in the word and vice versa. * For example, given `words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"]` and `pattern = \\"abb\\"`, you should return `[\\"mee\\", \\"aqq\\"]`. Return the list of words from `words` that match the given `pattern`.","solution":"def find_and_replace_pattern(words, pattern): def matches(word): if len(word) != len(pattern): return False char_map = {} mapped_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in mapped_chars: return False char_map[p_char] = w_char mapped_chars.add(w_char) return True return [word for word in words if matches(word)]"},{"question":"Given a string `s`, you need to repeatedly remove all adjacent duplicates in the string until no adjacent duplicates remain. The final result should be returned. Implement a function `removeDuplicates(string s)` that returns the resulting string with no adjacent duplicates. For example, given the string `\\"abbaca\\"`, the function should return `\\"ca\\"`. The algorithm should have a linear runtime complexity and use constant extra space.","solution":"def removeDuplicates(s): Removes all adjacent duplicates in the string until no adjacent duplicates remain. :param s: Input string :return: Resulting string with no adjacent duplicates stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there exist three elements in `nums` whose sum is equal to `target`. If such a triplet exists, return `true`; otherwise, return `false`. Note that the same number can be used multiple times in different combinations. Write a function with the following signature: `bool threeSumEqualsTarget(vector<int>& nums, int target);`","solution":"def threeSumEqualsTarget(nums, target): Returns True if there exist three elements in nums whose sum is equal to target. nums.sort() n = len(nums) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if nums[i] + nums[j] + nums[k] == target: return True return False"},{"question":"You are given a 2D integer grid `grid` of size `m x n` representing a box. Each cell in the grid contains either a `0` representing an empty cell or a `1` representing a box. The grid represents a warehouse where boxes are stacked on top of each other within each column. A box can only fall down to an empty cell directly below it. Implement a function that simulates the falling of the boxes. After all the boxes have fallen down to the bottom of their respective columns, return the resulting grid. The boxes can only fall straight down, and each box moves as far down as possible within its column.","solution":"def drop_boxes(grid): Simulates the falling of the boxes within columns in a grid. Parameters: grid (list[list[int]]): A 2D integer grid representing the warehouse boxes. Returns: list[list[int]]: The resulting grid after all boxes have fallen. m, n = len(grid), len(grid[0]) for col in range(n): # Collect all boxes in the current column stack = [grid[row][col] for row in range(m) if grid[row][col] == 1] # Empty the column for row in range(m): grid[row][col] = 0 # Drop the boxes to the bottom for i in range(len(stack)): grid[m - 1 - i][col] = 1 return grid"},{"question":"You are given a binary tree where each node contains a positive integer value. The **cost** to traverse from one node to another node is defined as the absolute difference between the values of the two nodes. Your task is to find the maximum cost to traverse from the root node to any leaf node. Return _the maximum cost of all possible paths from the root to any leaf in the tree_. (Note: A leaf node is a node with no children.)","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_cost_path(root): if root is None: return 0 def helper(node, current_cost): if not node: return current_cost # Traverse left and right subtree and calculate their respective costs left_cost = helper(node.left, current_cost + (abs(node.value - node.left.value) if node.left else 0)) right_cost = helper(node.right, current_cost + (abs(node.value - node.right.value) if node.right else 0)) # Return the maximum cost from left or right subtree return max(left_cost, right_cost) return helper(root, 0)"},{"question":"You are given an array of integers `arr` representing a sequence of jobs where each job has a certain processing time. There are `k` workers available, and each worker can be assigned to exactly one job at a time. Each worker takes as long as the job assigned to them. You need to find the minimum time required to complete all jobs when the jobs can be assigned to any worker in such a way that the time taken by the worker who finishes last is minimized. Return _the **minimum possible time** to complete all jobs_.","solution":"def min_time_to_complete_jobs(arr, k): Given an array of job processing times and a number of workers, return the minimum possible time to complete all jobs such that the time taken by the worker who finishes last is minimized. # Binary search between max job time and sum of all job times def can_complete_in_time(arr, k, max_time): workers = 1 current_time = 0 for time in arr: if current_time + time > max_time: workers += 1 current_time = time if workers > k: return False else: current_time += time return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_complete_in_time(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `nums` and an integer `k`. A **continuous subarray** is defined as a subarray where the difference between the maximum and minimum values is at most `k`. Return _the length of the longest continuous subarray that meets this condition in_ `nums`. **Note:** A subarray is a contiguous part of the array, and it should have at least one element.","solution":"from collections import deque def longest_subarray(nums, k): Returns the length of the longest continuous subarray where the difference between the maximum and minimum values is at most k. if not nums: return 0 min_deque = deque() # to keep indexes of increasing elements max_deque = deque() # to keep indexes of decreasing elements left = 0 # left boundary of the window longest = 0 # result for right in range(len(nums)): # Maintain the min_deque in increasing order while min_deque and nums[min_deque[-1]] > nums[right]: min_deque.pop() min_deque.append(right) # Maintain the max_deque in decreasing order while max_deque and nums[max_deque[-1]] < nums[right]: max_deque.pop() max_deque.append(right) # Check if the current window is valid while nums[max_deque[0]] - nums[min_deque[0]] > k: if min_deque[0] == left: min_deque.popleft() if max_deque[0] == left: max_deque.popleft() left += 1 # Update the longest subarray length longest = max(longest, right - left + 1) return longest"},{"question":"Given a linked list where each node contains a single digit of a non-negative integer in reverse order, return the integer represented by the linked list. Each node contains a single digit, where the first node represents the least significant digit. For example, the linked list `2 -> 4 -> 3` represents the number `342`. Write a function to perform this conversion.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_to_integer(node): Converts a linked list into an integer. Each node contains a single digit and the digits are given in reverse order. :param node: ListNode, the head of the linked list :return: int, the integer representation of the linked list num = 0 place = 1 current = node while current: num += current.val * place place *= 10 current = current.next return num"},{"question":"Given an integer array `arr` and a threshold value `k`, write a function to determine whether there are two distinct indices `i` and `j` in the array such that the absolute difference between `arr[i]` and `arr[j]` is at most `k` and the absolute difference between `i` and `j` is at most `k`. Return `true` if such indices exist, otherwise return `false`.","solution":"def contains_nearby_almost_duplicate(arr, k): Checks if there are two distinct indices i and j in the array such that: - The absolute difference between arr[i] and arr[j] is at most k - The absolute difference between i and j is at most k Arguments: arr : List[int] - List of integers k : int - Threshold value for differences Returns: bool - True if such indices exist, False otherwise if k <= 0: return False for i in range(len(arr)): for j in range(i + 1, min(i + k + 1, len(arr))): if abs(arr[i] - arr[j]) <= k: return True return False"},{"question":"Given two integers, `n` and `k`, return the number of ways to arrange `n` distinct items into `k` non-empty groups. Note that the arrangement is considered unique only if the groups themselves are unique in terms of contents. In other words, two groups with the same members in different orders are considered the same group.","solution":"from math import comb def arrange_into_groups(n, k): Returns the number of ways to arrange n distinct items into k non-empty groups. # Using Stirling numbers of the second kind if k == 0 or n == 0: return 0 if k == 1: return 1 if n > 0 else 0 if k > n: return 0 S = [[0 for x in range(k+1)] for y in range(n+1)] S[0][0] = 1 for i in range(1, n+1): for j in range(1, k+1): S[i][j] = j * S[i-1][j] + S[i-1][j-1] return S[n][k]"},{"question":"You are given a list of `n` integers, `arr`, which represent the weights of `n` stones. In each turn, you can select any two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash is: - If `x == y`, both stones are destroyed. - If `x != y`, the stone weight `x` is destroyed, and the stone weight `y` is replaced with the new weight `y - x`. Your goal is to determine the weight of the last remaining stone (if any). If all stones are destroyed, return `0`. Create a function that calculates and returns the weight of the last remaining stone. Note: You may assume all weights are positive integers.","solution":"import heapq def last_stone_weight(arr): Determine the weight of the last remaining stone after repeatedly applying the stone-smashing process. :param arr: List of integers, where each integer represents the weight of a stone. :return: An integer representing the weight of the last remaining stone. If all stones are destroyed, returns 0. # Convert all stone weights to negative numbers, since heapq is a min-heap by default arr = [-a for a in arr] heapq.heapify(arr) while len(arr) > 1: y = -heapq.heappop(arr) # heaviest stone x = -heapq.heappop(arr) # second heaviest stone if x != y: # If x and y are not equal, push the difference back into the heap heapq.heappush(arr, -(y - x)) return -arr[0] if arr else 0"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to find the length of the smallest substring that contains at least one occurrence of the most frequently occurring character in the string. If multiple substrings have the same length, return the length of the first one found.","solution":"def smallest_substring_containing_most_frequent_char(s): from collections import Counter # Step 1: Find the most frequent character(s) freq = Counter(s) most_frequent_char = max(freq, key=freq.get) max_freq = freq[most_frequent_char] # Step 2: Find the smallest substring containing at least one occurrence # of the most frequent character min_length = float(\'inf\') n = len(s) for i in range(n): if s[i] == most_frequent_char: for j in range(i, n): if s[j] == most_frequent_char: min_length = min(min_length, j - i + 1) break return min_length"},{"question":"You are given an integer array `days` where `days[i]` represents the number of hours you spent studying on the `i-th` day. You are also provided an integer `threshold` that represents the minimum number of hours required to be considered an effective study day. A contiguous subarray is called **productive** if every day in the subarray meets or exceeds the `threshold`. Return the length of the longest productive subarray. If no such subarray exists, return `0`.","solution":"def longest_productive_subarray(days, threshold): Returns the length of the longest productive subarray where every element is greater than or equal to the threshold. :param days: List[int] - List of integers representing hours spent on each day. :param threshold: int - The threshold for productive hours. :return: int - Length of the longest productive subarray. max_length = 0 current_length = 0 for hours in days: if hours >= threshold: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"You are given a list of integers representing points a player scored in multiple levels of a game, stored in a non-empty array `points`. The player\'s final score is the sum of three highest-scoring levels. Write a function that returns the final score of the player. If the player has less than three levels, return the sum of all available points. For example, given the input array `points = [100, 200, 300, 400]`, the function should return `900` (300 + 400 + 200). Another example is with `points = [50, 60]`, the function should return `110` as there are less than three levels.","solution":"def final_score(points): Returns the final score of the player by summing the three highest-scoring levels, or the sum of all available points if there are less than three levels. :param points: List of integers. :return: Integer representing the final score. if len(points) < 3: return sum(points) return sum(sorted(points, reverse=True)[:3])"},{"question":"You are given two integer arrays `nums1` and `nums2`, both of which contain unique elements. A subset of `nums1` can be regarded as a subsequence in `nums2` if all elements of the subset appear in `nums2` in the same order as they do in `nums1`, but not necessarily consecutively. Return _the length of the longest possible subsequence of `nums1` that is also a subsequence in `nums2`_.","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest possible subsequence of nums1 that is also a subsequence in nums2. n, m = len(nums1), len(nums2) # dp[i][j] will store the length of the longest common subsequence of nums1[0..i-1] and nums2[0..j-1] dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"A transportation company operates a series of routes in a city represented by a directed, weighted graph where each node is a station and each edge is a bus route between two stations with a specific travel time. Given a list of routes represented as `edges` where `edges[i] = [u, v, w]` indicates a direct bus route from station `u` to station `v` that takes `w` minutes, your task is to find the shortest travel time between two specified stations `src` and `dst`. If there is no path between the two stations, return `-1`. Return _the shortest travel time from station_ `src` _to station_ `dst` _, or_ `-1` _if no such path exists_.","solution":"import heapq import collections def find_shortest_travel_time(edges, src, dst): Returns the shortest travel time from station src to station dst or -1 if no such path exists. Args: edges (List[List[int]]): List of routes represented as [u, v, w] where there is a direct bus route from station u to station v taking w minutes. src (int): The source station. dst (int): The destination station. Returns: int: The shortest travel time from station src to station dst, or -1 if no path exists. # Create a graph from the edges graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Min-heap to keep track of shortest distances heap = [(0, src)] # (travel_time, station) distances = {src: 0} while heap: current_time, u = heapq.heappop(heap) if u == dst: return current_time for v, w in graph[u]: new_time = current_time + w if v not in distances or new_time < distances[v]: distances[v] = new_time heapq.heappush(heap, (new_time, v)) return -1"},{"question":"You are given a list of integers `nums` where each integer represents the number of stones in a pile. You are playing a game with another player where you take turns removing stones. On each turn, a player must take one, two, or three stones from the pile. The player who removes the last stone wins the game. Given that both players play optimally, determine whether the player forced to play first will win or lose. Return `true` if the first player will win, and `false` otherwise.","solution":"def can_win_nim(nums): Determines if the first player can win the game given optimal play. :param nums: List[int] - a list of integers where each integer represents the number of stones in a pile :return: bool - True if the first player will win, False otherwise def can_win_single_pile(n): return n % 4 != 0 return all(can_win_single_pile(n) for n in nums)"},{"question":"You are given a string `s` that consists of only lowercase alphabetical characters. A substring of `s` is called a **good substring** if all the characters of the substring are distinct. Return _the number of **good substrings** of length `n`_ that can be found in string `s`. If there are no such substrings, return `0`.","solution":"def count_good_substrings_of_length_n(s, n): Returns the number of good substrings of length n in string s where all characters are distinct. if n > len(s): return 0 good_substring_count = 0 for i in range(len(s) - n + 1): substring = s[i:i+n] if len(set(substring)) == n: good_substring_count += 1 return good_substring_count"},{"question":"Given a list of non-negative integers `nums`, you are tasked to calculate and return the **maximum sum** you can obtain by removing some (possibly all or none) elements from the list such that **no two removed elements are adjacent** in the original list. Elements in the list `nums` are non-negative and there can be zero or more elements between any two removed elements.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the list. if not nums: return 0 n = len(nums) if n == 1: return nums[0] prev2, prev1 = 0, 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"You are given a string `s` composed of lowercase English letters. You need to determine the length of the longest substring without repeating characters. Return this length. **Example:** ```plaintext Input: s = \\"abcabcbb\\" Output: 3 Explanation: The answer is \\"abc\\", with the length of 3. ``` **Example:** ```plaintext Input: s = \\"bbbbb\\" Output: 1 Explanation: The answer is \\"b\\", with the length of 1. ``` **Example:** ```plaintext Input: s = \\"pwwkew\\" Output: 3 Explanation: The answer is \\"wke\\", with the length of 3. ```","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an array of integers `nums` and an integer `k`, return the number of unique k-pairs where pair (i, j) (i < j) has the sum equal to `k`. A k-pair is a pair of distinct indices whose elements add up to `k`. Ensure that each pair (i, j) is counted exactly once. Return the number of unique k-pairs in the array.","solution":"def count_k_pairs(nums, k): Given an array of integers nums and an integer k, return the number of unique k-pairs where pair (i, j) (i < j) has the sum equal to k. A k-pair is a pair of distinct indices whose elements add up to k. Args: nums (List[int]): List of integers. k (int): Target sum. Returns: int: Number of unique k-pairs. num_count = {} count = 0 pairs = set() for num in nums: if k - num in num_count: pair = tuple(sorted((num, k - num))) if pair not in pairs: pairs.add(pair) count += 1 num_count[num] = num_count.get(num, 0) + 1 return count"},{"question":"Given a `root` of a binary tree, you need to find the sum of the values of the deepest leaves in the tree. The deepest leaves are the nodes with the maximum depth from the root. The depth of a node is the number of edges from the root to the node. Return the sum of the values of these deepest leaves. For example, if the binary tree is represented as follows: ``` 1 / 2 3 /| | 4 5 6 7 / 8 9 ``` The deepest leaves are the nodes with values 8 and 9. So, the sum of the values of the deepest leaves is 8 + 9 = 17.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for i in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"You are given two strings `str1` and `str2`. Your task is to find the minimum number of operations required to make `str1` a subsequence of `str2`. In one operation, you can: 1. Insert any character anywhere in `str1`. 2. Delete any character from `str1`. Return the minimum number of operations required to make `str1` a subsequence of `str2`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def min_operations_to_subsequence(str1, str2): Returns the minimum number of operations required to make str1 a subsequence of str2. # Get the lengths of both strings m, n = len(str1), len(str2) # Create a DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) # The length of the longest common subsequence (LCS) is dp[m][n] lcs_length = dp[m][n] # Minimum operations: # Deletions in str1: m - lcs_length # Insertions in str1: none needed return m - lcs_length"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values, but in alternating order, i.e., reverse the order of traversal every other level. For example, if the binary tree root has the following structure: ``` 3 / 9 20 / 4 5 7 ``` Your output should be like: ``` [ [3], [20, 9], [4, 5, 7] ] ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): Returns the zigzag (alternating order) level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`. Merge `nums1` and `nums2` and return _the k-th smallest element_ in the merged sorted array. If there is no such element, return `-1`. Write an algorithm that runs in `O(log(min(nums1.length, nums2.length)))` time.","solution":"def find_kth_smallest(nums1, nums2, k): def kth_smallest_util(arr1, arr2, k): len1, len2 = len(arr1), len(arr2) if len1 > len2: return kth_smallest_util(arr2, arr1, k) if len1 == 0: return arr2[k-1] if k <= len2 else -1 if k == 1: return min(arr1[0], arr2[0]) idx1 = min(len1, k // 2) idx2 = k - idx1 if arr1[idx1 - 1] < arr2[idx2 - 1]: return kth_smallest_util(arr1[idx1:], arr2, k - idx1) else: return kth_smallest_util(arr1, arr2[idx2:], k - idx2) total_length = len(nums1) + len(nums2) if k > total_length: return -1 return kth_smallest_util(nums1, nums2, k)"},{"question":"You are given a string `ingredients` representing a recipe, where each character denotes an ingredient. You want to find the shortest subsequence that contains all the unique ingredients in the recipe in the order of their first appearance. Return the shortest subsequence as a string. For instance, if the `ingredients` is \\"abacbc\\", the shortest subsequence would be \\"abc\\" because all the unique ingredients \\"a\\", \\"b\\", and \\"c\\" appear in that order. If the `ingredients` is \\"aadbbc\\", the shortest subsequence would be \\"adbc\\". To clarify, a subsequence is derived from another string by deleting some or no characters without disturbing the relative positions of the remaining characters.","solution":"def shortest_subsequence(ingredients): Returns the shortest subsequence containing all unique ingredients in order of their first appearance. Args: ingredients (str): A string representing a recipe. Returns: str: The shortest subsequence containing all unique ingredients. seen = set() result = [] for ingredient in ingredients: if ingredient not in seen: seen.add(ingredient) result.append(ingredient) return \'\'.join(result)"},{"question":"Given a string `s`, you are allowed to choose one contiguous substring of `s` and delete all of its occurrences in the string. The operation can be performed any number of times, but not consecutively on overlapping substrings. Return the length of the shortest possible string you can achieve after performing the operation as many times as you wish. For example, given `s = \\"ababcb\\"`, one possible sequence of operations could be: - Delete \\"ab\\", resulting in `s = \\"cb\\"`. - Delete \\"cb\\", resulting in `s = \\"\\"`. Hence, the length of the shortest possible string is 0.","solution":"def shortest_possible_string(s): Given a string s, you are allowed to choose one contiguous substring of s and delete all of its occurrences in the string. Return the length of the shortest possible string you can achieve. # Create a set of unique characters in the string unique_chars = set(s) # The length of the shortest possible string would be # the number of unique characters in the string. return len(unique_chars)"},{"question":"You are given a list of words `words` and a target word `target`. Each word in the list is given a score based on the number of characters it shares with the target word. The score of a word is defined as the count of characters that appear in both the word and the target word at the same positions (i.e., the characters match also in their positions). You need to find the maximum score from the list of words and return it. If no words match any character with the target word, return 0.","solution":"def max_score(words, target): Returns the maximum score from the list of words based on the number of characters that match in both the word and the target word at the same positions. def score(word, target): return sum(1 for w, t in zip(word, target) if w == t) return max((score(word, target) for word in words), default=0)"},{"question":"You are given two strings `s` and `t` of the same length `n` consisting of lowercase letters. You are also given an integer `m`. Your task is to transform string `s` into string `t` using exactly `m` operations. In one operation, you can select a character in `s` and replace it with any lowercase letter (including the same letter). Return `true` if it is possible to transform `s` into `t` using exactly `m` operations, otherwise return `false`.","solution":"def can_transform(s, t, m): Determines if string s can be transformed into string t using exactly m operations. Parameters: s (str): The original string. t (str): The target string. m (int): The exact number of operations allowed. Returns: bool: True if s can be transformed into t using exactly m operations, False otherwise. if len(s) != len(t): return False # Calculate the number of differing characters between s and t diff_count = sum(1 for a, b in zip(s, t) if a != b) if diff_count > m: return False # More differences than allowed operations means it\'s impossible # We need exactly m operations, so the remaining operations must be spare operations # where we can simply replace a character with itself remaining_operations = m - diff_count return remaining_operations % 2 == 0"},{"question":"You are given an array of integers `arr` where each element appears exactly `k` times except for one element which appears exactly once. Write a function to find the single element that appears only once. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def find_single_element(arr, k): Finds the single element that appears only once in the array where every other element appears exactly k times. Parameters: arr (list): List of integers where each element appears exactly k times except for one element. Returns: int: The single element that appears only once. if not arr: return None # Return None if the input array is empty # Initialize a variable for tracking the result result = 0 # Iterate over each bit position for i in range(32): # Assuming a 32-bit integer sum_bits = 0 # Initialize sum of bits at the ith position # Check each number in the array for num in arr: if num & (1 << i): # Check if the ith bit is set sum_bits += 1 # If the sum_bits is not divisible by k, this bit must belong to the unique element if sum_bits % k: result |= (1 << i) # Since Python uses arbitrary precision for integers, we mask it to handle negative values properly max_int = (1 << 31) if result >= max_int: result -= (1 << 32) return result"},{"question":"You are given a **0-indexed** integer array `arr` which represents the height of each building in a row. You can remove any number of buildings, but you want to keep the skyline aesthetically pleasing. An aesthetically pleasing skyline should have heights in non-decreasing order from the leftmost building to the rightmost. Return _the **minimum number** of buildings that need to be removed to achieve an aesthetically pleasing skyline_.","solution":"def min_buildings_to_remove(arr): Returns the minimum number of buildings that need to be removed to achieve a non-decreasing order of heights from left to right. def longest_increasing_subsequence_length(arr): if not arr: return 0 lis = [arr[0]] for height in arr[1:]: if height >= lis[-1]: lis.append(height) else: idx = binary_search(lis, height) lis[idx] = height return len(lis) def binary_search(lis, x): lo, hi = 0, len(lis) while lo < hi: mid = (lo + hi) // 2 if lis[mid] <= x: lo = mid + 1 else: hi = mid return lo return len(arr) - longest_increasing_subsequence_length(arr)"},{"question":"Design a function that, given a list of intervals representing a set of events, merges all overlapping intervals and returns a list of the merged intervals. Each interval is represented as a tuple `(start, end)`, where `start` and `end` are integers. The given intervals are not necessarily sorted. For example, given the intervals `[(1, 3), (2, 6), (8, 10), (15, 18)]`, the function should return `[(1, 6), (8, 10), (15, 18)]` after merging the overlapping intervals. **Note:** Ensure the intervals in the result are also sorted in ascending order by their start times.","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of the merged intervals. Args: intervals (list of tuples): List of intervals represented as tuples (start, end). Returns: list of tuples: List of merged intervals sorted by start time. if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"Given a 2D matrix `grid` of integers where each row is sorted in non-decreasing order and each column is sorted in non-decreasing order, write a function that finds a target integer `x` in the matrix. If found, return the position of `x` as a tuple `(row, column)`. If `x` is not found, return `(-1, -1)`.","solution":"def find_target_in_matrix(grid, x): Finds a target integer x in a 2D matrix grid. If found, returns the position of x as a tuple (row, column). If x is not found, returns (-1, -1). if not grid or not grid[0]: return (-1, -1) rows, cols = len(grid), len(grid[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if grid[row][col] == x: return (row, col) elif grid[row][col] > x: col -= 1 else: row += 1 return (-1, -1)"},{"question":"Given a singly linked list of integers, reverse the list and return the reversed list. You must do this in-place without using any extra space for another linked list. For example, given the input linked list `1 -> 2 -> 3 -> 4 -> 5`, the output should be `5 -> 4 -> 3 -> 2 -> 1`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed linked list. prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine if there are three integers in `nums` that add up to the given `target`. If such a triplet exists, return the triplet as a list of integers in non-decreasing order. If there are multiple solutions, return any one of them. If no such triplet exists, return an empty list. Note that the triplet returned should not contain duplicate sets; i.e., order of elements within the list does not count as a different set.","solution":"def three_sum(nums, target): Returns a triplet of integers from the list that add up to the target. If no such triplet exists, returns an empty list. nums.sort() n = len(nums) result = [] for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 if result: return result[0] return []"},{"question":"You are given a string `events` where each character represents a type of event. The character can be either \'C\' (Concert), \'S\' (Sports), \'P\' (Party), or \'O\' (Other). You are to organize these events such that: * All events of the same type are grouped together. * The order of the first occurrence of each event type in the input string should be preserved in the output. Return the rearranged string of events following the above rules.","solution":"from collections import OrderedDict def organize_events(events): Organizes the events such that all events of the same type are grouped together and the order of the first occurrence of each event type in the input string is preserved. :param events: str : Input string representing events. :return: str : Rearranged string of events. event_dict = OrderedDict() for event in events: if event in event_dict: event_dict[event] += event else: event_dict[event] = event return \'\'.join(event_dict.values())"},{"question":"You are given a **0-indexed** integer array `arr` of even length `n` and an integer `m`. Your task is to split the array into `n/2` pairs such that the sum of every pair equals `m`. Return `true` if the array can be split into the desired pairs, otherwise return `false`. Note: Each element in the array can only be used once.","solution":"def can_split_into_pairs(arr, m): Returns True if the given array can be split into pairs such that the sum of each pair equals m, otherwise returns False. from collections import Counter if len(arr) % 2 != 0: return False count = Counter(arr) for num in arr: if count[num] == 0: continue complement = m - num if count[complement] > 0: count[num] -= 1 count[complement] -= 1 else: return False return True"},{"question":"Given an array of distinct integers, find all unique triplets in the array which gives the sum of zero. Your solution should not include duplicate triplets. Each triplet must be in non-descending order (i.e., [x, y, z] with x <= y <= z). Return a list of all triplets such that their sum is zero.","solution":"def three_sum(nums): Returns a list of unique triplets in the array which gives the sum of zero. Each triplet is in non-descending order. nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return res"},{"question":"Given an array `heights` representing the heights of columns in a histogram (where the width of each column is `1`), find the area of the largest rectangle that can be formed by any number of consecutive columns. Return the area of the largest rectangle in the histogram. Note: The histogram is represented as an array of integers, where each integer represents the height of the column at that index. Here is an example for clarity: ``` Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The largest rectangle has an area of 10 units, formed by heights[2], heights[3], and heights[4] (heights 5 and 6, width 2).","solution":"def largest_rectangle_area(heights): Function to find the area of the largest rectangle in the histogram. stack = [] max_area = 0 for i, height in enumerate(heights): start = i while stack and stack[-1][1] > height: index, h = stack.pop() max_area = max(max_area, h * (i - index)) start = index stack.append((start, height)) for i, h in stack: max_area = max(max_area, h * (len(heights) - i)) return max_area"},{"question":"You are given a 2D integer array `matrix` representing a rectangular grid with `m` rows and `n` columns. The value in the `i-th` row and `j-th` column denotes the cost of stepping on the cell `(i, j)`. Starting at the top-left cell `(0, 0)`, you want to reach the bottom-right cell `(m-1, n-1)` with the minimum possible cost. In each step, you can move only to the right cell or the bottom cell. Define a function that returns the minimum cost to travel from the top-left to the bottom-right of the grid.","solution":"def minPathSum(matrix): Returns the minimum cost to travel from the top-left to the bottom-right of the grid. Only moves to the right or down are allowed. :param matrix: List[List[int]] - 2D list representing the grid :return: int - minimum cost to travel from top-left to bottom-right if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize the cost matrix with the same dimensions as matrix cost = [[0] * n for _ in range(m)] # Set the cost of the top-left cell cost[0][0] = matrix[0][0] # Fill out the first column for i in range(1, m): cost[i][0] = cost[i-1][0] + matrix[i][0] # Fill out the first row for j in range(1, n): cost[0][j] = cost[0][j-1] + matrix[0][j] # Fill out the rest of the cost matrix for i in range(1, m): for j in range(1, n): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + matrix[i][j] # The cost of the bottom-right cell is the answer return cost[m-1][n-1]"},{"question":"You are given an array `words` consisting of strings made up of lowercase English letters. A word is considered a **palindromic word** if it can be read the same forwards and backwards. Your task is to determine the **maximum length** of a palindromic word that can be formed by concatenating any two different words from the `words` array. Return _the **maximum length** of a palindromic word that can be created, or 0 if it\'s not possible to form a palindromic word._","solution":"def is_palindrome(word): return word == word[::-1] def max_palindromic_concatenation(words): max_length = 0 n = len(words) for i in range(n): for j in range(i + 1, n): if is_palindrome(words[i] + words[j]): max_length = max(max_length, len(words[i]) + len(words[j])) if is_palindrome(words[j] + words[i]): max_length = max(max_length, len(words[i]) + len(words[j])) return max_length"},{"question":"Given a string `s`, find the number of distinct non-empty substrings of `s` that are palindromes. A palindrome is a string that reads the same backward as forward. For example, given `s = \\"aabaa\\"`, the distinct palindromic substrings are `\\"a\\"`, `\\"aa\\"`, `\\"aaa\\"`, `\\"aabaa\\"`, `\\"b\\"`. Therefore, the output should be `5`.","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct non-empty substrings of s that are palindromes. n = len(s) palindromes = set() # To check for palindromic substrings centered at every character: for center in range(n): # Odd-length palindromes: l, r = center, center while l >= 0 and r < n and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 # Even-length palindromes: l, r = center, center + 1 while l >= 0 and r < n and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 return len(palindromes)"},{"question":"Given a 2D matrix `matrix`, write a function that returns a list of elements of the matrix in spiral order. The spiral order starts at the top left corner, progresses to the right, then down the last column, then to the left along the bottom row, then up the first column, and continues spiraling inward until all elements are traversed. The matrix will have at least one element. **Example:** ``` Input: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ```","solution":"def spiralOrder(matrix): Returns the elements of the matrix in spiral order. result = [] while matrix: # Add the first row to the result result += matrix.pop(0) # Add the last column to the result (if it exists) if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Add the last row to the result in reverse (if it exists) if matrix: result += matrix.pop()[::-1] # Add the first column to the result in reverse (if it exists) if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer array `indices` of the same length as `s`. The `indices` array contains unique integers from `0` to `n-1`, where `n` is the length of `s`. The goal is to permute the characters of `s` such that each character `s[i]` moves to `indices[i]` in the resulting permutation. Return _the permuted string_.","solution":"def permute_string(s, indices): Permute the characters of the string s such that the character at index i moves to indices[i] in the resulting string. :param s: A string consisting of lowercase alphabets. :param indices: A list of integers containing unique values from 0 to len(s)-1. :return: The permuted string. n = len(s) result = [\'\'] * n # Create a list of empty strings with the same length as s for i, index in enumerate(indices): result[index] = s[i] # Place character s[i] at the position indices[i] return \'\'.join(result) # Combine the list into a single string and return"},{"question":"Given an array of integers `arr` and an integer `target`, return the starting and ending indices of the largest contiguous subarray that sums up to `target`. If there is no such subarray, return `[-1, -1]`. A subarray is a contiguous part of an array.","solution":"def find_largest_subarray_with_sum(arr, target): Finds the starting and ending indices of the largest contiguous subarray that sums to \'target\'. Args: arr : List[int] : The input array of integers target : int : The target sum for the subarray Returns: List[int] : A list containing the starting and ending indices of the largest subarray that sums up to target, or [-1, -1] if no such subarray exists. if not arr: return [-1, -1] max_length = 0 result = [-1, -1] sum_dict = {0: -1} current_sum = 0 for i, num in enumerate(arr): current_sum += num if (current_sum - target) in sum_dict: start_index = sum_dict[current_sum - target] + 1 end_index = i current_length = end_index - start_index + 1 if current_length > max_length: max_length = current_length result = [start_index, end_index] if current_sum not in sum_dict: sum_dict[current_sum] = i return result"},{"question":"You are given a graph with `n` nodes labeled from `0` to `n-1`. You are asked to find the shortest path from the starting node `start` to the destination node `end` in an undirected graph. The graph is represented by an array `edges` where `edges[i] = [u, v, w]` indicates there is an edge between nodes `u` and `v` with weight `w`. If there is no path from `start` to `end`, return `-1`. Return _the shortest path from `start` to `end` in the given graph. If there is no such path, return `-1`._","solution":"import heapq def shortest_path(n, edges, start, end): Finds the shortest path from start to end in a weighted undirected graph. Parameters: n (int): number of nodes edges (List[List[int]]): list of edges where each edge is represented as [u, v, w] start (int): starting node end (int): destination node Returns: int: the weight of the shortest path. If no path exists, returns -1. # Create adjacency list graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue for Dijkstra\'s algorithm min_heap = [(0, start)] # (cost, node) distances = {i: float(\'inf\') for i in range(n)} distances[start] = 0 while min_heap: current_cost, current_node = heapq.heappop(min_heap) # If the destination is reached if current_node == end: return current_cost for neighbor, weight in graph[current_node]: distance = current_cost + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1"},{"question":"Given a list of `n` unique integers, find an integer in the range `[1, n + 1]` that is not present in the list. Implement a function that returns the missing integer.","solution":"def find_missing_number(arr): Finds the missing number in the range [1, n+1] given a list of n unique integers. Args: arr (list of int): List of n unique integers. Returns: int: The missing integer in the range [1, n+1]. n = len(arr) total_sum = (n + 1) * (n + 2) // 2 # Sum of first (n + 1) natural numbers arr_sum = sum(arr) return total_sum - arr_sum"},{"question":"You are given a string `s` and an integer `k`. The string `s` represents a ciphertext, and your task is to decrypt the ciphertext using a Caesar cipher with a right shift of `k`. The Caesar cipher shifts each letter in the string by `k` positions in the alphabet while wrapping around if necessary. Non-alphabet characters should remain unchanged. Return the decrypted string. For example: - Input: `s = \\"d e f!\\"`, `k = 3` - Output: `\\"a b c!\\"`","solution":"def decrypt_caesar_cipher(s, k): Decrypts a ciphertext `s` using a Caesar cipher with a right shift of `k`. def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') - shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') - shift) % 26 + ord(\'A\')) else: return c decrypted = \'\'.join(shift_char(c, k) for c in s) return decrypted"},{"question":"Given a list of `n` words, you need to find the longest word that can be constructed by concatenating copies of any of the other words in the list. The word must be formed using at least one of the other words in the list. If there are multiple possible results, return the word that is lexicographically smallest. If no such word exists, return an empty string.","solution":"def can_form(word, word_set, memo): if word in memo: return memo[word] for i in range(1, len(word)): left, right = word[:i], word[i:] if left in word_set and (right in word_set or can_form(right, word_set, memo)): memo[word] = True return True memo[word] = False return False def longest_concatenated_word(words): word_set = set(words) memo = {} longest = \\"\\" for word in words: word_set.remove(word) if can_form(word, word_set, memo): if len(word) > len(longest) or (len(word) == len(longest) and word < longest): longest = word word_set.add(word) return longest"},{"question":"You are given a **0-indexed** string `s` containing only lowercase English letters and an integer `x`. You need to determine if it is possible to select a non-empty subsequence of `s` such that the ASCII value of its characters sums up to `x`. If such a subsequence exists, return `true`; otherwise, return `false`. A subsequence is derived by deleting zero or more characters from the string without changing the order of the remaining characters.","solution":"def can_form_sum(s, x): Returns whether it\'s possible to select a non-empty subsequence of s such that the ASCII value of its characters sums up to x. # Create a set to track possible sums possible_sums = set([0]) for char in s: ascii_val = ord(char) new_sums = set() for sum_val in possible_sums: new_sum = sum_val + ascii_val if new_sum == x: return True new_sums.add(new_sum) possible_sums.update(new_sums) return False"},{"question":"You are given a string `s` consisting of only lowercase English letters. A substring is defined as a contiguous sequence of characters within the string. A distinct letter in the string is a letter that appears only once throughout the string. Return the total number of substrings that contain exactly one distinct letter.","solution":"def count_substrings_with_one_distinct_letter(s): Returns the total number of substrings that contain exactly one distinct letter. total = 0 n = len(s) i = 0 while i < n: char = s[i] count = 0 while i < n and s[i] == char: i += 1 count += 1 total += count * (count + 1) // 2 return total"},{"question":"A software developer needs to process a log of transactions that contains different types of operations with varying levels of impacts on system resources. Each entry in the log is represented by an integer value, where positive integers indicate an increase in a specific resource, and negative integers indicate a decrease in that resource. Your task is to determine the **minimum** level of the resource at any point in the transaction sequence, starting with an initial resource level of 0. The transaction log is provided as an integer array `transactions`. Return the minimum resource level encountered during the entire sequence of transactions.","solution":"def min_resource_level(transactions): Determine the minimum resource level at any point in the transaction sequence. :param transactions: List of integers representing transaction log. :return: Minimum resource level encountered. current_level = 0 min_level = 0 for transaction in transactions: current_level += transaction if current_level < min_level: min_level = current_level return min_level"},{"question":"A network engineer is tasked with evaluating an integer array `arr`, which represents packet sizes arriving at a network buffer. Your goal is to merge consecutive duplicate packet sizes into a single packet while maintaining the order. For example, given the array `[2, 2, 1, 1, 1, 3, 3, 2]`, the merged array would be `[2, 1, 3, 2]`. Return _the merged array after combining consecutive duplicates into single entries._","solution":"def merge_consecutive_duplicates(arr): Merges consecutive duplicate elements in the list \'arr\' into single entries. Args: arr (list): A list of integers representing packet sizes. Returns: list: A list with consecutive duplicates merged into single entries. if not arr: return [] merged_arr = [arr[0]] for packet in arr[1:]: if packet != merged_arr[-1]: merged_arr.append(packet) return merged_arr"},{"question":"You are given a 2D integer matrix `grid` representing a rectangular map where each element represents the height of a cell. Two cells are considered connected if they share an edge. A water body is a region of cells that are all at the same height and connected to each other. Determine the number of distinct water bodies in the given `grid`. Return _the total number of water bodies found in the grid_.","solution":"def num_water_bodies(grid): Returns the number of distinct water bodies in the grid. if not grid: return 0 def dfs(x, y, height): Depth-First Search to mark the entire water body. if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != height: return grid[x][y] = None # mark as visited # Explore all four directions dfs(x + 1, y, height) dfs(x - 1, y, height) dfs(x, y + 1, height) dfs(x, y - 1, height) num_bodies = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] is not None: # found an unvisited water body num_bodies += 1 dfs(i, j, grid[i][j]) return num_bodies"},{"question":"You are given two integer arrays `nums1` and `nums2` of length `n`, both containing integers from 1 to `n`. You need to create a new array `result` of length `n` such that for each index `i`: 1. `result[i]` is either `nums1[i]` or `nums2[i]`. 2. `result` is a permutation of the integers from 1 to `n`. Determine whether it\'s possible to construct such an array `result`. If such an array exists, return `true`; otherwise, return `false`.","solution":"def can_construct_permutation(nums1, nums2): Determine if it\'s possible to construct a permutation of 1 to n from nums1 and nums2. Each element in the resultant array should be either from nums1 or nums2 and the resultant array should contain all integers from 1 to n. :param nums1: List[int] :param nums2: List[int] :return: bool n = len(nums1) potential_elements = set(range(1, n+1)) # All elements from 1 to n chosen_elements = set() # Track chosen elements for i in range(n): if nums1[i] in potential_elements: chosen_elements.add(nums1[i]) potential_elements.remove(nums1[i]) elif nums2[i] in potential_elements: chosen_elements.add(nums2[i]) potential_elements.remove(nums2[i]) else: return False # If neither nums1[i] nor nums2[i] is available, return False # Check if all numbers from 1 to n are used return len(chosen_elements) == n"},{"question":"You are given a **0-indexed** integer array `temps` representing the daily temperatures for a certain period, where `temps[i]` is the temperature on the `ith` day. You need to find the length of the longest subarray in which the temperatures are strictly increasing on each day except the first day. Return _the length of the **longest strictly increasing subarray**_.","solution":"def longest_increasing_subarray(temps): Returns the length of the longest strictly increasing subarray in the given list of temperatures. if not temps: return 0 max_length = 1 current_length = 1 for i in range(1, len(temps)): if temps[i] > temps[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given two integer arrays, `nums1` and `nums2`, which are sorted in **non-decreasing** order, merge `nums2` into `nums1` as one sorted array. The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively, and `nums1` has a size of `m + n` to accommodate the elements from `nums2`.","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 in sorted order. Parameters: nums1 (List[int]): The first sorted array with m initialized elements and m+n size. m (int): Number of initialized elements in nums1. nums2 (List[int]): The second sorted array with n initialized elements. n (int): Number of initialized elements in nums2. Returns: None: nums1 is modified in-place. # Start filling nums1 from the end while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 # If there are remaining elements in nums2, place them in nums1 while n > 0: nums1[n - 1] = nums2[n - 1] n -= 1"},{"question":"You are given a matrix `grid` where each cell represents a colored piece of land. Each piece of land might belong to one or more nations. The cell values are positive integers where each unique integer represents a different nation. If two cells with the same nation\'s integer value are adjacent, they belong to the same territory of that nation. Territories can be in any shape but are composed of contiguous cells of the same nation. Write a function to determine the largest territory area (number of cells) that belongs to any single nation in the `grid`. The grid connections are 4-directional (up, down, left, right). Consider the following example: ``` grid = [ [1, 1, 2], [3, 1, 2], [3, 3, 2] ] ``` In the provided grid, nation `1` has a territory area of `3` cells, nation `2` has a territory area of `3` cells, and nation `3` has a territory area of `3` cells. The largest territory area in this grid is `3`. Return _the area of the largest territory_.","solution":"def find_largest_territory(grid): Determines the largest territory area (number of cells) that belongs to any single nation in the grid. if not grid: return 0 def dfs(r, c, nation): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != nation: return 0 grid[r][c] = -1 # Mark as visited return 1 + dfs(r-1, c, nation) + dfs(r+1, c, nation) + dfs(r, c-1, nation) + dfs(r, c+1, nation) max_area = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] > 0: nation = grid[r][c] area = dfs(r, c, nation) max_area = max(max_area, area) return max_area"},{"question":"In a game, you are given a list of integers representing the power levels of wizards. You are also provided with a target integer `S`, which represents a specific power level sum you need to achieve using consecutive wizards. Write a function that determines whether there exists a contiguous subarray of wizards\' power levels that sums up exactly to `S`. If such a subarray exists, return `true`; otherwise, return `false`.","solution":"def has_subarray_with_sum(power_levels, S): Determines whether there exists a contiguous subarray of wizards\' power levels that sums exactly up to S. Parameters: power_levels (list of int): The list of integers representing wizards\' power levels. S (int): The target sum. Returns: bool: True if there exists a contiguous subarray that sums up to S, False otherwise. current_sum = 0 start_index = 0 sums_map = {} for end_index, power_level in enumerate(power_levels): current_sum += power_level if current_sum == S: return True if (current_sum - S) in sums_map: return True sums_map[current_sum] = end_index return False"},{"question":"You are given an array `candies` where `candies[i]` represents the number of candies in the `i-th` pile. You can perform the following operation any number of times (possibly zero): choose any pile of candies and discard half (rounded down) of the candies in that pile. For example, if there are `9` candies in a pile, you may discard `4` candies, leaving `5` candies in the pile. Your goal is to minimize the number of candies in all piles. Return the minimum number of total candies that can remain after performing the operations any number of times.","solution":"def min_candies(candies): Returns the minimum number of total candies that can remain after discarding half of the candies in any pile any number of times. def discard_half(c): Discards half of the candies until remaining candies are 0 or 1. while c > 1: c //= 2 return c return sum(discard_half(c) for c in candies)"},{"question":"You are given a list of `n` integers representing the heights of buildings in a city on a perfectly flat landscape aligned in a straight line. The goal is to determine the maximum amount of water that can be trapped after a rainfall that fills the gaps between the buildings. Write a function to compute the total amount of water trapped between the buildings. The heights of the buildings are given in a list `heights` of length `n`, where `heights[i]` is the height of the building at position `i`. Return the total units of water that the buildings can trap.","solution":"def trap(heights): Compute the total amount of water that can be trapped given the heights of buildings. :param heights: List[int] - A list representing heights of buildings :return: int - The total amount of water trapped if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max values left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right max values right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"A networking system is designed such that each computer is identified by a unique integer ID. Computers are connected to each other directly forming a tree (an acyclic connected graph). Your task is to write a function to find the **critical connections** in this network. A critical connection is an edge that, if removed, will make the network disconnected, resulting in more than one connected component. The connections are given as a list of pairs `connections` where `connections[i] = [u, v]` represents a connection between computer `u` and computer `v`. Implement the function `List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections)` where: - `n` is the number of computers, each labeled from `0` to `n-1`. - `connections` is a list of pairs representing the connected computers. The function should return a list of all critical connections in the network in any order.","solution":"def critical_connections(n, connections): from collections import defaultdict def dfs(node, parent, depth): ids[node] = low[node] = depth for neighbor in graph[node]: if neighbor == parent: continue if ids[neighbor] == -1: dfs(neighbor, node, depth + 1) low[node] = min(low[node], low[neighbor]) if ids[node] < low[neighbor]: result.append([node, neighbor]) else: low[node] = min(low[node], ids[neighbor]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) ids = [-1] * n low = [-1] * n result = [] for i in range(n): if ids[i] == -1: dfs(i, -1, 0) return result"},{"question":"Given a string `S` consisting of lowercase letters, your task is to compress it using the following method: For a group of consecutive repeating characters, replace the group with the character followed by the number of repetitions. If the length of the compressed string is not smaller than the original string, return the original string. Implement this function and return the compressed string.","solution":"def compress_string(S): Compresses the given string using the counts of consecutive repeating characters. Parameters: S (str): The input string consisting of lowercase letters Returns: str: The compressed string if it is shorter than the original string, otherwise the original string. if not S: return S compressed = [] count = 1 for i in range(1, len(S)): if S[i] == S[i - 1]: count += 1 else: compressed.append(S[i - 1] + str(count)) count = 1 # Add the last group compressed.append(S[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(S) else S"},{"question":"Given a **0-indexed** string `s` and an integer `k`, split the string into as many substrings as possible, each of length `k`. Return _an array of these substrings_. If the string cannot be exactly divided into substrings of length `k`, then the last substring should contain the remaining characters.","solution":"def split_string(s, k): Split the string `s` into as many substrings as possible of length `k`. If it cannot be divided exactly, the last substring will contain the remaining characters. :param s: Input string :param k: Length of each substring :return: List of substrings substrings = [] for i in range(0, len(s), k): substrings.append(s[i:i+k]) return substrings"},{"question":"You are given an integer array `arr` and an integer `k`. You need to find the length of the longest contiguous subarray whose sum is equal to `k`. If there is no such subarray, return `0`. For example, given the array `arr = [1, -1, 5, -2, 3]` and `k = 3`, the function should return `4` because the longest subarray with sum equal to `3` is `[1, -1, 5, -2]`. Similarly, given the array `arr = [-2, -1, 2, 1]` and `k = 1`, the function should return `2` because the longest subarray with sum equal to `1` is `[-1, 2]`.","solution":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest contiguous subarray whose sum is equal to k. If there is no such subarray, returns 0. sum_map = {} sum_map[0] = -1 # to handle case when subarray starts from index 0 current_sum = 0 max_length = 0 for i, num in enumerate(arr): current_sum += num if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"You are working on a database management system and need to handle multiple queries efficiently. You are given an integer array `data` and a list of queries `queries`. Each query is represented as a tuple `(i, j)` where `i` and `j` are indices within the array. For each query, you need to return the sum of the elements in the array from index `i` to index `j` (both inclusive). Return _an array of integers where each integer represents the sum for the corresponding query in the input list_. Example: ``` data = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (2, 4)] ``` Output: ``` [6, 9, 12] ```","solution":"def sum_queries(data, queries): Returns the sum of elements for each query in the list of queries. Parameters: data (list): A list of integers. queries (list): A list of tuples where each tuple represents a query with start and end indices (i, j). Returns: list: A list of sums corresponding to each query. results = [] for i, j in queries: results.append(sum(data[i:j+1])) return results"},{"question":"You are given two integer arrays `arr1` and `arr2` of equal length. Your task is to merge these arrays into a single integer array `result` such that: * The even-indexed positions of `result` are filled with the elements from `arr1` in ascending order. * The odd-indexed positions of `result` are filled with the elements from `arr2` in descending order. Return the merged array `result`. For example, given `arr1 = [4, 1, 3]` and `arr2 = [9, 5, 6]`, the resulting `result` array should be `[1, 9, 3, 6, 4, 5]`.","solution":"def merge_arrays(arr1, arr2): Merges two arrays such that the even indices are from arr1 in ascending order and odd indices are from arr2 in descending order. # Sort arr1 in ascending order arr1_sorted = sorted(arr1) # Sort arr2 in descending order arr2_sorted = sorted(arr2, reverse=True) # Initialize result array with the size of arr1 and arr2 result = [0] * (len(arr1) + len(arr2)) # Fill the even indices with elements from arr1_sorted result[0::2] = arr1_sorted # Fill the odd indices with elements from arr2_sorted result[1::2] = arr2_sorted return result # Example usage # arr1 = [4, 1, 3] # arr2 = [9, 5, 6] # Resultant array should be [1, 9, 3, 6, 4, 5] # print(merge_arrays(arr1, arr2))"},{"question":"You are given a string `s` consisting of lowercase alphabets and the character \'#\'. For every occurrence of \'#\', the preceding character gets deleted. Return the final string after all \'#\'\'s have been processed. Note that the given string may contain no \'#\' characters, one or more \'#\' characters, and the sequence of these characters may lead to an empty string.","solution":"def process_string(s): Processes the string by removing the character preceding every \'#\' and the \'#\' itself. Args: s (str): input string containing lowercase alphabets and \'#\' characters. Returns: str: the final processed string after applying the described rules. result = [] for char in s: if char == \'#\': if result: result.pop() else: result.append(char) return \'\'.join(result) # Example usage: # s = \\"ab#c\\" # print(process_string(s)) # Output: \\"ac\\""},{"question":"Given a list of integers `arr`, rearrange the elements in such a way that for any two consecutive elements `arr[i]` and `arr[i+1]`, their sum is not divisible by a given integer `k`. If such an arrangement is not possible, return an empty list. Return the rearranged list if possible.","solution":"def rearrange_elements(arr, k): Rearranges the elements in the list such that the sum of any two consecutive elements is not divisible by k. If not possible, returns an empty list. from itertools import permutations for perm in permutations(arr): valid = True for i in range(len(perm) - 1): if (perm[i] + perm[i + 1]) % k == 0: valid = False break if valid: return list(perm) return []"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `x`. Your task is to determine the length of the shortest subarray (contiguous sequence) of `arr` whose sum is at least `x`. If such a subarray does not exist, return `-1`. Keep in mind that the array can contain both positive and negative integers.","solution":"def shortest_subarray_with_sum_at_least_x(arr, x): Returns the length of the shortest subarray whose sum is at least x. If such a subarray does not exist, returns -1. from collections import deque import sys n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] min_len = sys.maxsize deque_prefix_sums = deque() for i in range(n + 1): while deque_prefix_sums and prefix_sums[i] - prefix_sums[deque_prefix_sums[0]] >= x: min_len = min(min_len, i - deque_prefix_sums.popleft()) while deque_prefix_sums and prefix_sums[i] <= prefix_sums[deque_prefix_sums[-1]]: deque_prefix_sums.pop() deque_prefix_sums.append(i) return min_len if min_len != sys.maxsize else -1"},{"question":"You are given an array `nums` of length `n` consisting of non-negative integers. You are also given a target integer `T`. Your task is to find and return all unique triplets `a, b, c` from the array such that ( a + b + c = T ). Each triplet in the result should be sorted in ascending order and the result should be sorted in ascending order based on the first element of each triplet, then the second element, and finally the third element. If no such triplets are found, return an empty list. Note that the same number from the array can be used multiple times if necessary.","solution":"def three_sum(nums, T): nums.sort() n = len(nums) result = [] for i in range(n-2): # Avoid duplicates for the first number if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == T: result.append([nums[i], nums[left], nums[right]]) # Avoid duplicates for the second number while left < right and nums[left] == nums[left + 1]: left += 1 # Avoid duplicates for the third number while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < T: left += 1 else: right -= 1 return result"},{"question":"Given a list of strings `words`, each string `words[i]` contains only lowercase letters. A string `b` is a **subsequence** of a string `a` if `b` can be obtained from `a` by deleting some (possibly zero) characters of `a`. You need to find the longest string in `words` that can be formed by deleting some characters of the given string `s`. If there are multiple possible results, return the one that is lexicographically smallest. If there is no possible result, return an empty string. Given a string `s` and an array of strings `words`, find the required longest string that matches the criteria described.","solution":"def findLongestWord(s, words): Finds the longest string in words that can be formed by deleting some characters of s. If there are multiple results, returns the lexicographically smallest one. If there is no result, returns an empty string. def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) longest_word = \\"\\" for word in words: if is_subsequence(word, s): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"A common problem in text processing is to identify the **longest common prefix** among a group of strings. The longest common prefix of a set of strings is the longest initial portion of all the strings in the set that is identical. * For example, the longest common prefix of `[\\"flower\\", \\"flow\\", \\"flight\\"]` is `\\"fl\\"`. * If there is no common prefix, return an empty string `\\"\\"`. Given an array of strings, return the longest common prefix of the strings. If there is no common prefix, return an empty string.","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Parameters: strs (List[str]): A list of strings Returns: str: The longest common prefix or an empty string if there is none if not strs: return \\"\\" prefix = strs[0] for s in strs[1:]: while s.find(prefix) != 0: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"You are given a string `s` consisting of lowercase English letters and integers from 0 to 9. Write a function to determine if `s` can be rearranged to form a palindrome ignoring the numeric characters. The function should return `True` if it is possible, otherwise `False`. A **Palindrome** is a string that reads the same forwards as backwards.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if the string `s` can be rearranged to form a palindrome ignoring numeric characters. Parameters: s (str): Input string consisting of lowercase English letters and digits. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. # Remove numeric characters filtered_s = \'\'.join(filter(str.isalpha, s)) # Count frequency of each character char_count = Counter(filtered_s) # Check the number of odd occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome, # there must be at most one character with an odd count return odd_count <= 1"},{"question":"You are given a string `s` that contains only characters \'a\' and \'b\'. You can swap any two characters in the string any number of times. Return the length of the longest subsequence of characters \'a\' and \'b\' such that all the \'b\'s come before any \'a\'. Note that the characters within this subsequence do not need to be contiguous in the original string.","solution":"def longest_subsequence_length(s): Returns the length of the longest subsequence where all \'b\'s come before all \'a\'s. count_a = s.count(\'a\') count_b = s.count(\'b\') return count_a + count_b"},{"question":"You are given an n-ary tree, in which each node contains a value and a list of its children. Implement a function to perform a level-order traversal of the n-ary tree, where the nodes are visited from left to right at each level. A node is defined as: ```python class Node: def __init__(self, value=None, children=None): self.value = value self.children = children if children is not None else [] ``` The function should return a list of lists, where each sublist represents the nodes at that particular level from top to bottom. **Example:** ``` Input: root = [1, [3, [5, 6], 2, 4]] Output: [[1], [3, 2, 4], [5, 6]] ``` **Explanation:** The input represents the following n-ary tree: ``` 1 / | 3 2 4 / 5 6 ``` The level order traversal returns [[1], [3, 2, 4], [5, 6]].","solution":"class Node: def __init__(self, value=None, children=None): self.value = value self.children = children if children is not None else [] def level_order_traversal(root): if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.value) queue.extend(node.children) result.append(current_level) return result"},{"question":"Given a list of `n` integers, return all unique triplets in the list that sum up to zero. Each triplet in the output must be sorted in ascending order, and the output must not contain duplicate triplets. The function should return a list of lists, where each inner list is the triplet of integers that sum to zero.","solution":"def three_sum(nums): Returns a list of lists of unique triplets in the list nums that sum to zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicates left, right = i + 1, n - 1 while left < right: total_sum = nums[i] + nums[left] + nums[right] if total_sum < 0: left += 1 elif total_sum > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # skip duplicates left += 1 right -= 1 return result"},{"question":"Given an array of integers `arr` and an integer `x`, you need to find the maximum sum of any subarray of length `x`. Implement the function `maxSubarraySum(arr, x)` where: * `arr` is the input array of integers. * `x` is the length of the subarray. The function should return an integer representing the maximum sum of any subarray of length `x` found within the input array `arr`.","solution":"def maxSubarraySum(arr, x): Returns the maximum sum of any subarray of length x. # Edge case: if x is greater than array length n = len(arr) if x > n: return None max_sum = float(\'-inf\') current_sum = 0 for i in range(x): current_sum += arr[i] max_sum = current_sum for i in range(x, n): current_sum += arr[i] - arr[i - x] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `threshold`. Your task is to find the maximum element in `arr` such that the element is greater than the `threshold`. If no such element exists, return -1.","solution":"def find_max_above_threshold(arr, threshold): Finds the maximum element in the list `arr` that is greater than `threshold`. Returns -1 if no such element exists. Parameters: arr (list): List of integers. threshold (int): The threshold value. Returns: int: Maximum element greater than threshold, or -1 if no such element exists. max_element = -1 for num in arr: if num > threshold and num > max_element: max_element = num return max_element"},{"question":"You are given a list of `triplets` where each triplet `triplets[i] = [ai, bi, ci]` represents the lengths of the sides of a triangle. Write a function that determines which triplets can form a valid triangle and returns the list of indices of such triplets. A valid triangle must meet the following conditions: for any triplet [a, b, c], the sum of any two sides must be greater than the third side (i.e., `a + b > c`, `a + c > b`, and `b + c > a`). Return the list of indices in ascending order.","solution":"def valid_triangle_indices(triplets): Given a list of triplets, determine the indices of triplets which can form a valid triangle. A valid triangle must satisfy the condition that the sum of any two sides must be greater than the third side. :param triplets: List of triplets, where each triplet is a list of three integers :return: List of indices of valid triangle triplets in ascending order valid_indices = [] for i, (a, b, c) in enumerate(triplets): if a + b > c and a + c > b and b + c > a: valid_indices.append(i) return sorted(valid_indices)"},{"question":"You are given an integer array `height` representing the heights of buildings, and an integer `bricks` and an integer `ladders`. You need to determine the furthest building you can reach if you can use the `bricks` to climb smaller heights and the `ladders` to climb taller heights. You can start at building 0 and move to the next building by climbing a height difference of `height[i+1] - height[i]` between the current building `i` and the next building `i+1`. Return the index of the furthest building you can reach. * Implement the function `int furthestBuilding(vector<int>& height, int bricks, int ladders)`, which will return the furthest building index that can be reached.","solution":"import heapq def furthest_building(height, bricks, ladders): Determine the furthest building that can be reached using bricks and ladders. :param height: List of heights of the buildings. :param bricks: Number of bricks available. :param ladders: Number of ladders available. :return: The index of the furthest building that can be reached. min_heap = [] for i in range(len(height) - 1): diff = height[i+1] - height[i] if diff > 0: heapq.heappush(min_heap, diff) if len(min_heap) > ladders: bricks -= heapq.heappop(min_heap) if bricks < 0: return i return len(height) - 1"},{"question":"You are managing a parking lot with `n` parking spots, where each parking spot can either be occupied or vacant. You receive a series of `m` parking requests, where each request consists of a type (either \'enter\' or \'exit\') and a spot number. If the request is of type \'enter\', a car tries to park at the given spot number. If it is \'exit\', a car at the given spot number leaves. If a car attempts to park at an already occupied spot or tries to leave from an already vacant spot, these actions are considered invalid. Given the initial states of the parking spots as a binary array `initial_states` with length `n` (where `initial_states[i]` is `1` if the spot is occupied and `0` if it is vacant), and a list of `m` requests, return _a list indicating whether each request is valid or invalid_. Your function should output an array of `m` boolean values, where `true` represents a valid request and `false` represents an invalid request.","solution":"def manage_parking_lot(initial_states, requests): Manages a parking lot with initial states and parking requests, and returns a list indicating whether each request is valid or invalid. Parameters: initial_states (list[int]): A list where 1 represents occupied and 0 represents vacant spots. requests (list[tuple]): A list of tuples where each tuple has a request type (\'enter\'/\'exit\') and a spot number. Returns: list: A list of booleans indicating validity of each request. n = len(initial_states) results = [] for request in requests: request_type, spot = request if request_type == \'enter\': if initial_states[spot] == 1: results.append(False) # invalid request to park because the spot is already occupied else: initial_states[spot] = 1 # park the car and mark the spot as occupied results.append(True) elif request_type == \'exit\': if initial_states[spot] == 0: results.append(False) # invalid request to leave because the spot is already vacant else: initial_states[spot] = 0 # leave the spot and mark it as vacant results.append(True) return results"},{"question":"You are given an integer array `arr` which contains 0s, 1s, and 2s. Implement the Dutch National Flag algorithm to sort the array in ascending order (0s followed by 1s and then 2s). Your solution should run in O(n) time and should not use extra space for another array. Return the sorted array.","solution":"def dutch_national_flag(arr): Sorts the array containing 0s, 1s, and 2s in ascending order using the Dutch National Flag algorithm. :param arr: List of integers containing only 0s, 1s, and 2s :return: Sorted list with 0s followed by 1s and then 2s low = 0 mid = 0 high = len(arr) - 1 while mid <= high: if arr[mid] == 0: arr[low], arr[mid] = arr[mid], arr[low] low += 1 mid += 1 elif arr[mid] == 1: mid += 1 else: # arr[mid] == 2 arr[mid], arr[high] = arr[high], arr[mid] high -= 1 return arr"},{"question":"Given a list of integers `nums` and an integer `target`, return the number of subarrays that add up to the target. A subarray is a contiguous non-empty sequence of elements within the array.","solution":"def subarray_sum(nums, target): Returns the number of subarrays that add up to the target. :param nums: List of integers. :param target: The target sum. :return: Number of subarrays that sum to target. count = 0 current_sum = 0 prefix_sum = {0: 1} for num in nums: current_sum += num if (current_sum - target) in prefix_sum: count += prefix_sum[current_sum - target] if current_sum in prefix_sum: prefix_sum[current_sum] += 1 else: prefix_sum[current_sum] = 1 return count"},{"question":"Given a list of non-overlapping intervals sorted by their start time, insert a new interval into the list and merge if necessary such that the intervals remain non-overlapping and sorted by their start time. Each interval is represented as a pair of integers `[start, end]`. The new interval can partially or completely overlap with one or more of the existing intervals. Return the updated list of intervals. For example, given the intervals `[[1, 3], [6, 9]]` and a new interval `[2, 5]`, the result should be `[[1, 5], [6, 9]]` because the interval `[2, 5]` merges with `[1, 3]` to form `[1, 5]`.","solution":"def insert_interval(intervals, new_interval): result = [] i = 0 start, end = new_interval # Add all intervals that end before the new interval starts while i < len(intervals) and intervals[i][1] < start: result.append(intervals[i]) i += 1 # Merge overlapping intervals while i < len(intervals) and intervals[i][0] <= end: start = min(start, intervals[i][0]) end = max(end, intervals[i][1]) i += 1 result.append([start, end]) # Add the remaining intervals while i < len(intervals): result.append(intervals[i]) i += 1 return result"},{"question":"Given an array of integers `nums` and an integer `k`, write an algorithm to find the maximum sum of **length k** subarrays in `nums`. A subarray is a contiguous part of the array and must consist of exactly `k` elements. Implement a solution that has a linear runtime complexity.","solution":"def max_sum_of_k_subarray(nums, k): Returns the maximum sum of length k subarrays in nums. # Initialize the maximum sum to negative infinity max_sum = float(\'-inf\') # Calculate the sum of the first k elements current_sum = sum(nums[:k]) max_sum = max(max_sum, current_sum) # Use a sliding window to calculate the sum of the remaining subarrays for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Implement a class `MyHashMap` that simulates a hashmap without using any built-in hash table libraries. Your implementation should include the following functions: * `MyHashMap()` - Initializes the hashmap. * `void put(int key, int value)` - Inserts a `(key, value)` pair into the hashmap. If the key already exists, update the corresponding value. * `int get(int key)` - Returns the value to which the specified key is mapped, or `-1` if this map contains no mapping for the key. * `void remove(int key)` - Removes the mapping for the specified key if the map contains the mapping. Ensure your implementation performs the operations in constant time on average.","solution":"class MyHashMap: def __init__(self): self.size = 10000 self.buckets = [[] for _ in range(self.size)] def _hash(self, key): return key % self.size def put(self, key, value): hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) def get(self, key): hash_key = self._hash(key) bucket = self.buckets[hash_key] for k, v in bucket: if k == key: return v return -1 def remove(self, key): hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] return"},{"question":"You are given a list of words `wordList` and two words `startWord` and `endWord`. The words in `wordList` are all of the same length. We need to transform `startWord` into `endWord` by altering exactly one character at a time. Each intermediate word must exist in the `wordList`. The transformation sequence must be as short as possible. If there is no such transformation sequence, return `0`. Return the length of the shortest transformation sequence from `startWord` to `endWord`, including `startWord` and `endWord`. For example: * Given `wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]`, `startWord = \\"hit\\"`, and `endWord = \\"cog\\"`, the answer is 5: `\\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\"`. * Given `wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]`, `startWord = \\"hit\\"`, and `endWord = \\"cog\\"`, the answer is `0` because `endWord` is not in `wordList`.","solution":"from collections import deque def word_ladder_length(startWord, endWord, wordList): Returns the length of the shortest transformation sequence from startWord to endWord, altering one character at a time and using only words from wordList. if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(startWord, 1)]) while queue: currentWord, level = queue.popleft() if currentWord == endWord: return level for i in range(len(currentWord)): for c in \'abcdefghijklmnopqrstuvwxyz\': nextWord = currentWord[:i] + c + currentWord[i+1:] if nextWord in wordSet: wordSet.remove(nextWord) queue.append((nextWord, level + 1)) return 0"},{"question":"Given a string `s` and a dictionary of words `wordDict`, return _all the sentences possible by segmenting_ `s` _such that each word is a valid dictionary word_. Each segment in the solution should be a space-separated sequence of directory words. The same word in the dictionary may be reused multiple times in the segmentation.","solution":"def word_break(s, wordDict): Returns all possible sentences by segmenting s such that each word is a valid dictionary word. def dfs(s, word_set, memo): if s in memo: return memo[s] if not s: return [\\"\\"] res = [] for word in word_set: if s.startswith(word): suffix_ways = dfs(s[len(word):], word_set, memo) for way in suffix_ways: if way: res.append(word + \\" \\" + way) else: res.append(word) memo[s] = res return res word_set = set(wordDict) memo = {} return dfs(s, word_set, memo)"},{"question":"You are given a list of non-negative integers representing the heights of a set of bars. Your task is to determine how much water can be trapped after raining. The width of each bar is `1`. For instance, given the list `heights = [4,2,0,3,2,5]`, you can trap `9` units of water. Write a function that takes in a list of integers and returns the total amount of water trapped in terms of units. The function should efficiently calculate the trapped water amount based on the provided heights.","solution":"def trap_water(heights): Calculate the total amount of water that can be trapped after raining. :param heights: List of non-negative integers representing the heights of bars. :return: Total amount of water trapped in units. if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"A company wants to implement a way to re-arrange their employee list such that specific characteristics about the employees are continuously mapped correctly. They provide you with a list of employee names, where each name is an uppercase string, and a set of rearranging rules. You are given a 2D integer array `rules` where each `rules[i] = [a, b]` means that the employee with name at the `a-th` index must come before the employee with name at the `b-th` index in the final arrangement. Return any valid ordering of the employees such that the rearranging rules are satisfied. If there are multiple valid orderings, return any of them. If it is impossible to satisfy the rules, return an empty list. **Note:** Each employee name is unique. The 1-D array of employee names and the 2-D array of rearranging rules will be provided as inputs to your function.","solution":"from collections import defaultdict, deque def find_employee_order(employees, rules): Find a valid ordering of employees such that the rearranging rules are satisfied. Args: employees: List of employee names. rules: List of rules in the form [a, b] where \'a\' should be ordered before \'b\'. Returns: List of employee names in a valid order or an empty list if no valid order exists. # Create graph and in-degree dictionary graph = defaultdict(list) in_degree = defaultdict(int) for rule in rules: graph[employees[rule[0]]].append(employees[rule[1]]) in_degree[employees[rule[1]]] += 1 # Queue for nodes with no incoming edges queue = deque(employee for employee in employees if in_degree[employee] == 0) result = [] while queue: current = queue.popleft() result.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If result contains all employees, return it, else return empty list return result if len(result) == len(employees) else []"},{"question":"You are given a linked list where each node contains an integer value and a reference to the next node. Each node additionally has a \\"child\\" pointer, which may point to a separate, potentially lengthy additional linked list. These child lists may have one or more nodes with their own child pointers, and so on, to produce a multilevel data structure. Flatten the list so that all the nodes appear in a single-level, null-terminated linked list. The returned list should use the same node objects and should be sorted in the same order as in the original multi-level linked list.","solution":"class Node: def __init__(self, value, next=None, child=None): self.value = value self.next = next self.child = child def flatten_linked_list(head): Flattens a multilevel linked list into a single-level linked list. if not head: return head stack = [] current = head while current: if current.child: if current.next: stack.append(current.next) current.next = current.child current.child = None if not current.next and stack: current.next = stack.pop() current = current.next return head"},{"question":"You are given a list of strings `words` and a string `target`. Each string in `words` represents a scrambled word. Your task is to determine if `target` can be constructed by concatenating exactly two different strings from `words`. Return `true` if `target` can be formed this way, and `false` otherwise.","solution":"def can_form_target(words, target): Determines if the target can be constructed by concatenating exactly two different strings from words. Parameters: * words: List[str] - A list of scrambled words. * target: str - The target string to form. Returns: * bool - True if target can be formed, False otherwise. word_set = set(words) for i in range(1, len(target)): prefix = target[:i] suffix = target[i:] if prefix in word_set and suffix in word_set and prefix != suffix: return True return False"},{"question":"You are given an array of integers `nums` where each element appears twice except for one, which appears exactly once. Implement the `SingleNumber` class: - `SingleNumber(int[] nums)` Initializes the object with the array `nums`. - `int findUniqueNumber()` returns the value of the single unique integer that appears only once in the array. # Example - `SingleNumber([2, 2, 1, 4, 4])` initializes the object with the input array - `findUniqueNumber()` returns `1` since it is the only integer that does not repeat","solution":"class SingleNumber: def __init__(self, nums): self.nums = nums def findUniqueNumber(self): unique_num = 0 for num in self.nums: unique_num ^= num return unique_num"},{"question":"Given a `2D` matrix `matrix`, handle multiple queries of the following types: * **Update** the value of a cell at `matrix[row][col]` to a given value `val`. * **SumRegion** returns the sum of the elements of the submatrix defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`. Implement the `Matrix` class: * `Matrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`. * `void update(int row, int col, int val)` Updates the value of `matrix[row][col]` to `val`. * `int sumRegion(int row1, int col1, int row2, int col2)` Returns the sum of the elements of the submatrix specified by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`. You must design a solution that supports _both_ `update` and `sumRegion` operations in `O(log m * log n)` time complexity where `m` is the number of rows and `n` is the number of columns in the matrix.","solution":"class FenwickTree2D: def __init__(self, m, n): self.m = m self.n = n self.tree = [[0] * (n + 1) for _ in range(m + 1)] def add(self, row, col, delta): i = row + 1 while i <= self.m: j = col + 1 while j <= self.n: self.tree[i][j] += delta j += j & -j i += i & -i def sum(self, row, col): s = 0 i = row + 1 while i > 0: j = col + 1 while j > 0: s += self.tree[i][j] j -= j & -j i -= i & -i return s class Matrix: def __init__(self, matrix): if not matrix or not matrix[0]: raise ValueError(\\"Matrix can\'t be empty\\") self.m = len(matrix) self.n = len(matrix[0]) self.matrix = matrix self.tree = FenwickTree2D(self.m, self.n) self.build() def build(self): for i in range(self.m): for j in range(self.n): self.tree.add(i, j, self.matrix[i][j]) def update(self, row, col, val): delta = val - self.matrix[row][col] self.matrix[row][col] = val self.tree.add(row, col, delta) def sumRegion(self, row1, col1, row2, col2): return self.tree.sum(row2, col2) - self.tree.sum(row1 - 1, col2) - self.tree.sum(row2, col1 - 1) + self.tree.sum(row1 - 1, col1 - 1)"},{"question":"You are given an integer array `tokens` where `tokens[i]` represents the value of the i-th token, and an integer `power`. The tokens can be used to increase your score by 1 if you pay the token\'s value in power. Alternatively, if you have at least one score, you can lose 1 score to gain an amount of power equal to the value of the token. Each token can be used at most once and in any order. Return _the maximum score_ you can achieve.","solution":"def maxScore(tokens, power): Given an array of tokens and an initial power, this function returns the maximum score that can be achieved using the strategy described. tokens.sort() i, j = 0, len(tokens) - 1 score = 0 max_score = 0 while i <= j: if power >= tokens[i]: power -= tokens[i] score += 1 max_score = max(max_score, score) i += 1 elif score > 0: power += tokens[j] score -= 1 j -= 1 else: break return max_score"},{"question":"Given an integer array `nums` of size `n`, write a function to determine whether there exists a subsequence of length 3 that forms an increasing sequence. An increasing sequence is such that the first number is less than the second number and the second number is less than the third number. Return `true` if such a subsequence exists, otherwise return `false`.","solution":"def increasing_subsequence(nums): Determines if there exists a subsequence of length 3 that forms an increasing sequence. Args: nums (list of int): The input array of integers. Returns: bool: True if there exists an increasing subsequence of length 3, False otherwise. if len(nums) < 3: return False first = float(\'inf\') second = float(\'inf\') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"A company is building a new system to analyze code written in a specific programming language. They need a function that identifies the longest common subsequence (LCS) of two given strings `text1` and `text2`, which represent lines of code. The LCS is the longest sequence that can be derived from both strings without changing the order of characters. Given these two strings, write a function that returns the length of their longest common subsequence. You can assume that the input strings consist of only English alphabets and are non-empty.","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of two given strings. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Given a `m x n` matrix `grid` initialized with these three possible values: - `-1` representing an obstacle, - `0` representing an empty cell, - `1` representing a source of gold. Your goal is to find the maximum amount of gold you can collect starting from any cell containing gold and moving to any adjacent cell up, down, left, or right without visiting any cell more than once. You cannot move into any obstacle or revisit a cell. If there\'s no gold to collect, return `0`.","solution":"def getMaximumGold(grid): def dfs(x, y, current_gold): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] <= 0: return current_gold original_value = grid[x][y] grid[x][y] = 0 # mark the cell as visited current_gold += original_value max_gold = current_gold for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy max_gold = max(max_gold, dfs(new_x, new_y, current_gold)) grid[x][y] = original_value # unmark the cell return max_gold max_collected_gold = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] > 0: max_collected_gold = max(max_collected_gold, dfs(i, j, 0)) return max_collected_gold"},{"question":"Given a string `s` containing a mixture of characters and digits, find the largest numerical value formed by concatenating all digit characters in `s`. If there are no digit characters in the string, return -1.","solution":"def largest_numerical_value(s): Returns the largest numerical value formed by concatenating all digit characters in the string s. If there are no digit characters in the string, returns -1. digits = [char for char in s if char.isdigit()] if not digits: return -1 digits.sort(reverse=True) return int(\'\'.join(digits))"},{"question":"Design a class for managing a playlist of songs. Each song has a unique ID and a play count, and the playlist should support the following operations: adding a song, deleting a song, playing a song which increases its play count, and retrieving the song with the highest play count. If multiple songs have the same highest play count, return any one of them. Implement the `PlaylistManager` class: * `PlaylistManager()` Initializes an empty playlist. * `void addSong(int songID)` Adds a song with the given `songID` to the playlist with an initial play count of 0. If the song already exists in the playlist, it does nothing. * `void deleteSong(int songID)` Removes the song with the given `songID` from the playlist. If the song does not exist in the playlist, it does nothing. * `void play(int songID)` Increases the play count of the song with the given `songID` by 1. If the song does not exist in the playlist, it does nothing. * `int getTopSong()` Returns the `songID` of the song with the highest play count. If multiple songs have the same highest play count, return any one of them. If the playlist is empty, return -1. Make sure to optimize the retrieval of the song with the highest play count.","solution":"class PlaylistManager: def __init__(self): self.playlist = {} self.play_counts = {} def addSong(self, songID): if songID not in self.playlist: self.playlist[songID] = 0 self.play_counts[songID] = 0 def deleteSong(self, songID): if songID in self.playlist: del self.playlist[songID] del self.play_counts[songID] def play(self, songID): if songID in self.playlist: self.playlist[songID] += 1 self.play_counts[songID] = self.playlist[songID] def getTopSong(self): if not self.play_counts: return -1 # Return the songID with the max play count. In case of tie, any one will be returned return max(self.play_counts, key=self.play_counts.get)"},{"question":"You are given a string `s` consisting of lowercase English letters. You can apply the following operation any number of times: * Choose any two adjacent characters in the string, and if they are equal, remove both of them from the string. Your task is to determine the final string after performing the above operation as many times as possible. Return the resulting string. If the final string is empty, return an empty string.","solution":"def remove_adjacent_pairs(s): Removes pairs of adjacent equal characters from the string s until no more pairs can be removed. Returns the resulting string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an **m**-by-**n** binary grid `grid` representing a map of **0s** (land) and **1s** (water). An island is a maximal 4-directionally connected group of **0s** and a lake is a maximal 4-directionally connected group of **1s** completely surrounded by land. Your task is to find the number of distinct lakes in the given `grid`. Return an integer representing the total number of distinct lakes.","solution":"def num_lakes(grid): def dfs(x, y): if not (0 <= x < m and 0 <= y < n) or grid[x][y] != 1: return False grid[x][y] = \'#\' for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy) return True def is_surrounded(x, y): stack = [(x, y)] visited.add((x, y)) is_surrounded = True while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if not (0 <= nx < m and 0 <= ny < n): is_surrounded = False continue if (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) stack.append((nx, ny)) return is_surrounded m, n = len(grid), len(grid[0]) visited = set() lakes = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: if is_surrounded(i, j): lakes += 1 dfs(i, j) return lakes"},{"question":"Given an integer array `heights` representing the height of each student in a class, return the number of pairs of students `(i, j)` where `0 <= i < j < n` and `heights[i] < heights[j]`. The pair `(i, j)` represents student `i` and student `j`, where student `i` is shorter than student `j`. Your task is to implement a function that performs this calculation efficiently.","solution":"def count_height_pairs(heights): Returns the number of pairs (i, j) where 0 <= i < j < n and heights[i] < heights[j]. count = 0 for i in range(len(heights)): for j in range(i + 1, len(heights)): if heights[i] < heights[j]: count += 1 return count"},{"question":"You are given a list of integers `heights` representing the heights of a row of buildings. You are standing on the roof of the building with the smallest height and want to see the ocean which is on the opposite side of the row. To see the ocean, any building taller than the one you\'re currently on will block your view of subsequent buildings. Return the list of indices of the buildings that have an unobstructed view of the ocean when looking from left to right in the row. Do the same for viewing from right to left in the row and return that list of indices as well. If a building allows an unobstructed view in both directions, the index should appear in both returned lists.","solution":"def find_unblocked_views(heights): This function returns two lists representing the indices of buildings with unobstructed views when looking from left to right and from right to left. n = len(heights) # Calculate left to right view left_to_right = [] max_height_so_far = 0 for i in range(n): if heights[i] > max_height_so_far: left_to_right.append(i) max_height_so_far = heights[i] # Calculate right to left view right_to_left = [] max_height_so_far = 0 for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: right_to_left.append(i) max_height_so_far = heights[i] right_to_left.reverse() return left_to_right, right_to_left"},{"question":"Given a string `expression` representing a mathematical expression containing mixed addition and multiplication of non-negative integers. The expression has no spaces and includes only digits and the characters \'+\' and \'*\'. Write a function to evaluate the expression and return the result. The multiplication operator has higher precedence over the addition operator. **Example:** Input: \\"2+3*2\\" Output: 8 Explanation: The expression must be evaluated as 2 + (3 * 2) = 2 + 6 = 8.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, addition (+), and multiplication (*) operators. Multiplication has higher precedence over addition. :param expression: str, mathematical expression :return: int, result of evaluated expression def evaluate(tokens): stack = [] current_number = 0 operator = \'+\' for i, token in enumerate(tokens): if token.isdigit(): current_number = current_number * 10 + int(token) if token in \\"+*\\": if operator == \'+\': stack.append(current_number) elif operator == \'*\': stack[-1] = stack[-1] * current_number operator = token current_number = 0 if i == len(tokens) - 1: if operator == \'+\': stack.append(current_number) elif operator == \'*\': stack[-1] = stack[-1] * current_number return sum(stack) return evaluate(expression)"},{"question":"You are given a list of intervals representing the presence of keys in a room. Each interval `interval[i] = [start_i, end_i]` signifies that a key starts being available from time `start_i` and remains available until time `end_i`. A thief plans to enter the room at time `startTime` and exit at time `endTime`. The thief can collect any keys that are available during their time in the room. Return the **maximum number** of distinct keys that the thief can collect during their time in the room. Note that if two intervals overlap, each overlap counts as a separate key.","solution":"def max_keys_collected(intervals, startTime, endTime): Returns the maximum number of distinct keys that the thief can collect during their time in the room. starts = [] ends = [] for interval in intervals: if interval[0] < endTime and interval[1] > startTime: starts.append(max(interval[0], startTime)) ends.append(min(interval[1], endTime)) starts.sort() ends.sort() active_keys = 0 max_keys = 0 i, j = 0, 0 while i < len(starts): if starts[i] <= ends[j]: active_keys += 1 max_keys = max(max_keys, active_keys) i += 1 else: active_keys -= 1 j += 1 return max_keys"},{"question":"You are given a binary tree where each node contains a positive integer value. Each path from the root to a leaf is considered valid if it satisfies the following condition: the sum of values in the path is equal to a given target sum. Write a function that counts the number of valid paths in the tree. The function should take the root of the binary tree and an integer `targetSum` as input and return the count of valid paths. For example, given the binary tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` and `targetSum = 22`, there are two valid paths: 1. 5 -> 4 -> 11 -> 2 (which sums to 22) 2. 5 -> 8 -> 4 -> 5 (which sums to 22) Return the count of valid paths that equal the target sum.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_valid_paths(root, targetSum): if not root: return 0 # Helper function to count paths that sum to target starting from current node def count_paths_from_node(node, remaining_sum): if not node: return 0 count = 0 if node.value == remaining_sum: count += 1 count += count_paths_from_node(node.left, remaining_sum - node.value) count += count_paths_from_node(node.right, remaining_sum - node.value) return count # Count paths starting from the root, and recursively from the left and right children return (count_paths_from_node(root, targetSum) + count_valid_paths(root.left, targetSum) + count_valid_paths(root.right, targetSum))"},{"question":"You are given an integer array `nums` representing a sequence of steps where each element indicates the maximum jump length that can be made from that position. Your task is to determine if it is possible to reach the last index starting from the first index. For example, given an array `nums = [2,3,1,1,4]`, starting at index `0` with a jump length of `2`, you can reach the indices `1` or `2`. From index `1` with a jump length of `3`, you can reach the indices `2`, `3`, or `4`. Thus, in this case, you can reach the last index. Implement the function `bool canJump(vector<int>& nums)` that returns `true` if you can reach the last index, or `false` otherwise. The function accepts the following parameter: * `vector<int>& nums`: An array of non-negative integers representing the steps and jump lengths.","solution":"def canJump(nums): Determines if you can reach the last index starting from the first index. :param nums: List[int], a list of non-negative integers representing the maximum jump length at each position. :return: bool, True if you can reach the last index, False otherwise max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: # Can\'t move further than the current maximum reachable index return False max_reachable = max(max_reachable, i + jump) if max_reachable >= len(nums) - 1: return True return max_reachable >= len(nums) - 1"},{"question":"You are given a 2D integer grid `grid` representing a map where `0` represents water and `1` represents land. An **island** in the grid is a group of `1\'s` (land) connected horizontally or vertically. The number of islands is the number of distinct groups of connected `1\'s`. You can assume that all four edges of the grid are surrounded by water. Return _the number of islands in_ `grid`.","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == \\"0\\": return grid[i][j] = \\"0\\" dfs(grid, i-1, j) dfs(grid, i+1, j) dfs(grid, i, j-1) dfs(grid, i, j+1) num_of_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \\"1\\": num_of_islands += 1 dfs(grid, i, j) return num_of_islands"},{"question":"You are given a 2D grid `board` containing `\'X\'` and `\'O\'`. A region is captured by flipping all `\'O\'`s into `\'X\'`s in that surrounded region. A region is surrounded if all boundaries are filled with `\'X\'`. *Given the 2D grid board, return the board after flipping all surrounded regions*. Note that any `\'O\'` connected to a boundary cannot be flipped as it is not surrounded. ```python Example: Input: board = [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\", \\"X\\"], [\\"X\\", \\"X\\", \\"O\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ] Output: [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ] ```","solution":"def solve(board): if not board or not board[0]: return rows = len(board) cols = len(board[0]) def mark_not_surrounded(i, j): if i < 0 or i >= rows or j < 0 or j >= cols or board[i][j] != \'O\': return board[i][j] = \'M\' # Mark as not surrounded # Check all adjacent cells mark_not_surrounded(i + 1, j) mark_not_surrounded(i - 1, j) mark_not_surrounded(i, j + 1) mark_not_surrounded(i, j - 1) # Step 1: Capture unsurrounded regions by marking \'O\'s on the border and their connected \'O\'s. for i in range(rows): if board[i][0] == \'O\': mark_not_surrounded(i, 0) if board[i][cols - 1] == \'O\': mark_not_surrounded(i, cols - 1) for j in range(cols): if board[0][j] == \'O\': mark_not_surrounded(0, j) if board[rows - 1][j] == \'O\': mark_not_surrounded(rows - 1, j) # Step 2: All remaining \'O\'s are surrounded, flip them to \'X\'. # Convert \'M\' back to \'O\' for i in range(rows): for j in range(cols): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'M\': board[i][j] = \'O\' return board"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` representing the number of times each person has been selected in a random draw. Initially, all values in `nums` are `0`, indicating no one has been selected yet. You are also given a **0-indexed** 2D integer array `rules` where `rules[i] = [a, b]` indicates that if person `a` is selected, then person `b` is automatically selected as well. If there are no such rules, an individual is selected independently. After processing all the rules, return the final state of the selection array `nums`.","solution":"from collections import defaultdict def apply_draw_rules(nums, rules): Applies selection rules to the initial selection array nums. Args: nums: List[int] -- The initial selection array. rules: List[List[int]] -- The list of selection rules. Returns: List[int] -- The final state of the selection array after applying the rules. def dfs(person): if seen[person]: return seen[person] = True for next_person in graph[person]: nums[next_person] += 1 dfs(next_person) n = len(nums) graph = defaultdict(list) for a, b in rules: graph[a].append(b) seen = [False] * n for i in range(n): if nums[i] > 0 and not seen[i]: dfs(i) return nums"},{"question":"You are given a list of strings `words` and a target string `target`. Your task is to determine if the `target` can be formed by concatenating any sub-sequence of strings from `words`, in any order. Return `true` if it is possible and `false` otherwise. You may assume that all string elements in `words` and `target` consist of lowercase English letters only.","solution":"def can_form_target(words, target): Determine if target can be formed by concatenating any sub-sequence of strings from words. from collections import Counter # Count the frequency of each character in target target_counter = Counter(target) # Count the frequency of each character in all words combined words_counter = Counter(\'\'.join(words)) # Check if each character in target can be formed by characters in words for char in target_counter: if target_counter[char] > words_counter[char]: return False return True"},{"question":"You are given a list of strings `words`, where each string represents a word. Two words are concatenated if they are placed next to each other. Write a function that returns the longest string formed by concatenating any sequence of strings in `words` such that all the characters in the resulting string are unique. If there is no such concatenation, return an empty string.","solution":"def is_unique_concatenation(word1, word2): Checks if concatenation of word1 and word2 results in a string with all unique characters. combined = word1 + word2 return len(set(combined)) == len(combined) def longest_unique_concatenation(words): Returns the longest string formed by concatenating any sequence of strings in \'words\' such that all characters in the resulting string are unique. n = len(words) max_length = 0 max_string = \\"\\" def backtrack(current_string, index): nonlocal max_length, max_string if len(set(current_string)) == len(current_string): if len(current_string) > max_length: max_length = len(current_string) max_string = current_string else: return for i in range(index, n): backtrack(current_string + words[i], i + 1) backtrack(\\"\\", 0) return max_string"},{"question":"You are given a 2D board and a list of words. The board is filled with lower-case letters, and each word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once per word. Find all words in the list that can be formed by this board. Return the words in ascending lexical order.","solution":"def find_words(board, words): def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False tmp, board[i][j] = board[i][j], \'#\' found = (dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1)) board[i][j] = tmp return found found_words = set() for word in words: if any(dfs(board, word, i, j, 0) for i in range(len(board)) for j in range(len(board[0]))): found_words.add(word) return sorted(found_words)"},{"question":"Given an integer array `heights`, return the number of indices `i` such that the absolute difference between the heights at index `i` and its adjacent indices are all greater than or equal to a given threshold `t`. An index `i` is valid if and only if `heights[i]` is compared with the heights at indices `i-1` (if exists) and `i+1` (if exists). Return _the number of such indices_. Note: - If `heights` contains only one element, it is considered a valid index. - The threshold `t` is a non-negative integer.","solution":"def valid_indices_count(heights, t): Returns the number of indices i such that the absolute difference between heights at index i and its adjacent indices are all greater than or equal to threshold t. n = len(heights) if n == 0: return 0 if n == 1: return 1 count = 0 for i in range(n): valid = True if i > 0 and abs(heights[i] - heights[i-1]) < t: valid = False if i < n - 1 and abs(heights[i] - heights[i+1]) < t: valid = False if valid: count += 1 return count"},{"question":"You are given an array of integers `arr` representing the allocation of work to employees in a company, where each element `arr[i]` is the amount of work assigned to the `i-th` employee. The company wants to ensure a fair distribution of work and decide if it is possible for a supervisor to redistribute the work such that no two consecutive employees have more than a given threshold `k` difference in their amount of work. Write a function `canRedistributeWork(int[] arr, int k)` that returns a boolean value `true` if it is possible to redistribute the work fairly, and `false` otherwise. To achieve this redistribution, the supervisor can only perform the following operations: - Increase the work of any employee by `1`. - Decrease the work of any employee by `1`. Return `true` if it is possible to redistribute the work fairly, otherwise return `false`.","solution":"def canRedistributeWork(arr, k): Checks if it is possible to redistribute the work such that no two consecutive employees have more than a given threshold k difference in their amount of work. Parameters: arr (list of int): A list of integers representing the work assigned to each employee. k (int): The maximum allowed difference in work between consecutive employees. Returns: bool: True if it is possible to redistribute the work fairly, False otherwise. for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > k: return False return True"},{"question":"Given an `n x n` matrix where every row and column is sorted in ascending order, write a function to find the `kth` smallest element in the matrix. The matrix is structured in a way that the smallest element is at the top-left corner and the largest element is at the bottom-right corner. Your solution should ensure optimal time complexity.","solution":"import heapq def kth_smallest(matrix, k): Returns the kth smallest element in an n x n matrix where each row and each column is sorted in ascending order. Parameters: matrix (List[List[int]]): The n x n matrix. k (int): The k-th smallest element to find. Returns: int: The k-th smallest element in the matrix. # Initialize a min-heap min_heap = [] n = len(matrix) # Initialize the heap with the first element of each row for i in range(min(k, n)): heapq.heappush(min_heap, (matrix[i][0], i, 0)) # Iterate k-1 times to extract the (k-1) smallest elements for _ in range(k - 1): val, row, col = heapq.heappop(min_heap) # If the current row has more elements, add the next element to the heap if col + 1 < n: heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1)) # The root of the heap is now the k-th smallest element return heapq.heappop(min_heap)[0]"},{"question":"You are given a grid of characters `board` representing a Scrabble board where each cell contains either an English letter or an empty string. You are also given a list of words `words` to search for on the board. A word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once per word. Return _a list of words_ `found_words` _that are present in the list_ `words` _and can be formed by a sequence of adjacent cells on the board_.","solution":"def exist(board, word): rows, cols = len(board), len(board[0]) def backtrack(r, c, suffix): if len(suffix) == 0: return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != suffix[0]: return False ret = False board[r][c] = \'#\' for (row_offset, col_offset) in [(0,1), (1,0), (0,-1), (-1,0)]: ret = backtrack(r + row_offset, c + col_offset, suffix[1:]) if ret: break board[r][c] = suffix[0] return ret for row in range(rows): for col in range(cols): if backtrack(row, col, word): return True return False def find_words(board, words): found_words = [] for word in words: if exist(board, word): found_words.append(word) return found_words"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to find two distinct integers in the array that sum up to the `target`. Return the indices of the two numbers such that they add up to the `target`. The indices returned should be in ascending order. If there are multiple pairs that satisfy the condition, return the pair with the smallest first index. If no such pair exists, return an empty array. For example, given `nums = [2, 7, 11, 15]` and `target = 9`, the function should return `[0, 1]` because `nums[0] + nums[1] = 2 + 7 = 9`.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in `nums` that add up to `target`. The indices should be returned in ascending order. If no such pair exists, return an empty array. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"You are given two arrays: `students` and `grades`, where `students[i]` is the name of the `i-th` student and `grades[i]` is the grade of the `i-th` student. Implement the `GradingSystem` class, which should be able to perform the following **operations**: * **Add** a student with a specific grade. If the student already exists, their grade should be updated. * **Delete** a student by name from the system. * **Get** the grade of a specific student by their name. If the student does not exist, return `-1`. * **Average** the grades of all students currently in the system. Implement the `GradingSystem` class: * `GradingSystem()` Initializes a new grading system. * `void addStudent(String student, int grade)` Adds the student with the provided grade, or updates the grade if the student already exists. * `void deleteStudent(String student)` Removes the student from the system. It is guaranteed that the student will exist. * `int getGrade(String student)` Returns the grade of the student, or `-1` if the student does not exist. * `double averageGrade()` Returns the average grade of all students in the system. If there are no students, return `0.0`.","solution":"class GradingSystem: def __init__(self): self.students_grades = {} def addStudent(self, student, grade): self.students_grades[student] = grade def deleteStudent(self, student): if student in self.students_grades: del self.students_grades[student] def getGrade(self, student): return self.students_grades.get(student, -1) def averageGrade(self): if not self.students_grades: return 0.0 return sum(self.students_grades.values()) / len(self.students_grades)"},{"question":"You are given a list of `n` integers representing the heights of buildings along a street. Each building can be represented by a vertical line at some point `i` with a height specified by `heights[i]`. The width of each building is `1` unit. Consider drawing a silhouette of the buildings by filling the space between them with the shorter of the respective buildings, forming a series of contiguous rectangles. Your task is to compute the *maximum area* of a rectangle formed by any number of contiguous buildings. **Hint:** Utilize a stack to keep track of the building indices and compute the area dynamically. Return the *maximum rectangle area* formed by any series of contiguous buildings.","solution":"def largest_rectangle_area(heights): Returns the maximum rectangle area formed by any number of contiguous buildings. # Initialize max_area and stack max_area = 0 stack = [] # Iterate through each building along with the dummy end building height of 0 for i in range(len(heights) + 1): current_height = heights[i] if i < len(heights) else 0 # While the stack is not empty, and the current height is less than the height of the building at stack\'s top index while stack and current_height < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) # Push the current index into the stack stack.append(i) return max_area"},{"question":"Given a string `s` containing only lowercase English letters, find the length of the longest substring with all distinct characters. If the longest substring with distinct characters repeats in multiple places, return the length of any one such substring. For example, for the input string \\"abcabcbb\\", the longest substring with all distinct characters is \\"abc\\", and its length is 3. For the input \\"bbbbb\\", the longest substring with all distinct characters is \\"b\\", and its length is 1. For the input \\"pwwkew\\", the longest substring with all distinct characters is \\"wke\\", and its length is 3. Write a function `longest_distinct_substring_length(s: str) -> int`.","solution":"def longest_distinct_substring_length(s): Returns the length of the longest substring with all distinct characters. start = 0 max_length = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"Write a function that converts an integer to its Roman numeral representation. The Roman numeral system uses the following symbols: `I, V, X, L, C, D, M`. Given an integer between 1 and 3999, return the corresponding Roman numeral as a string. The integer is guaranteed to be within the range from 1 to 3999. Roman numerals are usually written largest to smallest from left to right. However, certain instances require subtraction to avoid four identical symbols being repeated in succession. For example, `4` is not `IIII`, but `IV`, and `9` is not `VIIII`, but `IX`.","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. Args: num (int): An integer between 1 and 3999. Returns: str: The corresponding Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"Given a list of non-negative integers representing the amounts of change you have in different denominations, determine if it is possible to make the exact amount of a given sum using any combination of these denominations. Return `true` if it is possible, otherwise return `false`.","solution":"def can_make_amount(coins, amount): Determines if it\'s possible to create the exact amount using given coin denominations. :param coins: List[int] - List of coin denominations. :param amount: int - The target amount to create. :return: bool - True if the amount can be made exactly using any combination of coins, False otherwise. dp = [False] * (amount + 1) dp[0] = True # Base case: zero amount can always be made with no coins. for coin in coins: for i in range(coin, amount + 1): if dp[i - coin]: dp[i] = True return dp[amount]"},{"question":"You are given a string `text` containing a sentence with multiple words separated by single spaces. Another input is a string `brokenLetters` which contains a set of distinct characters that represent the broken keys on a keyboard. A word cannot be typed if it contains at least one broken key character. Return the number of words in the given `text` that can be fully typed using the working keys on the keyboard. Words are case-insensitive and the broken keys are also case-insensitive. The result should be presented in the format of an integer.","solution":"def can_be_typed(text, brokenLetters): Returns the number of words in the given text that can be fully typed using the working keys on the keyboard. Parameters: text (str): Input sentence. brokenLetters (str): String containing broken key characters. Returns: int: Count of words that can be typed fully. # Convert both text and brokenLetters to lowercase text = text.lower() brokenLetters = set(brokenLetters.lower()) # Split the text into words words = text.split() count = 0 for word in words: # Check if any character in the word is in the set of broken letters if not any(char in brokenLetters for char in word): count += 1 return count"},{"question":"You are given an integer array `arr` where `arr[i]` represents the number of tokens at the `ith` index. Your task is to gather all the tokens into one pile according to the following rule: - In each move, you can pick exactly two indices `i` and `j` (where `i != j`) and perform one of the following actions: - Add the tokens of `j` to `i`, or - Subtract the tokens of `j` from `i` Return the _minimum number of moves required_ to accumulate all tokens into a single pile at any index.","solution":"def min_moves_to_gather_tokens(arr): Returns the minimum number of moves required to accumulate all tokens into a single pile. # The minimum moves to gather all tokens is simply the length of the array minus one, # because in each move we are reducing the number of piles by one. n = len(arr) return n - 1"},{"question":"You are given a matrix of `m x n` size filled with non-negative integers. Perform a breadth-first search (BFS) to find and return a new matrix of the same size where each cell `(i, j)` contains the smallest distance to the nearest cell containing a zero. A distance between two cells `(i1, j1)` and `(i2, j2)` is the number of moves required to move from `(i1, j1)` to `(i2, j2)`, moving only up, down, left, or right. *Example:* `matrix = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]` `Output: [[0, 0, 0], [0, 1, 0], [1, 2, 1]]`","solution":"from collections import deque def updateMatrix(matrix): rows, cols = len(matrix), len(matrix[0]) dist = [[float(\'inf\')] * cols for _ in range(rows)] queue = deque() # Enqueue all 0 cells and set their distance as 0. for r in range(rows): for c in range(cols): if matrix[r][c] == 0: dist[r][c] = 0 queue.append((r, c)) # Define the 4 possible directions to move in the matrix. directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Perform BFS to find the shortest distance from each cell to a 0 cell. while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: if dist[nr][nc] > dist[r][c] + 1: dist[nr][nc] = dist[r][c] + 1 queue.append((nr, nc)) return dist"},{"question":"Given an array of integers `nums`, representing the prices of various items, and an integer `k` representing the budget limit, return the maximum number of items that can be purchased without exceeding the budget `k`. Each item can only be purchased once, and you must buy the items in whole. Write a function that accepts two parameters: `nums` (an array of integers) and `k` (an integer). The function should return an integer representing the maximum number of items that can be purchased within the given budget. Example: ```python nums = [20, 10, 5, 30, 100] k = 35 ``` Output: `3`","solution":"def max_items_within_budget(nums, k): Returns the maximum number of items that can be purchased within the given budget k. Parameters: nums (list of int): Prices of various items. k (int): The budget limit. Returns: int: Maximum number of items purchasable within the budget. nums.sort() total_cost = 0 items_count = 0 for price in nums: if total_cost + price <= k: total_cost += price items_count += 1 else: break return items_count"},{"question":"A company has a hierarchical reporting structure represented as an array `manager` where `manager[i]` is the direct manager of the `i-th` employee. Each employee has an efficiency rating given by the array `efficiency` where `efficiency[i]` is the efficiency rating of the `i-th` employee. If an employee has no manager, the value is `-1`. You need to find the highest combined efficiency rating for any team. A team is defined as an employee and all of their direct and indirect subordinates. Return the maximum combined efficiency rating for any team in the company.","solution":"def get_max_combined_efficiency(manager, efficiency): from collections import defaultdict, deque n = len(manager) team_efficiency = [0] * n for i in range(n): team_efficiency[i] = efficiency[i] # Build the company\'s hierarchical tree as an adjacency list using defaultdict subordinates = defaultdict(list) root = -1 for i, m in enumerate(manager): if m != -1: subordinates[m].append(i) else: root = i def dfs(employee): total_efficiency = efficiency[employee] for sub in subordinates[employee]: total_efficiency += dfs(sub) team_efficiency[employee] = total_efficiency return total_efficiency # Start DFS from the root dfs(root) return max(team_efficiency)"},{"question":"Implement a function `countSubstrings` which receives a string `s` and returns the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. The input string `s` consists of lowercase English letters only.","solution":"def countSubstrings(s): Returns the number of palindromic substrings in the given string. n = len(s) count = 0 for center in range(2*n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count"},{"question":"You are given a list of `n` items, each having a weight and a value. Additionally, you are given a maximum capacity `W` which represents the weight limit of a knapsack. Your task is to find the maximum total value of items that can be placed in the knapsack without exceeding its weight capacity. You may only include whole items in the knapsack (i.e., you cannot break items into smaller pieces). Return the maximum value that can be obtained.","solution":"def knapsack(weights, values, capacity): Solves the 0/1 Knapsack problem using dynamic programming. Parameters: weights (list): List of weights for each item. values (list): List of values for each item. capacity (int): Maximum weight capacity of the knapsack. Returns: int: The maximum value that can be obtained without exceeding the weight capacity. n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], values[i-1] + dp[i-1][w-weights[i-1]]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"You are given an array of integers `nums` representing the amount of money of each house, and another non-negative integer `k`. You are a thief planning to rob houses, but you cannot rob two adjacent houses. Design an algorithm to maximize the total amount of money you can rob, considering that after you rob a house, you must skip at least `k` houses before robbing another one. Return _the maximum amount of money you can rob given these conditions_.","solution":"def rob(nums, k): Returns the maximum amount of money that can be robbed from the houses, considering that after robbing one house, you must skip at least k houses. :param nums: List[int] - list of integers representing the amount of money at each house :param k: int - the number of houses you must skip after robbing one house :return: int - the maximum amount of money you can rob if not nums: return 0 n = len(nums) if k >= n: return max(nums) dp = [0] * n dp[0] = nums[0] for i in range(1, n): if i <= k: dp[i] = max(dp[i-1], nums[i]) else: dp[i] = max(dp[i-1], nums[i] + dp[i-k-1]) return max(dp)"},{"question":"You are tasked with designing a parking lot management system. The parking lot has a specific number of slots and supports the following operations: - `park(carPlate)`: Attempts to park the car with the given plate number into the first available slot. Returns `false` if the car is already parked or if the parking lot is full, otherwise parks the car and returns `true`. - `leave(carPlate)`: Removes the car with the given plate number from the parking lot if it is parked there. Returns `false` if the car is not parked, otherwise removes the car and returns `true`. - `status()`: Returns a list of the current car plate numbers in the parking lot, sorted from the first slot to the last slot. Empty slots are represented by `null`. You need to implement the parking lot management functionality by writing a class `ParkingLot` that supports these operations. The parking lot should be initialized with the given number of slots.","solution":"class ParkingLot: def __init__(self, num_slots): Initializes the parking lot with the given number of slots. self.num_slots = num_slots self.slots = [None] * num_slots def park(self, carPlate): Parks a car with the given plate number into the first available slot. Returns False if the car is already parked or the parking lot is full, otherwise parks the car and returns True. if carPlate in self.slots: return False for i in range(self.num_slots): if self.slots[i] is None: self.slots[i] = carPlate return True return False def leave(self, carPlate): Removes the car with the given plate number from the parking lot. Returns False if the car is not parked, otherwise removes the car and returns True. if carPlate in self.slots: index = self.slots.index(carPlate) self.slots[index] = None return True return False def status(self): Returns a list of the current car plate numbers in the parking lot, sorted from the first slot to the last slot. Empty slots are represented by None. return self.slots"},{"question":"You are given a **0-indexed** integer array `heights` of length `n`, where `heights[i]` represents the height of the `i-th` person. You want to form a queue of these people in non-decreasing order of their heights. However, you are required to swap the positions of any two people at most `k` times. Return _the array of heights after making the optimal swaps to achieve a non-decreasing order as much as possible within the given `k` swaps_.","solution":"def minSwapsToSortArray(heights, k): Returns the array of heights after making the optimal swaps to achieve a non-decreasing order as much as possible within the given k swaps. :param heights: List of integers representing heights of people. :param k: Maximum number of swaps allowed. :return: Optimally sorted heights list. n = len(heights) for i in range(n): # Find the smallest element within the range we can reach with k swaps min_idx = i for j in range(i+1, min(n, i+k+1)): if heights[j] < heights[min_idx]: min_idx = j # Can we swap to get the smallest element at the ith position? if min_idx != i: # Calculate how many swaps we need number_of_swaps = min_idx - i if k >= number_of_swaps: # Place the found minimum element at the ith position # and adjust k accordingly heights[i:min_idx+1] = [heights[min_idx]] + heights[i:min_idx] k -= number_of_swaps return heights"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of platforms at different distances. A frog can jump from platform to platform, but it can only move to a higher or the same height platform. Determine the maximum number of platforms the frog can visit, starting from any platform. Return _the **maximum** number of platforms_ the frog can visit, considering any starting platform.","solution":"def max_platforms(heights): Determine the maximum number of platforms the frog can visit, starting from any platform in a non-decreasing manner. :param heights: List[int], the heights of platforms :return: int, the maximum number of platforms the frog can visit. n = len(heights) if n == 0: return 0 max_visits = 1 for i in range(n): current_visits = 1 for j in range(i + 1, n): if heights[j] >= heights[i]: current_visits += 1 i = j max_visits = max(max_visits, current_visits) return max_visits"},{"question":"Given an array of integers `arr` and an integer `k`, rearrange the array such that the difference between the maximum and minimum values of any subsequence of length `k` is minimized. Return the minimized difference. A **subsequence** of an array is a new array generated from the original array by deleting some or no elements without changing the order of the remaining elements.","solution":"def minimize_difference(arr, k): Rearranges the array such that the difference between the maximum and minimum values of any subsequence of length k is minimized. Parameters: arr (List[int]): List of integers. k (int): Length of the subsequence. Returns: int: The minimized difference between the maximum and minimum values of any subsequence of length k. if not arr or k <= 0 or k > len(arr): return None arr.sort() min_diff = float(\'inf\') for i in range(len(arr) - k + 1): current_diff = arr[i + k - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"You have been given a grid of size `m x n` filled with non-negative integers representing the amount of money in each cell. You start at the top-left corner of the grid and are only allowed to move either down or right at any point in time. Write a function to compute the maximum amount of money you can collect by the time you reach the bottom-right corner.","solution":"def max_money_collected(grid): Computes the maximum amount of money that can be collected from the top-left corner to the bottom-right corner of the given grid. :param grid: List[List[int]] - 2D list of non-negative integers representing the grid :return: int - The maximum amount of money that can be collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a dp table dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"You are given a list of integers representing the height of buildings in a city, where each building\'s width is the same. The goal is to find the maximum amount of water that can be trapped between the buildings after it rains. Write a function that takes the list of building heights and returns the maximum volume of water that can be trapped.","solution":"def trap(height): Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. :param height: List[int] :return: int if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) total_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) total_water += right_max - height[right] return total_water"},{"question":"Given a string `s` representing a **sinusoidal wave pattern** and a positive integer `n`, your task is to return the original string by reading the pattern in a zigzag manner. A sinusoidal wave pattern can be visualized by writing the string across `n` rows in a zigzag form, starting from the top row and moving down until the `n`-th row, then moving upward back to the top row. For example, the string `PAYPALISHIRING` with `n = 4` would be written as follows: ``` P I N A L S I G Y A H R P I ``` **Input format:** ``` - A string `s` (1 ≤ |s| ≤ 1000), where |s| denotes the length of the string. - An integer `n` (1 ≤ n ≤ 10). ``` **Output format:** Return the string obtained by concatenating the characters in each row, from top to bottom. **Example:** ``` s = \\"PAYPALISHIRING\\" n = 3 ``` After writing `s` in a sinusoidal wave pattern with `n = 3`, you should return `\\"PAHNAPLSIIGYIR\\"`. Note: The function should handle cases where `n = 1` as a single row, simply returning the input string `s`.","solution":"def convert(s, n): Given a string `s` and an integer `n`, return the string in a sinusoidal wave pattern. if n == 1: return s # Create a list of empty strings for each row rows = [\'\'] * min(n, len(s)) current_row = 0 going_down = False # Traverse through characters in the input string for char in s: rows[current_row] += char if current_row == 0 or current_row == n - 1: going_down = not going_down current_row += 1 if going_down else -1 # Concatenate rows to get the final result return \'\'.join(rows)"},{"question":"You are given an array of integers `nums` containing `n` elements. Each element in the array represents a different type of flower, and `nums[i]` specifies the type of the `i`-th flower. A bouquet of flowers is considered beautiful if and only if it contains at least three flowers of the same type. You need to find the total number of different bouquets that can be made from the given flowers. Return _the total number of beautiful bouquets that can be made from the array_ `nums`.","solution":"from collections import Counter def beautiful_bouquets(nums): Returns the total number of beautiful bouquets that can be made from the given flowers array `nums`. A bouquet is considered beautiful if it contains at least three flowers of the same type. count = Counter(nums) total_bouquets = 0 for flower_type in count: if count[flower_type] >= 3: total_bouquets += 1 return total_bouquets"},{"question":"You are given a list of integers `nums` where each integer represents the number of apples in a basket. You want to distribute the apples to several children. You can give each child any number of entire baskets, but each basket must be given to exactly one child. You also want to ensure that the difference in the number of apples any two children receive is minimized. Return _the minimum possible difference between the largest and smallest number of apples given to any two children._","solution":"def min_difference(nums): Returns the minimum possible difference between the largest and smallest number of apples given to any two children. # Sort the list of baskets in non-decreasing order nums.sort() # Initialize the minimum difference to a large number min_diff = float(\'inf\') for i in range(len(nums) - 1): diff = nums[i + 1] - nums[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to find the length of the shortest subarray, which when sorted would result in the entire `nums` array being sorted in non-decreasing order. If the array is already sorted, return 0.","solution":"def findUnsortedSubarray(nums): Returns the length of the shortest subarray, which when sorted would result in the entire array being sorted in non-decreasing order. If the array is already sorted, returns 0. sorted_nums = sorted(nums) if nums == sorted_nums: return 0 start, end = 0, len(nums) - 1 while nums[start] == sorted_nums[start]: start += 1 while nums[end] == sorted_nums[end]: end -= 1 return end - start + 1"},{"question":"You are managing a series of meetings in a company, and each meeting has a specific start and end time. You want to implement a system that can efficiently decide if a new meeting can be scheduled without conflicts. Write a class `MeetingScheduler` that supports the following operations: * `MeetingScheduler()` Initializes the meeting scheduler. * `boolean scheduleMeeting(int startTime, int endTime)` Schedules a new meeting if it does not conflict with any existing meeting. A meeting conflicts with another if it starts before another meeting ends and ends after another meeting starts. Returns `true` if the meeting can be scheduled, otherwise returns `false`. * `void cancelMeeting(int startTime, int endTime)` Cancels a meeting that exactly matches the provided start and end time if it exists. If such a meeting exists, it is removed from the schedule. * `List<int[]> getAllMeetings()` Returns a list of all scheduled meetings as a list of integer arrays, where each array contains two integers representing the start and end times of a meeting, sorted by the start times. For instance, if no meetings are currently scheduled, `scheduleMeeting(9, 10)` would return `true` and add the meeting to the schedule. If a meeting from 9 to 10 is scheduled, `scheduleMeeting(9, 11)` would return `false` due to the conflict.","solution":"class MeetingScheduler: def __init__(self): # Initialize an empty list for meetings self.meetings = [] def scheduleMeeting(self, startTime, endTime): # Check for conflicts with existing meetings for meeting in self.meetings: if not (endTime <= meeting[0] or startTime >= meeting[1]): return False # If no conflicts, add the new meeting self.meetings.append([startTime, endTime]) # Sort meetings by start time self.meetings.sort() return True def cancelMeeting(self, startTime, endTime): # Find and cancel the meeting for meeting in self.meetings: if meeting[0] == startTime and meeting[1] == endTime: self.meetings.remove(meeting) break def getAllMeetings(self): # Return all meetings return self.meetings"},{"question":"You are given an integer array `nums` where each element is an integer that represents the number of items in a storage unit. A worker can retrieve items from a unit according to the following rules: - A worker can only retrieve items from one unit at a time. - Once a worker starts retrieving items from a unit, they must retrieve all the items in that unit before moving on to the next. Given an integer `k` representing the maximum number of units a worker can handle consecutively without taking a break, return the minimum number of workers needed to retrieve all the items from all storage units.","solution":"def minimum_workers(nums, k): Calculates the minimum number of workers needed to retrieve all items from all storage units, considering a worker can handle at most k units consecutively. Parameters: nums (list of int): List of integers representing the number of items in each storage unit. k (int): Maximum number of units a worker can handle consecutively without taking a break. Returns: int: Minimum number of workers needed. n = len(nums) if n == 0: return 0 workers_needed = 0 i = 0 while i < n: workers_needed += 1 # Move the index i k steps ahead or to the end of the array, whichever comes first. i += k return workers_needed"},{"question":"Write a function `missingNumber(nums)` that takes an array `nums` containing `n` distinct numbers from the range `[0, n]` and returns the only number in the range that is missing from the array. _Do not use extra space beyond O(1) and aim for linear time complexity._","solution":"def missingNumber(nums): Takes an array \'nums\' containing \'n\' distinct numbers from the range `[0, n]` and returns the only number in the range that is missing from the array. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"Given two integer arrays `nums1` and `nums2` sorted in non-decreasing order, merge `nums2` into `nums1` as one sorted array. Initialize `nums1` with a size large enough to hold the additional elements from `nums2`. The final sorted array should not return but rather modify `nums1` **in-place**.","solution":"def merge(nums1, m, nums2, n): Merge nums2 into nums1 as one sorted array in-place. :param nums1: List[int], first list with size m + n initialized with m elements followed by n zeros :param m: int, number of initialized elements in nums1 :param nums2: List[int], second list with n elements :param n: int, number of elements in nums2 :return: None, modifies nums1 in-place # Start filling nums1 from the end p1, p2, p = m - 1, n - 1, m + n - 1 while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If there are remaining elements in nums2, add them while p2 >= 0: nums1[p] = nums2[p2] p -= 1 p2 -= 1"},{"question":"You are given a **0-indexed** integer array `dist` which represents the distance between consecutive gas stations along a circular route. The last gas station connects back to the first gas station. You also have an integer `fuelCapacity`, which is the maximum amount of fuel your car can hold. Each unit of distance requires one unit of fuel. You can start at any gas station with a full tank of fuel. Determine if there exists a starting gas station such that you can travel around the entire circular route without running out of fuel at any point. If such a starting gas station exists, return its index; otherwise, return `-1`.","solution":"def can_complete_circuit(dist, fuelCapacity): Determines the starting gas station index from which you can complete a circular route without running out of fuel. :param dist: List[int] representing distances between consecutive gas stations. :param fuelCapacity: int representing the maximum fuel capacity of the car. :return: int representing the starting gas station index or -1 if not possible. total_stations = len(dist) for start in range(total_stations): fuel = fuelCapacity possible = True for i in range(total_stations): index = (start + i) % total_stations if dist[index] > fuel: possible = False break fuel -= dist[index] # consume fuel for the distance fuel = min(fuelCapacity, fuel + fuelCapacity) # refill at each station, ensuring not exceeding the capacity if possible: return start return -1"},{"question":"You are given an array of integers `arr`, representing the heights of a series of buildings. Each building can trap rainwater between it and the next taller building to its right. Write a function to return _the total amount of water trapped_ between the buildings after raining.","solution":"def trap_rain_water(arr): Returns the total amount of water trapped between buildings after raining. :param arr: List of integers representing the building heights. :return: Integer representing the total water trapped. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"You are given an array `buildings` where each element represents the height of a building. An ocean view is defined as a building that can see the ocean (i.e., there are no higher buildings to its right). Return an array of indices of these buildings in ascending order of their appearance in the `buildings` array.","solution":"def find_buildings_with_ocean_view(buildings): Returns an array of indices of buildings that have an ocean view. A building has an ocean view if no building to its right is higher than it. Args: buildings (List[int]): List of building heights. Returns: List[int]: List of indices of buildings with an ocean view in ascending order. n = len(buildings) if n == 0: return [] ocean_view_indices = [] max_height_to_right = -1 for i in range(n - 1, -1, -1): if buildings[i] > max_height_to_right: ocean_view_indices.append(i) max_height_to_right = buildings[i] ocean_view_indices.reverse() return ocean_view_indices"},{"question":"You are given a list of integers `hours`, where `hours[i]` represents the number of hours a worker has worked on the ith day. A worker is considered to be **tired** on a day if they work more than `8` hours. A worker\'s shift is a streak of consecutive tired days within the list. Return _the length of the longest shift that the worker has._ In the case where there are no `tired` days, return `0`.","solution":"def longest_tired_shift(hours): Returns the length of the longest shift of consecutive tired days max_shift, current_shift = 0, 0 for hour in hours: if hour > 8: current_shift += 1 else: max_shift = max(max_shift, current_shift) current_shift = 0 return max(max_shift, current_shift)"},{"question":"You are given a **0-indexed** integer array `changes` representing the change in elevation at each step, where a positive value represents an uphill step, and a negative value represents a downhill step. Determine the **highest** elevation point that can be reached starting from an initial elevation of `0`. Return _the highest elevation point that can be reached._","solution":"def highest_elevation(changes): Returns the highest elevation point that can be reached starting from an initial elevation of 0. Parameters: changes (list of int): The change in elevation at each step. Returns: int: The highest elevation point. current_elevation = 0 highest_elevation_reached = 0 for change in changes: current_elevation += change if current_elevation > highest_elevation_reached: highest_elevation_reached = current_elevation return highest_elevation_reached"},{"question":"Given an array of integers `arr` and a positive integer `k`, determine the minimal length of a contiguous subarray of which the sum is at least `k`. If there is no such subarray, return `0`. For example, given `arr = [2, 3, 1, 2, 4, 3]` and `k = 7`, the minimal length subarray with a sum of at least `7` is `[4, 3]`, so the function should return `2`.","solution":"def min_subarray_len(arr, k): Determines the minimal length of a contiguous subarray of which the sum is at least k. If there is no such subarray, it returns 0. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to determine the average value of the nodes on each level. For example, given the following tree: ``` 3 / 9 20 / 15 7 ``` Return the averages of each level as an array: `[3.0, 14.5, 11.0]`. The function signature should be: ```python def averageOfLevels(root: TreeNode) -> List[float]: # your code here ``` Where `TreeNode` is a class representing a node in a binary tree that has the following attributes: - `val` (int): The value of the node. - `left` (TreeNode): A pointer to the left child of the node. - `right` (TreeNode): A pointer to the right child of the node.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def averageOfLevels(root: TreeNode) -> List[float]: if not root: return [] queue = deque([root]) averages = [] while queue: level_sum = 0 level_count = len(queue) for _ in range(level_count): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) averages.append(level_sum / level_count) return averages"},{"question":"Given a list of lists of integers `heights` representing the height of buildings in a city, return _a list of lists of integers representing the skyline formed by these buildings_. Each building is represented as three integers `[start, end, height]`, where `start` is the x-coordinate of the left edge, `end` is the x-coordinate of the right edge, and `height` is the height of the building. The skyline should be represented as a sequence of \\"key points\\" in the format `[x, height]`, where `x` is the x-coordinate of the key point and `height` is the height of the skyline at that point. The key points should be sorted by x-coordinate.","solution":"import heapq def get_skyline(buildings): # Events are (x, h) where x is the coordinate and h is the height events = sorted([(L, -H, R) for L, R, H in buildings] + list({(R, 0, 0) for L, R, H in buildings})) result, heap = [[0, 0]], [(0, float(\\"inf\\"))] for x, negH, R in events: while heap[0][1] <= x: heapq.heappop(heap) if negH: heapq.heappush(heap, (negH, R)) if result[-1][1] != -heap[0][0]: result.append([x, -heap[0][0]]) return result[1:]"},{"question":"You are given a directed graph represented by an **adjacency matrix** `graph` where `graph[i][j]` represents the presence (`1`) or absence (`0`) of a directed edge from node `i` to node `j`. You are also given a starting node `start` and a destination node `end`. Your task is to determine if there is a path from `start` to `end`. Return `true` if there is a path from `start` to `end`, otherwise return `false`.","solution":"def has_path(graph, start, end): Determines if there is a path from start node to end node in a directed graph. :param graph: List[List[int]] - Adjacency matrix representation of the graph :param start: int - The starting node :param end: int - The destination node :return: bool - True if there is a path from start to end, otherwise False def dfs(current, destination, visited): if current == destination: return True visited.add(current) for neighbor, is_edge in enumerate(graph[current]): if is_edge and neighbor not in visited: if dfs(neighbor, destination, visited): return True return False visited = set() return dfs(start, end, visited)"},{"question":"You are given a list of strings `words` and another string `s`. A word is defined as a subsequence of `s` if it can be derived by deleting some or no characters of `s` without changing the order of the remaining characters. Implement a function `findLongestSubsequence(words, s)` that returns the longest word in `words` that is a subsequence of `s`. If there are multiple results, return the one that appears first in the list. If no such word exists, return an empty string.","solution":"def is_subsequence(word, target): it = iter(target) return all(char in it for char in word) def findLongestSubsequence(words, s): longest_word = \\"\\" for word in words: if is_subsequence(word, s) and (len(word) > len(longest_word) or (len(word) == len(longest_word) and words.index(word) < words.index(longest_word))): longest_word = word return longest_word"},{"question":"Given an array of integers `height` representing the height of buildings in a cityscape, determine the maximum area of water that can be trapped between the buildings. The width between each building is 1 unit. Return _an integer representing the maximum trapped water area_. Note: Water can only be trapped between buildings if there are higher buildings on both sides, and the trapped water\'s height is determined by the shorter of the two buildings.","solution":"def maxArea(height): This function returns the maximum area of water that can be trapped between buildings. :param height: List of integers representing the height of buildings :return: Integer representing the maximum trapped water area left, right = 0, len(height) - 1 max_area = 0 while left < right: # Calculate the width and height for the current left and right pointers width = right - left current_height = min(height[left], height[right]) # Update the maximum area if the current calculated area is larger max_area = max(max_area, width * current_height) # Move the pointers inward to potentially find a larger area if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"Implement a function that takes a list of integers and a target integer as input. The function should return the indices of the two numbers such that they add up to the target. Assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): Target integer. Returns: List[int]: Indices of the two numbers. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"Given a list of strings `words`, return the length of the longest sequence of strings such that each string in the sequence is formed by adding exactly one letter to the previous string in the sequence. Each added letter can be inserted at any position in the previous string. Each string in the list can only be used once in the sequence.","solution":"def longest_str_chain(words): Returns the length of the longest sequence of strings such that each string in the sequence is formed by adding exactly one letter to the previous string in the sequence. words.sort(key=len) dp = {} longest_chain_length = 1 for word in words: dp[word] = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: dp[word] = max(dp[word], dp[predecessor] + 1) longest_chain_length = max(longest_chain_length, dp[word]) return longest_chain_length"},{"question":"Given an array of integers `arr`, your task is to return _the total number of strictly increasing subsequences that can be derived from the array_. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Since the answer may be large, return it **modulo** `109 + 7`.","solution":"MOD = 10**9 + 7 def num_increasing_subsequences(arr): n = len(arr) dp = [0] * n total_subsequences = 0 for i in range(n): dp[i] = 1 # single element is considered as an increasing subsequence for j in range(i): if arr[j] < arr[i]: dp[i] = (dp[i] + dp[j]) % MOD total_subsequences = (total_subsequences + dp[i]) % MOD return total_subsequences"},{"question":"Given an array of integers `arr` and an integer `target`, return `true` if there exist two indices `i` and `j` such that `arr[i] + arr[j] == target` and `i != j`. Otherwise, return `false`.","solution":"def has_pair_with_sum(arr, target): Returns true if there exist two indices i and j such that arr[i] + arr[j] == target and i != j. Otherwise, returns false. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a 2D grid of size `m x n` representing a map of land (`1`) and water (`0`). An island is a group of `1`s (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The distance between two cells is the number of steps it takes to move from one cell to the other. You can move in one of the four directions (left, right, up, down). The **maximum island size** is the size of the largest island in the grid. Return _the maximum island size in the grid_.","solution":"def maxIslandSize(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark the cell as visited size = 1 size += dfs(x - 1, y) # up size += dfs(x + 1, y) # down size += dfs(x, y - 1) # left size += dfs(x, y + 1) # right return size max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to form a new string such that each character from `s` appears in the new string `t` exactly **once** in the same order as they appear in `s`. Additionally, if the same character appears multiple times in `s`, **only the first appearance** should be considered and all subsequent appearances should be ignored. Return _the new string `t`_.","solution":"def remove_duplicates(s): Returns a new string with characters from s that appear only once in the order they first appear in s. seen = set() result = [] for char in s: if char not in seen: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"Given a string `s` representing a sequence of lowercase English letters, we define a **substring** of `s` as a contiguous block of characters. Find the length of the **longest substring** without repeating characters. If there are multiple possible substrings of the same maximum length, return the length of any one of them.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` and an array of strings `words`. You need to check if `s` is the **concatenation** of each word in `words` exactly once and without any intervening characters. There can be multiple ways to concatenate the strings in `words`. Return `true` if `s` can be formed by concatenating the words in some order, and `false` otherwise.","solution":"def is_concatenation(s, words): Returns True if s can be formed by concatenating all the words in the words list exactly once. from itertools import permutations for perm in permutations(words): if \\"\\".join(perm) == s: return True return False"},{"question":"Given two integers `n` and `start`, create an array `nums` where `nums[i] = start + 2*i` (where `i` is the index of the array from `0` to `n-1`). Find the bitwise XOR of all elements in the `nums` array and return _the result of the XOR operation_.","solution":"def xor_operation(n, start): Returns the bitwise XOR of all elements in the array nums where nums[i] = start + 2 * i for i in range(n). :param n: int - The number of elements in the nums array. :param start: int - The start value from which the nums array is generated. :return: int - The result of XOR operation on all elements in nums. xor_result = 0 for i in range(n): num = start + 2 * i xor_result ^= num return xor_result"},{"question":"Given an array of integers `nums`, design an algorithm that returns the length of the longest increasing subsequence. A subsequence is a sequence derived from the array by deleting some or no elements without changing the order of the remaining elements. Implement the `lengthOfLIS` function to meet this requirement.","solution":"def lengthOfLIS(nums): Returns the length of the longest increasing subsequence in the given list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a string `s` containing **only lowercase English letters**, you need to rearrange the characters in the string such that each adjacent pair of characters are different. If it is not possible to rearrange the string in such a way, return _an empty string_. If there are multiple valid rearrangements, return any one of them. **Note**: The length of the string `s` will be at most `500`.","solution":"from collections import Counter import heapq def reorganizeString(s): Rearranges the characters in the string s such that each adjacent pair of characters are different. If it is not possible to rearrange the string in such a way, returns an empty string. char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) if -max_heap[0][0] > (len(s) + 1) // 2: return \\"\\" result = [] prev_count, prev_char = 0, \'\' while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return \\"\\".join(result)"},{"question":"Given `n` pairs of numbers representing `intervals`, where each pair `[start, end]` indicates a time interval starting from `start` and ending at `end` (both inclusive). Your task is to return the minimum number of intervals you need to remove so that the rest of the intervals are non-overlapping. An interval `[a,b]` is considered overlapping with an interval `[c,d]` if they share at least one point, i.e., `a <= d` and `c <= b`. If there is no such interval to remove, return `0`.","solution":"def erase_overlap_intervals(intervals): Given a list of intervals, returns the minimum number of intervals to remove so that the remaining intervals are non-overlapping. Parameters: intervals (List[List[int]]): A list of intervals represented as [start, end] Returns: int: Minimum number of intervals to remove if not intervals: return 0 # Sort intervals based on their ending values intervals.sort(key=lambda x: x[1]) end = intervals[0][1] count = 0 for i in range(1, len(intervals)): if intervals[i][0] < end: count += 1 else: end = intervals[i][1] return count"},{"question":"Given a string `s` and an array of integers representing indices of the original string, return the smallest lexicographical string that can be obtained by removing characters at the given indices and shifting the remaining characters to the left. If no indices are provided, return the original string.","solution":"def smallest_lexicographical_string(s, indices): Returns the smallest lexicographical string after removing the characters at the specified indices and shifting the remaining characters to the left. Parameters: s (str): The original string. indices (list[int]): The list of indices to remove from the string. Returns: str: The smallest lexicographical string. indices_set = set(indices) result = [s[i] for i in range(len(s)) if i not in indices_set] return \'\'.join(result)"},{"question":"You are given a binary tree where each node has a value `0` or `1`. Each path from the root to a leaf node forms a binary number. Find the sum of all the binary numbers represented by the root-to-leaf paths in the tree. The answer may be large, so return it modulo `10^9 + 7`. You are to implement the function `sum_root_to_leaf` that receives the root of the tree and returns the sum of all the binary numbers formed by the paths from the root to the leaf.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_root_to_leaf(root): MOD = 10**9 + 7 def dfs(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val if not node.left and not node.right: return current_number return (dfs(node.left, current_number) + dfs(node.right, current_number)) % MOD return dfs(root, 0)"},{"question":"You are given an array of integers `arr` and an integer `target`. Determine if there exist four distinct elements in `arr` such that their sum is equal to `target`. Return `true` if such a combination exists, otherwise return `false`.","solution":"def four_sum_exists(arr, target): Determine if there exist four distinct elements in `arr` such that their sum is equal to `target`. n = len(arr) if n < 4: return False arr.sort() for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given an integer array `arr` and an integer `k`, return _the maximum sum of any non-empty subarray of `arr` that can be obtained by performing at most `k` circular shifts_. A circular shift moves the element from the end of the array to the start. For example, a circular shift on `[1, 2, 3, 4]` results in `[4, 1, 2, 3]`. A **subarray** is a contiguous part of the array.","solution":"def max_circular_subarray_sum(arr, k): def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(arr) if n == 0: return 0 overall_max = max_subarray_sum(arr) for shift in range(1, min(k, n) + 1): shift_arr = arr[-shift:] + arr[:-shift] overall_max = max(overall_max, max_subarray_sum(shift_arr)) return overall_max"},{"question":"A **binary tree** is a tree data structure where each node has at most two children, referred to as the left child and the right child. You are given the root of a binary tree and an integer `targetSum`. Your task is to determine the **number of paths** that **sum** to `targetSum`. The path must start and end at any node in the tree, but it must only move downward (i.e., it must go from parent nodes to child nodes). Return _the **number of paths** that sum to `targetSum` in the binary tree._","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): def dfs(node, current_path): if not node: return 0 current_path.append(node.val) count = 0 path_sum = 0 # Traverse the path in reverse order and check sums for value in reversed(current_path): path_sum += value if path_sum == target_sum: count += 1 # Continue the depth-first search on child nodes count += dfs(node.left, current_path) count += dfs(node.right, current_path) # Backtrack by removing current node\'s value current_path.pop() return count return dfs(root, [])"},{"question":"You are given a list of tasks where each task is represented by a start and end time. Implement a function to find the maximum number of tasks that can be executed without overlapping. Each task\'s start time is inclusive, and the end time is exclusive. If `[start, end)` represents a task, no two tasks can have overlapping intervals. Function signature: ```python def max_tasks(tasks: List[Tuple[int, int]]) -> int: pass ``` **Example**: ``` Input: tasks = [(1, 3), (2, 5), (4, 6), (1, 2)] Output: 2 Explanation: The tasks (1, 2) and (4, 6) can be executed without overlapping.","solution":"from typing import List, Tuple def max_tasks(tasks: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping tasks. Parameters: tasks (List[Tuple[int, int]]): List of tasks represented by (start, end) Returns: int: Maximum number of non-overlapping tasks # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a row. A building with height `heights[i]` can see another building at height `heights[j]` if there are no taller buildings between them. Return _the total number of buildings that can see at least one other building._ Example: Input: `heights = [4, 2, 3, 1, 5]` Output: `9` Explanation: - Building with height 4 can see buildings with heights 2, 3, and 5. - Building with height 2 can see buildings with heights 4, 3, and 5. - Building with height 3 can see buildings with heights 4, 5. - Building with height 1 can see buildings with heights 4, 2, 3, and 5. - Building with height 5 can see buildings with heights 4, 2, 3, and 1. Thus, every building can see at least one other building.","solution":"def count_visible_buildings(heights): n = len(heights) visible_count = [0] * n for i in range(n): # Check left direction max_height_left = 0 for j in range(i-1, -1, -1): if heights[j] > max_height_left: max_height_left = heights[j] visible_count[i] += 1 visible_count[j] += 1 # Check right direction max_height_right = 0 for j in range(i+1, n): if heights[j] > max_height_right: max_height_right = heights[j] visible_count[i] += 1 visible_count[j] += 1 total_visible_buildings = 0 for count in visible_count: if count > 0: total_visible_buildings += 1 return total_visible_buildings"},{"question":"You are given a **2D** array `forest`, where `forest[i][j]` represents the height of a tree at the cell `(i, j)`. Your goal is to cut off all the trees in such a way that you cut them in non-decreasing order of their height. You can start at any tree and can use a **Breadth-First Search (BFS)** to move from one tree to another. You can move up, down, left, or right, and you can only traverse cells with heights less than or equal to the height of the tree being cut down. Return the minimum number of steps required to cut all the trees in the forest. If it is impossible to cut off all the trees, return `-1`.","solution":"from collections import deque def min_steps_forest_cutting(forest): def bfs(start, target): Helper function to perform Breadth-First Search queue, visited = deque([(start[0], start[1], 0)]), set((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == target: return steps for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and (nx, ny) not in visited and forest[nx][ny] > 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 trees = [(h, i, j) for i, row in enumerate(forest) for j, h in enumerate(row) if h > 1] trees.sort() steps = 0 curr_position = (0, 0) for height, i, j in trees: s = bfs(curr_position, (i, j)) if s == -1: return -1 steps += s curr_position = (i, j) return steps"},{"question":"Given an integer `n`, return the number of distinct strings of length `n` that can be formed using the characters \'a\' and \'b\' such that there are no consecutive \'b\'s in any of the strings. For example, if `n = 3`, the valid strings are `aaa`, `aab`, `aba`, and `baa`. Hence, the answer should be `4`.","solution":"def count_strings(n): Returns the number of distinct strings of length n that can be formed using the characters \'a\' and \'b\' such that there are no consecutive \'b\'s. if n == 0: return 0 if n == 1: return 2 # \\"a\\", \\"b\\" # dp0 represents the count of valid strings of length i ending with \'a\' # dp1 represents the count of valid strings of length i ending with \'b\' dp0, dp1 = 1, 1 for i in range(2, n + 1): new_dp0 = dp0 + dp1 new_dp1 = dp0 dp0, dp1 = new_dp0, new_dp1 return dp0 + dp1"},{"question":"You are given a list of strings `words`. A string `s` is called a **valid password candidate** if it meets the following criteria: - `s` contains at least one digit. - `s` contains both uppercase and lowercase letters. - `s` contains at least one special character from the set `[\'@\', \'#\', \'\', \'%\', \'&\', \'*\', \'!\']`. Return _the list of strings that are valid password candidates from the given input list `words`_, preserving the original order.","solution":"def is_valid_password_candidate(s): Checks if the given string s is a valid password candidate. contains_digit = any(c.isdigit() for c in s) contains_uppercase = any(c.isupper() for c in s) contains_lowercase = any(c.islower() for c in s) contains_special = any(c in [\'@\', \'#\', \'\', \'%\', \'&\', \'*\', \'!\'] for c in s) return contains_digit and contains_uppercase and contains_lowercase and contains_special def valid_password_candidates(words): Returns the list of valid password candidates from the given list of words. return [word for word in words if is_valid_password_candidate(word)]"},{"question":"Given a string `s` which represents a valid parentheses sequence, where \'(\' represents an opening parenthesis and \')\' represents a closing parenthesis. The depth of the parenthesis sequence is defined as the maximum breadth (i.e., nested level) that is reached by the sequence. For example, the depth of the sequence `(())()` is `2`, whereas the depth of `((()))` is `3`. Write a function that returns the depth of a given valid parentheses sequence.","solution":"def max_depth(s: str) -> int: Returns the maximum depth of nested parentheses sequence in the given string s. current_depth = max_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"Given an array of integers `arr`, find the length of the longest contiguous subarray such that every element in the subarray is unique. The array may contain both positive and negative integers. The algorithm should run in linear time and use constant extra space.","solution":"def length_of_longest_subarray(arr): Returns the length of the longest contiguous subarray with all unique elements. n = len(arr) max_len = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen and seen[arr[end]] >= start: start = seen[arr[end]] + 1 seen[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a rectangular grid of size `m x n` consisting of only the characters `\'0\'` and `\'1\'`. A connected component in the grid is a group of adjacent cells that have the same value and you can move between them horizontally or vertically. Two cells are adjacent if they are next to each other horizontally or vertically. Return the number of connected components consisting exclusively of the character `\'1\'`. For example, consider the grid: ``` 1 1 0 1 0 0 0 0 1 ``` The grid contains two connected components consisting exclusively of \'1\'. One component includes the cells (0, 0), (0, 1), and (1, 0). The other component includes the cell (2, 2).","solution":"def num_connected_components(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() if (x, y) in visited: continue visited.add((x, y)) # add neighbors to stack for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == \'1\' and (nx, ny) not in visited: stack.append((nx, ny)) component_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and (r, c) not in visited: dfs(r, c) component_count += 1 return component_count"},{"question":"You are given a `rows x cols` binary matrix `grid` which represents a map of \'1\'s (land) and \'0\'s (water). An **island** is a group of `1\'s` (land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Each cell in the grid is marked as either land (\'1\') or water (\'0\'). A cell is considered connected if it shares an edge with another \'1\' (land) cell. The **perimeter** of an island is the total number of cells around it that are either water or the edge of the grid. Write a function that returns _the perimeter of the island_. For example, consider the following `grid`: ```plaintext grid = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] ``` In this example, the perimeter of the island is 16.","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Each land cell contributes 4 to the perimeter initially perimeter += 4 # Check the cell above (if there\'s land above, subtract 2 from perimeter) if r > 0 and grid[r - 1][c] == 1: perimeter -= 2 # Check the cell to the left (if there\'s land to the left, subtract 2 from perimeter) if c > 0 and grid[r][c - 1] == 1: perimeter -= 2 return perimeter"},{"question":"Write a function to find the longest substring of a given string where all the characters are unique. The function should return the length of this longest substring and the substring itself. Implement the function `findLongestUniqueSubstring(s: str) -> Tuple[int, str]` where: * `s` is a string consisting of lowercase and/or uppercase characters. * The function returns a tuple containing two elements: the length of the longest unique substring, and the substring itself. Ensure your solution has efficient time complexity.","solution":"from typing import Tuple def findLongestUniqueSubstring(s: str) -> Tuple[int, str]: Returns the length of the longest substring with all unique characters and the substring itself. n = len(s) longest_len = 0 longest_substr = \\"\\" start = 0 char_index = {} for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end current_length = end - start + 1 if current_length > longest_len: longest_len = current_length longest_substr = s[start:end+1] return longest_len, longest_substr"},{"question":"You are given two integers, `m` and `n`, representing the number of rows and columns of a 2D matrix `grid`, and an integer `k`. You need to find the maximum sum of a submatrix within `grid` that contains at most `k` elements. Write a function that returns this maximum sum. Note that the values in the grid can be positive, negative, or zero.","solution":"def max_sum_submatrix(grid, k): import itertools import bisect def max_sum_no_larger_than_k(nums, k): max_sum, current_sum = float(\'-inf\'), 0 prefix_sum = [0] for num in nums: current_sum += num idx = bisect.bisect_left(prefix_sum, current_sum - k) if idx < len(prefix_sum): max_sum = max(max_sum, current_sum - prefix_sum[idx]) bisect.insort(prefix_sum, current_sum) return max_sum if not grid or not grid[0]: return 0 row, col = len(grid), len(grid[0]) max_sum = float(\'-inf\') for left in range(col): row_sum = [0] * row for right in range(left, col): for r in range(row): row_sum[r] += grid[r][right] max_sum = max(max_sum, max_sum_no_larger_than_k(row_sum, k)) return max_sum"},{"question":"[Question]: You are given an integer array `nums` which contains even and odd numbers. You need to rearrange the array such that all even numbers come before all odd numbers while preserving the original relative order of the even and the odd numbers. Write a function: ```python def rearrangeEvenOdd(nums): # your code here ``` _Example:_ ```python nums = [1, 2, 3, 4, 5, 6] rearrangeEvenOdd(nums) # Expected output: [2, 4, 6, 1, 3, 5] ``` Function signature: ```python def rearrangeEvenOdd(nums: List[int]) -> List[int]: ```","solution":"from typing import List def rearrangeEvenOdd(nums: List[int]) -> List[int]: evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"You are given an array of integers, `nums`, and an integer `target`. Your task is to determine if there exist two elements in `nums` such that their sum is equal to `target`. Return `true` if such a pair exists, otherwise return `false`. You may assume that each input would have exactly one solution, and you may not use the same element twice. # Example **Input:** `nums = [2, 7, 11, 15]`, `target = 9` **Output:** `true` **Explanation:** `2 + 7 = 9`","solution":"def two_sum(nums, target): Determines if there exist two elements in \'nums\' such that their sum is equal to \'target\'. Parameters: nums (list): List of integers. target (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. num_set = set() for num in nums: complement = target - num if complement in num_set: return True num_set.add(num) return False"},{"question":"You are given an array of `n` positive integers representing the calories in various food items. You need to distribute these food items to your friends in such a way that each friend gets at least one food item. Moreover, no friend should receive more total calories than another friend who has already been given food items. Return the total number of ways to distribute the food items that satisfy this condition.","solution":"import math def count_ways(n): Returns the total number of ways to distribute n food items to friends such that each friend gets at least one food item and no friend receives more calories than a friend who has already been given food items. This is equivalent to finding the n-th Catalan number. # Catalan number formula: C(n) = (1 / (n + 1)) * (2n choose n) # C(n) = (2n)! / ((n + 1)! * n!) return math.comb(2 * n, n) // (n + 1)"},{"question":"Write a function to find the minimum number of steps required to convert a given string `s` into another string `t` using the following operations: 1. Insert a character 2. Delete a character 3. Replace a character Both strings `s` and `t` consist of lowercase English letters. The function should take two strings `s` and `t` as input and return the minimum number of steps required to transform `s` into `t`.","solution":"def min_steps(s, t): Returns the minimum number of steps required to convert string s into string t. The operations allowed are insert, delete, and replace a character. m, n = len(s), len(t) # Create a DP table to store the minimum number of steps. dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base cases. for i in range(m + 1): dp[i][0] = i # Deleting all characters from s to match an empty t for j in range(n + 1): dp[0][j] = j # Inserting all characters into an empty s to match t # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no additional step needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"Given an integer `num`, return the list of all its unique prime factors sorted in ascending order. A prime factor is a factor of a number that is a prime number itself. For example, given `num = 60`, the unique prime factors are `[2, 3, 5]`. Note: The input `num` is guaranteed to be a positive integer greater than 1.","solution":"def prime_factors(num): Returns the list of all unique prime factors of the given number sorted in ascending order. factors = [] divisor = 2 while num > 1: if num % divisor == 0: if divisor not in factors: factors.append(divisor) num //= divisor else: divisor += 1 return factors"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of only \'0\'s (empty cells) and \'1\'s (wall cells). A ball is dropped into one of the empty cells, and it rolls through all possible paths following a specific set of rules: - The ball can travel up, down, left, or right. - The ball stops when it hits a wall (\'1\') or the edge of the grid. - The ball cannot pass through walls. Return the number of distinct cells the ball can reach. Note: - The ball can start from any empty cell. - The ball must follow the rules for each move until it can\'t move any further.","solution":"def num_cells_ball_can_reach(grid, start): Returns the number of distinct cells a ball can reach starting from a specific cell in a grid. :param grid: List of List of str, the grid of cells represented by \'0\' (empty) and \'1\' (wall) :param start: Tuple of (int, int), starting (row, col) position of the ball :return: int, the number of distinct cells the ball can reach def valid_cell(x, y, m, n): return 0 <= x < m and 0 <= y < n and grid[x][y] == \'0\' def dfs(x, y, visited): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy while valid_cell(nx, ny, m, n): nx += dx ny += dy nx -= dx ny -= dy if (nx, ny) not in visited: visited.add((nx, ny)) dfs(nx, ny, visited) visited = set() m, n = len(grid), len(grid[0]) visited.add(start) dfs(start[0], start[1], visited) return len(visited)"},{"question":"You are given a string `s` consisting of `n` lowercase English letters. You are also given an integer `m`. Your task is to select a substring from `s` such that the substring has exactly `m` distinct characters. Among all possible substrings satisfying the condition, return the length of the shortest one. If there is no such substring, return `-1`.","solution":"def shortest_substring_with_m_distinct_chars(s, m): Returns the length of the shortest substring of \'s\' that contains exactly \'m\' distinct characters. If no such substring exists, return -1. from collections import defaultdict n = len(s) if m > n: return -1 left = 0 right = 0 char_count = defaultdict(int) distinct_count = 0 min_len = float(\'inf\') while right < n: char_count[s[right]] += 1 if char_count[s[right]] == 1: distinct_count += 1 while distinct_count >= m: if distinct_count == m: min_len = min(min_len, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 right += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given two sorted arrays `arr1` and `arr2` of lengths `m` and `n` respectively. Your task is to find the `k`-th smallest element in the combined sorted array of `arr1` and `arr2`. Implement a function that efficiently finds this element without merging the arrays.","solution":"def find_kth_element(arr1, arr2, k): Finds the k-th smallest element in the combined sorted array of arr1 and arr2. Args: arr1 (list): First sorted array arr2 (list): Second sorted array k (int): The 1-based index of the smallest element to find Returns: int: The k-th smallest element def kth_smallest_helper(arr1, start1, arr2, start2, k): if start1 >= len(arr1): return arr2[start2 + k - 1] if start2 >= len(arr2): return arr1[start1 + k - 1] if k == 1: return min(arr1[start1], arr2[start2]) mid1 = start1 + k // 2 - 1 mid2 = start2 + k // 2 - 1 mid1_val = arr1[mid1] if mid1 < len(arr1) else float(\'inf\') mid2_val = arr2[mid2] if mid2 < len(arr2) else float(\'inf\') if mid1_val < mid2_val: return kth_smallest_helper(arr1, mid1 + 1, arr2, start2, k - k // 2) else: return kth_smallest_helper(arr1, start1, arr2, mid2 + 1, k - k // 2) return kth_smallest_helper(arr1, 0, arr2, 0, k)"},{"question":"Given a list of `n` strings, you need to determine if there is a way to concatenate all the strings in such an order that the resulting string is a palindrome. Return `true` if such a concatenation exists, otherwise return `false`. Note that the order of strings can be rearranged to achieve the result.","solution":"from collections import Counter def can_form_palindrome(strings): Determines if there is a way to concatenate all the strings in such an order that the resulting string is a palindrome. Parameters: strings (List[str]): List of strings to be concatenated. Returns: bool: True if a palindromic concatenation exists, False otherwise. # Count all character frequencies char_count = Counter() for s in strings: char_count.update(s) # Count how many characters have an odd count odd_count = sum(count % 2 for count in char_count.values()) # A palindrome can have at most one character with an odd frequency return odd_count <= 1"},{"question":"You are given a list of `logs` where each log is a string with an identifier followed by a space and a string or a number. Each log is categorized as a letter-log if the content after the identifier consists of words composed of letters, and as a digit-log if the content consists only of digits. Return the logs sorted in the following order: Letter-logs come before digit-logs, letter-logs are sorted lexicographically by content (if contents are equal, then by identifier), and digit-logs remain in their original order.","solution":"def reorder_log_files(logs): Reorders logs such that: 1. Letter-logs come before digit-logs. 2. Letter-logs are ordered lexicographically by content, and in case of ties, by identifier. 3. Digit-logs maintain their relative ordering. letter_logs = [] digit_logs = [] for log in logs: identifier, rest = log.split(\' \', 1) if rest[0].isdigit(): digit_logs.append(log) else: letter_logs.append((rest, identifier)) # Sort letter logs by content, then by identifier letter_logs.sort(key=lambda x: (x[0], x[1])) # Combine the sorted letter logs and original order digit logs sorted_logs = [f\\"{identifier} {content}\\" for content, identifier in letter_logs] + digit_logs return sorted_logs"},{"question":"A factory produces widgets, and each widget is produced using `materials` represented by an array `costs`, where `costs[i]` is the cost of the `i-th` material. The factory also has multiple discount offers, each represented by an array `discounts` where `discounts[j] = [k, d]` provides a discount `d`, applied only if at least `k` materials are used. The discount is applied to the total cost of the materials used. If multiple discounts apply, the one offering the highest overall discount should be used. Given the array `costs` and the array `discounts`, return the minimum cost required to produce a single widget using all the materials and applying the best possible discount. Example: ``` costs = [10, 20, 30] discounts = [[2, 5], [3, 10]] ``` Output: 45 Explanation: - Using three materials without discount: 10 + 20 + 30 = 60. - Available discounts: 5 (for using at least 2 materials), 10 (for using 3 materials). - Apply 10 discount: 60 - 10 = 50. Hence the minimum cost is 50.","solution":"def min_cost_with_discounts(costs, discounts): Calculate the minimum cost after applying the best possible discount. Arguments: costs -- List of integers representing the cost of each material. discounts -- List of lists, where each list contains two integers [k, d] representing a discount \'d\' applicable if at least \'k\' materials are used. Returns: Integer representing the minimum cost after applying the best discount. total_cost = sum(costs) max_discount = 0 for k, d in discounts: if len(costs) >= k: max_discount = max(max_discount, d) return total_cost - max_discount"},{"question":"Given a binary matrix where 0 represents water and 1 represents land, find the largest square submatrix which contains only 1s and return its area.","solution":"def find_largest_square(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given a list of strings `words` and an integer `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified. Return _a list of strings where each string represents a formatted line of text_. The words should be distributed as evenly as possible, with extra spaces inserted between words to ensure fill justification. If a line has only one word or it is the last line, the word should be left-justified with no extra space inserted between words.","solution":"def full_justify(words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) > maxWidth: for i in range(maxWidth - num_of_letters): cur[i % (len(cur) - 1 or 1)] += \' \' res.append(\'\'.join(cur)) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) return res + [\' \'.join(cur).ljust(maxWidth)]"},{"question":"We define a harmonious sequence as an array where the difference between the maximum value and the minimum value is exactly 1. Given an array of integers, determine the length of the longest harmonious subsequence of the array. A subsequence of an array is a sequence derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Return _an integer_ representing the length of the longest harmonious subsequence in the input array.","solution":"from collections import Counter def findLHS(nums): Finds the length of the longest harmonious subsequence in the array. Args: nums (List[int]): The input array of integers. Returns: int: The length of the longest harmonious subsequence. if not nums: return 0 num_counts = Counter(nums) max_length = 0 for num in num_counts: if num + 1 in num_counts: max_length = max(max_length, num_counts[num] + num_counts[num + 1]) return max_length"},{"question":"You are given a string `s` representing a sequence of lowercase English letters. You can perform the following operation any number of times: take any two adjacent characters in `s` that are in lexicographical order and remove the first character. Return the lexicographically smallest string possible after applying the operation any number of times.","solution":"def lexicographically_smallest_string(s): Given a string `s` representing a sequence of lowercase English letters, return the lexicographically smallest string possible after applying the given operation any number of times. stack = [] for char in s: while stack and stack[-1] > char: stack.pop() stack.append(char) return \'\'.join(stack)"},{"question":"You are given an array of integers `arr` containing `n` elements, and a positive integer `m` less than or equal to `n`. Your task is to split the array into exactly `m` non-empty continuous subarrays so as to minimize the maximum sum among these `m` subarrays. Return _the minimum possible value of the maximum sum_.","solution":"def minimize_max_sum(arr, m): def can_split(nums, m, max_sum): current_sum = 0 pieces = 1 for num in nums: if current_sum + num > max_sum: pieces += 1 current_sum = num if pieces > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(arr, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two integers `n` and `k`, representing the total number of elements and the size of the combinations, respectively. Implement a function that returns all possible combinations of `k` numbers out of the range `[1, n]`. You can return the combinations in any order.","solution":"from itertools import combinations def combine(n, k): Returns all possible combinations of k numbers out of the range [1, n]. Parameters: n (int): Total number of elements. k (int): Size of each combination. Returns: List[List[int]]: List of all combinations. return list(combinations(range(1, n + 1), k))"},{"question":"You are given a string `text` representing a document consisting of words separated by single spaces. A word is defined as a sequence of non-space characters. Write a function to return _the length of the longest word in the document_. If there are multiple words with the same maximum length, return the length of the word that occurs first in the document. Note that the document does not contain any leading or trailing spaces and each word consists of only uppercase and lowercase English letters.","solution":"def longest_word_length(text): Returns the length of the longest word in the given text. If multiple words have the same length, returns the length of the first such word. Parameters: text (str): A string representing a document with words separated by single spaces. Returns: int: The length of the longest word. words = text.split() max_length = 0 for word in words: if len(word) > max_length: max_length = len(word) return max_length"},{"question":"You are given an array of integers `heights` where `heights[i]` represents the height of a person standing in queue. The queue is rearranged so that each person stands before the next person that is taller than them (if there is one). Given a new order of the queue, return an array of indices representing the original positions of the people in the new queue order. For simplicity, assume all heights are unique.","solution":"def original_positions(heights): Returns an array of indices representing the original positions of the people in the new queue order where each person stands before the next person that is taller than them. Parameters: heights (list of int): List of unique heights of individuals in the queue. Returns: list of int: List of indices representing original positions in the new queue order. # Pair each height with its original index indexed_heights = [(h, i) for i, h in enumerate(heights)] # Sort the heights (ascending) indexed_heights.sort() # Extract the indices from the sorted list positions = [idx for h, idx in indexed_heights] return positions"},{"question":"Given a square matrix `matrix`, rotate the matrix 90 degrees clockwise in place. Return the rotated matrix. The rotation should be performed with a constant amount of extra space. For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The rotated matrix would be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Ensure the matrix dimensions remain the same, and that you handle both even and odd-sized matrices correctly.","solution":"def rotate_matrix(matrix): Rotate the given N x N matrix 90 degrees clockwise. :param matrix: List[List[int]], a 2D list representing the matrix. :return: The rotated matrix, which is modified in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given an integer array `heights` representing the heights of students in a class. The students are standing in a line in the order of their heights. A supersorted line is such that each student except the first one has a height that is exactly one greater than the height of the student directly before them. Find the minimum number of students you\'d need to remove from `heights` to make the remaining students form a supersorted line. Return _the minimum number of removals needed_.","solution":"def min_removals_for_supersorted_line(heights): Returns the minimum number of removals needed to make the remaining students form a supersorted line. if not heights: return 0 dp = [1] * len(heights) for i in range(1, len(heights)): for j in range(i): if heights[i] == heights[j] + 1: dp[i] = max(dp[i], dp[j] + 1) longest_supersorted_length = max(dp) return len(heights) - longest_supersorted_length"},{"question":"You are given a list of non-negative integers `nums` and an integer `pivot`. Your task is to partition the list into three sections such that all elements less than `pivot` come before all elements equal to `pivot`, and all elements greater than `pivot` come after all elements equal to `pivot`. Return the list after partitioning. The relative order of elements less than `pivot` and greater than `pivot` should be maintained as in the original list.","solution":"def partition_list(nums, pivot): Partitions the list `nums` such that all elements less than `pivot` come before all elements equal to `pivot`, and all elements greater than `pivot` come after all elements equal to `pivot`. The relative order of elements less than `pivot` and greater than `pivot` are maintained as in the original list. Args: nums: List of non-negative integers. pivot: The pivot integer to partition the list around. Returns: A list after partitioning. less_than_pivot = [] equal_to_pivot = [] greater_than_pivot = [] for num in nums: if num < pivot: less_than_pivot.append(num) elif num == pivot: equal_to_pivot.append(num) else: greater_than_pivot.append(num) return less_than_pivot + equal_to_pivot + greater_than_pivot"},{"question":"You are given a string `instructions` consisting of characters \'G\', \'L\' and \'R\'. \'G\' means go straight, \'L\' means turn left, and \'R\' means turn right. An instruction sequence leads to a circle if after executing the sequence, the robot returns to the initial position and orientation. Determine if the instruction sequence is a circular route. Return _`true` if the instruction sequence forms a circle, and `false` otherwise_.","solution":"def is_circular_route(instructions): direction = 0 # 0: North, 1: East, 2: South, 3: West x, y = 0, 0 # starting position for char in instructions: if char == \'G\': if direction == 0: # North y += 1 elif direction == 1: # East x += 1 elif direction == 2: # South y -= 1 elif direction == 3: # West x -= 1 elif char == \'L\': direction = (direction - 1) % 4 elif char == \'R\': direction = (direction + 1) % 4 return (x, y) == (0, 0) and direction == 0"},{"question":"You are given a **0-indexed** array `nums` consisting of positive integers. Your task is to determine the **length** of the longest possible subarray such that the **bitwise AND** of the subarray elements is strictly greater than `0`. The **bitwise AND** of an array is the bitwise AND of all the numbers in it. Return _the length of the longest subarray with a bitwise AND greater than_ `0`. If no such subarray exists, return `0`.","solution":"def longest_subarray(nums): Returns the length of the longest subarray with bitwise AND > 0. max_length = 0 current_length = 0 for num in nums: if num > 0: current_length += 1 else: current_length = 0 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a list of integers `heights` representing the height of buildings along a street from left to right. Your task is to calculate the **total volume of water** that could get trapped between these buildings after a rainstorm. Water is trapped where there are gaps between the buildings that can collect water. The width of each building is `1` unit. Return _the total amount of water trapped_.","solution":"def trap_rain_water(heights): Calculate the total volume of water that can be trapped between the buildings. :param heights: List[int] - List representing the height of the buildings. :return: int - Total volume of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"An alien language uses lowercase English letters, but possibly in a different order. The order of the letters is determined by an `order` string of length 26, where each character is a unique letter of the English alphabet. You are given an array of words `words` where each word follows the alien language\'s dictionary order. Determine if the words in the array are sorted lexicographically according to the alien language. Return `true` if they are sorted and `false` otherwise.","solution":"def is_alien_sorted(words, order): Returns True if words are sorted lexicographically according to the alien language order, otherwise False. order_index = {char: i for i, char in enumerate(order)} def is_sorted(word1, word2): min_length = min(len(word1), len(word2)) for i in range(min_length): if word1[i] != word2[i]: return order_index[word1[i]] < order_index[word2[i]] return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_sorted(words[i], words[i + 1]): return False return True"},{"question":"Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same, and the extra space complexity should be constant. Return the number of unique elements in `nums` and modify `nums` in-place to contain these unique elements as the first part of the array. You do not need to consider elements beyond the new length.","solution":"def remove_duplicates(nums): Removes duplicates in-place from a sorted array `nums` such that each unique element appears only once. Returns the number of unique elements. Args: nums (List[int]): List of sorted integers where duplicates to be removed in-place. Returns: int: The count of unique elements. if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] # The new length of the array will be the index of the last unique element + 1 return unique_index + 1"},{"question":"Given a list of `start` and `end` times for `n` meetings represented as two arrays `startTimes` and `endTimes`, determine if a single person can attend all given meetings without any overlap. Each meeting\'s start time will be less than its corresponding end time. Return `true` if it is possible for one person to attend all meetings, otherwise return `false`.","solution":"def can_attend_all_meetings(startTimes, endTimes): Determines if a single person can attend all meetings without any overlap. :param startTimes: List of start times of meetings. :param endTimes: List of end times of meetings. :return: True if a person can attend all meetings without overlap, False otherwise. meetings = sorted(zip(startTimes, endTimes), key=lambda x: x[0]) for i in range(1, len(meetings)): if meetings[i][0] < meetings[i-1][1]: return False return True"},{"question":"You are given an \\"infinite\\" 2D grid of cells, each initially set to 0. You are also given a list of operations, where each operation is one of the following: 1. **Increment**: This operation increases the value of all cells in a subgrid by 1. A subgrid is defined by its top-left and bottom-right corners, represented as `(r1, c1, r2, c2)`, where `r1` and `c1` are the row and column indices of the top-left corner, and `r2` and `c2` are the row and column indices of the bottom-right corner. 2. **Query**: This operation returns the current value of a specific cell `(r, c)`. For an input list of operations, return the results of all the query operations in the order they appear in the input. Operations are given as a list of tuples, where the first element of each tuple is a string that either says \\"Increment\\" or \\"Query\\", followed by the parameters for that operation. Assume the initial state of the grid allows for both positive and negative indices. Example Input: ``` [ (\\"Increment\\", 0, 0, 2, 2), (\\"Query\\", 1, 1), (\\"Increment\\", -1, -1, 0, 0), (\\"Query\\", 0, 0), (\\"Query\\", -1, -1) ] ``` Example Output: ``` [1, 2, 1] ```","solution":"def grid_operations(operations): grid = {} def increment(r1, c1, r2, c2): for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): if (r, c) not in grid: grid[(r, c)] = 0 grid[(r, c)] += 1 def query(r, c): return grid.get((r, c), 0) results = [] for op in operations: if op[0] == \\"Increment\\": _, r1, c1, r2, c2 = op increment(r1, c1, r2, c2) elif op[0] == \\"Query\\": _, r, c = op results.append(query(r, c)) return results"},{"question":"You are given a positive integer `n`, which represents the number of nodes in a **binary** tree. Each node in the binary tree has a value `val` associated with it, which is a unique integer from `1` to `n`. You need to construct all possible unique BSTs (Binary Search Trees) that store values `1` to `n` and return their root nodes. A BST is a binary tree in which for each node, all nodes in its left subtree have values less than its value, and all nodes in its right subtree have values greater than its value. Return all possible unique BSTs.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def generateTrees(n): if n == 0: return [] def generate(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate(start, i - 1) right_trees = generate(i + 1, end) for l in left_trees: for r in right_trees: curr_tree = TreeNode(i) curr_tree.left = l curr_tree.right = r all_trees.append(curr_tree) return all_trees return generate(1, n)"},{"question":"Given an n-ary tree, where each node can have up to `N` children, flatten the tree into a linked list in place. Each node should point to its next node using the `right` pointer while the `left` pointer of all nodes should be null. The resulting linked list should contain the nodes in the same order as a pre-order traversal of the original n-ary tree.","solution":"class Node: Definition for a Node. def __init__(self, val=0, children=None): self.val = val self.left = None self.right = None self.children = children if children is not None else [] def flatten_nary_tree(root): Flattens an n-ary tree to a linked list in-place. The tree is traversed in pre-order and nodes are linked using the `right` pointers. if not root: return None stack = [root] prev = None while stack: current = stack.pop() if prev: prev.right = current prev = current # We need to push children in reverse order for pre-order traversal if current.children: for child in reversed(current.children): stack.append(child) current.left = None # Ensure the left pointer is null return root"},{"question":"Given an array of integers `heights` representing the height of each tree in a row, you are asked to trim the trees such that the resulting array, when sorted by the heights, forms a sequence of increasing numbers with a difference of exactly 1 between consecutive heights. You can only decrease the height of a tree, and the final heights must be non-negative. Determine the minimum number of trees you need to cut down to achieve this sequence. Return the _minimum number of trees to cut down or trim_.","solution":"def min_trees_to_cut(heights): Determines the minimum number of trees to cut down or trim to achieve a sequence with a difference of exactly 1. :param heights: list of integers representing the heights of the trees. :return: minimum number of trees to cut down or trim. heights.sort() n = len(heights) # To store the maximum possible length of height sequence that meets the condition. max_length_sequence = 1 current_length_sequence = 1 # List to track the longest sequence ending at each height. dp = [0] * n for i in range(n): dp[i] = 1 for j in range(i): if heights[i] == heights[j] + 1: dp[i] = max(dp[i], dp[j] + 1) max_length_sequence = max(max_length_sequence, dp[i]) return n - max_length_sequence"},{"question":"You are given an array `arr` of integers, where the length of the array is `n` and all the integers are non-negative. You are also given an integer `k`. You can perform the following operation at most `k` times: choose any two indices `i` and `j` such that `0 <= i, j < n` and `i != j`, then swap the elements at `arr[i]` and `arr[j]`. Your task is to determine the lexicographically smallest possible array that can be obtained after performing the given operation at most `k` times. Return _the lexicographically smallest array_ after performing the operations. The order of the elements in the result should be the same as given in `arr`.","solution":"def lexicographically_smallest_array(arr, k): Returns the lexicographically smallest array after performing at most k swaps of any two distinct elements in the given array arr. n = len(arr) for i in range(n): # If no swaps left, break early if k <= 0: break # Find the smallest element to swap with arr[i] min_index = i for j in range(i + 1, min(n, i + k + 1)): if arr[j] < arr[min_index]: min_index = j # If the current element is already the smallest, continue to next index if min_index == i: continue # Perform the swap arr[i], arr[min_index] = arr[min_index], arr[i] # Decrease the swap count k -= (min_index - i) return arr"},{"question":"A game is played on a 2D grid with `m` rows and `n` columns. Each cell in this grid can either be land, represented by the integer `1`, or water, represented by the integer `0`. You are given several queries, each represented by a tuple `(r, c)`, where `(r, c)` denotes a cell in the grid. For each query, you need to determine the size of the largest land area (connected component of `1`s) that includes the cell `(r, c)`. Two cells are considered connected if they are adjacent in one of the four directions (up, down, left, right). If the cell `(r, c)` is water, the result for that query should be `0`. Return an array of integers where each integer is the answer to the respective query.","solution":"def bfs(grid, r, c, visited): queue = [(r, c)] visited[r][c] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] size = 0 while queue: x, y = queue.pop(0) size += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == 1: queue.append((nx, ny)) visited[nx][ny] = True return size def max_land_area(grid, queries): results = [] for r, c in queries: if grid[r][c] == 0: results.append(0) else: visited = [[False] * len(grid[0]) for _ in range(len(grid))] result = bfs(grid, r, c, visited) results.append(result) return results"},{"question":"Given a string `s` which consists of lowercase alphabets and has a length of `n`, your task is to determine the **smallest window** (substring) in `s` that contains all the unique characters present in `s`. If there are multiple such smallest windows, return the one that appears first. Return _the smallest window in `s` that contains all the unique characters_.","solution":"def smallest_window_containing_all_chars(s): from collections import defaultdict unique_chars = set(s) required_char_count = len(unique_chars) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) min_length = float(\'inf\') min_window = \\"\\" while right < len(s): char = s[right] window_counts[char] += 1 if window_counts[char] == 1: formed += 1 while left <= right and formed == required_char_count: char = s[left] window_length = right - left + 1 if window_length < min_length: min_length = window_length min_window = s[left:right + 1] window_counts[char] -= 1 if window_counts[char] == 0: formed -= 1 left += 1 right += 1 return min_window"},{"question":"You are given a 2D integer grid `grid` of size `m x n`. Each cell in the grid represents a point on the map, with `grid[i][j] = 1` indicating that the point is an obstacle and `grid[i][j] = 0` indicating that the point is open space. A path is a sequence of non-diagonal adjacent cells that connects two different points on the grid. Your task is to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) that avoids all obstacles. If such a path does not exist, return `-1`. Note that you can only move up, down, left, or right on the grid.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from top-left corner to bottom-right corner in a 2D grid avoiding obstacles. :param grid: List[List[int]] grid of obstacles (1) and open spaces (0) :return: The length of the shortest path or -1 if no path exists if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) # If start or end points are obstacles if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if r == m - 1 and c == n - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given a string `tasks` representing a sequence of tasks that must be completed in a specific order. Each task is represented by a different character. You also have an array of strings `dependencies` where each element is a pair `a->b`, indicating that task `a` must be completed before task `b`. Write a function to determine if it is possible to complete all tasks in the order specified by `tasks`, respecting the given dependencies. Return `true` if it is possible to complete all tasks, otherwise return `false`.","solution":"def can_complete_tasks(tasks, dependencies): Determines if it is possible to complete all tasks in the order specified by tasks, respecting the given dependencies. :param tasks: str - A string representing the sequence of tasks. :param dependencies: list of str - A list of strings where each string is in the format \\"a->b\\" indicating that task `a` must be completed before task `b`. :return: bool - True if all tasks can be completed, considering dependencies; otherwise, False. from collections import defaultdict, deque graph = defaultdict(list) in_degree = {task: 0 for task in tasks} for dependency in dependencies: pre, post = dependency.split(\\"->\\") graph[pre].append(post) in_degree[post] += 1 zero_in_degree_queue = deque([task for task in tasks if in_degree[task] == 0]) count_of_tasks_processed = 0 while zero_in_degree_queue: task = zero_in_degree_queue.popleft() count_of_tasks_processed += 1 for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return count_of_tasks_processed == len(tasks)"},{"question":"In a dystopian city, there is a grid of streets organized in a perfect rectangular layout. Each street has blocks represented by a 2D grid of integers, where `grid[i][j]` indicates the time (in minutes) it takes to traverse the block `i, j`. You are a freedom fighter planning the most efficient path to travel from the top-left corner of the grid (0, 0) to the bottom-right corner (n-1, m-1) avoiding patrols as much as possible. Write a function to find the **minimum time** to traverse from the top-left to the bottom-right corner of the grid. You can only move right or down at any point in time. Given the 2D list `grid`, return the minimum traversal time.","solution":"def min_traversal_time(grid): Returns the minimum traversal time from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"Given an array of integers `nums` and an integer `k`, return `true` if there exists a contiguous subarray of size `k` that sums to a value greater than or equal to the average of the entire array, otherwise return `false`. The array is non-empty and `k` is always a positive integer less than or equal to the length of the array.","solution":"def has_subarray_with_sum_gte_average(nums, k): This function checks if there exists a contiguous subarray of size k in nums whose sum is greater than or equal to the average of the entire array nums. :param nums: List of integers :param k: Size of the subarray :return: True if such a subarray exists, False otherwise n = len(nums) total_sum = sum(nums) average = total_sum / n # Calculate initial window sum of the first k elements current_window_sum = sum(nums[0:k]) # Check if the initial window sum is equal or greater than the average if current_window_sum >= average * k: return True # Slide the window across the array and keep updating the window sum. for i in range(k, n): current_window_sum += nums[i] - nums[i - k] if current_window_sum >= average * k: return True return False"},{"question":"Given the head of a doubly linked list, you are required to reverse the list and return the head of the reversed list. A **doubly linked list** is a type of linked list in which each node contains a reference to both the next node and the previous node. The structure of a node is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None, prev=None): self.val = val self.next = next self.prev = prev ``` Your function should return the head of the linked list after reversing it. The input list is guaranteed to have at least one node. Make sure to handle edge cases such as an empty list or a list with a single element. **Follow up:** Can you perform the reversal in linear time, i.e., O(n)?","solution":"class ListNode: def __init__(self, val=0, next=None, prev=None): self.val = val self.next = next self.prev = prev def reverse_doubly_linked_list(head): Reverses a doubly linked list and returns the new head. :param head: ListNode, the head of a doubly linked list :return: ListNode, the new head of the reversed doubly linked list if not head: return None current = head while current: # Swap the next and prev pointers current.next, current.prev = current.prev, current.next # Move to the next node in the original list, which is prev now head = current # Update head to the current node current = current.prev return head"},{"question":"A network of computers is represented as an undirected graph with `n` nodes numbered from `0` to `n - 1` and an array `edges` where `edges[i] = [node1i, node2i, timei]` represents a connection between `node1i` and `node2i` that takes `timei` units of time to traverse. You are also given an integer `start` representing the starting node. Write a function to find the shortest time required for the signal to reach all nodes in the network from the starting node `start`. If it is impossible for the signal to reach all nodes, return `-1`.","solution":"import heapq from collections import defaultdict def networkDelayTime(times, n, start): Returns the shortest time required for the signal to reach all nodes in the network from the starting node \'start\'. If it is impossible for the signal to reach all nodes, return -1. # create a graph from the input times graph = defaultdict(list) for u, v, w in times: graph[u].append((v, w)) # use Dijkstra\'s algorithm to find the shortest path from the start node to all other nodes heap = [(0, start)] shortest_times = {} while heap: time, node = heapq.heappop(heap) if node in shortest_times: continue shortest_times[node] = time for neighbor, weight in graph[node]: if neighbor not in shortest_times: heapq.heappush(heap, (time + weight, neighbor)) # if there are nodes that are not reachable, return -1 if len(shortest_times) != n: return -1 return max(shortest_times.values())"},{"question":"You are given a `m x n` grid containing only integers from `1` to `5`, representing different types of terrain on which you can walk. You need to find the **shortest path** from the top-left corner `(0,0)` to the bottom-right corner `(m-1,n-1)` such that you **only** walk on cells with non-decreasing integer values. You can only move up, down, left, or right at each step. Return the length of the shortest path if it exists, otherwise return `-1`.","solution":"from collections import deque def shortest_path_non_decreasing(grid): m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] >= grid[x][y] and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"Given a `2D` grid of size `m x n` representing a map of \'-\' (land) and \'W\' (water). You are initially on the top-left cell (0, 0). Your initial goal is to reach the bottom-right cell (m-1, n-1). You can move up, down, left, or right. You cannot move into cells marked \'W\'. Return the length of the shortest path to reach the bottom-right cell. If there is no path, return `-1`.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left cell to the bottom-right cell in a grid, where \'-\' represents land and \'W\' represents water. If no path exists, returns -1. if not grid or grid[0][0] == \'W\' or grid[-1][-1] == \'W\': return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (m - 1, n - 1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == \'-\' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given a list of points representing the positions of towers on a 2D plane and an integer `r`. You need to find a point on the plane such that the sum of the distances from this point to all the towers is minimized. If there are multiple points, return any one of them. The distance between two points `(x1, y1)` and `(x2, y2)` is calculated using the Manhattan distance formula: `|x1 - x2| + |y1 - y2|`. Implement the function `findOptimalPoint(towers, r)` where the `towers` list contains tuples of integers representing the coordinates of the towers, and `r` is an integer. The function should return a tuple of integer coordinates representing the optimal point.","solution":"def findOptimalPoint(towers, r): Find a point on the plane such that the sum of the distances from this point to all the towers is minimized. The distance is calculated using the Manhattan distance formula. Arguments: towers: List of tuples, where each tuple is (x, y) coordinates of a tower. r: An integer value, not used in the calculation. Returns: Tuple of integer coordinates representing the optimal point. if not towers: return (0, 0) # To minimize Manhattan distance sum, the optimal x and y coordinates # will be the median of the tower\'s x and y coordinates respectively. x_coords = sorted([t[0] for t in towers]) y_coords = sorted([t[1] for t in towers]) median_x = x_coords[len(x_coords) // 2] median_y = y_coords[len(y_coords) // 2] return (median_x, median_y)"},{"question":"You are given an integer array `nums` and an integer `k`. Find the number of unique k-length subarrays from `nums` that have a sum equal to a target value `target`. A subarray is a contiguous non-empty sequence of elements within an array. Return _the number of k-length subarrays that sum up to_ `target`. Example: ```python Input: nums = [1, 2, 3, 4, 5], k = 3, target = 9 Output: 1 Explanation: There is one subarray of length 3 that sums up to 9: [2, 3, 4]. ``` ```python Input: nums = [1, 1, 1, 1, 1, 1], k = 2, target = 2 Output: 5 Explanation: There are five subarrays of length 2 that sum up to 2: [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]. ```","solution":"def count_k_length_subarrays_with_sum(nums, k, target): Returns the number of unique k-length subarrays that sum up to the target. if not nums or k > len(nums): return 0 count = 0 current_sum = sum(nums[:k]) if current_sum == target: count += 1 for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum == target: count += 1 return count"},{"question":"You are given two integer arrays `startTimes` and `endTimes`, both of length `n`, representing the starting and ending times of `n` intervals. These intervals represent the periods during which different events occur. Write a function that determines the maximum number of events that take place at the same time. Return _the **maximum** number of overlapping intervals at any point in time._","solution":"def max_overlapping_intervals(startTimes, endTimes): Returns the maximum number of overlapping intervals at any point in time. events = [] for start, end in zip(startTimes, endTimes): events.append((start, \'start\')) events.append((end, \'end\')) # Sort events first by time, and then by type of event such that \'end\' comes before \'start\' when times are the same events.sort(key=lambda x: (x[0], x[1] == \'start\')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == \'start\': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"Given a binary tree with `n` nodes, where each node contains a unique value from `1` to `n`. The tree is provided as an adjacency list. You need to determine if there\'s a path in the tree such that the sum of the values of the nodes in this path equals a given target sum `T`. Return the boolean value `true` if such a path exists, and `false` otherwise. * The binary tree is represented as an adjacency list in the form of a dictionary where each key is a node, and its value is a list of its children nodes. Nodes have unique values from `1` to `n`. * The path must be a simple path (no node is visited more than once). * The path must contain at least one node. For example, for a binary tree represented as `{1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []}`, and a target sum `T = 10`, return `true` because there exists a path (1 -> 2 -> 5) which sums up to 10.","solution":"def has_path_sum(adjacency_list, target_sum): def dfs(node, current_sum): if node not in adjacency_list: return False current_sum += node # Check if it\'s a leaf node if not adjacency_list[node]: return current_sum == target_sum # Recursively visit children for child in adjacency_list[node]: if dfs(child, current_sum): return True return False # Starting from the root node \'1\' return dfs(1, 0)"},{"question":"Given an integer array `nums`, move all `0`s to the end of the array while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. ```python def move_zeroes(nums: List[int]) -> None: Do not return anything, modify nums in-place instead. ``` For example: - Input: `nums = [0,1,0,3,12]` - Output: `nums = [1,3,12,0,0]`","solution":"from typing import List def move_zeroes(nums: List[int]) -> None: Moves all zeros to the end of the list while maintaining the relative order of the non-zero elements. Modifies the list in-place. non_zero_position = 0 for i in range(len(nums)): if nums[i] != 0: nums[non_zero_position] = nums[i] if non_zero_position != i: nums[i] = 0 non_zero_position += 1"},{"question":"You are given a rectangular grid of size `m x n` consisting of water and land, where ‘1’ represents land and ‘0’ represents water. An island is formed by connecting adjacent lands horizontally or vertically. Given the grid, return _the number of distinct islands._ Two islands are considered distinct if and only if one island is not identical to another (i.e., they are not reflections or rotations of one another).","solution":"def numDistinctIslands(grid): def dfs(x, y, island, direction): # if out of bounds or at water cell, return if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == \'0\': return # mark the cell as visited grid[x][y] = \'0\' # record the direction island.append(direction) # do DFS in all directions dfs(x + 1, y, island, \'D\') # down dfs(x - 1, y, island, \'U\') # up dfs(x, y + 1, island, \'R\') # right dfs(x, y - 1, island, \'L\') # left # avoid same directions when coming back island.append(\'B\') unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': island = [] dfs(i, j, island, \'O\') # \'O\' for origin unique_islands.add(tuple(island)) return len(unique_islands)"},{"question":"Given a **0-indexed** integer array `nums`, return an array `answer` where `answer[i]` is the sum of every number in `nums` except `nums[i]`. You must write an algorithm that runs in `O(n)` time and uses only `O(1)` extra space (excluding the output array).","solution":"def sum_except_self(nums): Returns an array where each element at index i is the sum of all elements in nums except nums[i]. total_sum = sum(nums) answer = [total_sum - num for num in nums] return answer"},{"question":"Given a grid of size `m x n` where each cell can have one of three values: - `0` representing an empty cell, - `1` representing a wall, and - `2` representing the starting point of a fire, You must determine the minimum time required to reach a target cell in the grid, starting from the fire cells. You should assume that the fire spreads to adjacent cells (up, down, left, right) every minute and cannot pass through walls. If it is impossible to reach the target cell, return `-1`. The target cell is represented by coordinates `(target_x, target_y)`. Your function should take the grid, the target coordinates, and return the minimum time needed to reach the target cell or `-1` if it is impossible.","solution":"from collections import deque def min_time_to_reach_target(grid, target_x, target_y): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) target = (target_x, target_y) if grid[target_x][target_y] == 1: return -1 # Target cell is a wall directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque() visited = set() # Initialize the queue with all fire starting points for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) # (row, col, time) visited.add((i, j)) # BFS to spread the fire while queue: x, y, time = queue.popleft() if (x, y) == target: return time for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, time + 1)) visited.add((nx, ny)) return -1"},{"question":"Given a string `s`, return the length of the longest substring without repeating characters. You need to implement a function that finds the substring in linear time. For instance, if the input string is `\\"abcabcbb\\"`, then the longest substring without repeating characters is `\\"abc\\"`, which has a length of 3. If the input string is `\\"bbbbb\\"`, the longest substring without repeating characters is `\\"b\\"`, with a length of 1. Ensure your function efficiently handles strings of various lengths up to 10^5 characters.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"You are given an integer array `heights` where `heights[i]` represents the height of the `ith` tree in a forest. You want to build an observation tower on top of one of the trees so that you can see the maximum number of other trees in a row without any taller tree blocking the view. From the tree with the tower, you can see another tree if there is no tree taller than both blocking the view in between. Return an integer representing the maximum number of trees that can be viewed from the tower tree, including the tower tree itself.","solution":"def max_trees_visible(heights): Returns the maximum number of trees that can be viewed from the tower tree. heights: The list of integers representing the height of trees. The function considers all possible trees where the observation tower could be built and determines the maximum number of visible trees, including the tower tree. n = len(heights) if n == 0: return 0 max_visible = 0 for i in range(n): left_visible = 0 right_visible = 0 # Counting visible trees to the left tallest_left = heights[i] for j in range(i - 1, -1, -1): if heights[j] > tallest_left: left_visible += 1 tallest_left = heights[j] else: left_visible += 1 # Counting visible trees to the right tallest_right = heights[i] for k in range(i + 1, n): if heights[k] > tallest_right: right_visible += 1 tallest_right = heights[k] else: right_visible += 1 max_visible = max(max_visible, 1 + left_visible + right_visible) return max_visible"},{"question":"You are given a `m x n` grid consisting of `0\'s` and `1\'s`. A move consists of choosing any `1` and flipping it to `0`. Each move cost is equal to the number of `1\'s` adjacent to the cell being flipped (consider 4-directional adjacency). Your goal is to flip all `1\'s` in the grid to `0\'s`. Minimize the total move cost. Return the minimum move cost required to make all cells in the grid `0\'s`.","solution":"def minMoveCost(grid): Given a grid of 0\'s and 1\'s, flip all 1\'s to 0\'s with minimal move cost. Each move cost is equal to the number of 1\'s adjacent to the cell being flipped. :param grid: List[List[int]] - a 2D grid of 0\'s and 1\'s :return: int - the minimum move cost m, n = len(grid), len(grid[0]) move_cost = 0 # Function to compute number of adjacent 1\'s for a cell at (i, j) def adjacent_ones(i, j): count = 0 if i > 0 and grid[i-1][j] == 1: count += 1 if i < m-1 and grid[i+1][j] == 1: count += 1 if j > 0 and grid[i][j-1] == 1: count += 1 if j < n-1 and grid[i][j+1] == 1: count += 1 return count # Extract all cells which are 1\'s ones = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1] # Perform moves in reversed order (to process least cost ones first) while ones: i, j = ones.pop() current_cost = adjacent_ones(i, j) move_cost += current_cost grid[i][j] = 0 # Updating the adjacent_ones for remaining cells in the ones list ones = [(i, j) for i, j in ones if grid[i][j] == 1] return move_cost"},{"question":"Given an integer `n`, return the number of unique **balanced parentheses** strings of length `2n`. A balanced parentheses string has equal numbers of opening and closing parentheses in a valid order. For example, given `n = 3`, the function should return `5` because there are five unique balanced parentheses strings of length `6`: `\\"((()))\\"`, `\\"(()())\\"`, `\\"(())()\\"`, `\\"()(())\\"`, and `\\"()()()\\"`. Return _the count of such strings_.","solution":"def count_balanced_parentheses(n): Returns the number of unique balanced parentheses strings of length 2n. The problem of counting balanced parentheses strings can be reduced to counting the nth Catalan number. if n == 0: return 1 # Table to store results of subproblems catalan = [0] * (n + 1) # Initialize catalan[0] = catalan[1] = 1 # Fill the table in bottom-up manner for i in range(2, n + 1): catalan[i] = 0 for j in range(i): catalan[i] += catalan[j] * catalan[i - j - 1] return catalan[n]"},{"question":"You are given two strings `s` and `t` consisting of lower-case English letters only. You want to make `t` an anagram of `s` by rearranging its letters. However, you can also change any letter of `t` to any other lower-case letter. Return _the **minimum** number of changes needed to make_ `t` _an anagram of_ `s`. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once.","solution":"from collections import Counter def min_changes_to_make_anagram(s, t): Returns the minimum number of changes needed to make t an anagram of s. if len(s) != len(t): raise ValueError(\\"The lengths of s and t must be the same\\") count_s = Counter(s) count_t = Counter(t) changes_needed = 0 for char in count_s: if count_s[char] > count_t[char]: changes_needed += count_s[char] - count_t[char] return changes_needed"},{"question":"You are given a binary tree represented as a sequence of `TreeNode` objects. Each `TreeNode` object has attributes `val` (integer) and `left`, `right` (pointers to the left and right children, respectively). Implement a function to serialize and deserialize this binary tree. The serialization should convert the binary tree into a single string, and the deserialization should take this string and reconstruct the original binary tree structure. For example, given the binary tree: ``` 1 / 2 3 / 4 5 ``` You should be able to serialize it into a string such as `\\"1,2,null,null,3,4,null,null,5,null,null\\"` and then deserialize it back to the original binary tree structure. Ensure that your solution handles null values and various tree structures correctly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if not node: serialized_values.append(\\"null\\") return serialized_values.append(str(node.val)) helper(node.left) helper(node.right) serialized_values = [] helper(root) return \',\'.join(serialized_values) def deserialize(data): Decodes your encoded data to tree. def helper(): value = next(values) if value == \\"null\\": return None node = TreeNode(int(value)) node.left = helper() node.right = helper() return node values = iter(data.split(\',\')) return helper()"},{"question":"You are given an m x n 2D grid consisting of non-negative integers where each cell represents an elevation map. Each integer in the grid denotes the height of a particular cell. The rainwater can only flow from a cell to its neighboring cells (left, right, up, or down) if the neighboring cell has an equal or lower height. The goal is to find the number of cells in the grid from which water can flow to both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges of the grid. Your task is to return the count of cells in the grid from which water can flow to both the Pacific and Atlantic Oceans.","solution":"def pacificAtlantic(matrix): Returns the number of cells from which water can flow to both the Pacific and Atlantic Ocean. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) def dfs(matrix, visited, i, j): visited.add((i, j)) for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= x < m and 0 <= y < n and (x, y) not in visited and matrix[x][y] >= matrix[i][j]: dfs(matrix, visited, x, y) pacific_reachable = set() atlantic_reachable = set() for i in range(m): dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, n-1) for j in range(n): dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, m-1, j) return len(pacific_reachable & atlantic_reachable)"},{"question":"You are given two strings `word1` and `word2`. You want to delete the minimum number of characters from either of the two strings so that the remaining two substrings are **anagrams**. Return the minimum number of deletions required. An anagram of a string is a string that contains the same characters, only the order of characters can be different.","solution":"from collections import Counter def min_deletions_to_make_anagrams(word1, word2): Returns the minimum number of deletions required to make the two strings anagrams. count1 = Counter(word1) count2 = Counter(word2) # Find the characters that need to be deleted deletions = 0 for char in count1: if char in count2: deletions += abs(count1[char] - count2[char]) else: deletions += count1[char] for char in count2: if char not in count1: deletions += count2[char] return deletions"},{"question":"Write a function to find the **second smallest** number in a list. The function should return the second smallest number only if there are at least two distinct numbers in the list. If there are less than two distinct numbers, return -1. For example, given the list `[4, 2, 5, 1, 3, 2, 5]`, the second smallest distinct number is `2`.","solution":"def second_smallest(numbers): Returns the second smallest distinct number in the list. If there are less than two distinct numbers, returns -1. distinct_numbers = list(set(numbers)) # Remove duplicates if len(distinct_numbers) < 2: return -1 distinct_numbers.sort() return distinct_numbers[1]"},{"question":"You are given a list of strings `words` and a string `s` consisting of lowercase letters. Write a function that returns the longest word in `words` that can be formed by deleting some characters of `s` without reordering the remaining characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If no valid word can be formed, return an empty string.","solution":"def findLongestWord(s, words): Returns the longest word in words that can be formed by deleting some characters of s without reordering the remaining characters. If there is more than one possible result, returns the longest word with the smallest lexicographical order. If no valid word can be formed, returns an empty string. def is_subsequence(x): it = iter(s) return all(char in it for char in x) longest_word = \'\' for word in words: if is_subsequence(word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"You are given a list of **non-negative** integers `nums` and an integer `target`. Find a contiguous subarray whose sum is equal to `target` and return _the starting and ending indices of the subarray_. If there are multiple such subarrays, return the indices of the one that appears first. If no such subarray is found, return an empty list.","solution":"def find_subarray_with_target_sum(nums, target): Finds a contiguous subarray whose sum is equal to target and returns the starting and ending indices of the subarray. If no such subarray is found, returns an empty list. current_sum = 0 start_index = 0 sum_dict = {} for end_index, num in enumerate(nums): current_sum += num if current_sum == target: return [start_index, end_index] if (current_sum - target) in sum_dict: return [sum_dict[current_sum - target] + 1, end_index] sum_dict[current_sum] = end_index return []"},{"question":"You are given a string `s` containing digits from 2 to 9 inclusive, and a list of strings `wordList`. Each digit in `s` maps to a set of letters as follows: 2 -> \\"abc\\", 3 -> \\"def\\", 4 -> \\"ghi\\", 5 -> \\"jkl\\", 6 -> \\"mno\\", 7 -> \\"pqrs\\", 8 -> \\"tuv\\", and 9 -> \\"wxyz\\". Consider any possible concatenations of the letters that these digits could represent. Return _the count of words from `wordList` that can exactly represent one of these concatenations_.","solution":"def count_matching_words(s, wordList): Given a string `s` containing digits from 2 to 9 inclusive and a list of strings `wordList`, return the count of words from `wordList` that can exactly represent one of the possible concatenations of the letters that these digits could represent. # Mapping of digits to corresponding letters digit_to_letters = { \'2\': \\"abc\\", \'3\': \\"def\\", \'4\': \\"ghi\\", \'5\': \\"jkl\\", \'6\': \\"mno\\", \'7\': \\"pqrs\\", \'8\': \\"tuv\\", \'9\': \\"wxyz\\" } from itertools import product # Generate lists of letters for each digit in the string `s` letter_combinations = [digit_to_letters[digit] for digit in s] # Generate all possible concatenations possible_words = set(\'\'.join(combination) for combination in product(*letter_combinations)) # Count how many words from wordList are in the possible_words set matching_words_count = sum(1 for word in wordList if word in possible_words) return matching_words_count"},{"question":"Given an array `arr` of integers, you are to determine if it\'s possible to split the entire array into two subarrays such that the sum of elements in both subarrays is the same. Return `true` if it is possible, otherwise return `false`. Note: - A subarray is a contiguous part of the array. - Each element of the array should be part of exactly one of the two subarrays.","solution":"def can_split_into_equal_sum_subarrays(arr): Determines if an array can be split into two subarrays with equal sum. Arguments: arr -- a list of integers Returns: True if the array can be split into two subarrays with equal sum, False otherwise. total_sum = sum(arr) # If the total sum is odd, we can\'t split it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for num in arr: current_sum += num if current_sum == target_sum: return True return False"},{"question":"You are given a `string` containing digits from `0-9` and a positive integer `k`. You need to find the smallest possible number that can be obtained by removing exactly `k` digits from the original string. The resulting number should not contain any leading zeros unless the number is `0`. Return _the smallest number obtained_ as a `string`.","solution":"def removeKdigits(num: str, k: int) -> str: Returns the smallest possible number as a string after removing exactly k digits from num. # Edge case where k is greater than or equal to the length of the number if k == len(num): return \\"0\\" stack = [] for digit in num: # While stack has elements, k is greater than 0, # and the current digit is less than the last digit in the stack, # remove the last digit from the stack (to get a smaller number) while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # Finally, remove the remaining digits from the end if k > 0 final_number = stack[:-k] if k else stack # Convert the list back to a string and strip leading zeroes result = \\"\\".join(final_number).lstrip(\'0\') # Return \\"0\\" if the result is an empty string return result if result else \\"0\\""},{"question":"A robot is located at the top-left corner of a `m x n` grid marked as `(0, 0)`. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid marked as `(m-1, n-1)`. Write a function to count the number of unique paths that the robot can take to reach the bottom-right corner. **Note:** The answer can be a large number, so you should return the answer modulo `10^9 + 7`. You are given the dimensions `m` and `n` of the grid.","solution":"def unique_paths(m, n): Returns the number of unique paths in a m x n grid. The result is returned modulo 10^9 + 7. MOD = 10**9 + 7 # Initialize a 2D array with zeros dp = [[0] * n for _ in range(m)] # Base case: One way to reach any cell in the first row or first column. for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting of lowercase English letters. A character is considered \\"special\\" if it appears at least three times in `s`. Your task is to rearrange `s` such that no two \\"special\\" characters are adjacent to each other. If it is possible to rearrange `s` in this manner, return the rearranged string. Otherwise, return an empty string.","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s): Rearranges the input string such that no two adjacent characters are both \\"special\\". A \\"special\\" character appears at least three times in `s`. Returns the rearranged string if possible, else an empty string. # Count the frequency of each character in the string char_count = Counter(s) # Create a max heap based on the counts. Using negative because Python\'s heap is min heap by default heap = [] for char, count in char_count.items(): heappush(heap, (-count, char)) prev_count, prev_char = 0, \'\' result = [] while heap: count, char = heappop(heap) # Append the current character to the result result.append(char) # If the previous char exists and it\'s not zero, push it back into heap if prev_count < 0: heappush(heap, (prev_count, prev_char)) # Update the count of the current character count += 1 prev_count, prev_char = count, char # If the rearranged string\'s length matches the original string, it\'s valid if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"You are given an array of integers `arr`, which contains `n` elements (where `n` > 1). The task is to split the array into two parts such that the sum of one part is as close as possible to the sum of the other part, and then determine the absolute difference between these two sums. You need to return the minimum possible absolute difference. For example, given an array `[1, 6, 11, 5]`, you can split it into `[1, 6, 5]` and `[11]` or `[1, 11]` and `[6, 5]`, or other combinations. The goal is to find the split such that the absolute difference between the sums of the two parts is minimized.","solution":"def find_min_diff(arr): Finds the minimum possible absolute difference between the sums of two parts of the array. total_sum = sum(arr) n = len(arr) # Create a DP table where dp[i][j] is True if a subset of sum j can be formed using the first i elements dp = [[False] * (total_sum//2 + 1) for _ in range(n+1)] # Initialize for i in range(n+1): dp[i][0] = True # Fill the DP table for i in range(1, n+1): for j in range(1, total_sum//2 + 1): dp[i][j] = dp[i-1][j] if arr[i-1] <= j: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] # Find the maximum sum that is possible to achieve with the first n elements for j in range(total_sum//2, -1, -1): if dp[n][j]: sum1 = j break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"Given an integer array `arr` where each element is at most two positions away from its original position in a sorted array, return the sorted version of this array. Write an efficient algorithm to achieve this, ensuring your solution handles the given constraints optimally.","solution":"import heapq def sort_nearly_sorted_array(arr): Given an array where each element is at most two positions away from its original position in a sorted array, return the sorted version of this array. n = len(arr) if n <= 2: return sorted(arr) # Initiate a min heap heap = [] result = [] # Add first 3 elements to the heap because any element in the sorted array # can only be present within the first 3 elements at maximum. for i in range(3): heapq.heappush(heap, arr[i]) # For the rest of the elements, add the next element and remove the # smallest element from the heap. for i in range(3, n): heapq.heappush(heap, arr[i]) result.append(heapq.heappop(heap)) # Add remaining elements in the heap to the result. while heap: result.append(heapq.heappop(heap)) return result"},{"question":"You are given an integer array `nums` and an integer `k`. You can choose any subarray of `nums` and increment each of its elements by `1` exactly `k` times. Return _the maximum possible sum of the array_ after performing the operations.","solution":"def max_sum_after_k_operations(nums, k): Returns the maximum possible sum of the array after incrementing each element of a chosen subarray by 1 exactly k times. n = len(nums) total_sum = sum(nums) max_sum = total_sum + k * n return max_sum"},{"question":"You are given a string `s` and an integer `k`. You need to split the string into `k` parts such that each part is as even as possible in length. If the string cannot be evenly divided, some parts will be longer than others. Return a list of strings representing the split parts. If it is not possible to split the string into exactly `k` parts, return an empty list.","solution":"def split_string(s, k): Splits the string `s` into `k` parts such that each part is as even as possible in length. If it is not possible to split the string into exactly `k` parts, return an empty list. n = len(s) if k > n: return [] quotient, remainder = divmod(n, k) parts = [] start = 0 for i in range(k): extra = 1 if i < remainder else 0 end = start + quotient + extra parts.append(s[start:end]) start = end return parts"},{"question":"You are given a `root` of a binary tree where each node contains an integer value. Return the _deepest level sum_ of the tree. The deepest level sum is defined as the sum of all nodes\' values that are at the deepest level of the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_level_sum(root): if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"You are given a list of unique words. The task is to determine the length of the longest word chain that can be created. A word chain is formed by adding exactly one letter at a time to a word from the previous word in the chain such that the word remains in the given list of words. For instance, the list `[\\"a\\", \\"ba\\", \\"bda\\", \\"bdca\\"]` has a longest word chain of `\\"a\\" -> \\"ba\\" -> \\"bda\\" -> \\"bdca\\"`, so the length is 4. The order of the words and the resulting chain length should be returned as an integer. One word chains (e.g., just “a”) are valid and should return a length of 1. Writing a function that takes the list of words and returns the length of the longest possible word chain. Example input: `words = [\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]` Example output: `4`","solution":"def longest_str_chain(words): Returns the length of the longest word chain that can be created from the given list of words. words.sort(key=len) longest_chain = {} max_length = 0 for word in words: longest_chain[word] = 1 for i in range(len(word)): prev_word = word[:i] + word[i+1:] if prev_word in longest_chain: longest_chain[word] = max(longest_chain[word], longest_chain[prev_word] + 1) max_length = max(max_length, longest_chain[word]) return max_length"},{"question":"You are given a binary string `s`, which consists of characters \'0\' and \'1\' only. You are allowed to flip at most one \'0\' to \'1\'. If you choose to make this flip, return the length of the longest contiguous sequence of \'1\'s that can be achieved. If you don\'t need to make any flips, return the length of the longest contiguous sequence of \'1\'s that already exists in the string.","solution":"def longest_contiguous_ones(s): Returns the length of the longest contiguous sequence of \'1\'s that can be achieved by flipping at most one \'0\' to \'1\' in the given binary string `s`. :param s: A binary string consisting of \'0\' and \'1\'. :return: An integer representing the length of the longest contiguous sequence of \'1\'s. n = len(s) if n == 0: return 0 # Count the number of 1s in the original string total_ones = s.count(\'1\') if total_ones == n: # All are 1s return total_ones # Use two pointers to find the longest sequence left = 0 right = 0 max_ones_with_flip = 0 zeros_count = 0 while right < n: if s[right] == \'0\': zeros_count += 1 while zeros_count > 1: if s[left] == \'0\': zeros_count -= 1 left += 1 max_ones_with_flip = max(max_ones_with_flip, right - left + 1) right += 1 return max_ones_with_flip"},{"question":"You are given a string `s` consisting of lowercase English letters. You can choose any one of its characters and change it to any other lowercase English character. What is the minimum number of changes needed so that the string does not contain any repeating consecutive characters? Return the minimum number of changes required.","solution":"def min_changes_to_avoid_consecutive_repeats(s): Returns the minimum number of changes needed to avoid consecutive repeating characters in the string. if not s: return 0 changes = 0 n = len(s) for i in range(1, n): if s[i] == s[i-1]: changes += 1 # To avoid consecutive repeats, change the current character to some other character. # We can choose any character different from s[i-1] if i + 1 < n and s[i-1] == s[i+1]: # If the next character is the same as s[i-1], we need to change s[i+1] as well. # We\'ll assume changing s[i+1] will be handled in the next iterations. pass return changes"},{"question":"You are given a list of integers `arr` representing the `heights` of buildings where `arr[i]` is the height of the `ith` building. The buildings are situated in a straight line and form a skyline from left to right. A building can be seen if and only if there are no taller buildings to its left that obstruct its view. Identify the buildings that can be seen from a viewpoint at the immediate left of the first building. Return an array containing the indices of these visible buildings in the order they appear in the input array.","solution":"def visible_buildings(arr): Returns the indices of buildings that are visible from the left. Args: arr: List[int] - A list of integers representing the heights of buildings. Returns: List[int] - A list of indices of buildings that are visible from the left. visible = [] max_height = float(\'-inf\') for i, height in enumerate(arr): if height > max_height: visible.append(i) max_height = height return visible"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, your task is to determine if it is possible to partition the array into **exactly two** non-empty subsets with an equal sum. If such a partition is possible, return `true`; otherwise, return `false`. You may assume the entire array sum does not exceed `10^4`.","solution":"def can_partition(nums): Determines if it\'s possible to partition the given array into two subsets with equal sums. Args: nums: A list of integers. Returns: A boolean indicating if the partition is possible. total_sum = sum(nums) # If the total sum is odd, it cannot be partitioned equally if total_sum % 2 != 0: return False subset_sum = total_sum // 2 n = len(nums) # Initialize a DP array dp = [False] * (subset_sum + 1) dp[0] = True # Base case: sum of 0 is always possible for num in nums: # Traverse the dp array backwards for s in range(subset_sum, num - 1, -1): dp[s] = dp[s] or dp[s - num] return dp[subset_sum]"},{"question":"Implement a class `BankAccount` that simulates a simple bank account. The class should have the following functionalities: - The constructor `BankAccount(double initialBalance)` initializes the account with a given initial balance. - A method `void deposit(double amount)` that adds the specified amount to the account balance. - A method `boolean withdraw(double amount)` that subtracts the specified amount from the account balance if sufficient funds are available, and returns `true`. If there are insufficient funds, the balance should remain unchanged, and the method should return `false`. - A method `double getBalance()` that returns the current balance of the account. Ensure that the balance is always rounded to two decimal places.","solution":"class BankAccount: def __init__(self, initialBalance): Initializes the account with a given initial balance. if initialBalance < 0: raise ValueError(\\"Initial balance must be non-negative.\\") self.balance = round(initialBalance, 2) def deposit(self, amount): Adds the specified amount to the account balance. if amount < 0: raise ValueError(\\"Deposit amount must be non-negative.\\") self.balance = round(self.balance + amount, 2) def withdraw(self, amount): Subtracts the specified amount from the account balance if sufficient funds are available. Returns True if the withdrawal was successful, False otherwise. if amount < 0: raise ValueError(\\"Withdrawal amount must be non-negative.\\") if self.balance >= amount: self.balance = round(self.balance - amount, 2) return True else: return False def getBalance(self): Returns the current balance of the account. return self.balance"},{"question":"You are given a binary tree where each node has an integer value. Design an algorithm to find the value of the deepest left leaf node in the tree. If there are multiple deepest left leaf nodes, return the value of the leftmost one. If there is no left leaf, return `-1`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_deepest_left_leaf(root): Function to find the deepest left leaf node in a binary tree. If there are multiple deepest left leaf nodes, return the value of the leftmost one. If there is no left leaf, return -1. if not root: return -1 # Queue for level order traversal, storing nodes along with their depth and whether they are left children queue = [(root, 0, False)] deepest_left_leaf_depth = -1 deepest_left_leaf_val = -1 while queue: current, depth, is_left = queue.pop(0) # Check if it\'s a left leaf node and deeper than the known deepest if is_left and not current.left and not current.right and depth > deepest_left_leaf_depth: deepest_left_leaf_depth = depth deepest_left_leaf_val = current.val # Add children to the queue if current.left: queue.append((current.left, depth + 1, True)) if current.right: queue.append((current.right, depth + 1, False)) return deepest_left_leaf_val"},{"question":"You are given a list of integers `arr`. A sublist `sub` of `arr` is called a **strictly increasing subsequence** (SIS) if the elements of `sub` are in strictly increasing order. Write a function that finds the length of the longest strictly increasing subsequence of `arr`. For example, given `arr = [10, 9, 2, 5, 3, 7, 101, 18]`, the longest SIS is `[2, 3, 7, 101]`, which has a length of 4. Return _the length of the longest strictly increasing subsequence_ in `arr`.","solution":"def length_of_longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence in the given list. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one. Implement a function `findUnique(nums)` that returns the single one. Your algorithm should have a linear runtime complexity. Can you implement it without using any extra memory?","solution":"def findUnique(nums): Returns the unique number in the array where every other number appears twice. unique = 0 for num in nums: unique ^= num return unique"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', return the maximum length of a substring that contains the same number of \'a\'s and \'b\'s. If the string does not contain a substring with equal numbers of \'a\'s and \'b\'s, return `0`.","solution":"def max_equal_ab_substring_length(s): Given a string consisting only of \'a\' and \'b\', returns the maximum length of a substring that contains the same number of \'a\'s and \'b\'s. If no such substring exists, returns 0. n = len(s) count_diffs = {0: -1} # Dictionary to store the first occurrence of each count difference max_length = 0 count_diff = 0 # Variable to store the current difference between counts of \'a\' and \'b\' for i, char in enumerate(s): if char == \'a\': count_diff += 1 else: count_diff -= 1 if count_diff in count_diffs: # Update max_length if we found a larger balanced substring max_length = max(max_length, i - count_diffs[count_diff]) else: # Store the first occurrence of this count difference count_diffs[count_diff] = i return max_length"},{"question":"**Given a string `s` consisting of lowercase letters, you need to find the length of the longest substring without repeating characters. Implement a function that returns the length of such a substring.** _Write a function that takes a string `s` as input and returns an integer representing the length of the longest substring without repeating characters._ **Example:** - For the input `s = \\"abcabcbb\\"`, the output should be `3`, representing the substring `\\"abc\\"`. - For the input `s = \\"bbbbb\\"`, the output should be `1`, representing the substring `\\"b\\"`. - For the input `s = \\"pwwkew\\"`, the output should be `3`, representing the substring `\\"wke\\"`.","solution":"def length_of_longest_substring(s): This function returns the length of the longest substring without repeating characters. :param s: String input :return: Integer length of the longest substring without repeating characters start = 0 max_length = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, i - start + 1) used_chars[char] = i return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters. A character in `s` is considered \\"special\\" if it appears exactly twice in `s`. Return a new string where all non-special characters from `s` have been removed. If no special characters exist in `s`, return an empty string.","solution":"def get_special_characters(s): Returns a new string consisting of characters in `s` that appear exactly twice. :param s: Input string consisting of lowercase English letters :return: A new string with all non-special characters removed from collections import Counter char_count = Counter(s) special_chars = \'\'.join([char for char in s if char_count[char] == 2]) return special_chars"},{"question":"You are given a **0-indexed** integer array `heights` of length `n`, where `heights[i]` represents the height of the `i-th` person in a line. You need to find the number of people who need to move to a different position in order for the line to be in non-decreasing order by height. Return the **minimum** number of moves required.","solution":"def min_moves_to_sort(heights): Returns the minimum number of moves required for the line to be in non-decreasing order of heights. Args: heights (List[int]): A list of integers representing the heights of people. Returns: int: Minimum number of moves required. sorted_heights = sorted(heights) moves = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves += 1 return moves"},{"question":"You are given a list of flight routes, where each route is represented as a list of two cities `[cityA, cityB]`, meaning there is a direct flight between `cityA` and `cityB`. Write a function that determines if there is a way to travel from a given starting city `startCity` to a destination city `destinationCity` using these routes. Return `true` if it is possible to travel from `startCity` to `destinationCity`, otherwise return `false`. If `startCity` and `destinationCity` are the same, return `true`. The function should handle the possibility of circular routes and disconnected graphs.","solution":"def can_travel(routes, startCity, destinationCity): from collections import defaultdict, deque if startCity == destinationCity: return True # Create adjacency list graph = defaultdict(list) for cityA, cityB in routes: graph[cityA].append(cityB) graph[cityB].append(cityA) # Perform BFS to find a path from startCity to destinationCity visited = set() queue = deque([startCity]) while queue: current_city = queue.popleft() if current_city == destinationCity: return True if current_city not in visited: visited.add(current_city) for neighbor in graph[current_city]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"Given a binary string `s`, you are allowed to perform at most one operation where you can choose any substring of `s` and flip all the bits in it (i.e., change all `0`s to `1`s and all `1`s to `0`s). Your goal is to return the maximum number of consecutive `1`s that can be obtained by performing at most one flip operation. If no flipping is needed to achieve the maximum number of consecutive `1`s, return the length of the already longest sequence of consecutive `1`s.","solution":"def max_consecutive_ones(binary_string): Returns the maximum number of consecutive 1s obtainable by at most one flip operation on any substring of the binary string. n = len(binary_string) if n == 0: return 0 left_ones = [0] * n right_ones = [0] * n current_ones = 0 for i in range(n): if binary_string[i] == \'1\': current_ones += 1 else: current_ones = 0 left_ones[i] = current_ones current_ones = 0 for i in range(n-1, -1, -1): if binary_string[i] == \'1\': current_ones += 1 else: current_ones = 0 right_ones[i] = current_ones max_consecutive_1s = max(left_ones) # Without any flip for i in range(1, n - 1): if binary_string[i] == \'0\': # Sequence if flipped binary_string[i] from 0 to 1 max_consecutive_1s = max(max_consecutive_1s, left_ones[i-1] + 1 + right_ones[i+1]) if \'0\' in binary_string: max_consecutive_1s = max(max_consecutive_1s, max(left_ones) + 1) # Single flip for all zeroes return max_consecutive_1s"},{"question":"You are given a string `s` which consists only of lowercase English letters. You are allowed to shuffle the characters of the string as many times as needed. Return _the length of the longest substring containing only unique characters that you can generate by any permutation of the given string_.","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring containing only unique characters that can be generated by any permutation of the given string. return len(set(s))"},{"question":"You are given a binary tree represented as a list where elements are stored in level order traversal of the tree. Each element can either be an integer or `None` (indicating that there is no valid node at that position). Your task is to determine if this tree is a **Complete Binary Tree**. A **Complete Binary Tree** is a binary tree in which all the levels are completely filled except possibly for the last level, which is filled from left to right. Return `True` if the given binary tree is complete, otherwise return `False`.","solution":"def is_complete_binary_tree(tree): Determines if the given binary tree (represented as a level order list of elements) is a Complete Binary Tree. if not tree: return True n = len(tree) # Identify the first occurrence of None for i in range(n): if tree[i] is None: # Check if all the elements after the first None are also None for j in range(i, n): if tree[j] is not None: return False break return True"},{"question":"You are given a `k x k` binary matrix `matrix` and an integer `k`. A binary matrix is a matrix that has only `0`s and `1`s as its elements. Your task is to determine the length of the largest square that can be obtained by selecting a submatrix from `matrix` such that all of its elements are `1`. Return _the side length of the largest square submatrix with all `1`s in `matrix`_.","solution":"def largest_square_submatrix(matrix, k): if k == 0: return 0 dp = [[0] * k for _ in range(k)] max_side = 0 for i in range(k): for j in range(k): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # If it\'s on the first row or first column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"Write a function that, given an integer array `nums` and an integer `target`, returns the length of the shortest, non-empty contiguous subarray of `nums` with a sum greater than or equal to `target`. If there is no such subarray, return `0`. Example: ``` Input: nums = [2,3,1,2,4,3], target = 7 Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. ```","solution":"def min_subarray_len(nums, target): Returns the length of the shortest, non-empty contiguous subarray of `nums` with a sum greater than or equal to `target`. n = len(nums) min_len = float(\'inf\') # Initialize to a large number left = 0 curr_sum = 0 for right in range(n): curr_sum += nums[right] while curr_sum >= target: min_len = min(min_len, right - left + 1) curr_sum -= nums[left] left += 1 return 0 if min_len == float(\'inf\') else min_len"},{"question":"Given a positive integer `num`, generate the lexicographical order (dictionary order) from `1` to `num` inclusive. Return _an integer array where the first element is `1`, the second element is the second smallest number in dictionary order, and so on until the number `num`_. For example, if `num = 13`, the resulting array should be `[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]`.","solution":"def lexicalOrder(num): Given a positive integer num, generate the lexicographical order (dictionary order) from 1 to num inclusive. return sorted(range(1, num + 1), key=str)"},{"question":"You are given two strings `s` and `t`, both of the same length. In one **move**, you can choose any character in `s` and replace it with any character from `t`. The goal is to convert `s` into a palindrome with the fewest moves possible. A string is a **palindrome** if it reads the same forward and backward. Return _the minimum number of moves needed to make_ `s` _a palindrome using characters from_ `t`.","solution":"def min_moves_to_make_palindrome(s, t): Returns the minimum number of moves needed to make s a palindrome using characters from t. n = len(s) moves = 0 for i in range(n // 2): left = s[i] right = s[n - 1 - i] if left != right: if left in t: s = s[:i] + right + s[i+1:] elif right in t: s = s[:n - 1 - i] + left + s[n - i:] else: s = s[:i] + right + s[i+1:] t = t.replace(left, \'\', 1).replace(right, \'\', 1) moves += 1 return moves"},{"question":"Given a string `s`, your task is to determine the minimum number of steps required to make the string a palindrome. In one step, you can choose any character in the string and replace it with another character. The string `s` consists of only lowercase English letters. **Example:** * `Input: s = \\"abca\\"` * `Output: 1` * `Explanation: By replacing the \'b\' with \'c\', we get \\"acca\\", which is a palindrome. Write a function: ```python def min_steps_to_palindrome(s: str) -> int: # Your code here ``` The function should return an integer representing the minimum number of steps to make the given string a palindrome.","solution":"def min_steps_to_palindrome(s: str) -> int: Determines the minimum number of steps required to make the string a palindrome. :param s: Input string consisting only of lowercase English letters. :return: Minimum number of character replacements needed. n = len(s) steps = 0 # Compare characters from both ends towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: steps += 1 return steps"},{"question":"You are given an array of integers `arr` and an integer `d`. Every element in the array represents a platform with a certain height, and you can only jump from one platform to another if the height difference between the two platforms is at most `d`. You can start jumping from any platform in the array and you can jump to either the left or the right. Return _the maximum number of platforms you can visit in one continuous jump sequence._ Note: You cannot visit the same platform more than once during the jump sequence.","solution":"def max_jumps(arr, d): n = len(arr) dp = [1] * n def dfs(i): if dp[i] > 1: return dp[i] max_jump = 1 for direction in (-1, 1): for step in range(1, d + 1): nxt = i + direction * step if 0 <= nxt < n and arr[nxt] < arr[i]: max_jump = max(max_jump, dfs(nxt) + 1) else: break dp[i] = max_jump return dp[i] return max(dfs(i) for i in range(n))"},{"question":"You are given a string `uniqueText` consisting of uppercase English letters and sorted in non-decreasing order. You need to compress the string such that each group of consecutive repeating characters is replaced with a single instance of that character followed by the number of times it repeats. For example, the string `\\"AAABBCCDDDD\\"` would be compressed to `\\"A3B2C2D4\\"`. If a character appears only once in a group, it should appear in the compressed form as the character itself without the number 1 following it. Return _the compressed string_. If the length of the compressed string is not smaller than the original string, return _the original string_.","solution":"def compress_string(uniqueText): if not uniqueText: return uniqueText n = len(uniqueText) compressed = [] count = 1 for i in range(1, n): if uniqueText[i] == uniqueText[i - 1]: count += 1 else: compressed.append(uniqueText[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(uniqueText[-1]) if count > 1: compressed.append(str(count)) compressed_str = \'\'.join(compressed) if len(compressed_str) >= n: return uniqueText else: return compressed_str"},{"question":"Given a single string `s` consisting of lowercase English letters, you need to find and return all the different palindromic substrings in `s`. A string is palindromic if it reads the same forward and backward. Your function should return a list of all unique palindromic substrings in lexicographical order. For example, given the input string \\"aabb\\", your function should return [\\"a\\", \\"aa\\", \\"b\\", \\"bb\\"].","solution":"def find_palindromic_substrings(s): Returns a list of unique palindromic substrings in lexicographical order. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if is_palindrome(substring): palindromic_substrings.add(substring) return sorted(palindromic_substrings)"},{"question":"You are given a string `s` consisting of lowercase English letters. A **substring** is a contiguous sequence of characters within the string. Two substrings are considered **distinct** if they have different starting or ending positions in the string. Write a function `countDistinctSubstrings` to return _the total number of distinct substrings present in the string_ `s`. *For example, given the string `s = \\"abc\\"`, the distinct substrings are: `\\"a\\"`, `\\"b\\"`, `\\"c\\"`, `\\"ab\\"`, `\\"bc\\"`, and `\\"abc\\"`. Thus, the function should return `6`*. Implement the `countDistinctSubstrings` class: * `countDistinctSubstrings(String s)` - Returns the total number of distinct substrings present in the string `s`.","solution":"def countDistinctSubstrings(s): Returns the total number of distinct substrings present in the string s. n = len(s) substrings = set() for i in range(n): for j in range(i, n): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"You are given a grid representing a city, where each cell in the grid contains a non-negative integer indicating the cost to pass through that cell. You are to find a path from the top-left corner of the grid to the bottom-right corner such that the total cost is minimized. You can move in all four possible directions (up, down, left, right) but cannot move diagonally. Implement the function `minPathCost(grid)` that returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. - Note: Ensure the function handles varying grid sizes and dimensions properly.","solution":"import heapq def minPathCost(grid): Returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] heap = [(grid[0][0], 0, 0)] # (cost, row, col) visited = set() while heap: cost, row, col = heapq.heappop(heap) if (row, col) in visited: continue visited.add((row, col)) if row == rows - 1 and col == cols - 1: return cost for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: heapq.heappush(heap, (cost + grid[new_row][new_col], new_row, new_col)) return -1 # If there\'s no path (shouldn\'t reach here for valid input)"},{"question":"Given an array of integers `arr`, you are asked to find the **number of distinct maximum values** in each of its **subarrays**. A subarray is a contiguous part of an array. Return an array `result` where `result[i]` is the number of distinct maximum values in the subarray starting at index `i` and ending at any possible index `j` (where `i <= j < len(arr)`). For instance, if the array is `[1, 2, 1]`, the subarrays starting from index 0 are `[1]`, `[1, 2]`, and `[1, 2, 1]`. The result for this example would be `[2, 1, 1]` because: - The subarray `[1]` has a distinct maximum value of `1`. - The subarray `[1, 2]` has distinct maximum values of `1` and `2`. - The subarray `[1, 2, 1]` has distinct maximum values of `1` and `2`.","solution":"def number_of_distinct_maximums(arr): Returns an array where the ith element contains the number of distinct maximum values in all subarrays starting from index i. n = len(arr) result = [] for i in range(n): subarray_max = set() current_max = float(\'-inf\') for j in range(i, n): current_max = max(current_max, arr[j]) subarray_max.add(current_max) result.append(len(subarray_max)) return result"},{"question":"You are given a list of words `[words]` and a string `[chars]`. Each character in `[chars]` can be used to form words in `[words]`. A word can be formed if and only if there are sufficient characters in `[chars]` to match the characters in the word. Return the sum of the lengths of all good words that can be formed by characters from `[chars]`. A good word is one that can be entirely formed by characters in `[chars]`. For example, if `[words] = [\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"]` and `[chars] = \\"atach\\"`, you can form the words \\"cat\\" and \\"hat\\" which have lengths 3 and 3 respectively. The answer would be `6`.","solution":"from collections import Counter def count_characters(words, chars): Returns the sum of lengths of all good words that can be formed using characters from chars. char_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= char_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"Given an integer array `heights` representing the height of buildings along a street, and a positive integer `k`, return _the maximum number of buildings you can consecutively jump over if you can only make `k` jumps in total. A jump is defined as moving from one building to another if the height difference is at most `k` units_. If you cannot jump over any buildings, return `0`.","solution":"def max_buildings_jump(heights, k): Returns the maximum number of buildings consecutively jumped over if you can make `k` jumps in total. Parameters: heights (list): List of integers representing the height of buildings. k (int): The maximum height difference you can jump over. Returns: int: Maximum number of buildings that can be consecutively jumped over. max_count = 0 current_count = 0 for i in range(1, len(heights)): if abs(heights[i] - heights[i - 1]) <= k: current_count += 1 else: max_count = max(max_count, current_count) current_count = 0 max_count = max(max_count, current_count) return max_count + 1 if max_count > 0 else 0 # Add 1 to include the first building in the count"},{"question":"You are given a sorted array of unique integers `arr` and two integers `k` and `x`. Return _the **k** closest integers to `x` in the array_. The result should also be sorted in ascending order. If there is a tie, the smaller element is preferred.","solution":"def findClosestElements(arr, k, x): Returns the k closest integers to x in the array. left = 0 right = len(arr) - 1 while right - left >= k: if abs(arr[left] - x) > abs(arr[right] - x): left += 1 else: right -= 1 return arr[left:left + k]"},{"question":"You are given a **linked list** where each node contains an integer value. The linked list can be represented as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Write a function to **reverse** the linked list. The function should take the head of the linked list as input and return the new head of the reversed linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses the linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The new head of the reversed linked list. prev = None curr = head while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev"},{"question":"Given an array of integers `nums` where every integer appears exactly three times except for one which appears exactly once, find the single integer that appears only once. Implement the function `int singleNumber(int[] nums)` that receives the array `nums` as input and returns the integer that appears only once. Your algorithm should have a linear runtime complexity and use constant extra space.","solution":"def singleNumber(nums): Given an array of integers where every integer appears exactly three times except for one that appears only once, return the integer that appears only once. Args: nums (List[int]): The list of integers. Returns: int: The single number that appears only once. if not nums: return 0 # Initialize variables to hold bits showing up once and twice ones, twos = 0, 0 for num in nums: # First, calculate `ones` ones = (ones ^ num) & ~twos # Then, calculate `twos` twos = (twos ^ num) & ~ones # `ones` is holding the single number now since bits are cleared when they appear thrice return ones"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to construct a new string by selecting `k` characters from `s` such that the characters are in reverse order of their original appearance in `s`. In other words, you will select the characters from the end of the string `s` and move towards the beginning, maintaining their order after reversing. Return the newly constructed string after selecting `k` characters. For example, if `s = \\"abcdefg\\"` and `k = 4`, selecting the last 4 characters from the end would result in `gfed`, and reversing them would give `defg`.","solution":"def select_reverse_characters(s, k): Selects `k` characters from the end of the string `s` and returns them in reverse order of their original appearance. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The number of characters to select from the end of the string. Returns: str: The newly constructed string after selecting `k` characters in reverse order. # Select the last k characters from the string selected_chars = s[-k:] # Reverse the selected characters reversed_chars = selected_chars[::-1] return reversed_chars"},{"question":"You are given a `2D` list of integers `grid` representing a 2D elevation map where `grid[i][j]` represents the height of a cell. Each cell can be used to store water. After it rains, water can only flow horizontally or vertically from one cell to a neighboring cell with a height equal to or lower than the current cell. Water cannot flow diagonally or to a cell with a higher elevation. Given this representation, compute the maximum amount of water that the `2D` grid can trap, assuming each cell can hold an infinite amount of water up to its height. Return the total amount of water that can be trapped within the entire `grid`.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells onto the heap and mark them as visited for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"Given an array of integers representing the heights of `n` buildings, you need to determine the number of buildings that have an ocean view. A building has an ocean view if all the buildings to its right have a smaller height. Assume the ocean is to the right side of the array. Return an array containing the indices of all buildings that have an ocean view, in increasing order. Implement the function `buildingsWithOceanView(mod)` which takes the array `heights` as input and returns the array of indices with ocean views as described.","solution":"def buildingsWithOceanView(heights): Returns an array containing the indices of all buildings that have an ocean view. n = len(heights) max_height = 0 result = [] for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"You are given an array of integers `nums` and an integer `threshold`. Your task is to find the maximum integer `k` such that there exists `k` consecutive elements in the array with their sum not exceeding the given `threshold`. Return the maximum integer `k` or `-1` if no such `k` exists.","solution":"def max_k_consecutive_sum(nums, threshold): Returns the maximum integer k such that there exists k consecutive elements in the array nums with their sum not exceeding the given threshold. n = len(nums) left, right = 1, n def can_find_k(k): current_sum = sum(nums[:k]) if current_sum <= threshold: return True for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum <= threshold: return True return False max_k = -1 while left <= right: mid = (left + right) // 2 if can_find_k(mid): max_k = mid left = mid + 1 else: right = mid - 1 return max_k"},{"question":"A company has a number of employees, each with a unique ID, and a hierarchical reporting structure where each employee reports to exactly one manager. You are given an integer `n`, the number of employees, and an array `manager` where `manager[i]` is the ID of the manager of the `i`-th employee. The company\'s CEO has ID `0` and is the ultimate manager of everyone. The ID of the CEO is `-1` in the `manager` array. Each employee has a certain amount of importance value represented by an array `importance` where `importance[i]` is the importance value of the `i`-th employee. The overall importance for an employee is calculated as the sum of their own importance value and the importance values of all the employees that report directly or indirectly to them. Your task is to compute and return the importance values for all the employees in the company in the form of an array where the `i`-th index represents the total importance value of the `i`-th employee.","solution":"def get_importance(n, manager, importance): from collections import defaultdict, deque # Create an adjacency list to represent the reporting structure adj_list = defaultdict(list) for i in range(n): if manager[i] != -1: # Ignore the CEO (who has manager[i] = -1) adj_list[manager[i]].append(i) # Function to calculate importance recursively def calculate_importance(employee_id): total_importance = importance[employee_id] for sub_id in adj_list[employee_id]: total_importance += calculate_importance(sub_id) return total_importance # Calculate importance for each employee result = [0] * n for i in range(n): result[i] = calculate_importance(i) return result"},{"question":"You are given a list of integers representing the heights of buildings along a street. Each building `i` is represented by its height `heights[i]`. From the rooftops, you have the opportunity to look at the sunset. A building can see the sunset if it is taller than all the buildings to its right. Write a function that takes in the list `heights` and returns a list of indices of the buildings that can see the sunset, in the order they appear from left to right.","solution":"def sunset_views(heights): Returns the list of indices of buildings that can see the sunset. A building can see the sunset if it is taller than all the buildings to its right. :param heights: List of building heights :return: List of indices of buildings that can see the sunset if not heights: return [] sunset_buildings = [] max_height_from_right = float(\'-inf\') # Iterate from right to left for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height_from_right: sunset_buildings.append(i) max_height_from_right = heights[i] # We need to reverse the order of buildings because we collected them from right to left return list(reversed(sunset_buildings))"},{"question":"You are given a string `s` consisting of lowercase letters, and an integer `k`. You need to perform a series of operations such that the resulting string is a palindrome with a maximum number of same consecutive characters minimized. In one operation, you can replace any character in `s` with any other character. Output the minimum number of operations required to achieve the task. Implement the `Solution` class: * `Solution(String s, int k)` Initializes the object with the string `s` and the integer `k`. * `int minOperations()` Returns the minimum number of operations required to transform the string `s` into a palindrome with a maximum of `k` consecutive characters being the same.","solution":"class Solution: def __init__(self, s, k): self.s = s self.k = k def minOperations(self): s = self.s n = len(s) k = self.k operations = 0 # Traverse the string from both ends to the center for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"You are given a string `s` and an array of strings `words`. All the strings in `words` are of the same length. A **concatenated sublist** is a string that is formed by concatenating all the strings in `words` exactly once, in any order. Your task is to find all the starting indices of the `s`\'s substrings that are exactly equal to a **concatenated sublist**. Return _the list of starting indices in ascending order_. If no substrings match, return an empty list.","solution":"def findSubstring(s, words): Find all starting indices of substrings in `s` that are concatenations of all strings in `words`. :param s: The string to search within. :param words: A list of words to concatenate. :return: A list of starting indices of substrings matching the concatenated words. if not s or not words or not words[0]: return [] word_len = len(words[0]) num_words = len(words) total_len = word_len * num_words word_count = {} # Count the frequency of each word in words for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 def is_valid(start): seen = {} for i in range(num_words): word_start = start + i * word_len word = s[word_start:word_start + word_len] if word not in word_count: return False if word in seen: seen[word] += 1 if seen[word] > word_count[word]: return False else: seen[word] = 1 return True results = [] for i in range(len(s) - total_len + 1): if is_valid(i): results.append(i) return results"},{"question":"You are given an integer array `nums` of length `n`. Your task is to rearrange `nums` such that every `nums[i]` is equal to the product of all elements in `nums` except `nums[i]`. Return the modified array. You must solve it without using division and in O(n) time complexity.","solution":"def product_except_self(nums): Given an array nums, return an array such that each element at index i is the product of all the numbers in the array except nums[i]. n = len(nums) # Initialize the result array with ones result = [1] * n # Pass 1: Calculate the products of all elements to the left of each element left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Pass 2: Calculate the products of all elements to the right of each element right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"You are given an array `arr` of integers where `arr[i]` represents the number of cars waiting to pass through a single-lane bridge. Each car can be represented as a positive integer indicating its weight. The bridge has a maximum weight limit and can only allow a certain amount of weight on it at any given time. Create a program that takes the array of car weights and the maximum weight limit of the bridge as input and returns the minimum number of trips required to get all cars across the bridge, assuming the cars are moved one at a time in the sequence they appear in the array.","solution":"def minimum_trips(arr, max_weight): Returns the minimum number of trips required to get all cars across the bridge. Parameters: arr (list): List of integers representing the weights of the cars. max_weight (int): Maximum weight limit of the bridge. Returns: int: Minimum number of trips required. trips = 0 current_weight = 0 for weight in arr: if current_weight + weight > max_weight: trips += 1 current_weight = 0 current_weight += weight if current_weight > 0: trips += 1 return trips"},{"question":"You are given a **0-indexed** integer array `arr` where each element represents the height of a building. The array is considered as buildings standing on a street from left to right. A building can see the sunset if there are no buildings of equal or greater height to its right. Return an array of indices of buildings that can see the sunset, sorted in ascending order.","solution":"def buildings_with_sunset_view(arr): Returns the indices of buildings that can see the sunset. A building can see the sunset if there are no buildings of equal or greater height to its right. :param arr: List of integers representing the heights of buildings. :return: List of indices of buildings that can see the sunset. result = [] max_height = float(\'-inf\') for i in range(len(arr)-1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return sorted(result)"},{"question":"Given a list of non-negative integers `nums`, you are asked to find the smallest missing positive integer. The function should return this integer, which is not present in the list, and it should have a time complexity of O(n) and use constant extra space. For example, given `nums = [3, 4, -1, 1]`, the function should return `2` because it is the smallest positive integer missing from the list.","solution":"def first_missing_positive(nums): Find the smallest missing positive integer in the list nums. Args: nums: List[int] - List of non-negative integers Return: int - The smallest missing positive integer n = len(nums) # Step 1: Mark numbers which are out of range (negative numbers and numbers that are 0 or > n) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the index as a hash to record the frequency of the number for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: The first index which has positive number, its index + 1 is the result for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"You are given an integer array `arr` of length `n` and an integer `targetSum`. Your task is to determine if there are three distinct elements in the array that sum up to `targetSum`. Return _a boolean value_ `True` _if such a triplet exists, otherwise return_ `False`. The function should have a time complexity better than O(n^3).","solution":"def three_sum(arr, targetSum): Determines if there are three distinct elements in the array `arr` that sum up to `targetSum`. Parameters: arr (list of int): The list of integers. targetSum (int): The target sum to find in the array. Returns: bool: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == targetSum: return True elif current_sum < targetSum: left += 1 else: right -= 1 return False"},{"question":"You are given a list of non-negative integers representing the heights of bars in a histogram. Each bar has a width of `1`. Write a function to find the area of the largest rectangle that can be formed within the bounds of the histogram. For example, given the list `[2,1,5,6,2,3]`, the largest rectangle has an area of `10` (obtained by choosing the height `2` and the width `5` corresponding to the subarray `[2,1,5,6,2]`). Write a function `largestRectangleArea(heights: List[int]) -> int:` that takes in a list `heights` and returns the maximum area of the rectangle.","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Function to find the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Write a Python class, `NonDecreasingArray`, that determines if a given array of integers could become non-decreasing by modifying at most one element. An array is considered non-decreasing if `nums[i] <= nums[i + 1]` for every `i` (0-indexed) such that (0 <= i <= n - 2). Implement the `NonDecreasingArray` class: * `boolean checkPossibility(int[] nums)` Returns true if the array can be made non-decreasing by modifying at most one element, otherwise returns false.","solution":"class NonDecreasingArray: @staticmethod def checkPossibility(nums): Determines if the array can be made non-decreasing by modifying at most one element. count = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: if count == 1: return False count += 1 if i - 2 < 0 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"You are given two integer arrays `nums1` and `nums2`, and an integer `k`. The arrays `nums1` and `nums2` are both sorted in non-decreasing order. Write a function to find the `k` smallest pairs `(u, v)` where `u` is an element from `nums1` and `v` is an element from `nums2`. Implement the `Solution` class: * `List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k)` - This function should return a list of `k` smallest pairs `(u, v)` such that `u` is from `nums1` and `v` is from `nums2`. The pairs should be returned in ascending order based on their sum `u + v`. # Example: ``` Input: nums1 = [1,2], nums2 = [3,4], k = 3 Output: [[1,3],[1,4],[2,3]] Explanation: The first 3 pairs with the smallest sums are (1,3), (1,4), and (2,3). ```","solution":"import heapq def k_smallest_pairs(nums1, nums2, k): This function returns a list of k smallest pairs (u, v) where u is from nums1 and v is from nums2. if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(k, len(nums1))): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while k > 0 and min_heap: sum_uv, i, j = heapq.heappop(min_heap) result.append([nums1[i], nums2[j]]) k -= 1 if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) return result"},{"question":"Given a list of daily temperatures `temperatures`, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead. Implement the `DailyTemperatures` class: * `int[] dailyTemperatures(int[] temperatures)` returns an array where the value at each index represents the number of days until a warmer temperature, or `0` if no such day exists.","solution":"from typing import List class DailyTemperatures: def dailyTemperatures(self, temperatures: List[int]) -> List[int]: Given a list of daily temperatures, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. answer = [0] * len(temperatures) stack = [] # stores indices of the temperatures list for i, current_temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < current_temp: index = stack.pop() answer[index] = i - index stack.append(i) return answer"},{"question":"You are working with a list of integers called `nums`, and you need to implement a function that finds the **length of the longest subsequence** of consecutive elements in `nums`. Note that the consecutive elements may appear in any order within the original list. The function signature should be: ```python def longest_consecutive(nums: List[int]) -> int: ``` **Example:** ```python longest_consecutive([100, 4, 200, 1, 3, 2]) # returns 4 because the longest consecutive sequence is [1, 2, 3, 4] ``` **Note:** - The solution should have a time complexity of O(n).","solution":"def longest_consecutive(nums): Return the length of the longest consecutive elements sequence. Args: nums (List[int]): List of integers. Returns: int: Length of the longest consecutive elements sequence. if not nums: return 0 # Create a set of nums to allow O(1) look-ups for existence tests num_set = set(nums) longest_streak = 0 for num in nums: # Check if it\'s the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # Incrementally check for the next elements in the sequence while current_num + 1 in num_set: current_num += 1 current_streak += 1 # Update the longest streak found longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given two strings `word1` and `word2`. You want to construct a new string `merge` using all the characters of `word1` and `word2` in a way that maintains their respective orders. Your task is to return the lexicographically smallest `merge` from all possible merges. For example, * If `word1 = \\"abc\\"` and `word2 = \\"def\\"`, the merge is `\\"abcdef\\"`. * If `word1 = \\"ab\\"` and `word2 = \\"zz\\"`, the merge is `\\"abzz\\"`. Implement the function `string mergeStrings(string word1, string word2)` that takes two strings and returns the lexicographically smallest merge.","solution":"def mergeStrings(word1, word2): Returns the lexicographically smallest merge of `word1` and `word2`. i, j = 0, 0 merge = [] while i < len(word1) and j < len(word2): if word1[i:] < word2[j:]: merge.append(word1[i]) i += 1 else: merge.append(word2[j]) j += 1 merge.extend(word1[i:]) merge.extend(word2[j:]) return \'\'.join(merge)"},{"question":"Given a list of `words` and a pattern, return _a list of all the words that match the given pattern_. Note that a word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the word. All words and patterns consist of lowercase English letters only. Each word or pattern will be between 1 and 20 characters long.","solution":"def find_and_replace_pattern(words, pattern): Finds and returns a list of all the words that match the given pattern. def matches(word, pattern): if len(word) != len(pattern): return False word_to_pattern, pattern_to_word = {}, {} for w, p in zip(word, pattern): if word_to_pattern.get(w) != pattern_to_word.get(p): return False word_to_pattern[w] = pattern_to_word[p] = p return True return [word for word in words if matches(word, pattern)]"},{"question":"Given a positive integer `num`, find the largest integer `k` such that the sum of the first `k` consecutive positive integers (beginning from 1) is less than or equal to `num`. Return the value of `k`. For instance, if `num` is 15, the largest `k` would be 5 because 1 + 2 + 3 + 4 + 5 = 15. If `num` is 10, the largest `k` would be 4 because 1 + 2 + 3 + 4 = 10.","solution":"def largest_k(num): Returns the largest integer k such that the sum of the first k consecutive positive integers is less than or equal to num. k = 0 total = 0 while total + (k + 1) <= num: k += 1 total += k return k"},{"question":"You are given an integer array `nums` of length `n`. Each element in `nums` represents the number of candies a child will initially receive. You need to distribute additional candies to the children such that the total number of candies each child has forms a non-decreasing sequence from left to right. Each time you give candies, you can only give a non-negative integer amount to one child. Return _the minimum number of additional candies needed_ to achieve the required non-decreasing order.","solution":"def min_additional_candies(nums): Given an array of integers, nums, representing the number of candies each child has initially, this function returns the minimum number of additional candies needed to make the sequence non-decreasing. additional_candies = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: additional_candies += nums[i - 1] - nums[i] nums[i] = nums[i - 1] return additional_candies"},{"question":"Given an integer array `events` representing the amount of people attending different events, you are responsible for managing the overall attendance in a way that keeps balance. The goal is to reorganize the `events` array so that the maximum difference in attendance between any two successive events is minimized. Return the minimized maximum difference. If there is no way to reorganize the events to achieve the goal, return `-1`.","solution":"def minimize_max_difference(events): Reorganizes the events array to minimize the maximum difference in attendance between any two successive events. :param events: List[int] :return: int if not events or len(events) < 2: return 0 events.sort() min_diff = float(\'inf\') for i in range(1, len(events)): min_diff = min(min_diff, events[i] - events[i - 1]) return min_diff"},{"question":"You are given a 2D grid represented by a list of strings, where each string consists of characters `\'0\'` or `\'1\'`. A cell with `1` represents land, and a cell with `0` represents water. Write a function that counts the number of **distinct islands** in the grid. Two islands are considered distinct if one island\'s shape does not match the shape of the other island, even after rotation or reflection. Return the _number of distinct islands_ in the grid.","solution":"def numDistinctIslands(grid): Counts the number of distinct islands in the grid. :param grid: List[List[str]], a 2D grid where \'1\' represents land and \'0\' represents water :return: int, number of distinct islands def dfs(x, y, grid, seen, island, origin): stack = [(x, y)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while stack: cx, cy = stack.pop() island.add((cx - origin[0], cy - origin[1])) # record relative position for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == \'1\' and (nx, ny) not in seen: seen.add((nx, ny)) stack.append((nx, ny)) seen = set() unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\' and (i, j) not in seen: island = set() seen.add((i, j)) dfs(i, j, grid, seen, island, (i, j)) if island: unique_islands.add(frozenset(island)) return len(unique_islands)"},{"question":"You are given a string `s` containing only lowercase letters. A \\"balanced\\" string is defined as a string where no letter appears more than once. You can remove one or more characters from `s` to obtain a new string. Your task is to return the maximum possible length of a \\"balanced\\" string that can be obtained from `s`.","solution":"def max_balanced_length(s): Returns the maximum possible length of a \\"balanced\\" string obtained from the input string `s` by removing one or more characters. # A balanced string contains no character more than once # Thus, the maximum length of a balanced string is the number of unique characters in `s` return len(set(s))"},{"question":"You are given two sorted integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively, and an integer `k`. Write a function that returns the `k`th smallest element in the combined and sorted array formed by merging `nums1` and `nums2`. The function should have an optimal run-time complexity. For example, given `nums1 = [1, 3, 4, 7]`, `nums2 = [2, 3, 5, 6]`, and `k = 5`, the result should be `4` since the combined sorted array is `[1, 2, 3, 3, 4, 5, 6, 7]` and the 5th smallest element is `4`.","solution":"def find_kth_element(nums1, nums2, k): Returns the k-th smallest element in the combined and sorted array formed by merging nums1 and nums2. def kth_smallest(a, b, k): if not a: return b[k-1] if not b: return a[k-1] mid_a, mid_b = len(a) // 2 , len(b) // 2 mid_val_a, mid_val_b = a[mid_a], b[mid_b] if mid_a + mid_b < k - 1: if mid_val_a > mid_val_b: return kth_smallest(a, b[mid_b + 1:], k - mid_b - 1) else: return kth_smallest(a[mid_a + 1:], b, k - mid_a - 1) else: if mid_val_a > mid_val_b: return kth_smallest(a[:mid_a], b, k) else: return kth_smallest(a, b[:mid_b], k) return kth_smallest(nums1, nums2, k)"},{"question":"Given a string `s`, implement a function to check if it can be rearranged to form a palindrome. For example, for the string \\"civic\\", the output should be true, while for the string \\"hello\\", it should be false. Write an algorithm that efficiently determines whether the input string can be rearranged to form a palindrome.","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. :param s: input string :return: True if the input string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string. char_count = Counter(s) # To form a palindrome, at most one character can have an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if there is at most one odd character count. return odd_count <= 1"},{"question":"**[Question 4]:** Given an integer array `arr`, return the _length of the longest subarray that contains only even numbers_. Subarrays must be contiguous. For example, given the input `[1, 2, 4, 6, 3, 8, 10]`, the longest subarray of even numbers is `[2, 4, 6]` with a length of `3`.","solution":"def longest_even_subarray_length(arr): Returns the length of the longest subarray containing only even numbers. Parameters: arr (list): List of integers. Returns: int: Length of the longest subarray with only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"Given an array of integers `nums`, return _the length of the longest subsequence that is a valid Fibonacci-like sequence_. A **Fibonacci-like sequence** is defined as a sequence that starts with two integers, and each subsequent integer is the sum of the previous two. Note that the sequence must contain at least three elements. If no such sequence exists, return `0`.","solution":"def len_longest_fib_subseq(nums): if len(nums) < 3: return 0 index = {x: i for i, x in enumerate(nums)} longest = {} max_len = 0 for k in range(len(nums)): for j in range(k): i = index.get(nums[k] - nums[j], None) if i is not None and i < j: seq_len = longest.get((i, j), 2) + 1 longest[j, k] = seq_len max_len = max(max_len, seq_len) return max_len if max_len >= 3 else 0"},{"question":"You are developing a simulation for an ecological system. In this system, various animals interact, and these interactions can be represented as an undirected graph where nodes represent animals and edges represent interactions. You are given an integer `n` representing the number of animals and a list of `edges` where `edges[i]` = [a, b] indicates an interaction between animals `a` and `b`. You need to determine if it\'s possible to split the animals into two distinct groups such that no two animals within the same group interact with each other. Return `true` if such a division is possible and `false` otherwise.","solution":"def possible_bipartition(n, edges): from collections import defaultdict, deque graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) color = {} for node in range(1, n + 1): # assuming animals are labeled from 1 to n if node not in color: queue = deque([node]) color[node] = 0 # starting color while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in color: color[neighbor] = 1 - color[current] # flip color queue.append(neighbor) elif color[neighbor] == color[current]: return False return True"},{"question":"You are given an undirected graph represented as an adjacency list. Each list element `graph[i]` represents the neighbors of node `i`. A connected component in an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. Implement a function `connectedComponents(graph)` that returns the number of connected components in the given graph. You can assume that the nodes are labeled from `0` to `n-1` where `n` is the number of nodes in the graph. For example, given the following graph: ``` graph = [ [1, 2], [0, 2], [0, 1], [4], [3], ] ``` The graph has two connected components, so the function should return `2`. In contrast, given: ``` graph = [ [1], [0], [3], [2] ] ``` The graph has four connected components, so the function should return `4`. Function signature: ``` def connectedComponents(graph: List[List[int]]) -> int: ```","solution":"from typing import List def connectedComponents(graph: List[List[int]]) -> int: def dfs(node, visited): for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) dfs(neighbor, visited) visited = set() count = 0 for node in range(len(graph)): if node not in visited: visited.add(node) dfs(node, visited) count += 1 return count"},{"question":"You are given a `0-indexed` integer array `nums` containing `n` distinct positive integers. The array represents a permutation of the first `n` positive integers. A permutation is called an **ideal permutation** if for every index `i`, there are no elements `nums[j]` for which `j > i + 1` and `nums[j] < nums[i]`. Return a boolean value indicating whether the given permutation is an ideal permutation or not.","solution":"def isIdealPermutation(nums): Returns True if the given permutation is an ideal permutation. n = len(nums) for i in range(n): if abs(nums[i] - i) > 1: return False return True"},{"question":"You are given two arrays: `heights` and `tastes`, both of which are **0-indexed** and have the same length `n`. The `heights` array represents the heights of `n` plants in a garden, and the `tastes` array represents the taste factor of each respective plant. You want to select a contiguous subarray of plants such that the sum of their taste factors is maximized, but you must ensure that the height of each plant in the selected subarray is strictly increasing from left to right. Return _the maximum sum of taste factors for such a subarray_. If no such subarray exists, return 0.","solution":"def max_taste_subarray(heights, tastes): n = len(heights) if n == 0: return 0 # Initialize a dp array where dp[i] will be the maximum sum of taste factors # of a strictly increasing subarray that ends at index i. dp = [0] * n # Start by setting the dp value for the first plant for i in range(n): dp[i] = tastes[i] max_taste = 0 # Fill dp array using the given conditions for i in range(n): for j in range(i): if heights[j] < heights[i]: # Only consider j if height[j] is less than height[i] dp[i] = max(dp[i], dp[j] + tastes[i]) max_taste = max(max_taste, dp[i]) return max_taste"},{"question":"Given two integers `dividend` and `divisor`, divide the `dividend` by the `divisor` without using multiplication, division, and modulo operators. Return the quotient after dividing the `dividend` by the `divisor`. The integer division should truncate toward zero, which means losing its fractional part. For example, `7` divided by `-3` equals `-2`. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: `[−2^31, 2^31 − 1]`. Ensure that if the final result exceeds this range, it is capped to the corresponding boundary value.","solution":"def divide(dividend, divisor): Divide the dividend by the divisor without using multiplication, division, and modulo operators. Aim to truncate the integer division toward zero and cap the result within 32-bit signed integer range. MAX_INT = 2**31 - 1 MIN_INT = -2**31 # Handle edge case where division could exceed 32-bit integer boundary if dividend == MIN_INT and divisor == -1: return MAX_INT # Determine the sign of the result negative = (dividend < 0) != (divisor < 0) # Work with positive values dividend, divisor = abs(dividend), abs(divisor) quotient = 0 # Subtract the divisor from the dividend until the dividend is less than the divisor while dividend >= divisor: temp_divisor, num_divisors = divisor, 1 # Efficiently reduce the dividend by subtracting large multiples of the divisor while dividend >= temp_divisor: dividend -= temp_divisor quotient += num_divisors # Increase the divisor power to subtract more efficiently num_divisors <<= 1 temp_divisor <<= 1 return -quotient if negative else quotient"},{"question":"Given a binary matrix where `0` represents water and `1` represents land, your task is to find the largest island in the matrix. An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the matrix are surrounded by water. Implement the function `largestIsland(matrix)` that takes a 2D integer array `matrix` as input and returns the area of the largest island. **Notes:** - The size of the matrix is at most 50x50. - The area of an island is measured by the number of 1’s in the island.","solution":"def largestIsland(matrix): def dfs(matrix, i, j, visited): if (i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0 or (i, j) in visited): return 0 visited.add((i, j)) area = 1 area += dfs(matrix, i + 1, j, visited) area += dfs(matrix, i - 1, j, visited) area += dfs(matrix, i, j + 1, visited) area += dfs(matrix, i, j - 1, visited) return area max_area = 0 visited = set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and (i, j) not in visited: max_area = max(max_area, dfs(matrix, i, j, visited)) return max_area"},{"question":"Given an array of integers `arr` and an integer `t`, find all unique quadruplets `[arr[a], arr[b], arr[c], arr[d]]` such that: - `0 <= a, b, c, d < arr.length` - `a, b, c, and d` are distinct. - `arr[a] + arr[b] + arr[c] + arr[d] == t` Return the list of all quadruplets in any order. The solution set must not contain duplicate quadruplets.","solution":"def four_sum(arr, t): arr.sort() quadruplets = [] n = len(arr) for i in range(n - 3): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicates for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue # Skip duplicates left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == t: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicates while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 elif total < t: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given a string `s` containing only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You are allowed to perform the following operation any number of times: choose any two adjacent characters and replace them with the third character. For example, replace `\'ab\'` with `\'c\'`, replace `\'bc\'` with `\'a\'`, or replace `\'ca\'` with `\'b\'`. Determine whether it is possible to turn the string `s` into a single character string of any type. Return `true` if it is possible, otherwise return `false`.","solution":"def is_possible_to_reduce(s): Checks if it is possible to reduce the string s to a single character by repeatedly replacing any two adjacent characters with the third character. # The length of the input string s n = len(s) # If the length of the string is less than 2, it is already a single character or empty if n < 2: return True # If the length of the string is exactly 2, check whether it\'s already reducible in one step if n == 2: return s[0] != s[1] # For string length greater than 2, check if there are at least two distinct characters if len(set(s)) < 3: return False return True"},{"question":"You are given a 2D grid of integers `grid` where each cell represents the elevation at that point. The Pacific ocean touches the left and top edges of the grid, and the Atlantic ocean touches the right and bottom edges. Water can flow from any cell to another one with equal or lower elevation, and it can only flow up, down, left, or right. Determine _the list of coordinates where water can flow to both the Pacific and Atlantic oceans._ The coordinates should be returned as a list of lists.","solution":"def pacific_atlantic(grid): if not grid or not grid[0]: return [] rows, cols = len(grid), len(grid[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, reachable): reachable[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not reachable[nr][nc] and grid[nr][nc] >= grid[r][c]: dfs(nr, nc, reachable) for i in range(rows): dfs(i, 0, pacific_reachable) dfs(i, cols - 1, atlantic_reachable) for j in range(cols): dfs(0, j, pacific_reachable) dfs(rows - 1, j, atlantic_reachable) result = [] for r in range(rows): for c in range(cols): if pacific_reachable[r][c] and atlantic_reachable[r][c]: result.append([r, c]) return result"},{"question":"Given a string `s` and a list of strings `words`, determine the number of times any word from `words` appears as a substring in `s`. Each word in `words` must be treated independently, and overlaps between substrings should be considered. Return the total count of such substrings present in `s`.","solution":"def count_substrings(s, words): Returns the total number of times any word from `words` appears as a substring in `s`. Parameters: s (str): The string to search within. words (list): A list of strings to search for within `s`. Returns: int: The count of substrings found in `s`. count = 0 for word in words: count += s.count(word) return count"},{"question":"Given a linked list, return _the node where the cycle begins_. If there is no cycle, return `null`. Note that a cycle in a linked list is a sequence of nodes starting from any node, where the next pointer eventually points back to one of the previous nodes within the sequence, thereby forming a loop.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the cycle in the linked list and returns the node where the cycle begins. Returns None if there is no cycle. if not head or not head.next: return None slow, fast = head, head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if not has_cycle: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given two strings `s1` and `s2`, each containing only lowercase English letters. Your task is to determine if `s2` can be formed by rearranging the characters of a substring of `s1`. In other words, check if s1 contains a substring that is an anagram of s2, where an anagram is formed by rearranging the characters in a string to form another string. Return `true` if it is possible, otherwise return `false`.","solution":"def check_inclusion(s1, s2): Determines if s2 can be formed by rearranging the characters of a substring of s1. :param s1: The main string in which we are looking for a permutation of s2\'s characters. :param s2: The string whose permutation we are looking for in s1. :return: Boolean value indicating if a permutation of s2 is found in s1. from collections import Counter len_s1, len_s2 = len(s1), len(s2) if len_s2 > len_s1: return False s2_count = Counter(s2) window_count = Counter(s1[:len_s2]) if window_count == s2_count: return True for i in range(len_s2, len_s1): window_count[s1[i]] += 1 window_count[s1[i - len_s2]] -= 1 if window_count[s1[i - len_s2]] == 0: del window_count[s1[i - len_s2]] if window_count == s2_count: return True return False"},{"question":"You are given a `k x n` matrix `matrix` where each row is a string of lowercase English letters in alphabetical order. You are also given an integer `n`, which is the length of each string. You need to merge these rows into a single string of length `k * n` that is also in alphabetical order. Return the lexicographically smallest string that can be obtained by merging these rows. Note: You can choose any character from any row until all characters are used up.","solution":"import heapq def merge_sorted_strings(matrix, n): # Min heap to keep track of the smallest elements min_heap = [] # Initialize the heap with the first element of each row for row in matrix: heapq.heappush(min_heap, (row[0], 0, row)) result = [] while min_heap: # Get the smallest element from the heap smallest, idx, string = heapq.heappop(min_heap) result.append(smallest) # If there are more elements in the same row, push the next element into the heap if idx + 1 < n: heapq.heappush(min_heap, (string[idx + 1], idx + 1, string)) # Return the result as a single string return \'\'.join(result)"},{"question":"You are given two arrays `nums` consisting of `n` positive integers and `queries` consisting of `m` pairs. Each pair represents a range `[L, R]` (0-indexed) in the `nums` array, and your task is to find the **maximum value** within that range and the **number of times** it appears in the given range. Implement the function `rangeMaxCounts(nums, queries)` that returns an array of pairs, where each pair contains the maximum value and its frequency for the corresponding range in `queries`.","solution":"def rangeMaxCounts(nums, queries): For each query range [L, R], return the maximum value and the number of times it appears in the range. results = [] for L, R in queries: max_val = max(nums[L:R+1]) count = nums[L:R+1].count(max_val) results.append((max_val, count)) return results"},{"question":"Given a string `s` consisting of only characters `\'G\'`, `\'A\'`, and `\'C\'`, you need to find the shortest substring that contains at least one occurrence of each character. If such a substring does not exist, return an empty string. For example: - Input: `s = \\"GACGACG\\"` Output: `\\"GAC\\"` - Input: `s = \\"CGA\\"` Output: `\\"CGA\\"` Implement a function `string shortest_substring(String s)` that returns the shortest substring containing at least one `\'G\'`, one `\'A\'`, and one `\'C\'`.","solution":"def shortest_substring(s): Returns the shortest substring containing at least one \'G\', one \'A\', and one \'C\'. If no such substring exists, returns an empty string. if not s or len(set(s)) < 3: return \\"\\" required_chars = {\'G\', \'A\', \'C\'} min_length = float(\'inf\') shortest_sub = \\"\\" left = 0 char_count = {\'G\': 0, \'A\': 0, \'C\': 0} for right, char in enumerate(s): if char in char_count: char_count[char] += 1 while all(char_count[c] > 0 for c in required_chars): current_length = right - left + 1 if current_length < min_length: min_length = current_length shortest_sub = s[left:right+1] if s[left] in char_count: char_count[s[left]] -= 1 left += 1 return shortest_sub"},{"question":"Given a string `s` consisting of only the characters \'a\', \'b\', and \'c\', find the smallest substring that contains at least one of each character. If such a substring does not exist, return an empty string.","solution":"def smallest_substring_with_abc(s): Finds the smallest substring of `s` containing at least one \'a\', one \'b\', and one \'c\'. If no such substring exists, return an empty string. n = len(s) if n < 3: return \\"\\" # Using a sliding window approach left, right = 0, 0 min_len = float(\\"inf\\") result = \\"\\" count = {\'a\': 0, \'b\': 0, \'c\': 0} while right < n: if s[right] in count: count[s[right]] += 1 while all(count[char] > 0 for char in \'abc\'): if right - left + 1 < min_len: min_len = right - left + 1 result = s[left:right+1] if s[left] in count: count[s[left]] -= 1 left += 1 right += 1 return result"},{"question":"You are given an array of integers `arr` and a target integer `target_sum`. Your task is to determine if there are **two distinct indices** `i` and `j` in the array such that `arr[i] + arr[j] = target_sum`. Return `true` if such indices exist, and `false` otherwise. Write a function `boolean hasPairWithSum(int[] arr, int target_sum)` that implements this functionality. The function should aim for an efficient solution.","solution":"def has_pair_with_sum(arr, target_sum): Determine if there are two distinct indices i and j in the array arr such that arr[i] + arr[j] == target_sum. seen = set() for num in arr: if target_sum - num in seen: return True seen.add(num) return False"},{"question":"You are given an array of integers `nums` representing a sequence of numbers. You can perform the following operation on the array as many times as you want: choose a non-empty subarray of `nums` and multiply every element of the subarray by `-1`. Return the maximum possible sum of the array you can achieve after performing any number of operations.","solution":"def max_array_sum(nums): Returns the maximum possible sum of the array after performing any number of flipping operations. max_sum = 0 for num in nums: max_sum += abs(num) return max_sum"},{"question":"You are given a list of non-negative integers `nums` representing the amount of rainwater stored in a series of adjacent bars where the width of each bar is 1. Write a function to compute the total amount of rainwater that could be trapped between the bars after it rains. The height of each bar is given by the value in the list `nums`.","solution":"def trap_rainwater(nums): Calculates the total amount of rainwater that can be trapped between the bars represented by the list nums. :param nums: List[int], list of non-negative integers representing bar heights :return: int total amount of trapped rainwater if not nums: return 0 n = len(nums) left_max, right_max = [0] * n, [0] * n # Fill left_max array left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], nums[i]) # Fill right_max array right_max[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], nums[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - nums[i] return trapped_water"},{"question":"You are given a string `s` containing only lowercase English alphabets and a 2D integer array `operations` where `operations[i] = [index, char]` indicates that the character at position `index` in the string `s` should be replaced with `char`. Changes specified in the `operations` array are applied in sequence. You need to find the resulting string after performing all the operations in the given order. If a particular index is modified more than once, the last modification should be used. Return the final modified string.","solution":"def modify_string(s, operations): Returns the modified string after performing all operations. Each operation is a tuple [index, char] which replaces the character at the given index with the provided char. :param s: str - input string to be modified :param operations: list[list[int, str]] - list of operations to be performed on the string :return: str - modified string after applying all operations s_list = list(s) for index, char in operations: s_list[index] = char return \\"\\".join(s_list)"},{"question":"Given an integer `n`, return any array `nums `of length `n` such that each `nums[i]` is either `-1` or `1` and the sum of all the elements in the array is `0`. If there are multiple valid arrays, you can return any of them. If no such array exists, return an empty array.","solution":"def generate_zero_sum_array(n): Given an integer n, return an array of length n such that each element is either -1 or 1 and the sum of all the elements is 0. If no such array exists, return an empty array. if n % 2 != 0: # If n is odd, there\'s no way to split numbers into equal positive and negative values return [] # Create an array of length n with the first half being 1 and the second half being -1 half_n = n // 2 return [1] * half_n + [-1] * half_n"},{"question":"You are given a string `s`, representing a file path in a Unix-style file system. Return the simplified canonical path. The canonical path should have the following format: - The path starts with a single slash `\'/\'`. - Any two directory names are separated by a single slash `\'/\'`. - The path does not end with a trailing `\'/\'`. - The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `\'.\'` or double period `\'..\'`). Make sure your solution does not use any in-built functions that simplify the path for you.","solution":"def simplify_path(s): Simplify the given Unix-style file path. Args: s (str): The input path string. Returns: str: The simplified canonical path. parts = s.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Given an integer array `nums`, find the length of the longest contiguous subarray with an equal number of `0`s and `1`s. Return the length of this subarray. Implement a function `longestEqualSubarray(nums)` to solve this problem. For example: - `nums = [0,1,0]`, the function should return `2` because the longest contiguous subarray with an equal number of `0`s and `1`s is `[0, 1]` which has length `2`. - `nums = [0,1,0,1,0,1]`, the function should return `6` because the entire array contains an equal number of `0`s and `1`s.","solution":"def longestEqualSubarray(nums): Returns the length of the longest contiguous subarray with equal number of 0s and 1s. count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You are given an array of integers `nums` sorted in non-decreasing order, and an integer `target`. You want to find the closest element to `target` in `nums`. If there are two elements equally close to `target`, return the smaller element. Write an algorithm that runs in O(log n) time complexity to find the closest element. Return the closest element to `target`.","solution":"def closest_element(nums, target): Returns the closest element to target in nums. If there are two elements equally close to target, return the smaller element. left, right = 0, len(nums) - 1 closest = nums[0] while left <= right: mid = (left + right) // 2 # Update closest if current mid is closer to target if abs(nums[mid] - target) < abs(closest - target) or (abs(nums[mid] - target) == abs(closest - target) and nums[mid] < closest): closest = nums[mid] if nums[mid] < target: left = mid + 1 elif nums[mid] > target: right = mid - 1 else: return nums[mid] return closest"},{"question":"Given a list of words `words` and a word `target`, return the length of the largest word in the list that can be constructed using the letters of the `target` word exactly once. Each letter in the `target` word can only be used once per word construction. If no words can be constructed, return `-1`. You may assume the list of words does not contain duplicates.","solution":"def can_construct(word, target): Helper function to check if a word can be constructed from the letters of the target word. from collections import Counter word_count = Counter(word) target_count = Counter(target) for char in word_count: if word_count[char] > target_count.get(char, 0): return False return True def largest_constructible_length(words, target): Returns the length of the largest word in the list that can be constructed using the letters of the target word exactly once. max_length = -1 for word in words: if can_construct(word, target): max_length = max(max_length, len(word)) return max_length"},{"question":"Given a list of `n` integers representing the height of consecutive buildings, determine the maximum area of a rectangular pool that can be constructed between two buildings, where the width of the pool is determined by the horizontal distance between the buildings and the height by the shorter of the two buildings\' heights. Return the maximum possible pool area.","solution":"def max_pool_area(heights): Returns the maximum area of a rectangular pool that can be constructed between two buildings. :param heights: List of integers representing the height of consecutive buildings :return: Integer representing the maximum pool area if not heights: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left current_height = min(heights[left], heights[right]) current_area = width * current_height max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a **0-indexed** array `nums` of integers. The array is said to be \\"rotationally sorted\\" if it can be transformed into a non-decreasing order sequence by performing a **cyclic rotation**. A cyclic rotation in this context means moving the elements of the array from the end to the front. For example, `[3, 4, 5, 1, 2]` is a rotationally sorted array because rotating the last two elements to the front results in `[1, 2, 3, 4, 5]`, which is in non-decreasing order. Return `true` if the array is rotationally sorted, or `false` otherwise. Note: The input array has at least one element and at most 10^5 elements.","solution":"def is_rotationally_sorted(nums): Check if the array is rotationally sorted. Parameters: nums (list): A list of integers. Returns: bool: True if the array can be rotated to form a non-decreasing sequence, False otherwise. n = len(nums) if n == 1: return True drop_count = 0 for i in range(1, n): if nums[i] < nums[i - 1]: drop_count += 1 if drop_count > 1: return False if drop_count == 0: return True return nums[0] >= nums[-1]"},{"question":"A string is said to have **balanced brackets** if for every opening bracket (`\'(\'`, `\'{\'`, `\'[\'`) there is a corresponding closing bracket (`\')\'`, `\'}\'`, `\']\'`) of the same type, and the brackets are properly nested. *For example, the strings `\\"(a + b) * [c - d]\\"` and `\\"{[a + b] * c}\\"` are balanced, whereas the strings `\\"((a + b)\\"` and `\\"a + b] * c{\\"` are not. Given a string `s`, return `true` if the string has balanced brackets, otherwise return `false`.","solution":"def is_balanced(s): Returns True if the string s has balanced brackets, otherwise returns False. stack = [] bracket_map = { \')\': \'(\', \'}\': \'{\', \']\': \'[\' } for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"Write a function that takes a string `s` and returns the longest palindromic substring in `s`. A **palindrome** is a sequence of characters that reads the same backward as forward. The function should have a time complexity better than O(n^3). Correct Answer: To solve the problem of finding the longest palindromic substring, we can use the expand-around-center technique. This approach guarantees a time complexity of O(n^2), which is efficient enough for our needs, avoiding the O(n^3) complexity of the brute force solution. Here\'s an implementation in Python: ```python def longest_palindromic_substring(s): if not s: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest # Test cases print(longest_palindromic_substring(\\"babad\\")) # Output: \\"bab\\" or \\"aba\\" print(longest_palindromic_substring(\\"cbbd\\")) # Output: \\"bb\\" print(longest_palindromic_substring(\\"a\\")) # Output: \\"a\\" print(longest_palindromic_substring(\\"ac\\")) # Output: \\"a\\" or \\"c\\" ``` This solution works as follows: 1. It includes a helper function `expand_around_center` that takes a string `s` and two indices `left` and `right`. It expands outwards from the center as long as the characters on both sides are equal, and returns the longest palindromic substring found. 2. The main function iterates through each index in the string, checking for both odd- and even-length palindromes centered at each index. 3. It updates the longest palindromic substring found so far and finally returns the result.","solution":"def longest_palindromic_substring(s): if not s: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"You have an array of integers `arr` of length `n`. You need to determine if there exists a pair of indices `(i, j)` such that `i != j` and `arr[i]` + `arr[j]` equals a given target number `k`. Return _a boolean value_ `true`_ if such a pair exists_ and `false`_ otherwise._","solution":"def has_pair_with_sum(arr, k): Returns True if there exists a pair of indices (i, j) such that i != j and arr[i] + arr[j] equals the target number k. Otherwise, returns False. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"Given an array of integers `nums`, return _the number of pairs `(i, j)` where `0 <= i < j < len(nums)` and `nums[i]` xor `nums[j]` is equal to a given integer `k`. Two integers `a` and `b` are considered a pair if: * `0 <= i < j < len(nums)` * `a = nums[i]`, `b = nums[j]` * `a xor b = k` For example, given `nums = [1, 4, 2, 7]` and `k = 5`, the valid pairs are `(0, 3)` and `(1, 2)`.","solution":"def count_pairs_with_xor(nums, k): Returns the number of pairs (i, j) where 0 <= i < j < len(nums) and nums[i] xor nums[j] is equal to the given integer k. count = 0 n = len(nums) # Iterate through all pairs (i, j) and calculate nums[i] xor nums[j] for i in range(n): for j in range(i + 1, n): if nums[i] ^ nums[j] == k: count += 1 return count"},{"question":"Develop a function that takes a positive integer n and returns a list of all possible unique permutations of its digits. Each permutation is to be considered as a unique integer with leading zeros permitted where applicable. For example, given n = 123, the function should return all permutations of 123, 132, 213, 231, 312, and 321. Ensure that the returned list does not contain any duplicate permutations.","solution":"from itertools import permutations def unique_permutations(n): Returns a list of all unique permutations of the digits of the given integer n. :param n: A positive integer :return: A list of unique permutations of the digits of n as integers digits = str(n) perms = set(int(\'\'.join(p)) for p in permutations(digits)) return sorted(perms)"},{"question":"You are given an integer matrix `grid` where each element represents the elevation at that point. Two elements are considered **connected** if they are adjacent horizontally or vertically and have the same elevation. Return _the total number of distinct connected components_ in the grid. A **connected component** is a maximal set of connected elements.","solution":"def num_connected_components(grid): Returns the total number of distinct connected components in the grid. Two elements are considered connected if they are adjacent horizontally or vertically and have the same elevation. if not grid: return 0 def dfs(x, y, val): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != val: return grid[x][y] = None # Mark as visited dfs(x + 1, y, val) dfs(x - 1, y, val) dfs(x, y + 1, val) dfs(x, y - 1, val) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] is not None: count += 1 dfs(i, j, grid[i][j]) return count"},{"question":"Given a string of lowercase English letters `s`, you are allowed to turn every `k` consecutive characters into uppercase. Return _the lexicographically largest string you can obtain by applying the operation any number of times (including zero)_.","solution":"def largest_string(s, k): Returns the lexicographically largest string by turning every k consecutive characters into uppercase any number of times. n = len(s) s = list(s) # Convert string to a list of characters for mutability # We can turn every character to upper case to ensure the largest lexicographical order for i in range(n): s[i] = s[i].upper() return \'\'.join(s)"},{"question":"You are given an array of integers `arr` and an integer `k`. Define a **k-complement** of an integer `x` as the number `y` such that `x + y = k`. Write a function to find the number of unique pairs `(x, y)` in the array that satisfy the k-complement requirement. Each pair should be counted only once, even if there are multiple occurrences of each number in the array. Return the count of such unique pairs.","solution":"def count_k_complement_pairs(arr, k): Returns the number of unique pairs (x, y) in the array that satisfy x + y = k. num_count = {} unique_pairs = set() for num in arr: complement = k - num if complement in num_count: # Ensure each pair is counted only once unique_pairs.add(tuple(sorted((num, complement)))) num_count[num] = num_count.get(num, 0) + 1 return len(unique_pairs)"},{"question":"You are given a text composed of lowercase and uppercase letters in a string `s`. You need to calculate the \\"weight\\" of this string. The weight of a string is defined as the sum of weights of all distinct characters multiplied by their respective frequencies. The weight of a character is the position of the character in the alphabet (`\'a\'` is 1, `\'b\'` is 2, ..., `\'z\'` is 26, `\'A\'` is 1, `\'B\'` is 2, ..., `\'Z\'` is 26). Write a function that calculates this weight given the string `s`. For example, for the input string `\\"abCca\\"`, the output should be: * Character `\'a\'` appears 2 times and its weight is `1`. Hence, contribution is `2 * 1 = 2`. * Character `\'b\'` appears 1 time and its weight is `2`. Hence, contribution is `1 * 2 = 2`. * Character `\'C\'` appears 1 time and its weight is `3`. Hence, contribution is `1 * 3 = 3`. * Character `\'c\'` appears 1 time and its weight is `3`. Hence, contribution is `1 * 3 = 3`. Therefore, the total weight is `2 + 2 + 3 + 3 = 10`. Write a function `calculateWeight(s: str) -> int` that takes in a string `s` and returns the total weight of the string.","solution":"def calculateWeight(s): Calculate the weight of the string `s`. Args: s (str): The input string containing lowercase and uppercase letters. Returns: int: The total weight of the string. # Create a dictionary to keep track of the frequency of each character freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 total_weight = 0 for char, count in freq.items(): # Calculate the weight of the character (both uppercase and lowercase are treated equally) weight = ord(char.lower()) - ord(\'a\') + 1 # Multiply the weight by the frequency total_weight += count * weight return total_weight"},{"question":"Given a **0-indexed** integer array `arr` of length `n`, you can perform a move consisting of choosing two distinct indices `i` and `j` where `0 <= i, j < n` and swapping `arr[i]` and `arr[j]`. Return _the minimum number of moves required to make the array non-decreasing_. If it is already non-decreasing, return `0`.","solution":"def min_moves_to_make_non_decreasing(arr): Returns the minimum number of moves required to make the array non-decreasing. If it is already non-decreasing, return 0. n = len(arr) sorted_arr = sorted(arr) # Count the number of elements out of place out_of_place = sum(1 for i in range(n) if arr[i] != sorted_arr[i]) # Each move can correct at most two out-of-place elements return out_of_place // 2"},{"question":"You are given an array `buildings` where `buildings[i] = [lefti, righti, heighti]` represents a building with a rectangular structure at the skyline. The `lefti` and `righti` represent the starting and ending points of the building on the x-axis, and `heighti` represents the height of the building. Write a function that returns the skyline formed by these buildings as a list of \\"key points\\" sorted in ascending order. A key point is represented as `[x, height]` and signifies a change in height at the x-coordinate `x`.","solution":"import heapq def getSkyline(buildings): Returns the skyline formed by the buildings as a list of key points. # List to contain all the events events = [] # Split each building into two events: start and end for left, right, height in buildings: events.append((left, -height, right)) # Start event events.append((right, 0, 0)) # End event # Sort events first by x coordinate, then by height (start events with higher heights first) events.sort() # Result list and a max heap result = [[0, 0]] max_heap = [(0, float(\'inf\'))] # To store (-height, end) for x, neg_height, end in events: # While the current x has moved past the end of the tallest building in the heap while max_heap[0][1] <= x: heapq.heappop(max_heap) # If this is a start event, add the building to the heap if neg_height != 0: heapq.heappush(max_heap, (neg_height, end)) # If the height at the current x has changed, add a key point to the result if result[-1][1] != -max_heap[0][0]: result.append([x, -max_heap[0][0]]) return result[1:] # Excluding the initial ground level key point"},{"question":"You are given an array of integers `numbers`, where each element represents the count of items you have to distribute. Your task is to find the smallest possible value of the largest number of items in any group after distributing all the items into exactly `k` groups such that each group has at least one item. Return _an integer_ `answer` _which is the smallest possible value of the largest number of items in any group._","solution":"def min_max_items_group(numbers, k): Returns the smallest possible value of the largest number of items in any group after distributing the given items into exactly k groups. def is_feasible(limit): groups = 1 current_sum = 0 for num in numbers: if current_sum + num > limit: groups += 1 current_sum = num if groups > k: return False else: current_sum += num return True left, right = max(numbers), sum(numbers) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting of \'(\' and \')\' representing a balanced parentheses sequence. Your task is to calculate and return the maximum depth of nested parentheses in the given sequence. The depth of the sequence is defined as follows: - `()` has depth 1. - `((()))` has depth 3. - `(())` has depth 2. Ensure your solution works within linear time complexity.","solution":"def max_depth(s): Calculate the maximum depth of nested parentheses in the given sequence. Parameters: s (str): A string of \'(\' and \')\' representing a balanced parentheses sequence. Returns: int: The maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"A **magic square** is a `n x n` grid filled with distinct integers such that the sum of the integers in each row, each column, and both main diagonals are the same. Given an `n x n` grid containing distinct integers, return `true` if it is a magic square, otherwise return `false`. Test cases are generated such that `n` is always a positive integer.","solution":"def is_magic_square(grid): Returns True if the given n x n grid is a magic square, otherwise False. n = len(grid) # Calculate the sum of the first row magic_sum = sum(grid[0]) # Check rows for row in grid: if sum(row) != magic_sum: return False # Check columns for col in range(n): col_sum = sum(grid[row][col] for row in range(n)) if col_sum != magic_sum: return False # Check main diagonal diag1_sum = sum(grid[i][i] for i in range(n)) if diag1_sum != magic_sum: return False # Check secondary diagonal diag2_sum = sum(grid[i][n - 1 - i] for i in range(n)) if diag2_sum != magic_sum: return False return True"},{"question":"Given a non-empty array of integers `nums`, where each element appears twice except for one. Find that single one. Implement a function that takes an array of integers `nums` and returns the single integer that appears only once. **Note:** Your algorithm should have a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Given a non-empty array of integers nums, where each element appears twice except for one, find that single one. :param nums: List[int] :return: int result = 0 for num in nums: result ^= num return result"},{"question":"You are given a grid of size `m x n` filled with non-negative integers. You can start from any cell in the first row and move to any cell in the last row by choosing the cell in a way such that you minimize the sum of all the cells you traverse. From a cell in the current row, you can move to the cell directly below it or diagonally to the left or right cell in the next row. Complete the function `minFallingPathSum(grid: List[List[int]]) -> int` that returns the minimum path sum.","solution":"from typing import List def minFallingPathSum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Traverse from the second last row to the top for row in range(m-2, -1, -1): for col in range(n): # Get the minimum sum from the cells below this cell down = grid[row+1][col] if col < n else float(\'inf\') down_left = grid[row+1][col-1] if col-1 >= 0 else float(\'inf\') down_right = grid[row+1][col+1] if col+1 < n else float(\'inf\') grid[row][col] += min(down, down_left, down_right) # Get the minimum value from the top row return min(grid[0])"},{"question":"In a faraway kingdom, there are `n` castles located along a straight road. Each castle is represented by its position on the road as an integer in the array `positions`. The king wants to build defense towers to protect the castles from invaders. Each tower can protect all castles within a certain range `r` on both sides of its location. That is, a tower at position `p` can protect any castle located between `p - r` and `p + r` inclusive. Your task is to determine the minimum number of towers needed to ensure all castles are protected. Given the array `positions` representing the positions of the castles, and an integer `r` representing the range of each tower, return the minimum number of towers required to protect all the castles.","solution":"def min_towers(positions, r): Returns the minimum number of towers needed to protect all castles. Parameters: positions (list): List of integers representing the positions of the castles. r (int): The range of each tower. Returns: int: Minimum number of towers required. # Sort the positions to handle them in order positions.sort() # Initialize the count of towers and the index towers = 0 i = 0 n = len(positions) while i < n: # Place the tower at the farthest position which can cover the current castle towers += 1 loc = positions[i] + r # Move to the farthest castle that can be covered by the new tower while i < n and positions[i] <= loc: i += 1 # This is the farthest position the current tower can cover loc = positions[i - 1] + r # Skip all the castles that are already covered by this tower while i < n and positions[i] <= loc: i += 1 return towers"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to find a triplet in the array whose sum is closest to the target. Return _the sum of the triplet_. You may assume that each input would have exactly one solution. A triplet is defined as three numbers in the array that are distinct indices.","solution":"def three_sum_closest(arr, target): This function finds the triplet in the array whose sum is closest to the target and returns the sum of the triplet. :param arr: List of integers :param target: Target integer :return: Sum of the triplet closest to the target arr.sort() closest_sum = float(\'inf\') for i in range(len(arr) - 2): left = i + 1 right = len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: # if current_sum == target, we have found the closest possible sum return closest_sum return closest_sum"},{"question":"You are given two arrays `source` and `target` of positive integers with the same length. You can perform the following operation on `source` any number of times: - Select any index `i` from `source` and increase the value at that index by 1 (i.e., `source[i] += 1`). Return the minimum number of operations required to make `source` an exact match to `target`.","solution":"def min_operations_to_match(source, target): Returns the minimum number of operations required to make `source` an exact match to `target`. if len(source) != len(target): raise ValueError(\\"Source and Target arrays must be of the same length.\\") operations = 0 for s, t in zip(source, target): if s < t: operations += (t - s) return operations"},{"question":"Given a list of non-negative integers `nums`, you are tasked with removing the minimum number of elements from the list so that the difference between the maximum and minimum values in the remaining list is at most `k`. Return the minimum number of elements to remove. Write a function `minRemovals(nums, k)` that implements this logic. For example, given `nums = [1, 3, 6, 9, 12]` and `k = 4`, the remaining list can be `[1, 3]`, `[6, 9]`, or `[9, 12]` with the minimum removals being `3`.","solution":"def minRemovals(nums, k): nums.sort() left = 0 result = len(nums) for right in range(len(nums)): while nums[right] - nums[left] > k: left += 1 result = min(result, len(nums) - (right - left + 1)) return result"},{"question":"You are given an integer array `heights` representing the heights of students standing in a row, where `heights[i]` is the height of the `i-th` student in line. Suppose there is a strict rule that no student of a given height should stand behind a shorter student. Determine the minimum number of students who must move to ensure all students are standing in non-decreasing order of height. Return the number of moves required.","solution":"def min_students_to_move(heights): Given an array of heights, determine the minimum number of movements required for all students to stand in non-decreasing order of height. Returns the number of moves required. sorted_heights = sorted(heights) moves_required = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves_required += 1 return moves_required"},{"question":"**[Question 4]:** Given a string `s`, find the length of the longest substring without repeating characters and return the substring itself. The substring should be contiguous and should not contain any duplicate characters. Example: ``` Input: s = \\"abcabcbb\\" Output: 3, \\"abc\\" Explanation: The answer is \\"abc\\", with a length of 3. ```","solution":"def longest_unique_substring(s): This function finds the length of the longest substring without repeating characters and returns the substring itself. :param s: str :return: tuple(int, str) n = len(s) char_index_map = {} max_length = 0 start = 0 longest_substring = \\"\\" for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 longest_substring = s[start:end + 1] return (max_length, longest_substring)"},{"question":"You are given an array `nums` of positive integers and an integer `n`. Your goal is to make `nums` strictly increasing by modifying at most `n` elements. In other words, you should not have any duplicates or elements out of order in the modified array. You are allowed to increase or decrease the value of an element as long as the final result is strictly increasing. Return the minimum number of modifications required to achieve this. If it is not possible to make `nums` strictly increasing with exactly `n` modifications, return `-1`.","solution":"def min_modifications(nums, n): Returns the minimum number of modifications required to make nums strictly increasing, or -1 if it\'s not possible to make nums strictly increasing with exactly n modifications. if not nums: return 0 length = len(nums) dp = [[float(\'inf\')] * length for _ in range(length)] for i in range(length): dp[i][i] = 0 for i in range(length - 1): dp[i][i + 1] = 0 if nums[i] < nums[i + 1] else 1 for gap in range(2, length): for i in range(length - gap): j = i + gap if nums[i] < nums[i + 1]: dp[i][j] = min(dp[i][j], dp[i + 2][j] + 1) if nums[i] < nums[j]: dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]) if nums[j - 1] < nums[j]: dp[i][j] = min(dp[i][j], dp[i][j - 2] + 1) if nums[i] < nums[j]: dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]) min_mods = dp[0][length - 1] return min_mods if min_mods <= n else -1"},{"question":"Given a string `s` consisting of lowercase English letters, return _the **number of distinct** characters in_ `s` _that appear **exactly**__ times_ .","solution":"def count_distinct_chars_with_exactly_k_occurrences(s, k): Returns the number of distinct characters in s that appear exactly k times. :param s: Input string consisting of lowercase English letters :param k: The exact number of times the distinct characters must appear :return: Number of distinct characters that appear exactly k times from collections import Counter # Count occurrences of each character in the string char_count = Counter(s) # Count distinct characters that appear exactly k times exact_k_count = sum(1 for key, val in char_count.items() if val == k) return exact_k_count"},{"question":"Given a string `s` representing a set of words separated by spaces, reverse the order of characters in each word while still preserving whitespace and initial word order. A word is defined as a sequence of non-space characters. The string `s` may contain leading or trailing spaces or multiple spaces between words. Write a function that returns the modified string after reversing each word. For example, given the input string `\\"Let\'s take LeetCode contest\\"`, the output should be `\\"s\'teL ekat edoCteeL tsetnoc\\"`.","solution":"def reverse_each_word(s): This function takes a string s and returns a new string where each word\'s characters are reversed but the word order and spaces are preserved. words = s.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"You are given a list of integers `nums` representing a permutation of numbers from 1 to `n` where `n` is the length of the list. Write a function that returns a list of integers where each integer in the returned list represents the length of the cycle that each corresponding integer in the input list belongs to. A cycle is defined by repeatedly jumping to the index indicated by the value at the current index, starting from a given position, until you return to the initial position.","solution":"def find_cycle_lengths(nums): Returns a list representing the length of the cycle for each element in nums. n = len(nums) visited = [False] * n cycle_lengths = [0] * n for i in range(n): if not visited[i]: cycle = [] while not visited[i]: visited[i] = True cycle.append(i) i = nums[i] - 1 cycle_length = len(cycle) for index in cycle: cycle_lengths[index] = cycle_length return cycle_lengths"},{"question":"Given a list of integers `nums`, partition it into as many sublists as possible such that each sublist contains at least one occurrence of the minimum value in `nums`, and the length of each sublist is minimized. Return a list containing these sublists. If there are multiple answers, return any of them. If it\'s impossible to partition the list as required, return an empty list.","solution":"def partition_by_min(nums): Partitions the list nums into sublists such that each sublist contains at least one occurrence of the minimum value in nums, and the length of each sublist is minimized. Returns a list of these sublists. If it\'s not possible to partition the list as required, returns an empty list. if not nums: return [] min_val = min(nums) partitions = [] current_partition = [] for num in nums: current_partition.append(num) if num == min_val: partitions.append(current_partition) current_partition = [] # If there are leftovers in current_partition which doesn\'t have the minimum value if current_partition: return [] # This means the last sublist does not have the minimum value, hence invalid partition. return partitions"},{"question":"You are given an integer array `nums` containing `n` unique numbers in the range from `1` to `n`. The array may be shuffled and may contain any permutation of these numbers. Your task is to determine if it is possible to sort this array in ascending order by performing a series of operations. In one operation, you can choose any two adjacent elements and swap them. Return `true` if you can sort the array using these operations, otherwise return `false`.","solution":"def can_sort_by_adjacent_swaps(nums): Determines if the array can be sorted in ascending order by swapping adjacent elements. # Since we are allowed to swap any two adjacent elements, # this is essentially a bubble sort problem. # We can always sort any array in ascending order using bubble sort, # which involves repeatedly swapping adjacent elements. return True"},{"question":"You are given an integer array `nums` with a length of `n`, representing the number of points available on a circular dartboard. Each element `nums[i]` represents the score for hitting that section of the dartboard. The dartboard is considered circular, meaning the element after `nums[n-1]` is `nums[0]`. Your goal is to find the maximum possible score by summing up exactly three consecutive sections on this circular dartboard. Return the maximum possible score obtainable by summing up three consecutive sections from the circular dartboard.","solution":"def max_score_three_consecutive_sections(nums): Returns the maximum possible score by summing up exactly three consecutive sections on the circular dartboard. n = len(nums) if n < 3: return sum(nums) # If there are less than 3 sections, sum all available sections. # Extend nums to handle the circular nature nums_extended = nums + nums[:2] max_sum = float(\'-inf\') for i in range(n): current_sum = nums_extended[i] + nums_extended[i + 1] + nums_extended[i + 2] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase and uppercase English letters. You need to sort the characters in the string so that all the uppercase letters come before all the lowercase letters, while preserving the relative order of the letters within each group. Implement the function `sortStringByCase(String s)` that takes a string `s` as an argument and returns a new string with the uppercase letters appearing before the lowercase letters, maintaining the original relative order of the letters within each group. Example: - Input: `s = \\"aCAdBb\\"` - Output: `\\"CABadb\\"`","solution":"def sortStringByCase(s): Returns a new string with all the uppercase letters coming before all the lowercase letters, preserving the original relative order of the letters within each group. uppercase = [char for char in s if char.isupper()] lowercase = [char for char in s if char.islower()] return \'\'.join(uppercase + lowercase)"},{"question":"Given a list of integers `arr`, write a function that returns `true` if there exist three indices `i`, `j`, and `k` such that `0 <= i < j < k < arr.length` and `arr[i] < arr[j] < arr[k]`. Otherwise, return `false`.","solution":"def increasing_triplet(arr): Returns true if there exist three indices i, j, and k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] < arr[k]. if len(arr) < 3: return False first = second = float(\'inf\') for num in arr: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"You are given a 0-indexed integer array `coins` of length `n` where `coins[i]` represents the number of coins at the `ith` position. There are two players who take turns to pick coins from either end of the array (leftmost or rightmost element) until no coins are left. The player who picks the last coin(s) wins if the number of coins they picked is even. Assuming both players play optimally, return \\"Player 1\\" if the first player to start the game will win, and \\"Player 2\\" otherwise.","solution":"def winner(coins): Determines the winner of the game where two players take turns to pick coins from either end of the array. The player who picks the last coin(s) wins if the number of coins they picked is even. Returns \\"Player 1\\" if the first player will win, otherwise \\"Player 2\\". Args: coins (list of int): A list representing the number of coins at each position. Returns: str: \\"Player 1\\" if the starting player wins, otherwise \\"Player 2\\". if len(coins) % 2 == 0: return \\"Player 1\\" else: return \\"Player 2\\""},{"question":"Given an `n x n` grid where each cell has either a land (1) or water (0), find the maximum distance from any land cell to the nearest water cell. If there is no land or water in the grid, return -1. You can only move up, down, left, and right within the grid. Implement the function `maxDistance(int[][] grid)` such that: - `maxDistance(int[][] grid)` returns the maximum distance from any land cell to the nearest water cell or -1 if either there is no land or no water in the grid.","solution":"from collections import deque def maxDistance(grid): n = len(grid) queue = deque() water_found = False land_found = False for i in range(n): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) land_found = True else: water_found = True if not land_found or not water_found: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] distance = -1 while queue: distance += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0: grid[nx][ny] = 1 queue.append((nx, ny)) return distance"},{"question":"You are given a rectangular grid of `m` rows and `n` columns, each cell containing a non-negative integer representing the cost of stepping into that cell. Starting from the top-left cell, you need to reach the bottom-right cell by moving either right or down at each step. Return _the minimum cost of reaching the bottom-right cell from the top-left cell_.","solution":"def min_path_cost(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a DP array with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner has the result, i.e., the minimum cost return dp[m - 1][n - 1]"},{"question":"Given an array `nums` consisting of distinct integers, return _a length of the longest sequence of consecutive numbers that can be found in `nums`_.","solution":"def longest_consecutive(nums): Returns the length of the longest sequence of consecutive numbers in the array \'nums\'. Parameters: nums (list): A list of distinct integers. Returns: int: The length of the longest consecutive elements sequence. if not nums: return 0 nums_set = set(nums) max_length = 0 for num in nums: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a 2D grid of integers `grid` where each element represents the altitude at that point. The grid represents a **map** where we need to determine which points are **peaks**. A point `(i, j)` in the grid is considered a **peak** if it is strictly greater than its 4 vertical and horizontal neighbors (if they exist). Return _a list of pairs (i, j)_ representing _the coordinates of all the peaks in the grid_. The order of the peaks in the output list does not matter.","solution":"def find_peaks(grid): Returns a list of pairs (i, j) representing the coordinates of peaks in the grid. A peak is an element that is strictly greater than its vertical and horizontal neighbors. :param grid: List[List[int]] :return: List[Tuple[int, int]] rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 peaks = [] def is_peak(i, j): for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols and grid[i][j] <= grid[ni][nj]: return False return True for i in range(rows): for j in range(cols): if is_peak(i, j): peaks.append((i, j)) return peaks"},{"question":"Given an integer array `nums`, return the number of **reverse pairs** in the array. A reverse pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `nums[i] > 2 * nums[j]`. For example: - Input: `nums = [1,3,2,3,1]` - Output: `2` Explanation: The reverse pairs are `(1, 4)` and `(3, 4)`.","solution":"def merge_count_rev_pairs(nums, left, mid, right): # Count the reverse pairs count = 0 j = mid + 1 for i in range(left, mid + 1): while j <= right and nums[i] > 2 * nums[j]: j += 1 count += (j - (mid + 1)) # Merge the two sorted halves temp = [] i, j = left, mid + 1 while i <= mid and j <= right: if nums[i] <= nums[j]: temp.append(nums[i]) i += 1 else: temp.append(nums[j]) j += 1 while i <= mid: temp.append(nums[i]) i += 1 while j <= right: temp.append(nums[j]) j += 1 for i in range(left, right + 1): nums[i] = temp[i - left] return count def count_reverse_pairs(nums, left, right): if left >= right: return 0 mid = (left + right) // 2 count = count_reverse_pairs(nums, left, mid) count += count_reverse_pairs(nums, mid + 1, right) count += merge_count_rev_pairs(nums, left, mid, right) return count def reverse_pairs(nums): if not nums: return 0 return count_reverse_pairs(nums, 0, len(nums) - 1)"},{"question":"Given two arrays `arr1` and `arr2` of equal length `n`, return _an array `result` such that `result[i]` is the **maximum value** obtained from `arr1[i]` and `arr2[i]` for each `0 <= i < n`_.","solution":"def max_values(arr1, arr2): Given two arrays arr1 and arr2 of equal length n, return an array result such that result[i] is the maximum value obtained from arr1[i] and arr2[i] for each 0 <= i < n. result = [] for i in range(len(arr1)): result.append(max(arr1[i], arr2[i])) return result"},{"question":"Given an integer array `arr` and an integer `m`, your task is to find _all contiguous subarrays of length `m` that have at most `k` distinct integers_. Return _the number of such subarrays_. Here are the steps for the function: 1. **Initialize** a variable to store the count of such subarrays. 2. Use a sliding window approach to traverse all possible subarrays of length `m`. 3. **Check** each subarray for the number of distinct integers. 4. **If** a subarray has at most `k` distinct integers, **increment** the count. 5. **Return** the total count of subarrays that meet the criteria. Note that the function should be implemented to handle the characteristics of the sliding window and counting distinct integers efficiently.","solution":"def count_subarrays_with_k_distinct(arr, m, k): This function returns the number of contiguous subarrays of length m that have at most k distinct integers. def sliding_window(arr, m, k): count = 0 window = {} distinct_count = 0 for i in range(len(arr)): # Add current element to the window if arr[i] in window: window[arr[i]] += 1 else: window[arr[i]] = 1 distinct_count += 1 # Remove the element that slides out of the window if i >= m: if window[arr[i - m]] == 1: del window[arr[i - m]] distinct_count -= 1 else: window[arr[i - m]] -= 1 # Increment count if the current window has at most k distinct integers if i >= m - 1 and distinct_count <= k: count += 1 return count return sliding_window(arr, m, k)"},{"question":"You are given a 2D grid of `n` x `n` binary values representing a map of an island. Each cell in the grid contains either a `0` (representing water) or a `1` (representing land). An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write a function to find the largest connected component of land in the grid and return its area. The area of an island is the number of cells with a value of `1` in the largest connected component of land.","solution":"def largest_island_area(grid): Given a 2D grid of binary values representing a map of an island, this function returns the area of the largest connected component of land (1s). def dfs(x, y): # Edge cases and base case for DFS if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the current land as visited grid[x][y] = 0 area = 1 # Explore adjacent cells in 4 directions area += dfs(x+1, y) area += dfs(x-1, y) area += dfs(x, y+1) area += dfs(x, y-1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Calculate area of the connected component using DFS max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a string `s` that consists of lowercase letters and an integer `k`. You need to perform a transformation on the string such that each given letter can be changed to any other letter, but at most `k` letters in the string can be different after the transformation. Return the length of the longest substring where you can apply this transformation. The transformation must satisfy the condition `k`.","solution":"def characterReplacement(s: str, k: int) -> int: Returns the length of the longest substring that can be transformed to consist of the same character with at most k changes. max_len = 0 left = 0 max_count = 0 count = {} for right in range(len(s)): count[s[right]] = count.get(s[right], 0) + 1 max_count = max(max_count, count[s[right]]) while (right - left + 1 - max_count) > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a binary tree root, return all root-to-leaf paths in any order. Each root-to-leaf path should be represented as a list of node values. A leaf is a node with no children. Write a function that takes the root of a binary tree and returns a list of lists, where each inner list contains the values of nodes from the root to a leaf.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths in a binary tree. :param TreeNode root: The root of the binary tree. :return: A list of lists, where each inner list represents a root-to-leaf path. if not root: return [] def dfs(node, path, paths): if not node: return path.append(node.val) if not node.left and not node.right: paths.append(list(path)) # Leaf node else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() # backtrack paths = [] dfs(root, [], paths) return paths"},{"question":"Given an m x n binary matrix `grid`, return the number of **distinct islands** in the matrix. An island is a group of `1`s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Two islands are considered distinct if one island is equal to another (not the same) if and only if one swap of `1`s and `0`s changes a part of the first island to be connected to the water. Implement the `NumberOfDistinctIslands` class: * `int numDistinctIslands(int[][] grid)` returns the number of distinct islands in the `grid`.","solution":"class NumberOfDistinctIslands: def numDistinctIslands(self, grid): def dfs(x, y, direction): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 path_signature.append(direction) dfs(x + 1, y, \\"d\\") dfs(x - 1, y, \\"u\\") dfs(x, y + 1, \\"r\\") dfs(x, y - 1, \\"l\\") path_signature.append(\\"b\\") distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, \\"o\\") distinct_islands.add(tuple(path_signature)) return len(distinct_islands)"},{"question":"You are given two integer arrays `nums1` and `nums2` representing the elements of two sets, where both arrays are sorted in non-decreasing order. Write a function to find the intersection of these two sets, which means the elements that appear in both arrays. The result should also be sorted in non-decreasing order. Each element in the result must be unique. Return _an array containing the intersection of `nums1` and `nums2`_.","solution":"def intersection(nums1, nums2): Returns the intersection of two sorted arrays nums1 and nums2 as a sorted array. Only unique elements that are present in both arrays are included in the result. set1 = set(nums1) set2 = set(nums2) intersect = set1 & set2 # Finding the intersection return sorted(list(intersect)) # Returning sorted list of the intersection"},{"question":"You are provided with a collection of `n` items where each item has a **weight** and a **value**. You are also given a **maximum weight** capacity `W`. Implement a function to determine the **maximum total value** of items that can be included in a knapsack without exceeding the weight capacity. Solve this problem using a dynamic programming approach. # Function Signature ```python def knapsack(values: List[int], weights: List[int], W: int) -> int: ```","solution":"from typing import List def knapsack(values: List[int], weights: List[int], W: int) -> int: Returns the maximum total value of items that can be included in a knapsack without exceeding the weight capacity W using dynamic programming approach. n = len(values) # Create a 2D DP array where dp[i][w] represents the maximum value that can be # gained with the first i items and with a weight allowance of w. dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Populate the DP array for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: # Item can be included in the knapsack dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: # Item cannot be included in the knapsack dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"A square matrix is said to be a **magic square** if the sum of each row, each column, and both diagonals are all the same. Given a 2D array `matrix` of size `n x n` (where `n` is an odd integer), determine if the matrix is a magic square. Return `true` if the matrix is a magic square, otherwise, return `false`. Your solution should have a time complexity of `O(n^2)`.","solution":"def is_magic_square(matrix): Determines if a given n x n matrix is a magic square. n = len(matrix) if not matrix or n != len(matrix[0]): return False # Calculate the sum of the main diagonal main_diag_sum = sum(matrix[i][i] for i in range(n)) # Calculate the sum of the anti-diagonal anti_diag_sum = sum(matrix[i][n - i - 1] for i in range(n)) # If both diagonals do not have the same sum, it\'s not a magic square if main_diag_sum != anti_diag_sum: return False # Check each row and each column\'s sum for i in range(n): if sum(matrix[i]) != main_diag_sum or sum(matrix[j][i] for j in range(n)) != main_diag_sum: return False # If all checks are satisfied, return True return True"},{"question":"Given a 2D integer grid `grid` representing a map of islands (1s) and water (0s), an island is a maximal 4-directionally connected group of `1`s. If an island is completely surrounded by water and there are no `1`s touching the boundary of the grid, the island is considered completely surrounded. Return the number of completely surrounded islands in the grid.","solution":"def num_completely_surrounded_islands(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= rows or y < 0 or y >= cols: return False if grid[x][y] == 0: return True if grid[x][y] == -1: return True grid[x][y] = -1 top = dfs(x - 1, y) bottom = dfs(x + 1, y) left = dfs(x, y - 1) right = dfs(x, y + 1) return top and bottom and left and right surrounded_islands_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: if dfs(i, j): surrounded_islands_count += 1 return surrounded_islands_count"},{"question":"Given an integer array `hours` of length `n` representing the number of hours you have worked each day over `n` consecutive days. You are tasked with finding a contiguous subarray within the `hours` array that has the largest sum, assuming that it is possible to take at least one day off (excluding entirely contiguous subarrays). Return the maximum sum of the contiguous subarray.","solution":"def max_contiguous_subarray_sum(hours): Finds the maximum sum of a contiguous subarray in hours array. if not hours: return 0 max_sum = float(\'-inf\') current_sum = 0 for hour in hours: current_sum += hour if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"Given a string containing digits `0-9`, return the number of possible valid IP address combinations that can be formed by inserting exactly three dots into the string. Note that an IP address consists of four sections of numbers separated by dots, and each section must fall between `0` and `255` inclusively. Leading zeros are not allowed in any section except for `0` itself.","solution":"def is_valid_section(section): Checks if a given section of an IP address is valid. A valid section must be an integer between 0 and 255 and cannot have leading zeros (except for the number 0 itself). if len(section) > 1 and section[0] == \'0\': return False return 0 <= int(section) <= 255 def valid_ip_addresses(s): Returns the number of possible valid IP address combinations that can be formed by inserting exactly three dots into the string. n = len(s) if n < 4 or n > 12: return 0 valid_count = 0 for i in range(1, min(n, 4)): for j in range(i+1, min(n, i+4)): for k in range(j+1, min(n, j+4)): section1, section2, section3, section4 = s[:i], s[i:j], s[j:k], s[k:] if is_valid_section(section1) and is_valid_section(section2) and is_valid_section(section3) and is_valid_section(section4): valid_count += 1 return valid_count"},{"question":"Given a string `s`, return the length of the longest substring `t` that contains no duplicate characters and at most `k` distinct characters. If `k` is zero, return 0.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains no duplicate characters and at most k distinct characters. if k == 0: return 0 n = len(s) if n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a circular array `nums` of integers, where each element represents the amount of money stashed at that index. You can start robbing from any index and rob continuously until you return to the starting point. However, you cannot rob two adjacent houses simultaneously. Write a function that returns the maximum amount of money you can rob without robbing two adjacent houses.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without robbing two adjacent houses in a circular array of integers. Args: nums (list of int): The circular array of integers representing the amount of money at each house. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] def rob_line(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr # Exclude the first house or the last house because it\'s a circular array return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"You are given a linked list where each node contains an integer value. Implement a function that takes the head of the linked list as input and returns the head of the list after removing all nodes whose values are greater than a given threshold `T`. The order of the remaining nodes should be preserved.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nodes_above_threshold(head, T): Removes all nodes from the linked list whose values are greater than T. Args: head (ListNode): The head of the linked list. T (int): The threshold value. Returns: ListNode: The head of the modified linked list. dummy = ListNode(0) dummy.next = head current = dummy while current.next: if current.next.val > T: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"You are given an array of integers `nums` representing a sequence of scores. A score sequence is considered **well-performing** if the sum of its elements is strictly greater than zero. Your task is to determine the length of the longest **well-performing** score sequence within `nums`. Return _the **length** of the longest well-performing sequence_ in `nums`.","solution":"def longest_well_performing_sequence(nums): Returns the length of the longest well-performing sequence within nums. A well-performing sequence is defined as a subarray with a sum strictly greater than zero. if not nums: return 0 max_length = 0 prefix_sum = 0 sum_indices = {} for i, num in enumerate(nums): prefix_sum += num if prefix_sum > 0: max_length = i + 1 else: if prefix_sum - 1 in sum_indices: max_length = max(max_length, i - sum_indices[prefix_sum - 1]) if prefix_sum not in sum_indices: sum_indices[prefix_sum] = i return max_length"},{"question":"You are given a list of integers `arr` and an integer `k`. You can choose any subarray of `arr` with length exactly `k` and rearrange its elements in any order. Return _the maximum possible sum of the minimum values of all subarrays of length `k` after you have rearranged the subarrays_. For example, if `arr = [1, 3, 2, 4]` and `k = 2`, you could choose the subarray `[3, 2]`, rearrange it to `[2, 3]`, and the subarray `[1, 4]` remains the same. Hence, the minimum values would be `2` and `1`, resulting in a sum of `2 + 1 = 3`.","solution":"def max_possible_sum_of_minimums(arr, k): Returns the maximum possible sum of the minimum values of all subarrays of length k after rearrangement. Parameters: arr (list of int): The list of integers. k (int): The length of each subarray to consider. Returns: int: The maximum sum of the minimum values of all subarrays of length k. # Sort the array in descending order to maximize the sum of the minimum values in subarrays of length k sorted_arr = sorted(arr, reverse=True) # Calculate the sum of the minimum values of each subarray of length k max_sum = sum(sorted_arr[i] for i in range(k)) return max_sum"},{"question":"Given an array of integers `arr`, write a function that returns the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to `1`. Make sure your solution runs efficiently for large arrays.","solution":"def max_length_subarray(arr): Returns the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to 1. if not arr: return 0 from collections import defaultdict count_map = defaultdict(int) max_length = 0 for num in arr: count_map[num] += 1 max_length = max(max_length, count_map[num] + count_map[num + 1], count_map[num] + count_map[num - 1]) return max_length"},{"question":": A delivery service company needs to optimize the time it takes to deliver packages. They have a set of `n` delivery locations, represented as a 2D array `locations` where `locations[i] = [x, y]` represents the coordinates of the `i-th` delivery location. The delivery truck starts at the origin `(0, 0)`. They can visit any location in any order, but each location must be visited only once. The company wants to minimize the total Manhattan distance traveled by the truck. The Manhattan distance between two points `(x1, y1)` and `(x2, y2)` is calculated as `|x1 - x2| + |y1 - y2|`. Write a function that calculates the minimum total Manhattan distance needed for the truck to visit all delivery locations and return back to the origin. Note that the truck should return to the origin after delivering all packages.","solution":"import itertools def min_total_manhattan_distance(locations): Returns the minimum total Manhattan distance needed for the truck to visit all delivery locations and return back to the origin. def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) n = len(locations) min_distance = float(\'inf\') # Generate all permutations of locations to check all possible orders of visit for perm in itertools.permutations(locations): current_distance = 0 current_point = (0, 0) # truck starts at the origin for loc in perm: current_distance += manhattan_distance(current_point, loc) current_point = loc current_distance += manhattan_distance(current_point, (0, 0)) # returning to the origin min_distance = min(min_distance, current_distance) return min_distance"},{"question":"Given a string `s`, find the length of the longest substring that contains at most two distinct characters. You can assume that `0 ≤ s.length ≤ 100` and `s` consists of only lowercase English letters. **Function Signature:** `public int lengthOfLongestSubstringTwoDistinct(String s)`","solution":"def length_of_longest_substring_two_distinct(s): Find the length of the longest substring that contains at most two distinct characters. :param s: Input string :return: Length of the longest substring with at most two distinct characters from collections import defaultdict if len(s) == 0: return 0 left = 0 right = 0 max_length = 0 char_map = defaultdict(int) while right < len(s): char_map[s[right]] += 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a `root` of a binary tree containing integer values. Your task is to print the top view of the binary tree. The top view of the binary tree means the set of nodes that are visible when the tree is viewed from the top. Return _a list of values representing the nodes seen from the top view ordered from left to right_. Note: If multiple nodes are at the same horizontal distance and position, only the topmost (the smallest vertical distance to the root) node should be considered.","solution":"from collections import deque class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def top_view(root): if root is None: return [] # This dictionary keeps the first node at every horizontal distance top_nodes = {} # Queue for BFS: it stores pairs (node, horizontal_distance) queue = deque([(root, 0)]) while queue: node, hd = queue.popleft() if hd not in top_nodes: top_nodes[hd] = node.val if node.left is not None: queue.append((node.left, hd - 1)) if node.right is not None: queue.append((node.right, hd + 1)) # Extract the entries from the map and sort them by horizontal distance sorted_hd = sorted(top_nodes.keys()) return [top_nodes[hd] for hd in sorted_hd]"},{"question":"Given a string `s` containing only three types of characters: `\'(\'`, `\')\'`, and `\'*\'`, where `\'*\'` can represent either `(`, `)`, or an empty string, determine if the string `s` is valid. The string is considered valid if it is possible to insert characters `(` and `)` in place of `\'*\'` such that the resulting string is a valid parentheses string. A valid parentheses string is defined as follows: 1. Any left parenthesis `\'(\'` must have a corresponding right parenthesis `\')\'`. 2. Any right parenthesis `\')\'` must have a corresponding left parenthesis `\'(\'`. 3. Left parentheses `\'(\'` must go before the corresponding right parenthesis `\')\'`.","solution":"def checkValidString(s: str) -> bool: This function checks if a string with parentheses and wildcards is valid. :param s: A string containing \'(\', \')\' and \'*\' :return: A boolean indicating if the string is a valid parentheses string low = 0 # The minimum number of open parentheses needed high = 0 # The maximum number of open parentheses possible for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': low -= 1 high -= 1 elif char == \'*\': low -= 1 high += 1 if high < 0: return False if low < 0: low = 0 return low == 0"},{"question":"You are given a list of non-negative integers `prices` representing the price of ice cream bars on a particular day, and an integer `coins` which is the amount of money you have. You need to determine the **maximum number** of ice cream bars you can buy with your coins. Each ice cream bar can only be bought once and you must buy the bars in whole units (i.e., fractional units are not allowed). Return the maximum number of ice cream bars you can buy. If you cannot buy any ice cream bars, return `0`.","solution":"def max_ice_cream(prices, coins): Determines the maximum number of ice cream bars that can be bought with the available coins. :param prices: List of non-negative integers representing the price of each ice cream bar. :param coins: Integer representing the amount of money available to spend. :return: Integer representing the maximum number of ice cream bars that can be bought. prices.sort() count = 0 for price in prices: if price <= coins: coins -= price count += 1 else: break return count"},{"question":"You are given a list of strings `words` and a string `target`. Each string in `words` contains only lowercase English letters. You need to determine if you can form the `target` string by concatenating any number of strings (including zero) from the `words` list, where each string can be used only once. Return `true` if it is possible to form the `target` string, otherwise return `false`.","solution":"def can_form_target(words, target): Determine if target can be formed by concatenating any number of strings from words list. Each string in words can be used only once. :param words: List[str] - a list of strings containing lowercase English letters :param target: str - the target string to be formed :return: bool - True if target can be formed, False otherwise def can_form_recurse(remaining_target, used): if remaining_target == \\"\\": return True for i, word in enumerate(words): if not used[i] and remaining_target.startswith(word): used[i] = True if can_form_recurse(remaining_target[len(word):], used): return True used[i] = False return False return can_form_recurse(target, [False] * len(words))"},{"question":"You are given an array of integers `arr` where each element represents the height of a building. An element `arr[i]` is considered **visible** if all the elements before it (from `0` to `i-1`) are smaller than it. Return the number of buildings that are visible. For example, given `arr = [4, 2, 3, 6, 5, 1, 7]`, the visible buildings are `[4, 6, 7]`. So, the function should return `3`.","solution":"def count_visible_buildings(arr): Returns the number of visible buildings based on the given array of heights. if not arr: return 0 visible_count = 0 max_height_so_far = float(\'-inf\') # Initialize to a very small number for height in arr: if height > max_height_so_far: visible_count += 1 max_height_so_far = height return visible_count"},{"question":"You are given an integer array `nums` and a target value `target`. Write a function to find the number of contiguous subarrays that sum to a given value `target`. The function should return the count of such subarrays. Use an efficient algorithm to ensure it runs within acceptable limits for large input sizes.","solution":"def subarray_sum(nums, target): Returns the number of contiguous subarrays that sum to a given target value. count = 0 cumulative_sum = 0 sum_count_map = {0: 1} # To handle the case when subarray starts from index 0 for num in nums: cumulative_sum += num if (cumulative_sum - target) in sum_count_map: count += sum_count_map[cumulative_sum - target] sum_count_map[cumulative_sum] = sum_count_map.get(cumulative_sum, 0) + 1 return count"},{"question":"You are given a string `s` that represents an expression containing digits and the operators `+`, `-`, `*`, and `/`. The expression may include parentheses `(` and `)` to dictate the order of operations. Implement a function to evaluate this expression and return the result as an integer. The expression is always valid, meaning no division by zero and input will not contain any spaces. Note: Operator precedence must be respected, and parentheses may be used to override default precedence. For example: - `s = \\"3+2*2\\"` should return `7` because multiplication is evaluated before addition. - `s = \\"(1+(4+5+2)-3)+(6+8)\\"` should return `23` because parentheses indicate the order of operations.","solution":"def evaluate(s): Evaluates the given arithmetic expression string and returns the result as an integer. def operate(a, b, op): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) # Ensure the result is an integer def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operators(operators, values): right = values.pop() left = values.pop() op = operators.pop() values.append(operate(left, right, op)) operators = [] values = [] i = 0 while i < len(s): if s[i] == \'(\': operators.append(s[i]) elif s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = (val * 10) + int(s[i]) i += 1 values.append(val) i -= 1 # Adjust for the increment in the for loop elif s[i] == \')\': while operators and operators[-1] != \'(\': apply_operators(operators, values) operators.pop() # Pop the opening parenthesis else: while operators and precedence(operators[-1]) >= precedence(s[i]): apply_operators(operators, values) operators.append(s[i]) i += 1 while operators: apply_operators(operators, values) return values[0]"},{"question":"You are given a list of strings `commands`, where each command is a comma-separated sequence of operations. Each operation is a string of directory names followed by \\"/\\" or \\"..\\" to represent moving into a directory or moving one level up, respectively. You are supposed to determine the current directory path after executing all the commands sequentially starting from the root directory \\"/\\". Return the final directory path as a string. If the path becomes empty, return \\"/\\". Note: Assume all paths are valid and \'..\' will not move above the root.","solution":"def execute_commands(commands): Return the current directory path after executing all the commands sequentially starting from the root directory \\"/\\". path = [] for command in commands: operations = command.split(\',\') for op in operations: if op == \\"..\\": if path: path.pop() else: path.append(op.strip(\\"/\\")) return \\"/\\" + \\"/\\".join(path) if path else \\"/\\""},{"question":"You are given an array of integers `arr` of length `n` and an integer `t`. Your task is to determine the **smallest subarray** (of any length) of `arr` such that the sum of its elements is greater than or equal to `t`. If no such subarray exists, return `-1`. A **subarray** is a contiguous part of an array. For example, given `arr = [2, 3, 1, 2, 4, 3]` and `t = 7`, the smallest subarray with sum >= 7 is `[4, 3]` and its length is 2. Return the length of the smallest subarray with sum greater than or equal to `t`, or `-1` if no such subarray exists.","solution":"def smallest_subarray_with_sum(arr, t): Returns the length of the smallest subarray with sum greater than or equal to t. If no such subarray exists, return -1. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= t: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given an array of integers `cards` where `cards[i]` represents the value of the i-th card. You are allowed to pick cards in a sequence but must immediately stop if the sum of the picked cards exceeds a given integer `limit`. Your task is to determine the maximum sum you can achieve that is less than or equal to the `limit`. Return this maximum sum.","solution":"def max_sum_under_limit(cards, limit): Returns the maximum sum of a subsequence of `cards` that does not exceed the given `limit`. n = len(cards) max_sum = 0 for i in range(n): current_sum = 0 for j in range(i, n): if current_sum + cards[j] > limit: break current_sum += cards[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"A sequence of integers `nums` is defined to be a **Hill Sequence** if it satisfies the following conditions: * There is a peak element in the sequence. * All elements before the peak are in ascending order. * All elements after the peak are in descending order. Given an integer array `nums`, return _`true` if the array is a Hill Sequence. Otherwise, return `false`_.","solution":"def is_hill_sequence(nums): Determine if the given array nums is a Hill Sequence. A Hill Sequence has a peak element where all elements before it are in ascending order and all elements after it are in descending order. Args: nums (list[int]): List of integers. Returns: bool: True if nums is a Hill Sequence, False otherwise. if len(nums) < 3: return False peak_found = False peak_index = -1 n = len(nums) for i in range(1, n - 1): if nums[i - 1] < nums[i] > nums[i + 1]: peak_found = True peak_index = i break if not peak_found: return False for i in range(peak_index): if nums[i] >= nums[i + 1]: return False for i in range(peak_index, n - 1): if nums[i] <= nums[i + 1]: return False return True"},{"question":"You are given two strings `s` and `t`. Your task is to check if the string `t` can be obtained by deleting exactly one character from the string `s` and rearranging the remaining characters. Implement the `Solution` class: - `boolean canFormByDeletingAndRearranging(String s, String t)` - This method should return `true` if `t` can be formed by deleting exactly one character from `s` and rearranging the remaining characters, and `false` otherwise.","solution":"def can_form_by_deleting_and_rearranging(s, t): Returns True if t can be formed by deleting exactly one character from s and rearranging the remaining characters. # Check the length conditions if len(s) != len(t) + 1: return False # Create frequency counts for both strings from collections import Counter s_count = Counter(s) t_count = Counter(t) # Check the character frequency difference differences = 0 for char in s_count: s_freq = s_count[char] t_freq = t_count[char] if char in t_count else 0 if s_freq != t_freq: differences += (s_freq - t_freq) if differences > 1: return False return differences == 1"},{"question":"You are given a string `s` representing a sequence of characters. Your task is to determine the length of the longest subsequence of `s` that is also a palindrome. A subsequence is derived by deleting some or none of the characters in `s` without changing the order of the remaining characters. Write a function: ```python def longest_palindromic_subsequence(s: str) -> int: ``` Return an integer representing the length of the longest palindromic subsequence in `s`. You can assume that the input string will only contain lowercase English letters and its length will not exceed 1000 characters.","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in a given string s. n = len(s) # Create a 2D table to store lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # Subsequences of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Fill the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of longest palindromic subseq return dp[0][n - 1]"}]'),F={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},N={class:"card-container"},z={key:0,class:"empty-state"},C=["disabled"],S={key:0},D={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",N,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",z,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",D,"Loading...")):(n(),r("span",S,"See more"))],8,C)):l("",!0)])}const G=m(F,[["render",E],["__scopeId","data-v-b9ff2419"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/1.md","filePath":"library/1.md"}'),P={name:"library/1.md"},M=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{O as __pageData,M as default};
