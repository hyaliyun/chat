import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},A={class:"review-title"},E={class:"review-content"};function I(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",I],["__scopeId","data-v-5ebf50eb"]]),S=JSON.parse('[{"question":"# Coding Assessment Question: Sum of Odd Fibonacci Numbers Objective Implement a function `sum_of_odd_fibonacci(upper_limit: int) -> int` that calculates the sum of all odd Fibonacci numbers less than or equal to a given upper limit. Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. The sequence starts with 0 and 1. Function Signature ```python def sum_of_odd_fibonacci(upper_limit: int) -> int: ``` Input - **Single integer `upper_limit`**: The upper limit up to which odd Fibonacci numbers are to be summed (inclusive). This will always be a positive integer. Output - **Integer sum**: The sum of all odd Fibonacci numbers less than or equal to the given upper limit. Constraints - Efficiently generate Fibonacci numbers without causing performance degradation for large upper limits. - Handle large inputs efficiently to ensure the function performs well up to an upper limit of (10^{9}). - Raise a `TypeError` if `upper_limit` is not an integer. Performance Requirements - The function should be optimized for handling upper limits up to (10^{9}). Example Scenarios - `sum_of_odd_fibonacci(10)` should return `10` (since the odd Fibonacci numbers ≤ 10 are 1, 1, 3, 5) - `sum_of_odd_fibonacci(1)` should return `2` (since the odd Fibonacci numbers ≤ 1 are 1, 1) - `sum_of_odd_fibonacci(34)` should return `44` (since the odd Fibonacci numbers ≤ 34 are 1, 1, 3, 5, 13, 21) Use the following snippet to start the implementation: ```python def sum_of_odd_fibonacci(upper_limit: int) -> int: if not isinstance(upper_limit, int): raise TypeError(\\"The upper limit must be an integer.\\") a, b = 0, 1 sum_odds = 0 while a <= upper_limit: if a % 2 != 0: sum_odds += a a, b = b, a + b return sum_odds ``` Through this question, the students should demonstrate: 1. Proper understanding of the Fibonacci sequence. 2. Handling edge cases, error conditions, and large inputs effectively. 3. Writing clear, efficient, and maintainable code.","solution":"def sum_of_odd_fibonacci(upper_limit: int) -> int: if not isinstance(upper_limit, int): raise TypeError(\\"The upper limit must be an integer.\\") a, b = 0, 1 sum_odds = 0 while a <= upper_limit: if a % 2 != 0: sum_odds += a a, b = b, a + b return sum_odds"},{"question":"# Question: Implement a Simple LRU (Least Recently Used) Cache You are required to implement a class `LRUCache` with methods to set and get values in a cache with a fixed capacity, using the LRU (Least Recently Used) replacement policy. Your implementation should reflect the requirements mentioned below: Class: `LRUCache` Methods: 1. **`__init__(self, capacity: int) -> None`**: * Input: An integer representing the capacity of the cache. * Output: None. * Example: `LRUCache(2)` should create an LRU cache with a capacity of 2. 2. **`get(self, key: int) -> int`**: * Input: An integer representing the key to retrieve. * Output: An integer representing the value associated with the key. If the key is not found, return -1. * Example: If you call `cache.get(1)` and the key `1` exists with a value of `10`, it should return `10`. If the key `1` does not exist, it should return `-1`. 3. **`set(self, key: int, value: int) -> None`**: * Input: Two integers, the key and the value to set. * Output: None. * Example: `cache.set(1, 10)` should set the value of the key `1` to `10`. Constraints: * All keys and values will be integers. * The capacity should always be a positive integer. * In case the cache reaches its capacity and you need to insert a new element, remove the least recently used element. ```python class LRUCache: def __init__(self, capacity: int) -> None: # Implement this method pass def get(self, key: int) -> int: # Implement this method pass def set(self, key: int, value: int) -> None: # Implement this method pass # Example Usage: # cache = LRUCache(2) # cache.set(1, 10) # cache.set(2, 20) # print(cache.get(1)) # Returns 10 # cache.set(3, 30) # Evicts key 2 # print(cache.get(2)) # Returns -1 (not found) # cache.set(4, 40) # Evicts key 1 # print(cache.get(1)) # Returns -1 (not found) # print(cache.get(3)) # Returns 30 # print(cache.get(4)) # Returns 40 ``` Your solution should manage the cache efficiently with both set and get operations running in O(1) time complexity.","solution":"class LRUCache: def __init__(self, capacity: int) -> None: self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def set(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key)"},{"question":"# Problem Statement Create a function `sum_missing_numbers(nums: list, n: int) -> int` that calculates the sum of all integers from 1 to `n` that are missing in the input list `nums`. Input - A list `nums` of integers (1 ≤ |nums| ≤ 10^4) representing a subset of the first `n` natural numbers. - An integer `n` (1 ≤ n ≤ 10^5) representing the upper limit of the natural number range. Output - An integer representing the sum of the missing numbers in the list. # Task Implement the function `sum_missing_numbers(nums: list, n: int) -> int` that computes the sum of all integers from 1 to `n` that are missing from the input list. Follow the example structure provided below: ```python def sum_missing_numbers(nums: list, n: int) -> int: # Your implementation here ``` Examples 1. **Input**: `sum_missing_numbers([1, 2, 4], 5)` - **Output**: `9` - **Explanation**: The numbers 3 and 5 are missing. Their sum is 3 + 5 = 8. 2. **Input**: `sum_missing_numbers([2, 3, 7, 4], 7)` - **Output**: `15` - **Explanation**: The numbers 1, 5, and 6 are missing. Their sum is 1 + 5 + 6 = 12. 3. **Input**: `sum_missing_numbers([1, 2, 3, 4, 5], 5)` - **Output**: `0` - **Explanation**: No numbers are missing; the sum is 0. 4. **Input**: `sum_missing_numbers([10, 1, 2, 5, 6], 10)` - **Output**: `38` - **Explanation**: The numbers 3, 4, 7, 8, and 9 are missing. Their sum is 3 + 4 + 7 + 8 + 9 = 31. Constraints - The input list `nums` may contain duplicates. - The input list `nums` will always contain numbers within the range 1 to `n`. - The length of the input list and the value of `n` will ensure that the sum of missing numbers can be computed efficiently. Please consider time and space optimal solutions. # Notes - You may use set operations, arithmetic progressions, or other methods as long as the final implementation adheres to the specified constraints.","solution":"def sum_missing_numbers(nums: list, n: int) -> int: Computes the sum of all integers from 1 to n that are missing in the input list nums. total_sum = n * (n + 1) // 2 actual_sum = sum(set(nums)) return total_sum - actual_sum"},{"question":"**Context**: You are tasked to enhance a base `Trie` (prefix tree) structure for efficient word storage and retrieval by implementing additional methods for auto-completion and counting the number of words with a given prefix. **Objective**: Implement a class `EnhancedTrie` that inherits from `Trie` and extends its functionalities by adding the following methods: 1. `autocomplete`: Given a prefix, return all words in the trie that begin with that prefix. 2. `count_words_starting_with`: Given a prefix, return the number of words that start with that prefix. # Requirements: 1. **Class Hierarchy**: Your `EnhancedTrie` should inherit from `Trie`. 2. **Auto-completion**: Implement a method to retrieve all words that start with a given prefix. 3. **Counting Words**: Implement a method to count how many words start with a given prefix. # Define Class Structure ```python class EnhancedTrie(Trie): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # Define additional properties if needed def autocomplete(self, prefix: str) -> List[str]: Return a list of all words that start with the given prefix. # Implement auto-completion logic def count_words_starting_with(self, prefix: str) -> int: Return the number of words that start with the given prefix. # Implement counting logic ``` # Instructions 1. **Initialize**: On initialization, it should take the same parameters as the base class. 2. **Auto-completion Logic**: Implement `autocomplete` to traverse nodes starting from the end of the prefix, collecting all words that continue from those nodes. 3. **Counting Logic**: Implement `count_words_starting_with` to count all valid words starting from the end of the specified prefix. # Constraints * `prefix` is always a string. * Words in the trie are non-null strings consisting of lowercase alphabets. # Example ```python # Example usage trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") print(trie.autocomplete(\\"ap\\")) # Output: [\'apple\', \'app\', \'apricot\'] print(trie.count_words_starting_with(\\"ap\\")) # Output: 3 print(trie.autocomplete(\\"ban\\")) # Output: [\'banana\'] print(trie.count_words_starting_with(\\"ban\\")) # Output: 1 ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _search_node(self, prefix): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node class EnhancedTrie(Trie): def __init__(self): super().__init__() def autocomplete(self, prefix: str): Return a list of all words that start with the given prefix. node = self._search_node(prefix) if not node: return [] words = [] self._dfs(node, prefix, words) return words def _dfs(self, node, prefix, words): Depth-first search from the given node to collect all words. if node.is_end_of_word: words.append(prefix) for char, child_node in node.children.items(): self._dfs(child_node, prefix + char, words) def count_words_starting_with(self, prefix: str): Return the number of words that start with the given prefix. node = self._search_node(prefix) if not node: return 0 return self._count_words(node) def _count_words(self, node): Count all words from the given node. count = 1 if node.is_end_of_word else 0 for child_node in node.children.values(): count += self._count_words(child_node) return count"},{"question":"# Context and Problem Statement You are tasked with developing a utility for a text processor that helps to identify duplicated words in a sentence. Consecutive duplicated words are often a sign of typographical errors and should be flagged for correction. Your program should detect these errors and return the corrected sentence. # Task Implement a function `remove_consecutive_duplicates(sentence: str) -> str` that takes: 1. **sentence** (str): A string containing a sentence composed of words separated by spaces. Return a string where all consecutive duplicated words are removed. The function should maintain the order of the remaining words and ensure exactly one space between words in the corrected sentence. # Input and Output Formats **Input:** * A single string `sentence`. **Output:** * A string representing the corrected sentence with consecutive duplicates removed. # Constraints * `1 <= len(sentence) <= 10^5` * The sentence contains only lowercase and uppercase English letters, and spaces. * Words in the sentence are separated by a single space and there are no leading or trailing spaces. # Example ```python sentence = \\"this is is a test test sentence\\" assert remove_consecutive_duplicates(sentence) == \\"this is a test sentence\\" sentence = \\"hello hello world\\" assert remove_consecutive_duplicates(sentence) == \\"hello world\\" ``` # Explanation: 1. In the first example, the consecutive duplicates \\"is\\" and \\"test\\" are removed, resulting in \\"this is a test sentence\\". 2. In the second example, the consecutive duplicate \\"hello\\" is removed, resulting in \\"hello world\\". # Follow-up: Discuss the time and space complexity of your implementation and how it handles the upper limit of the input size effectively. # Solution Example ```python def remove_consecutive_duplicates(sentence: str) -> str: words = sentence.split() result = [words[0]] for i in range(1, len(words)): if words[i] != words[i-1]: result.append(words[i]) return \' \'.join(result) ```","solution":"def remove_consecutive_duplicates(sentence: str) -> str: Removes consecutive duplicate words from the sentence. Args: sentence (str): A string containing a sentence composed of words separated by spaces. Returns: str: A string where all consecutive duplicated words are removed. words = sentence.split() if not words: return sentence result = [words[0]] for i in range(1, len(words)): if words[i] != words[i-1]: result.append(words[i]) return \' \'.join(result)"},{"question":"# Coding Assessment Question Problem Description You are tasked with creating a function that generates all possible letter combinations that the provided digit string could represent on a traditional telephone keypad. In such keypads, digits are mapped to multiple letters as follows: - \'2\' -> \\"abc\\" - \'3\' -> \\"def\\" - \'4\' -> \\"ghi\\" - \'5\' -> \\"jkl\\" - \'6\' -> \\"mno\\" - \'7\' -> \\"pqrs\\" - \'8\' -> \\"tuv\\" - \'9\' -> \\"wxyz\\" Write a function `letter_combinations` that returns all possible letter combinations using the provided digit string. Requirements 1. The function should take a single parameter `digits`, a string that represents the digit string. 2. The function should return a list of strings representing all possible letter combinations. 3. The function should handle cases when the input string is empty by returning an empty list. Input Format - A single string `digits` (0 ≤ |digits| ≤ 4), where |digits| denotes the length of the string. The input string contains only digits from \'2\' to \'9\'. Output Format - A list of strings, each string representing a possible letter combination. Constraints - The input string will contain only valid digits from \'2\' to \'9\'. Example ```python letter_combinations(\\"23\\") # Returns: [\'ad\', \'ae\', \'af\', \'bd\', \'be\', \'bf\', \'cd\', \'ce\', \'cf\'] letter_combinations(\\"\\") # Returns: [] letter_combinations(\\"7\\") # Returns: [\'p\', \'q\', \'r\', \'s\'] letter_combinations(\\"29\\") # Returns: [\'aw\', \'ax\', \'ay\', \'az\', \'bw\', \'bx\', \'by\', \'bz\', \'cw\', \'cx\', \'cy\', \'cz\'] ``` Additional Notes - Ensure to validate the input and handle cases where no digit is provided. - The order of the combinations in the output list does not matter. - Ensure that your solution is efficient even for the maximum allowed input length.","solution":"def letter_combinations(digits): Generates all possible letter combinations that the provided digit string could represent on a traditional telephone keypad. :param digits: A string of digits (\'2\'-\'9\') :return: A list of strings representing all possible letter combinations if not digits: return [] digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Prime Number Check with Customizable Divisors **Context**: You are developing a mathematical tool that includes functions for prime number validation. A prime number is traditionally defined as a natural number greater than 1 that has no positive divisors other than 1 and itself. However, for advanced analysis, you want to allow the flexibility to define custom divisors for which the primality check should be performed. **Task**: Implement the `is_custom_prime` function that checks if a given number is prime based on a customizable list of divisors. If a list of divisors is provided, the function should check divisibility only among those divisors. If no list is provided, it should check divisibility against all natural numbers up to the square root of the given number by default. # Function Signature: ```python def is_custom_prime(number: int, divisors: list = None) -> bool: number: an integer to be checked for primality divisors: a list of integer divisors to check against, defaults to None indicating traditional prime check returns: True if the number is prime under the given conditions, False otherwise ``` # Constraints: 1. `number` is a non-negative integer. 2. If `divisors` is provided, it will be a list containing unique positive integers. 3. Your function should handle edge cases such as the number being 0 or 1, and empty or None `divisors`. # Expected Input/Output: - **Input**: An integer and an optional list of divisors. - **Output**: A boolean indicating primality based on the provided conditions. **Example**: ```python # Traditional prime number check print(is_custom_prime(13)) # Output: True print(is_custom_prime(4)) # Output: False # Custom prime number check with specified divisors print(is_custom_prime(15, [2, 3, 5])) # Output: False (divisible by 3 and 5) print(is_custom_prime(11, [2, 3, 5])) # Output: True (not divisible by 2, 3, or 5) # Edge cases print(is_custom_prime(1)) # Output: False (1 is not a prime number) print(is_custom_prime(17, [])) # Output: True (empty divisor list implies no additional checks) ``` # Additional Notes: - Ensure your function performs efficiently, especially for higher values of `number`. - Handle edge cases carefully, including but not limited to cases where `number` is non-positive or when `divisors` are non-existent (None or empty).","solution":"def is_custom_prime(number: int, divisors: list = None) -> bool: Checks if the given number is prime based on a customizable list of divisors. If no list is provided, it checks against all numbers up to the square root of the given number. Parameters: number (int): The number to be checked. divisors (list, optional): List of integer divisors to check against. Returns: bool: True if the number is prime under the given conditions, False otherwise. if number <= 1: return False if divisors is None: if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number ** 0.5) + 1, 2): if number % i == 0: return False return True else: for divisor in divisors: if number % divisor == 0: return False return True"},{"question":"# Coding Task: Implement Linked List Intersection Background Given two singly linked lists, your task is to determine if they intersect and find the node where the intersection begins. The intersection of two linked lists means that the lists share a common node. Note that the intersection is defined by reference, not value. Function Signature ```python def get_intersection_node(headA, headB): Determines the node at which the intersection of two singly linked lists begins. headA : ListNode, the head node of the first linked list. headB : ListNode, the head node of the second linked list. Returns the ListNode where the intersection starts or None if there is no intersection. >>> class ListNode: ... def __init__(self, x): ... self.val = x ... self.next = None >>> # Creating two intersecting linked lists: >>> a1 = ListNode(1) >>> a2 = ListNode(2) >>> c1 = ListNode(3) >>> c2 = ListNode(4) >>> c3 = ListNode(5) >>> b1 = ListNode(6) >>> b2 = ListNode(7) >>> b3 = ListNode(8) >>> a1.next = a2 >>> a2.next = c1 >>> c1.next = c2 >>> c2.next = c3 >>> b1.next = b2 >>> b2.next = b3 >>> b3.next = c1 >>> get_intersection_node(a1, b1) <__main__.ListNode object at 0x...> # The intersection node with value 3 ``` Input 1. **headA**: The head node of the first singly linked list. 2. **headB**: The head node of the second singly linked list. Output * Returns the `ListNode` where the intersection begins or `None` if there is no intersection. Constraints * The number of nodes in both lists is in the range `[0, 10^4]`. * If the two linked lists have no intersection at all, return `None`. Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None # Creating two intersecting linked lists: a1 = ListNode(1) a2 = ListNode(2) c1 = ListNode(3) c2 = ListNode(4) c3 = ListNode(5) b1 = ListNode(6) b2 = ListNode(7) b3 = ListNode(8) a1.next = a2 a2.next = c1 c1.next = c2 c2.next = c3 b1.next = b2 b2.next = b3 b3.next = c1 print(get_intersection_node(a1, b1)) # Output = ListNode object with value 3 ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def get_intersection_node(headA, headB): Determines the node at which the intersection of two singly linked lists begins. :param headA: ListNode, the head node of the first linked list. :param headB: ListNode, the head node of the second linked list. :return: ListNode where the intersection starts or None if there is no intersection. if not headA or not headB: return None pointerA, pointerB = headA, headB # Traverse both lists. When reaching the end of a list, start at the head of the other list. while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA # Can be None or the intersection node"},{"question":"# Problem Statement Let\'s design a custom integer parsing function that behaves similarly to the built-in `int` function, but with some enhancements. The function should convert a string representation of a number into an integer, provided the string is in a valid format. # Function Signature ```python def custom_parse_int(s: str) -> int: ``` # Input * A single string `s`. # Output * An integer equivalent of the input string. # Constraints * The input must be a string representing a valid integer. If the string is formatted incorrectly, the function should raise appropriate exceptions: * `ValueError` if the string cannot be parsed as an integer. * `TypeError` if the input is not a string. # Valid Input Rules 1. The string may contain leading or trailing whitespace, which should be ignored. 2. The string can optionally start with a `+` or `-` sign. 3. All characters after stripping whitespace and removing the optional sign must be digits. # Examples ```python custom_parse_int(\\"123\\") => 123 custom_parse_int(\\" -456 \\") => -456 custom_parse_int(\\"+789\\") => 789 custom_parse_int(\\" 321\\") => 321 custom_parse_int(\\"42\\") => 42 ``` # Invalid Input Examples ```python custom_parse_int(\\"42abc\\") => raises ValueError custom_parse_int(\\"abc123\\") => raises ValueError custom_parse_int(123) => raises TypeError custom_parse_int(\\"\\") => raises ValueError ``` # Additional Information * Ensure to validate the input string format diligently. * Think about handling edge cases such as strings with only whitespace or invalid characters. * Raise exceptions that provide clear error messages indicating why the input is invalid. # Implementation Challenge Document the steps as comments within your code explaining how various edge cases and input validations are handled. Ensure that the function is robust and can handle irregular but valid input formats by sanitizing and parsing accurately.","solution":"def custom_parse_int(s: str) -> int: Converts a string representation of a number into an integer. Args: s: The string to parse. Returns: The integer representation of the string. Raises: TypeError: If the input is not a string. ValueError: If the string cannot be parsed as an integer. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") # Strip leading and trailing whitespace s = s.strip() if s == \\"\\": raise ValueError(\\"Input string cannot be empty\\") # Check if the remaining string after stripping is a valid integer string. if s[0] in \\"+-\\": if s[1:].isdigit(): return int(s) elif s.isdigit(): return int(s) raise ValueError(\\"Input string is not a valid integer\\")"},{"question":"# Matrix Diagonal Traverse **Context**: Given an `MxN` matrix, the goal is to return all elements of the matrix in a diagonal order. The diagonal order starts from the top-left corner of the matrix and alternates between moving upwards and downwards along the diagonals. **Objective**: Implement the function `find_diagonal_order(matrix: list[list[int]]) -> list[int]` that, given a matrix `matrix`, returns the elements of the matrix in a diagonal order. **Specifications**: * Input: A 2D list of integers `matrix` with dimensions `M x N` where 1 ≤ M, N ≤ 10^3. * Output: A list of integers representing the matrix in diagonal order. **Example**: ```python >>> find_diagonal_order([[ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> find_diagonal_order([[1, 2], [3, 4], [5, 6]]) [1, 2, 3, 5, 4, 6] ``` **Constraints**: 1. The function should efficiently handle the traversal for large matrices. 2. Consider edge cases like single row or single column matrices. **Performance**: - Targeted time complexity: ( O(M times N) ) - Targeted space complexity: ( O(M times N) ) **Notes**: - Do not use external libraries. - The function must handle empty matrices and return an empty list in such cases. # Implementation Your task is to complete the following function skeleton: ```python def find_diagonal_order(matrix: list[list[int]]) -> list[int]: Given an MxN matrix, return the elements in diagonal order. # Implement the function here pass ```","solution":"def find_diagonal_order(matrix: list[list[int]]) -> list[int]: Given an MxN matrix, return the elements in diagonal order. if not matrix or not matrix[0]: return [] M, N = len(matrix), len(matrix[0]) result = [] intermediate = [] for d in range(M + N - 1): intermediate.clear() r = 0 if d < N else d - N + 1 c = d if d < N else N - 1 while r < M and c > -1: intermediate.append(matrix[r][c]) r += 1 c -= 1 if d % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) return result"},{"question":"# Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). Function Signature `def level_order_traversal(root: TreeNode) -> List[List[int]]:` Input - `root`: the root node of the binary tree. Output - Returns a list of lists, where each sublist contains the values of the nodes at each level of the tree. Example Given binary tree [3, 9, 20, None, None, 15, 7]: ``` 3 / 9 20 / 15 7 ``` Return its level order traversal as: ```python >>> level_order_traversal(root) [ [3], [9, 20], [15, 7] ] ``` Constraints - The number of nodes in the tree is in the range [0, 2000]. - Each node\'s value is an integer in the range [-1000, 1000]. # Hints 1. Use a queue to keep track of nodes in the current level and process them level by level. 2. As you dequeue a node, enqueue its child nodes.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.pop(0) level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Objective: Create a program to determine all Armstrong numbers within a given range. An Armstrong number, in a given base `b`, is a number that is the sum of its own digits each raised to the power of the number of digits. # Requirements: 1. **Function Implementation**: * Write a function `is_armstrong_number(n: int, base: int) -> bool`. * Write a function `find_armstrong_numbers(start: int, end: int, base: int) -> list[int]`. 2. **Input**: * `start` (int): The starting number of the range (inclusive). * `end` (int): The ending number of the range (inclusive). * `base` (int): The numerical base used for calculations. 3. **Output**: * `is_armstrong_number`: Boolean indicating if a number is an Armstrong number. * `find_armstrong_numbers`: List of Armstrong numbers within the specified range (inclusive). # Constraints: * The base will be at least 2. * The start and end range will be positive integers, and start <= end. # Example: ```plaintext Input: start = 1, end = 500, base = 10 Output of `is_armstrong_number(153, 10)`: True Output of `find_armstrong_numbers(1, 500, 10)`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407] ``` # Performance Requirements: - Ensure the solution is optimized to handle the upper range efficiently, ideally O(n) for checking each number independently within the range. # Context: You are developing a feature for a mathematics learning application for elementary students. The feature should help students identify Armstrong numbers and understand their properties in different numerical bases. Develop your solution by implementing the functions below, ensuring they return correct and efficient results. ```python def is_armstrong_number(n: int, base: int) -> bool: # Your implementation here pass def find_armstrong_numbers(start: int, end: int, base: int) -> list[int]: # Your implementation here pass # Example usage: if __name__ == \\"__main__\\": print(is_armstrong_number(153, 10)) # Example usage for checking if a number is an Armstrong number print(find_armstrong_numbers(1, 500, 10)) # Example usage to find all Armstrong numbers within the specified range ```","solution":"def is_armstrong_number(n: int, base: int) -> bool: Check if a number n is an Armstrong number in a given base. digits = [] original_number = n while n > 0: digits.append(n % base) n = n // base num_digits = len(digits) sum_of_powers = sum(digit ** num_digits for digit in digits) return sum_of_powers == original_number def find_armstrong_numbers(start: int, end: int, base: int) -> list[int]: Find all Armstrong numbers within the given range [start, end] for the specified base. return [n for n in range(start, end + 1) if is_armstrong_number(n, base)]"},{"question":"# Coding Question Problem Statement You are provided with a function `is_palindrome` that checks whether a given string is a palindrome, ignoring any non-alphanumeric characters and case differences. Unfortunately, the given implementation is not optimized for large inputs. Write a function `optimized_is_palindrome` that accomplishes the same task but in a more efficient manner. The expected input and output formats, as well as constraints and limitations, are detailed below. Input - A string `s` of length `1 <= len(s) <= 10^6`, which needs to be checked for being a palindrome. Output - A boolean representing whether the given string is a palindrome. Constraints - Your solution should ignore all non-alphanumeric characters and perform case-insensitive comparison. - The solution needs to handle large inputs efficiently. Performance Requirement - The runtime complexity of your solution should be O(n). Examples 1. `optimized_is_palindrome(\\"A man, a plan, a canal: Panama\\")` should return `True`. 2. `optimized_is_palindrome(\\"race a car\\")` should return `False`. 3. `optimized_is_palindrome(\\" \\")` should return `True`. Function Signature ```python def optimized_is_palindrome(s: str) -> bool: Returns True if the string is a palindrome, False otherwise. pass ``` Additional Notes - Consider using two-pointer technique or regex to efficiently handle the requirements.","solution":"def optimized_is_palindrome(s: str) -> bool: Returns True if the string is a palindrome, False otherwise. This function ignores non-alphanumeric characters and is case-insensitive. left, right = 0, len(s) - 1 while left < right: # Move left index to the right while it\'s not alphanumeric while left < right and not s[left].isalnum(): left += 1 # Move right index to the left while it\'s not alphanumeric while left < right and not s[right].isalnum(): right -= 1 # Compare characters if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# Question: Encrypting and Decrypting Messages with a Simple Cipher **Context:** In a secure communication system, encrypting and decrypting messages are fundamental operations. You are involved in developing a function that uses a simple substitution cipher to encrypt and decrypt messages. **Problem Statement:** Write a function `cipher(text: str, shift: int, encrypt: bool) -> str` that either encrypts or decrypts a given message using a simple substitution cipher. * If `encrypt` is `True`, shift each letter in `text` by the given `shift` value to get the encrypted message. * If `encrypt` is `False`, shift each letter in `text` by the negative of the given `shift` value to get the decrypted message. **Requirements:** 1. The function should only shift alphabetic characters (\'a\'-\'z\' and \'A\'-\'Z\'). Non-alphabetic characters should remain unchanged. 2. Maintain the case of the original letters (i.e., keep lowercase letters as lowercase and uppercase letters as uppercase). 3. The shift value can be positive or negative. **Function Signature:** ```python def cipher(text: str, shift: int, encrypt: bool) -> str: pass ``` **Input:** * `text`: A string representing the input message to encrypt or decrypt. * `shift`: An integer representing the shift value for the cipher. * `encrypt`: A boolean indicating whether to encrypt (`True`) or decrypt (`False`) the message. **Output:** * A string representing the encrypted or decrypted message. **Constraints:** * The `shift` can be any integer, positive or negative. * The `text` can contain any character, but only alphabetic characters are shifted. **Examples:** ```python # Example 1: cipher(\\"Hello World!\\", 3, True) # Expected output: \\"Khoor Zruog!\\" # Example 2: cipher(\\"Khoor Zruog!\\", 3, False) # Expected output: \\"Hello World!\\" # Example 3: cipher(\\"abc xyz\\", 1, True) # Expected output: \\"bcd yza\\" # Example 4: cipher(\\"bcd yza\\", 1, False) # Expected output: \\"abc xyz\\" # Example 5: cipher(\\"abc xyz\\", -1, True) # Expected output: \\"zab wxy\\" ``` Ensure that your implementation handles both positive and negative shift values correctly and maintains the integrity of non-alphabetic characters.","solution":"def cipher(text: str, shift: int, encrypt: bool) -> str: result = [] # Adjust the shift for decryption if necessary if not encrypt: shift = -shift for char in text: if char.isalpha(): start = ord(\'A\') if char.isupper() else ord(\'a\') result.append(chr((ord(char) - start + shift) % 26 + start)) else: result.append(char) return \'\'.join(result)"},{"question":"# Rotate Array Right Given an array of integers, `arr`, and a non-negative integer, `k`, rotate the array to the right by `k` steps. # Input * `arr` - A list of integers where 1 ≤ length of `arr` ≤ 10^5. * `k` - A non-negative integer where 0 ≤ `k` ≤ 10^5. # Output * Return the array after rotating it to the right by `k` steps. # Constraints * Aim for an efficient solution considering both time and space complexity. # Example ```python def rotate_array(arr: list[int], k: int) -> list[int]: >>> rotate_array([1,2,3,4,5,6,7], 3) [5,6,7,1,2,3,4] >>> rotate_array([-1,-100,3,99], 2) [3,99,-1,-100] >>> rotate_array([1, 2], 4) [1,2] >>> rotate_array([], 1) [] >>> rotate_array([1, 2, 3], 0) [1,2,3] if not arr: # edge case for empty array return arr n = len(arr) k = k % n # if k is greater than length of array, take modulus return arr[-k:] + arr[:-k] if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Implementation Notes: * Consider edge cases, such as when `k` is zero, the array is empty, or `k` is larger than the length of the array. * Ensure your implementation handles large values of `k` efficiently.","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates the array to the right by k steps. Parameters: arr (list[int]): The input array. k (int): The number of steps to rotate the array. Returns: list[int]: The rotated array. if not arr: # edge case for empty array return arr n = len(arr) k = k % n # if k is greater than length of array, take modulus return arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment: Create a Robust Weather Data Analyzer Objective You are required to write Python functions to fetch and analyze weather data from a weather API using a city name. Your solution should be efficient, handle potential errors gracefully, and provide meaningful analytical insights. Requirements 1. **Function 1: `fetch_weather_data(city: str) -> dict`** - Input: - A string representing the city name. - Output: - A dictionary containing the raw weather data fetched from the weather API. - Constraints: - The city input should be a valid city name. - If the city name is invalid or data is not found, return an appropriate error message. 2. **Function 2: `analyze_weather_data(weather_data: dict) -> dict`** - Input: - A dictionary containing raw weather data. - Output: - A dictionary containing an analysis of the weather data including: - City Name - Temperature (in Celsius) - Weather Condition - Wind Speed (in km/h) - Humidity (percentage) - Recommendation (e.g., \\"Carry an umbrella\\" if rain is expected) Performance Requirements - Your solution should handle multiple API calls efficiently. - Handle any API delays or errors gracefully without breaking the program flow. Example ```python >>> weather_data = fetch_weather_data(\\"New York\\") >>> analysis = analyze_weather_data(weather_data) >>> print(analysis) { \\"City Name\\": \\"New York\\", \\"Temperature\\": 22.3, \\"Weather Condition\\": \\"Clear\\", \\"Wind Speed\\": 5.4, \\"Humidity\\": 55, \\"Recommendation\\": \\"Enjoy your day, the weather is clear.\\" } ``` Notes 1. Pay attention to possible API restrictions and handle them properly using appropriate error messages. 2. Ensure that your analysis handles missing data gracefully and include default values where necessary. Constraints - Ensure the city name passed is a valid string. - Handle timeout scenarios and missing data fields properly.","solution":"import requests API_KEY = \'YOUR_API_KEY\' # Replace with your actual OpenWeatherMap API key def fetch_weather_data(city: str) -> dict: Fetches weather data for the specified city from the OpenWeatherMap API. Params: - city (str): The city name to fetch weather data for. Returns: - dict: The raw weather data if the city is valid, otherwise an error message. url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric\\" try: response = requests.get(url) response.raise_for_status() # Raise HTTPError for bad responses (4xx and 5xx) return response.json() except requests.RequestException as e: return {\\"error\\": str(e)} def analyze_weather_data(weather_data: dict) -> dict: Analyzes the raw weather data and provides insights. Params: - weather_data (dict): The raw weather data. Returns: - dict: A dictionary containing analyzed weather details. if \\"error\\" in weather_data: return {\\"error\\": weather_data[\\"error\\"]} try: city_name = weather_data[\\"name\\"] temperature = weather_data[\\"main\\"][\\"temp\\"] weather_condition = weather_data[\\"weather\\"][0][\\"description\\"].capitalize() wind_speed = weather_data[\\"wind\\"][\\"speed\\"] * 3.6 # Convert m/s to km/h humidity = weather_data[\\"main\\"][\\"humidity\\"] # Simple recommendation based on weather condition if \'rain\' in weather_condition.lower(): recommendation = \\"Carry an umbrella.\\" elif \'clear\' in weather_condition.lower(): recommendation = \\"Enjoy your day, the weather is clear.\\" else: recommendation = \\"Have a nice day.\\" return { \\"City Name\\": city_name, \\"Temperature\\": temperature, \\"Weather Condition\\": weather_condition, \\"Wind Speed\\": wind_speed, \\"Humidity\\": humidity, \\"Recommendation\\": recommendation } except KeyError as e: return {\\"error\\": f\\"Missing data in the weather information: {str(e)}\\"}"},{"question":"# Coding Assessment Question Context A Turing machine is a mathematical model of computation. It reads input from a tape, which it processes according to a set of rules, and writes back on the tape. Your task is to simulate a very basic Turing machine that checks for a well-defined pattern in a string. Task Implement a function `check_pattern` that simulates a Turing machine to verify if a binary string satisfies the pattern: all \'1\'s must precede all \'0\'s. The Turing machine can only move one cell to the left or right at a time, read the current symbol, and must decide if the string is valid according to the pattern defined. Function Signature ```python def check_pattern(tape: str) -> bool: ``` Input - `tape` (string): The input binary string consisting of only \'0\'s and \'1\'s. Length of the string is `1 <= len(tape) <= 100`. Output - A boolean value: - `True`, if all \'1\'s in the string precede all \'0\'s. - `False`, otherwise. Example - Input: `tape = \\"1111000\\"` - Output: `True` - Explanation: All \'1\'s precede all \'0\'s. - Input: `tape = \\"00111\\"` - Output: `False` - Explanation: \'0\'s appear before \'1\'s. Constraints - Ensure that the function efficiently simulates the required checks. - Handle edge cases where the string is entirely \'0\'s or \'1\'s correctly. - Ensure that the function runs within the given constraints for large inputs. Write a robust function that simulates the described Turing machine operation to detect the specified pattern in a binary string.","solution":"def check_pattern(tape: str) -> bool: Check if all \'1\'s precede all \'0\'s in a binary string. Parameters: tape (str): Input binary string consisting of only \'0\'s and \'1\'s. Returns: bool: True if all \'1\'s precede all \'0\'s, False otherwise. # Start reading from the beginning of the tape found_zero = False for symbol in tape: if symbol == \'0\': found_zero = True elif symbol == \'1\' and found_zero: # If we find a \'1\' after encountering a \'0\', the pattern is incorrect return False return True"},{"question":"# Scenario You have been assigned a task to write a function for a common data structure problem involving linked lists. This type of problem frequently appears in technical interviews and can help you practice your skills in manipulating linked lists. # Problem Statement Write a function `reverse_linked_list_in_groups(head: ListNode, k: int) -> ListNode` that reverses the nodes of a linked list in groups of size `k` and returns the modified list\'s head. If the number of nodes is not a multiple of `k`, then the remaining nodes should remain as they are. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list_in_groups(head: ListNode, k: int) -> ListNode: pass ``` # Input Constraints - The linked list can be of any length. - `k` is a positive integer `1 <= k <= 1000`. # Output - The head of the modified linked list after reversing nodes in groups of `k`. # Example 1. **Input**: ```python # Linked list: 1 -> 2 -> 3 -> 4 -> 5, k = 2 # Output: 2 -> 1 -> 4 -> 3 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) result = reverse_linked_list_in_groups(head, 2) while result: print(result.val, \'->\', end=\' \') result = result.next # Expected Output: 2 -> 1 -> 4 -> 3 -> 5 -> ``` 2. **Input**: ```python # Linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8, k = 3 # Output: 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8)))))))) result = reverse_linked_list_in_groups(head, 3) while result: print(result.val, \'->\', end=\' \') result = result.next # Expected Output: 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 -> ``` # Notes - Pay special attention to maintaining the correct order and preserving the original relative order of nodes that do not fit into the last group of size `k`. - **Edge Cases**: - A linked list with fewer nodes than `k`. - An empty linked list. - A linked list where `k = 1`. # Performance Requirements The function should be efficient and operate within a reasonable time frame even for larger linked lists up to several thousands of nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list_in_groups(head: ListNode, k: int) -> ListNode: if k == 1 or not head: return head dummy = ListNode(0) dummy.next = head current = dummy next_group = dummy pre_group = dummy def has_k_nodes(cur, k): count = 0 while cur and count < k: cur = cur.next count += 1 return count == k while has_k_nodes(current.next, k): pre_group = current current = current.next next_group = current.next # Reverse k nodes tail = current prev = None for _ in range(k): next_temp = current.next current.next = prev prev = current current = next_temp pre_group.next = prev tail.next = current current = tail return dummy.next"},{"question":"# Question: Implement a Custom Sorting Algorithm You are required to implement a custom sorting algorithm that sorts a list of integers using a hybrid approach. The algorithm should utilize both the QuickSort and MergeSort techniques based on the size of the sublists. **Features to Implement**: 1. **Hybrid QuickSort and MergeSort**: For sublists smaller than a specified threshold (`THRESHOLD`), use MergeSort; for larger sublists, use QuickSort. 2. **Pivot Selection**: Implement a median-of-three strategy for pivot selection in QuickSort. The pivot should be the median of the first, middle, and last elements of the list. 3. **In-place Sorting**: Ensure the in-place sorting characteristic of QuickSort, but also support the stability provided by MergeSort for smaller sublists. # Function Definitions: ```python def hybrid_sort(arr: list[int], threshold: int) -> None: \'\'\' Sort a list of integers using a hybrid of QuickSort and MergeSort. Args: arr (list): List of integers to sort. threshold (int): The threshold below which to use MergeSort instead of QuickSort. Returns: None \'\'\' pass def quicksort(arr: list[int], low: int, high: int, threshold: int) -> None: \'\'\' QuickSort implementation with median-of-three pivot selection and hybrid with MergeSort. Args: arr (list): List of integers to sort. low (int): Lower index of the sublist to sort. high (int): Higher index of the sublist to sort. threshold (int): The threshold below which to switch to MergeSort. Returns: None \'\'\' pass def mergesort(arr: list[int]) -> list[int]: \'\'\' MergeSort implementation to sort sublists smaller than the threshold. Args: arr (list): List of integers to sort. Returns: list: A new sorted list. \'\'\' pass ``` Input Format: - For `hybrid_sort`: `(arr, threshold)` where `arr` is a list of integers to sort and `threshold` is the size below which MergeSort is used. Output Format: - Returns `None` (In-place sorting), but the input list `arr` will be sorted. Constraints: - Ensure that your sorting algorithm handles both small and large inputs efficiently. - The performance of QuickSort for larger sublists should be optimized by the median-of-three pivot strategy. - MergeSort should handle smaller sublists to take advantage of its stability and simple partitioning. Example Usage: ```python # Example list to sort arr = [38, 27, 43, 3, 9, 82, 10] # Using hybrid sort with a threshold of 4 hybrid_sort(arr, 4) # The sorted array print(arr) # Output should be: [3, 9, 10, 27, 38, 43, 82] ``` Explanation: 1. **Initial Call**: Start by calling `hybrid_sort(arr, threshold)`. 2. **Quicksort**: For sublists larger than `threshold`, implement QuickSort with pivot selection using the median-of-three rule. 3. **Mergesort**: For sublists with `size <= threshold`, implement MergeSort to leverage its stable characteristics. Your task is to implement these functions and ensure they work together to provide an efficient hybrid sorting algorithm.","solution":"def hybrid_sort(arr: list[int], threshold: int) -> None: if len(arr) <= 1: return quicksort(arr, 0, len(arr) - 1, threshold) def quicksort(arr: list[int], low: int, high: int, threshold: int) -> None: if high - low < threshold: sorted_subarray = mergesort(arr[low:high + 1]) for i in range(len(sorted_subarray)): arr[low + i] = sorted_subarray[i] return if low < high: pivot_index = median_of_three(arr, low, high) pivot_index = partition(arr, low, high, pivot_index) quicksort(arr, low, pivot_index - 1, threshold) quicksort(arr, pivot_index + 1, high, threshold) def median_of_three(arr: list[int], low: int, high: int) -> int: mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def partition(arr: list[int], low: int, high: int, pivot_index: int) -> int: pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def mergesort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = mergesort(arr[:mid]) right = mergesort(arr[mid:]) return merge(left, right) def merge(left: list[int], right: list[int]) -> list[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Coding Assessment Question # Generating and Filtering Sensor Readings You are asked to write a function that simulates the generation of sensor readings and then filters the readings based on predefined criteria. The task involves creating a list of random sensor readings, each consisting of a timestamp and a value, and then excluding readings that do not meet certain conditions. Here are the steps to follow: 1. Write a function that generates a list of sensor readings. Each reading should be a dictionary with two keys: \'timestamp\' and \'value\'. 2. Write a function to filter the list of sensor readings based on the following criteria: - The value of the reading must be within a specified range. - The timestamp must be within a certain timeframe. 3. Handle cases where the input criteria are invalid or where the generated list of readings is empty. Function Specifications 1. **generate_readings** - **Input**: Two integers specifying the number of readings to generate and the seed for random number generation. - **Output**: A list of dictionaries, each containing a \'timestamp\' and a \'value\'. - **Constraints**: - The number of readings should be a positive integer. - The seed should ensure reproducibility of the generated readings. 2. **filter_readings** - **Input**: A list of sensor readings, a value range (min and max), and a timeframe (start and end timestamps). - **Output**: A filtered list of sensor readings that meet the given criteria. - **Constraints**: - Ensure the value range and timeframe are valid. - Handle empty input reading lists gracefully. - **Performance Requirements**: - Implementations should have a time complexity of O(n). Example ```python import random import time def generate_readings(num_readings, seed): random.seed(seed) readings = [] current_time = int(time.time()) for _ in range(num_readings): timestamp = current_time - random.randint(0, 86400) # Random timestamp within the last 24 hours value = random.uniform(10.0, 100.0) # Random value between 10.0 and 100.0 readings.append({\'timestamp\': timestamp, \'value\': value}) return readings def filter_readings(readings, value_range, time_frame): min_value, max_value = value_range start_time, end_time = time_frame if not readings: raise ValueError(\\"The list of readings is empty.\\") if min_value >= max_value: raise ValueError(\\"Invalid value range. Min value should be less than max value.\\") if start_time >= end_time: raise ValueError(\\"Invalid time frame. Start time should be less than end time.\\") filtered_readings = [ reading for reading in readings if min_value <= reading[\'value\'] <= max_value and start_time <= reading[\'timestamp\'] <= end_time ] return filtered_readings # Example Usage num_readings = 10 seed = 42 readings = generate_readings(num_readings, seed) filtered = filter_readings(readings, value_range=(20.0, 80.0), time_frame=(1625097600, 1625184000)) print(filtered) # Output: List of filtered readings ```","solution":"import random import time def generate_readings(num_readings, seed): Generate a list of sensor readings. Each reading consists of a dictionary with \'timestamp\' and \'value\'. Args: - num_readings (int): Number of readings to generate. - seed (int): Seed for random number generation. Returns: - List[Dict]: A list of sensor readings. random.seed(seed) readings = [] current_time = int(time.time()) for _ in range(num_readings): timestamp = current_time - random.randint(0, 86400) # Random timestamp within the last 24 hours value = random.uniform(10.0, 100.0) # Random value between 10.0 and 100.0 readings.append({\'timestamp\': timestamp, \'value\': value}) return readings def filter_readings(readings, value_range, time_frame): Filter the list of sensor readings based on value range and timeframe. Args: - readings (List[Dict]): List of sensor readings. - value_range (Tuple[float, float]): A tuple (min_value, max_value) representing the value range. - time_frame (Tuple[int, int]): A tuple (start_time, end_time) representing the timeframe. Returns: - List[Dict]: Filtered list of sensor readings. Raises: - ValueError: If the input criteria are invalid or the reading list is empty. min_value, max_value = value_range start_time, end_time = time_frame if not readings: raise ValueError(\\"The list of readings is empty.\\") if min_value >= max_value: raise ValueError(\\"Invalid value range. Min value should be less than max value.\\") if start_time >= end_time: raise ValueError(\\"Invalid time frame. Start time should be less than end time.\\") filtered_readings = [ reading for reading in readings if min_value <= reading[\'value\'] <= max_value and start_time <= reading[\'timestamp\'] <= end_time ] return filtered_readings"},{"question":"# Context You are tasked with creating a utility to manage and filter a collection of records. Each record represents a person and their attributes, including their name, age, and email. # Task Implement a Python class to manage a collection of person records. Your class should support adding new records, removing records by name, and filtering records based on a minimum age criterion. # Requirements - Class Name: `PersonRecords` - **Attributes**: - `records`: A dictionary to store person records with names as keys. - **Methods**: - `add_person(name, age, email)`: Adds a new person to the records. - `remove_person(name)`: Removes a person by their name from the records. - `filter_by_min_age(min_age)`: Filters and returns a list of names of people whose age is greater than or equal to `min_age`. # Example ```python # Example usage pr = PersonRecords() pr.add_person(\\"Alice\\", 30, \\"alice@example.com\\") pr.add_person(\\"Bob\\", 25, \\"bob@example.com\\") pr.add_person(\\"Charlie\\", 35, \\"charlie@example.com\\") # Filter by minimum age print(pr.filter_by_min_age(30)) # Output should be: [\'Alice\', \'Charlie\'] pr.remove_person(\\"Alice\\") # After removal print(pr.filter_by_min_age(30)) # Output should be: [\'Charlie\'] ``` # Notes: - Ensure proper handling of edge cases such as adding a person with an existing name, removing a non-existent person, and filtering with no records present. - Maintain code readability and efficiency as the number of records can be large. **Implement the Class Below:** ```python class PersonRecords: def __init__(self): self.records = {} def add_person(self, name, age, email): # Add new person logic here def remove_person(self, name): # Remove person logic here def filter_by_min_age(self, min_age): # Filter by minimum age logic here ```","solution":"class PersonRecords: def __init__(self): self.records = {} def add_person(self, name, age, email): Adds a new person to the records. If the person already exists, their record gets updated. self.records[name] = {\'age\': age, \'email\': email} def remove_person(self, name): Removes a person by their name from the records. If the person does not exist, this operation does nothing. if name in self.records: del self.records[name] def filter_by_min_age(self, min_age): Filters and returns a list of names of people whose age is greater than or equal to min_age. return [name for name, info in self.records.items() if info[\'age\'] >= min_age]"},{"question":"Coding Question: Longest Substring with Constraints # Context: Analyzing substrings within a string while adhering to specific constraints is a fundamental problem in string processing. Such applications are often encountered in tasks involving text manipulation, data compression, and pattern recognition. # Problem Statement: Implement a function `longest_substring_with_constraints(s: str, k: int) -> int` that returns the length of the longest substring of the given string `s` in which no more than `k` distinct characters appear. Input: - `s`: A string consisting of lowercase alphabetical characters. - `k`: An integer (0 <= k <= 26) representing the maximum number of distinct characters allowed in the substring. Output: - Returns an integer indicating the length of the longest substring that satisfies the constraints. # Constraints: - The length of the input string `s` can be up to 10000 characters. - If `k` is 0, the result should be 0 (as no substring can meet the condition). - If `k` exceeds the number of distinct characters in `s`, return the length of `s`. # Examples: Example 1: ```python s = \\"abcba\\" k = 2 assert longest_substring_with_constraints(s, 2) == 3 # \\"bcb\\" has exactly 2 distinct characters ``` Example 2: ```python s = \\"aabbcc\\" k = 1 assert longest_substring_with_constraints(s, 1) == 2 # \\"aa\\", \\"bb\\", or \\"cc\\", each has 1 distinct character ``` # Notes: 1. Consider sliding window or two-pointer techniques to optimize the solution. 2. Ensure the function handles various edge cases such as an empty string or low values of `k`. 3. Pay attention to the efficiency with respect to the input size constraint.","solution":"def longest_substring_with_constraints(s: str, k: int) -> int: if k == 0: return 0 if len(set(s)) <= k: return len(s) left = 0 max_length = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem: You are tasked with creating a custom sorting function for a list of words based on the lengths of the words, followed by alphabetic order in case of ties in length. # Objective: Implement the function `custom_sort(words: List[str]) -> List[str]` that takes a list of words as input and returns a new list of words sorted primarily by word length and secondarily by alphabetical order. # Function Signature: ```python def custom_sort(words: List[str]) -> List[str]: ``` # Input: - `words`: A list of strings representing the words to sort. (1 <= len(words) <= 1000, 1 <= len(words[i]) <= 100) # Output: - A list of strings sorted first by word length in ascending order, and for words with the same length, sorted alphabetically. # Example: ```python words = [\'apple\', \'bat\', \'banana\', \'pear\', \'dog\', \'cat\'] output = custom_sort(words) # Expected output: # [\'bat\', \'cat\', \'dog\', \'pear\', \'apple\', \'banana\'] ``` # Constraints: - Each word will consist only of lowercase English letters. - The input list can have duplicate words. # Guidance: In your function: 1. Use a sorting algorithm that allows for multiple criteria. 2. First sort the words by their lengths. 3. In case of words with the same length, sort them lexicographically. 4. Return the sorted list of words. You can use Python\'s built-in sorting capabilities with a custom key to achieve this.","solution":"from typing import List def custom_sort(words: List[str]) -> List[str]: Sorts the list of words primarily by word length and secondarily by alphabetical order. Args: words (List[str]): A list of words to sort. Returns: List[str]: A new list of words sorted primarily by length and secondarily alphabetically. # Sort the words using a tuple (len(word), word) to handle both conditions return sorted(words, key=lambda word: (len(word), word))"},{"question":"# Problem Statement You are given a unsorted list of integers and a target integer. Implement the linear search algorithm to find the index of the target integer in the list. If the target is not found, return -1. # Input Format * **arr**: An unsorted list of integers (1 ≤ len(arr) ≤ 10^6) * **x**: An integer to search within the list (0 ≤ |x| ≤ 10^9) # Output Format * Return the index of the target integer if found, otherwise return -1. # Example ```python >>> linear_search([4, 2, 1, 7, 8, 3, 5], 7) 3 >>> linear_search([-10, -30, 15, -5, 25, 10], -5) 3 >>> linear_search([34, 78, 90, 56, 12], 100) -1 >>> linear_search([5, 8, 9, 2, 4, 7], 4) 4 >>> linear_search([10, 20, 30, 40, 50], 20) 1 ``` # Constraints * The given list is unsorted. * You should not use any built-in search functions like `list.index`. * Expected time complexity is O(n). # Performance Requirements Your implementation should be able to handle large lists up to length 10^6. # Hints 1. Traverse the list element by element. 2. Compare each element with the target integer. 3. Return the index immediately if a match is found.","solution":"def linear_search(arr, x): Perform a linear search to find the index of x in arr. Parameters: arr (list): Unsorted list of integers. x (int): Target integer to search. Returns: int: The index of x if found, otherwise -1. for index, value in enumerate(arr): if value == x: return index return -1"},{"question":"# Common Integer Divisor Problem You are given two lists of integers, `A` and `B`. Your task is to determine the highest common integer divisor present in both lists. The divisor must be a number that appears as an element in both lists. Input: - List `A` of integers (1 ≤ len(A) ≤ 100, 1 ≤ A[i] ≤ 1000) - List `B` of integers (1 ≤ len(B) ≤ 100, 1 ≤ B[i] ≤ 1000) Output: - The highest integer that appears in both lists, or `-1` if there is no common integer. # Function Signature ```python def find_common_divisor(A: List[int], B: List[int]) -> int: pass ``` # Requirements 1. Consider that lists may contain duplicate values and handle such cases gracefully. 2. Ensure that your solution is efficient in finding and comparing elements between the two lists. 3. Handle edge cases where either list might be very small or where there are no common elements. # Constraints - The lists contain integer values within the range 1 to 1000. - Both lists have a length between 1 and 100. # Example The function call: ```python find_common_divisor([10, 15, 20, 25], [5, 10, 15, 30]) ``` should return: ``` 15 ``` The function call: ```python find_common_divisor([9, 13, 19], [8, 14, 20]) ``` should return: ``` -1 ``` # Solution Explanation For the first example, the integers 10 and 15 appear in both lists, with 15 being the highest common integer divisor. For the second example, there are no common integers in both lists, so the function returns `-1`.","solution":"def find_common_divisor(A, B): Returns the highest common integer present in both lists A and B. If there is no common integer, returns -1. # Convert lists to sets to eliminate duplicates and for efficient comparison set_A = set(A) set_B = set(B) # Find the common elements in both sets common_elements = set_A.intersection(set_B) # If there are no common elements, return -1 if not common_elements: return -1 # Return the highest common element return max(common_elements)"},{"question":"# Coding Assessment Question Question: As part of a text analysis tool, you are required to implement a feature that identifies the longest run of consecutive identical characters in a given string and returns the length of that run. Write a function that performs this task. Function Details: * **Function Name**: `longest_run` * **Input**: A single argument `text` which is a string. * **Output**: An integer representing the length of the longest consecutive run of identical characters. * The input string should be treated as case-sensitive. * **Constraints**: * The length of the input string will not exceed 1000 characters. * The input string may be empty. * **Performance Requirement**: The function should run efficiently within O(n) time complexity where n is the length of the string. Examples: ```python >>> print(longest_run(\\"aabbbccddddeeeee\\")) 5 >>> print(longest_run(\\"abcd\\")) 1 >>> print(longest_run(\\"AaaBBbCc\\")) 2 >>> print(longest_run(\\"\\")) 0 ``` Ensure your implementation handles edge cases such as an empty string gracefully. Include error handling for non-string inputs and document your code appropriately.","solution":"def longest_run(text): Returns the length of the longest consecutive run of identical characters in the given string `text`. Parameters: text (str): the input string to be analyzed. Returns: int: the length of the longest consecutive run of identical characters. if not isinstance(text, str): raise ValueError(\\"Input must be a string\\") max_run_length = 0 current_run_length = 0 previous_char = None for char in text: if char == previous_char: current_run_length += 1 else: current_run_length = 1 previous_char = char if current_run_length > max_run_length: max_run_length = current_run_length return max_run_length"},{"question":"# Graph Data Structure with DFS for Component Counting You\'re working on a social network analysis where you need to determine the number of distinct user groups. Each user group is a subset of users who are all directly or indirectly connected with each other through friendships. Using a graph data structure, implement a solution to count these distinct user groups. Each user is a node, and each friendship is an undirected edge between two nodes. Given a list of friendships, determine the total number of connected components (user groups) in the graph. # Requirements * Implement the function `count_user_groups(friendships: List[Tuple[int, int]], n: int) -> int` * **Input**: - `friendships`: A list of tuples representing the friendships between users. Each tuple `(u, v)` indicates a friendship between user `u` and user `v`. - `n`: An integer representing the total number of users, labeled from `0` to `n-1`. * **Output**: - An integer representing the number of distinct user groups. # Constraints 1. `0 <= n <= 10^4` 2. `0 <= len(friendships) <= 10^5` 3. Each friendship `(u, v)` where `0 <= u, v < n` # Example ```python count_user_groups([(0, 1), (1, 2), (3, 4)], 5) ``` Output: `3` This example contains three user groups: {0, 1, 2}, {3, 4}, and {5} (where user `5` has no friends). # Implementation Guide 1. **Graph Construction**: Represent the graph using an adjacency list where each node points to its list of neighbors. 2. **DFS Traversal**: Implement Depth-First Search (DFS) to explore all nodes connected to a starting node. Track visited nodes to prevent revisiting. 3. **Count Components**: Iterate through all nodes, and for each unvisited node, initiate a DFS to mark all reachable nodes as visited, incrementing the component count. It\'s essential to ensure optimal performance to handle the upper limits of input size efficiently. Happy coding!","solution":"from typing import List, Tuple def count_user_groups(friendships: List[Tuple[int, int]], n: int) -> int: def dfs(node: int): for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True dfs(neighbor) adj_list = [[] for _ in range(n)] visited = [False] * n for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) num_groups = 0 for user in range(n): if not visited[user]: num_groups += 1 visited[user] = True dfs(user) return num_groups"},{"question":"# Customer Feedback Analyzer You are tasked with developing a feature for a customer feedback application where you need to analyze customer reviews and classify their sentiments as \\"positive\\", \\"negative\\", or \\"neutral\\". For simplicity, you are provided a list of predefined words that determine the sentiment of the review. Requirements: 1. **Function Definition**: ```python def classify_reviews(reviews: list, positive_words: list, negative_words: list) -> dict: ``` 2. **Input**: * `reviews` (list): List of strings, where each string represents a customer\'s review. * `positive_words` (list): List of strings, where each string is a word assumed to have a positive sentiment. * `negative_words` (list): List of strings, where each string is a word assumed to have a negative sentiment. 3. **Output**: * Return a dictionary where each key is a review from the input list and the value is one of the strings: \\"positive\\", \\"negative\\", or \\"neutral\\", indicating the sentiment of the review. 4. **Constraints**: * A review is classified as \\"positive\\" if it contains more words from `positive_words` than from `negative_words`. * A review is classified as \\"negative\\" if it contains more words from `negative_words` than from `positive_words`. * A review is classified as \\"neutral\\" if it contains an equal number of words from both `positive_words` and `negative_words`, or contains no words from either list. * Ignore case when matching words (e.g., \\"Good\\" and \\"good\\" should be considered the same). 5. **Performance Requirements**: * The function should handle up to 1000 reviews reasonably efficiently. * Optimize for readability and maintainability. Example: ```python reviews = [ \\"The product is great and I love it!\\", \\"This is the worst experience I\'ve ever had.\\", \\"It was okay, nothing special.\\" ] positive_words = [\\"great\\", \\"love\\", \\"fantastic\\", \\"excellent\\"] negative_words = [\\"worst\\", \\"terrible\\", \\"bad\\", \\"hate\\"] result = classify_reviews(reviews, positive_words, negative_words) # The \'result\' dictionary might look like: # { # \\"The product is great and I love it!\\": \\"positive\\", # \\"This is the worst experience I\'ve ever had.\\": \\"negative\\", # \\"It was okay, nothing special.\\": \\"neutral\\" # } ``` Implementation Tips: * Use string methods to handle case insensitivity. * Ensure the function processes each review independently. * Consider edge cases such as reviews with no words or only neutral sentiment words.","solution":"def classify_reviews(reviews: list, positive_words: list, negative_words: list) -> dict: Classify the sentiments of customer reviews. Parameters: reviews (list): List of customer reviews. positive_words (list): List of words with positive sentiment. negative_words (list): List of words with negative sentiment. Returns: dict: Dictionary with reviews as keys and sentiment (\\"positive\\", \\"negative\\", or \\"neutral\\") as values. sentiment_dict = {} # Convert positive and negative words to set for quick look-up and case insensitivity positive_set = set(word.lower() for word in positive_words) negative_set = set(word.lower() for word in negative_words) for review in reviews: review_lower = review.lower() review_words = review_lower.split() positive_count = len([word for word in review_words if word in positive_set]) negative_count = len([word for word in review_words if word in negative_set]) if positive_count > negative_count: sentiment = \\"positive\\" elif negative_count > positive_count: sentiment = \\"negative\\" else: sentiment = \\"neutral\\" sentiment_dict[review] = sentiment return sentiment_dict"},{"question":"# Coding Assessment: Implementing a Binary Search Tree with Custom Operations Context You are tasked to create and manage a Binary Search Tree (BST) that supports specific operations. Your goal is to implement the BST and provide functionalities for insertion, searching, and finding the minimum and maximum values in the tree. Requirements Implement the following classes and functions: 1. **class TreeNode**: * A class representing a node in the binary search tree. * Attributes: * `val`: An integer value of the node. * `left`: A reference to the left child node. * `right`: A reference to the right child node. 2. **class BinarySearchTree**: * A class for the binary search tree. * **insert(root: TreeNode, val: int) -> TreeNode**: * Inserts a new value into the BST. * If the root is `None`, create a new `TreeNode` with the given value. * Returns the root node after insertion. * **search(root: TreeNode, val: int) -> bool**: * Searches for a value in the BST. * Returns `True` if the value is found, otherwise `False`. * **find_min(root: TreeNode) -> int**: * Finds the minimum value in the BST. * Assumes the BST is non-empty. * Returns the minimum value. * **find_max(root: TreeNode) -> int**: * Finds the maximum value in the BST. * Assumes the BST is non-empty. * Returns the maximum value. Input * You will be provided initial insertions into the BST followed by a series of operations (`insert`, `search`, `find_min`, `find_max`). * Example: ```python initial_values = [20, 10, 30, 5, 15] operations = [ (\\"insert\\", 25), (\\"search\\", 10), (\\"search\\", 100), (\\"find_min\\",), (\\"find_max\\",) ] ``` Output * For each operation, print the result as follows: * For `insert`, print `Inserted {val}`. * For `search`, print `Found {val}` or `Not Found {val}`. * For `find_min`, print the minimum value. * For `find_max`, print the maximum value. Example ```python # Example provided inputs: initial_values = [20, 10, 30, 5, 15] operations = [ (\\"insert\\", 25), (\\"search\\", 10), (\\"search\\", 100), (\\"find_min\\",), (\\"find_max\\",) ] # Expected Output: Inserted 25 Found 10 Not Found 100 5 30 ``` Ensure your implementation correctly handles the operations and provides the correct output for each case.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def insert(self, root, val): if root is None: return TreeNode(val) if val < root.val: root.left = self.insert(root.left, val) else: root.right = self.insert(root.right, val) return root def search(self, root, val): if root is None or root.val == val: return root is not None if val < root.val: return self.search(root.left, val) return self.search(root.right, val) def find_min(self, root): current = root while current.left is not None: current = current.left return current.val def find_max(self, root): current = root while current.right is not None: current = current.right return current.val def execute_operations(initial_values, operations): bst = BinarySearchTree() root = None for val in initial_values: root = bst.insert(root, val) results = [] for operation in operations: if operation[0] == \\"insert\\": val = operation[1] root = bst.insert(root, val) results.append(f\\"Inserted {val}\\") elif operation[0] == \\"search\\": val = operation[1] found = bst.search(root, val) if found: results.append(f\\"Found {val}\\") else: results.append(f\\"Not Found {val}\\") elif operation[0] == \\"find_min\\": min_val = bst.find_min(root) results.append(f\\"{min_val}\\") elif operation[0] == \\"find_max\\": max_val = bst.find_max(root) results.append(f\\"{max_val}\\") return results"},{"question":"# Find the Intersection of Two Arrays Write a function `find_intersection` that finds the intersection of two arrays. Function Signature ```python def find_intersection(arr1: list, arr2: list) -> list: pass ``` # Input - Two arrays `arr1` and `arr2` of integers. # Output - A sorted list of integers that represents the intersection of `arr1` and `arr2`. # Constraints - Elements in the arrays are not necessarily unique. - The result list should contain each element only once, even if it appears multiple times in the inputs. - The elements in the result list should be sorted in ascending order. # Example ```python # Example inputs arr1 = [1, 2, 2, 3, 4] arr2 = [2, 3, 5] # Example output result = find_intersection(arr1, arr2) print(result) # Output: [2, 3] ``` **Note**: Ensure the solution efficiently handles the intersection operation and sorting. # Additional Requirements - Handle edge cases such as empty arrays where an empty list should be returned. - Optimize for time complexity to handle larger inputs efficiently. - Provide error handling for inputs that are not correctly structured (e.g., non-list inputs).","solution":"def find_intersection(arr1: list, arr2: list) -> list: Finds the intersection of two arrays and returns a sorted list of unique elements. Parameters: arr1 (list): The first array of integers. arr2 (list): The second array of integers. Returns: list: Sorted list of integers representing the intersection of the two arrays. if not isinstance(arr1, list) or not isinstance(arr2, list): raise ValueError(\\"Both inputs should be lists.\\") set1 = set(arr1) set2 = set(arr2) intersection = set1.intersection(set2) return sorted(intersection)"},{"question":"DNA Sequence Complement To assess your understanding of string manipulation and basic biological computation, your task is to create a function that generates the complementary DNA strand for a given DNA sequence. In a DNA sequence, - \'A\' (Adenine) pairs with \'T\' (Thymine) - \'T\' (Thymine) pairs with \'A\' (Adenine) - \'C\' (Cytosine) pairs with \'G\' (Guanine) - \'G\' (Guanine) pairs with \'C\' (Cytosine) Given a string representing the DNA sequence, the function should return a new string with the complementary bases. # Function Signature ```python def dna_complement(dna_sequence: str) -> str: ``` # Parameters - `dna_sequence` (str): A string representing the DNA sequence, consisting only of characters \'A\', \'T\', \'C\', and \'G\'. The input sequence will be uppercase and non-empty. # Returns - `str`: The complement of the given DNA sequence. # Constraints - The DNA sequence will contain only \'A\', \'T\', \'C\', and \'G\'. - The input sequence will be a non-empty string. # Example Usage ```python >>> dna_complement(\\"ATCG\\") \'TAGC\' >>> dna_complement(\\"GCTA\\") \'CGAT\' >>> dna_complement(\\"ACTGACTG\\") \'TGACTGAC\' ``` Implement the function following these clear specifications and ensure that all pairs are correctly matched to generate the complementary DNA strand.","solution":"def dna_complement(dna_sequence: str) -> str: Returns the complement of a given DNA sequence. Parameters: dna_sequence (str): A string representing the DNA sequence, consisting only of characters \'A\', \'T\', \'C\', and \'G\'. Returns: str: The complement of the given DNA sequence. # A dictionary to map each base to its complement complement = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} # Generate the complement sequence complement_sequence = \\"\\".join(complement[base] for base in dna_sequence) return complement_sequence"},{"question":"# Coding Assessment Question Scenario Your company is working on an e-commerce application, and one of the requirements is to find the most purchased item in a list of transactions. However, some of the items might be excluded from this list based on specific criteria. Given this constraint, you need to implement an efficient algorithm to find the most purchased item, excluding certain items. Task Implement a function `most_purchased_item` that, given a list of transactions and a list of excluded items, returns the most purchased item excluding the specified items. If there is no valid item, raise a `ValueError` with the message \\"No valid item found.\\" Function Signature ```python def most_purchased_item(transactions: List[str], exclude_list: List[str]) -> str: ``` Input * `transactions (List[str])`: A list of strings representing the transactions. Each string represents an item purchased. * `exclude_list (List[str])`: A list of strings representing items that should be excluded from the count. Output * Returns the most purchased item (str) from the `transactions` list excluding the items in `exclude_list`. * If there is no valid item, raise a `ValueError` with the message \\"No valid item found.\\" Constraints * The `transactions` list has at least 1 and at most 1000 items. * The `exclude_list` has at least 0 and at most 100 items. * Each item in the `transactions` list is a non-empty string up to 50 characters. * Each item in the `exclude_list` is a non-empty string up to 50 characters. Example ```python You have the list of transactions as follows: [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] And the list of excluded items: [\\"banana\\"] The function call to find the most purchased item should return \\"apple\\", as it appears 3 times in the transactions excluding \\"banana\\". transactions = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] exclude_list = [\\"banana\\"] item = most_purchased_item(transactions, exclude_list) print(item) # Output should be \\"apple\\" ``` Notes * Focus on the correctness and efficiency of the solution. * Ensure to handle potential edge cases, including empty result sets when all items are excluded.","solution":"from typing import List from collections import Counter def most_purchased_item(transactions: List[str], exclude_list: List[str]) -> str: Returns the most purchased item from the transactions list excluding the items in exclude_list. Raises ValueError if no valid item is found. # Convert exclude list to a set for faster lookup exclude_set = set(exclude_list) # Filter out excluded items and count occurrences of valid items filtered_transactions = [item for item in transactions if item not in exclude_set] if not filtered_transactions: raise ValueError(\\"No valid item found\\") # Use a Counter to determine the most common item count = Counter(filtered_transactions) most_purchased = count.most_common(1)[0][0] return most_purchased"},{"question":"# Problem Description: Extend the functionality of the `Deque` data structure by implementing a method that retrieves the `n`-th element from the front and another method that retrieves the `n`-th element from the back of the deque. **Task**: Implement the following methods: 1. `get_nth_from_front(self, n: int) -> Any` 2. `get_nth_from_back(self, n: int) -> Any` ```python def get_nth_from_front(self, n: int) -> Any: Retrieves the n-th element from the front of the deque. Time complexity: O(n) @param n: The index (0-based) from the front. @returns: The n-th element from the front, or None if the index is out of bounds. Example: >>> our_deque = Deque([1, 2, 3, 4, 5]) >>> our_deque.get_nth_from_front(2) 3 >>> our_deque.get_nth_from_front(0) 1 >>> our_deque.get_nth_from_front(10) None def get_nth_from_back(self, n: int) -> Any: Retrieves the n-th element from the back of the deque. Time complexity: O(n) @param n: The index (0-based) from the back. @returns: The n-th element from the back, or None if the index is out of bounds. Example: >>> our_deque = Deque([1, 2, 3, 4, 5]) >>> our_deque.get_nth_from_back(1) 4 >>> our_deque.get_nth_from_back(0) 5 >>> our_deque.get_nth_from_back(10) None ``` **Input**: - An integer `n` for both methods. **Output**: - The `n`-th element from the front or from the back of the deque, or `None` if the index is out of bounds. # Constraints: - The deque should be properly implemented with basic operations working as intended. - The `get_nth_from_front` method should return the n-th element when traversing from the front. - The `get_nth_from_back` method should return the n-th element when traversing from the back. - Handle edge cases where `n` is greater than or equal to the length of the deque. # Example Consider a sample usage below: ```python # Deque initialization d = Deque([10, 20, 30, 40, 50]) # Retrieving elements from the front print(d.get_nth_from_front(0)) # Output: 10 print(d.get_nth_from_front(3)) # Output: 40 print(d.get_nth_from_front(5)) # Output: None # Retrieving elements from the back print(d.get_nth_from_back(0)) # Output: 50 print(d.get_nth_from_back(2)) # Output: 30 print(d.get_nth_from_back(7)) # Output: None ``` **Notes**: - Ensure proper iteration through the deque for retrieving the elements. - Handle both empty and populated deques effectively. - Test for various values of `n` for accurate retrieval.","solution":"from collections import deque from typing import Any class Deque: def __init__(self, items=None): self.deque = deque(items if items is not None else []) def get_nth_from_front(self, n: int) -> Any: if n < 0 or n >= len(self.deque): return None return self.deque[n] def get_nth_from_back(self, n: int) -> Any: if n < 0 or n >= len(self.deque): return None return self.deque[-(n + 1)]"},{"question":"You are required to implement a method in the given LinkedList code that removes all consecutive nodes that sum up to zero. The objective of the new method is to ensure that any sequence of nodes within the list that, when summed, equals zero, should be removed. # Task Implement a method `remove_zero_sum_sublists(self) -> None` in the `LinkedList` class which removes all consecutive nodes that sum up to zero. # Input This implementation does not require any input as it operates on the `LinkedList` instance itself. The list will already contain nodes added using an `append` method. # Output The resulting linked list after removing sequences of nodes that sum to zero. This will involve modifying the linked list structure internally, and the method will not produce an explicit return value. # Constraints * The linked list can contain both positive and negative integers. * The nodes should be removed in place, and you cannot use additional complex data structures (like another list). * You may assume that the list contains at least one node that does not need to be removed. # Example Consider the following sequence of events: ```python l = LinkedList() l.append(1) l.append(2) l.append(-3) l.append(3) l.append(1) print(l.to_list()) # Output: [1, 2, -3, 3, 1] # Before removal, linked list looks like: # [1] -> [2] -> [-3] -> [3] -> [1] l.remove_zero_sum_sublists() print(l.to_list()) # Output: [3, 1] # After removal, linked list looks like: # [3] -> [1] ``` # Tips 1. You might find it useful to use a dictionary to keep track of prefix sums and their corresponding nodes. 2. Traverse the list from head to end, compute the prefix sum and utilize it to find and remove zero-sum sublists. Implement your solution inside the `LinkedList` class below.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def remove_zero_sum_sublists(self): dummy = Node(0) dummy.next = self.head prefix_sum = 0 sum_dict = {0: dummy} current = self.head while current: prefix_sum += current.value if prefix_sum in sum_dict: node = sum_dict[prefix_sum].next sum = prefix_sum while node != current: sum += node.value del sum_dict[sum] node = node.next sum_dict[prefix_sum].next = current.next else: sum_dict[prefix_sum] = current current = current.next self.head = dummy.next"},{"question":"# Graph Cycle Detection Challenge You are given a directed graph with `n` nodes and `m` edges. Your task is to implement a function that determines whether the graph contains a cycle. # Function Signature: ```python def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: ``` # Input: - An integer `n`, the number of nodes in the graph. - A list of `m` tuples `edges`, where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. - Vertices are numbered from `0` to `n-1`. # Output: - A boolean value `True` if the graph contains a cycle, and `False` otherwise. # Example: Input: ```python n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] ``` Output: ```python True ``` Input: ```python n = 3 edges = [(0, 1), (1, 2)] ``` Output: ```python False ``` # Constraints: - 1 <= n, m <= 10^5 **Note**: - You can use Depth-First Search (DFS) or any other algorithm suitable for cycle detection in directed graphs. - Ensure your solution is optimized for large inputs.","solution":"def has_cycle(n: int, edges): Determines whether the directed graph contains a cycle. Parameters: n (int): Number of nodes in the graph. edges (List[Tuple[int, int]]): List of directed edges in the graph. Returns: bool: True if the graph contains a cycle, False otherwise. from collections import defaultdict def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) visiting = set() visited = set() for node in range(n): if dfs(node): return True return False"},{"question":"# Sorting Words by Frequency and Alphabet Write a function `sort_words_by_frequency(words: List[str]) -> List[str]` that takes a list of words and sorts them first by their frequency in descending order and then alphabetically in ascending order for words with the same frequency. Input - `words`: A list of strings containing words. Output - A list of strings sorted by the described criteria. Constraints - The input list `words` will not be empty. - Each word in the list `words` will contain only lowercase alphabetical characters. # Example ```python >>> sort_words_by_frequency([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"cherry\\"]) [\'banana\', \'apple\', \'cherry\'] >>> sort_words_by_frequency([\\"dog\\", \\"cat\\", \\"dog\\", \\"cat\\", \\"dog\\", \\"elephant\\", \\"frog\\", \\"frog\\", \\"frog\\", \\"cat\\"]) [\'cat\', \'dog\', \'frog\', \'elephant\'] ``` Notes - Words appearing more frequently should come first in the output list. - If two words have the same frequency, they should be sorted alphabetically. - Implement robust error handling for edge cases such as an empty list or words with non-primary characters.","solution":"from typing import List from collections import Counter def sort_words_by_frequency(words: List[str]) -> List[str]: Sorts a list of words first by their frequency in descending order and then alphabetically in ascending order for words with the same frequency. :param words: List of words to be sorted. :return: Sorted list of words. # Count the frequency of each word. word_count = Counter(words) # Sort words by frequency (descending) and then alphabetically (ascending). sorted_words = sorted(word_count.keys(), key=lambda word: (-word_count[word], word)) return sorted_words"},{"question":"# Question You are given a list of positive integers representing a sequence, and you need to determine if it\'s possible to rearrange the sequence into a contiguous block such that all elements form a consecutive sequence of integers (with no gaps). Implement the function `can_form_consecutive_sequence` that takes a list of integers and returns a boolean indicating whether the sequence can be rearranged into a consecutive sequence. Function Signature ```python def can_form_consecutive_sequence(sequence: list[int]) -> bool: pass ``` Input * `sequence` (list of int): A list of positive integers (1 ≤ len(sequence) ≤ 10^5, 1 ≤ sequence[i] ≤ 10^9 for all i). Output * `bool`: A boolean value indicating whether the sequence can be rearranged to form a consecutive sequence. Examples 1. `can_form_consecutive_sequence([5, 2, 4, 3])` should return `True` because the sequence can be rearranged to `[2, 3, 4, 5]`. 2. `can_form_consecutive_sequence([9, 7, 8, 6, 5])` should return `True` because the sequence can be rearranged to `[5, 6, 7, 8, 9]`. 3. `can_form_consecutive_sequence([1, 3, 5, 7])` should return `False` because it\'s impossible to form a consecutive sequence from these elements. Constraints * The input list is non-empty and contains only positive integers. * Aim for an optimal time complexity solution. Requirements * Implement the function using efficient algorithmic techniques. * Avoid unnecessary sorting or nested loops to ensure performance within acceptable time limits.","solution":"def can_form_consecutive_sequence(sequence: list[int]) -> bool: Given a list of positive integers, determine if it\'s possible to rearrange the list to form a consecutive sequence of integers. Args: sequence (list[int]): A list of positive integers. Returns: bool: True if the sequence can be rearranged to form a consecutive sequence, otherwise False. # Check if the list has only one element which is trivially a consecutive sequence if len(sequence) == 1: return True # Find the minimum and maximum elements in the sequence min_value = min(sequence) max_value = max(sequence) # Calculate expected length of a consecutive sequence from min_value to max_value expected_length = max_value - min_value + 1 # A sequence can form a consecutive sequence if: # 1. The expected length of the consecutive sequence matches the length of the original sequence # 2. There are exactly as many unique elements in the sequence as the expected length if len(sequence) == expected_length and len(set(sequence)) == expected_length: return True return False"},{"question":"# **Coding Challenge: Longest Common Subsequence in Ranges** You are given two integer ranges and need to determine the longest common subsequence of numbers within those ranges. The sequence must be in non-decreasing order and within the bounds of the given ranges. **Problem Statement**: Write a function `longest_common_subsequence(range1: tuple, range2: tuple) -> list` that calculates the longest common subsequence of integers between two inclusive ranges. **Function Signature**: ```python def longest_common_subsequence(range1: tuple, range2: tuple) -> list: ``` # **Input Format** * A tuple `range1` which contains two integers representing the inclusive bounds of the first range. * A tuple `range2` which contains two integers representing the inclusive bounds of the second range. # **Output Format** * Returns a list of integers representing the longest common subsequence. # **Constraints** * All integers in the range of `range1` and `range2` are within the bounds of `-10^6 <= x <= 10^6` * The ranges are valid, i.e., `range1[0] <= range1[1]` and `range2[0] <= range2[1]` # **Examples** *Example 1:* ```python range1 = (1, 5) range2 = (3, 7) print(longest_common_subsequence(range1, range2)) # Output: [3, 4, 5] ``` *Example 2:* ```python range1 = (-10, 0) range2 = (-5, 5) print(longest_common_subsequence(range1, range2)) # Output: [-5, -4, -3, -2, -1, 0] ``` *Example 3:* ```python range1 = (0, 0) range2 = (0, 0) print(longest_common_subsequence(range1, range2)) # Output: [0] ``` # **Explanation** - In the first example, the intersection of the ranges [1, 5] and [3, 7] is [3, 4, 5]. - In the second example, the intersection of the ranges [-10, 0] and [-5, 5] is [-5, -4, -3, -2, -1, 0]. - In the third example, the intersection of the single-element ranges [0, 0] and [0, 0] is [0]. To solve this problem optimally, considering the given constraints, identify and extract the overlapping range between the two given ranges.","solution":"def longest_common_subsequence(range1: tuple, range2: tuple) -> list: Returns the longest common subsequence of numbers within two given inclusive ranges. start1, end1 = range1 start2, end2 = range2 # Find the overlap range start_common = max(start1, start2) end_common = min(end1, end2) # If there\'s no overlap if start_common > end_common: return [] # Returning the common subsequence as a list from start_common to end_common return list(range(start_common, end_common + 1))"},{"question":"# Question You are given two sorted arrays (non-decreasing order) and a positive integer `k`. Write a function `find_kth_smallest` to find the k-th smallest element in the merged sorted array without merging the arrays. **Function Signature**: ```python def find_kth_smallest(arr1: List[int], arr2: List[int], k: int) -> int: ``` # Input - `arr1` is a sorted list of integers. The elements are in non-decreasing order. - `arr2` is another sorted list of integers. The elements are in non-decreasing order. - `k` is a positive integer representing the position (1-indexed) of the element we want to find in the merged sorted array. # Output - The function should return the k-th smallest element in the merged sorted array of `arr1` and `arr2`. # Constraints - The length of `arr1` and `arr2` combined will not exceed 2000. - The elements in `arr1` and `arr2` will each be in the range [-10^6, 10^6]. - `1 ≤ k ≤ len(arr1) + len(arr2)` # Examples ```python # Example 1 arr1 = [1, 3, 5] arr2 = [2, 4, 6] k = 4 print(find_kth_smallest(arr1, arr2, k)) # Expected Output: 4 # Example 2 arr1 = [1, 2, 3, 4, 5] arr2 = [6, 7, 8, 9, 10] k = 7 print(find_kth_smallest(arr1, arr2, k)) # Expected Output: 7 # Example 3 arr1 = [2, 3, 6, 7, 9] arr2 = [1, 4, 8, 10] k = 5 print(find_kth_smallest(arr1, arr2, k)) # Expected Output: 6 # Example 4 arr1 = [1, 5, 9] arr2 = [2, 3, 4, 6, 7, 8, 10] k = 1 print(find_kth_smallest(arr1, arr2, k)) # Expected Output: 1 # Example 5 arr1 = [] arr2 = [1, 2, 3, 4, 5] k = 3 print(find_kth_smallest(arr1, arr2, k)) # Expected Output: 3 ``` # Notes - The solution should be efficient, with a time complexity better than O(n + m), where n and m are the lengths of `arr1` and `arr2` respectively. - Consider edge cases such as one of the arrays being empty. - Focus on binary search techniques to achieve optimal performance.","solution":"from typing import List def find_kth_smallest(arr1: List[int], arr2: List[int], k: int) -> int: def kth_smallest_in_merged(arr1, arr2, k): len1, len2 = len(arr1), len(arr2) low, high = max(0, k - len2), min(k, len1) while low < high: mid1 = (low + high) // 2 mid2 = k - mid1 if mid2 > len2 or (mid1 < len1 and arr1[mid1] < arr2[mid2 - 1]): low = mid1 + 1 else: high = mid1 mid1 = low mid2 = k - low if mid1 == 0: return arr2[mid2 - 1] if mid2 == 0: return arr1[mid1 - 1] return max(arr1[mid1 - 1], arr2[mid2 - 1]) return kth_smallest_in_merged(arr1, arr2, k)"},{"question":"**Introduction**: You are given a string and a task to determine if the string can be rearranged to form a palindrome. This problem will test your understanding of string manipulation and handling of character frequencies. **Problem**: Implement the method `can_form_palindrome(self) -> bool` within a class `PalindromeChecker` that determines if the input string can be rearranged to form a palindrome. A palindrome is a string that reads the same backward as forward. **Input**: - An instance of the `PalindromeChecker` class, which has been initialized with a string. **Output**: - A boolean value that indicates whether the input string can be rearranged to form a palindrome. **Constraints**: - The length of the string is at most 100 characters. - The input string consists of lowercase letters only. **Example**: ```python >>> pc = PalindromeChecker(\\"civic\\") >>> pc.can_form_palindrome() True >>> pc = PalindromeChecker(\\"ivicc\\") >>> pc.can_form_palindrome() True >>> pc = PalindromeChecker(\\"hello\\") >>> pc.can_form_palindrome() False >>> pc = PalindromeChecker(\\"aaabbbb\\") >>> pc.can_form_palindrome() True >>> pc = PalindromeChecker(\\"a\\") >>> pc.can_form_palindrome() True >>> pc = PalindromeChecker(\\"\\") >>> pc.can_form_palindrome() True ``` **Requirements**: - Handle all edge cases, including empty strings and strings with only one character. - Ensure efficient manipulation and check for palindromic rearrangement. **Additional**: - You may utilize helper methods or additional classes if needed. - Focus on optimal character frequency checks to achieve the outcome.","solution":"class PalindromeChecker: def __init__(self, s: str): self.s = s def can_form_palindrome(self) -> bool: from collections import Counter char_counts = Counter(self.s) # Count how many characters have an odd number of occurrences odd_count_chars = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if there is at most one character with an odd occurrence return odd_count_chars <= 1"},{"question":"# Coding Challenge: Array Element Replacement You are tasked with writing a function that processes an array of integers by replacing each element with the product of all other elements in the array, except the element at the current index. Task Implement a function `replace_elements_with_products` that receives an array of integers and returns a new array. Each element in the returned array should be the product of all the integers in the input array except the integer at the same index. Function Signature ```python def replace_elements_with_products(arr: List[int]) -> List[int]: pass ``` Input Description - `arr` - List of `n` integers where ( 1 leq n leq 10^{3} ). Each integer `arr[i]` can range from (-10^{4}) to (10^{4}). Output Description - Return a list of `n` integers where each element at index `i` is the product of all elements in the input array except `arr[i]`. Constraints - You cannot use division to solve this problem. - Consider edge cases with zeros in the array. Example ```python print(replace_elements_with_products([1, 2, 3, 4])) # Output: [24, 12, 8, 6] print(replace_elements_with_products([2, 3, 5, 7])) # Output: [105, 70, 42, 30] print(replace_elements_with_products([3, 0, 2])) # Output: [0, 6, 0] ``` Points to Consider - Aim for an efficient solution with linear time complexity. - Handle arrays that contain one or more zeros appropriately, ensuring the output adheres to the constraints without resulting in division errors. - Ensure the function correctly computes the product without redundancy or excessive computational steps.","solution":"from typing import List def replace_elements_with_products(arr: List[int]) -> List[int]: n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i-1] * arr[i-1] # Calculate right products for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * arr[i+1] # Calculate result by multiplying left and right products result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"# Coding Assessment Question Context: You are working on optimizing a popular recommendation system that ranks items by user ratings. You need to implement a function to find the median rating from a very large dataset. However, loading all data into memory is not feasible due to the size of the dataset. Task: The goal is to implement a function that uses the Quickselect algorithm to find the median value from a list of ratings without loading all data into memory. Requirements: - Implement a function `quickselect_median(ratings)`: - **Input**: - `ratings` (list[int]): A list of positive integers representing user ratings. - **Output**: - An integer representing the median rating value. - **Constraints**: - The list of ratings is non-empty. - All ratings are integers between 1 and 5 (inclusive). Performance Requirements: - The function should be able to handle lists with up to 1,000,000 ratings efficiently. Examples: ```python >>> ratings = [4, 1, 3, 2, 5] >>> quickselect_median(ratings) 3 >>> ratings = [5, 3, 1, 2, 4, 6] >>> quickselect_median(ratings) 3 >>> ratings = [1, 2, 2, 2, 3, 4, 4, 5, 5] >>> quickselect_median(ratings) 3 ``` Note: - Assume that the length of the rating list is always at least 1. - The Quickselect algorithm should be completed in-place and in linear time on average. Consider edge cases for both even and odd lengths of the ratings list.","solution":"def quickselect(arr, k): Perform the Quickselect algorithm to find the k-th smallest element in the list. if len(arr) == 1: return arr[0] pivot = arr[len(arr) // 2] lows = [el for el in arr if el < pivot] highs = [el for el in arr if el > pivot] pivots = [el for el in arr if el == pivot] if k < len(lows): return quickselect(lows, k) elif k < len(lows) + len(pivots): return pivots[0] else: return quickselect(highs, k - len(lows) - len(pivots)) def quickselect_median(ratings): Returns the median rating using the Quickselect algorithm. n = len(ratings) if n % 2 == 1: # If odd, return the middle element return quickselect(ratings, n // 2) else: # If even, return the average of the two middle elements return 0.5 * (quickselect(ratings, n // 2 - 1) + quickselect(ratings, n // 2))"},{"question":"# Question You are tasked with developing a program to schedule a set of tasks on a single processor, minimizing the total time to complete all tasks (also known as minimizing the makespan). The tasks have different lengths and must be scheduled in such a way that total completion time is minimized. Your task is to implement a function that returns the optimal order of the tasks. Function Specification ```python def minimize_makespan(tasks: list[int]) -> list[int]: Given a list of task durations, returns a list of task indices representing the order in which tasks should be processed to minimize the total completion time. ``` # Input * `tasks`: A list of integers where each integer represents the duration of a task. # Output * A list of integers representing the indices of the tasks in the order they should be processed to minimize the total completion time. # Constraints * `1 ≤ len(tasks) ≤ 10^3` - The number of tasks is constrained between 1 and 1000. * `1 ≤ tasks[i] ≤ 10^4` - The duration of each task is between 1 and 10,000. # Example ```python tasks = [3, 1, 9, 2, 7] print(minimize_makespan(tasks)) # Output: [1, 3, 0, 4, 2] ``` # Performance Requirements Your implementation should aim for a time complexity of O(n log n) to handle the upper limit of inputs efficiently. Explanation: In the example given: 1. Task 1 duration is 1. 2. Task 3 duration is 2. 3. Task 0 duration is 3. 4. Task 4 duration is 7. 5. Task 2 duration is 9. Ordering the tasks by ascending duration minimizes the total completion time. The optimal order in this case is [1, 3, 0, 4, 2], representing the durations [1, 2, 3, 7, 9]. This leads to the smallest possible makespan. By ensuring tasks are ordered and processed from the shortest duration to the longest, we minimize the total amount of idle time on the processor, thus minimizing the overall completion time.","solution":"def minimize_makespan(tasks: list[int]) -> list[int]: Given a list of task durations, returns a list of task indices representing the order in which tasks should be processed to minimize the total completion time. # Pair each task with its original index indexed_tasks = list(enumerate(tasks)) # Sort tasks primarily by their duration indexed_tasks.sort(key=lambda x: x[1]) # Extract the original indices from the sorted list optimal_order = [index for index, duration in indexed_tasks] return optimal_order"},{"question":"# Problem Description You are required to implement a system for managing bookings for a small event venue. The system allows for creating, modifying, and querying bookings using the given API endpoints. # Requirements 1. **Function 1: `create_booking`** - **Input**: Two integers, `start_time` (0 <= start_time < 24) and `end_time` (0 < end_time <= 24), representing the starting and ending time of the booking. - **Output**: A boolean value indicating success or failure of the booking. - **Behavior**: Create a new booking for the specified time range. A booking should succeed if and only if the specified time range does not overlap with any existing booking. 2. **Function 2: `modify_booking`** - **Input**: An integer `booking_id` (ID of the booking to modify), and two integers `new_start_time` and `new_end_time` for the updated time range. - **Output**: A boolean value indicating success or failure of the modification. - **Behavior**: Modify an existing booking to a new time range. The modification should succeed if the new time range does not overlap with any other existing booking except the one being modified. 3. **Function 3: `query_booking`** - **Input**: Two integers, `start_time` and `end_time`. - **Output**: A list of booking IDs that overlap with the specified time range. - **Behavior**: Return a list of booking IDs for all bookings that overlap with the given time range. # Example ```python >>> bookings = BookingSystem() >>> bookings.create_booking(9, 12) True >>> bookings.create_booking(11, 13) False >>> bookings.create_booking(13, 15) True >>> bookings.modify_booking(1, 10, 11) False >>> bookings.modify_booking(1, 12, 14) True >>> bookings.query_booking(10, 14) # successfully modified, so now there are no overlapping bookings [] >>> bookings.query_booking(12, 14) [1, 2] # booking id 1 and 2 are overlapping with the specified time range ``` # Constraints * There will be no more than 10^5 bookings or modifications. * Start and end times are within a 24-hour period represented as integer values (0 through 24). # Task Implement a class `BookingSystem` with the mentioned methods (`create_booking`, `modify_booking`, `query_booking`) in Python to manage the bookings for the event venue as described. Each booking should be identified with a unique ID, starting from 1.","solution":"class BookingSystem: def __init__(self): # Dictionary to store bookings with booking_id as key and tuple (start_time, end_time) as value self.bookings = {} self.booking_counter = 1 def create_booking(self, start_time, end_time): for booking in self.bookings.values(): if not (end_time <= booking[0] or start_time >= booking[1]): return False self.bookings[self.booking_counter] = (start_time, end_time) self.booking_counter += 1 return True def modify_booking(self, booking_id, new_start_time, new_end_time): if booking_id not in self.bookings: return False old_booking = self.bookings[booking_id] self.bookings.pop(booking_id) for booking in self.bookings.values(): if not (new_end_time <= booking[0] or new_start_time >= booking[1]): self.bookings[booking_id] = old_booking return False self.bookings[booking_id] = (new_start_time, new_end_time) return True def query_booking(self, start_time, end_time): result = [] for booking_id, booking in self.bookings.items(): if not (end_time <= booking[0] or start_time >= booking[1]): result.append(booking_id) return result"},{"question":"# Problem Statement You are tasked with developing an algorithm to help a delivery service optimize their route to minimize the total travel distance. Given the locations of the delivery points, determine the shortest possible route that visits each location exactly once and returns to the starting point. # Requirements: Implement a function `tsp` that takes in: 1. A list of tuples, where each tuple represents the x and y coordinates of a delivery point. Your function should return the route (a list of indices corresponding to the input list) that provides the shortest travel distance. Constraints: * Each point is a tuple of two integers. * There will be at most 10 delivery points. * The coordinates of each point are positive or negative integers. # Function Signature: ```python from typing import List, Tuple def tsp(delivery_points: List[Tuple[int, int]]) -> List[int]: pass ``` # Example: ```python from typing import List, Tuple def tsp(delivery_points: List[Tuple[int, int]]) -> List[int]: # Your implementation here # Example Usage delivery_points = [(0, 0), (1, 1), (2, 2), (3, 3)] print(tsp(delivery_points)) # Example possible output: [0, 1, 2, 3], assuming it provides the shortest route. ``` # Additional Examples: ```python delivery_points = [(0, 0), (2, 3), (5, 6), (8, 8)] print(tsp(delivery_points)) # Expected output: any permutation of [0, 1, 2, 3] which provides the shortest route. delivery_points = [(1, 1), (4, 5), (6, 3), (7, 9), (8, 8)] print(tsp(delivery_points)) # Expected output: any permutation that provides the shortest route. delivery_points = [(1, 2), (2, 3)] print(tsp(delivery_points)) # Expected output: [0, 1] or [1, 0] indicating the single possible route. ``` # Notes: * If the list of `delivery_points` has fewer than 2 points, return the list itself as the route. * The problem can be approached by exploring permutation, dynamic programming, or any other heuristic to find the shortest route.","solution":"from typing import List, Tuple import itertools def euclidean_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5 def total_distance(route: List[int], delivery_points: List[Tuple[int, int]]) -> float: distance = 0 num_points = len(route) for i in range(num_points): distance += euclidean_distance(delivery_points[route[i]], delivery_points[route[(i + 1) % num_points]]) return distance def tsp(delivery_points: List[Tuple[int, int]]) -> List[int]: if len(delivery_points) < 2: return list(range(len(delivery_points))) num_points = len(delivery_points) best_route = None min_distance = float(\'inf\') for perm in itertools.permutations(range(num_points)): current_distance = total_distance(list(perm), delivery_points) if current_distance < min_distance: min_distance = current_distance best_route = list(perm) return best_route"},{"question":"# Coding Assessment Question **Context**: Imagine you are tasked with developing a feature for a social networking platform that calculates the shortest path of friendship connections between two users. **Problem Statement**: Implement a function to find the shortest path of friendship connections (degree of separation) between two users in a social network graph. The graph is given as an adjacency list, where each key is a user ID and the associated value is a list of user IDs representing that user\'s friends. # Function Signature: ```python def shortest_path(connections: dict[int, list[int]], start: int, end: int) -> list[int]: pass ``` # Input: 1. **connections (dict[int, list[int]})**: A dictionary representing the social network as an adjacency list. 2. **start (int)**: The user ID where the search starts. 3. **end (int)**: The user ID where the search ends. # Output: Returns a list of user IDs representing the shortest path of connections from **start** to **end**. If no such path exists, return an empty list. # Constraints: 1. The number of users and connections is at most ( 10^5 ). 2. The user IDs are unique and are integers ranging from 1 to ( 10^5 ). 3. The connections ensure an undirected graph (if user A is a friend of user B, then user B is a friend of user A). # Example: ```python assert shortest_path( { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4] }, 1, 5 ) == [1, 2, 4, 5] assert shortest_path( { 1: [2], 2: [1, 3], 3: [2, 4], 4: [3] }, 1, 5 ) == [] ``` # Explanation: In the first example, the shortest path from user 1 to user 5 goes through users 2 and 4. The resulting path is [1, 2, 4, 5]. In the second example, there is no connection between user 1 and user 5, so the function returns an empty list.","solution":"from collections import deque def shortest_path(connections: dict[int, list[int]], start: int, end: int) -> list[int]: if start not in connections or end not in connections: return [] queue = deque([(start, [start])]) visited = set([start]) while queue: current, path = queue.popleft() if current == end: return path for neighbor in connections[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"Average Temperature Calculation **Objective**: Implement a function to calculate the average temperature from a list of daily temperature readings. **Function Signature**: ```python def average_temperature(temperatures: List[float]) -> float: ``` # Instructions: Write a function `average_temperature` that: 1. Takes a list of floating-point numbers representing daily temperatures in Celsius. 2. Returns a floating-point number representing the average temperature. The average temperature should be calculated using the formula: [ text{Average} = frac{1}{n} sum_{i=1}^{n} t_i ] Where ( t_i ) represents each temperature reading and ( n ) is the number of readings. # Input constraints: * The list will contain at least one temperature reading and at most 365 readings. * Each temperature reading will be in the range of (-50.0 ) to ( 50.0 ) # Output: The function should return the average temperature as a float rounded to two decimal places. # Examples: ```python >>> average_temperature([30.5, 28.0, 25.5, 24.0]) 27.0 >>> average_temperature([-10.0, -5.0, 0.0, 5.0, 10.0]) 0.0 >>> average_temperature([1.5]) 1.5 >>> average_temperature([10.0, 20.0, 10.0, 20.0]) 15.0 ``` # Performance requirements: The function should execute in linear time O(n) and use linear space O(n), where ( n ) is the number of temperature readings. # Additional Notes: * You can assume the function will not receive non-numeric input values. * Consider edge cases such as all temperatures being the same or varying significantly. * Ensure the function handles an input list of minimum length (1 reading) correctly.","solution":"from typing import List def average_temperature(temperatures: List[float]) -> float: Calculates the average temperature from a list of daily temperature readings. Args: temperatures (List[float]): A list of floating-point numbers representing daily temperatures in Celsius. Returns: float: The average temperature rounded to two decimal places. if not temperatures: raise ValueError(\\"The temperatures list is empty.\\") total = sum(temperatures) count = len(temperatures) average = total / count return round(average, 2)"},{"question":"# Problem Statement: You are tasked with devising a function that determines the minimum number of interchangeable parts needed for a piece of machinery, given each part\'s unique specifications. The parts must be matched with given criteria based on size and efficiency. # Requirements 1. Implement a function `minimum_parts(parts: list, criteria: dict) -> int` that calculates the minimum number of interchangeable parts required. 2. The input `parts` will be a list of dictionaries, each representing a part with its specifications. 3. The input `criteria` will be a dictionary representing the size and efficiency requirements that the parts must meet. 4. Each part dictionary contains: - `\\"size\\"`: an integer representing the size of the part. - `\\"efficiency\\"`: a floating-point number representing the efficiency of the part. 5. The `criteria` dictionary contains: - `\\"size\\"`: an integer representing the minimum required size. - `\\"efficiency\\"`: a floating-point number representing the minimum required efficiency. Here is an example configuration: ```python parts = [ {\\"size\\": 10, \\"efficiency\\": 90.0}, {\\"size\\": 15, \\"efficiency\\": 85.0}, {\\"size\\": 10, \\"efficiency\\": 95.0}, {\\"size\\": 20, \\"efficiency\\": 80.0} ] criteria = { \\"size\\": 10, \\"efficiency\\": 90.0 } ``` In this configuration: - Three parts: `{\\"size\\": 10, \\"efficiency\\": 90.0}`, `{\\"size\\": 10, \\"efficiency\\": 95.0}`, and `{\\"size\\": 15, \\"efficiency\\": 85.0}` will be considered because they meet the criteria\'s size requirement of 10. - Only two parts meet both the size and efficiency requirement. # Steps to implement: 1. Parse the list of parts and the criteria to identify valid parts. 2. Filter parts based on the given criteria for size and efficiency. 3. Calculate the minimum number of parts that can adequately meet or exceed each criterion. 4. Your function should return the minimum number of parts that meet both the size and efficiency criteria. # Constraints: - Size values: positive integers. - Efficiency values: positive floating-point numbers. - The input list of parts is always valid and non-empty. - The criteria dictionary is always valid and non-empty. - All parts and criteria values are positive. # Input: - A list of dictionaries representing the parts. - A dictionary representing the criteria. # Output: - A single integer representing the minimum number of parts that meet both the size and efficiency criteria. # Example: ```python example_parts = [ {\\"size\\": 10, \\"efficiency\\": 90.0}, {\\"size\\": 15, \\"efficiency\\": 85.0}, {\\"size\\": 10, \\"efficiency\\": 95.0}, {\\"size\\": 20, \\"efficiency\\": 80.0} ] example_criteria = { \\"size\\": 10, \\"efficiency\\": 90.0 } result = minimum_parts(example_parts, example_criteria) # Expected Minimum Number of Parts: 2 ``` Evaluate your solution against scenarios such as: - All parts meeting the criteria. - None of the parts meeting the criteria. - Mixture of parts meeting one but not the other criterion.","solution":"def minimum_parts(parts, criteria): Returns the minimum number of parts that meet both size and efficiency criteria. :param parts: a list of dictionaries with \'size\' and \'efficiency\' keys. :param criteria: a dictionary with keys \'size\' and \'efficiency\'. :return: int - minimum number of parts that meet both criteria. size_criteria = criteria[\\"size\\"] efficiency_criteria = criteria[\\"efficiency\\"] # Filter parts based on the criteria valid_parts = [ part for part in parts if part[\\"size\\"] >= size_criteria and part[\\"efficiency\\"] >= efficiency_criteria ] return len(valid_parts) # Example usage example_parts = [ {\\"size\\": 10, \\"efficiency\\": 90.0}, {\\"size\\": 15, \\"efficiency\\": 85.0}, {\\"size\\": 10, \\"efficiency\\": 95.0}, {\\"size\\": 20, \\"efficiency\\": 80.0} ] example_criteria = { \\"size\\": 10, \\"efficiency\\": 90.0 } result = minimum_parts(example_parts, example_criteria) print(result) # Expected Minimum Number of Parts: 2"},{"question":"# Problem: Caloric Burn During Exercise You are developing a fitness app that tracks the calories burned based on the user\'s exercise details. The caloric burn process during an exercise session follows a straightforward linear relationship based on activity type, weight, and duration. Write a function `caloric_burn` that calculates the calories burned during an exercise session. The function will follow the mathematical formula: [ text{Calories Burned} = text{MET} times text{Weight (kg)} times left(frac{text{Duration (min)}}{60}right) ] where: - `MET` is the Metabolic Equivalent of the exercise activity, - `Weight` is the user\'s weight in kilograms, - `Duration` is the duration of the exercise in minutes. Your task is to implement this function while ensuring proper input validation and rounding the result to two decimal places. Function Signature ```python def caloric_burn(met: float, weight_kg: float, duration_min: float) -> float: ``` Input * **met**: A positive float representing the Metabolic Equivalent of the exercise activity. * **weight_kg**: A positive float representing the user\'s weight in kilograms. * **duration_min**: A positive float representing the duration of the exercise in minutes. Output * **returns**: A float representing the calories burned during the exercise session, rounded to two decimal places. Constraints * All inputs for `met`, `weight_kg`, and `duration_min` must be positive. * If any input is non-positive, the function should raise a `ValueError` with an appropriate error message. Examples ```python >>> caloric_burn(8.0, 70.0, 45.0) 420.00 >>> caloric_burn(3.5, 68.5, 30.0) 119.88 >>> caloric_burn(5.0, 80.0, 60.0) 400.00 >>> caloric_burn(10.0, 73.5, 90.0) 1102.50 >>> caloric_burn(-8.0, 70.0, 45.0) Traceback (most recent call last): ... ValueError: MET must be positive. >>> caloric_burn(8.0, -70.0, 45.0) Traceback (most recent call last): ... ValueError: Weight must be positive. >>> caloric_burn(8.0, 70.0, -45.0) Traceback (most recent call last): ... ValueError: Duration must be positive. ```","solution":"def caloric_burn(met: float, weight_kg: float, duration_min: float) -> float: Calculate the calories burned during an exercise session based on MET value, weight, and duration. :param met: Metabolic Equivalent of the exercise activity (positive float) :param weight_kg: User\'s weight in kilograms (positive float) :param duration_min: Duration of the exercise in minutes (positive float) :return: Calories burned, rounded to two decimal places (float) :raises ValueError: If any input is non-positive if met <= 0: raise ValueError(\\"MET must be positive.\\") if weight_kg <= 0: raise ValueError(\\"Weight must be positive.\\") if duration_min <= 0: raise ValueError(\\"Duration must be positive.\\") calories_burned = met * weight_kg * (duration_min / 60) return round(calories_burned, 2)"},{"question":"# **List Zipping with Default Values** Write a function `zip_with_defaults(list1: list, list2: list, default=None) -> list` that zips two lists into a list of tuples. If the lists are of unequal lengths, the shorter list should be padded with the specified default value. 1. **Input:** - `list1`: First list to zip. - `list2`: Second list to zip. - `default`: The default value to use for padding (default is `None`). 2. **Output:** - A new list containing tuples where each tuple contains elements from `list1` and `list2`. If one list is shorter, use `default` to fill the missing values. 3. **Constraints:** - Elements of `list1` and `list2` can be of any type. - `list1` and `list2` may be of different lengths. - The function should not modify the original lists. 4. **Handling Errors:** - Raise a `TypeError` if `list1` or `list2` is not a list. # Example Usage ```python >>> zip_with_defaults([1, 2, 3], [\'a\', \'b\', \'c\']) [(1, \'a\'), (2, \'b\'), (3, \'c\')] >>> zip_with_defaults([1, 2], [\'a\', \'b\', \'c\']) [(1, \'a\'), (2, \'b\'), (None, \'c\')] >>> zip_with_defaults([1, 2, 3], [\'a\'], default=\'x\') [(1, \'a\'), (2, \'x\'), (3, \'x\')] >>> zip_with_defaults([], [\'a\', \'b\'], default=0) [(0, \'a\'), (0, \'b\')] >>> zip_with_defaults([1, 2], []) [(1, None), (2, None)] >>> zip_with_defaults(123, [\'a\', \'b\']) Traceback (most recent call last): ... TypeError: list1 and list2 must be lists ``` # Requirements * Ensure the function handles invalid input gracefully by raising exceptions where necessary. * Optimize the implementation to handle large lists efficiently without excessive memory usage.","solution":"def zip_with_defaults(list1, list2, default=None): Zips two lists into a list of tuples. If the lists are of unequal lengths, the shorter list will be padded with the specified default value. Parameters: - list1: First list to zip. - list2: Second list to zip. - default: The default value to use for padding (default is None). Returns: - A new list containing tuples where each tuple contains elements from `list1` and `list2`. If one list is shorter, the missing values are filled with `default`. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"list1 and list2 must be lists\\") max_len = max(len(list1), len(list2)) padded_list1 = list1 + [default] * (max_len - len(list1)) padded_list2 = list2 + [default] * (max_len - len(list2)) return list(zip(padded_list1, padded_list2))"},{"question":"Fibonacci Sequence: Unique Number Calculation The Fibonacci sequence is a well-known sequence in which each term is the sum of the two preceding ones, usually starting with 0 and 1. The first few terms are: ``` 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... ``` For this task, you are required to calculate the Sum of Unique Numbers in a given range `[a, b]` in the Fibonacci Sequence. # Task Implement a function that calculates the sum of unique Fibonacci numbers within a given range `[a, b]` inclusive. Function Signature ```python def sum_unique_fibonacci(a: int, b: int) -> int: Calculates the sum of unique Fibonacci numbers in the range [a, b]. Parameters: a (int): Lower bound of the range (inclusive). b (int): Upper bound of the range (inclusive). Returns: int: The sum of unique Fibonacci numbers in the given range. Raises: TypeError: If a or b is not an integer. ValueError: If a is negative or a > b. pass ``` # Constraints 1. `a` and `b` should be non-negative integers. 2. `a` should not be greater than `b`. 3. If these constraints are not met, raise appropriate exceptions (`TypeError` or `ValueError`). # Expected Output Format The function should return an integer representing the sum of unique Fibonacci numbers within the given range. # Examples ```python assert sum_unique_fibonacci(0, 10) == 44 # Fibonacci numbers: 0, 1, 1, 2, 3, 5, 8. Unique sum: 0 + 1 + 2 + 3 + 5 + 8 = 19 assert sum_unique_fibonacci(10, 100) == 231 # Fibonacci numbers: 13, 21, 34, 55, 89. Unique sum: 13 + 21 + 34 + 55 + 89 = 212 ``` # Hints 1. Consider generating Fibonacci numbers until the maximum value `b` is reached. 2. Use a set to keep track of unique Fibonacci numbers.","solution":"def sum_unique_fibonacci(a: int, b: int) -> int: Calculates the sum of unique Fibonacci numbers in the range [a, b]. Parameters: a (int): Lower bound of the range (inclusive). b (int): Upper bound of the range (inclusive). Returns: int: The sum of unique Fibonacci numbers in the given range. Raises: TypeError: If a or b is not an integer. ValueError: If a is negative or a > b. if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Both a and b should be integers\\") if a < 0 or b < 0: raise ValueError(\\"Both a and b should be non-negative\\") if a > b: raise ValueError(\\"a should not be greater than b\\") # Generate Fibonacci numbers until we reach the maximum value b fibs = set() f1, f2 = 0, 1 while f1 <= b: if f1 >= a: fibs.add(f1) f1, f2 = f2, f1 + f2 return sum(fibs)"},{"question":"# Coding Assessment Question Write a function that takes a list of integers and a target integer, and returns the indices of the two numbers in the list that add up to the target. If there are no such indices, the function should return `[-1, -1]`. Each input would have exactly one solution, and you may not use the same element twice. Function Signature `def two_sum(nums: list, target: int) -> list:` Input * `nums`: A list of integers. (e.g., `[2, 7, 11, 15]`) * `target`: An integer representing the sum target. Output * Returns a list of two indices of the `nums` list whose values add up to `target`. If no such indices exist, return `[-1, -1]`. Constraints * The length of `nums` will be at least 2 and at most 1000. * Each function has exactly one valid solution. * You may not use the same element twice. * The solution must have a time complexity of O(n). Examples ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) [-1, -1] >>> two_sum([5, 75, 25], 100) [1, 2] ``` Notes Ensure your implementation handles edge cases, such as input lists where no two indices add up to the target. The function should operate efficiently, considering the constraints provided. ```python def two_sum(nums: list, target: int) -> list: # Your code here ```","solution":"def two_sum(nums: list, target: int) -> list: Returns indices of two numbers in the `nums` list that add up to `target`. If no such indices exist, return [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"# Context You are a software developer working on an application that manages to-do lists. One of the features you need to implement is a function that consolidates multiple to-do lists into a single one, removing any duplicate tasks and prioritizing based on their urgency. # Problem Statement Write a function `consolidate_tasks(task_lists: List[List[Tuple[str, int]]]) -> List[Tuple[str, int]]` that takes a list of to-do lists as input and returns a single consolidated list of tasks. Each task in the input lists is represented as a tuple of the form `(task: str, urgency: int)`, where `task` is the task description and `urgency` is an integer representing the urgency of the task (higher numbers indicate higher urgency). The consolidated list should: 1. Remove duplicate tasks, keeping the task with the highest urgency. 2. Be sorted in descending order of urgency. Function Signature ```python def consolidate_tasks(task_lists: List[List[Tuple[str, int]]]) -> List[Tuple[str, int]]: pass ``` Input - `task_lists` (List[List[Tuple[str, int]]]): A list of to-do lists, where each to-do list is a list of tasks represented as tuples `(task: str, urgency: int)`. Output - (List[Tuple[str, int]]): The consolidated list of tasks, sorted by urgency in descending order. # Requirements 1. Ensure the function handles an arbitrary number of to-do lists. 2. Task descriptions are case-sensitive (e.g., \\"Task A\\" and \\"task a\\" are considered different). 3. Handle edge cases such as empty to-do lists and tasks with the same urgency. Example ```python tasks = [ [(\\"Buy groceries\\", 2), (\\"Clean the house\\", 1)], [(\\"Buy groceries\\", 3), (\\"Read a book\\", 2)], [(\\"Exercise\\", 4), (\\"Read a book\\", 5)] ] print(consolidate_tasks(tasks)) # Expected output: [(\\"Read a book\\", 5), (\\"Exercise\\", 4), (\\"Buy groceries\\", 3), (\\"Clean the house\\", 1)] ``` # Constraints - Assume each task description is a non-empty string with a maximum length of 100 characters. - There can be up to 1000 tasks across all to-do lists combined. - Urgency is a non-negative integer. # Notes 1. The urgency of tasks in the consolidated list should be the highest urgency found across all to-do lists. 2. The function should be efficient, making use of appropriate data structures to handle duplicate tasks and sorting.","solution":"from typing import List, Tuple def consolidate_tasks(task_lists: List[List[Tuple[str, int]]]) -> List[Tuple[str, int]]: Consolidates multiple to-do lists into a single list, removing duplicates and prioritizing based on urgency. Parameters: task_lists (List[List[Tuple[str, int]]]): A list of to-do lists, where each to-do list is a list of tasks represented as tuples. Returns: List[Tuple[str, int]]: The consolidated list of tasks, sorted by urgency in descending order. task_dict = {} for task_list in task_lists: for task, urgency in task_list: if task in task_dict: if urgency > task_dict[task]: task_dict[task] = urgency else: task_dict[task] = urgency consolidated_list = sorted(task_dict.items(), key=lambda x: x[1], reverse=True) return consolidated_list"},{"question":"# Problem Statement Imagine you are designing an automated ticket vending system for a movie theater. The system allows customers to purchase multiple tickets simultaneously, but the theater has a specific pricing policy: 1. The cost of a single ticket is 10. 2. If a customer buys 3 or more tickets, they receive a 20% discount on the total cost. 3. If a customer buys 5 or more tickets, they receive a 25% discount on the total cost. Your task is to: 1. **Implement** the `calculate_total_cost` function that computes the total cost given the number of tickets. 2. **Enhance** input validation to ensure the number of tickets is a non-negative integer. # Function Signature ```python def calculate_total_cost(num_tickets: int) -> float: ``` # Constraints * ( 0 leq num_tickets leq 10^6 ) * `num_tickets` is a non-negative integer. # Example ```python # Example 1 print(calculate_total_cost(2)) # should return 20.0 # Example 2 print(calculate_total_cost(4)) # should return 32.0 # Example 3 print(calculate_total_cost(5)) # should return 37.5 ``` # Requirements 1. **Correctness**: Accurately compute the cost based on the pricing policy. 2. **Validation**: Ensure `num_tickets` is a non-negative integer, raising appropriate exceptions for invalid inputs.","solution":"def calculate_total_cost(num_tickets: int) -> float: Computes the total cost given the number of tickets. Parameters: - num_tickets (int): The number of tickets to purchase. Returns: - float: The total cost based on the pricing policy. Raises: - ValueError: If num_tickets is not a non-negative integer. if not isinstance(num_tickets, int) or num_tickets < 0: raise ValueError(\\"The number of tickets must be a non-negative integer.\\") cost_per_ticket = 10.0 if num_tickets >= 5: discount = 0.25 elif num_tickets >= 3: discount = 0.20 else: discount = 0.0 total_cost = num_tickets * cost_per_ticket * (1 - discount) return total_cost"},{"question":"# Context In data analysis and scientific computing, normalization of data is an essential preprocessing step that transforms the data to a common scale without distorting differences in the ranges of values. One common normalization technique is min-max normalization, which scales the data to a fixed range, usually [0, 1]. The min-max normalization is described by the formula: ``` x\' = (x - min) / (max - min) ``` where `x` is the original value, `min` is the minimum value in the dataset, and `max` is the maximum value in the dataset. # Problem Statement You are required to implement a function `min_max_normalize(data)` that normalizes a list of numerical values using the min-max normalization technique and returns a new list of normalized values. # Function Signature ```python def min_max_normalize(data: List[float]) -> List[float]: pass ``` # Input and Output * **Input**: - `data` (List[float]): A list of numerical values to be normalized. * **Output**: - `List[float]`: A list containing the normalized values. # Constraints * The input list must contain at least two elements. * The values in the input list can be negative or positive. * The input list will not contain NaN or infinite values. # Performance Requirements The function should maintain linear time complexity, efficiently handling large datasets. # Example ```python data = [1, 2, 3, 4, 5] normalized_data = min_max_normalize(data) print(normalized_data) # Expected output: [0.0, 0.25, 0.5, 0.75, 1.0] data = [-5, 0, 5, 10, 15] normalized_data = min_max_normalize(data) print(normalized_data) # Expected output: [0.0, 0.25, 0.5, 0.75, 1.0] ``` # Implementation Notes 1. Determine the minimum and maximum values in the list. 2. Apply the min-max normalization formula to each value in the list. 3. Handle edge cases where all values in the list might be identical, resulting in division by zero (although the problem constraints ensure there\'s at least one value difference in the list). This implementation fosters understanding of data normalization, important in preparing datasets for machine learning algorithms.","solution":"from typing import List def min_max_normalize(data: List[float]) -> List[float]: min_val = min(data) max_val = max(data) range_val = max_val - min_val # Guard against division by zero in case all values are the same if range_val == 0: return [0.0 for _ in data] normalized_data = [(x - min_val) / range_val for x in data] return normalized_data"},{"question":"# Coding Assessment Question Scenario As a developer at a web scraping company, you are tasked with parsing and analyzing large HTML documents efficiently. An important part of this job involves extracting specific data from HTML strings. Your manager has identified the need for a specialized function that extracts the content of all HTML tags of a certain type. Task Write a function `extract_html_content` that extracts the content nested within HTML tags of a specified type. The function should take an HTML string and the tag of interest as inputs and return a list of strings representing the content within each matching tag. # Function Signature ```python def extract_html_content(html: str, tag: str) -> list[str]: pass ``` # Input * `html`: A string representing the HTML document. * `tag`: A string representing the HTML tag of interest (e.g., \\"div\\", \\"p\\"). # Output * A list of strings, where each string is the content within one matching HTML tag. # Constraints * The function should effectively handle nested tags. * HTML tags can contain attributes, but you only need the inner content. * The function should ignore tags other than the specified one, even if they are nested within the target tags. * An empty list should be returned if no matching tags are found. * Assume well-formed input HTML for simplicity. # Example ```python html_doc = \\"<div><p>This is a test</p><p>Another test</p></div>\\" assert extract_html_content(html_doc, \\"p\\") == [\\"This is a test\\", \\"Another test\\"] html_doc = \\"<div>Content 1 <span>Ignored</span> Content 2</div><div>Content 3</div>\\" assert extract_html_content(html_doc, \\"div\\") == [\\"Content 1 Ignored Content 2\\", \\"Content 3\\"] html_doc = \\"<html><body><h1>Title</h1><p>Paragraph</p></body></html>\\" assert extract_html_content(html_doc, \\"body\\") == [\\"<h1>Title</h1><p>Paragraph</p>\\"] ``` # Notes * Your implementation should use efficient string manipulation techniques. * Consider edge cases, such as empty HTML strings and tags with no content. * Avoid using third-party HTML parsing libraries. * Write clean, readable code with appropriate comments.","solution":"def extract_html_content(html: str, tag: str) -> list[str]: Extracts the content within all HTML tags of a specified type. Args: html (str): The HTML document as a string. tag (str): The HTML tag of interest (e.g., \\"div\\", \\"p\\"). Returns: list[str]: A list of strings representing the content within each matching tag. import re # Pattern to match the given tag and capture the content within it pattern = f\'<{tag}[^>]*>(.*?)</{tag}>\' # Using re.findall to find all occurrences of the pattern content_list = re.findall(pattern, html, re.DOTALL) # Return the list of matched content return content_list"},{"question":"# Problem Statement You are given a list of transactions representing stock prices at different time intervals throughout a single day. Each transaction is represented as a tuple containing the timestamp (an integer) and the stock price at that time (a float). The goal is to implement a function that calculates the maximum profit you can achieve from a single buy and sell operation within the given chronological data. # Function Signature ```python def maximum_profit(transactions: List[Tuple[int, float]]) -> float: Calculate the maximum profit from a single buy and sell operation given a list of stock transactions. Parameters: transactions (List[Tuple[int, float]]): A list where each tuple contains an integer timestamp and a float stock price. Returns: float: The maximum possible profit from a single buy and sell operation. If no profit is possible, return 0.0. Example: >>> transactions = [(1, 100.0), (2, 180.0), (3, 260.0), (4, 310.0), (5, 40.0), (6, 535.0), (7, 695.0)] >>> maximum_profit(transactions) 655.0 >>> transactions = [(1, 120.0), (2, 90.0), (3, 70.0), (4, 65.0), (5, 60.0)] >>> maximum_profit(transactions) 0.0 ``` # Constraints * Transactions are given in chronological order by their timestamps. * You cannot sell before you buy. * If no profit can be made, the function should return 0.0. * Assume the list of transactions always contains at least two data points. # Example Input ```python transactions = [(1, 100.0), (2, 180.0), (3, 260.0), (4, 310.0), (5, 40.0), (6, 535.0), (7, 695.0)] ``` # Example Output ```python 655.0 ``` # Performance Requirements * Your solution should handle lists containing up to 10,000 transactions efficiently. * Ensure the function executes in linear time complexity ( O(n) ), where ( n ) is the number of transactions. * Consider edge cases where prices continuously decrease or remain constant throughout the day.","solution":"from typing import List, Tuple def maximum_profit(transactions: List[Tuple[int, float]]) -> float: if not transactions or len(transactions) < 2: return 0.0 min_price = transactions[0][1] max_profit = 0.0 for _, price in transactions: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"# Coding Assessment Question Problem Statement Water jug problem: You are given two empty jugs with capacities of `a` liters and `b` liters respectively. Your goal is to measure exactly `c` liters of water using these two jugs, where `0 <= c <= max(a, b)`. The operations you can perform are: 1. Fill one of the jugs completely. 2. Empty one of the jugs completely. 3. Pour water from one jug into the other jug until one of the jugs is either empty or full. Write a function to determine whether it is possible to measure exactly `c` liters of water using the two jugs. If it is possible, return True; otherwise, return False. Function Signature ```python def can_measure_water(a: int, b: int, c: int) -> bool: ``` Input - `a` (int): The capacity of the first jug (liters). Value is positive. - `b` (int): The capacity of the second jug (liters). Value is positive. - `c` (int): The target amount of water to measure (liters). Value can be zero. Output - Returns a boolean value indicating whether it is possible (`True`) or not (`False`) to measure exactly `c` liters using the two jugs. Constraints - `1 <= a, b <= 10^6` - `0 <= c <= 10^6` Examples ```python >>> can_measure_water(3, 5, 4) True >>> can_measure_water(2, 6, 5) False >>> can_measure_water(1, 2, 3) True >>> can_measure_water(9, 5, 6) True >>> can_measure_water(8, 3, 0) True ``` Hints: - Use the Breadth-First Search (BFS) or the greatest common divisor (gcd) approach to determine if the measurement is possible. - If `c` is more than the sum of both jugs\' capacities, it is impossible to measure it. - Check if `c` is a multiple of the gcd of `a` and `b`. Restrictions - Assume both jugs are initially empty. - Raise a `ValueError` if any input value is non-positive or if `c` is greater than the sum of the capacities of both jugs.","solution":"import math def can_measure_water(a: int, b: int, c: int) -> bool: Returns True if it is possible to measure exactly c liters of water using two jugs with capacities a and b liters respectively. if a <= 0 or b <= 0 or c < 0: raise ValueError(\\"Invalid input: capacities must be positive and target must be non-negative\\") if c > a + b: return False # Check if c is a multiple of the greatest common divisor of a and b return c % math.gcd(a, b) == 0"},{"question":"# Coding Assessment Question: Scenario: You are tasked with creating a function that identifies whether a given string follows the \\"snake_case\\" naming convention commonly used in programming. Function Specification: Write a function `is_snake_case(input_string: str) -> bool` that determines if a given string adheres to the \\"snake_case\\" format. Input: * `input_string`: a string (length between 1 and 1000 characters) which needs to be checked for snake_case compliance. Output: * Returns `True` if the `input_string` is in snake_case format, otherwise returns `False`. Constraints: * Raise a `TypeError` if `input_string` is not of type `str`. Definition of snake_case: * Contains only lowercase letters, digits, and underscores. * Starts with a letter or digit. * Does not have consecutive underscores. * Does not end with an underscore. Examples: ```python >>> is_snake_case(\\"valid_snake_case\\") True >>> is_snake_case(\\"also_valid1\\") True >>> is_snake_case(\\"_invalid_start\\") False >>> is_snake_case(\\"invalid__double_underscore\\") False >>> is_snake_case(\\"invalidEnd_\\") False >>> is_snake_case(\\"InvalidUpperCase\\") False >>> is_snake_case(12345) Traceback (most recent call last): ... TypeError: Input must be a string ``` Ensure your function correctly identifies and handles edge cases, validates the input, raises errors for invalid cases, and accurately determines snake_case compliance.","solution":"def is_snake_case(input_string: str) -> bool: Determines if a given string adheres to the snake_case format. Args: - input_string (str): The string to check. Returns: - bool: True if the input_string is in snake_case format, otherwise False. Raises: - TypeError: If input_string is not of type str. # Raise TypeError if input is not a string if not isinstance(input_string, str): raise TypeError(\\"Input must be a string\\") # Check for valid snake_case format if not input_string: return False if not (input_string[0].islower() or input_string[0].isdigit()): return False if input_string.endswith(\'_\'): return False if \'__\' in input_string: return False for char in input_string: if not (char.islower() or char.isdigit() or char == \'_\'): return False return True"},{"question":"# Question You are developing a text-based game engine that handles a sequence of commands to manage player actions and game state. Each command modifies the game state, and your task is to implement the engine that processes these commands. Function Specifications: 1. **process_command(command: str, state: dict) -> dict** * Processes the input `command` and updates the game `state` accordingly. * Available commands: * `\\"collect <item>\\"`: Adds `<item>` to the player\'s inventory. * `\\"use <item>\\"`: Removes `<item>` from the player\'s inventory if it exists. * `\\"move <direction>\\"`: Updates the player\'s current `location` to `<direction>`. 2. **initialize_state() -> dict** * Initializes the game state with the following default values: * `\\"inventory\\"`: An empty list. * `\\"location\\"`: The initial location is `\\"home\\"`. Input/Output Requirements: * Commands are given as strings and each command should be processed independently to update the state. * The state is a dictionary that holds the game information, including the player\'s inventory and current location. * The engine should handle a sequence of multiple commands, updating the state step-by-step for each command. Constraints: * Commands will be valid and in the expected format. * No specific constraints on the length of inventory or number of commands. Example: ```python def test_game_engine(): state = initialize_state() commands = [ \\"collect sword\\", \\"move north\\", \\"use sword\\", \\"move east\\", \\"collect shield\\" ] for command in commands: state = process_command(command, state) assert state == { \\"inventory\\": [\\"shield\\"], \\"location\\": \\"east\\" } test_game_engine() ``` Additional Context: Imagine you are creating this engine for a text-based adventure game where players can collect items, use items, and move between different locations. The game state should accurately reflect the player\'s actions as they progress through the game. You are expected to implement these functions ensuring they handle the sequence of commands correctly and maintain the integrity of the game state.","solution":"def process_command(command: str, state: dict) -> dict: Processes a command and updates the game state accordingly. Available commands: * \\"collect <item>\\": Adds <item> to the player\'s inventory. * \\"use <item>\\": Removes <item> from the player\'s inventory if it exists. * \\"move <direction>\\": Updates the player\'s current location to <direction>. parts = command.split(\' \', 1) action = parts[0] if action == \\"collect\\" and len(parts) == 2: item = parts[1] state[\\"inventory\\"].append(item) elif action == \\"use\\" and len(parts) == 2: item = parts[1] if item in state[\\"inventory\\"]: state[\\"inventory\\"].remove(item) elif action == \\"move\\" and len(parts) == 2: direction = parts[1] state[\\"location\\"] = direction return state def initialize_state() -> dict: Initializes the game state with the default values: * \\"inventory\\": An empty list. * \\"location\\": The initial location is \\"home\\". return { \\"inventory\\": [], \\"location\\": \\"home\\" }"},{"question":"# Coding Assessment Question Scenario You are developing a text processing tool that helps to identify unique words used in large documents. As part of this tool, you need to implement a feature that can count the number of unique words in a given text and return these words sorted alphabetically. Task Write a function `unique_words(text)` that takes a string as input (representing the text) and returns a list of unique words in alphabetical order. Input * `text`: A string containing the text that needs to be processed. Output * A list of strings, where each string is a unique word from the input text, sorted alphabetically. Constraints * Words are case-insensitive. The words \\"Hello\\" and \\"hello\\" should be considered the same. * Punctuation is not part of a word and should be ignored. * The text string will contain at most 10000 characters. * The function should return the unique words in lowercase. Example Input ```python text = \\"Hello, world! Hello Programming world.\\" ``` Example Output ```python [\'hello\', \'programming\', \'world\'] ``` Additional Instructions Ensure your code handles diverse cases of punctuation and capitalization. Use built-in string handling and set operations to simplify the process of identifying and counting unique words. Hint To handle punctuation, consider using regular expressions or string methods to remove unwanted characters. Convert the text to lowercase to ensure words are counted in a case-insensitive manner.","solution":"import re def unique_words(text): Returns a list of unique words from the input text, sorted alphabetically. # Remove punctuation using regex and convert text to lowercase words = re.findall(r\'bw+b\', text.lower()) # Use a set to find unique words unique_words_set = set(words) # Sort the unique words alphabetically and return as a list return sorted(unique_words_set)"},{"question":"# Problem Statement: Largest Subarray with at Most ( K ) Distinct Characters You are given a string ( s ) and an integer ( k ). Your task is to implement a function that finds the length of the largest subarray (substring) of ( s ) that contains at most ( k ) distinct characters. # Function Specifications longest_subarray_with_k_distinct **Parameters**: - `s`: A string of lowercase and uppercase English letters. - `k`: An integer representing the maximum number of distinct characters allowed in the subarray. **Returns**: - An integer representing the length of the largest subarray with at most ( k ) distinct characters. Example ```python def longest_subarray_with_k_distinct(s: str, k: int) -> int: # Your implementation here ``` Input: ```python s = \\"eceba\\" k = 2 ``` Output: ```python 3 ``` Input: ```python s = \\"aa\\" k = 1 ``` Output: ```python 2 ``` Constraints - ( 0 leq |s| leq 10^5 ) - ( 1 leq k leq 26 ) # Notes - Use an efficient algorithm, aiming for a linear time complexity solution. - Handle edge cases such as empty strings or ( k ) being greater than the number of unique characters in ( s ). - Ensure your implementation can handle both mixed-case strings and strings with special characters. # Hints - Consider using the sliding window technique to solve this problem efficiently. - A dictionary or hashmap can be useful for tracking the frequency of characters in the current window.","solution":"def longest_subarray_with_k_distinct(s: str, k: int) -> int: if not s or k == 0: return 0 char_frequency = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_frequency: char_frequency[s[right]] += 1 else: char_frequency[s[right]] = 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"**Question**: Implementing a Custom Sorting Function You are tasked with implementing a custom sorting function that sorts a list of integers based on a specific rule. The rule is to sort the integers primarily by their absolute values in ascending order. If two integers have the same absolute value, they should retain their original relative order in the list. # Problem Statement Given a list of integers, arrange them such that they are sorted by their absolute values in ascending order. If two integers have the same absolute value, their order from the original list should be preserved. # Input Format - A list of integers `nums` representing the numbers to be sorted. # Output Format - A list of integers sorted according to the specified rule. # Constraints - The input list `nums` will have at least one integer and no more than 1000 integers. - Each integer in the list will be between `-1000` and `1000` inclusive. # Example ```python def custom_sort(nums: list) -> list: return sorted(nums, key=lambda x: (abs(x), nums.index(x))) # Example Usage: print(custom_sort([10, -4, 3, -10, 2])) # Output: [2, 3, -4, 10, -10] print(custom_sort([-1, 3, -3, 4, 0, -1])) # Output: [0, -1, -1, 3, -3, 4] ``` # Notes - The sorting criteria must prioritize the absolute value of the numbers. - Stability of the sorting process must be maintained, meaning that if two numbers have the same absolute value, their original order within the list should not be altered. - Consider edge cases such as all elements being negative or positive, or a list with duplicate values. The given solution employs a lambda function in the `sorted` method to achieve the sorting criteria, using the absolute value of each number and its index in the list to ensure stability.","solution":"def custom_sort(nums: list) -> list: Sort a list of integers primarily by their absolute values in ascending order. If two integers have the same absolute value, they retain their original relative order. return sorted(nums, key=lambda x: (abs(x), nums.index(x)))"},{"question":"# Coding Assessment Question **Title**: Implement Longest Common Subsequence (LCS) Calculation **Context**: You are developing a text comparison tool that highlights differences between two sequences of text. One of the crucial aspects of this tool is to compute the Longest Common Subsequence (LCS) between two strings. The LCS is the longest subsequence that appears in the same order in both strings, but not necessarily consecutively. **Task**: Write a function `calculate_lcs` that takes two strings and returns the length of their longest common subsequence. **Input**: - `str1`: a string consisting of lowercase and uppercase English letters only. - `str2`: a string consisting of lowercase and uppercase English letters only. **Output**: - An integer representing the length of the longest common subsequence. **Constraints**: - The lengths of `str1` and `str2` will be between 1 and 1,000. **Example**: ```python str1 = \\"AGGTAB\\" str2 = \\"GXTXAYB\\" print(calculate_lcs(str1, str2)) ``` **Expected Output**: ``` 4 ``` **Explanation**: The longest common subsequence is \\"GTAB\\". **Notes**: - You may use dynamic programming to efficiently compute the LCS length. - Pay attention to case sensitivity; the function should treat uppercase and lowercase letters as distinct characters. - Optimize your function to handle the upper limit of the constraints within reasonable time limits.","solution":"def calculate_lcs(str1, str2): This function returns the length of the Longest Common Subsequence (LCS) between two strings. m = len(str1) n = len(str2) # Create a 2D array to store the lengths of LCS dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Problem Statement You are given a list of strings. Write a function that finds the smallest list of substrings such that concatenation of these substrings (in any order) can generate every string in the given list. Each substring can only appear once in the result list. # Function Signature ```python def minimal_substrings(lst: list[str]) -> list[str]: ``` # Input * `lst`: A list of strings. Each string consists of lowercase English letters. # Output * Returns a list of strings that represents the smallest set of substrings. The order in the returned list doesn\'t matter. # Constraints * The length of the list `lst` will not exceed 10^3. * The length of each string in `lst` will not exceed 10^3. # Examples ```python >>> minimal_substrings([\\"apple\\", \\"app\\", \\"lemon\\"]) [\'e\', \'n\', \'o\', \'p\', \'l\', \'a\', \'m\'] >>> minimal_substrings([\\"cat\\", \\"dog\\", \\"catdog\\"]) [\'c\', \'a\', \'t\', \'d\', \'o\', \'g\'] >>> minimal_substrings([\\"abcd\\", \\"efgh\\"]) [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\'] >>> minimal_substrings([\\"abcabc\\", \\"cab\\", \\"bca\\"]) [\'a\', \'b\', \'c\'] >>> minimal_substrings([\\"aaaa\\", \\"aaa\\"]) [\'a\'] ``` # Additional Notes * The function should handle edge cases like empty lists, lists with repeated characters, and the mix of truly minimal substrings efficiently. * Consider the performance implications and ensure the solution is optimized for large lists and long strings.","solution":"def minimal_substrings(lst): Finds the smallest list of substrings such that concatenation of these substrings (in any order) can generate every string in the given list. unique_chars = set() for string in lst: unique_chars.update(string) return list(unique_chars)"},{"question":"# Problem Statement Develop a function that computes the minimum number of operations required to transform a given string `s1` into another string `s2` using only the following operations: insertion, deletion, or substitution of a single character. This problem is also known as the \\"Levenshtein Distance\\" problem. # Function Signature ```python def levenshtein_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform the string s1 into s2. ``` # Input - `s1`: A string (1 <= len(s1) <= 100) representing the original string. - `s2`: A string (1 <= len(s2) <= 100) representing the target string. # Output - An integer representing the minimum number of operations required to transform `s1` into `s2`. # Constraints - Handle edge cases such as empty strings (`\\"\\"`). - Efficiency is important, so ensure that your solution runs in polynomial time. - Use dynamic programming for an optimal solution. # Example ```python >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 >>> levenshtein_distance(\\"apple\\", \\"apple\\") 0 ``` # Performance Requirements - Aim for a solution with a time complexity of O(n * m) and space complexity of O(n * m), where `n` is the length of `s1` and `m` is the length of `s2`. - The solution should be efficient enough to handle the upper limit constraint (lengths up to 100) within a reasonable time frame. Good luck!","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform the string s1 into s2. n, m = len(s1), len(s2) if n == 0: return m if m == 0: return n # Create a matrix to store distances dp = [[0 for _ in range(m+1)] for _ in range(n+1)] # Initialize the first row and column of the matrix for i in range(n+1): dp[i][0] = i for j in range(m+1): dp[0][j] = j # Fill the matrix for i in range(1, n+1): for j in range(1, m+1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j] + 1, # deletion dp[i][j-1] + 1, # insertion dp[i-1][j-1] + 1) # substitution return dp[n][m]"},{"question":"# Scenario You are building a library management system where books are categorized into various genres, and users can borrow and return books. Each book is uniquely identified by an ISBN, and each user is identified by a unique user ID. Your task is to implement a recommendation system that suggests books to users based on the genres of the books they have previously borrowed. # Problem Statement Write a program that maintains the record of users and the genres of the books they borrow. Your task is to implement a function to recommend a list of books from the available catalog that match the user\'s most frequently borrowed genre. If there are books from other genres that the user has borrowed, those should also be considered but given a lower priority in the recommendation list. # Function Signature ```python def recommend_books(catalog: List[Dict[str, str]], user_borrowed: Dict[int, List[str]]) -> Dict[int, List[str]]: pass ``` # Input - `catalog`: A list of dictionaries where each dictionary represents a book. Each dictionary contains two keys: `\\"isbn\\"` (a unique string representing the book\'s ISBN) and `\\"genre\\"` (a string representing the genre of the book). - `user_borrowed`: A dictionary where each key is a user ID (integer) and the value is a list of genres (strings) representing the genres of books the user has borrowed in the past. # Output - A dictionary where each key is a user ID (integer) and the value is a list of ISBNs (strings) that are recommended for that user. The list should prioritize books from the user\'s most frequently borrowed genre. # Constraints - The `catalog` will always contain at least one book from each borrowed genre. - The `user_borrowed` dictionary will always have at least one genre for each user. - There should be no duplicate ISBN values in the recommendation list for any user. # Example ```python catalog = [ {\\"isbn\\": \\"1234\\", \\"genre\\": \\"Fantasy\\"}, {\\"isbn\\": \\"5678\\", \\"genre\\": \\"Science Fiction\\"}, {\\"isbn\\": \\"9101\\", \\"genre\\": \\"Fantasy\\"}, {\\"isbn\\": \\"1121\\", \\"genre\\": \\"Romance\\"}, {\\"isbn\\": \\"3141\\", \\"genre\\": \\"Science Fiction\\"} ] user_borrowed = { 1: [\\"Fantasy\\", \\"Science Fiction\\", \\"Fantasy\\"], 2: [\\"Romance\\", \\"Romance\\", \\"Fantasy\\"], 3: [\\"Science Fiction\\"] } print(recommend_books(catalog, user_borrowed)) # Expected Output: # { # 1: [\\"1234\\", \\"9101\\", \\"5678\\", \\"3141\\"], # 2: [\\"1121\\", \\"1234\\", \\"9101\\"], # 3: [\\"5678\\", \\"3141\\"] # } ``` # Notes - Ensure that the recommendations do not include duplicate ISBNs for each user. - Prioritize books from the user\'s most frequently borrowed genre, followed by other genres they have borrowed from. - If a user has borrowed books from multiple genres with the same frequency, treat them with equal priority in the recommendation list.","solution":"from collections import defaultdict, Counter from typing import List, Dict def recommend_books(catalog: List[Dict[str, str]], user_borrowed: Dict[int, List[str]]) -> Dict[int, List[str]]: # Create a mapping of genres to books for quick look-up genre_to_books = defaultdict(list) for book in catalog: genre_to_books[book[\'genre\']].append(book[\'isbn\']) recommendations = {} for user, genres in user_borrowed.items(): # Count the frequency of each genre in the user\'s borrowed list genre_count = Counter(genres) most_common_genres = [genre for genre, count in genre_count.most_common()] # Generate the list of recommended books user_recommendations = [] seen_isbns = set() for genre in most_common_genres: for isbn in genre_to_books[genre]: if isbn not in seen_isbns: user_recommendations.append(isbn) seen_isbns.add(isbn) recommendations[user] = user_recommendations return recommendations"},{"question":"# Subarray Sum Equals K You are tasked with finding the number of continuous subarrays within an array that sum up to a given target value, `k`. Task: Subarray Sum Calculation Write a function, `subarray_sum(nums: list[int], k: int) -> int`, that calculates the number of contiguous subarrays whose cumulative sum equals the target value, `k`. Input: 1. A list of integers, `nums: list[int]`, where `1 ≤ len(nums) ≤ 2 * 10^4`, and `-10^5 ≤ nums[i] ≤ 10^5`. 2. An integer, `k: int`, where `-10^7 ≤ k ≤ 10^7`. Output: 1. Return an integer representing the count of contiguous subarrays that sum to `k`. Example: ```python # Given nums and target k nums = [1, 1, 1] k = 2 # Calculate the number of subarrays count = subarray_sum(nums, k) # Output: Number of subarrays that sum to k, e.g., 2 print(count) # Output: 2 ``` Constraints: - The length of `nums` will not exceed `2 * 10^4`. - Elements in `nums` can be negative, zero, or positive. Performance Requirements: - Aim for a time complexity of `O(n)` for the solution. # References: - Consider using a hashmap to store cumulative sums and their frequencies to achieve efficient lookups and updates. - Ensure your solution handles large ranges of possible integer values and employs an optimal approach for counting subarrays. Walkthrough: 1. Iterate through the array while maintaining a running cumulative sum. 2. Use a hashmap to track the frequency of each cumulative sum observed. 3. For each element in the array, determine if there\'s a previous sum that, when subtracted, equals the target `k`. By adhering to these guidelines, you will be able to efficiently find the number of contiguous subarrays that sum to the provided target value. --- In this new question, the style, length, difficulty level, and topic are aligned with the provided KD-Tree construction and nearest neighbor search question. The problem focuses on a fundamental algorithmic concept relevant in coding assessments, promoting skills such as hashing for efficient solution design.","solution":"def subarray_sum(nums: list[int], k: int) -> int: Calculates the number of contiguous subarrays that sum to a given target value k. :param nums: List of integers :param k: Target sum :return: Number of contiguous subarrays summing to k count = 0 current_sum = 0 sum_counts = {0: 1} # Initialize with zero sum having one count for num in nums: current_sum += num if (current_sum - k) in sum_counts: count += sum_counts[current_sum - k] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"# String Transformation Path Context: You are designing a word puzzle game where players must transform a starting word into an ending word using a sequence of valid transformations. Each transformation changes only one letter at a time, and each intermediate word must also be a valid word found in a given dictionary. Task: Write a function `find_transformation_path` that: 1. **Reads Input**: - A starting word, an ending word, and a list of valid dictionary words. 2. **Processes**: - Finds the shortest transformation path from the starting word to the ending word where each transformed word is in the provided dictionary and only one letter changes at a time. 3. **Outputs**: - Returns a list representing the shortest sequence of words transforming from the starting word to the ending word. If no such path exists, return an empty list. Input: * A `start_word` (string). * An `end_word` (string). * A list of strings `words` that represents the dictionary. Output: * A list of strings representing the word transformation sequence from `start_word` to `end_word`. If no sequence exists, return an empty list. Constraints: * 1 <= len(start_word) == len(end_word) <= 10 * 1 <= len(words) <= 5000 * Words consist of lowercase English letters. Example: ```python def find_transformation_path(start_word: str, end_word: str, words: list[str]) -> list[str]: pass # Example usage: start_word = \\"hit\\" end_word = \\"cog\\" words = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] result = find_transformation_path(start_word, end_word, words) print(result) # Should print: [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] ``` Performance Criteria: * Efficient use of algorithms to handle up to 5000 dictionary words efficiently. * Correct handling of edge cases, such as non-existent paths or invalid inputs. * Clear and readable code, adhering to good programming practices.","solution":"from collections import deque def find_neighbours(word, words_set): neighbours = [] for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = word[:i] + c + word[i+1:] if next_word in words_set and next_word != word: neighbours.append(next_word) return neighbours def find_transformation_path(start_word, end_word, words): words_set = set(words) if end_word not in words_set: return [] queue = deque([(start_word, [start_word])]) visited = set([start_word]) while queue: current_word, path = queue.popleft() if current_word == end_word: return path for neighbour in find_neighbours(current_word, words_set): if neighbour not in visited: visited.add(neighbour) queue.append((neighbour, path + [neighbour])) return []"},{"question":"# Chess Move Validator Context You are building an application to validate chess moves. In a standard chess game, each piece moves in specific ways and certain moves are not allowed based on the state of the game board. For simplicity, this task focuses only on the individual piece movement rules without considering the entire game state (like other pieces blocking moves). Task Write a function that reads a chess piece type, its current position, and a target position, and determines if the move is valid based on the standard movement rules for that piece. Function Signature ```python def is_valid_move(piece_type: str, current_pos: str, target_pos: str) -> bool: ... ``` Input - `piece_type` (str): Type of the chess piece (one of \\"pawn\\", \\"rook\\", \\"knight\\", \\"bishop\\", \\"queen\\", \\"king\\"). - `current_pos` (str): Current position of the piece in algebraic notation (e.g., \\"e2\\"). - `target_pos` (str): Target position for the piece in algebraic notation (e.g., \\"e4\\"). Output - Returns a boolean value: `True` if the move is valid, `False` otherwise. Constraints - `piece_type` is always one of the predefined types. - `current_pos` and `target_pos` are valid positions in standard chess notation (a1 to h8). - Assume white pieces for simplicity (e.g., pawn moving \\"up\\" the board). Movement Rules - **Pawn**: Moves one square forward to an empty square or moves diagonally forward one square to capture. - **Rook**: Moves any number of squares vertically or horizontally. - **Knight**: Moves in an L-shape: two squares in one direction and then one square perpendicular. - **Bishop**: Moves any number of squares diagonally. - **Queen**: Moves any number of squares vertically, horizontally, or diagonally. - **King**: Moves one square in any direction. Example ```python # Example 1 piece_type = \\"pawn\\" current_pos = \\"a2\\" target_pos = \\"a3\\" assert is_valid_move(piece_type, current_pos, target_pos) == True # Example 2 piece_type = \\"knight\\" current_pos = \\"g1\\" target_pos = \\"f3\\" assert is_valid_move(piece_type, current_pos, target_pos) == True # Example 3 piece_type = \\"rook\\" current_pos = \\"a1\\" target_pos = \\"a4\\" assert is_valid_move(piece_type, current_pos, target_pos) == True # Example 4 piece_type = \\"bishop\\" current_pos = \\"c1\\" target_pos = \\"h6\\" assert is_valid_move(piece_type, current_pos, target_pos) == True # Example 5 piece_type = \\"queen\\" current_pos = \\"d1\\" target_pos = \\"h5\\" assert is_valid_move(piece_type, current_pos, target_pos) == False # Invalid move for any piece ```","solution":"def is_valid_move(piece_type: str, current_pos: str, target_pos: str) -> bool: def position_to_coords(pos): return ord(pos[0]) - ord(\'a\'), int(pos[1]) - 1 current_x, current_y = position_to_coords(current_pos) target_x, target_y = position_to_coords(target_pos) if piece_type == \\"pawn\\": if current_x == target_x and current_y + 1 == target_y: return True if current_x == target_x and current_y == 1 and target_y == 3: return True if abs(current_x - target_x) == 1 and current_y + 1 == target_y: return True elif piece_type == \\"rook\\": return current_x == target_x or current_y == target_y elif piece_type == \\"knight\\": return (abs(current_x - target_x) == 2 and abs(current_y - target_y) == 1) or (abs(current_x - target_x) == 1 and abs(current_y - target_y) == 2) elif piece_type == \\"bishop\\": return abs(current_x - target_x) == abs(current_y - target_y) elif piece_type == \\"queen\\": return (current_x == target_x or current_y == target_y) or (abs(current_x - target_x) == abs(current_y - target_y)) elif piece_type == \\"king\\": return abs(current_x - target_x) <= 1 and abs(current_y - target_y) <= 1 return False"},{"question":"# Most Frequent Subtree Sum Challenge Objective: Implement a function to find the most frequent sum of values in any subtree within a given binary tree. Context: Efficient aggregation and analysis of node values are paramount in applications like error detection in hierarchical data, where identifying common value patterns can be crucial. By determining the most frequent subtree sum, one can derive insights into common value groupings within the data structure. Problem Statement: Given a binary tree, the task is to identify the sums of all its subtrees and find the most frequent subtree sum. A subtree sum is the sum of all the node values in that subtree. You need to write a function `find_frequent_tree_sum` which takes the root of the binary tree and returns a list of the most frequent subtree sums. If there is a tie for the most frequent sum, return all the sums in any order. Function Signature: ```python def find_frequent_tree_sum(root: TreeNode | None) -> List[int]: ``` Input: - `root`: A TreeNode representing the root of the binary tree. Each TreeNode has `val`, `left`, and `right` attributes. Output: - A list of integers representing the most frequent subtree sums. Constraints: - The number of nodes in the tree is in the range [1, 10^4]. - -10^4 <= Node.val <= 10^4. Example: ```python # Example binary tree # 5 # / # 2 -3 t1 = TreeNode(5) t1.left = TreeNode(2) t1.right = TreeNode(-3) print(find_frequent_tree_sum(t1)) # Output should be [2, -3, 4] # Another example binary tree # 5 # / # 2 -5 t2 = TreeNode(5) t2.left = TreeNode(2) t2.right = TreeNode(-5) print(find_frequent_tree_sum(t2)) # Output should be [2] ``` Note: - Ensure the solution accounts for all possible input scenarios, including trees with negative node values and varied tree structures. - Handle edge cases such as an entire tree being a single node and when all nodes have the same value. - The implementation should efficiently manage larger trees within the given constraints. This problem tests the ability to perform complex tree analysis and aggregation, ensuring proficiency in recursion and data structure manipulation.","solution":"from collections import defaultdict from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_frequent_tree_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] def subtree_sum(node: TreeNode) -> int: if not node: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) total_sum = node.val + left_sum + right_sum sum_count[total_sum] += 1 return total_sum sum_count = defaultdict(int) subtree_sum(root) max_freq = max(sum_count.values()) most_frequent_sums = [s for s, count in sum_count.items() if count == max_freq] return most_frequent_sums"},{"question":"# Question: Optimized Bucket Sort Implement an optimized version of the Bucket Sort algorithm, tailored for an array of floating-point numbers uniformly distributed over the range ([0, 1)). The optimization should include dynamically adjusting the number of buckets based on the input size to ensure efficient sorting. Your task is to write a function `optimized_bucket_sort(data: list) -> list` in Python, which takes a list of floating-point numbers and returns the sorted list. # Input: * A list of floating-point numbers `data`, where (1 leq text{len(data)} leq 10^6) and (0 leq text{data}[i] < 1). # Output: * A list containing the sorted floating-point numbers in ascending order. # Constraints: * Optimize the sorting for large datasets by appropriately adjusting the number of buckets. * Ensure stable sorting within each bucket. # Performance Requirements: * Aim for an average time complexity of (O(n + k log k)), where (n) is the number of elements and (k) is the number of buckets. # Examples: Example 1: ```python data = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] print(optimized_bucket_sort(data)) # Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` Example 2: ```python data = [0.23, 0.42, 0.89, 0.1, 0.5, 0.73] print(optimized_bucket_sort(data)) # Output: [0.1, 0.23, 0.42, 0.5, 0.73, 0.89] ``` Example 3: ```python data = [0.3] print(optimized_bucket_sort(data)) # Output: [0.3] ``` # Hints: * Determine an appropriate number of buckets to balance between bucket sizes and the total number of buckets. * Ensure that each bucket is sorted using an efficient algorithm (consider using an in-place sorting like Timsort for Python).","solution":"def optimized_bucket_sort(data): Optimized bucket sort for floating point numbers uniformly distributed over [0, 1). if len(data) <= 1: return data n = len(data) # Dynamic number of buckets bucket_count = max(1, int(n ** 0.5)) buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for value in data: bucket_index = int(value * bucket_count) buckets[bucket_index].append(value) # Sort individual buckets and concatenate results sorted_data = [] for bucket in buckets: bucket.sort() # Timsort is used under the hood in Python\'s sort() sorted_data.extend(bucket) return sorted_data"},{"question":"# Problem Statement Given an array of integers representing daily temperatures, return a new array such that each element in the new array is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. # Requirements and Constraints 1. **Input**: - `temperatures`: A list of integers `temperatures` where each element is an integer representing the temperature of that day. 2. **Output**: - Returns a list of integers where each element is the number of days until a warmer temperature. 3. **Constraints**: - The length of the `temperatures` array will be in the range [1, 10^5]. - Each temperature value in the `temperatures` array will be in the range [30, 100]. # Example **Input**: ```python temperatures = [73, 74, 75, 71, 69, 72, 76, 73] ``` **Output**: ```python [1, 1, 4, 2, 1, 1, 0, 0] ``` # Instructions 1. Implement the function `daily_temperatures(temperatures: List[int]) -> List[int]`. 2. Ensure the output list has the same length as the input list. 3. Use appropriate data structures that optimize query and update operations. ```python from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: # Your code goes here pass # Example usage: # temperatures = [73, 74, 75, 71, 69, 72, 76, 73] # result = daily_temperatures(temperatures) ``` In this additional question, you are required to process a list of daily temperatures and determine how many days it will take for each day\'s temperature to encounter a warmer temperature. This involves leveraging appropriate data structures to manage and compare elements efficiently, ensuring the solution scales well for the input constraints.","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: length = len(temperatures) answer = [0] * length stack = [] # This will store indices of the temperatures list for i in range(length - 1, -1, -1): # Maintain the stack to only include days with higher temperatures while stack and temperatures[i] >= temperatures[stack[-1]]: stack.pop() if stack: answer[i] = stack[-1] - i stack.append(i) return answer"},{"question":"# Fibonacci Sequence Checker Scenario You are tasked with implementing a function that determines whether a given positive integer is a number in the Fibonacci sequence. Fibonacci numbers are a series of numbers in which each number is the sum of the two preceding ones, typically starting with 0 and 1. The first few Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on. Your implementation must efficiently validate if a number belongs to this sequence and handle various edge cases, including invalid types and negative numbers gracefully. Function Signature ```python def is_fibonacci(n: int) -> bool: ``` Input - `n` (int): A positive integer. Output - Return `True` if `n` is a Fibonacci number, otherwise return `False`. Constraints - `n` should be a positive integer. - If `n` is negative, raise a `ValueError` with the message \\"the value must be a positive integer\\". - If `n` is not an integer, raise a `TypeError`. Examples ```python >>> is_fibonacci(0) True >>> is_fibonacci(1) True >>> is_fibonacci(2) True >>> is_fibonacci(4) False >>> is_fibonacci(5) True >>> is_fibonacci(21) True >>> is_fibonacci(22) False >>> is_fibonacci(-8) Traceback (most recent call last): ... ValueError: the value must be a positive integer >>> is_fibonacci(8.8) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> is_fibonacci(\\"8\\") Traceback (most recent call last): ... TypeError: \'<\' not supported between instances of \'str\' and \'int\' ``` **Notes**: - You may use mathematical characteristics of Fibonacci numbers for the solution. - Ensure your solution is well-documented and handles corner cases effectively. Task Implement the `is_fibonacci` function as specified. Ensure all edge cases are covered and validate inputs thoroughly.","solution":"import math def is_fibonacci(n: int) -> bool: Checks if a given integer n is a Fibonacci number. Parameters: n (int): The number to check. Returns: bool: True if n is a Fibonacci number, False otherwise. Raises: ValueError: If n is negative. TypeError: If n is not an integer. if not isinstance(n, int): raise TypeError(f\\"\'{type(n).__name__}\' object cannot be interpreted as an integer\\") if n < 0: raise ValueError(\\"the value must be a positive integer\\") def is_perfect_square(x): s = int(math.isqrt(x)) return s * s == x # A number is a Fibonacci number if and only if one or both of # (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)"},{"question":"# Coding Question: Implementing a Multi-threaded File Copy Utility You are given a requirement to create a file copy utility that copies files from a source directory to a destination directory. The utility should leverage multi-threading to copy multiple files simultaneously, improving the overall performance compared to a single-threaded approach. # Task 1. **Implement Multi-threaded File Copy**: - Create a function `copy_file(src_file, dest_file)` that copies a file from `src_file` to `dest_file`. - Implement a class `FileCopyManager` that manages the multi-threaded copying of files. 2. **Functionality**: - The `FileCopyManager` class should have a method `copy_files_multithreaded(src_dir, dest_dir)` that copies all files from `src_dir` to `dest_dir` using multiple threads. - Ensure that the number of threads used is configurable via an argument `num_threads` with a sensible default value (e.g., 4). 3. **Error Handling**: - Handle exceptions that might occur during file I/O operations gracefully and log errors. 4. **Required Code Implementation**: - Implement the `copy_file` function. - Implement the `FileCopyManager` class with `copy_files_multithreaded` method, including thread management. # Function Signatures ```python import os import shutil import threading def copy_file(src_file, dest_file): Copies a file from src_file to dest_file. :param src_file: str, path to the source file. :param dest_file: str, path to the destination file. try: shutil.copy2(src_file, dest_file) except Exception as e: print(f\\"Error copying {src_file} to {dest_file}: {e}\\") class FileCopyManager: def __init__(self, num_threads=4): self.num_threads = num_threads self.lock = threading.Lock() self.thread_queue = [] def copy_files_multithreaded(self, src_dir, dest_dir): Copies all files from src_dir to dest_dir using multiple threads. :param src_dir: str, path to the source directory. :param dest_dir: str, path to the destination directory. try: if not os.path.exists(dest_dir): os.makedirs(dest_dir) files = os.listdir(src_dir) for i in range(0, len(files), self.num_threads): threads = [] for file_name in files[i:i+self.num_threads]: src_file = os.path.join(src_dir, file_name) dest_file = os.path.join(dest_dir, file_name) thread = threading.Thread(target=copy_file, args=(src_file, dest_file)) threads.append(thread) thread.start() for thread in threads: thread.join() except Exception as e: print(f\\"Error in copying files: {e}\\") ``` # Constraints: 1. Ensure that the copying process handles file I/O operations efficiently and concurrently. 2. Handle large directories with reasonable performance. # Sample Input: ```python src_dir = \\"path/to/source_directory\\" dest_dir = \\"path/to/destination_directory\\" manager = FileCopyManager(num_threads=4) manager.copy_files_multithreaded(src_dir, dest_dir) ``` # Sample Output: ``` Files from \'path/to/source_directory\' are successfully copied to \'path/to/destination_directory\' using multiple threads. ``` # Testing: Provide a set of test cases that verify the following: - The files are copied correctly. - The utility works with empty, smaller, and larger directories. - The error handling mechanism is robust and provides meaningful error messages.","solution":"import os import shutil import threading def copy_file(src_file, dest_file): Copies a file from src_file to dest_file. :param src_file: str, path to the source file. :param dest_file: str, path to the destination file. try: shutil.copy2(src_file, dest_file) except Exception as e: print(f\\"Error copying {src_file} to {dest_file}: {e}\\") class FileCopyManager: def __init__(self, num_threads=4): self.num_threads = num_threads self.lock = threading.Lock() self.threads = [] def copy_files_multithreaded(self, src_dir, dest_dir): Copies all files from src_dir to dest_dir using multiple threads. :param src_dir: str, path to the source directory. :param dest_dir: str, path to the destination directory. if not os.path.exists(dest_dir): os.makedirs(dest_dir) files = os.listdir(src_dir) def worker(files): for file_name in files: src_file = os.path.join(src_dir, file_name) dest_file = os.path.join(dest_dir, file_name) copy_file(src_file, dest_file) file_chunks = [files[i::self.num_threads] for i in range(self.num_threads)] for chunk in file_chunks: thread = threading.Thread(target=worker, args=(chunk,)) self.threads.append(thread) thread.start() for thread in self.threads: thread.join()"},{"question":"**Problem Statement**: You are given an array of integers representing the daily temperature fluctuations. Write a function that outputs an array where each element is the number of days you need to wait until a warmer temperature, and if there is no future day for which this is possible, put `0` instead. **Function Signature**: ```python def daily_temperatures(temps: tuple[int, ...]) -> list[int]: ``` **Inputs**: - `temps`: A tuple of integers representing the daily temperatures. Each element in the tuple is a temperature. The length of the tuple is between 0 and 10^5. **Outputs**: - Return a list of integers where each element represents the number of days to wait until a warmer temperature, or `0` if there is no future warmer day. **Constraints**: - Ensure the solution handles the case with an empty input array. - All temperatures should be integers ranging between -100 and 100. - Aim for an efficient solution with O(n) complexity using appropriate data structures. **Scenario**: Imagine you are working as a meteorologist, analyzing a sequence of daily temperatures. To prepare the weekly weather forecast, you need to determine how long it takes for a warmer day to occur after each day in your data. **Examples**: ```python >>> daily_temperatures((73, 74, 75, 71, 69, 72, 76, 73)) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures((30, 40, 50, 60)) [1, 1, 1, 0] >>> daily_temperatures((30, 20, 10)) [0, 0, 0] ``` **Requirements**: - Implement the function using a stack to achieve the desired time complexity. - Return an empty list if the input is empty. - Ensure to handle varying temperature ranges efficiently. --- By crafting the new question, I\'ve maintained the formatting, complexity, and technical requirement consistency, ensuring a seamless integration with the original set while introducing a novel yet related problem.","solution":"def daily_temperatures(temps: tuple[int, ...]) -> list[int]: Returns a list where each element is the number of days needed to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. :param temps: A tuple of integers representing daily temperatures. :return: A list of integers indicating days to wait for a warmer temperature. n = len(temps) result = [0] * n stack = [] for i in range(n): # While stack is not empty and the current temperature is greater than # the temperature at the index stored at the top of the stack: while stack and temps[i] > temps[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"**Balanced Binary Tree Validation** **Background**: A balanced binary tree is a binary tree structure where the left and right subtrees of every node differ in height by no more than one. This property ensures optimal performance for operations such as insertions, deletions, and lookups. **Problem Statement**: Write a function `is_balanced(root: Optional[TreeNode]) -> bool` to determine if a binary tree is balanced. A `TreeNode` class with attributes `val`, `left`, and `right` is provided to represent nodes of the tree. **Implementation Details**: 1. Create a helper function to calculate the height of the tree while simultaneously checking balance. 2. Use depth-first search (DFS) to traverse the tree and validate the balance property for each node. 3. Return `True` if the tree is balanced, otherwise return `False`. **Input**: * `root` (TreeNode): The root node of the binary tree, which could be `None`. **Output**: * `is_balanced` (bool): A boolean indicating whether the binary tree is balanced. **Constraints**: * The number of nodes in the tree can be quite large (up to 10^4). * The values within the `TreeNode` do not matter for balance checking. **Performance Requirements**: * Your implementation should traverse the tree only once to ensure efficiency. **Example**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.left.left = TreeNode(4) root1.left.right = TreeNode(5) root1.right.right = TreeNode(6) \'\'\' Tree Structure: 1 / 2 3 / 4 5 6 Balanced: True \'\'\' assert is_balanced(root1) == True # Example 2 root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) root2.left.left = TreeNode(4) root2.left.left.left = TreeNode(5) \'\'\' Tree Structure: 1 / 2 3 / 4 / 5 Balanced: False \'\'\' assert is_balanced(root2) == False ``` *Note*: Ensure your function handles edge cases properly, such as empty trees or trees with only one node. The implementation should be optimal to handle large trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): def check_height_balanced(node): if not node: return 0, True left_height, is_left_balanced = check_height_balanced(node.left) right_height, is_right_balanced = check_height_balanced(node.right) current_height = 1 + max(left_height, right_height) is_current_balanced = (abs(left_height - right_height) <= 1) and is_left_balanced and is_right_balanced return current_height, is_current_balanced _, is_balanced_tree = check_height_balanced(root) return is_balanced_tree"},{"question":"# Coding Assessment Question **Context:** You need to design an algorithm that finds the largest possible sum of two distinct elements from a given list of integers. The purpose is to assess your ability to efficiently determine the best possible pair for maximum sum within given constraints. **Problem Statement:** Write a function `max_pair_sum(arr: List[int]) -> int` that takes in a list of integers `arr` and returns the largest possible sum of two distinct elements from the list. **Input:** - A list of integers `arr` where `2 ≤ len(arr) ≤ 10^5` and `-10^6 ≤ arr[i] ≤ 10^6` for each `i`. **Output:** - An integer representing the largest possible sum of any two distinct elements from the list. **Constraints:** - You must ensure to handle large inputs within reasonable time limits. - All elements in the list will be within the given ranges. # Function Signature ```python def max_pair_sum(arr: List[int]) -> int: pass ``` # Examples ```python # Example 1: print(max_pair_sum([5, 9, 7, 1, 2])) # Output: 16 # Explanation: The largest sum is obtained by 9 + 7 = 16. # Example 2: print(max_pair_sum([1, 2, 3, 4, 5])) # Output: 9 # Explanation: The largest sum is obtained by 4 + 5 = 9. # Example 3: print(max_pair_sum([-10, -20, -5, -1])) # Output: -6 # Explanation: The largest sum is obtained by -1 + (-5) = -6. ``` # Notes: Ensure the function runs efficiently with the provided constraints and does not unnecessarily iterate more than needed.","solution":"from typing import List def max_pair_sum(arr: List[int]) -> int: Returns the largest possible sum of two distinct elements from the list. # Sort the array arr.sort() # The largest sum will be the sum of the two largest elements return arr[-1] + arr[-2] # Example usage: # print(max_pair_sum([5, 9, 7, 1, 2])) # Output: 16 # print(max_pair_sum([1, 2, 3, 4, 5])) # Output: 9 # print(max_pair_sum([-10, -20, -5, -1])) # Output: -6"},{"question":"# Collection Operations Task You are tasked with creating a function that performs specific operations on a list of dictionaries representing students\' data. Each dictionary contains keys `\'name\'`, `\'grades\'`, and `\'id\'`. Your function should: 1. **Calculate Average Grades**: Compute and add the average grade for each student. 2. **Sort Students**: Sort the list of students by their average grade in descending order. 3. **Filter Students**: Filter out students who have an average grade below a specified threshold. # Function Signature ```python def process_students_data(students: list, threshold: float) -> list: Processes a list of students\' data and filters based on their average grades. Parameters: - students (list): A list of dictionaries, each representing a student\'s data. - threshold (float): The minimum average grade to include a student in the final list. Returns: - list: A sorted and filtered list of students based on their average grades. ``` # Requirements 1. Each student dictionary contains: - `\'name\'` (str): The student\'s name. - `\'grades\'` (list of int): A list of the student\'s grades. - `\'id\'` (int): The student\'s unique ID. 2. Calculate the average grade for each student and add it to their dictionary under the key `\'average\'`. 3. Sort the list of students by their `\'average\'` grade in descending order. 4. Remove students whose `\'average\'` grade is below the specified threshold. # Constraints - Assume all students have at least one grade. - Grades are integers ranging from 0 to 100. # Example ```python students_data = [ {\\"name\\": \\"Alice\\", \\"grades\\": [85, 90, 78], \\"id\\": 101}, {\\"name\\": \\"Bob\\", \\"grades\\": [70, 75, 80], \\"id\\": 102}, {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 95, 92], \\"id\\": 103}, ] filtered_students = process_students_data(students_data, 80.0) print(filtered_students) ``` **Expected output:** ```python [ {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 95, 92], \\"id\\": 103, \\"average\\": 94.0}, {\\"name\\": \\"Alice\\", \\"grades\\": [85, 90, 78], \\"id\\": 101, \\"average\\": 84.33} ] ```","solution":"def process_students_data(students, threshold): Processes a list of students\' data and filters based on their average grades. Parameters: - students (list): A list of dictionaries, each representing a student\'s data. - threshold (float): The minimum average grade to include a student in the final list. Returns: - list: A sorted and filtered list of students based on their average grades. for student in students: grades = student[\'grades\'] average_grade = sum(grades) / len(grades) student[\'average\'] = round(average_grade, 2) students = [student for student in students if student[\'average\'] >= threshold] students.sort(key=lambda x: x[\'average\'], reverse=True) return students"},{"question":"# Scenario You are developing a utility library that includes functions to manipulate and analyze strings. One of the crucial features requested involves determining whether a string can be rearranged to form a palindrome. This utility could be used for validation purposes in various applications such as text analysis, cryptography, and game development. # Task Write a function `can_form_palindrome(s: str) -> bool` that determines if any permutation of the given string can form a palindrome. # Input - A string `s` consisting of lowercase English letters (1 ≤ length of `s` ≤ 1000). # Output - Return a boolean value `True` if any permutation of the input string can form a palindrome, otherwise return `False`. # Example ```python input: \'civic\' output: True input: \'ivicc\' output: True input: \'hello\' output: False ``` # Constraints - The function should handle edge cases efficiently, considering the maximum string length. - The time complexity should be O(n), where n is the length of the input string. - Only primitive data types and inherent Python libraries should be used for the solution. # Notes - A string can be rearranged to form a palindrome if at most one character occurs an odd number of times.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if any permutation of the given string can form a palindrome. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"Scenario You are working for a software development company that specializes in creating customer management software. One of the features you need to implement is a \\"merge customer records\\" functionality that consolidates multiple customer records into a single record while preserving all unique information across different fields. The `CustomerRecord` data class provided below holds the customer\'s first name, last name, email, and phone number. Objective Using the provided `merge_records` function signature, implement the functionality to merge a list of `CustomerRecord` objects into a single `CustomerRecord`. The merging should follow these rules: 1. **First name**: Keep the first name from the first record that appears in the list. 2. **Last name**: Keep the last name from the first record that appears in the list. 3. **Email**: Combine unique emails from all records, separated by a semicolon (`;`). 4. **Phone**: Combine unique phone numbers from all records, separated by a semicolon (`;`). Function Signature ```python from typing import List class CustomerRecord: def __init__(self, first_name: str, last_name: str, email: str, phone: str): self.first_name = first_name self.last_name = last_name self.email = email self.phone = phone def merge_records(records: List[CustomerRecord]) -> CustomerRecord: pass ``` Input - A list of `CustomerRecord` objects. Output - A single `CustomerRecord` object that contains the merged customer data. Example Usage ```python >>> records = [ ... CustomerRecord(\\"John\\", \\"Doe\\", \\"john.doe@example.com\\", \\"555-1234\\"), ... CustomerRecord(\\"Jane\\", \\"Smith\\", \\"jane.smith@example.com\\", \\"555-5678\\"), ... CustomerRecord(\\"John\\", \\"Doe\\", \\"john.doe@example.com\\", \\"555-5678;555-9999\\") ... ] >>> merged_record = merge_records(records) >>> merged_record.first_name \'John\' >>> merged_record.last_name \'Doe\' >>> merged_record.email \'john.doe@example.com;jane.smith@example.com\' >>> merged_record.phone \'555-1234;555-5678;555-9999\' ``` Additional Notes - Ensure that the merged email and phone fields contain unique values with no duplicates. - The order of unique emails and phone numbers in the merged field can be based on their first appearance in the input list. - Consider using sets to handle unique values efficiently. Constraints - You can assume the input list will contain at least one `CustomerRecord`. - The fields `email` and `phone` within each `CustomerRecord` are non-empty strings.","solution":"from typing import List class CustomerRecord: def __init__(self, first_name: str, last_name: str, email: str, phone: str): self.first_name = first_name self.last_name = last_name self.email = email self.phone = phone def merge_records(records: List[CustomerRecord]) -> CustomerRecord: if not records: return None first_name, last_name = records[0].first_name, records[0].last_name emails = set() phones = set() for record in records: emails.update(record.email.split(\';\')) phones.update(record.phone.split(\';\')) merged_email = \';\'.join(sorted(emails)) merged_phone = \';\'.join(sorted(phones)) return CustomerRecord(first_name, last_name, merged_email, merged_phone)"},{"question":"# Problem Statement You need to develop a function that determines whether a given string can be rearranged to form a palindrome. The goal is to assess your ability to work with string operations, hash maps, and permutations while considering constraints of efficiently analyzing character frequencies. # Function Signature ```python def can_form_palindrome(s: str) -> bool: This function checks if the given string can be rearranged to form a palindrome. :param s: A string consisting of lowercase letters. :return: A boolean value indicating whether the string can be rearranged to form a palindrome (True) or not (False). ``` # Expected Input and Output - **Input**: A single string `s` consisting of lowercase English letters where 1 ≤ len(s) ≤ 10^5. - Example: `can_form_palindrome(\\"carrace\\")` - **Output**: A boolean value where `True` indicates that the string can be rearranged to form a palindrome and `False` otherwise. - Example: `True` (since the string \\"carrace\\" can be rearranged to form \\"racecar\\" or \\"carrace\\", both of which are palindromes) # Constraints and Limitations 1. Ensure that the input string only contains lowercase English letters. 2. Consider edge cases such as: - Single character strings (always a palindrome). - Strings where all characters are the same. - Strings with characters having both even and odd frequencies. 3. The function should handle strings of length up to 10^5 efficiently. # Example Scenarios 1. **Scenario 1**: - Input: `can_form_palindrome(\\"aabbccdd\\")` - Output: `True` 2. **Scenario 2**: - Input: `can_form_palindrome(\\"abcde\\")` - Output: `False` 3. **Scenario 3**: - Input: `can_form_palindrome(\\"level\\")` - Output: `True` 4. **Scenario 4**: - Input: `can_form_palindrome(\\"a\\")` - Output: `True` # Performance Requirements Ensure your implementation can determine the result efficiently, considering the constraints of string length up to 10^5. Minimize time complexity by leveraging appropriate data structures and avoiding unnecessary computations. --- This newly created question follows the required style, length, and difficulty level while introducing a fresh problem related to string manipulation and palindrome formation, aligning well with the original set.","solution":"def can_form_palindrome(s: str) -> bool: This function checks if the given string can be rearranged to form a palindrome. :param s: A string consisting of lowercase letters. :return: A boolean value indicating whether the string can be rearranged to form a palindrome (True) or not (False). from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters with odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"# Coding Assessment Question **Problem Statement:** Design a Python function to compute the Radix Sort on a given list of non-negative integers. Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. Implement the given algorithm while considering the details specified below. **Function Signature:** ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` **Input:** * `arr`: A list of non-negative integers to be sorted. **Output:** * A list of non-negative integers sorted in ascending order. **Constraints:** * The list `arr` will contain up to (10^4) integers, each integer will not exceed (10^6). * The list can initially be empty, and in that case should return an empty list. **Example:** ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr)) # Expected Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` **Explanation:** The radix sort starts sorting based on the least significant digit and moves towards the most significant one. In the given example, the sorted array based on the functionalities of radix sort will be returned. **Notes:** * Ensure your implementation handles large lists efficiently. * Utilize stable counting sort as a subroutine to manage the various digit positions. * Ensure non-comparative sorting mechanisms are adhered to, maintaining the algorithm\'s nature and efficiency. **Hint:** * Utilize bucket sorting for each digit place value. * The counting sort technique can be adapted for this purpose.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Problem Statement: You are given a rectangular grid representing an image made up of pixel values. Your task is to implement the following functions to manipulate and analyze the grid: 1. **`rotate_image_90`**: Rotate the grid 90 degrees clockwise. 2. **`flip_image_horizontal`**: Flip the grid horizontally. 3. **`flip_image_vertical`**: Flip the grid vertically. 4. **`transpose_image`**: Transpose the grid. 5. **`average_pixel_value`**: Calculate the average pixel value of the grid. # Function Signatures: 1. **`def rotate_image_90(image: list[list[int]]) -> list[list[int]]:`** 2. **`def flip_image_horizontal(image: list[list[int]]) -> list[list[int]]:`** 3. **`def flip_image_vertical(image: list[list[int]]) -> list[list[int]]:`** 4. **`def transpose_image(image: list[list[int]]) -> list[list[int]]:`** 5. **`def average_pixel_value(image: list[list[int]]) -> float:`** # Input: - `image`: A 2D list representing the pixel values of the image. # Output: - The functions should return the manipulated grid or the calculated average value as described in the function signatures. # Constraints: - The `image` grid is non-empty and contains at least one row and one column. - Pixel values are integers ranging from 0 to 255. - The dimensions of the grid range from 1x1 to 100x100. # Example: ```python # Example usage of the functions: image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Rotate Image 90 degrees rotated_image = rotate_image_90(image) print(rotated_image) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Flip Image Horizontally flipped_horizontal_image = flip_image_horizontal(image) print(flipped_horizontal_image) # Output: [[3, 2, 1], [6, 5, 4], [9, 8, 7]] # Flip Image Vertically flipped_vertical_image = flip_image_vertical(image) print(flipped_vertical_image) # Output: [[7, 8, 9], [4, 5, 6], [1, 2, 3]] # Transpose Image transposed_image = transpose_image(image) print(transposed_image) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Average Pixel Value avg_pixel_value = average_pixel_value(image) print(avg_pixel_value) # Output: 5.0 ``` Implement the functions to perform the described image manipulations and analysis.","solution":"def rotate_image_90(image: list[list[int]]) -> list[list[int]]: Rotate the grid 90 degrees clockwise. return [list(row) for row in zip(*image[::-1])] def flip_image_horizontal(image: list[list[int]]) -> list[list[int]]: Flip the grid horizontally. return [row[::-1] for row in image] def flip_image_vertical(image: list[list[int]]) -> list[list[int]]: Flip the grid vertically. return image[::-1] def transpose_image(image: list[list[int]]) -> list[list[int]]: Transpose the grid. return [list(row) for row in zip(*image)] def average_pixel_value(image: list[list[int]]) -> float: Calculate the average pixel value of the grid. total_sum = sum(sum(row) for row in image) num_pixels = sum(len(row) for row in image) return total_sum / num_pixels"},{"question":"# Coding Question Problem Statement You are required to implement a function `get_char_counts` that analyzes the frequency of each character in a given string, including spaces and punctuation. The function should return a dictionary where the keys are characters and the values are their respective counts in the string. Your function should be optimized for performance and handle edge cases gracefully. Function Signature ```python def get_char_counts(input_str: str) -> dict: pass ``` Input and Output Requirements * **Input**: - `input_str` (str): A string whose characters\' frequencies are to be counted. * **Output**: - Returns a dictionary with keys as characters and values as their counts in the input string. Constraints * The function should return an empty dictionary if the input string is empty. * The function should be case-sensitive (i.e., \'a\' and \'A\' are different characters). Examples 1. `get_char_counts(\\"hello world\\")` should return `{\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1}` 2. `get_char_counts(\\"AaBbCc.\\")` should return `{\'A\': 1, \'a\': 1, \'B\': 1, \'b\': 1, \'C\': 1, \'c\': 1, \'.\': 1}` 3. `get_char_counts(\\" \\")` should return `{\' \': 1}` 4. `get_char_counts(\\"\\")` should return `{}` Ensure your implementation is optimized and considers potential edge cases properly.","solution":"def get_char_counts(input_str: str) -> dict: Returns a dictionary with the frequency of each character in the input string. Parameters: input_str (str): The string whose characters needs to be counted. Returns: dict: A dictionary where keys are characters and values are their counts. char_counts = {} for char in input_str: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 return char_counts"},{"question":"# Coding Question Context You\'re working on a reservation system for a high-end restaurant. The restaurant needs to ensure that the reservations do not overlap and that all guests\' bookings are accommodated without conflicts. Problem Given a list of reservations, each defined by a start and end time, implement a function to determine the maximum number of non-overlapping reservations that can be accommodated. Requirements 1. Implement a function that takes a list of tuples, where each tuple contains two integers representing the start and end time of a reservation. 2. Your function should return the maximum number of non-overlapping reservations that can be accommodated. Function Signature ```python def max_non_overlapping_reservations(reservations: list[tuple[int, int]]) -> int: Determines the maximum number of non-overlapping reservations that can be accommodated. :param reservations: List of tuples, each containing the start and end times of a reservation. :return: Maximum number of non-overlapping reservations. Example: >>> max_non_overlapping_reservations([(1, 3), (2, 4), (3, 5), (7, 8)]) 3 >>> max_non_overlapping_reservations([(4, 5), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_reservations([(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_reservations([(1, 4), (2, 3)]) 1 >>> max_non_overlapping_reservations([(1, 2)]) 1 ``` Constraints 1. The input list can have zero or more reservations. 2. Each reservation will have valid start and end times (start < end). Input/Output Format * **Input**: A list of tuples, where each tuple denotes the start and end time of a reservation. * **Output**: An integer representing the maximum number of non-overlapping reservations. Examples 1. `max_non_overlapping_reservations([(1, 3), (2, 4), (3, 5), (7, 8)])` should return `3`. 2. `max_non_overlapping_reservations([(4, 5), (2, 3), (3, 4)])` should return `3`. 3. `max_non_overlapping_reservations([(1, 2), (2, 3), (3, 4)])` should return `3`. 4. `max_non_overlapping_reservations([(1, 4), (2, 3)])` should return `1`. Notes 1. Write comprehensive tests to ensure your implementation is correct and efficient. 2. Consider edge cases such as an empty list and lists with overlapping and non-overlapping reservations.","solution":"def max_non_overlapping_reservations(reservations): Determines the maximum number of non-overlapping reservations that can be accommodated. :param reservations: List of tuples, each containing the start and end times of a reservation. :return: Maximum number of non-overlapping reservations. if not reservations: return 0 # Sort reservations by their end times reservations.sort(key=lambda x: x[1]) # Initialize variables max_reservations = 0 last_end_time = float(\'-inf\') for start, end in reservations: if start >= last_end_time: max_reservations += 1 last_end_time = end return max_reservations"},{"question":"# Problem: Simulating the Spread of a Virus using the SIR Model You are tasked with implementing a simulation to model the spread of a virus using the SIR (Susceptible, Infected, Recovered) model. This model is widely used in epidemiology to understand infectious disease dynamics over time. Your task is to write a function `sir_model` which takes in the following parameters: - `S0`: The initial number of susceptible individuals. - `I0`: The initial number of infected individuals. - `R0`: The initial number of recovered individuals. - `beta`: The infection rate. - `gamma`: The recovery rate. - `days`: The number of days to simulate. The function should return a tuple of `np.ndarrays` containing the number of susceptible, infected, and recovered individuals for each day of the simulation, in that order. # Constraints: - `S0 >= 0` - `I0 >= 0` - `R0 >= 0` - `beta > 0` - `gamma > 0` - `days > 0` # Expected Function Signature: ```python def sir_model(S0: int, I0: int, R0: int, beta: float, gamma: float, days: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: pass ``` # Example: ```python # Simulate an epidemic over 160 days with initial conditions and rates S, I, R = sir_model(S0=999, I0=1, R0=0, beta=0.2, gamma=0.1, days=160) print(I[-1]) # Output the number of infected individuals on the last day ``` # Notes: 1. Ensure that you raise a `ValueError` if any of the constraints are not met. 2. The provided example in the docstring should help you understand the expected behavior and implementation. 3. Use numpy for array manipulations and ensure efficient computation. Your function will be tested with various initial conditions and rates to ensure correctness and performance. # Implementation Details: The SIR model is governed by the following set of differential equations: [ frac{dS}{dt} = -beta cdot S cdot I ] [ frac{dI}{dt} = beta cdot S cdot I - gamma cdot I ] [ frac{dR}{dt} = gamma cdot I ] Where: - (S(t)) is the number of susceptible individuals at time (t). - (I(t)) is the number of infected individuals at time (t). - (R(t)) is the number of recovered individuals at time (t). - (beta) is the transmission rate per contact. - (gamma) is the recovery rate. Use these equations to update the values of (S), (I), and (R) for each time step ( Delta t = 1 ) day.","solution":"import numpy as np from typing import Tuple def sir_model(S0: int, I0: int, R0: int, beta: float, gamma: float, days: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: Returns the numbers of susceptible, infected, and recovered individuals for each day of the simulation. :param S0: Initial number of susceptible individuals :param I0: Initial number of infected individuals :param R0: Initial number of recovered individuals :param beta: Infection rate :param gamma: Recovery rate :param days: Number of days to simulate :return: A tuple of numpy.ndarrays for susceptible, infected, and recovered individuals if S0 < 0 or I0 < 0 or R0 < 0 or beta <= 0 or gamma <= 0 or days <= 0: raise ValueError(\\"Invalid input parameters\\") S = np.zeros(days + 1) I = np.zeros(days + 1) R = np.zeros(days + 1) S[0] = S0 I[0] = I0 R[0] = R0 for t in range(1, days + 1): S[t] = S[t-1] - (beta * S[t-1] * I[t-1]) I[t] = I[t-1] + (beta * S[t-1] * I[t-1]) - (gamma * I[t-1]) R[t] = R[t-1] + (gamma * I[t-1]) # Ensure that we do not have negative values (biological constraint) S[t] = max(S[t], 0) I[t] = max(I[t], 0) R[t] = max(R[t], 0) return S, I, R"},{"question":"# Coding Assessment Question Context You are developing a library of mathematical functions, and one of the utility functions required is to compute the Greatest Common Divisor (GCD) of two integers. Your task is to implement a function that does this while handling various edge cases gracefully. Task Implement a function `safe_gcd`, which calculates the Greatest Common Divisor (GCD) of two given integers. The function should handle invalid input gracefully by raising appropriate exceptions. Make sure to adhere to the function signature and constraints. Function Signature ```python def safe_gcd(num1: int, num2: int) -> int: pass ``` Input * `num1` and `num2` are integers which can be positive, negative, or zero. Output * Returns an integer representing the GCD of the two integers. Constraints * Both inputs must be integers. * Raise `TypeError` if the inputs are not integers. * Raise `ValueError` if inputs are invalid (such as both being zero simultaneously). Example ```python assert safe_gcd(54, 24) == 6 assert safe_gcd(-54, 24) == 6 assert safe_gcd(0, 5) == 5 assert safe_gcd(-81, -153) == 9 ``` Edge Cases * Zero input: `safe_gcd(0, 0)` should raise `ValueError`. * Invalid input types: `safe_gcd(54, \'24\')` should raise `TypeError`. # Solution Outline Ensure to follow these basic steps to implement the function: 1. Validate that both inputs are integers. 2. If both numbers are zero, raise a `ValueError`. 3. Use the Euclidean algorithm to compute the GCD. 4. Handle sign, ensure result is non-negative. ```python def safe_gcd(num1: int, num2: int) -> int: if not isinstance(num1, int) or not isinstance(num2, int): raise TypeError(\\"Both inputs must be integers\\") if num1 == 0 and num2 == 0: raise ValueError(\\"At least one number must be non-zero\\") while num2 != 0: num1, num2 = num2, num1 % num2 return abs(num1) ```","solution":"def safe_gcd(num1: int, num2: int) -> int: if not isinstance(num1, int) or not isinstance(num2, int): raise TypeError(\\"Both inputs must be integers\\") if num1 == 0 and num2 == 0: raise ValueError(\\"At least one number must be non-zero\\") while num2 != 0: num1, num2 = num2, num1 % num2 return abs(num1)"},{"question":"# Question: Calculate the Roots of a Quadratic Equation Given the coefficients (a), (b), and (c) of a quadratic equation of the form (ax^2 + bx + c = 0), write a Python function to calculate and return the roots of the equation. The roots can be real or complex numbers. The roots of the quadratic equation can be found using the quadratic formula: [ x = frac{-b pm sqrt{b^2 - 4ac}}{2a} ] # Function Signature: ```python def calculate_quadratic_roots(a: float, b: float, c: float) -> tuple: pass ``` # Input: - `a` (float): Coefficient of (x^2), must be non-zero. - `b` (float): Coefficient of (x). - `c` (float): Constant term. # Output: - A tuple containing two values: - The first root of the equation. - The second root of the equation. - The roots can be either real numbers (floats) or complex numbers (complex). # Constraints: - `a` should not be zero. # Example: ```python >>> calculate_quadratic_roots(1, -3, 2) (2.0, 1.0) >>> calculate_quadratic_roots(1, 2, 5) ((-1+2j), (-1-2j)) ``` # Notes: - Ensure to import the necessary module (`cmath`) to handle complex roots. - Consider edge cases and validate that `a` is not zero, raising a `ValueError` with an appropriate message if this constraint is violated. - The solution should be precise and handle floating-point arithmetic correctly.","solution":"import cmath def calculate_quadratic_roots(a: float, b: float, c: float) -> tuple: Calculates the roots of the quadratic equation ax^2 + bx + c = 0. if a == 0: raise ValueError(\\"Coefficient \'a\' must be non-zero.\\") # Calculate the discriminant discriminant = b**2 - 4*a*c # Calculate the two roots using the quadratic formula root1 = (-b + cmath.sqrt(discriminant)) / (2*a) root2 = (-b - cmath.sqrt(discriminant)) / (2*a) return (root1, root2)"},{"question":"# Problem Statement You are given a string that contains words separated by spaces. However, some words might be repeated. Implement a function `remove_duplicate_words` that processes the input string and returns a new string with all duplicate words removed, maintaining their original order in the first occurrence. # Input: - A string `s` which contains lowercase alphabetic words separated by spaces, with `1 <= len(s) <= 10^5`. # Output: - A string with duplicates removed, words appearing in their original order in the first occurrence. # Example: ```python # Example 1 s = \\"the cat in the hat\\" print(remove_duplicate_words(s)) # Output: \\"the cat in hat\\" # Example 2 s = \\"hello world hello\\" print(remove_duplicate_words(s)) # Output: \\"hello world\\" # Example 3 s = \\"a quick brown fox jumps over the lazy dog a quick fox\\" print(remove_duplicate_words(s)) # Output: \\"a quick brown fox jumps over the lazy dog\\" ``` # Requirements: - Your function should have a time complexity of O(n). - Do not use additional data structures that exceed O(n) space. - Ensure the order of the words is maintained as in the first occurrence. # Notes: - The input string will only contain lowercase alphabetic words and spaces. - Words are delimited by a single space and there will be no leading or trailing spaces.","solution":"def remove_duplicate_words(s): Returns a new string with all duplicate words removed, maintaining their original order in the first occurrence. seen = set() result = [] for word in s.split(): if word not in seen: seen.add(word) result.append(word) return \' \'.join(result)"},{"question":"Implement a Memory-Efficient Fibonacci Sequence Generator The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Traditional recursive solutions for generating Fibonacci numbers can be memory-intensive due to excessive stack usage. Your task is to implement a memory-efficient iterator-based solution to generate the Fibonacci sequence. Requirements: 1. **Input**: An integer `n` indicating the number of Fibonacci numbers to generate. 2. **Output**: A list containing the first `n` Fibonacci numbers. 3. **Constraints**: * Handle cases where `n` is zero or negative by returning an empty list. * Ensure the solution uses constant space for generating the sequence. 4. **Performance**: * The solution should ideally run in O(n) time with O(1) space complexity. * Minimize the use of additional data structures. ```python def fibonacci_generator(n: int) -> list: Memory-efficient generator for the Fibonacci sequence. :param n: Number of Fibonacci numbers to generate :return: List containing the first n Fibonacci numbers Examples: >>> fibonacci_generator(0) [] >>> fibonacci_generator(5) [0, 1, 1, 2, 3] >>> fibonacci_generator(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] if n <= 0: return [] fib_sequence = [] a, b = 0, 1 for _ in range(n): fib_sequence.append(a) a, b = b, a + b return fib_sequence if __name__ == \\"__main__\\": assert fibonacci_generator(0) == [] assert fibonacci_generator(1) == [0] assert fibonacci_generator(5) == [0, 1, 1, 2, 3] assert fibonacci_generator(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ```","solution":"def fibonacci_generator(n: int) -> list: Memory-efficient generator for the Fibonacci sequence. :param n: Number of Fibonacci numbers to generate :return: List containing the first n Fibonacci numbers Examples: >>> fibonacci_generator(0) [] >>> fibonacci_generator(5) [0, 1, 1, 2, 3] >>> fibonacci_generator(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] if n <= 0: return [] fib_sequence = [] a, b = 0, 1 for _ in range(n): fib_sequence.append(a) a, b = b, a + b return fib_sequence"},{"question":"# Problem Statement You are given a list of strings, each representing a binary number. Your task is to find the two binary numbers within the list that, when converted to decimal, have the maximum difference. Return these two numbers as strings in their original binary form. # Function to Implement ```python def max_binary_diff(binaries: list[str]) -> tuple[str, str]: Finds the two binary numbers in the list that have the maximum difference when converted to decimal. Parameters: binaries (list[str]): The list of binary strings. Returns: tuple[str, str]: A tuple containing the two binary strings with the maximum decimal difference. If the input list is empty or has less than two elements, raise ValueError(\\"Insufficient elements in the list\\"). pass ``` # Example ```python binaries = [\\"101\\", \\"1110\\", \\"1111\\", \\"100\\", \\"10001\\"] result = max_binary_diff(binaries) # Possible output: # (\\"100\\", \\"10001\\") binaries = [\\"110\\", \\"101\\", \\"011\\"] result = max_binary_diff(binaries) # Possible output: # (\\"011\\", \\"110\\") ``` # Constraints 1. Each element in the list `binaries` is a string representing a binary number. 2. The length of each binary string is between 1 and 20 (inclusive). 3. The list `binaries` contains at least two binary numbers. # Assumptions 1. All binary strings are valid and contain only \'0\' and \'1\'. # Performance Requirements Ensure that your solution is effective for lists containing up to 1000 binary strings, taking into account both time and space complexity.","solution":"def max_binary_diff(binaries: list[str]) -> tuple[str, str]: Finds the two binary numbers in the list that have the maximum difference when converted to decimal. Parameters: binaries (list[str]): The list of binary strings. Returns: tuple[str, str]: A tuple containing the two binary strings with the maximum decimal difference. If the input list is empty or has less than two elements, raise ValueError(\\"Insufficient elements in the list\\"). if len(binaries) < 2: raise ValueError(\\"Insufficient elements in the list\\") # Convert each binary string to a decimal number decimals = [int(binary, 2) for binary in binaries] # Find the maximum and minimum decimal values max_decimal = max(decimals) min_decimal = min(decimals) # Find the corresponding binary strings for the maximum and minimum decimal values max_binary = binaries[decimals.index(max_decimal)] min_binary = binaries[decimals.index(min_decimal)] return min_binary, max_binary"},{"question":"# Problem Statement: You are tasked with designing an algorithm that determines whether a given Sudoku puzzle is valid. The puzzle will be provided as a 9x9 grid, where some entries may be empty (represented by \'.\'), and the rest of the entries will be numbers from 1 to 9. A valid Sudoku puzzle must satisfy the following conditions: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. # Function Signature: ```python def is_valid_sudoku(board: List[List[str]]) -> bool: pass ``` # Input: * `board`: A 9x9 list of lists representing the Sudoku puzzle. * Some entries may be empty (represented by \'.\'). * Other entries will be numbers from \'1\' to \'9\'. # Output: * Return `True` if the Sudoku puzzle is valid, otherwise return `False`. # Constraints: * The solution should handle edge cases efficiently. * Ensure that the solution operates within a reasonable time frame. # Example: ```python sudoku_board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert is_valid_sudoku(sudoku_board) == True ``` # Notes: * Implement the validation checks without using pre-built Sudoku validation libraries. * The function should handle typical edge cases such as rows, columns, or sub-boxes containing duplicate numbers or invalid entries.","solution":"from typing import List def is_valid_sudoku(board: List[List[str]]) -> bool: rows = [set() for _ in range(9)] columns = [set() for _ in range(9)] sub_boxes = [set() for _ in range(9)] for r in range(9): for c in range(9): num = board[r][c] if num == \'.\': continue # Check row if num in rows[r]: return False rows[r].add(num) # Check column if num in columns[c]: return False columns[c].add(num) # Check sub-box sub_box_index = (r // 3) * 3 + (c // 3) if num in sub_boxes[sub_box_index]: return False sub_boxes[sub_box_index].add(num) return True"},{"question":"# Problem Statement: Write a program to determine if strings of text drawn from a list in an external file can be concatenated to exactly form another specific string. The file contains numerous strings, and your task is to identify if a given target string can be assembled by concatenating some of these strings without using any string more than once. # Detailed Instructions: 1. **File Reading**: Read a file named `strings.txt` which contains comma-separated strings enclosed in double quotes. This list constitutes the pool of available strings. 2. **Concatenation Check**: Determine if it is possible to concatenate a subset of strings from the list (each string used at most once) to exactly match a given target string. 3. **Output**: Return `True` if the target string can be formed from the list, otherwise return `False`. # Input and Output: - **Input**: - `strings.txt`: A file containing comma-separated strings in double quotes (e.g., \\"hello\\",\\"world\\",\\"foobar\\"). - `target`: A string that you want to construct using the subset of strings from the file. - **Output**: A boolean value: `True` if the target string can be formed, `False` otherwise. # Constraints: - The strings in `strings.txt` consist only of lowercase English letters. - All strings in the file are unique. - The `target` string consists of lowercase English letters. # Function Signature: ```python def can_form_target(filename: str, target: str) -> bool: pass ``` # Performance Requirements: Your solution should efficiently handle the file size and number of strings, ensuring optimal performance in both time and space complexity. # Example: Assume the contents of `strings.txt` are as follows: ```plaintext \\"one\\",\\"two\\",\\"three\\",\\"four\\",\\"five\\" ``` If the `target` is \\"onetwo\\", the function should return `True`. If the `target` is \\"six\\", the function should return `False`. # Notes: - Ensure the file `strings.txt` is present in the working directory. - Consider using dynamic programming or backtracking to solve the problem efficiently. ```python # Example usage: >>> can_form_target(\'strings.txt\', \'onetwo\') True >>> can_form_target(\'strings.txt\', \'six\') False ```","solution":"def can_form_target(filename: str, target: str) -> bool: with open(filename, \'r\') as f: content = f.read() strings = content.strip().replace(\'\\"\', \'\').split(\',\') memo = {} def can_construct(sub_target, words): if sub_target == \\"\\": return True if sub_target in memo: return memo[sub_target] for word in words: if sub_target.startswith(word): remainder = sub_target[len(word):] remaining_words = words[:] remaining_words.remove(word) if can_construct(remainder, remaining_words): memo[sub_target] = True return True memo[sub_target] = False return False return can_construct(target, strings)"},{"question":"# Scenario You are tasked with developing a library of utility functions to assist with data processing tasks. One critical feature of this library involves manipulating string data in various formats. Among these tasks, you need to implement functions to handle common operations on strings that represent numerical data. # Task Implement the following string operations as specified: 1. `is_digit(string)`: Returns whether the given string consists only of digits. 2. `to_int(string)`: Converts a string of digits to an integer. Raise `ValueError` if the string contains non-digit characters. 3. `to_float(string)`: Converts a string to a float. Raise `ValueError` if the string cannot be converted to a float. 4. `strip_whitespace(string)`: Removes leading and trailing whitespaces from the string. # Specifications - **Input**: - `is_digit`: A single `string` input. - `to_int`: A single `string` input containing digits. - `to_float`: A single `string` input that can be converted to a float. - `strip_whitespace`: A single `string` input. - **Output**: - `is_digit`: A boolean value indicating if the string contains only digits. - `to_int`: An integer representation of the string. - `to_float`: A floating-point representation of the string. - `strip_whitespace`: A string with leading and trailing whitespaces removed. # Example Implementations ```python def is_digit(string): if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") return string.isdigit() def to_int(string): if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") if not string.isdigit(): raise ValueError(\\"Input string must contain only digits\\") return int(string) def to_float(string): if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") try: return float(string) except ValueError: raise ValueError(\\"Input string cannot be converted to float\\") def strip_whitespace(string): if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") return string.strip() ``` # Constraints - Ensure the functions handle invalid input cases gracefully by raising appropriate exceptions, such as `ValueError` for invalid conversions or `TypeError` for incorrect input types. - The `string` input must be non-empty for `to_int` and `to_float` functions; otherwise, raise a `ValueError`. - Do not use external libraries; only use standard Python functionalities. # Performance Requirements - The functions should have optimal time complexity, considering the string manipulation and conversion operations. - Ensure the code performs efficiently, even with large string inputs, within reasonable limits seen in typical data processing tasks.","solution":"def is_digit(string): Check if the string contains only digits. if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") return string.isdigit() def to_int(string): Convert a string of digits to an integer. if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") if not string.isdigit(): raise ValueError(\\"Input string must contain only digits\\") return int(string) def to_float(string): Convert a string to a float. if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") try: return float(string) except ValueError: raise ValueError(\\"Input string cannot be converted to a float\\") def strip_whitespace(string): Remove leading and trailing whitespaces from the string. if not isinstance(string, str): raise TypeError(\\"Input must be a string\\") return string.strip()"},{"question":"**Product of Array Except Self** Given an array `nums` of integers, implement a function `product_except_self(nums: List[int]) -> List[int]` that returns an array such that each element at index `i` is the product of all the elements of `nums` except `nums[i]`. # Function Signature ```python def product_except_self(nums: List[int]) -> List[int]: ``` # Input * `nums` (list of int): A list of integers (2 ≤ length of `nums` ≤ 1000 and each element of `nums` is between -1000 and 1000). # Output * Returns a list of integers representing the product of all elements except the one at the current index. # Constraints * You must do this in O(n) time complexity and without using division. * Ensure the function handles edge cases such as the presence of zeros in the input list. # Examples ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1]) [1, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] ``` # Scenario Imagine you are optimizing computational tasks where you need to calculate values derived from a dataset excluding individual contributions but without recalculating the entire dataset each time. Your task is to implement a function that computes these values efficiently. # Assessment Criteria * Correctness: The solution should return the correct list for given inputs. * Efficiency: The solution should meet the O(n) time complexity requirement. * Code Quality: The solution should be readable and maintainable.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns an array such that each element at index `i` is the product of all the elements of `nums` except `nums[i]`. length = len(nums) result = [1] * length # Compute the products of all elements to the left of each index left_prod = 1 for i in range(length): result[i] = left_prod left_prod *= nums[i] # Compute the products of all elements to the right of each index right_prod = 1 for i in range(length - 1, -1, -1): result[i] *= right_prod right_prod *= nums[i] return result"},{"question":"# Scenario: You are given a string containing a mix of alphabetic characters, digits, and special characters. Your task is to implement a function that returns a new string in which all the digits are moved to the front, followed by the alphabetic characters, and finally the special characters. The relative order among the digits, alphabetic characters, and special characters should be preserved. # Requirements: 1. Implement a function `reorder_string` that takes a string as input and returns a reordered string as specified above. 2. The function should maintain the relative order of digits, alphabetic characters, and special characters within their respective groups. # Function Signature: ```python def reorder_string(s: str) -> str: ``` # Input: - `s`: A string `s` which may include alphabetic characters (both uppercase and lowercase), digits, and special characters where `1 <= len(s) <= 10^4`. # Output: - A reordered string where digits are moved to the front, followed by alphabetic characters, and then special characters at the end. # Example: ```python assert reorder_string(\\"a1b2c3!\\") == \\"123abc!\\" assert reorder_string(\\"Hello, World!123\\") == \\"123HelloWorld!,\\" assert reorder_string(\\"abc!@#456\\") == \\"456abc!@#\\" assert reorder_string(\\"1a2b3c\\") == \\"123abc\\" assert reorder_string(\\"!@#%^&*()_+\\") == \\"!@#%^&*()_+\\" ``` # Hints: - Consider using separate lists or strings to collect digits, alphabetic characters, and special characters while iterating through the input string. - You may concatenate these collections together to form the final reordered string. # Performance Requirements: - The function should process the input string in linear time, O(n), ensuring optimal performance for long strings.","solution":"def reorder_string(s: str) -> str: Reorders the input string such that all digits are moved to the front, followed by alphabetic characters, and then special characters. The relative order of each category (digits, alphabetic characters, special characters) is preserved. :param s: Input string containing digits, alphabetic characters, and special characters :return: Reordered string digits = [] alphabets = [] specials = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): alphabets.append(char) else: specials.append(char) return \'\'.join(digits + alphabets + specials)"},{"question":"# Question: You need to implement a function that generates a unique encoding for any given string. This encoding will replace each character with its ASCII value concatenated with its position in the string, separated by a special delimiter. The goal is to transform the input string into a single encoded string that uniquely identifies the input while retaining its original sequence information. The function `unique_encode` should: - Convert each character in the string to its ASCII value. - Append the position of the character in the string, starting from 1. - Use a specified single-character delimiter to separate each encoded value. - Handle any input string, including empty strings or non-ASCII characters. # Input: - A single string `input_str` consisting of any characters (including an empty string). - A single character `delimiter` used to separate encoded values. # Output: - A single string representing the encoded version of the input, with each character\'s ASCII and position encoded and separated by the delimiter. # Constraints: - Input string length can be up to 10^6 characters. - Characters can include any Unicode character. - The delimiter is guaranteed to be a single character and won\'t be a character present in the input string. # Function Signature: ```python def unique_encode(input_str: str, delimiter: str) -> str: pass ``` # Example: ```python >>> unique_encode(\'Hello\', \'-\') \'72-1-101-2-108-3-108-4-111-5\' >>> unique_encode(\'Data123\', \'|\') \'68|1|97|2|116|3|97|4|49|5|50|6|51|7\' >>> unique_encode(\'\', \'?\') \'\' ``` **Note**: Ensure your function handles the encoding efficiently, even with the maximum input length, and correctly formats the output string with the specified delimiter.","solution":"def unique_encode(input_str: str, delimiter: str) -> str: Unique encode the input string by replacing each character with its ASCII value concatenated with its position in the string, separated by the given delimiter. Args: - input_str: The input string to be encoded. - delimiter: The delimiter to separate each encoded value. Returns: - A unique encoded string. encoded_parts = [] for idx, char in enumerate(input_str): encoded_part = f\\"{ord(char)}{delimiter}{idx + 1}\\" encoded_parts.append(encoded_part) return delimiter.join(encoded_parts)"},{"question":"# Problem Statement You are given a directed graph with nodes numbered from 0 to N-1 and a list of `edges` where each edge is represented as a tuple (u, v, w) indicating an edge from node `u` to node `v` with weight `w`. Your task is to write a function `shortest_path_dag` to find the shortest path from a specified `start` node to all other nodes in the graph. The graph is guaranteed to be a Directed Acyclic Graph (DAG). # Input * An integer `N`, the number of nodes in the graph, where (1 leq N leq 10^4). * A list of tuples `edges`, each tuple (u, v, w) represents an edge with a start node `u`, end node `v`, and weight `w` where (0 leq u, v < N) and (-10^4 leq w leq 10^4). * An integer `start`, the starting node, where (0 leq text{start} < N). # Output * Return a list of `N` integers where the i-th element is the shortest distance from `start` to node i. If a node is not reachable from `start`, the distance should be set to infinity (or a very large value such as `float(\'inf\')`). # Function Signature ```python def shortest_path_dag(N: int, edges: list, start: int) -> list: pass ``` # Constraints * The graph is a DAG. * You must use a topological sort-based method to find the shortest paths. * Avoid using Python\'s built-in high-level graph libraries. # Example ```python >>> shortest_path_dag(5, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3)], 0) [0, 2, 3, 9, 6] >>> shortest_path_dag(3, [(0, 1, 1), (1, 2, 2)], 0) [0, 1, 3] >>> shortest_path_dag(4, [(0, 1, 2), (2, 3, 1)], 0) [0, 2, inf, inf] ``` # Detailed Explanation * Implement the shortest path algorithm for a DAG using a topological sort. * First, perform a topological sort of the graph. * Once sorted, initialize distances from the start node to all nodes as infinity, except the start node which should be 0. * Process each node in the topologically sorted order, relaxing the edges (updating the shortest distances). * Return the list of shortest distances from the start node to each node in the graph, using `float(\'inf\')` for nodes that are not reachable.","solution":"from collections import defaultdict, deque import heapq def topological_sort(N, edges): in_degree = [0] * N graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) in_degree[v] += 1 queue = deque([i for i in range(N) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor, weight in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return topo_order def shortest_path_dag(N, edges, start): topo_order = topological_sort(N, edges) dist = [float(\'inf\')] * N dist[start] = 0 graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) for u in topo_order: if dist[u] != float(\'inf\'): for v, w in graph[u]: if dist[u] + w < dist[v]: dist[v] = dist[u] + w return dist"},{"question":"**Scenario**: You are tasked to develop a utility for a predictive modeling system that improves model performance by identifying and handling missing data in large datasets. One of the functions needed is to impute missing values in a numeric dataset column using the median of the available values. **Task**: Implement a function to impute missing values with the median value of the dataset column. # Missing Value Imputation Function 1. **Function Name**: `impute_missing_with_median` 2. **Input**: - `data_column`: A list of floats where some values might be `None` (representing missing data). 3. **Output**: A list of floats where all `None` values are replaced with the median of the non-missing values. # Detailed Requirements: 1. **Input validation**: - The input list should contain at least one non-`None` value. - Handle all scenarios where values are `None` correctly. 2. **Output**: - Return the list of floats with missing values imputed. - If the list contains only one non-`None` value, all `None` values should be replaced with that single value. # Constraints & Performance: - The function should handle lists containing up to 1,000,000 elements efficiently. - Consider edge cases such as all or nearly all values being `None`. # Example Function Signature: ```python def impute_missing_with_median(data_column: list[float]) -> list[float]: pass ``` # Example Usage: ```python data = [12.5, None, 7.8, None, 10.2, 15.4, None] result = impute_missing_with_median(data) print(result) # Expected output: [12.5, 10.2, 7.8, 10.2, 10.2, 15.4, 10.2] ``` # Additional Notes: - Compute the median of the available (non-`None`) values accurately. - Pay attention to the performance concerns with large datasets. - Consider Python\'s built-in utilities and handle edge cases such as an empty list after filtering out `None` values.","solution":"import statistics def impute_missing_with_median(data_column): Impute missing values in the data_column with the median of the non-missing values. Parameters: data_column (list of float): List containing floats and None (representing missing values) Returns: list of float: The input list with missing values imputed by the median of non-missing values. # Extract non-missing values non_missing_values = [value for value in data_column if value is not None] # Validate the input list if not non_missing_values: raise ValueError(\\"The input list must contain at least one non-None value.\\") # Calculate the median of non-missing values median_value = statistics.median(non_missing_values) # Impute missing values with the median return [value if value is not None else median_value for value in data_column]"},{"question":"# Rectangle Collision Detection You are tasked with implementing a collision detection system for a 2D game. One of the core elements is detecting when two axis-aligned rectangles overlap. Your task is to implement the functions to: 1. **Represent a Rectangle** as an object in a 2D space. 2. **Detect if two Rectangles are Colliding** given their positions and dimensions. # Function Definitions Implement the following functions: 1. **`Rectangle` class**: Represents a Rectangle in a 2D space. ```python class Rectangle: def __init__(self, x: float, y: float, width: float, height: float): Initializes a Rectangle. :param x: The x-coordinate of the bottom-left corner of the rectangle. :param y: The y-coordinate of the bottom-left corner of the rectangle. :param width: The width of the rectangle. :param height: The height of the rectangle. self.x = x self.y = y self.width = width self.height = height def get_corners(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: Returns the bottom-left and top-right corners of the rectangle. :return: A tuple of two tuples, each containing the (x, y) coordinates of the corners. return (self.x, self.y), (self.x + self.width, self.y + self.height) ``` 2. **`check_collision`**: Checks if two rectangles are colliding. ```python def check_collision(rect1: Rectangle, rect2: Rectangle) -> bool: Checks if two rectangles are colliding. :param rect1: The first rectangle. :param rect2: The second rectangle. :return: True if the rectangles collide; False otherwise. (x1_min, y1_min), (x1_max, y1_max) = rect1.get_corners() (x2_min, y2_min), (x2_max, y2_max) = rect2.get_corners() # Check for non-overlapping conditions if x1_max <= x2_min or x2_max <= x1_min: return False if y1_max <= y2_min or y2_max <= y1_min: return False return True ``` # Requirements 1. **Performance**: * Ensure collision detection operates in **O(1)** time complexity. 2. **Edge Cases**: * Handle cases where the rectangles touch but do not overlap. * Test with rectangles of zero width/height. * Handle high-precision floating-point coordinates. # Input and Output * **Input**: Coordinates and dimensions of two rectangles. * **Output**: Boolean indicating collision status. # Example ```python # Example rectangles rect1 = Rectangle(2.0, 3.0, 4.0, 5.0) rect2 = Rectangle(5.0, 5.0, 6.0, 3.0) # Check collision collision = check_collision(rect1, rect2) print(collision) ``` *Expected Output*: ```python True # If the rectangles collide ```","solution":"class Rectangle: def __init__(self, x: float, y: float, width: float, height: float): Initializes a Rectangle. :param x: The x-coordinate of the bottom-left corner of the rectangle. :param y: The y-coordinate of the bottom-left corner of the rectangle. :param width: The width of the rectangle. :param height: The height of the rectangle. self.x = x self.y = y self.width = width self.height = height def get_corners(self) -> tuple: Returns the bottom-left and top-right corners of the rectangle. :return: A tuple of two tuples, each containing the (x, y) coordinates of the corners. return (self.x, self.y), (self.x + self.width, self.y + self.height) def check_collision(rect1: Rectangle, rect2: Rectangle) -> bool: Checks if two rectangles are colliding. :param rect1: The first rectangle. :param rect2: The second rectangle. :return: True if the rectangles collide; False otherwise. (x1_min, y1_min), (x1_max, y1_max) = rect1.get_corners() (x2_min, y2_min), (x2_max, y2_max) = rect2.get_corners() # Check for non-overlapping conditions if x1_max <= x2_min or x2_max <= x1_min: return False if y1_max <= y2_min or y2_max <= y1_min: return False return True"},{"question":"# Question: Validate Palindromic Substrings **Context**: A new text processing feature requires checking for palindromic substrings within larger strings. Your task is to develop a function that identifies all substrings within a given string and determines if they are palindromic. **Task**: Write a function `find_palindromic_substrings(s: str) -> List[str]` that finds and returns all unique palindromic substrings from the given string `s`. **Function Specifications**: ```python def find_palindromic_substrings(s: str) -> List[str]: Finds and returns all unique palindromic substrings within the provided string. ``` **Input**: 1. A string `s` where `1 <= len(s) <= 100`. **Output**: 1. A list of strings representing all unique palindromic substrings found in `s`. The substrings should be returned in lexicographical order. **Constraints**: 1. Consider all substrings within the provided string `s`. 2. The algorithm should efficiently handle the given string length. **Examples**: ```python assert find_palindromic_substrings(\\"ababa\\") == [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] assert find_palindromic_substrings(\\"racecar\\") == [\\"a\\", \\"aceca\\", \\"c\\", \\"cec\\", \\"e\\", \\"r\\", \\"racecar\\"] assert find_palindromic_substrings(\\"abc\\") == [\\"a\\", \\"b\\", \\"c\\"] assert find_palindromic_substrings(\\"aaa\\") == [\\"a\\", \\"aa\\", \\"aaa\\"] assert find_palindromic_substrings(\\"noon\\") == [\\"n\\", \\"noon\\", \\"o\\", \\"oo\\"] ``` **Note**: 1. A palindromic substring reads the same forward and backward. 2. You may use helper functions within your solution to manage substring extraction and palindrome validation. 3. Ensure your function returns results in lexicographical order and only includes unique substrings.","solution":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: def is_palindrome(sub: str) -> bool: return sub == sub[::-1] palindromic_set = set() n = len(s) for i in range(n): for j in range(i+1, n+1): substring = s[i:j] if is_palindrome(substring): palindromic_set.add(substring) return sorted(list(palindromic_set))"},{"question":"# Matrix Block Sum Calculation Context You\'re developing a data analysis tool that operates on matrices and one of the functionalities needed is to compute the block sum of a matrix. The block sum of an element in a matrix is the sum of all the elements which are within a given distance (K) from that element. Task Write a function called `matrix_block_sum` that returns the block sum of the given matrix for a specified distance K. Function Signature ```python def matrix_block_sum(mat: list[list[int]], K: int) -> list[list[int]]: pass ``` Input * `mat` (list of lists): A 2D list representing the matrix of integers. * `K` (int): An integer representing the distance to calculate the block sum. Output * (list of lists): A 2D list of the same size as `mat` where each element is the block sum of `mat[i][j]`. Constraints * The matrix may have dimensions `m x n` with up to (1 leq m, n leq 100). * The elements of the matrix are integers in the range ([-1000, 1000]). * (0 leq K leq min(m, n)) Example ```python def test_matrix_block_sum(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] K = 1 result = matrix_block_sum(mat, K) expected = [ [12, 21, 16], [27, 45, 33], [24, 39, 28] ] assert result == expected mat = [ [1, 2], [3, 4] ] K = 1 result = matrix_block_sum(mat, K) expected = [ [10, 10], [10, 10] ] assert result == expected print(\\"All tests passed!\\") test_matrix_block_sum() ``` You should also consider writing additional test cases to cover edge cases, such as different matrix sizes and varying values of K.","solution":"def matrix_block_sum(mat, K): Compute the block sum of a matrix for a given distance K. :param mat: 2D list of integers representing the matrix. :param K: Integer representing the distance to calculate the block sum. :return: 2D list of integers representing the block sums. m, n = len(mat), len(mat[0]) answer = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): total = 0 for r in range(max(0, i - K), min(m, i + K + 1)): for c in range(max(0, j - K), min(n, j + K + 1)): total += mat[r][c] answer[i][j] = total return answer"},{"question":"# Problem Statement Given a list of integers and a target value, determine if there are three distinct elements in the list that sum up to the target. # Task Write a function `three_sum(nums: List[int], target: int) -> bool` that returns a boolean, `True` if there are three integers in the list that can be added together to equal the target, otherwise `False`. # Input - A list of integers `nums` (0 ≤ len(nums) ≤ 5000, |nums[i]| ≤ 10^5), representing the list of integers. - An integer `target` (-10^5 ≤ target ≤ 10^5), representing the target sum value. # Output - Return `True` if there are three distinct integers in the list that sum up to `target`, otherwise return `False`. # Constraints 1. The length of the list will be between 0 and 5000 inclusive. 2. Each integer in the list will be between -10^5 and 10^5 inclusive. 3. The target value will be between -10^5 and 10^5 inclusive. 4. Optimize for both time and space complexity. # Example - Given `nums = [1, 2, 3, 4, 5], target = 9`, the output should be `True` because 1 + 3 + 5 = 9. - Given `nums = [1, 2, 3, 4], target = 11`, the output should be `False` because there is no combination of three distinct integers that sum up to 11. # Implementation Guide 1. Iterate through the list using three nested loops to check all possible triplet sums (ensuring all three indices are distinct). 2. Alternatively, sort the list first, and then use a combination of two pointers and a loop to find the triplet efficiently (if the length of the list allows it). ```python from typing import List def three_sum(nums: List[int], target: int) -> bool: Returns True if there are three integers in nums that sum up to target, False otherwise. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: bool: True if a triplet sum equals target, False otherwise. nums.sort() n = len(nums) for i in range(n): left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False # Example usage: print(three_sum([1, 2, 3, 4, 5], 9)) # Output: True print(three_sum([1, 2, 3, 4], 11)) # Output: False ``` This question tests the candidate\'s ability to work with arrays, understand sorting and two-pointer technique, and handle multiple constraints to optimize the search for specific conditions within a list.","solution":"from typing import List def three_sum(nums: List[int], target: int) -> bool: Returns True if there are three integers in nums that sum up to target, False otherwise. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: bool: True if a triplet sum equals target, False otherwise. nums.sort() n = len(nums) for i in range(n): left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"# Sorting a List of Tuples by Multiple Keys Objective: You are given a list of tuples where each tuple contains user data in the format `(user_id, age, score)`. Your task is to sort this list by age in ascending order, and if two users have the same age, then by score in descending order. Problem Statement: Write a function `sort_users(data: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]` that takes a list of tuples `data` where each tuple represents a user with `user_id`, `age`, and `score`. Your function should return a new list that is sorted based on the aforementioned criteria. Input: - A list of tuples `data` where each tuple is of the form `(user_id, age, score)`. Output: - A new list of tuples sorted by age in ascending order and then by score in descending order. Constraints: - The length of `data` is between 1 and 10^5. - Each tuple contains three integers: `user_id`, `age`, and `score`, where: - `user_id` is a unique identifier for each user (0 <= user_id < 10^5). - `age` is a positive integer (1 <= age <= 120). - `score` is a non-negative integer (0 <= score <= 100). Example: ```python sort_users([(1, 24, 70), (2, 30, 90), (3, 24, 85), (4, 22, 80)]) # Output: [(4, 22, 80), (3, 24, 85), (1, 24, 70), (2, 30, 90)] sort_users([(10, 25, 50), (11, 25, 60), (12, 20, 90), (13, 30, 70), (14, 30, 80)]) # Output: [(12, 20, 90), (11, 25, 60), (10, 25, 50), (14, 30, 80), (13, 30, 70)] ``` Hints: 1. In Python, you can use the `sorted` function with a custom sorting key. 2. When using multiple keys in sorting, you can specify a tuple in the key. 3. Remember that to sort by score in descending order, you can use the negative value of the score.","solution":"def sort_users(data): Sorts a list of user data tuples by age in ascending order, then by score in descending order if ages are the same. return sorted(data, key=lambda x: (x[1], -x[2]))"},{"question":"# Question: Implement a function `map_and_count(strings, substring)` that maps a list of strings to their counts of a specified substring. # Function Signature ```python def map_and_count(strings: List[str], substring: str) -> List[int]: ``` # Input: - `strings` (List[str]): A list of strings. - `substring` (str): A substring to count occurrences of within each string. # Output: - A list of integers representing the count of the substring in each respective string from the input list. # Examples: ```python >>> map_and_count([\\"hello\\", \\"world\\", \\"helloworld\\", \\"hellohello\\"], \\"hello\\") [1, 0, 1, 2] >>> map_and_count([\\"abcabc\\", \\"xyzabc\\", \\"ababc\\", \\"\\"], \\"abc\\") [2, 1, 1, 0] >>> map_and_count([\\"abcd\\", \\"abce\\", \\"abcf\\", \\"abcg\\"], \\"xyz\\") [0, 0, 0, 0] >>> map_and_count([\\"mississippi\\", \\"sissi\\", \\"pi\\"], \\"ssi\\") [2, 1, 0] ``` # Constraints: - The function should handle a wide range of input sizes and string lengths. - Assume `substring` will not be an empty string. # Notes: - The function should be efficient in counting the occurrences within each string. - Consider special cases and edge cases such as empty strings in the list and the absence of the substring.","solution":"from typing import List def map_and_count(strings: List[str], substring: str) -> List[int]: def count_substring(s: str, subs: str) -> int: count = 0 start = 0 while True: start = s.find(subs, start) if start == -1: break count += 1 start += len(subs) return count return [count_substring(string, substring) for string in strings]"},{"question":"# Coding Assessment Question: Implement a Min-Heap Data Structure Objective: Implement a Min-Heap data structure that supports insertion and extraction of the minimum element. Description: Design and implement a class `MinHeap` which supports the following methods: * `__init__(self)`: Initializes an empty Min-Heap. * `insert(self, value)`: Inserts a value into the Min-Heap. * `extract_min(self)`: Extracts and returns the minimum value from the Min-Heap. If the heap is empty, it should return `None`. Input/Output: * `__init__(self)`: Initializes an empty Min-Heap. * `insert(self, value)`: Inserts the given value into the Min-Heap. * `extract_min(self)`: Extracts the minimum value from the Min-Heap, or returns `None` if the heap is empty. Constraints: * The values are non-negative integers. * Your implementation should maintain the properties of the Min-Heap. Example: ```python # Example usage min_heap = MinHeap() min_heap.insert(10) min_heap.insert(20) min_heap.insert(5) print(min_heap.extract_min()) # Output: 5 print(min_heap.extract_min()) # Output: 10 print(min_heap.extract_min()) # Output: 20 print(min_heap.extract_min()) # Output: None ``` Requirements: * Maintain the Min-Heap property (parent node is always less than or equal to its children). * Implement necessary heap operations such as `heapify` to maintain the heap structure after insertion and extraction. * Provide necessary handling for edge cases like extracting from an empty heap.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, value): Insert value into the Min-Heap. self.heap.append(value) self.__heapify_up(len(self.heap) - 1) def extract_min(self): Extract and return the minimum value from the Min-Heap. if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() min_value = self.heap[0] self.heap[0] = self.heap.pop() self.__heapify_down(0) return min_value def __heapify_up(self, index): Maintains the heap property from a given index upwards to the root. parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self.__heapify_up(parent_index) def __heapify_down(self, index): Maintains the heap property from a given index downwards to the leaves. smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self.__heapify_down(smallest)"},{"question":"# Task Implement a function `find_combinations(nums: List[int], target: int) -> List[List[int]]` that returns all unique combinations of numbers from the input list `nums` that add up to the target value. Each number in `nums` may be used once in the combination. # Function Signature ```python def find_combinations(nums: List[int], target: int) -> List[List[int]]: pass ``` # Input - `nums`: A list of integers (1 ≤ len(nums) ≤ 30, 1 ≤ nums[i] ≤ 100) - `target`: An integer (1 ≤ target ≤ 300) # Output - A list of lists, where each inner list contains a unique combination of numbers that add up to the target. Combinations within each list should appear in non-descending order. # Examples ```python assert find_combinations([2, 3, 6, 7], 7) == [[7]] assert find_combinations([2, 3, 5], 8) == [[3, 5]] assert find_combinations([10, 1, 2, 7, 6, 1, 5], 8) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] assert find_combinations([2, 4, 6], 7) == [] ``` # Constraints - Each element in the list `nums` can be used once in each combination. - All possible valid combinations should be included in the output list. # Performance Requirements - The function should aim for efficient backtracking to reduce redundant calculations and ensure all combinations are discovered without unnecessary computations.","solution":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: def backtrack(start, path, remaining): if remaining == 0: result.append(list(path)) return if remaining < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue path.append(nums[i]) backtrack(i + 1, path, remaining - nums[i]) path.pop() nums.sort() result = [] backtrack(0, [], target) return result"},{"question":"# Problem Statement: Implement a function that parses a configuration file and extracts key-value pairs. The configuration file contains settings where each line signifies a key-value pair, separated by an equal sign (`=`). Your task is to read the file, parse each line to obtain the key and value, and store them in a dictionary. Additionally, ensure the keys are in lowercase and any leading/trailing whitespace around keys and values is removed. # Function Signature ```python def parse_config_file(file_path: str) -> dict: pass ``` # Input - `file_path` (str): A string representing the path to the configuration file. # Output - Returns a dictionary containing the key-value pairs extracted from the configuration file with processed keys and values. # File Format - Each line in the file represents a key-value pair separated by an equal sign `=`. - Keys and values might have leading or trailing whitespaces. - Lines starting with a hash `#` are comments and should be ignored. - Lines that do not contain an equal sign or are empty should be skipped. # Examples Consider the following configuration file content: ``` # Sample configuration file username = admin password = 1234 host= example.com port= 8080 # An unused setting unused_setting = should be ignored ``` For the above file, the function should return: ```python { \\"username\\": \\"admin\\", \\"password\\": \\"1234\\", \\"host\\": \\"example.com\\", \\"port\\": \\"8080\\" } ``` # Constraints - The maximum size of the file will not exceed 1MB. - The length of any line in the file will not exceed 256 characters. # Notes - Ensure to handle different kinds of whitespaces, including tabs and spaces. - The function should be able to handle up to 100 lines in the file efficiently. # Performance Requirements - The solution should read and process each line of the file in O(n) time complexity, where n is the number of lines in the file. - Space complexity should be O(k), where k is the total number of key-value pairs. Happy coding!","solution":"def parse_config_file(file_path: str) -> dict: config = {} with open(file_path, \'r\') as file: for line in file: line = line.strip() if not line or line.startswith(\'#\'): continue if \'=\' not in line: continue key, value = line.split(\'=\', 1) key = key.strip().lower() value = value.strip() config[key] = value return config"},{"question":"# Problem Statement A common problem in text analysis and processing is to identify substrings that are repeated within the same input string. For this problem, you are tasked with finding all distinct substrings of length `k` that appear more than once in an input string `s`. Your task involves the following steps: 1. **Substring Extraction**: Implement a function to extract all substrings of length `k` from a given string. 2. **Frequency Count**: Implement a function to count the frequency of each substring. 3. **Repeated Substrings Identification**: Implement a function to identify substrings that are repeated more than once. # Function Signatures ```python def extract_substrings(s: str, k: int) -> list[str]: pass def count_frequencies(substrings: list[str]) -> dict[str, int]: pass def find_repeated_substrings(s: str, k: int) -> list[str]: pass ``` # Input/Output Formats * **extract_substrings**: - **Input**: A string `s` and an integer `k`. - **Output**: A list of all substrings of length `k` extracted from `s`. * **count_frequencies**: - **Input**: A list of substrings. - **Output**: A dictionary where keys are substrings and values are their corresponding frequencies. * **find_repeated_substrings**: - **Input**: A string `s` and an integer `k`. - **Output**: A list of substrings of length `k` that appear more than once in `s`. # Constraints * `1 <= len(s) <= 10^5`. * `1 <= k <= len(s)`. # Example ```python # Example 1: assert extract_substrings(\\"abcabc\\", 3) == [\\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\"] assert count_frequencies([\\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\"]) == {\'abc\': 2, \'bca\': 1, \'cab\': 1} assert find_repeated_substrings(\\"abcabc\\", 3) == [\\"abc\\"] # Example 2: assert extract_substrings(\\"aabaaabaaac\\", 2) == [\\"aa\\", \\"ab\\", \\"ba\\", \\"aa\\", \\"aa\\", \\"ab\\", \\"ba\\", \\"aa\\", \\"aa\\", \\"ac\\"] assert count_frequencies([\\"aa\\", \\"ab\\", \\"ba\\", \\"aa\\", \\"aa\\", \\"ab\\", \\"ba\\", \\"aa\\", \\"aa\\", \\"ac\\"]) == {\'aa\': 5, \'ab\': 2, \'ba\': 2, \'ac\': 1} assert find_repeated_substrings(\\"aabaaabaaac\\", 2) == [\\"aa\\", \\"ab\\", \\"ba\\"] ``` # Implementation Notes 1. **extract_substrings**: Iterate through the string, capturing all substrings of length `k`. 2. **count_frequencies**: Utilize a dictionary to count occurrences of each substring. 3. **find_repeated_substrings**: Use the output of `count_frequencies` to identify and return substrings that appear more than once.","solution":"def extract_substrings(s: str, k: int) -> list[str]: Extract all substrings of length k from the given string s. return [s[i:i+k] for i in range(len(s) - k + 1)] def count_frequencies(substrings: list[str]) -> dict[str, int]: Count the frequency of each substring in the given list. frequency = {} for substring in substrings: if substring in frequency: frequency[substring] += 1 else: frequency[substring] = 1 return frequency def find_repeated_substrings(s: str, k: int) -> list[str]: Identify substrings of length k that appear more than once in the given string s. substrings = extract_substrings(s, k) frequency = count_frequencies(substrings) return [substring for substring, count in frequency.items() if count > 1]"},{"question":"# Problem Statement: You are tasked with implementing a `LinkedList` data structure that supports both standard operations and the ability to find and remove elements based on a given value, ensuring efficient traversal and deletion. Your implementation must support generic data types. # Requirements: 1. Implement a class `LinkedList` with the following methods: - `void append(data)`: Adds an element to the end of the list. - `void prepend(data)`: Adds an element to the start of the list. - `bool find(data)`: Returns `True` if an element with the given data exists in the list, otherwise returns `False`. - `bool remove(data)`: Removes the first occurrence of the element with the given data from the list and returns `True`; returns `False` if the element is not found. - `str __str__()`: Returns a string representation of the current list state. 2. Ensure the linked list performs append, prepend, find, and remove operations efficiently. 3. Handle edge cases such as removing elements from an empty list or removing elements that do not exist. 4. The list should be able to handle any data type, not just integers. # Input and Output Formats: - The `append` and `prepend` methods accept a single parameter `data` of generic type. - The `find` and `remove` methods return a boolean indicating the presence or successful removal of the element. - The `__str__` method returns a formatted string representing the linked list. # Constraints: - The linked list can have any number of elements within the limits of system memory. - Elements in the linked list may be of any data type that supports comparison. # Example: ```python class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): # Include your append implementation here pass def prepend(self, data): # Include your prepend implementation here pass def find(self, data) -> bool: # Include your find implementation here pass def remove(self, data) -> bool: # Include your remove implementation here pass def __str__(self) -> str: # Include your string representation here pass # Example usage: ll = LinkedList() ll.append(10) ll.append(20) ll.prepend(5) print(ll) # Expected: 5 -> 10 -> 20 print(ll.find(10)) # Expected: True print(ll.remove(10)) # Expected: True print(ll.find(10)) # Expected: False print(ll) # Expected: 5 -> 20 ``` Complete the class `LinkedList` based on the provided requirements and examples.","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def prepend(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def find(self, data) -> bool: current = self.head while current: if current.data == data: return True current = current.next return False def remove(self, data) -> bool: current = self.head previous = None while current: if current.data == data: if previous: previous.next = current.next else: self.head = current.next return True previous = current current = current.next return False def __str__(self) -> str: nodes = [] current = self.head while current: nodes.append(str(current.data)) current = current.next return \\" -> \\".join(nodes)"},{"question":"# Scenario You are working as a software developer for a robotics company. An essential part of the company\'s navigation system is to accurately track the position of a robot on a 2D plane. The robot can move in four directions: up, down, left, and right. To improve the system, your task is to develop a function that simulates the robot\'s movement and returns its final position after a series of movements. # Task Implement a function `robot_final_position` which takes a string `movements` representing a sequence of movements. The movements are indicated by the characters: \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). The function should return a tuple representing the robot\'s final position in the form `(x, y)`. # Input - A single string `movements` containing the characters \'U\', \'D\', \'L\', \'R\' with length between 1 and 1000. # Output - A tuple of two integers: `(x, y)`, representing the final position of the robot. # Constraints - The robot starts at the origin `(0, 0)`. # Example - Given `movements = \\"UUDDLRLRBB\\"`, the function should return `(0, 2)`. # Note - Each \'U\' movement increases the y-coordinate by 1. - Each \'D\' movement decreases the y-coordinate by 1. - Each \'L\' movement decreases the x-coordinate by 1. - Each \'R\' movement increases the x-coordinate by 1. ```python def robot_final_position(movements: str) -> tuple: Calculate the final position of the robot on a 2D plane after a series of movements. Args: movements (str): A string representing a sequence of movements. Returns: tuple: Final position of the robot as (x, y). # Initialize starting position at the origin x, y = 0, 0 # Iterate over each movement in the input string for move in movements: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 else: raise ValueError(\\"Invalid movement character in the input string.\\") return (x, y) ``` # Explanation The function `robot_final_position` initializes the robot\'s position at `(0, 0)` and iterates through each character in the input string to adjust the position accordingly. The final position is then returned as a tuple `(x, y)`. The constraints and example clarify how to handle various movements and validate the input.","solution":"def robot_final_position(movements: str) -> tuple: Calculate the final position of the robot on a 2D plane after a series of movements. Args: movements (str): A string representing a sequence of movements. Returns: tuple: Final position of the robot as (x, y). # Initialize starting position at the origin x, y = 0, 0 # Iterate over each movement in the input string for move in movements: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return (x, y)"},{"question":"# Problem Statement Design a function `find_k_pairs_with_smallest_sums` that takes two integer arrays `nums1` and `nums2`, and an integer `k`, and returns the `k` pairs `(u1, v1), (u2, v2), ..., (uk, vk)` with the smallest sums (where each pair consists of one element from `nums1` and one element from `nums2`). # Function Signature ```python def find_k_pairs_with_smallest_sums(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]: ``` # Input * `nums1`: A list of integers. * `nums2`: A list of integers. * `k`: An integer representing the number of pairs to return. # Output * Returns a list of tuples of the form `(u, v)` where: * `u` is an element from `nums1` * `v` is an element from `nums2` The list should contain exactly `k` pairs with the smallest sums. # Constraints * The length of the arrays `nums1` and `nums2` will not exceed 10^4. * The value of `k` will not exceed `len(nums1) * len(nums2)`. * All elements in both arrays are integers which can be negative or positive. # Example ```python # Example usage nums1 = [1, 7, 11] nums2 = [2, 4, 6] k = 3 print(find_k_pairs_with_smallest_sums(nums1, nums2, k)) # Output: [(1, 2), (1, 4), (1, 6)] nums1 = [1, 1, 2] nums2 = [1, 2, 3] k = 2 print(find_k_pairs_with_smallest_sums(nums1, nums2, k)) # Output: [(1, 1), (1, 1)] nums1 = [4, 6, 7] nums2 = [1, 2, 3] k = 5 print(find_k_pairs_with_smallest_sums(nums1, nums2, k)) # Output: [(4, 1), (4, 2), (4, 3), (6, 1), (6, 2)] ``` # Additional Notes * If `k` exceeds the total number of possible pairs, return all available pairs. * The returned pairs should be sorted based on their sums, and if sums are equal, they can be in any order.","solution":"from typing import List, Tuple import heapq def find_k_pairs_with_smallest_sums(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]: if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(len(nums1), k)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while min_heap and len(result) < k: current_sum, i, j = heapq.heappop(min_heap) result.append((nums1[i], nums2[j])) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) return result"},{"question":"# Context You have been tasked with developing a system to manage and manipulate customer information at a local bank. One of the requirements is to verify customer data for specific criteria and format it according to the bank\'s standards. # Task Write a function `format_customer_data(data: list[tuple[str, int]]) -> list[str]` that processes and formats customer data. The function should check the validity of each customer\'s name and age, then return a list of formatted strings for valid customer records, each string in the format `\\"Name: {name}, Age: {age}\\"`. # Function Signature ```python def format_customer_data(data: list[tuple[str, int]]) -> list[str]: Processes and formats a list of customer data tuples. :param data: A list of tuples, each containing a string (customer\'s name) and an integer (customer\'s age). :return: A list of formatted strings for valid customer data. ``` # Input * `data`: A list of tuples, each containing a customer\'s name as a string (first element) and age as an integer (second element). For example: `[(\\"Alice\\", 30), (\\"Bob\\", 17), (\\"Charlie\\", 25)]` # Output * A list of formatted strings for valid customer data. A valid customer has a name consisting only of alphabetic characters and a valid age between 18 and 99 inclusive. * The formatted string for each valid customer is in the format: `\\"Name: {name}, Age: {age}\\"` # Constraints * 0 ≤ len(data) ≤ 10^3 * Names are non-empty strings containing only alphabetic characters. * Ages are non-negative integers. # Examples 1. Input: `[(\\"Alice\\", 30), (\\"Bob\\", 17), (\\"Charlie\\", 25)]` Output: `[\\"Name: Alice, Age: 30\\", \\"Name: Charlie, Age: 25\\"]` 2. Input: `[(\\"Daisy\\", 20), (\\"Eve\\", 18), (\\"Frank\\", 100)]` Output: `[\\"Name: Daisy, Age: 20\\", \\"Name: Eve, Age: 18\\"]` 3. Input: `[(\\"Grace\\", 30), (\\"Heidi\\", -5), (\\"Ivan\\", 19), (\\"Judy2023\\", 40)]` Output: `[\\"Name: Grace, Age: 30\\", \\"Name: Ivan, Age: 19\\"]` # Notes Consider edge cases such as empty strings for names, invalid ages outside the specified range, and ensure that your function filters out these appropriately. Ensure that all names are valid alphabetic characters and all ages are within the specified range before formatting.","solution":"def format_customer_data(data): Processes and formats a list of customer data tuples. :param data: A list of tuples, each containing a string (customer\'s name) and an integer (customer\'s age). :return: A list of formatted strings for valid customer data. valid_customers = [] for name, age in data: if name.isalpha() and 18 <= age <= 99: valid_customers.append(f\\"Name: {name}, Age: {age}\\") return valid_customers"},{"question":"# Power Function Implementation Your task is to implement a power function that computes the result of raising a base number to a specified integer exponent. Function Signature ```python def power(base: float, exponent: int) -> float: ``` Input - A floating-point number `base`. - An integer `exponent`. Output - A floating-point number representing the result of raising `base` to the power of `exponent`. Constraints - The base should be a typical floating-point number, and the exponent can be any integer. - Performance should be efficient with a time complexity of O(log n). Examples ```python - Input: base = 2.0, exponent = 3 Output: 8.0 - Input: base = 5.0, exponent = -2 Output: 0.04 - Input: base = 3.0, exponent = 0 Output: 1.0 - Input: base = 2.5, exponent = 4 Output: 39.0625 - Input: base = -1.0, exponent = 3 Output: -1.0 ``` Additional requirements - You should not use the built-in `math.pow()` function or the ** operator in your implementation. - The algorithm should handle both positive and negative exponents. - Ensure that the implemented function passes all given example cases. Write your code to implement the function based on the described behavior and constraints.","solution":"def power(base: float, exponent: int) -> float: Raises base to the power of exponent. if exponent == 0: return 1.0 if base == 0: return 0.0 if exponent > 0 else float(\'inf\') # 0 raised to any positive power is 0; 0 raised to negative power is infinity result = 1.0 abs_exponent = abs(exponent) while abs_exponent > 0: if abs_exponent % 2 == 1: result *= base base *= base abs_exponent //= 2 return result if exponent > 0 else 1.0 / result"},{"question":"# Task Description You are provided with a `Tweet` class that simulates a single Tweet and a `TwitterUser` class that manages the Tweets of a user. Implement the following functionalities for the `TwitterUser` class: `post_tweet(self, content: str) -> None`, `get_timeline(self) -> list[str]`, and `most_common_word(self) -> str`. # Function Signatures ```python class Tweet: def __init__(self, content: str): self.content = content self.timestamp = int(time.time()) # represents the time of the tweet\'s creation class TwitterUser: def __init__(self): self.tweets = [] def post_tweet(self, content: str) -> None: pass def get_timeline(self) -> list[str]: pass def most_common_word(self) -> str: pass ``` # Input - `post_tweet(content: str)`: receives a string with the tweet content. - `get_timeline()`: no parameters, retrieves all tweets content sorted from most recent to oldest. - `most_common_word()`: no parameters, identifies the most frequently occurring word in all the user\'s tweets. # Output - `post_tweet(content: str)`: does not return anything. - `get_timeline()`: returns a list of strings, representing the tweets\' content sorted from most recent to oldest. - `most_common_word()`: returns a string representing the most frequently occurring word across all tweets. # Constraints - Tweets do not exceed 140 characters. - Each `TwitterUser` can have at most `10^4` tweets. - Words are case-insensitive, meaning \'Hello\' and \'hello\' should be considered as the same word. - No tweet content will be an empty string. # Examples ```python user = TwitterUser() user.post_tweet(\\"Hello world\\") user.post_tweet(\\"Hello again\\") user.get_timeline() # Output: [\\"Hello again\\", \\"Hello world\\"] user.most_common_word() # Output: \\"hello\\" ``` # Notes - Ensure you account for the case sensitivity and handle the timestamp to verify the order of tweets in the timeline correctly. - Focus on optimizing the functions to handle the maximum constraints efficiently. - Consider using auxiliary data structures to maintain efficient access and updates for frequently queried information like the most common word. # Implementation Implement the class `TwitterUser` and ensure the methods `post_tweet`, `get_timeline`, and `most_common_word` are efficient and correctly handle all edge cases described.","solution":"import time from collections import defaultdict, Counter class Tweet: def __init__(self, content: str): self.content = content self.timestamp = int(time.time()) # represents the time of the tweet\'s creation class TwitterUser: def __init__(self): self.tweets = [] def post_tweet(self, content: str) -> None: tweet = Tweet(content) self.tweets.append(tweet) def get_timeline(self) -> list: # sort by timestamp descending and return content return [tweet.content for tweet in sorted(self.tweets, key=lambda x: x.timestamp, reverse=True)] def most_common_word(self) -> str: word_count = Counter() for tweet in self.tweets: words = tweet.content.lower().split() word_count.update(words) if word_count: return word_count.most_common(1)[0][0] return \\"\\""},{"question":"# Coding Assessment Question Background In a scenario where a system administrator needs to monitor the health statuses of a set of servers, a basic utility is required to automate this task. Each server status can either be \\"up\\" or \\"down\\", and the statuses are stored in a sequential list. The utility should detect if there are any consecutive servers that are \\"down\\" and alert the administrator if this happens. Objective Your task is to implement a function that checks a list of server statuses and detects any consecutive \\"down\\" statuses. If found, it should print the indices of the servers that are down consecutively. Function Signature ```python def check_server_statuses(statuses: list) -> None: ``` Input * `statuses` (list): A list of strings where each string is either \\"up\\" or \\"down\\" representing the status of each server. Output If there are consecutive \\"down\\" statuses, print \\"Alert! Consecutive down servers at indices: [indexes]\\". If there are no consecutive \\"down\\" statuses, print \\"All servers are operating normally.\\" Constraints 1. The list will have at least one element. 2. Each element in the list will be either \\"up\\" or \\"down\\". Example 1 ```python check_server_statuses([\\"up\\", \\"down\\", \\"down\\", \\"up\\", \\"up\\"]) ``` Output: ``` Alert! Consecutive down servers at indices: [1, 2] ``` Example 2 ```python check_server_statuses([\\"up\\", \\"up\\", \\"down\\", \\"up\\", \\"down\\", \\"down\\", \\"up\\"]) ``` Output: ``` Alert! Consecutive down servers at indices: [4, 5] ``` Example 3 ```python check_server_statuses([\\"up\\", \\"up\\", \\"up\\"]) ``` Output: ``` All servers are operating normally. ``` Example 4 ```python check_server_statuses([\\"down\\", \\"down\\", \\"down\\", \\"down\\"]) ``` Output: ``` Alert! Consecutive down servers at indices: [0, 1, 2, 3] ``` Notes * Ensure that the function properly handles situations with varying lengths of consecutive \\"down\\" statuses and handles lists with only one status. * The function should be robust enough to handle unexpected inputs gracefully, providing useful error messages if necessary. Your solution should efficiently detect consecutive \\"down\\" statuses and provide clear, actionable output.","solution":"def check_server_statuses(statuses: list) -> None: if not all(status in [\\"up\\", \\"down\\"] for status in statuses): raise ValueError(\\"List elements must be \'up\' or \'down\'\\") consecutive_down_indices = [] for i in range(1, len(statuses)): if statuses[i] == \\"down\\" and statuses[i - 1] == \\"down\\": if not consecutive_down_indices or consecutive_down_indices[-1] != i - 1: consecutive_down_indices.append(i - 1) consecutive_down_indices.append(i) if consecutive_down_indices: print(f\\"Alert! Consecutive down servers at indices: {list(set(consecutive_down_indices))}\\") else: print(\\"All servers are operating normally.\\")"},{"question":"# Problem Statement You are given an array of integers representing the heights of buildings in a city. Imagine you are standing at the last building in the array and looking back towards the first building. Write a function `count_visible_buildings` that returns the count of buildings that are visible when looking back from the last building. Function Signature ```python def count_visible_buildings(buildings: list[int]) -> int: ``` Input - `buildings` (list[int]): A list of integers where each integer represents the height of a building. The list will have at least one building and at most 10,000 buildings. Each height will be between 1 and 1,000,000. Output - An integer representing the count of buildings visible from the last building in the array. Constraints - A building is considered visible if there are no taller buildings blocking the view between it and the last building in the array. # Example ```python buildings = [4, 2, 3, 1] print(count_visible_buildings(buildings)) # Output should be 3 because buildings with heights 1, 3, and 4 are visible from the last building. buildings = [5, 4, 3, 2, 1] print(count_visible_buildings(buildings)) # Output should be 5 because all buildings are visible from the last building. buildings = [1, 2, 3, 4, 5] print(count_visible_buildings(buildings)) # Output should be 1 because only the last building is visible from itself. ``` # Additional Notes - Implement your solution efficiently to handle the upper limit of the input size. - You should test for various edge cases, such as when all buildings have the same height or when the list contains only one building.","solution":"def count_visible_buildings(buildings: list[int]) -> int: Returns the count of buildings that are visible when looking back from the last building. visible_count = 0 max_height_seen = 0 # Iterate through the list from the last to the first building. for height in reversed(buildings): if height > max_height_seen: visible_count += 1 max_height_seen = height return visible_count"},{"question":"Number Permutation Identification You are to implement a program that identifies if one number is a permutation of another. For example, 321 is a permutation of 123 as they consist of the same digits. **Input/Output:** - **Input**: The input consists of: 1. `num1` - A positive integer. 2. `num2` - Another positive integer. - **Output**: Return a boolean `True` if `num2` is a permutation of `num1`, otherwise `False`. # Requirements: 1. **Handling Edge Cases**: - The function should handle very large numbers efficiently. - Ensure proper handling of edge cases like leading zeros in permutations. 2. **Performance Considerations**: - The function should optimize for time efficiency, even with very large inputs. # Function Signature: ```python def is_permutation(num1: int, num2: int) -> bool: pass ``` # Examples: ```python # Example usage: num1 = 123 num2 = 321 print(is_permutation(num1, num2)) # Output: True num1 = 123456 num2 = 654321 print(is_permutation(num1, num2)) # Output: True num1 = 123 num2 = 2310 print(is_permutation(num1, num2)) # Output: False num1 = 123 num2 = 1234 print(is_permutation(num1, num2)) # Output: False ``` # Constraints: - Assume all inputs are valid and are positive integers. - The function should handle integers up to 10^18 efficiently. # Notes: - You can utilize in-built functions and data structures like lists or dictionaries for easier handling of digits in the numbers. - Ensure your function does not rely on converting numbers to strings, maximizing numerical operations to handle digit permutations.","solution":"def is_permutation(num1: int, num2: int) -> bool: Determines if num2 is a permutation of num1. Args: num1 (int): First integer number. num2 (int): Second integer number. Returns: bool: True if num2 is a permutation of num1, False otherwise. # Convert the numbers to strings to count digits str1 = str(num1) str2 = str(num2) # If lengths don\'t match, they can\'t be permutations if len(str1) != len(str2): return False # Count frequency of each digit from collections import Counter count1 = Counter(str1) count2 = Counter(str2) # Check if both have the same digit frequencies return count1 == count2"},{"question":"# Fibonacci Sequence Generator You are required to implement a function that generates the Fibonacci sequence up to a specified number. Additionally, you should create functions to handle user input and output to validate they are receiving the correct Fibonacci sequence. Function Signatures: 1. `def generate_fibonacci_sequence(upto: int) -> list` 2. `def get_user_input() -> int` 3. `def print_fibonacci_sequence(fib_sequence: list) -> None` Description: - `generate_fibonacci_sequence(upto: int)`: This function accepts an integer `upto` and returns a list containing the Fibonacci sequence up to but not exceeding the specified number. - `get_user_input()`: This function prompts the user to enter a positive integer and returns the input value. Ensure that invalid inputs (e.g., negative integers, non-numeric inputs) are handled appropriately by re-prompting the user until a valid input is provided. - `print_fibonacci_sequence(fib_sequence: list)`: This function accepts a list of integers (the Fibonacci sequence) and prints each number in the sequence on a new line. Example: ```python >>> generate_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8] >>> generate_fibonacci_sequence(21) [0, 1, 1, 2, 3, 5, 8, 13, 21] >>> print_fibonacci_sequence([0, 1, 1, 2, 3, 5, 8]) 0 1 1 2 3 5 8 >>> get_user_input() Please enter a positive integer: twenty Invalid input. Please enter a positive integer: -5 Invalid input. Please enter a positive integer: 13 13 ``` Usage: Here\'s an example of how the functions might be used together in a script to allow users to generate and print a Fibonacci sequence: ```python def main(): upto = get_user_input() fib_sequence = generate_fibonacci_sequence(upto) print_fibonacci_sequence(fib_sequence) if __name__ == \\"__main__\\": main() ``` # Notes: 1. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones. 2. Ensure the user is repeatedly prompted until a valid positive integer is provided. 3. The sequence should stop at the largest Fibonacci number that does not exceed `upto`.","solution":"def generate_fibonacci_sequence(upto: int) -> list: Generates the Fibonacci sequence up to a specified number. :param upto: The upper limit up to which the Fibonacci sequence is generated. :return: A list containing the Fibonacci sequence up to the specified number. if upto < 0: return [] fib_sequence = [] a, b = 0, 1 while a <= upto: fib_sequence.append(a) a, b = b, a + b return fib_sequence def get_user_input() -> int: Prompts the user to enter a positive integer and returns the input. :return: A positive integer provided by the user. while True: try: user_input = int(input(\\"Please enter a positive integer: \\")) if user_input >= 0: return user_input else: print(\\"Invalid input. Please enter a positive integer.\\") except ValueError: print(\\"Invalid input. Please enter a positive integer.\\") def print_fibonacci_sequence(fib_sequence: list) -> None: Prints the Fibonacci sequence. :param fib_sequence: A list containing the Fibonacci sequence to be printed. for number in fib_sequence: print(number)"},{"question":"# Sorting a List of Tuples You are given a list of tuples, where each tuple contains two elements: a string and an integer. Implement the method `sort_tuples` that sorts the list primarily by the integer value in ascending order, and if two tuples have the same integer value, sort those tuples by the string value in alphabetical order. # Explanation: The `sort_tuples` method should sort the list based on the rules mentioned, modifying the list in place. # Function Signature: ```python def sort_tuples(lst): ... ``` # Expected Inputs and Outputs: * **Input**: * lst: A list of tuples [(str, int), (str, int), ...] * **Output**: * The sorted list of tuples. # Example: ```python # Initial list of tuples tuples_list = [(\\"apple\\", 10), (\\"banana\\", 20), (\\"orange\\", 15), (\\"kiwi\\", 20), (\\"grape\\", 15)] sort_tuples(tuples_list) # After sorting # [(\\"apple\\", 10), (\\"grape\\", 15), (\\"orange\\", 15), (\\"banana\\", 20), (\\"kiwi\\", 20)] assert tuples_list == [(\\"apple\\", 10), (\\"grape\\", 15), (\\"orange\\", 15), (\\"banana\\", 20), (\\"kiwi\\", 20)] ``` # Constraints: 1. The list length will be between 0 and 10000 tuples. 2. The string elements will contain only lowercase letters and be no more than 100 characters long. 3. The integer elements will be between -10000 and 10000. # Testing: Your solution will be tested with the following scenario: 1. Sorting an empty list. 2. Sorting a list with one tuple. 3. Sorting a list with multiple tuples with distinct integer values. 4. Sorting a list with multiple tuples sharing the same integer value. 5. Sorting a list with a mix of strings and integer values. # Notes: Make sure to handle edge cases where the list is empty or has only one tuple. Ensure proper sorting by both integer and string values.","solution":"def sort_tuples(lst): Sorts a list of tuples, where each tuple contains a string and an integer, primarily by the integer value in ascending order, and if two tuples have the same integer value, it sorts those tuples by the string value in alphabetical order. lst.sort(key=lambda x: (x[1], x[0]))"},{"question":"# Robot Navigation in a Grid Problem Statement You are given a grid (2D list) representing a field where \'1\' represents an obstacle and \'0\' represents a free space. Your task is to write a function `shortest_path(grid: List[List[int]]) -> int` that computes the length of the shortest path from the top-left corner (0,0) to the bottom-right corner of the grid. You can only move up, down, left, or right. If there is no path to the destination, return -1. Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: ``` Input - `grid`: A 2D list of integers (0s and 1s) of dimensions n x m (1 <= n, m <= 100). Output - An integer representing the length of the shortest path from the top-left to the bottom-right corner. Return -1 if no such path exists. Constraints - The grid will always have at least 1 row and 1 column. - The start and end points are always free spaces (i.e., `grid[0][0] == 0` and `grid[-1][-1] == 0`). Performance Requirements - The solution should be implemented using a Breadth-First Search (BFS) approach to ensure the shortest path is found efficiently. - The time complexity of the solution should be O(n * m) considering the breadth-first traversal. Example Given the following grid: ``` [ [0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0], [1, 1, 1, 0] ] ``` The function `shortest_path([[0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0], [1, 1, 1, 0]])` should return `7`. Implementation Provide a complete implementation of the function that processes the grid and calculates the shortest path using the BFS strategy.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]]) -> int: Computes the length of the shortest path from the top-left corner to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) def in_bounds(x: int, y: int) -> bool: return 0 <= x < n and 0 <= y < m # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 1)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reach the bottom-right corner if (x, y) == (n - 1, m - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) # If there is no path to the bottom-right corner return -1"},{"question":"# Coding Assessment Question # Scenario Your team is developing a web application that includes a feature to schedule tasks and send reminders to users. To ensure the reminders go out at appropriate times, you need a feature to convert a list of given times in different time zones to UTC (Coordinated Universal Time). # Task Implement a function: 1. `convert_to_utc(times: List[Tuple[str, str]]) -> List[str]` **Function Details**: 1. **convert_to_utc**: Converts a list of times with their respective time zones to UTC. * **Input**: * `times` (List[Tuple[str, str]]): A list of tuples where each tuple contains a time (`str`) in \\"HH:MM\\" format and a time zone (`str`) as a string representing the difference from UTC (e.g., \\"+02:00\\", \\"-05:30\\"). * **Output**: * (List[str]): A list of times in UTC, each in \\"HH:MM\\" format. # Constraints and Requirements * Time zones will always be in the format of \\"+HH:MM\\" or \\"-HH:MM\\". * Times will always be valid and in the 24-hour \\"HH:MM\\" format. * Input list can contain from 1 to 1000 elements. * The function should have a time complexity of O(n) and space complexity of O(n). **Example**: ```python convert_to_utc([(\\"14:45\\", \\"+02:00\\"), (\\"02:30\\", \\"-05:30\\")]) -> [\\"12:45\\", \\"08:00\\"] convert_to_utc([(\\"23:15\\", \\"+00:00\\"), (\\"06:50\\", \\"-01:00\\")]) -> [\\"23:15\\", \\"07:50\\"] ``` # Additional Requirements 1. Implement error handling for invalid inputs (non-string times or time zones, invalid formats). 2. Your solution should be efficient and avoid unnecessary computations. 3. Write at least 3 test cases to validate correctness. # Example of Implementation Here is an example of how the function can be utilized: ```python times = [(\\"14:45\\", \\"+02:00\\"), (\\"02:30\\", \\"-05:30\\"), (\\"23:15\\", \\"+00:00\\"), (\\"06:50\\", \\"-01:00\\")] result = convert_to_utc(times) print(result) # Expected: [\\"12:45\\", \\"08:00\\", \\"23:15\\", \\"07:50\\"] ```","solution":"from typing import List, Tuple from datetime import datetime, timedelta def convert_to_utc(times: List[Tuple[str, str]]) -> List[str]: Converts a list of times with their respective time zones to UTC. :param times: List of tuples containing the time in \\"HH:MM\\" format and the time zone in \\"+HH:MM\\" or \\"-HH:MM\\" format :return: List of times in UTC in \\"HH:MM\\" format utc_times = [] for time_str, timezone in times: # Parsing the time string and timezone offset time_obj = datetime.strptime(time_str, \\"%H:%M\\") sign = 1 if timezone[0] == \'+\' else -1 hours_offset = int(timezone[1:3]) minutes_offset = int(timezone[4:6]) # Calculate the total offset in minutes total_offset = sign * (hours_offset * 60 + minutes_offset) # Convert the time to UTC utc_time = time_obj - timedelta(minutes=total_offset) utc_times.append(utc_time.strftime(\\"%H:%M\\")) return utc_times"},{"question":"# Problem Statement Write a function that finds the smallest window in a given string `s` that contains all the characters of another string `t`. If there is no such window, the function should return an empty string. If there are multiple windows with the same size, return the one that appears first. # Function Specification Input * The function will receive two strings `s` and `t`, where: * s (1 ≤ |s| ≤ 10^6) * t (1 ≤ |t| ≤ 10^6) Output * The function should return a string representing the smallest window in `s` that contains all characters of `t`. # Requirements * Your solution should be efficient in terms of both time and space complexity. * The order in which characters appear in the output does not need to match the order they appear in `t`. # Function Signatures ```python def min_window_substring(s: str, t: str) -> str: pass ``` # Example ```python assert min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" assert min_window_substring(\\"a\\", \\"a\\") == \\"a\\" assert min_window_substring(\\"a\\", \\"aa\\") == \\"\\" ``` # Constraints * Ensure that your function handles edge cases like when `t` is longer than `s`. * Consider the case when characters can appear multiple times in both strings `s` and `t`. # Hint - Utilize the sliding window technique alongside two pointers to achieve the desired efficiency. - Maintain a frequency count of characters to ensure that all characters in `t` are covered in the current window of `s`.","solution":"def min_window_substring(s: str, t: str) -> str: from collections import Counter, defaultdict if not s or not t or len(s) < len(t): return \\"\\" # Create a frequency counter for t dict_t = Counter(t) required = len(dict_t) # Initialize the window pointers and required variables l, r = 0, 0 formed = 0 window_counts = defaultdict(int) # Resultant variables - (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] += 1 # Check if character frequency matches the requirement in t if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try to contract the window until the point where it ceases to be \'desirable\' while l <= r and formed == required: character = s[l] # Save the smallest window until now if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1] : ans[2] + 1]"},{"question":"# Problem Statement Implement a \\"Game of Life\\" simulator based on John Conway\'s cellular automaton, focusing on optimizing the simulation process to handle a larger grid efficiently. Requirements 1. Your function should simulate the Game of Life for a specified number of steps and return the final grid state. 2. Optimize the simulation to efficiently handle grids up to 1000x1000 cells and up to 100 steps. # Input - **initial_grid**: 2D numpy array of shape (m, n), where each element is either 0 (dead) or 1 (alive). - **steps**: Number of iterations to perform (integer value, constrained to 0 ≤ steps ≤ 100). # Output - A 2D numpy array representing the final grid state after the specified number of steps. # Implementation Guidelines 1. Implement `simulate_step` and `run_simulation` functions to ensure time efficiency. 2. Ensure the use of numpy operations to optimize the computation. 3. Handle large grid sizes efficiently by avoiding unnecessary computations and memory usage. # Function Signature ```python def game_of_life(initial_grid: np.ndarray, steps: int) -> np.ndarray: pass ``` # Example ```python import numpy as np INITIAL_GRID = np.array([ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ]) result = game_of_life(INITIAL_GRID, 5) print(result) ``` # Constraints - Do not use any external libraries or resources other than numpy. - Ensure the function executes efficiently within the constraints provided. - Handle all potential edge cases and optimize for performance where possible.","solution":"import numpy as np def simulate_step(grid: np.ndarray) -> np.ndarray: Simulate one step in the Game of Life. m, n = grid.shape # Create a padded version of the grid to handle edge cells more easily padded_grid = np.pad(grid, pad_width=1, mode=\'constant\', constant_values=0) # Create a copy of the grid to store the results new_grid = np.zeros_like(grid) # Iterate over each cell in the original grid for i in range(1, m + 1): for j in range(1, n + 1): # Extract the 3x3 neighborhood of the current cell neighborhood = padded_grid[i-1:i+2, j-1:j+2] # Count the number of alive cells around the current cell live_neighbors = np.sum(neighborhood) - padded_grid[i, j] # Apply the Game of Life rules if padded_grid[i, j] == 1 and (live_neighbors == 2 or live_neighbors == 3): new_grid[i-1, j-1] = 1 elif padded_grid[i, j] == 0 and live_neighbors == 3: new_grid[i-1, j-1] = 1 else: new_grid[i-1, j-1] = 0 return new_grid def game_of_life(initial_grid: np.ndarray, steps: int) -> np.ndarray: Simulate the Game of Life for a specified number of steps. current_grid = initial_grid.copy() for _ in range(steps): current_grid = simulate_step(current_grid) return current_grid"},{"question":"# Question: Implement the Leet Speak Translator You are required to implement a class `LeetTranslator` with methods to encode and decode messages using the Leet speak technique. Your implementation should follow the standards below: Class: `LeetTranslator` Methods: 1. **`encode(self, message: str) -> str`**: * Input: A message (str) to be encoded. * Output: The encoded message (str) in Leet speak. * Example: `LeetTranslator().encode(\'leet\')` should return `\'l337\'`. 2. **`decode(self, message: str) -> str`**: * Input: An encoded message (str) in Leet speak. * Output: The decoded message (str). * Example: `LeetTranslator().decode(\'l337\')` should return `\'leet\'`. Leet Speak Mapping (simplified): * \'a\' -> \'4\' * \'e\' -> \'3\' * \'i\' -> \'1\' * \'o\' -> \'0\' * \'t\' -> \'7\' * The mapping is case-insensitive. Constraints: * The message will contain only lowercase and uppercase letters and spaces. * Spaces should be preserved in the encoded and decoded messages. * The Leet translation is case-insensitive (both \'A\' and \'a\' translate to \'4\'). ```python class LeetTranslator: def __init__(self) -> None: self.leet_dict = { \'a\': \'4\', \'A\': \'4\', \'e\': \'3\', \'E\': \'3\', \'i\': \'1\', \'I\': \'1\', \'o\': \'0\', \'O\': \'0\', \'t\': \'7\', \'T\': \'7\' } self.reverse_leet_dict = {v: k for k, v in self.leet_dict.items()} def encode(self, message: str) -> str: encoded_message = \'\'.join([self.leet_dict.get(char, char) for char in message]) return encoded_message def decode(self, message: str) -> str: decoded_message = \'\'.join([self.reverse_leet_dict.get(char, char) for char in message]) return decoded_message # Example Usage: # translator = LeetTranslator() # encoded_message = translator.encode(\\"leet speak\\") # decoded_message = translator.decode(encoded_message) # print(f\\"Encoded: {encoded_message}, Decoded: {decoded_message}\\") ``` In this question, the `LeetTranslator` class should provide methods to encode messages into Leet speak and decode them back into the original message. The Leet speak encoding follows a specific character mapping, and both encoding and decoding methods should handle the translation based on these mappings.","solution":"class LeetTranslator: def __init__(self) -> None: self.leet_dict = { \'a\': \'4\', \'A\': \'4\', \'e\': \'3\', \'E\': \'3\', \'i\': \'1\', \'I\': \'1\', \'o\': \'0\', \'O\': \'0\', \'t\': \'7\', \'T\': \'7\' } self.reverse_leet_dict = {v: k.lower() for k, v in self.leet_dict.items()} def encode(self, message: str) -> str: encoded_message = \'\'.join([self.leet_dict.get(char, char) for char in message]) return encoded_message def decode(self, message: str) -> str: decoded_message = \'\'.join([self.reverse_leet_dict.get(char, char) for char in message]) return decoded_message"},{"question":"# Coding Assessment Question **Objective**: To test your understanding of dynamic programming and optimal substructure by solving the classic \\"Knapsack Problem\\". **Problem Statement**: Given a set of items, each with a weight and a value, determine the maximum value that can be accumulated in a knapsack without exceeding a given weight limit. **Function Signature**: ```python def knapsack(weights: list[int], values: list[int], capacity: int) -> int: pass ``` **Input**: * `weights`: A list of integers representing the weights of the items. * `values`: A list of integers representing the values of the items. * `capacity`: An integer representing the maximum weight capacity of the knapsack. **Output**: * Returns an integer that represents the maximum value that can be accommodated in the knapsack without exceeding the given capacity. **Constraints**: 1. `1 <= len(weights) == len(values) <= 100` 2. `1 <= weights[i] <= 1000` 3. `1 <= values[i] <= 1000` 4. `1 <= capacity <= 1000` **Example**: ```python weights = [10, 20, 30] values = [60, 100, 120] capacity = 50 print(knapsack(weights, values, capacity)) # Output 220 ``` **Requirements**: 1. Write your implementation inside the `knapsack` function. 2. Utilize dynamic programming to achieve optimal complexity. 3. Ensure your solution handles edge cases such as zero capacity and empty item lists. **Note**: - You are expected to construct a dynamic programming table as part of your implementation. - Use the provided sample input to debug and test your function.","solution":"def knapsack(weights, values, capacity): Solves the knapsack problem using dynamic programming. Args: weights (list[int]): The weights of the items. values (list[int]): The values of the items. capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value that can be accommodated in the knapsack without exceeding the given capacity. n = len(weights) # Create a DP table to store results of subproblems dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] # Build the table in bottom up manner for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"# Coding Assessment Question Context: You are working with a social media platform that requires analyzing user messages. One of the tasks involves identifying and extracting all unique hashtagged words from a user\'s message. A hashtagged word starts with a hash symbol (#) and ends with a whitespace, punctuation mark, or string termination. Implement a function that extracts these words, ignoring case sensitivity and treating hashtags like `#Word` and `#word` as the same. Task: Implement a function `extract_hashtags` that takes a single string representing the user\'s message and returns a set of unique hashtagged words in lowercase. Expected Input and Output Formats: Function signature: ```python def extract_hashtags(message: str) -> set: # your implementation here ``` - **Input**: - `message` (str): A string containing the user\'s message. - **Output**: - A set of unique hashtagged words in lowercase (set of str). Constraints and Assumptions: - The input is always a valid string. - Hashtagged words are composed of alphanumeric characters only after the hash symbol. - Extracted words should not include the hash symbol (#) and should be in lowercase. - The message could be as long as the maximum length of a tweet (280 characters). Example: ```python # Example 1 message = \\"Loving the #Sunshine and #beaches! #Sunshine\\" output = extract_hashtags(message) print(output) # Output should be {\'sunshine\', \'beaches\'} # Example 2 message = \\"#Coding is fun! #Python #coding #Fun #pythOn #2023\\" output = extract_hashtags(message) print(output) # Output should be {\'coding\', \'python\', \'fun\'} ``` Hints: - Use regular expressions to find hashtagged words. - Remember to handle different punctuation marks and end of strings correctly. - Convert all extracted words to lowercase to ensure uniqueness. Sample Implementation: ```python import re def extract_hashtags(message: str) -> set: # Regular expression to find hashtagged words hashtags = re.findall(r\'#bw+b\', message) # Convert to lowercase and remove the \'#\' symbol unique_hashtags = {hashtag[1:].lower() for hashtag in hashtags} return unique_hashtags # Testing the function message = \\"Loving the #Sunshine and #beaches! #Sunshine\\" output = extract_hashtags(message) print(output) # Output should be {\'sunshine\', \'beaches\'} message = \\"#Coding is fun! #Python #coding #Fun #pythOn #2023\\" output = extract_hashtags(message) print(output) # Output should be {\'coding\', \'python\', \'fun\'} ```","solution":"import re def extract_hashtags(message: str) -> set: Extracts all unique hashtagged words from a user\'s message, ignoring case sensitivity. Args: - message (str): A string containing the user\'s message. Returns: - set: A set of unique hashtagged words in lowercase. # Regular expression to find hashtagged words hashtags = re.findall(r\'#bw+b\', message) # Convert to lowercase and remove the \'#\' symbol unique_hashtags = {hashtag[1:].lower() for hashtag in hashtags} return unique_hashtags"},{"question":"# Coding Assessment Question: Implementing Lexicographic Substring Finder Context: A social media platform wants to implement a feature that extracts the lexicographically smallest substring of a fixed length from user-generated content. This feature is useful for creating unique identifiers and tags from posts. Your task is to help them by implementing this functionality. Your Task: Write a function called `smallest_substring` that: 1. **Receives** a string of text and an integer representing the desired length of the substring. 2. **Finds and returns** the lexicographically smallest substring of the specified length within the text. Function Signature: ```python def smallest_substring(text: str, length: int) -> str: Finds the lexicographically smallest substring of a given length within the provided text. :param text: A string representing the text. :param length: An integer representing the desired length of the substring. :return: The lexicographically smallest substring of the given length in the text. Example: >>> smallest_substring(\\"justanotherexample\\", 4) \'ampl\' >>> smallest_substring(\\"abracadabra\\", 3) \'abr\' >>> smallest_substring(\\"sampletext\\", 5) \'ample\' ``` # Constraints: * The length of the text will not exceed 10,000 characters. * The provided length will be a positive integer and will not exceed the length of the text. Implementation: Ensure your function scans through all possible substrings of the given length efficiently and correctly determines the lexicographically smallest one. Handle edge cases where the text is very short or the length is exactly the length of the text.","solution":"def smallest_substring(text: str, length: int) -> str: Finds the lexicographically smallest substring of a given length within the provided text. :param text: A string representing the text. :param length: An integer representing the desired length of the substring. :return: The lexicographically smallest substring of the given length in the text. smallest = text[:length] for i in range(1, len(text) - length + 1): current = text[i:i + length] if current < smallest: smallest = current return smallest"},{"question":"# Coding Assessment Question **Context**: In competitive programming, efficient calculation of prime numbers is a crucial skill. The Sieve of Eratosthenes is an ancient algorithm used to find all prime numbers up to a given limit. Given a range [L, R], your task is to implement a function that calculates the sum of all prime numbers within this range, inclusive. **Objective**: Implement the function `sum_of_primes_in_range(L: int, R: int) -> int` that returns the sum of all primes within the specified range [L, R]. Additionally, implement a function `count_primes_in_range(L: int, R: int) -> int` that returns the count of primes in the same range. **Function Signature**: ```python def sum_of_primes_in_range(L: int, R: int) -> int: pass def count_primes_in_range(L: int, R: int) -> int: pass ``` **Input and Output Formats**: 1. `sum_of_primes_in_range(L, R)`: - **Input**: - `L` (int): The lower bound of the range. (L >= 0) - `R` (int): The upper bound of the range. (R >= L) - **Output**: - Returns the sum of all prime numbers between `L` and `R`, inclusive. 2. `count_primes_in_range(L, R)`: - **Input**: - `L` (int): The lower bound of the range. (L >= 0) - `R` (int): The upper bound of the range. (R >= L) - **Output**: - Returns the count of prime numbers between `L` and `R`, inclusive. **Constraints**: - `0 <= L <= R <= 10^7` **Requirements**: - Ensure the implementation is optimized for large values of `L` and `R`. - Use the Sieve of Eratosthenes to find prime numbers efficiently. - Handle edge cases such as ranges starting from `0` or `1`. **Performance**: - Your solution should be optimal and efficient for the given constraints. **Example**: ```python >>> sum_of_primes_in_range(10, 20) 60 >>> count_primes_in_range(10, 20) 4 >>> sum_of_primes_in_range(1, 10) 17 >>> count_primes_in_range(1, 10) 4 ``` **Description**: 1. Implement the function `sum_of_primes_in_range` to compute the total sum of prime numbers within the range [L, R]. 2. Implement the function `count_primes_in_range` to count the number of prime numbers within the range [L, R]. **Notes**: - Consider reusing the prime-checking logic wherever applicable. - Optimize using a sieve technique to handle large range inputs efficiently.","solution":"def sieve(n): Helper function to generate a list of primes up to n using the Sieve of Eratosthenes is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers p = 2 while (p * p <= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(n + 1) if is_prime[p]] return primes def sum_of_primes_in_range(L: int, R: int) -> int: primes = sieve(R) return sum(p for p in primes if L <= p <= R) def count_primes_in_range(L: int, R: int) -> int: primes = sieve(R) return len([p for p in primes if L <= p <= R])"},{"question":"# Scenario As a backend developer at a financial tech company, you are tasked with implementing a module that facilitates operations on time-series data. This module will be used for various financial computations including averages, moving averages, and other statistical measures. Your solutions must be efficient to handle large datasets commonly found in the financial industry. # Task Implement the following time-series operations: 1. `simple_moving_average(data, window_size)`: Computes the simple moving average (SMA) for a given list of data points and specified window size. 2. `exponential_moving_average(data, window_size)`: Computes the exponential moving average (EMA) for a given list of data points and specified window size. 3. `cumulative_sum(data)`: Returns the cumulative sum of the data points in the given list. 4. `max_drawdown(data)`: Calculates the maximum drawdown of the data points, representing the largest peak-to-trough decline over the period. 5. `standard_deviation(data)`: Computes the standard deviation of the given list of data points. # Specifications - **Input**: - `simple_moving_average`, `exponential_moving_average`: A list of floats `data` and an integer `window_size`. - `cumulative_sum`, `max_drawdown`, `standard_deviation`: A list of floats `data`. - **Output**: - The result should be a list of floats for `simple_moving_average`, `exponential_moving_average`, `cumulative_sum`, and a single float for `max_drawdown` and `standard_deviation` functions. - For invalid input cases (e.g., empty list or non-positive `window_size`), raise appropriate exceptions such as `ValueError`. # Example Implementations ```python def simple_moving_average(data, window_size): # Implement simple moving average logic pass def exponential_moving_average(data, window_size): # Implement exponential moving average logic pass def cumulative_sum(data): # Implement cumulative sum logic pass def max_drawdown(data): # Implement max drawdown logic pass def standard_deviation(data): # Implement standard deviation logic pass ``` # Constraints - Ensure that your solutions are efficient and follow best practices, especially for large datasets. - Handle edge cases, such as empty data lists or inadequate window sizes, by raising appropriate exceptions. - Optimally manage computational complexity for time-series computations. # Performance Requirements - The time complexity should be kept as low as feasible, particularly for operations such as moving averages and cumulative sum, which may need to handle thousands or even millions of data points efficiently. - Your code will undergo performance tests to ensure it can manage sizeable time-series datasets within acceptable time limits.","solution":"def simple_moving_average(data, window_size): Computes the Simple Moving Average (SMA) for a given list of data points and specified window size. if not data or window_size <= 0 or window_size > len(data): raise ValueError(\\"Invalid data or window size\\") sma = [] window_sum = sum(data[:window_size]) sma.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] sma.append(window_sum / window_size) return sma def exponential_moving_average(data, window_size): Computes the Exponential Moving Average (EMA) for a given list of data points and specified window size. if not data or window_size <= 0 or window_size > len(data): raise ValueError(\\"Invalid data or window size\\") alpha = 2 / (window_size + 1) ema = [data[0]] # EMA starts with the first data point for i in range(1, len(data)): ema.append(alpha * data[i] + (1 - alpha) * ema[-1]) return ema def cumulative_sum(data): Returns the cumulative sum of the data points in the given list. if not data: raise ValueError(\\"Data list cannot be empty\\") cum_sum = [data[0]] for i in range(1, len(data)): cum_sum.append(cum_sum[-1] + data[i]) return cum_sum def max_drawdown(data): Calculates the maximum drawdown of the data points, representing the largest peak-to-trough decline over the period. if not data: raise ValueError(\\"Data list cannot be empty\\") max_peak = data[0] max_drawdown = 0 for value in data: if value > max_peak: max_peak = value drawdown = (max_peak - value) / max_peak if drawdown > max_drawdown: max_drawdown = drawdown return max_drawdown def standard_deviation(data): Computes the standard deviation of the given list of data points. if not data: raise ValueError(\\"Data list cannot be empty\\") mean = sum(data) / len(data) variance = sum((x - mean) ** 2 for x in data) / len(data) return variance ** 0.5"},{"question":"# Scenario You are a developer for a company that works with huge datasets stored in CSV files. One of your tasks is to clean and preprocess these datasets before they are fed into a data analysis pipeline. You need to implement a function that reads a CSV file, processes the data by removing rows with missing values, and transforms it into a dictionary where each key is a column name and the value is a list of values for that column. Additionally, you need to ensure that the strings representing numbers are converted to their appropriate numeric types (integers or floats). # Problem Statement Implement the function `process_csv(file_path: str) -> dict` to process the CSV data as described. Input: * `file_path`: A string representing the path to the CSV file. Output: * A dictionary where each key is a column name and the value is a list of values for that column. Rows with any missing values should be excluded, and numeric strings should be converted to their appropriate numeric types. Constraints: * The CSV files can be large, with up to 100,000 rows and 50 columns. * The first row in the CSV file is the header row. * Missing values are represented by empty strings. * Assume all data in the CSV can be either strings representing numeric values or non-numeric strings. Example: Consider a file `example.csv` with the following content: ``` id,name,age,salary 1,Alice,30,100000 2,Bob,,80000 3,Charlie,25, 4,David,40,120000 ``` ```python file_path = \'example.csv\' print(process_csv(file_path)) # Output: {\'id\': [1, 3, 4], \'name\': [\'Alice\', \'Charlie\', \'David\'], \'age\': [30, 25, 40], \'salary\': [100000, None, 120000]} ``` Rows with missing values should be excluded; hence, row 2 and row 3 are omitted in the processed data. # Notes: - Focus on efficiency, especially with large CSV files. - Ensure that the function correctly handles different numeric formats (e.g., \'42\', \'42.5\'). - Use standard CSV reading libraries available in Python.","solution":"import csv def convert_to_numeric(value): try: int_value = int(value) return int_value except ValueError: try: float_value = float(value) return float_value except ValueError: return value def process_csv(file_path: str) -> dict: result = {} with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) headers = reader.fieldnames # Initialize the result dictionary with empty lists for header in headers: result[header] = [] for row in reader: if any(value == \'\' for value in row.values()): # Skip rows with any missing value continue for header in headers: converted_value = convert_to_numeric(row[header]) result[header].append(converted_value) return result"},{"question":"# Question: Longest Consecutive Subsequence with Validation You are given a function `longest_consecutive_subsequence` that finds the length of the longest consecutive elements sequence in a given list of integers. The current implementation may not handle cases where non-integer elements are present, and lacks input validation to ensure all elements are integers. Your task is to re-implement the `longest_consecutive_subsequence` function to: 1. Find the length of the longest sequence of consecutive integers. 2. Validate that all elements in the `data` list are integers. 3. Return an appropriate error message if invalid data is encountered. # Function Signature ```python def longest_consecutive_subsequence(data: list[int]) -> int | str: pass ``` # Input * `data`: A list of integer data points. # Output * The length of the longest consecutive integers sequence. * Return an error message if the input list contains non-integer values. # Constraints * `1 <= len(data) <= 10^6` # Example ```python >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([100, 4, 200, 1, \'a\', 2]) \'Error: Data must contain only integer values\' >>> longest_consecutive_subsequence([]) 0 ``` # Explanation - For the first example, the longest consecutive elements sequence is [1, 2, 3, 4], so the output is 4. - For the second example, since the element \'a\' is not an integer, an error message is returned. - For the third example, the input list is empty, thus the longest consecutive subsequence length is 0.","solution":"def longest_consecutive_subsequence(data): Finds the length of the longest consecutive elements sequence in the given list of integers. Validates that all elements are integers, and returns an appropriate error message if invalid data is encountered. if not all(isinstance(x, int) for x in data): return \'Error: Data must contain only integer values\' if not data: return 0 num_set = set(data) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Subsequence Check Implementation Problem Statement Write a function `is_subsequence` that takes two strings, `sub` and `main`, and returns `True` if `sub` is a subsequence of `main`, and `False` otherwise. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. Constraints 1. Both inputs `sub` and `main` will be non-empty strings containing only lowercase alphabetic characters. 2. Ensure the function efficiently checks the subsequence condition even for relatively long strings. Input * Two strings `sub` and `main`. Example: \\"abc\\", \\"ahbgdc\\", etc. Output * Returns `True` if `sub` is a subsequence of `main`. * Returns `False` otherwise. Example ```python is_subsequence(\\"abc\\", \\"ahbgdc\\") # Returns: True is_subsequence(\\"axc\\", \\"ahbgdc\\") # Returns: False is_subsequence(\\"ace\\", \\"abcde\\") # Returns: True is_subsequence(\\"aec\\", \\"abcde\\") # Returns: False is_subsequence(\\"a\\", \\"a\\") # Returns: True is_subsequence(\\"a\\", \\"b\\") # Returns: False ``` Note * Pay attention to the order of characters in the `sub` string relative to the `main` string. * Consider edge cases such as when `sub` is longer than `main`, or they have no common characters. * Optimize the function to handle scenarios where the strings might be significantly long.","solution":"def is_subsequence(sub, main): Returns True if \'sub\' is a subsequence of \'main\'. Otherwise, returns False. sub_index = 0 sub_length = len(sub) for char in main: if sub_index < sub_length and char == sub[sub_index]: sub_index += 1 return sub_index == sub_length"},{"question":"**[Question 2]: # Binary Tree Depth Calculation** You are tasked with creating a function that calculates the maximum depth of a binary tree. The function should take the root of a binary tree as its parameter and return the maximum depth of the tree. A binary tree\'s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Here\'s the structure of a binary tree node: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the function with the following signature: ```python def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree rooted at \'root\'. ``` Input: - root (TreeNode): The root node of the binary tree. Output: - int: The maximum depth of the binary tree. Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - -100 <= Node.val <= 100 Example: Given the binary tree: ``` 3 / 9 20 / 15 7 ``` The maximum depth of the tree is 3. ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(max_depth(root)) # Output: 3 ``` Use the following code snippet to get you started and improve it according to the instructions: ```python def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree rooted at \'root\'. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 ``` Make sure to test your function for various scenarios and edge cases, such as: - An empty tree - A tree with only one node - A balanced tree - An unbalanced tree Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree rooted at \'root\'. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Coding Assessment Question Context and Scenario: You are working on a customer management system in which customer records are stored based on their unique IDs. Each customer record can have multiple attributes such as name, email, and address. You need to implement functionality that allows you to retrieve a list of customers whose ID falls within a specific range. Task: 1. **Function 1: Range Query** Write a function `range_query(customers, start_id, end_id)` that returns a list of customers whose IDs are within the range `[start_id, end_id]` (inclusive). The `customers` list is sorted in ascending order based on the customer IDs. ```python def range_query(customers: list[dict], start_id: int, end_id: int) -> list[dict]: Retrieve a list of customers whose IDs are within the specified range. :param customers: A list of dictionaries, where each dictionary represents a customer and contains \'id\' as one key among other attributes. :param start_id: The start of the ID range (inclusive). :param end_id: The end of the ID range (inclusive). :return: A list of customers whose IDs fall within the specified range. pass ``` **Example:** ```python customers = [ {\'id\': 1, \'name\': \'Alice\', \'email\': \'alice@example.com\', \'address\': \'123 Main St\'}, {\'id\': 3, \'name\': \'Bob\', \'email\': \'bob@example.com\', \'address\': \'456 Oak St\'}, {\'id\': 4, \'name\': \'Charlie\', \'email\': \'charlie@example.com\', \'address\': \'789 Pine St\'}, {\'id\': 6, \'name\': \'Diana\', \'email\': \'diana@example.com\', \'address\': \'101 Maple St\'} ] result = range_query(customers, 2, 5) print(result) # Output: [ # {\'id\': 3, \'name\': \'Bob\', \'email\': \'bob@example.com\', \'address\': \'456 Oak St\'}, # {\'id\': 4, \'name\': \'Charlie\', \'email\': \'charlie@example.com\', \'address\': \'789 Pine St\'} # ] ``` 2. **Function 2: Binary Search for IDs** Write a function `binary_search_customers(customers, customer_id)` that returns the index of the customer with the given `customer_id` in the sorted list of `customers`. If the customer is not found, return -1. ```python def binary_search_customers(customers: list[dict], customer_id: int) -> int: Search for a customer by their ID using binary search. :param customers: A list of dictionaries, where each dictionary represents a customer and contains \'id\' as one key among other attributes. :param customer_id: The ID of the customer to search for. :return: The index of the customer if found, otherwise -1. pass ``` **Example:** ```python customers = [ {\'id\': 1, \'name\': \'Alice\', \'email\': \'alice@example.com\', \'address\': \'123 Main St\'}, {\'id\': 3, \'name\': \'Bob\', \'email\': \'bob@example.com\', \'address\': \'456 Oak St\'}, {\'id\': 4, \'name\': \'Charlie\', \'email\': \'charlie@example.com\', \'address\': \'789 Pine St\'}, {\'id\': 6, \'name\': \'Diana\', \'email\': \'diana@example.com\', \'address\': \'101 Maple St\'} ] index = binary_search_customers(customers, 4) print(index) # Output: 2 index = binary_search_customers(customers, 5) print(index) # Output: -1 ``` Constraints: - Each customer record is represented as a dictionary with an \'id\' key and other information. - The `customers` list is sorted based on the \'id\' key in ascending order. - Your implementation should use binary search for efficient querying on the sorted list. Performance Requirements: - Your solution should handle large data sets up to ( 10^6 ) elements efficiently. - Ensure that both the range query and the binary search operations run in logarithmic or better complexity when possible.","solution":"def range_query(customers, start_id, end_id): Retrieve a list of customers whose IDs are within the specified range. :param customers: A list of dictionaries, where each dictionary represents a customer and contains \'id\' as one key among other attributes. :param start_id: The start of the ID range (inclusive). :param end_id: The end of the ID range (inclusive). :return: A list of customers whose IDs fall within the specified range. return [customer for customer in customers if start_id <= customer[\'id\'] <= end_id] def binary_search_customers(customers, customer_id): Search for a customer by their ID using binary search. :param customers: A list of dictionaries, where each dictionary represents a customer and contains \'id\' as one key among other attributes. :param customer_id: The ID of the customer to search for. :return: The index of the customer if found, otherwise -1. low = 0 high = len(customers) - 1 while low <= high: mid = (low + high) // 2 mid_id = customers[mid][\'id\'] if mid_id == customer_id: return mid elif mid_id < customer_id: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Problem Statement You are required to implement a function that generates the n-th term of an arithmetic sequence, determine the position of a given term in that sequence, and verify if a sequence is arithmetic. # Task Implement the following functions: 1. `nth_term(a: int, d: int, n: int) -> int`: Returns the n-th term of an arithmetic sequence where `a` is the first term and `d` is the common difference. Raises `ValueError` if `n` is less than or equal to zero. 2. `term_position(a: int, d: int, term: int) -> int`: Returns the position of the given `term` in the arithmetic sequence starting with `a` and having common difference `d`. Raises `ValueError` if the term does not belong to the sequence. 3. `is_arithmetic(seq: list[int]) -> bool`: Determines if the given sequence is an arithmetic sequence. Returns `True` if it is an arithmetic sequence, and `False` otherwise. Raises `ValueError` if the input list is empty or has less than two elements. # Input and Output Formats - **Nth Term Function Input**: - `a`: An integer representing the first term of the sequence. - `d`: An integer representing the common difference of the sequence. - `n`: An integer representing the position of the term to be found (must be positive). - **Nth Term Function Output**: - Returns an integer representing the n-th term of the arithmetic sequence. - **Term Position Function Input**: - `a`: An integer representing the first term of the sequence. - `d`: An integer representing the common difference of the sequence. - `term`: An integer representing the term whose position is to be found in the sequence. - **Term Position Function Output**: - Returns an integer representing the position of the term in the arithmetic sequence. - **Is Arithmetic Function Input**: - `seq`: A list of integers representing the sequence to be checked. - **Is Arithmetic Function Output**: - Returns a boolean value indicating whether the input sequence is an arithmetic sequence. # Constraints - The integers `a`, `d`, `n`, and `term` can be positive or negative. - The input list `seq` will always contain integers. # Examples ```python nth_term(2, 3, 5) # Output: 14 term_position(2, 3, 14) # Output: 5 is_arithmetic([2, 5, 8, 11]) # Output: True is_arithmetic([1, 2, 4, 8]) # Output: False ``` # Notes Consider edge cases like: - Single-element edge case for `is_arithmetic`. - Invalid term position for non-members in `term_position`.","solution":"def nth_term(a, d, n): Returns the n-th term of an arithmetic sequence where `a` is the first term and `d` is the common difference. Raises ValueError if `n` is less than or equal to zero. if n <= 0: raise ValueError(\\"n must be greater than zero\\") return a + (n - 1) * d def term_position(a, d, term): Returns the position of the given `term` in the arithmetic sequence starting with `a` and having common difference `d`. Raises ValueError if the term does not belong to the sequence. if d == 0: raise ValueError(\\"common difference d must not be zero\\") pos = (term - a) / d + 1 if pos != int(pos) or pos <= 0: raise ValueError(\\"term does not belong to the arithmetic sequence\\") return int(pos) def is_arithmetic(seq): Determines if the given sequence is an arithmetic sequence. Returns True if it is an arithmetic sequence, and False otherwise. Raises ValueError if the input list is empty or has less than two elements. if len(seq) < 2: raise ValueError(\\"sequence must have at least two elements\\") d = seq[1] - seq[0] return all(seq[i+1] - seq[i] == d for i in range(len(seq) - 1))"},{"question":"# Problem Statement A geometric sequence is defined by its first term and a common ratio. However, for this problem, we will modify a typical geometric sequence to include the following rules: 1. The sequence must start with a given positive integer `a`. 2. The sequence must have a common ratio `r` that is also a positive integer. 3. Each subsequent element in the sequence will be the product of the previous element and the common ratio `r`. 4. The sequence continues to generate terms as long as the terms do not exceed a given limit `L`. Write a function `generate_geometric_sequence` that, given the first term `a`, the common ratio `r`, and the limit `L`, returns a list of integers representing the generated terms of the modified geometric sequence. # Function Signature ```python def generate_geometric_sequence(a: int, r: int, L: int) -> List[int]: ``` # Input and Output * **Input**: - `a` (1 <= a <= 1000): The first term in the geometric sequence. - `r` (1 <= r <= 100): The common ratio of the sequence. - `L` (a < L <= 10^9): The inclusive upper limit for the terms in the sequence. * **Output**: Return a list of integers that are the terms of the geometric sequence adhering to the above rules. # Example ```python assert generate_geometric_sequence(1, 2, 10) == [1, 2, 4, 8] assert generate_geometric_sequence(3, 5, 1000) == [3, 15, 75, 375] ``` # Explanation - For `generate_geometric_sequence(1, 2, 10)`: Starting with the first term `1`, the next term is `1 * 2 = 2`, then `2 * 2 = 4`, then `4 * 2 = 8`. The next term `8 * 2 = 16` exceeds the limit 10, so the sequence stops at `[1, 2, 4, 8]`. - For `generate_geometric_sequence(3, 5, 1000)`: Starting with the first term `3`, the next term is `3 * 5 = 15`, then `15 * 5 = 75`, then `75 * 5 = 375`. The next term `375 * 5 = 1875` exceeds the limit 1000, so the sequence stops at `[3, 15, 75, 375]`.","solution":"def generate_geometric_sequence(a: int, r: int, L: int) -> list: Generates the geometric sequence starting from \'a\' with a common ratio \'r\' up to a limit \'L\'. Args: a (int): The first term of the sequence. r (int): The common ratio of the sequence. L (int): The inclusive upper limit for the terms in the sequence. Returns: list: A list containing the terms of the geometric sequence. sequence = [] current_term = a while current_term <= L: sequence.append(current_term) current_term *= r return sequence"},{"question":"# Book Sale Pattern You are tasked with implementing a function that processes the purchase pattern in a bookshop during a sale event. The sale attracts many customers, and you need to identify the most frequently purchased book during this event. Function to Implement Implement a new method, `most_frequent_book()`, that takes a list of book titles representing purchases made and returns the title of the most frequently purchased book. If there are ties, return the lexicographically smallest title. Input - A list of strings, `purchases`, where each string represents the title of a purchased book. Output - A string representing the title of the most frequently purchased book. Constraints - `0 <= len(purchases) <= 10^5` - `1 <= len(purchases[i]) <= 100` for each title. - Book titles consist of only lowercase letters and spaces. Example ```python purchases = [\\"the great gatsby\\", \\"to kill a mockingbird\\", \\"the great gatsby\\", \\"1984\\", \\"the great gatsby\\", \\"1984\\", \\"to kill a mockingbird\\"] # The most frequent book is \\"the great gatsby\\" result = most_frequent_book(purchases) print(result) # Output: \\"the great gatsby\\" purchases = [\\"a tale of two cities\\", \\"a brief history of time\\", \\"a brief history of time\\", \\"a tale of two cities\\", \\"invisible man\\"] # The most frequent books are \\"a brief history of time\\" and \\"a tale of two cities\\", lexicographically smallest is \\"a brief history of time\\" result = most_frequent_book(purchases) print(result) # Output: \\"a brief history of time\\" ``` Note - Ensure the function handles edge cases like an empty list appropriately, returning an empty string in such cases. - Optimize for efficiency to handle the upper limits of the input constraints. Implement the function in Python and illustrate with the provided examples.","solution":"def most_frequent_book(purchases): Returns the title of the most frequently purchased book. In case of a tie, returns the lexicographically smallest title. :param purchases: A list of strings representing book titles. :return: A string representing the title of the most frequently purchased book. from collections import Counter if not purchases: return \\"\\" purchase_count = Counter(purchases) most_frequent_title = min(purchase_count, key=lambda title: (-purchase_count[title], title)) return most_frequent_title"},{"question":"# Question: Implement Custom Matrix Operations Context: Matrices are a fundamental data structure in many areas of computer science and mathematics, including machine learning, graphics, and scientific computing. In this task, you will implement a few custom matrix operations beyond simple arithmetic to solve specific problems more efficiently. Task: Enhance the provided `CustomMatrix` class by implementing additional matrix operations suited to advanced applications. Requirements: 1. **Determinant Calculation**: Implement a method `determinant() -> float` that returns the determinant of the matrix. - The determinant is a key value that can tell whether the matrix is invertible, among other properties. 2. **Eigenvalues Calculation**: Implement a method `eigenvalues() -> List[float]` that returns the eigenvalues of a square matrix. - Eigenvalues are critical in various applications like stability analysis, vibrations, and systems of differential equations. 3. **Inverse Calculation**: Implement a method `inverse() -> CustomMatrix` that returns the inverse of the matrix if it is invertible. - If the matrix is not invertible, raise an appropriate error. Implementations: - Update the `CustomMatrix` class to include your new methods. - Add doctests or unit tests to validate the functionality of the new methods. - Ensure the existing functionality and new functionality do not interfere. Constraints: - The matrix must be square (NxN) for `determinant`, `eigenvalues`, and `inverse` methods. - Each method should handle edge cases properly (e.g., non-invertible matrices for `inverse()`). Here is the starter skeleton for your updated class: ```python import numpy as np from typing import List class CustomMatrix: def __init__(self, data: List[List[float]]): self.data = np.array(data) assert self.data.shape[0] == self.data.shape[1], \\"Matrix must be square\\" def determinant(self) -> float: Calculate and return the determinant of the matrix. Returns: The determinant of the matrix. Example: >>> matrix = CustomMatrix([[1, 2], [3, 4]]) >>> matrix.determinant() -2.0 return float(np.linalg.det(self.data)) def eigenvalues(self) -> List[float]: Calculate and return the eigenvalues of the matrix. Returns: A list of eigenvalues. Example: >>> matrix = CustomMatrix([[1, 2], [3, 4]]) >>> matrix.eigenvalues() [-0.3722813232690143, 5.372281323269014] return list(np.linalg.eigvals(self.data)) def inverse(self) -> CustomMatrix: Calculate and return the inverse of the matrix. Returns: A new CustomMatrix object representing the inverse matrix. Raises: ValueError: If the matrix is not invertible. Example: >>> matrix = CustomMatrix([[1, 2], [3, 4]]) >>> matrix.inverse().data.tolist() [[-2.0, 1.0], [1.5, -0.5]] try: inv_data = np.linalg.inv(self.data) return CustomMatrix(inv_data.tolist()) except np.linalg.LinAlgError: raise ValueError(\\"Matrix is not invertible\\") # Example usage and tests if __name__ == \\"__main__\\": matrix = CustomMatrix([[1, 2], [3, 4]]) print(matrix.determinant()) # Should print -2.0 print(matrix.eigenvalues()) # Should print eigenvalues e.g., [-0.372281, 5.372281] print(matrix.inverse().data) # Should print the inverse matrix [[-2.0, 1.0], [1.5, -0.5]] ``` Input and Output Format: - The input format for the `CustomMatrix` constructor is a list of lists representing the matrix data. - The `determinant` method returns a float. - The `eigenvalues` method returns a list of floats. - The `inverse` method returns a new `CustomMatrix` object. Constraints: - Your solution should maintain the computational efficiency of the matrix operations. - The extended functionalities should be demonstrable with appropriate unit tests or doctests. Good luck!","solution":"import numpy as np from typing import List class CustomMatrix: def __init__(self, data: List[List[float]]): self.data = np.array(data) assert self.data.shape[0] == self.data.shape[1], \\"Matrix must be square\\" def determinant(self) -> float: Calculate and return the determinant of the matrix. Returns: The determinant of the matrix. Example: >>> matrix = CustomMatrix([[1, 2], [3, 4]]) >>> matrix.determinant() -2.0 return float(np.linalg.det(self.data)) def eigenvalues(self) -> List[float]: Calculate and return the eigenvalues of the matrix. Returns: A list of eigenvalues. Example: >>> matrix = CustomMatrix([[1, 2], [3, 4]]) >>> matrix.eigenvalues() [-0.3722813232690143, 5.372281323269014] return list(np.linalg.eigvals(self.data)) def inverse(self) -> \'CustomMatrix\': Calculate and return the inverse of the matrix. Returns: A new CustomMatrix object representing the inverse matrix. Raises: ValueError: If the matrix is not invertible. Example: >>> matrix = CustomMatrix([[1, 2], [3, 4]]) >>> matrix.inverse().data.tolist() [[-2.0, 1.0], [1.5, -0.5]] try: inv_data = np.linalg.inv(self.data) return CustomMatrix(inv_data.tolist()) except np.linalg.LinAlgError: raise ValueError(\\"Matrix is not invertible\\") # Example usage and tests if __name__ == \\"__main__\\": matrix = CustomMatrix([[1, 2], [3, 4]]) print(matrix.determinant()) # Should print -2.0 print(matrix.eigenvalues()) # Should print eigenvalues e.g., [-0.372281, 5.372281] print(matrix.inverse().data) # Should print the inverse matrix [[-2.0, 1.0], [1.5, -0.5]]"},{"question":"# String Manipulation and Pattern Matching You are tasked with implementing a function that performs basic string manipulation and pattern matching to identify substrings that match a given pattern. The pattern should support two special characters: - `.` (dot) which matches any single character. - `*` (asterisk) which matches zero or more of the preceding character. Tasks: Implement the following function: ```python def is_match(text: str, pattern: str) -> bool: Function to determine if the given text matches the pattern. Parameters: - text (str): The input string to be matched. - pattern (str): The pattern string which can contain the special characters \'.\' and \'*\'. Returns: - bool: True if the text matches the pattern, False otherwise. ``` Constraints: - The input text will have a maximum length of 1000 characters. - The pattern will have a maximum length of 1000 characters. - Both text and pattern will only contain lowercase alphabetic characters and the special characters `.` and `*`. Expected Input and Output Format: - **Input**: Call the function `is_match(text, pattern)`. - **Output**: Return `True` or `False` based on whether the text matches the pattern. Example: ```python # Test case 1 text = \\"aa\\" pattern = \\"a\\" print(is_match(text, pattern)) # Output: False # Test case 2 text = \\"aa\\" pattern = \\"a*\\" print(is_match(text, pattern)) # Output: True # Test case 3 text = \\"ab\\" pattern = \\".*\\" print(is_match(text, pattern)) # Output: True # Test case 4 text = \\"aab\\" pattern = \\"c*a*b\\" print(is_match(text, pattern)) # Output: True # Test case 5 text = \\"mississippi\\" pattern = \\"mis*is*p*.\\" print(is_match(text, pattern)) # Output: False ``` Implement the function such that it handles all edge cases appropriately, based on the constraints.","solution":"def is_match(text: str, pattern: str) -> bool: Function to determine if the given text matches the pattern. Parameters: - text (str): The input string to be matched. - pattern (str): The pattern string which can contain the special characters \'.\' and \'*\'. Returns: - bool: True if the text matches the pattern, False otherwise. # If the pattern is empty, text must be empty to be a match. if not pattern: return not text # Check if the first character of text matches the first character of pattern (or if it\'s a dot). first_match = bool(text) and pattern[0] in {text[0], \'.\'} # If the pattern contains \\"*\\", it can match zero or more of the preceding character. if len(pattern) >= 2 and pattern[1] == \'*\': return (is_match(text, pattern[2:]) or (first_match and is_match(text[1:], pattern))) else: # If there\'s no \\"*\\", we simply move to the next character in both text and pattern. return first_match and is_match(text[1:], pattern[1:])"},{"question":"# Sentiment Analysis on Product Reviews You are tasked with analyzing the sentiment of customer product reviews using Natural Language Processing (NLP) techniques. Sentiment Analysis can help in determining whether a review reflects a positive, negative, or neutral sentiment. # Problem Statement Given a dataset `reviews.csv` containing product reviews, write a Python function `perform_sentiment_analysis` that: 1. Loads and preprocesses the data. 2. Trains a sentiment analysis model based on the text review. 3. Outputs the predicted sentiment for each review in the dataset. The dataset is a CSV file with two columns: `review_id` (a unique identifier for each review) and `review_text` (the text of the review). You should: - Use the `CountVectorizer` or `TfidfVectorizer` for text preprocessing and vectorization. - Split the data into training and testing sets. - Train a classifier (e.g., Logistic Regression, Naive Bayes) to predict the sentiment. - Return the DataFrame with the original `review_id` and an additional column for the predicted sentiment. # Function Signature ```python def perform_sentiment_analysis(file_path: str) -> pd.DataFrame: Performs sentiment analysis on product reviews. Args: - file_path (str): Path to the CSV file containing product reviews. Returns: - pd.DataFrame: DataFrame with \'review_id\' and predicted sentiments. pass ``` # Input - `file_path` : A string representing the path to the CSV file with product reviews. # Output - A DataFrame with the original `review_id` and an additional column `predicted_sentiment` containing the predicted sentiment (e.g., \'positive\', \'negative\', \'neutral\'). # Constraints - The CSV file has no missing values. - The dataset contains at least 1000 reviews. - The number of reviews per sentiment class is balanced. # Example Usage ```python # Example usage: review_sentiments = perform_sentiment_analysis(\\"reviews.csv\\") print(review_sentiments.head()) ``` Implement the function `perform_sentiment_analysis` to solve the given problem. Make sure to handle text cleaning, vectorization, and model training properly within the function.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.pipeline import make_pipeline from sklearn.metrics import accuracy_score def perform_sentiment_analysis(file_path: str) -> pd.DataFrame: # Load the data df = pd.read_csv(file_path) # Assuming the dataset also has a \'sentiment\' column for training purposes # Pre-processing and vectorization X = df[\'review_text\'] y = df[\'sentiment\'] # pretend we already have labelled sentiments for training # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create a pipeline with tf-idf vectorizer and logistic regression classifier pipeline = make_pipeline(TfidfVectorizer(), LogisticRegression(max_iter=1000)) # Train the model pipeline.fit(X_train, y_train) # Predict sentiment on the test set y_pred = pipeline.predict(X_test) # Measure accuracy accuracy = accuracy_score(y_test, y_pred) print(f\'Accuracy: {accuracy}\') # Now we predict on the whole dataset to get the sentiment predictions df[\'predicted_sentiment\'] = pipeline.predict(df[\'review_text\']) # Return the dataframe with review_id and predicted sentiment return df[[\'review_id\', \'predicted_sentiment\']]"},{"question":"# Question: Implement a Function to Determine Whether a Binary Tree is Balanced You have been tasked with writing a program to determine whether a binary tree is balanced. A balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Function Signature `def is_balanced(root: Optional[TreeNode]) -> bool` Class Definition ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Requirements * You need to implement the `is_balanced` function to return a boolean value indicating whether the tree is balanced. * The tree nodes are instances of the `TreeNode` class. * An empty tree is considered balanced. Input * `root`: The root node of the binary tree (may be `None`). Output * Return `True` if the binary tree is balanced, otherwise return `False`. Constraints * The number of nodes in the tree is in the range `[0, 5000]`. * The value of each node is in the range `[-10^4, 10^4]`. Examples ```python # Example 1 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert is_balanced(root) == True # Example 2 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert is_balanced(root) == False # Example 3 assert is_balanced(None) == True # An empty tree is considered balanced ``` Constraints & Limitations * The function should have a time complexity of O(n), where n is the number of nodes in the tree. * Space complexity should be O(h) due to the recursion stack, where h is the height of the tree. * Ensure the implementation handles various edge cases, including an empty tree and single-node trees.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = 1 + max(left_height, right_height) return height, balanced _, result = check(root) return result"},{"question":"# Matrix Operations and Diagonal Calculation You are tasked with implementing two functions to perform matrix operations. Specifically, you need to create one function that multiplies two matrices and another function that computes the sums of the main and secondary diagonals of a square matrix. Requirements 1. **`multiply_matrices` function**: * **Input**: Two 2D lists `matrix_a` and `matrix_b` representing matrices with compatible dimensions for multiplication. * **Output**: A 2D list representing the resulting matrix from the multiplication. * **Function Signature**: ```python def multiply_matrices(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]]: ``` 2. **`calculate_diagonal_sums` function**: * **Input**: A 2D list `matrix` representing a square matrix. * **Output**: A tuple containing the sum of the main diagonal and the sum of the secondary diagonal. * **Function Signature**: ```python def calculate_diagonal_sums(matrix: list[list[float]]) -> tuple[float, float]: ``` Constraints * Input values must be numeric (either `float` or `int`). * The matrices should be non-empty and have appropriate dimensions. Example ```python # Example usage of multiply_matrices matrix_a = [[1, 2], [3, 4]] matrix_b = [[2, 0], [1, 2]] result = multiply_matrices(matrix_a, matrix_b) print(result) # Output: [[4, 4], [10, 8]] # Example usage of calculate_diagonal_sums matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] sums = calculate_diagonal_sums(matrix) print(sums) # Output: (15, 15) ``` Notes * Ensure that your implementation raises appropriate exceptions for invalid input dimensions. * Use proper matrix multiplication logic, addressing edge cases like empty matrices or non-numeric inputs. Good luck, and happy coding!","solution":"def multiply_matrices(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]]: Multiplies two matrices and returns the resulting matrix. # Validate dimensions if len(matrix_a) == 0 or len(matrix_b) == 0 or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Incompatible matrices for multiplication.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result def calculate_diagonal_sums(matrix: list[list[float]]) -> tuple[float, float]: Computes the sum of the main and secondary diagonals of a square matrix. if len(matrix) == 0 or len(matrix) != len(matrix[0]): raise ValueError(\\"Matrix must be square and non-empty.\\") main_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(len(matrix)): main_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][len(matrix) - 1 - i] return main_diagonal_sum, secondary_diagonal_sum"},{"question":"# Problem: Polynomial Derivative Calculator You are given a polynomial represented by its coefficients in a list, where each index corresponds to the power of the variable. For example, the list [4, 0, -3, 5] represents the polynomial ( 4 + 0x - 3x^2 + 5x^3 ). Your task is to compute the derivative of this polynomial. The derivative of a polynomial ( a_n x^n + a_{n-1} x^{n-1} + ... + a_1 x + a_0 ) is given by ( n a_n x^{n-1} + (n-1) a_{n-1} x^{n-2} + ... + a_1 ). Write a function `polynomial_derivative` that takes in a list of coefficients and returns the coefficients of the derivative polynomial. Function Signature ```python def polynomial_derivative(coefficients: list) -> list: ``` Input * **coefficients**: A list of integers or floats representing the coefficients of the polynomial, where the i-th element corresponds to the coefficient of ( x^i ). Output * **returns**: A list of integers or floats representing the coefficients of the derivative polynomial, where the i-th element corresponds to the coefficient of ( x^i ). Constraints * The input list will have at least one element. * If the input list has only one element (constant polynomial), the derivative is zero, and an empty list should be returned. Examples ```python >>> polynomial_derivative([4, 0, -3, 5]) [0, -6, 15] >>> polynomial_derivative([1, 2, 3]) [2, 6] >>> polynomial_derivative([10]) [] >>> polynomial_derivative([5, -4]) [-4] ```","solution":"def polynomial_derivative(coefficients: list) -> list: Computes the derivative of a polynomial represented by its coefficients. Parameters: - coefficients (list): A list of integers or floats representing the coefficients of the polynomial. Returns: - list: A list of integers or floats representing the coefficients of the derivative polynomial. if len(coefficients) <= 1: return [] derivative_coeffs = [] for i in range(1, len(coefficients)): derivative_coeffs.append(i * coefficients[i]) return derivative_coeffs"},{"question":"# Coding Assessment Question Implement a function that converts a given Roman numeral string to its corresponding integer value. This problem tests your understanding of string manipulation and the specific rules governing the Roman numeral system. **Function Signature:** ```python def roman_to_integer(roman: str) -> int: Converts a Roman numeral string to its equivalent integer value. :param roman: A string representing the Roman numeral. :return: The corresponding integer value of the Roman numeral. ``` **Input:** - `roman`: A non-empty string containing a valid Roman numeral (e.g., \\"XIV\\", \\"MCMXCIV\\"). **Output:** - Returns the integer value corresponding to the Roman numeral. **Constraints:** - The input string will always be a valid Roman numeral from 1 to 3999. - The Roman numerals are limited to the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. **Requirements:** - The function should accurately handle the subtractive combination rule (e.g., IV for 4, IX for 9). - Optimize for readability and efficiency. **Example:** ```python >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"V\\") 5 ``` **Notes:** - Valid symbolic combinations must be taken into account (e.g., \\"IX\\" is 9 while \\"XI\\" is 11). - Ensure your code considers and processes each character and transition efficiently. - The solution should adhere to the linear O(n) time complexity where n is the length of the Roman numeral string.","solution":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral string to its equivalent integer value. :param roman: A string representing the Roman numeral. :return: The corresponding integer value of the Roman numeral. # Map of roman characters to their integer values roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 # Traverse the string in reverse order for char in reversed(roman): current_value = roman_to_int[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"# Graph Cycle Detection using Depth-First Search You are to implement a function that detects cycles in a directed graph using Depth-First Search (DFS). Cycle detection is a common problem in environments such as dependency resolution, scheduling, and verification of models. Task 1: Graph Representation Write a function, `add_edge(graph: dict[int, list[int]], u: int, v: int) -> None`, that adds a directed edge from vertex `u` to vertex `v` in the graph. The graph is represented as an adjacency list. Task 2: Cycle Detection Implement a function, `is_cyclic(graph: dict[int, list[int]]) -> bool`, that checks whether the directed graph contains a cycle. Input: 1. A dictionary representing the graph `graph` with keys as vertices and values as lists of vertices those keys have directed edges to. Output: 1. Return `True` if there is a cycle in the graph. Otherwise, return `False`. Example: ```python # Example graph graph = {} add_edge(graph, 0, 1) add_edge(graph, 0, 2) add_edge(graph, 1, 2) add_edge(graph, 2, 0) add_edge(graph, 2, 3) add_edge(graph, 3, 3) # Detect cycle in the graph has_cycle = is_cyclic(graph) # Output: True ``` Constraints: - The number of vertices `V` and the number of edges `E` will be such that `1 ≤ V, E ≤ 1000`. Performance Requirements: - Aim for a time complexity of `O(V + E)` for cycle detection using DFS. Notes: - The `add_edge` function is used to build the graph. - Carefully handle the cases where there are self-loops or multiple edges between vertices. This problem will test your understanding of graph representations and your ability to implement algorithms for cycle detection in graphs.","solution":"def add_edge(graph, u, v): Adds a directed edge from vertex u to vertex v in the graph. Parameters: graph (dict[int, list[int]]): The graph represented as an adjacency list. u (int): The start vertex. v (int): The end vertex. if u not in graph: graph[u] = [] graph[u].append(v) def is_cyclic_util(v, visited, rec_stack, graph): Utility function for cycle detection using DFS. Parameters: v (int): The current vertex. visited (set[int]): Set of visited vertices. rec_stack (set[int]): Recursion stack to track the current path (to detect cycle). graph (dict[int, list[int]]): The graph represented as an adjacency list. Returns: bool: True if a cycle is found, otherwise False. visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if is_cyclic_util(neighbor, visited, rec_stack, graph): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False def is_cyclic(graph): Checks whether the directed graph contains a cycle. Parameters: graph (dict[int, list[int]]): The graph represented as an adjacency list. Returns: bool: True if there is a cycle in the graph, otherwise False. visited = set() rec_stack = set() for node in graph: if node not in visited: if is_cyclic_util(node, visited, rec_stack, graph): return True return False"},{"question":"# Question In computer science, the hailstone sequence (also known as the Collatz sequence) is an integer sequence defined as follows: - Start with any positive integer ( n ). - Then each term is obtained from the previous term as follows: - If the previous term is even, the next term is one half of the previous term. - If the previous term is odd, the next term is 3 times the previous term plus 1. - The sequence ends when it reaches the number 1. Write a function to determine the length of the hailstone sequence for a given starting number. 1. **Function Name**: `hailstone_length(n: int) -> int` - **Input**: A single integer ( n ) where ( n > 0 ). - **Output**: The number of terms in the hailstone sequence starting with ( n ) and ending with 1 (inclusive). - **Constraints**: The function should handle ( 1 leq n leq 10^6 ) efficiently. - **Error Handling**: Raise an appropriate error if the input is not an integer or is not positive. # Example ```python >>> hailstone_length(1) 1 >>> hailstone_length(7) 17 >>> hailstone_length(27) 112 >>> hailstone_length(1000000) 153 >>> hailstone_length(\\"hello\\") Traceback (most recent call last): ... TypeError: The input must be a positive integer. >>> hailstone_length(-42) Traceback (most recent call last): ... ValueError: The input must be a positive integer. ``` # Requirements * Implement the function efficiently to handle large inputs within reasonable time. * The function should be robust and handle improper inputs gracefully.","solution":"def hailstone_length(n: int) -> int: Returns the length of the hailstone sequence starting from n and ending with 1. Args: n (int): The starting integer of the sequence. Must be a positive integer. Returns: int: The length of the hailstone sequence. Raises: TypeError: If the input is not an integer. ValueError: If the input is not a positive integer. # Check if input is an integer if not isinstance(n, int): raise TypeError(\\"The input must be a positive integer.\\") # Check if input is positive if n <= 0: raise ValueError(\\"The input must be a positive integer.\\") length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"# String Permutation Checker **Description**: Write a function that checks if two given strings are permutations of each other. Two strings are permutations of each other if they contain the same characters with the same frequency, but possibly in a different order. **Objective**: Implement the function `are_permutations(s1: str, s2: str) -> bool` that: 1. Takes in two strings and returns `True` if they are permutations of each other, otherwise returns `False`. 2. Handles cases where the strings are of different lengths efficiently. 3. Considers edge cases like empty strings and strings with special characters. **Input**: * Two strings `s1` and `s2`. **Output**: * A boolean value indicating whether `s1` and `s2` are permutations of each other. **Constraints**: * The strings can contain any printable ASCII characters. * The lengths of the strings can be up to 1000 characters. **Performance Requirements**: * The solution should have an average time complexity of O(n), where n is the length of the strings, considering that counting characters can be done in linear time. * Aim to use O(1) additional space if character frequency can be managed within a fixed set of ASCII characters. # Implementation Complete the function `are_permutations(s1: str, s2: str) -> bool`: ```python def are_permutations(s1: str, s2: str) -> bool: if len(s1) != len(s2): return False char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True # Example usage: if __name__ == \\"__main__\\": s1 = \\"listen\\" s2 = \\"silent\\" result = are_permutations(s1, s2) print(f\\"Are \'{s1}\' and \'{s2}\' permutations of each other? {result}\\") s1 = \\"triangle\\" s2 = \\"integral\\" result = are_permutations(s1, s2) print(f\\"Are \'{s1}\' and \'{s2}\' permutations of each other? {result}\\") s1 = \\"apple\\" s2 = \\"pale\\" result = are_permutations(s1, s2) print(f\\"Are \'{s1}\' and \'{s2}\' permutations of each other? {result}\\") ``` Handle all edge cases and ensure the function performs efficiently even for maximum input sizes. Happy coding!","solution":"def are_permutations(s1: str, s2: str) -> bool: if len(s1) != len(s2): return False char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"Data Structures and Algorithms Question: Use of Binary Search Approach for Targeting Circularly Rotated Arrays Background A circularly rotated array is an array that has been rotated an arbitrary number of times in either direction. For example, the array `[1, 2, 3, 4, 5]` could be rotated to become `[4, 5, 1, 2, 3]`, or `[3, 4, 5, 1, 2]`. Given a circularly rotated array, one common operation is to find the index of a target value using an efficient search algorithm. Binary search is typically used for this purpose due to its logarithmic time complexity. # Task 1. **Find Target in Circular Array**: - Implement the function `find_in_rotated_array` to search for a target value in a circularly rotated array. - Utilize a modified binary search approach to locate the index of the target efficiently. Function Signature * `def find_in_rotated_array(arr: list[int], target: int) -> int` # Constraints * The `arr` will not be empty and will contain unique integers. * The `target` will always be an integer. * The function should return the index of the `target` if found, otherwise, return `-1`. * The function should have a time complexity of O(log n). # Examples ```python print(find_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0)) # -> 4 print(find_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3)) # -> -1 print(find_in_rotated_array([30, 40, 50, 10, 20], 10)) # -> 3 ``` # Notes * Ensure your implementation handles both the ascending and descending segments of the circular array. * Consider the edge cases where the target is at the start or end of the array. * Optimize the performance of the algorithm, avoiding unnecessary comparisons and ensuring the binary search is applied properly. * Provide clear and concise docstrings and comments in your code.","solution":"def find_in_rotated_array(arr: list[int], target: int) -> int: Finds the index of the target value in a circularly rotated sorted array. Parameters: - arr: A list of integers representing the circularly rotated array. - target: An integer representing the target value to be searched. Returns: - The index of the target value if found; otherwise, -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Check if left part is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Right part must be sorted else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Modular Arithmetic: GCD-Based Integer Sequence Given an integer sequence defined by the following rules, your task is to implement functions that compute elements of the sequence and validate properties based on the given criteria. The sequence ( a_i ) of integers is constructed such that: 1. ( a_1 ) is given as an initial value. 2. For ( i > 1 ), ( a_i ) is the Greatest Common Divisor (GCD) of ( a_{i-1} ) and the integer ( K ). You will implement a class `GCDSequence` that encapsulates the functionality of generating sequence values and validating integer properties for the sequence. # Class and Methods Specification: Class: ```python class GCDSequence: def __init__(self, a1: int, k: int): pass def find_element(self, i: int) -> int: pass def validate_element(self, element: int, required_gcd: int) -> bool: pass def sequence_properties(self) -> dict: pass ``` # Method Description: * `__init__(self, a1: int, k: int)`: Initialize the `GCDSequence` instance with an initial value `a1` and integer `k`. * `find_element(self, i: int) -> int`: Finds the ( i )-th element of the sequence by iterating from ( a_1 ) to ( a_i ) according to the GCD rules. Returns the ( i )-th element of the sequence. * `validate_element(self, element: int, required_gcd: int) -> bool`: Validates whether a given element of the sequence has the GCD with integer `k` equal to `required_gcd`. Returns `True` if valid, otherwise returns `False`. * `sequence_properties(self) -> dict`: Computes and returns a dictionary of properties for the given sequence, including: - The first 10 elements of the sequence. - The maximum element in the first 10 elements. # Constraints: - The initial value `a1` is a positive integer. - The integer `k` is a positive integer. - Function `gcd` from the Python `math` module may be used for GCD calculations. # Examples: ```python sequence = GCDSequence(20, 8) # Example for finding the 5th element: fifth_element = sequence.find_element(5) print(fifth_element) # Output should match the expected value # Example for validating an element: is_valid = sequence.validate_element(4, 4) print(is_valid) # Output should be True or False based on the check # Example for sequence properties: properties = sequence.sequence_properties() print(properties) # Output should include first 10 elements and the maximum element ``` Additional validation: 1. If `a1` or `k` is not a positive integer, throw a ValueError with the message: `\'Inputs must be positive integers.\'`. 2. Ensure sequence computations do not exceed reasonable time complexity.","solution":"import math class GCDSequence: def __init__(self, a1: int, k: int): if a1 <= 0 or k <= 0: raise ValueError(\'Inputs must be positive integers.\') self.a1 = a1 self.k = k def find_element(self, i: int) -> int: current = self.a1 for _ in range(1, i): current = math.gcd(current, self.k) return current def validate_element(self, element: int, required_gcd: int) -> bool: return math.gcd(element, self.k) == required_gcd def sequence_properties(self) -> dict: sequence = [] current = self.a1 for _ in range(10): sequence.append(current) current = math.gcd(current, self.k) return { \\"first_10_elements\\": sequence, \\"max_element\\": max(sequence) }"},{"question":"# Question: Customizable Calculator with Advanced Operations Context Develop a customizable calculator class that supports basic arithmetic operations and allows the user to define additional operations. Your solution should demonstrate the ability to work with higher-order functions and handling user-defined functions. Requirements 1. **Custom Calculator Class (`CustomCalculator`)**: - Should support initialization with basic arithmetic operations: addition, subtraction, multiplication, and division. - Must provide a method to add new user-defined custom operations. 2. **Performing Operations**: - Implement a method `perform_operation` that accepts an operation name and a list of operands to perform the requested operation. Implementation Details - **Input Format**: - Default operations are integrated into the calculator during initialization. - Additional operations can be added using functions defined by the user. - `perform_operation` takes the operation name (a string) and the list of operands (a list of numbers). - **Output Format**: - Result of the performed operation. - **Constraints**: - Your calculator should handle up to 5 operands for user-defined operations. - Ensure to handle division by zero and other edge cases robustly. Function Signature ```python from typing import List, Callable class CustomCalculator: def __init__(self): self.operations = { \'add\': lambda x, y: x + y, \'subtract\': lambda x, y: x - y, \'multiply\': lambda x, y: x * y, \'divide\': lambda x, y: x / y if y != 0 else float(\'inf\') # handle division by zero } def add_operation(self, operation_name: str, operation_func: Callable) -> None: pass # Add a new operation to the operations dictionary def perform_operation(self, operation_name: str, operands: List[float]) -> float: pass # Perform the operation using the provided operands # Example Usage: # calculator = CustomCalculator() # result = calculator.perform_operation(\'add\', [3.0, 4.5]) # Should return 7.5 # calculator.add_operation(\'power\', lambda x, y: x ** y) # result = calculator.perform_operation(\'power\', [2.0, 3.0]) # Should return 8.0 ``` Performance Requirements - Ensure that custom operations can handle up to 5 operands efficiently. - Basic arithmetic operations should be performed with minimal overhead.","solution":"from typing import List, Callable class CustomCalculator: def __init__(self): self.operations = { \'add\': lambda x, y: x + y, \'subtract\': lambda x, y: x - y, \'multiply\': lambda x, y: x * y, \'divide\': lambda x, y: x / y if y != 0 else float(\'inf\') # handle division by zero } def add_operation(self, operation_name: str, operation_func: Callable) -> None: self.operations[operation_name] = operation_func def perform_operation(self, operation_name: str, operands: List[float]) -> float: if operation_name not in self.operations: raise ValueError(f\\"Operation \'{operation_name}\' not supported.\\") operation = self.operations[operation_name] # Basic binary operation expects two operands if len(operands) == 2: return operation(operands[0], operands[1]) # For custom operations that might need more operands, we can use *operands return operation(*operands)"},{"question":"Find Pairs with Given Difference **Problem Statement**: Given an array of distinct integers and a non-negative integer `k`, write a function to find all unique pairs (where the order of numbers within the pair does not matter) in the array with a difference of `k`. The function should return the pairs as a list of tuples. Write a function `find_pairs(nums: list[int], k: int) -> list[tuple[int, int]]` that implements this logic. **Function Signature**: ```python from typing import List, Tuple def find_pairs(nums: List[int], k: int) -> List[Tuple[int, int]]: ``` **Input**: - `nums`: A list of distinct integers (e.g., [1, 7, 5, 9, 2, 12, 3]). - `k`: A non-negative integer representing the difference (e.g., 2). **Output**: - A list of tuples, where each tuple contains two integers from `nums` with a difference of `k`. **Constraints**: - Each input list will contain distinct integers. - The order of tuples in the result does not matter. **Examples**: ```python assert find_pairs([1, 7, 5, 9, 2, 12, 3], 2) == [(1, 3), (3, 5), (5, 7), (7, 9)] assert find_pairs([1, 7, 5, 9, 2, 12, 3], 10) == [(2, 12)] assert find_pairs([1, 7, 5, 9, 2, 12, 3], 5) == [(2, 7), (7, 12)] assert find_pairs([1, 7, 5, 9, 2, 12, 3], 3) == [(1, 4), (2, 5), (3, 6)] assert find_pairs([1, 22, 35, 47], 11) == [] assert find_pairs([7, 5, 12, 3, 1], 4) == [(1, 5), (3, 7)] ``` **Explanation**: 1. `find_pairs([1, 7, 5, 9, 2, 12, 3], 2)` returns `[(1, 3), (3, 5), (5, 7), (7, 9)]` because these pairs all have a difference of 2. 2. `find_pairs([1, 7, 5, 9, 2, 12, 3], 10)` returns `[(2, 12)]` because 2 and 12 have a difference of 10. 3. `find_pairs([1, 7, 5, 9, 2, 12, 3], 5)` returns `[(2, 7), (7, 12)]` because these pairs have a difference of 5. 4. `find_pairs([1, 7, 5, 9, 2, 12, 3], 3)` returns `[(1, 4), (2, 5), (3, 6)]` because these pairs would have a difference of 3. 5. `find_pairs([1, 22, 35, 47], 11)` returns `[]` as no pairs have the required difference. 6. `find_pairs([7, 5, 12, 3, 1], 4)` returns `[(1, 5), (3, 7)]` as these pairs have a difference of 4. **Note**: - Ensure the function considers all unique pairs without repeating or reversing the order within the pairs.","solution":"from typing import List, Tuple def find_pairs(nums: List[int], k: int) -> List[Tuple[int, int]]: Returns all unique pairs in the array where the difference between the two numbers is k. result = set() num_set = set(nums) for num in nums: if num + k in num_set: result.add((num, num + k)) if num - k in num_set: result.add((num - k, num)) return list(result)"},{"question":"# Interval Tree for Overlapping Intervals **Context:** You are given a set of intervals, and you need to design a system that can efficiently add new intervals and query for the existing intervals that overlap with a given interval. # Requirements: 1. Implement an Interval Tree that supports: * **Add Interval**: Add a new interval. * **Query Intervals**: Retrieve the list of intervals that overlap with a given interval. 2. Your implementation should efficiently handle a large number of additions and queries. # Specifications: * **Function Definitions**: * `__init__(self)`: Initialize the interval tree. * `add_interval(self, start: int, end: int)`: Add a new interval [start, end] to the interval tree. * `query_intervals(self, start: int, end: int) -> List[Tuple[int, int]]`: Return a list of all intervals that overlap with the interval [start, end]. * **Input Constraints**: * The start of an interval is always less than or equal to the end of the interval. * Intervals are defined by non-negative integers. * Additions and queries are valid as per the given constraints. * **Example**: ```python int_tree = IntervalTree() int_tree.add_interval(1, 5) int_tree.add_interval(10, 15) int_tree.add_interval(12, 20) assert set(int_tree.query_intervals(14, 18)) == {(10, 15), (12, 20)} # These intervals overlap with [14, 18] assert set(int_tree.query_intervals(5, 10)) == {(1, 5), (10, 15)} # These intervals overlap with [5, 10] ``` * **Edge Cases to Consider**: * Adding intervals that are subsets of existing intervals. * Querying for an interval that has no overlaps. * Multiple overlapping additions and queries. # Objective: Provide a clear and efficient implementation of the interval tree that supports fast interval additions and overlap queries. Ensure to handle all edge cases robustly.","solution":"from typing import List, Tuple class IntervalTree: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int): self.intervals.append((start, end)) def query_intervals(self, start: int, end: int) -> List[Tuple[int, int]]: result = [] for (s, e) in self.intervals: if not (end < s or start > e): result.append((s, e)) return result"},{"question":"# Space-Efficient Duplicate Finder Context You are tasked with finding duplicates in an array of integers where the array utilizes constant space for extra storage. The array is permitted to be modified, but it should be left intact by the end of the operations. The array will contain integers from 1 to n, where n is the length of the array, with some elements occurring more than once. Your goal is to identify all duplicate numbers in the array without using extra space. Task Implement a class `DuplicateFinder` with a single method `find_duplicates`. Method Details 1. **find_duplicates(arr: List[int]) -> List[int]**: - **Input**: A list of `n` integers where each integer is in the range from 1 to `n`. - **Output**: A list of integers representing the duplicate numbers found in the input array. The order of duplicates in the output does not matter, but each duplicate should appear only once. - **Example**: ```python finder = DuplicateFinder() assert finder.find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] assert finder.find_duplicates([1, 2, 3, 4, 5, 5, 6]) == [5] ``` Constraints - The input list will always contain at least one element. - The input list may contain multiple duplicates for a single number. - The algorithm should run in O(n) time complexity. - Use only O(1) extra space, not counting the input and output arrays. Performance - Ensure the solution is efficient both in terms of time complexity and space usage. - The array should be modified only transiently and restored to its original state by the end of the method. Additional Information - You may assume that the method of restoring the array to its original state is handled internally. - Focus on the implementation of the `find_duplicates` method to meet the required performance guidelines.","solution":"from typing import List class DuplicateFinder: def find_duplicates(self, arr: List[int]) -> List[int]: duplicates = [] n = len(arr) for i in range(n): index = abs(arr[i]) - 1 if arr[index] < 0: duplicates.append(index + 1) else: arr[index] = -arr[index] for i in range(n): arr[i] = abs(arr[i]) return duplicates"},{"question":"# Question: Implement a Merge Sort Algorithm Context: Your task is to implement the merge sort algorithm using a recursive approach. The function should sort a given list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that divides the input list into two halves, sorts them recursively, and then merges the sorted halves to produce the final sorted list. Function Signature: ```python def merge_sort(arr: list) -> list: ``` Parameters: - `arr`: a list of integers that needs to be sorted. Returns: - The function returns a new list of integers that are sorted in ascending order. Constraints: - The function should handle edge cases like an empty list and a list with only one element. - You are not allowed to use any built-in sorting functions or libraries. - Focus on optimizing the merge process to ensure the performance is as expected for merge sort. Examples: ```python # Example 1 print(merge_sort([12, 11, 13, 5, 6, 7])) # Output: [5, 6, 7, 11, 12, 13] # Example 2 print(merge_sort([4, 1, 3, 9, 7])) # Output: [1, 3, 4, 7, 9] # Example 3 print(merge_sort([1, 20, 6, 4, 5])) # Output: [1, 4, 5, 6, 20] # Example 4 print(merge_sort([10, 5, 2, 3, 7, 2])) # Output: [2, 2, 3, 5, 7, 10] # Example 5 print(merge_sort([])) # Output: [] ``` Note: You need to implement the function without using any built-in sorting functions or libraries. Focus on handling the provided edge cases and ensuring that the function works optimally for different sizes of input lists.","solution":"def merge_sort(arr): Recursive implementation of merge sort. # Base case: if the list is empty or contains a single element if len(arr) <= 1: return arr # Recursive case: split the list into halves and merge sort each half mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) # Merge the sorted halves and return the sorted list return merge(left, right) def merge(left, right): Merge two sorted lists into one sorted list. sorted_list = [] i, j = 0, 0 # Traverse both lists and insert the smaller element into the sorted list while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # If there are remaining elements in left or right, append them sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"**Context**: You are developing a function that needs to evaluate whether a list of integers contains a contiguous subarray whose sum equals a specific target value. This problem often appears in financial software where developers need to identify sequences of transactions that meet a defined sum. **Coding Task**: Write a function named `has_contiguous_subarray_sum` that takes two parameters: * `arr` (a list of integers), * `target` (an integer). Your function should return a boolean indicating whether any contiguous subarray of `arr` sums up to `target`. The function must efficiently handle large input sizes with an optimized approach. # Input * The function will be called as: `has_contiguous_subarray_sum(arr: List[int], target: int) -> bool` * `arr` (a list of integers): 1 ≤ len(arr) ≤ 10^6 and each integer `k` will be in the range of -10^5 ≤ k ≤ 10^5 * `target` (an integer): -10^9 ≤ target ≤ 10^9 # Output * Return a boolean: `True` if there exists at least one contiguous subarray whose sum equals `target`, `False` otherwise. # Constraints * Aim for an optimized solution to handle large arrays efficiently. # Example ```python def has_contiguous_subarray_sum(arr: List[int], target: int) -> bool: # Your implementation here # Example usage print(has_contiguous_subarray_sum([1, 2, 3, 4, 5], 9)) # Output: True print(has_contiguous_subarray_sum([1, 2, 3, 4, 5], 20)) # Output: False ``` # Explanation * In the first example, the subarray `[2, 3, 4]` sums up to 9. * In the second example, no contiguous subarray sums up to 20.","solution":"def has_contiguous_subarray_sum(arr, target): Returns True if there exists a contiguous subarray within arr that sums up to target, otherwise returns False. current_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum to handle cases where subarray starts from index 0 for num in arr: current_sum += num if (current_sum - target) in sum_dict: return True if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return False"},{"question":"# Roman Numeral Translator Context: You are part of a team developing an educational tool that teaches students about Roman numerals. As part of this project, you need to implement a feature that converts Roman numeral strings to their integer equivalents and vice versa. Task: Implement two functions that handle these conversions: 1. **Function**: `roman_to_integer(roman: str) -> int` - Converts a Roman numeral string to its integer equivalent. - **Input**: A string representing the Roman numeral (e.g., \'XIV\', \'MCMXCIV\'). - **Output**: An integer representing the corresponding value. 2. **Function**: `integer_to_roman(value: int) -> str` - Converts an integer to its Roman numeral representation. - **Input**: An integer within the range 1 to 3999. - **Output**: A string representing the Roman numeral equivalent. Constraints: 1. For `roman_to_integer`, the input string will only contain valid uppercase Roman numeral characters (I, V, X, L, C, D, M). 2. For `integer_to_roman`, the value must be between 1 and 3999 inclusive. 3. Both functions should handle edge cases such as the largest and smallest possible values. Examples: ```python >>> roman_to_integer(\'MCMXCIV\') 1994 >>> roman_to_integer(\'III\') 3 >>> integer_to_roman(58) \'LVIII\' >>> integer_to_roman(1994) \'MCMXCIV\' ``` Implement the functions accordingly, ensuring they perform accurate and efficient conversions. **Note**: You can reference the following standard Roman numeral values: ``` I : 1 IV : 4 V : 5 IX : 9 X : 10 XL : 40 L : 50 XC : 90 C : 100 CD : 400 D : 500 CM : 900 M : 1000 ```","solution":"def roman_to_integer(roman): Converts a Roman numeral string to its integer equivalent. :param roman: A string representing the Roman numeral (e.g., \'XIV\', \'MCMXCIV\') :return: An integer representing the corresponding value. roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i = 0 result = 0 while i < len(roman): if i + 1 < len(roman) and roman[i:i+2] in roman_to_int: result += roman_to_int[roman[i:i+2]] i += 2 else: result += roman_to_int[roman[i]] i += 1 return result def integer_to_roman(value): Converts an integer to its Roman numeral representation. :param value: An integer within the range 1 to 3999. :return: A string representing the Roman numeral equivalent. int_to_roman = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] result = [] for (integer, roman) in int_to_roman: while value >= integer: result.append(roman) value -= integer return \'\'.join(result)"},{"question":"# Context A company\'s software development team uses a custom file synchronization tool that synchronizes files from one directory to another. The synchronization tool is selective and only copies files that have a specific file extension. The tool also logs the files it has processed and any errors encountered during the process. # Task Write a function to perform the file synchronization, given two directories and a file extension to filter by. Additionally, implement a function to generate a log of the synchronization process. # Implementation You will have to implement the following functions: 1. **`synchronize_files(source_dir: str, target_dir: str, file_extension: str) -> list[str]`**: - Synchronize files from `source_dir` to `target_dir` that match the given `file_extension`. - Returns a list of successfully synchronized files. - Example: ```python assert synchronize_files(\\"source\\", \\"target\\", \\".txt\\") == [\\"file1.txt\\", \\"file2.txt\\"] ``` 2. **`generate_log(files: list[str], errors: list[str]) -> str`**: - Generate a log string showing the synchronized files and any errors encountered. - Example: ```python files = [\\"file1.txt\\", \\"file2.txt\\"] errors = [\\"file3.txt not found\\", \\"file4.txt permission denied\\"] expected_log = ( \\"Synchronized Files:n\\" \\"file1.txtn\\" \\"file2.txtnn\\" \\"Errors:n\\" \\"file3.txt not foundn\\" \\"file4.txt permission denied\\" ) assert generate_log(files, errors) == expected_log ``` # Constraints * The `source_dir` and `target_dir` are valid directory paths. * The `file_extension` is a string representing the file extension (e.g., \\".txt\\", \\".png\\"). * Handle file I/O errors gracefully and log them. * Only files with the specified extension should be synchronized. * Ensure that the `target_dir` exists (create it if necessary). # Input/Output - **Input**: Three strings representing `source_dir`, `target_dir`, and `file_extension`. - **Output**: One string representing the synchronization log. # Example Scenario ```python # Example use source_dir = \\"path/to/source\\" target_dir = \\"path/to/target\\" file_extension = \\".txt\\" synchronized_files = synchronize_files(source_dir, target_dir, file_extension) errors = [] # Populate this list with any errors encountered during synchronization log = generate_log(synchronized_files, errors) print(log) ``` Submit your complete solution in a Python file.","solution":"import os import shutil from typing import List def synchronize_files(source_dir: str, target_dir: str, file_extension: str) -> List[str]: synchronized_files = [] errors = [] # Ensure the target directory exists os.makedirs(target_dir, exist_ok=True) try: # Iterate over files in the source directory for root, dirs, files in os.walk(source_dir): for file in files: if file.endswith(file_extension): source_file = os.path.join(root, file) target_file = os.path.join(target_dir, file) try: shutil.copy2(source_file, target_file) synchronized_files.append(file) except IOError as e: errors.append(f\\"{file}: {str(e)}\\") except Exception as e: errors.append(str(e)) return synchronized_files, errors def generate_log(files: List[str], errors: List[str]) -> str: log = \\"Synchronized Files:n\\" if files: log += \\"n\\".join(files) + \\"n\\" else: log += \\"Nonen\\" log += \\"nErrors:n\\" if errors: log += \\"n\\".join(errors) + \\"n\\" else: log += \\"Nonen\\" return log"},{"question":"# Problem Statement You are tasked with implementing a hash table that uses open addressing with linear probing in Python. Your hash table should handle standard operations such as insertion, deletion, and searching efficiently. Specifically, you will design a class `LinearProbingHashTable` to accommodate these operations and handle potential collisions using linear probing. # Requirements 1. **Input**: - `key` : An integer representing the key. - `value` : A string representing the value associated with the key. - `capacity` (int): The underlying array size of the hash table. Default value: 10. 2. **Output**: - You will create three methods: `insert(key, value)`, `delete(key)`, and `search(key)`. - The `insert` method adds the key-value pair to the hash table. - The `delete` method removes the key-value pair from the hash table. - The `search` method returns the value associated with the specified key, or `None` if the key is not present. # Constraints - The keys will be unique and are integers between -10^6 and 10^6. - The values are strings with a length between 1 and 100 characters. - The capacity of the hash table will be at least 1 and less than or equal to 10^4. - Handle collisions using linear probing. - Ensure that operations are performed with an average-case time complexity of O(1). # Example ```python # Creating the hash table hash_table = LinearProbingHashTable(capacity=5) # Inserting key-value pairs hash_table.insert(1, \\"a\\") hash_table.insert(2, \\"b\\") hash_table.insert(3, \\"c\\") # Searching for values print(hash_table.search(2)) # Output: \\"b\\" # Deleting a key hash_table.delete(2) print(hash_table.search(2)) # Output: None # Handling collisions gracefully with linear probing hash_table.insert(6, \\"f\\") # Since 6 % 5 == 1, should probe to next available slot. print(hash_table.search(6)) # Output: \\"f\\" ``` # Instructions: 1. Implement the class `LinearProbingHashTable` with methods: - `__init__(self, capacity=10)`: Initialize the hash table with a given capacity and empty slots. - `insert(self, key, value)`: Insert the key-value pair into the hash table, handling collisions using linear probing. - `delete(self, key)`: Remove the key-value pair from the hash table, ensuring that the structure remains valid for subsequent operations. - `search(self, key)`: Return the value associated with the specified key, or `None` if the key is not found. 2. Ensure proper handling of collisions using linear probing. 3. Implement all operations efficiently to achieve an average-case complexity of O(1). This question maintains the style, length, and complexity of the original set while introducing a new problem involving hash tables and collision handling.","solution":"class LinearProbingHashTable: def __init__(self, capacity=10): self.capacity = capacity self.table = [None] * self.capacity self.keys = set() def _hash(self, key): return key % self.capacity def insert(self, key, value): if key in self.keys: self.delete(key) # Remove the old entry index = self._hash(key) while self.table[index] is not None: index = (index + 1) % self.capacity self.table[index] = (key, value) self.keys.add(key) def delete(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.keys.remove(key) break index = (index + 1) % self.capacity # Rehash elements in the cluster index = (index + 1) % self.capacity while self.table[index] is not None: key_to_rehash, value_to_rehash = self.table[index] self.table[index] = None self.keys.remove(key_to_rehash) self.insert(key_to_rehash, value_to_rehash) index = (index + 1) % self.capacity def search(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None"},{"question":"# Question You are a software engineer tasked with creating an order management system for an e-commerce platform. Your task is to implement a function that calculates the total cost of a list of ordered items, including a dynamic discount policy. # Requirements 1. **Function Name**: `calculate_total_price` 2. **Inputs**: - A list of dictionaries `orders`, where each dictionary represents an order and includes the keys: - `\'item\'`: a string representing the name of the item. - `\'price\'`: a float representing the price of the item. - `\'quantity\'`: an integer representing the quantity of the item ordered. - A function `discount_policy` that takes a float (total price before discount) and returns a float (discounted price). 3. **Output**: - A float representing the total price after applying the dynamic discount policy. # Constraints - The list `orders` will always contain at least one order and each order will be a valid dictionary with the specified keys. - Prices and quantities will always be non-negative numbers. - The `discount_policy` function is guaranteed to return a non-negative discounted price that is less than or equal to the total price before discount. # Example ```python def discount_policy(total_price): if total_price > 100: return total_price * 0.9 # 10% discount for orders over 100 return total_price orders = [ {\'item\': \'Laptop\', \'price\': 999.99, \'quantity\': 1}, {\'item\': \'Mouse\', \'price\': 25.50, \'quantity\': 2}, {\'item\': \'Keyboard\', \'price\': 45.00, \'quantity\': 1}, ] total_price = calculate_total_price(orders, discount_policy) print(total_price) # 950.391 ``` # Notes - Ensure your code handles the summation of total prices correctly, considering both the price and quantity of each item. - The function should be efficient and scalable for lists containing a large number of orders. - You can assume all input data is well-formed and does not require additional validation.","solution":"def calculate_total_price(orders, discount_policy): Calculates the total price of a list of ordered items, applying a dynamic discount policy. Parameters: orders (list): A list of dictionaries where each dictionary contains \'item\', \'price\', and \'quantity\' keys. discount_policy (function): A function that applies a discount to the total price. Returns: float: The total price after applying the discount policy. # Calculate the total price before discount total_price_before_discount = sum(order[\'price\'] * order[\'quantity\'] for order in orders) # Apply the discount policy to get the final total price total_price_after_discount = discount_policy(total_price_before_discount) return total_price_after_discount"},{"question":"# Coding Assessment Question **Context**: You are working on a software module that analyzes network data to identify potentially harmful activities. One aspect of this module is to detect potential Distributed Denial-of-Service (DDoS) attacks by analyzing the number of requests made to a server from various IP addresses within specified time intervals. **Task**: Implement a function `detect_ddos` that takes in a list of log entries and a threshold value. Each log entry contains a timestamp and the IP address from which the request was made. The function should return a list of IP addresses that made requests exceeding the given threshold within any 10-second interval. # Function Signature ```python def detect_ddos(log_entries: list, threshold: int) -> list: ``` # Input * `log_entries` (list): A list of dictionary entries where each dictionary contains: * `timestamp` (int): The Unix timestamp representing the time of the request. * `ip_address` (str): The IP address from which the request was made. * `threshold` (int): The number of requests from a single IP address that must be exceeded within any 10-second interval to be considered a potential DDoS attack. # Output * A list of unique IP addresses (str) that made requests exceeding the specified threshold within any 10-second interval. # Constraints * `log_entries` must contain entries sorted by timestamp in ascending order. * The `timestamp` is an integer representing Unix time. * The `ip_address` is a non-empty string representing a valid IP address. * Only consider requests within a 10-second rolling window for threshold comparison. * If no IP addresses exceed the threshold, return an empty list. # Example ```python log_entries = [ {\\"timestamp\\": 1615569200, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569202, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569204, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569206, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569207, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569208, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569210, \\"ip_address\\": \\"192.168.1.1\\"}, {\\"timestamp\\": 1615569200, \\"ip_address\\": \\"192.168.1.2\\"}, {\\"timestamp\\": 1615569210, \\"ip_address\\": \\"192.168.1.2\\"}, {\\"timestamp\\": 1615569215, \\"ip_address\\": \\"192.168.1.2\\"}, ] result = detect_ddos(log_entries, 5) # Expected Output: [\\"192.168.1.1\\"] ``` # Notes 1. Use an efficient algorithm to ensure that the function handles large datasets within a reasonable time. 2. Consider edge cases such as multiple entries for the same timestamp, very high threshold values, and an empty list of log entries. 3. Return unique IP addresses only once in the output list.","solution":"def detect_ddos(log_entries: list, threshold: int) -> list: from collections import deque, defaultdict if not log_entries: return [] ip_dict = defaultdict(deque) suspicious_ips = set() for entry in log_entries: timestamp, ip = entry[\'timestamp\'], entry[\'ip_address\'] window = ip_dict[ip] window.append(timestamp) # Remove timestamps that are outside the 10-second window while window and window[0] < timestamp - 10: window.popleft() if len(window) > threshold: suspicious_ips.add(ip) return list(suspicious_ips)"},{"question":"# Objective: Implement a function that determines if a given string is a shuffled palindrome, ensuring understanding of string manipulation and permutation checks for performance. # Question: Design a function called `is_shuffled_palindrome(s: str) -> bool` that determines if a given string can be rearranged to form a palindrome. A string can form a palindrome if at most one character appears an odd number of times in the string. # Requirements: * **Input**: A string `s` of lowercase letters where 0 ≤ len(s) ≤ 10^5. * **Output**: A boolean value `True` if the string can be rearranged to form a palindrome, and `False` otherwise. # Constraints: * The function should have a linear time complexity relative to the length of the string. * Avoid using excessive memory and ensure the implementation is efficient. # Example: ```python def is_shuffled_palindrome(s: str) -> bool: # Your code here # Example Usage print(is_shuffled_palindrome(\\"civic\\")) # Expected: True print(is_shuffled_palindrome(\\"ivicc\\")) # Expected: True print(is_shuffled_palindrome(\\"hello\\")) # Expected: False print(is_shuffled_palindrome(\\"aabbcc\\")) # Expected: True ``` # Function Signature: ```python def is_shuffled_palindrome(s: str) -> bool: ``` # Notes: * A palindrome reads the same forwards and backwards. * Empty strings and single-character strings are trivially palindromes. * Pay attention to optimizing both time and space complexity, especially for large input sizes.","solution":"def is_shuffled_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. :param s: A string `s` of lowercase letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"# Task Scheduling Problem Given a list of tasks, each with a specific duration and a cooldown period that must pass after the task\'s execution before it can be scheduled again, determine the minimum time required to complete all tasks. Implement the function `def min_time_to_complete_tasks(tasks: List[int], cooldown: int) -> int:` such that: Input * `tasks`: A list of integers where each integer represents a task identifier. * `cooldown`: An integer representing the cooldown period (in time units) between two consecutive occurrences of the same task. Output * An integer representing the minimum time required to schedule all the tasks. Constraints * `1 <= len(tasks) <= 1000` * `1 <= cooldown <= 20` * All task identifiers are positive integers and may repeat. # Example Example 1 ```python tasks = [1, 1, 2, 1] cooldown = 2 assert min_time_to_complete_tasks(tasks, cooldown) == 7 # Explanation: One of the possible schedules could be: 1 -> 2 -> idle -> 1 -> 1 -> idle -> 1 ``` Example 2 ```python tasks = [1, 2, 1, 2, 3, 1] cooldown = 3 assert min_time_to_complete_tasks(tasks, cooldown) == 9 # Explanation: One of the possible schedules could be: 1 -> 2 -> 3 -> 1 -> idle -> idle -> idle -> 2 -> 1 ``` Note * Idle periods are considered as time units where no tasks are executed. * The order of tasks in the result means the minimum time to execute all given tasks enforcing the cooldown period. * The solution should manage the task execution optimally to minimize the total execution time while adhering to the cooldown constraints.","solution":"def min_time_to_complete_tasks(tasks, cooldown): from collections import defaultdict # Dictionary to store the last execution time of each task last_execution_time = defaultdict(lambda: -float(\'inf\')) current_time = 0 for task in tasks: if current_time - last_execution_time[task] <= cooldown: current_time = last_execution_time[task] + cooldown + 1 else: current_time += 1 last_execution_time[task] = current_time return current_time"},{"question":"# Problem Statement: You are developing a scheduling system for a multimedia production company. In this system, the next task to be executed is selected based on the highest priority first, and if two tasks have the same priority, they are executed based on which was added first (FIFO order for same-priority tasks). Implement a `PriorityTaskScheduler` system that supports constant time task addition and efficient task selection and removal. # Requirements: 1. Implement a class `PriorityTaskScheduler` with the following methods: - `void add_task(int priority, str task)`: Adds a task with the given priority to the system. - `str get_next_task()`: Removes and returns the next task (the one with the highest priority; if there is a tie, the task added first is selected). - `str __str__()`: Returns a string representation of the current state of the task list, ordered by priority and then by insertion order for tasks with the same priority. 2. Ensure that `add_task` maintains the priority queue property. 3. Ensure that `get_next_task` efficiently returns the task with the highest priority. 4. Raise an `UnderFlowError` if trying to get the next task from an empty schedule. 5. Handle a maximum of 200 tasks in the scheduler. # Input and Output Formats: - The `add_task` method accepts an integer `priority` and a string `task`. - The `get_next_task` method returns the string of the next task to be executed. - The `__str__` method returns a formatted string representation of the task list in priority order. # Constraints: - 1 <= `priority` <= 10^6 - Task description strings will be non-empty and have a maximum length of 100 characters. # Example: ```python class UnderFlowError(Exception): pass class PriorityTaskScheduler: def __init__(self): pass # Include your initialization code here def add_task(self, priority: int, task: str) -> None: pass # Include your add_task implementation here def get_next_task(self) -> str: pass # Include your get_next_task implementation here def __str__(self) -> str: pass # Include your string representation here # Example usage: scheduler = PriorityTaskScheduler() scheduler.add_task(5, \\"Edit video\\") scheduler.add_task(10, \\"Record audio\\") scheduler.add_task(5, \\"Write script\\") print(scheduler) # Expected: [(10, \\"Record audio\\"), (5, \\"Edit video\\"), (5, \\"Write script\\")] print(scheduler.get_next_task()) # Expected: \\"Record audio\\" print(scheduler.get_next_task()) # Expected: \\"Edit video\\" print(scheduler) # Expected: [(5, \\"Write script\\")] ``` Complete the class `PriorityTaskScheduler` based on the provided requirements and examples.","solution":"import heapq class UnderFlowError(Exception): pass class PriorityTaskScheduler: def __init__(self): self.heap = [] self.counter = 0 # This will act as a timestamp to maintain insertion order def add_task(self, priority: int, task: str) -> None: if len(self.heap) >= 200: raise OverflowError(\\"Maximum number of tasks exceeded\\") heapq.heappush(self.heap, (-priority, self.counter, task)) self.counter += 1 def get_next_task(self) -> str: if not self.heap: raise UnderFlowError(\\"No tasks in the scheduler\\") _, _, task = heapq.heappop(self.heap) return task def __str__(self) -> str: return str([(-priority, task) for priority, _, task in sorted(self.heap)])"},{"question":"**Context**: You are developing a software that manages a fleet of delivery vehicles for a logistics company. Each vehicle has a specific fuel efficiency and fuel capacity, and your task is to optimize the routes so that each vehicle can complete its deliveries without running out of fuel. To evaluate your optimization algorithm, you need to simulate the scenario and calculate the maximum distance each vehicle can travel based on its fuel efficiency and capacity. **Task**: Implement a function `calculate_max_distances` that takes a list of vehicles represented by their fuel efficiency and fuel capacity, and returns the maximum distance each vehicle can travel. # Function Signature ```python def calculate_max_distances(fleet: List[Tuple[float, float]]) -> List[float]: Given a list of vehicles where each vehicle is represented by its fuel efficiency (miles per gallon) and fuel capacity (gallons), calculate the maximum distance each vehicle can travel without refueling. Args: fleet (List[Tuple[float, float]]): A list of tuples, where each tuple contains the fuel efficiency (in miles per gallon) and fuel capacity (in gallons) of a vehicle. Returns: List[float]: A list of floats where each float represents the maximum distance a vehicle can travel. ``` # Input * `fleet` (List[Tuple[float, float]]): A list of tuples where each tuple contains: * A float representing the fuel efficiency of the vehicle (0.1 <= fuel efficiency <= 100.0 miles per gallon). * A float representing the fuel capacity of the vehicle (1.0 <= fuel capacity <= 200.0 gallons). # Output * A list of floats where each float represents the maximum distance a corresponding vehicle in the input list can travel. # Examples ```python >>> calculate_max_distances([(25.0, 10.0), (30.0, 8.0)]) [250.0, 240.0] >>> calculate_max_distances([(15.0, 20.0), (40.0, 5.0)]) [300.0, 200.0] >>> calculate_max_distances([(50.0, 2.0), (20.0, 15.5), (33.0, 7.7)]) [100.0, 310.0, 254.1] ``` # Constraints * Ensure that the function handles all edge cases effectively. * Minimize the computational complexity where possible. * Handle inputs with a large number of vehicles optimally. Write your implementation to make sure it correctly computes the maximum distances each vehicle can travel based on their specific fuel efficiency and capacity.","solution":"from typing import List, Tuple def calculate_max_distances(fleet: List[Tuple[float, float]]) -> List[float]: Given a list of vehicles where each vehicle is represented by its fuel efficiency (miles per gallon) and fuel capacity (gallons), calculate the maximum distance each vehicle can travel without refueling. Args: fleet (List[Tuple[float, float]]): A list of tuples, where each tuple contains the fuel efficiency (in miles per gallon) and fuel capacity (in gallons) of a vehicle. Returns: List[float]: A list of floats where each float represents the maximum distance a vehicle can travel. return [efficiency * capacity for efficiency, capacity in fleet]"},{"question":"# Binary Search Tree and Finding the Depth You are provided with a class definition for a binary search tree (BST) which includes methods such as `insert`, `delete`, and `find`. Your task is to implement a new method `max_depth` for the `BST` class that calculates the maximum depth (or height) of the binary search tree. The depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Requirements: 1. **Input**: The `max_depth` method should take no input parameters (other than `self` for the class method). 2. **Output**: The method should return an integer representing the maximum depth of the binary search tree. 3. **Performance Constraints**: The method should ideally run in O(n) time complexity, where n is the number of nodes in the tree. 4. **Corner Cases**: Handle edge cases where the tree is empty. Function Signature: ```python def max_depth(self) -> int ``` Example: ```python # Example 1 bst = BinarySearchTree() for value in [3, 1, 4, 0, 2]: bst.insert(value) assert bst.max_depth() == 3 # 3 -> 1 -> 0 (3 levels) # Example 2 bst = BinarySearchTree() for value in [10, 5, 20, 3, 7, 15, 25]: bst.insert(value) assert bst.max_depth() == 3 # 10 -> 5 -> 3 or 10 -> 20 -> 25 (3 levels) ``` **Note**: Make sure you thoroughly test your implementation with various edge cases to ensure its robustness.","solution":"class BSTNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = BSTNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if root.val < key: if root.right is None: root.right = BSTNode(key) else: self._insert(root.right, key) else: if root.left is None: root.left = BSTNode(key) else: self._insert(root.left, key) def max_depth(self): return self._max_depth(self.root) def _max_depth(self, node): if node is None: return 0 else: left_depth = self._max_depth(node.left) right_depth = self._max_depth(node.right) return max(left_depth, right_depth) + 1"},{"question":"# Array Rotation Task **Objective**: Implement an efficient algorithm to rotate the elements of an array to the right by a given number of steps. **Context**: Rotating arrays is a common task in various applications such as shunting puzzles, number games, and cyclically changing data arrangements. Your task is to develop an algorithm that performs this rotation efficiently and in-place. Requirements You need to write a function `rotate_array(arr: list, k: int) -> list` that performs an in-place rotation of the given array to the right by `k` steps. The function should: 1. **Rotate the list** such that each element is shifted to the right by `k` steps, with elements that overflow moving back to the start. 2. **Operate in linear time** O(n) and use constant additional space O(1). 3. Work with any **list of items**, including integers, strings, or custom objects. Specifications * **Input**: A list called `arr` with elements to be rotated and an integer `k` representing the number of steps to rotate. * **Output**: The function should return the same list but rotated to the right by `k` steps. Constraints * The list can contain up to 10^6 elements. * The integer `k` will be a non-negative integer. * The function should handle edge cases gracefully, such as `k` being zero, `k` being larger than the length of the list, an empty list, or a list with a single element. Performance Requirements * The rotation should not use additional memory proportional to the input size. * Execution time should be efficient relative to the input size. Example ```python def rotate_array(arr: list, k: int) -> list: n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the list arr[:] = arr[-k:] + arr[:-k] return arr integers = [1, 2, 3, 4, 5, 6, 7] rotate_steps = 3 print(\\"Original:\\", integers) print(\\"Rotated:\\", rotate_array(integers, rotate_steps)) strings = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] rotate_steps = 2 print(\\"Original:\\", strings) print(\\"Rotated:\\", rotate_array(strings, rotate_steps)) ``` **Note**: Ensure you properly test your implementation using different types and sizes of lists to verify the efficiency and correctness of the rotation.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of elements to be rotated. k (int): Number of steps to rotate the list. Returns: list: The rotated list. n = len(arr) if n == 0: return arr k = k % n # Normalize k to avoid unnecessary rotation arr[:] = arr[-k:] + arr[:-k] return arr"},{"question":"# Coding Assessment Question Context: You are tasked with developing functionality for an online book library system. Occasionally, titles of books contain numbers which represent series volumes or editions. Users expect these titles to be sorted naturally within the library\'s catalog. Task: Write a function `natural_sort_titles(book_list: list[str]) -> list[str]` that accepts a list of book titles and returns a new list sorted in natural order. Function Signature: ```python def natural_sort_titles(book_list: list[str]) -> list[str]: ``` Input: * A list of strings `book_list` where each string represents a book title, which could contain both alpha and numeric characters. * Example: `[\\"Series 10 - The Final Chapter\\", \\"Series 2 - The Beginning\\", \\"Series 1 - Introduction\\", \\"Series 20 - The End\\", \\"Series 11 - Next Steps\\"]` Output: * A new list of strings sorted in natural order. * Example: `[\\"Series 1 - Introduction\\", \\"Series 2 - The Beginning\\", \\"Series 10 - The Final Chapter\\", \\"Series 11 - Next Steps\\", \\"Series 20 - The End\\"]` Constraints: * The input list will contain between 1 and 10^5 book titles. * Titles are non-empty strings that may contain alphanumeric characters. Example: ```python book_list = [\\"Volume 3: The Journey\\", \\"Volume 10: The Revelation\\", \\"Volume 1: The Awakening\\"] assert natural_sort_titles(book_list) == [\\"Volume 1: The Awakening\\", \\"Volume 3: The Journey\\", \\"Volume 10: The Revelation\\"] ``` Performance Requirements: * The solution should operate within O(n log n) time complexity for sorting. Summary: Implement the `natural_sort_titles` function in such a way that it addresses the requirements for natural sorting of book titles. Make sure to handle potential edge cases such as titles with large numeric values or complex alphanumeric combinations.","solution":"import re def natural_sort_titles(book_list: list[str]) -> list[str]: Sorts a list of book titles in natural order. Args: book_list (list[str]): List of book titles. Returns: list[str]: Sorted list of book titles in natural order. def natural_key(title): # Convert title into parts of string and numbers to naturally sort by numerical values return [int(text) if text.isdigit() else text for text in re.split(r\'(d+)\', title)] return sorted(book_list, key=natural_key)"},{"question":"Merge Sorted Lists You are tasked with writing a function that takes two sorted lists and merges them into a single sorted list. Your function should maintain the order without using any in-built Python sorting functions. Function Signature ```python def merge_sorted_lists(list1: list, list2: list) -> list: ``` Inputs - `list1` (list): The first sorted list of integers. - `list2` (list): The second sorted list of integers. Output - (list): A single list containing all elements from both input lists, sorted in ascending order. Constraints - Each input list can have zero or more integers, and they are already sorted in ascending order. - The output list should maintain the ascending order. - The function should handle cases where one or both input lists are empty. Example Usage ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([0, 2, 4], [1, 3, 5]) [0, 1, 2, 3, 4, 5] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([4, 5, 6], []) [4, 5, 6] >>> merge_sorted_lists([], []) [] ``` Explanation Write a function that: 1. Accepts two sorted lists as input. 2. Merges the two lists by comparing their elements and maintaining the order. 3. Returns a new list with elements from both input lists, sorted in ascending order. 4. Handles edge cases like empty input lists. Ensure your solution is efficient, and focuses on combining the two lists without using built-in sorting functions.","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: Merges two sorted lists into a single sorted list merged_list = [] i, j = 0, 0 # Merge the two lists by comparing elements of both lists while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Question: Implement a Matrix Multiplication Function You are provided with two 2D lists (matrices) representing two matrices, A and B. Your task is to implement a function that multiplies these two matrices and returns the resulting matrix. # Objective Implement the function `matrix_multiplication` that takes two matrices A and B, and returns their product. # Input - Two matrices A and B (each a list of lists) where each inner list represents a row of the matrix. - The number of columns in matrix A is equal to the number of rows in matrix B. # Output - A new matrix (a list of lists) representing the product of matrices A and B. # Constraints - Both input matrices will have dimensions between 1x1 and 100x100. - It is guaranteed that the number of columns of A will be equal to the number of rows of B. # Performance Requirements - The implementation should efficiently handle the upper constraint limits. - Aim for an algorithm with a time complexity of O(n³) or better for matrix multiplication. # Function Signature ```python def matrix_multiplication(A, B): # Your implementation here pass ``` # Example ```python # Example input matrices A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] # Expected output matrix result = matrix_multiplication(A, B) print(result) # Output should be [[58, 64], [139, 154]] ``` # Notes - Input validation is not required. - You may assume that the input matrices are well-formed and meet the dimension constraints.","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the resulting matrix. Parameters: A (list of lists): The first matrix. B (list of lists): The second matrix. Returns: list of lists: The resulting matrix product of A and B. # Number of rows in A rows_A = len(A) # Number of columns in A cols_A = len(A[0]) # Number of columns in B cols_B = len(B[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Compute the product matrix for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Coding Assessment Question Context You\'re working on implementing a function to manage a list of integers that requires basic statistical analysis. The function should be capable of adding integers to the list, computing the average of the numbers, and returning the median of the list. The median is the middle number in a sorted list, or the average of the two middle numbers if the list has an even number of elements. Task Implement a class `StatsList` that supports the following methods: 1. `add_number(num: int) -> None`: Adds an integer to the list. 2. `get_average() -> float`: Returns the average of the numbers in the list. Should return `0.0` if the list is empty. 3. `get_median() -> float`: Returns the median of the numbers in the list. Should return `0.0` if the list is empty. Properties - The list should be able to handle multiple additions and provide accurate results after each addition. - Ensure that these methods work efficiently even as the number of elements in the list grows. Examples ```python >>> stats = StatsList() >>> stats.add_number(10) >>> stats.add_number(20) >>> stats.add_number(30) >>> stats.get_average() 20.0 >>> stats.get_median() 20.0 >>> stats.add_number(40) >>> stats.add_number(50) >>> stats.get_average() 30.0 >>> stats.get_median() 30.0 ``` # Notes: - You may assume that all numbers added are integers. - For computing the median, you may first sort the list but consider optimizing it for multiple sorting operations. - Consider edge cases such as an empty list. # Constraints: - The methods should handle up to 10^5 integers efficiently.","solution":"class StatsList: def __init__(self): self.numbers = [] def add_number(self, num: int) -> None: self.numbers.append(num) def get_average(self) -> float: if not self.numbers: return 0.0 return sum(self.numbers) / len(self.numbers) def get_median(self) -> float: if not self.numbers: return 0.0 sorted_numbers = sorted(self.numbers) mid = len(sorted_numbers) // 2 if len(sorted_numbers) % 2 == 0: return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2 else: return sorted_numbers[mid]"},{"question":"# Median of Two Sorted Arrays Context In this problem, you will work with two sorted arrays. Finding the median of a single sorted array is straightforward, but the challenge increases when you need to find the median of two sorted arrays that may differ in size. This type of problem commonly appears in coding interviews. Task Description You need to complete the function `median_of_two_sorted_arrays` which should find the median of two sorted arrays. The overall run-time complexity should be O(log(min(m, n))), where m and n are the lengths of the two arrays. Input - Two non-empty sorted numpy arrays `nums1` and `nums2`. Output - A float value representing the median of the two sorted arrays. Constraints - The arrays\' length can vary but they will have at least one element each (1 ≤ |nums1|, |nums2| ≤ 10^5). - The function should handle both even and odd combined lengths of the arrays. Examples ```python >>> import numpy as np >>> median_of_two_sorted_arrays(np.array([1, 3]), np.array([2])) 2.0 >>> median_of_two_sorted_arrays(np.array([1, 2]), np.array([3, 4])) 2.5 >>> median_of_two_sorted_arrays(np.array([0, 0]), np.array([0, 0])) 0.0 >>> median_of_two_sorted_arrays(np.array([1, 3]), np.array([2, 7])) 2.5 >>> median_of_two_sorted_arrays(np.array([1]), np.array([2, 3, 4, 5, 6])) 3.5 ```","solution":"import numpy as np def median_of_two_sorted_arrays(nums1: np.ndarray, nums2: np.ndarray) -> float: Finds the median of two sorted arrays. :param nums1: First sorted numpy array. :param nums2: Second sorted numpy array. :return: Median value as a float. def find_kth_smallest(nums1, start1, nums2, start2, k): if start1 >= len(nums1): return nums2[start2 + k - 1] if start2 >= len(nums2): return nums1[start1 + k - 1] if k == 1: return min(nums1[start1], nums2[start2]) mid1 = float(\'inf\') if start1 + k // 2 - 1 >= len(nums1) else nums1[start1 + k // 2 - 1] mid2 = float(\'inf\') if start2 + k // 2 - 1 >= len(nums2) else nums2[start2 + k // 2 - 1] if mid1 < mid2: return find_kth_smallest(nums1, start1 + k // 2, nums2, start2, k - k // 2) else: return find_kth_smallest(nums1, start1, nums2, start2 + k // 2, k - k // 2) total_length = len(nums1) + len(nums2) if total_length % 2 == 1: return find_kth_smallest(nums1, 0, nums2, 0, total_length // 2 + 1) else: return (find_kth_smallest(nums1, 0, nums2, 0, total_length // 2) + find_kth_smallest(nums1, 0, nums2, 0, total_length // 2 + 1)) / 2"},{"question":"# Word Frequency Tracker You are required to develop a class `WordFrequencyTracker` that efficiently tracks the frequency of words added to it and allows querying the most frequent word. Class Definition ```python class WordFrequencyTracker: def __init__(self) -> None: Initialize the WordFrequencyTracker with an empty structure. pass def add_word(self, word: str) -> None: Add a word to the tracker or increment its frequency if it already exists. pass def most_frequent_word(self) -> str: Returns the word with the highest frequency. If there are multiple words with the same frequency, return the lexicographically smallest word. pass ``` # Requirements 1. **Initialization**: The `__init__` method should initialize any data structures required to maintain word counts effectively. 2. **add_word**: Implement a method to add a word to the tracker. If the word is already present, increment its frequency. 3. **most_frequent_word**: Implement a method to return the word that has the highest frequency. If there are multiple words with the same highest frequency, return the one that comes first lexicographically. # Constraints * Words are non-empty strings consisting of lowercase English letters. * You may assume the word lengths provided in `add_word` will be manageable within typical constraints. * The container should handle up to 1,000,000 unique words efficiently. Example Usage: ```python tracker = WordFrequencyTracker() tracker.add_word(\\"apple\\") tracker.add_word(\\"banana\\") tracker.add_word(\\"apple\\") print(tracker.most_frequent_word()) # Output: \\"apple\\" tracker.add_word(\\"banana\\") tracker.add_word(\\"banana\\") print(tracker.most_frequent_word()) # Output: \\"banana\\" tracker.add_word(\\"cherry\\") tracker.add_word(\\"cherry\\") tracker.add_word(\\"cherry\\") tracker.add_word(\\"apple\\") print(tracker.most_frequent_word()) # Output: \\"cherry\\" ``` # Notes * Ensure your implementation handles all edge cases and error scenarios effectively. * The operations should perform efficiently within the constraints and context provided. * Include sufficient documentation and method-level comments to explain your logic and decisions.","solution":"class WordFrequencyTracker: def __init__(self) -> None: Initialize the WordFrequencyTracker with an empty dictionary to store word frequencies and a string variable to keep track of the most frequent word. self.word_counts = {} self.most_frequent = \\"\\" def add_word(self, word: str) -> None: Add a word to the tracker or increment its frequency if it already exists. if word in self.word_counts: self.word_counts[word] += 1 else: self.word_counts[word] = 1 # Update most frequent word if necessary if (self.most_frequent == \\"\\" or self.word_counts[word] > self.word_counts[self.most_frequent] or (self.word_counts[word] == self.word_counts[self.most_frequent] and word < self.most_frequent)): self.most_frequent = word def most_frequent_word(self) -> str: Returns the word with the highest frequency. If there are multiple words with the same frequency, return the lexicographically smallest word. return self.most_frequent"},{"question":"# Longest Increasing Subsequence with Constraints **Context**: As a software engineer, you are working on a data analysis task involving sequence comparison. Specifically, you need to determine the length of the longest increasing subsequence within a list of integers, with additional constraints on whether subsequences can include repeated elements or not. **Objective**: Implement the function `longest_increasing_subsequence` which takes an array of integers and a boolean flag that determines if repeated elements are allowed in the subsequence. # Requirements 1. **Input**: - An array `arr` of `n` integers where `1 ≤ n ≤ 10^4`. - A boolean flag `allow_repeats`. 2. **Output**: - An integer representing the length of the longest increasing subsequence. If `allow_repeats` is set to True, repeated elements can be included in the subsequence. 3. **Constraints**: - The code must handle edge cases like arrays with only one element or duplicate elements. # Function Signature ```python from typing import List def longest_increasing_subsequence(arr: List[int], allow_repeats: bool) -> int: pass ``` # Example ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18], False) == 4 # subsequence: [2, 3, 7, 18] assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18], True) == 4 # subsequence: [2, 3, 7, 18] assert longest_increasing_subsequence([10, 10, 10, 10], False) == 1 # subsequence: [10] assert longest_increasing_subsequence([10, 10, 10, 10], True) == 4 # subsequence: [10, 10, 10, 10] assert longest_increasing_subsequence([3, 10, 2, 1, 20], False) == 3 # subsequence: [3, 10, 20] assert longest_increasing_subsequence([3, 10, 2, 1, 20], True) == 3 # subsequence: [3, 10, 20] assert longest_increasing_subsequence([], True) == 0 # Empty array ``` # Implementation Notes - Develop a solution that efficiently handles the constraints, ideally in O(n log n) time complexity. - Take care to manage edge cases, including single-element arrays and arrays with only duplicate values. - Ensure the solution is robust to variations in input size and content, from very small up to the specified upper limit.","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int], allow_repeats: bool) -> int: Returns the length of the longest increasing subsequence. If allow_repeats is True, repeated elements can be included in the subsequence. if not arr: return 0 if allow_repeats: dp = [] for num in arr: if not dp or num >= dp[-1]: dp.append(num) else: # Find the first number larger than num and replace it idx = bisect.bisect_right(dp, num) dp[idx] = num return len(dp) else: dp = [] for num in arr: idx = bisect.bisect_left(dp, num) if idx == len(dp): dp.append(num) else: dp[idx] = num return len(dp)"},{"question":"# Coding Assessment Question Context You are part of a team developing software for a logistics company. One of the key features involves tracking the paths of delivery trucks and determining whether their paths intersect with one another. A critical component of this feature is detecting intersections between straight-line paths represented by two points in a 2D plane. Problem Statement **Task**: Implement a `do_paths_intersect` function in Python that determines if two given paths intersect. Each path is represented by a pair of points (start and end) in a 2D plane. * **Function Specification**: - **Function**: `do_paths_intersect` - **Input**: Four tuples, each containing two integers `(x, y)`, representing the coordinates of the start and end points of two paths, respectively: `(x1, y1), (x2, y2), (x3, y3), (x4, y4)`. - **Output**: A boolean value `True` if the paths intersect and `False` otherwise. * **Constraints**: - All inputs are integers. - The coordinates can be negative and positive values. * **Performance Requirements**: - The solution should evaluate path intersections in O(1) time. Example Usage ```python def do_paths_intersect(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool: >>> do_paths_intersect((0, 0), (2, 2), (0, 2), (2, 0)) True >>> do_paths_intersect((0, 0), (1, 1), (1, 2), (2, 3)) False >>> do_paths_intersect((1, 1), (3, 3), (2, 2), (4, 4)) True >>> do_paths_intersect((0, 0), (0, 4), (1, 1), (1, 5)) False def orientation(p: tuple, q: tuple, r: tuple) -> int: Determines the orientation of the triplet (p, q, r). Returns: 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 return 1 if val > 0 else 2 def on_segment(p: tuple, q: tuple, r: tuple) -> bool: Given three collinear points p, q, r, checks if point q lies on line segment pr if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]): return True return False o1 = orientation(p1, p2, p3) o2 = orientation(p1, p2, p4) o3 = orientation(p3, p4, p1) o4 = orientation(p3, p4, p2) # General case if o1 != o2 and o3 != o4: return True # Special Cases # p1, p2 and p3 are collinear and p3 lies on segment p1p2 if o1 == 0 and on_segment(p1, p3, p2): return True # p1, p2 and p4 are collinear and p4 lies on segment p1p2 if o2 == 0 and on_segment(p1, p4, p2): return True # p3, p4 and p1 are collinear and p1 lies on segment p3p4 if o3 == 0 and on_segment(p3, p1, p4): return True # p3, p4 and p2 are collinear and p2 lies on segment p3p4 if o4 == 0 and on_segment(p3, p2, p4): return True return False # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"def do_paths_intersect(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool: Determines if two paths intersect. Each path is represented by two points in a 2D plane. :param p1: (x1, y1) Start point of the first path :param p2: (x2, y2) End point of the first path :param p3: (x3, y3) Start point of the second path :param p4: (x4, y4) End point of the second path :return: True if the paths intersect, False otherwise. def orientation(p: tuple, q: tuple, r: tuple) -> int: Determines the orientation of the triplet (p, q, r). Returns: 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 return 1 if val > 0 else 2 def on_segment(p: tuple, q: tuple, r: tuple) -> bool: Given three collinear points p, q, r, checks if point q lies on line segment pr if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]): return True return False o1 = orientation(p1, p2, p3) o2 = orientation(p1, p2, p4) o3 = orientation(p3, p4, p1) o4 = orientation(p3, p4, p2) # General case if o1 != o2 and o3 != o4: return True # Special Cases # p1, p2 and p3 are collinear and p3 lies on segment p1p2 if o1 == 0 and on_segment(p1, p3, p2): return True # p1, p2 and p4 are collinear and p4 lies on segment p1p2 if o2 == 0 and on_segment(p1, p4, p2): return True # p3, p4 and p1 are collinear and p1 lies on segment p3p4 if o3 == 0 and on_segment(p3, p1, p4): return True # p3, p4 and p2 are collinear and p2 lies on segment p3p4 if o4 == 0 and on_segment(p3, p2, p4): return True return False"},{"question":"# Coding Assessment Question # Context You are developing a logistics management system for a shipping company. The company\'s operations involve managing and routing shipments across multiple locations, each represented by a unique identifier. The system must be able to determine the shortest route between two locations using a variety of transportation options that might have different costs and times. # Problem Statement Write a Python function `find_shortest_route(locations: list[str], routes: list[tuple[str, str, float]], start: str, end: str) -> list[str]` to determine the shortest path between two locations using Dijkstra\'s algorithm. The function should return the shortest path as a list of location identifiers. # Function Signature ```python def find_shortest_route(locations: list[str], routes: list[tuple[str, str, float]], start: str, end: str) -> list[str]: ``` # Input - `locations (list[str])`: A list of location identifiers. - `routes (list[tuple[str, str, float]])`: A list of tuples representing the routes between locations. Each tuple consists of: - `start_location (str)`: The identifier of the starting location. - `end_location (str)`: The identifier of the ending location. - `cost (float)`: The cost associated with taking this route. - `start (str)`: The identifier of the starting location for the path. - `end (str)`: The identifier of the ending location for the path. # Output - `result (list[str])`: A list of location identifiers representing the shortest path from the starting location to the ending location. If no path exists, return an empty list. # Constraints - Each route has a non-negative cost. - `start` and `end` are valid location identifiers within `locations`. # Performance Requirements - Your implementation should efficiently handle up to 500 locations and 2000 routes. - Aim for optimal performance within the constraints provided. # Example Usage ```python locations = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] routes = [ (\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 2.5), (\\"C\\", \\"D\\", 1) ] start = \\"A\\" end = \\"D\\" result = find_shortest_route(locations, routes, start, end) # Expected result: [\\"A\\", \\"C\\", \\"D\\"] ``` # Example Implementation ```python import heapq def find_shortest_route(locations: list[str], routes: list[tuple[str, str, float]], start: str, end: str) -> list[str]: # Create a graph graph = {location: [] for location in locations} for start_location, end_location, cost in routes: graph[start_location].append((end_location, cost)) graph[end_location].append((start_location, cost)) # Assuming bidirectional routes # Initialize data structures queue = [(0, start, [])] visited = set() min_cost = {location: float(\'inf\') for location in locations} min_cost[start] = 0 # Dijkstra\'s algorithm while queue: current_cost, current_location, path = heapq.heappop(queue) if current_location in visited: continue path = path + [current_location] if current_location == end: return path visited.add(current_location) for neighbor, cost in graph[current_location]: if neighbor not in visited: old_cost = min_cost[neighbor] new_cost = current_cost + cost if new_cost < old_cost: min_cost[neighbor] = new_cost heapq.heappush(queue, (new_cost, neighbor, path)) return [] # Test the function with example usage result = find_shortest_route([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 2.5), (\\"C\\", \\"D\\", 1)], \\"A\\", \\"D\\") print(result) # Output should be [\\"A\\", \\"C\\", \\"D\\"] ```","solution":"import heapq def find_shortest_route(locations: list[str], routes: list[tuple[str, str, float]], start: str, end: str) -> list[str]: Determines the shortest route between two locations using Dijkstra\'s algorithm. Args: locations (list[str]): A list of location identifiers. routes (list[tuple[str, str, float]]): A list of tuples representing the routes between locations. Each tuple consists of a start location, end location, and cost. start (str): The identifier of the starting location. end (str): The identifier of the ending location. Returns: list[str]: The shortest path from start to end as a list of location identifiers. If no path exists, returns an empty list. # Create a graph graph = {location: [] for location in locations} for start_location, end_location, cost in routes: graph[start_location].append((end_location, cost)) graph[end_location].append((start_location, cost)) # Assuming bidirectional routes # Initialize data structures queue = [(0, start, [])] visited = set() min_cost = {location: float(\'inf\') for location in locations} min_cost[start] = 0 # Dijkstra\'s algorithm while queue: current_cost, current_location, path = heapq.heappop(queue) if current_location in visited: continue path = path + [current_location] if current_location == end: return path visited.add(current_location) for neighbor, cost in graph[current_location]: if neighbor not in visited: old_cost = min_cost[neighbor] new_cost = current_cost + cost if new_cost < old_cost: min_cost[neighbor] = new_cost heapq.heappush(queue, (new_cost, neighbor, path)) return [] # Test the function with example usage result = find_shortest_route([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 2.5), (\\"C\\", \\"D\\", 1)], \\"A\\", \\"D\\") print(result) # Output should be [\\"A\\", \\"C\\", \\"D\\"]"},{"question":"# Coding Question: Custom Power Function Context In many programming challenges, an efficient custom implementation of mathematical functions is required. One such function is the power function, which raises one number to the power of another. You are tasked with designing a custom implementation of the `power()` function without using any built-in power functions. Problem Statement Write a function `power(base: float, exponent: int) -> float` that returns the result of raising the `base` to the power of the `exponent`. This will test your understanding of loops and handling edge cases. Input - A single float value `base`. - A single integer value `exponent`. Output - A float value representing `base` raised to the power of `exponent`. Constraints - Your implementation must not use any library functions like `math.pow` or the `**` operator. - Handle edge cases such as exponent being zero, positive, and negative. - Manage large and small floating-point numbers to prevent floating-point inaccuracies. Example ```python def power(base: float, exponent: int) -> float: # Your implementation here # Examples to test your solution print(power(2.0, 3)) # Expected output: 8.0 print(power(2.0, -3)) # Expected output: 0.125 print(power(2.0, 0)) # Expected output: 1.0 print(power(0.0, 5)) # Expected output: 0.0 print(power(5.0, 1)) # Expected output: 5.0 print(power(100.0, -2)) # Expected output: 0.0001 ``` Additional Requirements - Your solution must have a time complexity of O(|exponent|). - Include edge cases in your testing to ensure the function behaves correctly with different input ranges.","solution":"def power(base: float, exponent: int) -> float: Returns the result of raising base to the power of exponent. Parameters: base (float): The base number. exponent (int): The exponent (can be negative, zero, or positive). Returns: float: The result of base raised to the power of exponent. if exponent == 0: return 1.0 if base == 0: return 0.0 abs_exponent = abs(exponent) result = 1.0 for _ in range(abs_exponent): result *= base if exponent < 0: return 1 / result else: return result"},{"question":"# Problem Statement You are given a binary tree with integer values. Your task is to find the sum of all nodes that have at least one child. # Function Signature ```python def sum_of_nodes_with_children(root: Optional[TreeNode]) -> int: Calculate the sum of all nodes that have at least one child in a binary tree. Parameters: - root (TreeNode): The root of the binary tree. Returns: - int: The sum of all nodes with at least one child. pass ``` # Input - `root`: The root node of the binary tree, which can be `None` (representing an empty tree). - Each node in the tree is a `TreeNode` object. # Output - An integer representing the sum of all nodes that have at least one child. # Constraints - The number of nodes in the tree is between (0) and (10^4). - The value of each node is between (-10^5) and (10^5). # Example ```python # Define the TreeNode class for constructing the binary tree. class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right # Example 1: # Constructing the following Binary Tree: # 5 # / # 3 8 # / # 1 4 12 root = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)), TreeNode(8, None, TreeNode(12))) print(sum_of_nodes_with_children(root)) # Output: 5 + 3 + 8 = 16 # Example 2: # Constructing an empty tree root = None print(sum_of_nodes_with_children(root)) # Output: 0 # Example 3: # Constructing the following Binary Tree: # 10 # # 20 root = TreeNode(10, None, TreeNode(20)) print(sum_of_nodes_with_children(root)) # Output: 10 ``` # Notes - Nodes that do not have any children should not be included in the sum. - Be sure to handle the edge case where the tree is empty.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_nodes_with_children(root: TreeNode) -> int: Calculate the sum of all nodes that have at least one child in a binary tree. Parameters: - root (TreeNode): The root of the binary tree. Returns: - int: The sum of all nodes with at least one child. if root is None: return 0 sum_with_children = 0 if root.left or root.right: sum_with_children += root.value if root.left: sum_with_children += sum_of_nodes_with_children(root.left) if root.right: sum_with_children += sum_of_nodes_with_children(root.right) return sum_with_children"},{"question":"# Matrix Diagonal Sum Calculator Background In matrix computations, certain problems require the sum of elements along the diagonals of a matrix. This task involves interpreting and navigating through the matrix data structure to retrieve and process specific elements. Problem Statement Write a function `diagonal_sum` that calculates the sum of both the main diagonal and the anti-diagonal of a square matrix. Ensure the function handles various integer inputs and works efficiently with large matrices. ```python def diagonal_sum(matrix: list[list[int]]) -> tuple[int, int]: Computes and returns the sum of the main diagonal and the anti-diagonal of a square matrix. The main diagonal runs from the top-left to the bottom-right of the matrix. The anti-diagonal runs from the top-right to the bottom-left of the matrix. Examples: >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 15) >>> diagonal_sum([[5, 1], [2, 3]]) (8, 3) >>> diagonal_sum([[1]]) (1, 1) >>> diagonal_sum([[3, 2, 1, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) (36, 20) pass ``` # Input - `matrix` (list[list[int]]): A square matrix (2D list) containing integer values. # Output - `tuple[int, int]`: A tuple where the first integer is the sum of the main diagonal, and the second integer is the sum of the anti-diagonal. # Constraints - The input matrix will always be square (i.e., the number of rows will be equal to the number of columns). - The matrix will only contain integer values. - The size of the matrix can vary from 1x1 to 1000x1000. # Requirements - Ensure efficiency in handling large matrices. - Handle edge cases, including the smallest matrix (1x1) and matrices with repeated or negative values. - Test the function thoroughly with varied and edge case scenarios. # Testing Assume a testing framework similar to `doctest`. Comprehensive coverage of all potential edge cases and typical input scenarios is expected for robust functionality. Good luck, and happy coding!","solution":"def diagonal_sum(matrix: list[list[int]]) -> tuple[int, int]: Computes and returns the sum of the main diagonal and the anti-diagonal of a square matrix. The main diagonal runs from the top-left to the bottom-right of the matrix. The anti-diagonal runs from the top-right to the bottom-left of the matrix. n = len(matrix) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) anti_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) return (main_diagonal_sum, anti_diagonal_sum)"},{"question":"# Problem Statement You are tasked to write a function `largest_island_area(grid: List[List[int]]) -> int` that calculates the largest island area in a given grid. An island is defined as a group of connected `1s` (connected vertically and horizontally, not diagonally). The function must use a recursive Depth-First Search (DFS) algorithm to explore and calculate the area of each island. # Function Signature: ```python def largest_island_area(grid: List[List[int]]) -> int: ``` # Input: 1. `grid`: A two-dimensional list of integers representing the grid. Only `0s` and `1s` will be present where `1` represents land and `0` represents water. # Output: - Returns an integer that represents the area of the largest island found in the grid. The area is measured by the number of connected `1s`. # Constraints: - The grid will always be a rectangular matrix (m x n) where `1 <= m, n <= 50`. - There will be no cells with values other than `0` and `1`. # Example: ```python grid = [ [0, 1, 0, 0], [1, 1, 0, 1], [0, 1, 0, 1], [0, 0, 0, 1] ] print(largest_island_area(grid)) # Output: 4 ``` In the example above, the largest island has an area of 4 cells (the four `1`s connected in the middle of the grid). # Note: - The function should utilize a recursive DFS approach to explore all cells and determine the areas of islands. - Ensure you handle grid boundaries correctly and avoid counting the same cell more than once. - You can modify the input grid during the processing as long as the final area count is correct. Consider marking visited cells to avoid revisiting.","solution":"from typing import List def largest_island_area(grid: List[List[int]]) -> int: def dfs(x: int, y: int) -> int: # If out of bounds or on water, return 0 if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 (water) grid[x][y] = 0 # Recursively get the area of the island area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"**Introduction**: You are given a 2D grid of characters and a list of words. Your task is to find all the words in the grid that can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. This problem assesses your ability to implement graph traversal algorithms such as DFS or BFS. **Problem**: Implement the method `find_words(self, words: List[str]) -> List[str]` within the `Grid` class. The method should return a list of words that are found in the grid. **Input**: - An instance of the `Grid` class, which has been initialized with a 2D list of characters. - A list of strings `words`, each representing a word to search for in the grid. **Output**: - A list of strings, each word from the input list that can be formed by adjacent cells in the grid. **Constraints**: - The grid contains at most 100x100 characters. - Each word in the list `words` has a length between 1 and 10 characters. - The number of words in the `words` list is at most 500. **Example**: ```python >>> grid = Grid([ ... [\'o\', \'a\', \'a\', \'n\'], ... [\'e\', \'t\', \'a\', \'e\'], ... [\'i\', \'h\', \'k\', \'r\'], ... [\'i\', \'f\', \'l\', \'v\'] ... ]) >>> words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] >>> grid.find_words(words) [\'oath\', \'eat\'] ``` **Requirements**: - Ensure your solution handles edge cases such as an empty grid, a grid where no words can be matched, or a grid where all words can be matched. - Optimize for time and space complexity to handle the upper constraints. **Additional**: - You may use helper methods or additional classes if needed. - You must not modify the grid and words list; the grid may be read-only during traversal.","solution":"from typing import List class Grid: def __init__(self, grid: List[List[str]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def find_words(self, words: List[str]) -> List[str]: def dfs(r, c, word, index, visited): if index == len(word): return True if r < 0 or r >= self.rows or c < 0 or c >= self.cols or (r, c) in visited or self.grid[r][c] != word[index]: return False visited.add((r, c)) found = (dfs(r+1, c, word, index+1, visited) or dfs(r-1, c, word, index+1, visited) or dfs(r, c+1, word, index+1, visited) or dfs(r, c-1, word, index+1, visited)) visited.remove((r, c)) return found found_words = [] for word in words: word_found = False for r in range(self.rows): for c in range(self.cols): if dfs(r, c, word, 0, set()): found_words.append(word) word_found = True break if word_found: break return found_words"},{"question":"# Problem Statement Implement the following operations of a Linked List using the provided `LinkedList` class template: 1. **Add Node At Beginning**: The method, `add_at_beginning`, should add a new node with given data at the beginning of the linked list. 2. **Add Node At End**: The method, `add_at_end`, should add a new node with given data at the end of the linked list. 3. **Remove Node**: The method, `remove_node`, should remove the first node with the specified data from the linked list. 4. **Reverse LinkedList**: The method, `reverse_list`, should reverse the linked list. Input Format - You will be provided a sequence of operations to perform on the linked list. - Each operation will be in one of the following formats: - `add_at_beginning <value>` - `add_at_end <value>` - `remove_node <value>` - `reverse_list` Output Format - Print the linked list after all operations are performed. The linked list should be represented as a space-separated sequence of integers. Constraints - The sequence of operations will contain at most 10^5 commands. - The value associated with any operation will be an integer in the range of -10^9 to 10^9. Functions to Implement ```python class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def add_at_beginning(self, value: int) -> None: pass def add_at_end(self, value: int) -> None: pass def remove_node(self, value: int) -> None: pass def reverse_list(self) -> None: pass ``` Example ```python # Initialize the linked list linked_list = LinkedList() # Perform operations linked_list.add_at_beginning(10) linked_list.add_at_end(20) linked_list.add_at_beginning(30) linked_list.add_at_end(40) linked_list.remove_node(20) linked_list.reverse_list() # Print the final state of the linked list print(linked_list) # Output: 40 10 30 ``` Note: The exact output may depend on intermediate steps in the `add_at_beginning`, `add_at_end`, `remove_node`, and `reverse_list` methods. The final output should represent the state of the linked list after all operations have been performed.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def add_at_beginning(self, value: int) -> None: new_node = Node(value) new_node.next = self.head self.head = new_node def add_at_end(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def remove_node(self, value: int) -> None: current = self.head previous = None while current and current.data != value: previous = current current = current.next if not current: return if not previous: self.head = current.next else: previous.next = current.next def reverse_list(self) -> None: previous = None current = self.head while current: next_node = current.next current.next = previous previous = current current = next_node self.head = previous def __str__(self): result = [] current = self.head while current: result.append(str(current.data)) current = current.next return \' \'.join(result)"},{"question":"# Coding Question: Implement a Cache Simulator with LRU Replacement Policy **Context**: A cache is a hardware or software component that stores data so that future requests for that data can be served faster. One common cache replacement policy is Least Recently Used (LRU), which discards the least recently used items first. **Challenge**: Your task is to implement a `CacheSimulator` class that simulates a cache with a Least Recently Used (LRU) replacement policy. **Function Signature**: ```python class CacheSimulator: def __init__(self, capacity: int) -> None: pass def refer(self, key: int) -> None: pass def display(self) -> list[int]: pass ``` **Detailed Requirements**: 1. **Initialization**: The constructor should accept a single parameter: - `capacity`: An integer representing the maximum number of items that the cache can hold. 2. **Refer Function**: - You should implement the `refer` method to refer to a specific key in the cache. - If the key is already present, it should move to the most recently used position. - If the key is not present and the cache has reached its capacity, it should remove the least recently used item before adding the new key to the cache. 3. **Display Function**: - The `display` method should return a list of keys in the cache, ordered from the most recently used to the least recently used. **Constraints**: - All keys will be non-negative integers. - Capacity will be a positive integer. **Example**: ```python >>> cache = CacheSimulator(4) >>> cache.refer(1) >>> cache.refer(2) >>> cache.refer(3) >>> cache.refer(1) >>> cache.refer(4) >>> cache.refer(5) >>> print(cache.display()) [5, 4, 1, 3] ``` **Explanation**: - When you refer key 1, 2, and 3, they are added to the cache. - Referring key 1 again moves it to the most recently used position. - Adding key 4 to the cache makes the cache full. - Referring key 5 removes the least recently used key (which is key 2) and adds key 5 to the cache. **Performance Requirements**: - The `refer` method should operate within practical time limits for typical usage scenarios, ideally within O(1) time complexity for both insertion and deletion. - Memory usage should be efficient and within reasonable limits considering the cache capacity. Your implementation should effectively manage the cache while adhering to the LRU policy to ensure optimized retrieval times for frequently accessed data.","solution":"from collections import OrderedDict class CacheSimulator: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = OrderedDict() def refer(self, key: int) -> None: if key in self.cache: self.cache.move_to_end(key) else: if len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = None self.cache.move_to_end(key) def display(self) -> list[int]: return list(self.cache.keys())[::-1]"},{"question":"# Problem: Vacation Destination Comparison Tool You are provided with multiple JSON files, each containing data about different vacation destinations. Each file includes details such as the name of the destination, average temperature, average rainfall, and number of tourist attractions. Your task is to create a Python function that compares these destinations based on user-specified criteria and returns the best destination. Your function should allow the user to specify one or more criteria for comparison: 1. **Average Temperature**: Prefer destinations with a temperature closest to a user-defined target. 2. **Average Rainfall**: Prefer destinations with the least average rainfall. 3. **Number of Attractions**: Prefer destinations with the most tourist attractions. # Input - A list of file paths (strings): Each file path points to a JSON file containing data about a destination. - A dictionary with keys as criteria (`temperature`, `rainfall`, `attractions`) and values as the target for that criteria (e.g., target temperature). # Output - A string containing the name of the best destination based on the specified criteria. # Constraints - All input JSON files will be properly formatted. - At least one criterion will be provided in the input dictionary. - Evaluate all criteria if more than one is provided and weight them equally. # Example Usage ```python file_paths = [\'paris.json\', \'london.json\', \'new_york.json\'] criteria = {\'temperature\': 25, \'rainfall\': None, \'attractions\': None} best_destination = find_best_vacation_destination(file_paths, criteria) print(best_destination) # Expected output: \\"Paris\\" ``` # Example JSON Content For a file named `paris.json`: ```json { \\"name\\": \\"Paris\\", \\"average_temperature\\": 20, \\"average_rainfall\\": 50, \\"number_of_attractions\\": 100 } ``` # Implementation Tips - Parse each JSON file to extract the relevant information for each destination. - Use a scoring system to evaluate each destination based on the criteria. - Handle missing criteria by ignoring them in the comparison. - Ensure your solution is efficient, especially when handling a large number of destinations.","solution":"import json def load_destination_data(file_path): with open(file_path, \'r\') as file: return json.load(file) def calculate_score(destination, criteria, user_target): score = 0 if \'temperature\' in criteria and user_target[\'temperature\'] is not None: score -= abs(destination[\'average_temperature\'] - user_target[\'temperature\']) if \'rainfall\' in criteria and user_target[\'rainfall\'] is not None: score -= destination[\'average_rainfall\'] if \'attractions\' in criteria and user_target[\'attractions\'] is not None: score += destination[\'number_of_attractions\'] return score def find_best_vacation_destination(file_paths, criteria): best_destination = None best_score = float(\'-inf\') for file_path in file_paths: destination = load_destination_data(file_path) score = calculate_score(destination, criteria, criteria) if score > best_score: best_score = score best_destination = destination[\'name\'] return best_destination"},{"question":"# Binary Search Tree Insertion and Depth Calculation Challenge In this task, you will demonstrate your understanding of binary search tree (BST) operations by implementing the insertion of nodes and calculating the depth of the tree. Specifically, you will focus on inserting values into a BST and determining the depth of the resulting tree to ensure a solid grasp of BST properties and traversal techniques. Objective Implement a binary search tree and provide a way to determine the depth of the tree after inserting a series of values. Your implementation should handle the insertion process correctly and calculate the maximum depth of the tree. Function Signature ```python class TreeNode: def __init__(self, val: int = 0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: pass def get_depth(self) -> int: pass ``` Expected Input and Output * **Input**: A sequence of integers to be inserted into the BST, e.g., `[5, 3, 8, 1, 4]`. * **Output**: The `get_depth` function should return an integer representing the maximum depth of the tree after all insertions, e.g., the depth is `3` for the given example. Constraints * All integers are unique. * Your solution should handle lists with up to 10,000 elements efficiently. * Return the correct depth even for large inputs to demonstrate efficiency and correctness. Performance Requirements * Insertion Time Complexity: O(log n) on average (due to the properties of BST). * Depth Calculation Time Complexity: O(n). Additional Requirements 1. Use error handling to manage cases where non-integer values are provided to the `insert` method. 2. Ensure the `get_depth` function computes the depth of the tree dynamically after all insertions. 3. Do not use any existing tree libraries. Example Code Ensure your solution passes the following test cases: ```python # Test cases bst = BinarySearchTree() values1 = [5, 3, 8, 1, 4] for val in values1: bst.insert(val) assert bst.get_depth() == 3 bst = BinarySearchTree() values2 = [10, 5, 15, 2, 7, 12, 20] for val in values2: bst.insert(val) assert bst.get_depth() == 3 bst = BinarySearchTree() values3 = [1, 2, 3, 4, 5] for val in values3: bst.insert(val) assert bst.get_depth() == 5 bst = BinarySearchTree() values4 = [] for val in values4: bst.insert(val) assert bst.get_depth() == 0 bst = BinarySearchTree() values5 = [42] for val in values5: bst.insert(val) assert bst.get_depth() == 1 try: bst = BinarySearchTree() bst.insert(\\"ABC\\") except ValueError: print(\\"Error caught successfully for non-integer value\\") ``` Context Binary search trees are a fundamental data structure in computer science, especially useful for efficient searching, insertion, and retrieval operations. Understanding how to manipulate and analyze BSTs is key to mastering data organization and optimization in algorithms.","solution":"class TreeNode: def __init__(self, val: int = 0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not isinstance(val, int): raise ValueError(\\"Only integer values are allowed.\\") if self.root is None: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node: TreeNode, val: int) -> None: if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def get_depth(self) -> int: return self._get_depth_recursive(self.root) def _get_depth_recursive(self, node: TreeNode) -> int: if node is None: return 0 left_depth = self._get_depth_recursive(node.left) right_depth = self._get_depth_recursive(node.right) return max(left_depth, right_depth) + 1"},{"question":"# Problem Statement You are given an undirected graph represented by a list of edges, where each edge connects two nodes. Your task is to implement a function `is_tree` that determines whether the graph is a tree. A tree is a connected graph with no cycles and exactly `n-1` edges, where `n` is the number of nodes in the graph. # Function Definition ```python def is_tree(edges: list, n: int) -> bool: :param edges: List of tuples, each representing an edge between two nodes. :param n: Integer representing the number of nodes in the graph. :return: Boolean value indicating whether the graph is a tree. ``` # Input * `edges` is a list of tuples, each containing two integers (0 ≤ edges[i][0], edges[i][1] < n). * `n` is an integer representing the number of nodes in the graph (1 ≤ n ≤ 10^5). # Output * Return `True` if the graph is a tree, otherwise return `False`. # Constraints * Ensure that the solution works efficiently with a time complexity of O(n). # Performance Requirements * The function should correctly handle large input sizes. * Ensure the algorithm handles disconnected graphs and checks for cycles appropriately. # Example Example 1: ```python edges = [(0, 1), (0, 2), (1, 3), (1, 4)] n = 5 # Output: True ``` Example 2: ```python edges = [(0, 1), (0, 2), (1, 2)] n = 3 # Output: False ``` # Note * The graph is undirected, meaning an edge (x, y) implies that there is an edge between nodes x and y as well as between nodes y and x. * Handle edge cases such as graphs with a single node or no edges properly.","solution":"def is_tree(edges, n): if n == 1: return True # A single node without edges is a tree if len(edges) != n - 1: return False # A tree must have exactly n-1 edges from collections import defaultdict, deque # Create the adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS or DFS to check if the graph is connected and has no cycles visited = set() q = deque([0]) # Start BFS from node 0 visited.add(0) while q: node = q.popleft() for neighbor in graph[node]: if neighbor in visited: continue visited.add(neighbor) q.append(neighbor) return len(visited) == n"},{"question":"# Principal Component Analysis (PCA) for Dimensionality Reduction Context You are working as a data scientist at a tech company focusing on pattern recognition. Your task is to reduce the dimensionality of a given dataset to facilitate faster pattern recognition and to eliminate noise. You decide to use Principal Component Analysis (PCA) to project the data to a lower-dimensional space. Objective Implement a PCA model from scratch to reduce the dimensions of the given dataset while retaining the variability in the data. Input Format 1. A matrix `X` of shape (m, n) representing m samples and n features. 2. An integer `k` representing the number of principal components to retain. Output Format 1. A matrix `Z` of shape (m, k) representing the transformed dataset with reduced dimensions. 2. A matrix `U` of shape (n, k) representing the top k eigenvectors (principal components). Constraints 1. Number of features `n` should be ≥ 1 and ≤ 100. 2. Number of samples `m` should be ≥ 10 and ≤ 20000. 3. The integer `k` should be ≤ min(m, n). # Function Signature ```python def pca(X: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray]: pass ``` # Example ```python X = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) k = 2 Z, U = pca(X, k) print(\\"Transformed dataset:\\", Z) print(\\"Top k eigenvectors:\\", U) ``` In this example, the function `pca` should output the transformed dataset and the top eigenvectors based on the given features and the chosen number of principal components. # Requirements Implement the core operational steps for PCA: 1. Center the dataset by subtracting the mean of each feature. 2. Compute the covariance matrix of the centered data. 3. Calculate the eigenvalues and eigenvectors of the covariance matrix. 4. Choose the top `k` eigenvectors corresponding to the largest eigenvalues. 5. Project the data onto the new k-dimensional subspace using the selected eigenvectors. Good luck!","solution":"import numpy as np from typing import Tuple def pca(X: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray]: Perform PCA on the dataset X to reduce its dimension to k. Parameters: X (np.ndarray): The input data matrix of shape (m, n) k (int): The number of principal components to retain Returns: Tuple[np.ndarray, np.ndarray]: Tuple containing - Z (np.ndarray): The transformed dataset of shape (m, k) - U (np.ndarray): The top k eigenvectors of shape (n, k) # Center the dataset by subtracting the mean of each feature X_meaned = X - np.mean(X, axis=0) # Compute the covariance matrix of the centered data covariance_matrix = np.cov(X_meaned, rowvar=False) # Calculate the eigenvalues and eigenvectors of the covariance matrix eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix) # Sort the eigenvectors by decreasing eigenvalues sorted_indices = np.argsort(eigenvalues)[::-1] sorted_eigenvectors = eigenvectors[:, sorted_indices] # Select the top k eigenvectors U = sorted_eigenvectors[:, :k] # Project the data onto the new k-dimensional subspace Z = np.dot(X_meaned, U) return Z, U"},{"question":"You have been given a function `calculate_fibonacci` that aims to return the n-th Fibonacci number using a basic iterative approach. Modify this function to add memoization in order to improve its performance, and to handle edge cases with input validation. # Requirements: 1. Add memoization to the function to store previously computed Fibonacci numbers. 2. Add input validation to ensure the input is a non-negative integer. If the input is invalid, raise a `ValueError` with the message \\"Input must be a non-negative integer\\". 3. Update the Docstring and test cases to reflect the added memoization and input validation. # Function Signature: ```python def calculate_fibonacci(n: int, memo=None) -> int: Calculate the n-th Fibonacci number using memoization. Parameters ---------- n : int The position in the Fibonacci sequence. memo : dict, optional A dictionary to store computed Fibonacci values. Default is None. Returns ------- int The n-th Fibonacci number. Raises ------ ValueError If the input is not a non-negative integer. Examples -------- >>> calculate_fibonacci(0) 0 >>> calculate_fibonacci(1) 1 >>> calculate_fibonacci(10) 55 >>> calculate_fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer pass ``` # Constraints: * The input `n` must be a non-negative integer. * The function should handle large values of `n` efficiently with the use of memoization. Implement this function and ensure it passes the given validation tests.","solution":"def calculate_fibonacci(n: int, memo=None) -> int: Calculate the n-th Fibonacci number using memoization. Parameters ---------- n : int The position in the Fibonacci sequence. memo : dict, optional A dictionary to store computed Fibonacci values. Default is None. Returns ------- int The n-th Fibonacci number. Raises ------ ValueError If the input is not a non-negative integer. Examples -------- >>> calculate_fibonacci(0) 0 >>> calculate_fibonacci(1) 1 >>> calculate_fibonacci(10) 55 >>> calculate_fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if memo is None: memo = {} if n in memo: return memo[n] if n == 0: result = 0 elif n == 1: result = 1 else: result = calculate_fibonacci(n - 1, memo) + calculate_fibonacci(n - 2, memo) memo[n] = result return result"},{"question":"# Question You are given a large matrix containing only integers. Your task is to write a function, `find_largest_submatrix`, that finds the largest submatrix (by area) that contains only 1s, and returns the dimensions of this submatrix. Function Signature ```python def find_largest_submatrix(matrix: List[List[int]]) -> Tuple[int, int]: ``` Parameters * `matrix`: A 2D list of integers (each integer is either 0 or 1) representing the matrix. Output * Returns a tuple consisting of two integers: the number of rows and columns of the largest submatrix containing only 1s. Description 1. Traverse the matrix to determine the possible submatrices that contain only 1s. 2. Identify the largest such submatrix by area and return its dimensions. 3. In case of multiple submatrices of the same maximum area, any of the maximal submatrices may be returned. Example ```python matrix = [ [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 0], [1, 1, 1, 0, 0], ] dimensions = find_largest_submatrix(matrix) print(dimensions) # Output should be (3, 4), or any other valid submatrix dimension ``` **Constraints**: - The matrix dimensions can be up to 200 x 200. - The function should be efficient in both time and space complexity. **Hints**: - Dynamic Programming might be useful here to keep track of the size of submatrices ending at each position. - Consider edge cases where the matrix might be entirely zeros or ones.","solution":"from typing import List, Tuple def find_largest_submatrix(matrix: List[List[int]]) -> Tuple[int, int]: if not matrix or not matrix[0]: return (0, 0) rows, cols = len(matrix), len(matrix[0]) max_area = 0 max_dims = (0, 0) dp = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): if matrix[r][c] == 1: if r == 0 or c == 0: dp[r][c] = 1 else: dp[r][c] = min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1 current_area = dp[r][c] ** 2 if current_area > max_area: max_area = current_area max_dims = (dp[r][c], dp[r][c]) return max_dims"},{"question":"# Question: File System Tree Navigation You are tasked with creating a function to navigate a simplified file system tree and return the size of a specified directory. The function should recursively calculate the total size of all files and subdirectories within the given directory. Function Signature: ```python def calculate_directory_size(file_system: dict, directory: str) -> int: Calculates the total size of the specified directory in the given file system tree. Args: file_system (dict): A dictionary representing the file system tree where keys are directory or file names and values are either another dictionary (for subdirectories) or an integer (for file sizes). directory (str): The name of the directory for which to calculate the total size. Returns: int: The total size of all files and subdirectories within the specified directory. Raises: ValueError: If the specified directory does not exist in the file system. ``` Input & Output Formats: - **Input**: - `file_system` is a dictionary representing the file system tree. - `directory` is a string representing the directory name for which to calculate the total size. - **Output**: An integer representing the total size of the specified directory. Constraints: - The file system tree can contain directories and files. - Directory contents are represented as dictionaries, and file sizes are represented as integers. - If the specified directory does not exist in the file system, raise a `ValueError` with the message \\"Directory not found.\\" Sample Input: ```python file_system = { \\"root\\": { \\"file1.txt\\": 100, \\"file2.txt\\": 200, \\"subdir1\\": { \\"file3.txt\\": 300, \\"file4.txt\\": 400, }, \\"subdir2\\": { \\"file5.txt\\": 500, } } } directory = \\"root\\" ``` Sample Output: ```python result = calculate_directory_size(file_system, \\"root\\") print(result) # Expected output: 1500 ``` Explanation: - The total size of \\"root\\" includes all its files and subdirectories: - `file1.txt` (100) + `file2.txt` (200) + `file3.txt` (300) + `file4.txt` (400) + `file5.txt` (500) = 1500. **Notes**: - The function should handle deeply nested directories recursively. - Assume the file system tree provided as the `file_system` dictionary is well-formed and does not contain circular references.","solution":"def calculate_directory_size(file_system: dict, directory: str) -> int: Calculates the total size of the specified directory in the given file system tree. Args: file_system (dict): A dictionary representing the file system tree where keys are directory or file names and values are either another dictionary (for subdirectories) or an integer (for file sizes). directory (str): The name of the directory for which to calculate the total size. Returns: int: The total size of all files and subdirectories within the specified directory. Raises: ValueError: If the specified directory does not exist in the file system. def size_helper(current_directory): total_size = 0 for item, value in current_directory.items(): if isinstance(value, dict): total_size += size_helper(value) else: total_size += value return total_size if directory not in file_system: raise ValueError(\\"Directory not found\\") return size_helper(file_system[directory])"},{"question":"# Question You are given a function `merge_sorted_arrays` that merges two sorted arrays into a single sorted array. However, merging more than two arrays is common in advanced programming scenarios, especially when implementing custom versions of merge algorithms such as those used in merge sort, multiway merge, or merging data from different sources in a balanced way. Implement a function named `merge_multiple_sorted_arrays` that merges `k` sorted arrays, each of which can have different lengths, into a single sorted array. # Requirements * **Function Signature**: `def merge_multiple_sorted_arrays(arrays: list[list[int | float]]) -> list[int | float]:` * **Parameters**: - `arrays`: A list of `k` lists, each containing sorted integers or floats. * **Returns**: A single sorted list containing all the elements from the input arrays. # Constraints 1. Each list in `arrays` will be sorted in non-decreasing order. 2. The total number of elements across all lists will not exceed 10^6. 3. The function should be implemented with a time complexity no worse than O(n log k), where `n` is the total number of elements, and `k` is the number of input arrays. # Example ```python arrays = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] print(merge_multiple_sorted_arrays(arrays)) # Output should be [1, 2, 3, 4, 5, 6, 7, 8, 9] arrays = [ [-10, -5, 0], [1, 2, 3], [4, 10, 20] ] print(merge_multiple_sorted_arrays(arrays)) # Output should be [-10, -5, 0, 1, 2, 3, 4, 10, 20] ``` # Implementation Guidelines * You can use a min-heap (priority queue) to keep track of the smallest elements across the lists to efficiently get the minimum element and proceed with merging. * Ensure that edge cases like empty lists and lists with different lengths are properly handled. * Prioritize readability and efficiency in your implementation.","solution":"import heapq def merge_multiple_sorted_arrays(arrays): Merges `k` sorted arrays into a single sorted array using a min-heap. Args: arrays (list of list of int/float): A list containing `k` sorted arrays. Returns: list of int/float: A single sorted list containing all elements from the input arrays. # Initialize the heap heap = [] # Populate the heap with the first element of each array along with the array index and element index for i, array in enumerate(arrays): if array: # Check if the array is not empty heapq.heappush(heap, (array[0], i, 0)) result = [] while heap: # Extract the smallest element from the heap val, arr_idx, elem_idx = heapq.heappop(heap) result.append(val) # If there is a next element in the same array, add it to the heap if elem_idx + 1 < len(arrays[arr_idx]): next_element = arrays[arr_idx][elem_idx + 1] heapq.heappush(heap, (next_element, arr_idx, elem_idx + 1)) return result"},{"question":"Problem: Morse Code Encoder and Decoder Morse code is a method used in telecommunication to encode text characters into sequences of dots and dashes, representing letters and numerals. Your task is to implement the encoding and decoding processes for Morse code. # Input 1. A string **mode** which will be either \\"encode\\" or \\"decode\\", indicating the operation to perform. 2. A string **text** (1 <= |text| <= 1000) to be encoded or decoded. The input string will consist of lowercase and uppercase letters, digits, and spaces for encoding, or dots (`.`), dashes (`-`), and spaces for decoding. # Output 1. A string denoting the encoded or decoded text. # Function Signature ```python def morse_code(mode: str, text: str) -> str: pass ``` # Constraints - For encoding, alphanumeric characters and spaces will be considered. - For decoding, assume the input is a valid Morse code sequence. # Examples Example 1: ```python mode = \\"encode\\" text = \\"HELLO WORLD\\" print(morse_code(mode, text)) # Output: .... . .-.. .-.. --- / .-- --- .-. .-.. -.. ``` Example 2: ```python mode = \\"decode\\" text = \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" print(morse_code(mode, text)) # Output: HELLO WORLD ``` # Notes 1. Use the following Morse code conventions for encoding: - A: .- K: -.- U: ..- 5: ..... - B: -... L: .-.. V: ...- 6: -.... - C: -.-. M: -- W: .-- 7: --... - D: -.. N: -. X: -..- 8: ---.. - E: . O: --- Y: -.-- 9: ----. - F: ..-. P: .--. Z: --.. 0: ----- - G: --. Q: --.- 1: .---- - H: .... R: .-. 2: ..--- - I: .. S: ... 3: ...-- - J: .--- T: - 4: ....- - A space character in text is represented by `/` in Morse code. 2. Implement separate encoding and decoding subroutines as part of your function to handle the respective modes efficiently. 3. Maintain the case sensitivity of the input text where applicable during encoding and decoding.","solution":"def morse_code(mode: str, text: str) -> str: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } REVERSE_MORSE_CODE_DICT = {value: key for key, value in MORSE_CODE_DICT.items()} REVERSE_MORSE_CODE_DICT[\'/\'] = \' \' if mode == \\"encode\\": encoded_text = \' \'.join(MORSE_CODE_DICT[char] if char != \' \' else \'/\' for char in text.upper()) return encoded_text elif mode == \\"decode\\": decoded_text = \'\'.join(REVERSE_MORSE_CODE_DICT[code] for code in text.split(\' \')) return decoded_text else: raise ValueError(\\"Invalid mode. Only \'encode\' or \'decode\' are supported.\\")"},{"question":"# Your Task You are given a collection of products, each with a name and a price. Your task is to implement a system that allows adding, removing, and querying products based on various criteria. # Detailed Requirements 1. **Product Management**: * Implement the `add_product(product_name: str, price: int)` function to add a product with its name and price to the collection. * Implement the `remove_product(product_name: str)` function to remove a product from the collection by name. If the product does not exist, do nothing. 2. **Querying Products**: * Implement the `find_cheapest()` function to return the name of the product with the lowest price. If there are multiple products with the same price, return any one of them. If no products are available, return `None`. * Implement the `find_by_prefix(prefix: str)` function to return a list of all products\' names that start with the given prefix, sorted lexicographically. If no products match, return an empty list. # Input and Output Format Function Signatures ```python def add_product(product_name: str, price: int) -> None: Adds a product with its name and price to the collection. :param product_name: str - The name of the product :param price: int - The price of the product pass def remove_product(product_name: str) -> None: Removes the product with the given name from the collection. :param product_name: str - The name of the product to be removed pass def find_cheapest() -> str: Finds and returns the name of the cheapest product. :return: str - The name of the cheapest product or None if no products are available pass def find_by_prefix(prefix: str) -> list: Returns a list of product names that start with the given prefix, sorted lexicographically. :param prefix: str - The prefix to match against product names :return: list - A list of matching product names sorted lexicographically pass ``` Constraints * Product names are case-sensitive and consist of alphanumeric characters. * Prices are non-negative integers. * You should handle up to 10^5 products efficiently. Examples ```python # Adding Products >>> add_product(\\"Apple\\", 120) >>> add_product(\\"Orange\\", 100) >>> add_product(\\"Banana\\", 80) >>> add_product(\\"Grape\\", 90) # Removing Products >>> remove_product(\\"Orange\\") # Finding the Cheapest Product >>> find_cheapest() \'Banana\' # Finding Products by Prefix >>> find_by_prefix(\\"Ap\\") [\'Apple\'] >>> find_by_prefix(\\"B\\") [\'Banana\'] >>> find_by_prefix(\\"G\\") [\'Grape\'] ``` # Performance Requirements * Your solution should efficiently handle up to 10^5 product additions, removals, and queries.","solution":"products = {} def add_product(product_name: str, price: int) -> None: products[product_name] = price def remove_product(product_name: str) -> None: if product_name in products: del products[product_name] def find_cheapest() -> str: if not products: return None return min(products, key=products.get) def find_by_prefix(prefix: str) -> list: return sorted([name for name in products if name.startswith(prefix)])"},{"question":"# Coding Question: Validate and Normalize Phone Numbers **Scenario**: You are building a contact management system. One of the essential features is to ensure that all phone numbers are valid and normalized. A phone number is considered valid if it contains exactly 10 digits (0-9). Your task is to write a function that verifies the validity of phone numbers and normalizes valid ones by formatting them as `(XXX) XXX-XXXX`. If a phone number is invalid, it should be ignored. **Function Signature**: ```python def validate_and_format_phone_numbers(phone_numbers: list[str]) -> list[str]: pass ``` **Expected Input and Output**: * **Input**: - `phone_numbers` (list[str]): A list of phone numbers as strings. * **Output**: - A list of strings: The normalized phone numbers in the format `(XXX) XXX-XXXX`. **Example**: ```python >>> phone_numbers = [\\"1234567890\\", \\"9876543210\\", \\"12345678\\", \\"12345678901\\"] >>> result = validate_and_format_phone_numbers(phone_numbers) >>> print(result) [\\"(123) 456-7890\\", \\"(987) 654-3210\\"] >>> phone_numbers = [\\"1a34567890\\", \\"abcdefghij\\", \\"1234 567 890\\"] >>> result = validate_and_format_phone_numbers(phone_numbers) >>> print(result) [] ``` **Constraints**: * The input list will not exceed 10^5 phone numbers. * Phone numbers may contain any characters. * Only phone numbers with exactly 10 digits are considered valid. * Ignore phone numbers with non-digit characters or incorrect length. # Requirements: 1. Verify the validity of each phone number. 2. Normalize valid phone numbers to the format `(XXX) XXX-XXXX`. 3. Return a list of formatted phone numbers. 4. Ensure to handle edge cases such as empty strings and non-digit characters. # Tips: * Use regular expressions to identify valid phone numbers. * Consider using string methods for formatting. * Efficiently handle large lists by avoiding unnecessary computations.","solution":"import re def validate_and_format_phone_numbers(phone_numbers: list[str]) -> list[str]: Validates and normalizes a list of phone numbers. Parameters: phone_numbers (list[str]): A list of phone numbers as strings. Returns: list[str]: A list of formatted phone numbers in the format (XXX) XXX-XXXX. valid_phone_numbers = [] for pn in phone_numbers: if re.fullmatch(r\'d{10}\', pn): formatted_pn = f\\"({pn[:3]}) {pn[3:6]}-{pn[6:]}\\" valid_phone_numbers.append(formatted_pn) return valid_phone_numbers"},{"question":"# Unique Word Frequency Counter Scenario You are given a text document and need to perform a frequency analysis on the words. The task is to find the frequency of each unique word in the document. The words are defined as sequences of characters separated by whitespaces or punctuation. The output should only include words that appear in the document at least `k` times. Objective Write a function `word_frequency_counter` in Python that takes a string of text and an integer value `k`, and returns a dictionary where the keys are unique words that appear at least `k` times, and the values are their corresponding frequencies. Function Signature ```python def word_frequency_counter(text: str, k: int) -> dict[str, int]: ``` Input: 1. `text`: A string representing the content of the document. 2. `k`: An integer representing the minimum frequency threshold. Output: A dictionary where: - Keys are unique words (in lowercase) that appear at least `k` times in the text. - Values are the respective frequencies of these words. Constraints: * The `text` string can be of any length. * The `text` string may include punctuation and special characters. * Word comparison should be case-insensitive. * The `k` value will be a non-negative integer. * If no words meet the frequency threshold, return an empty dictionary. Requirements: 1. Ignore punctuation and special characters when considering word boundaries. 2. Words are case-insensitive, so \\"Word\\" and \\"word\\" should be considered the same. 3. The solution should handle large texts efficiently. Example: ```python # Examples print(word_frequency_counter(\\"This is a simple example. This example is simple.\\", 2)) # Output: {\'this\': 2, \'is\': 2, \'example\': 2, \'simple\': 2} print(word_frequency_counter(\\"Python is awesome. Python programming is fun!\\", 2)) # Output: {\'python\': 2, \'is\': 2} print(word_frequency_counter(\\"A quick brown fox jumps over the lazy dog.\\", 1)) # Output: {\'a\': 1, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'the\': 1, \'lazy\': 1, \'dog\': 1} print(word_frequency_counter(\\"Test, test, test. Testing one, two, three.\\", 3)) # Output: {\'test\': 3} print(word_frequency_counter(\\"Hello world\\", 2)) # Output: {} (No word appears at least 2 times) ``` Use appropriate methods to process and analyze the text efficiently.","solution":"import re from collections import Counter def word_frequency_counter(text: str, k: int) -> dict: Returns a dictionary of words that appear at least `k` times in the given `text` where the keys are the words and values are their frequencies. Words are case-insensitive. # Use regular expression to extract words and convert them to lowercase words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_counts = Counter(words) # Filter the words that meet or exceed the frequency threshold `k` result = {word: count for word, count in word_counts.items() if count >= k} return result"},{"question":"# Sum of Right Leaf Nodes Overview In a binary tree, a \\"right leaf node\\" is a leaf node that is the right child of its parent. You are required to calculate the sum of all the values of the right leaf nodes in a given binary tree. Problem Statement Implement a function `sum_of_right_leaves(root: TreeNode) -> int` that computes the sum of all right leaf nodes in a binary tree. Input - `root`: The root node of a binary tree. Output - An integer representing the sum of all the values of the right leaf nodes. Constraints - The number of nodes in the tree will be in the range `[0, 2000]`. - Each node\'s value will be an integer in the range `[-10^4, 10^4]`. Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree structure: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) output = 7 assert sum_of_right_leaves(root) == 7 ``` ```python # Example tree structure: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) output = 5 assert sum_of_right_leaves(root) == 5 ``` Notes - A node is a leaf node if it does not have any children. - Carefully handle edge cases where the tree might be empty (i.e., `root` is `None`). In such cases, the sum should be 0. - Optimize the solution to traverse the tree efficiently without unnecessary computations. Hint - You may want to use a Depth-First Search (DFS) or Breadth-First Search (BFS) traversal to visit each node and determine if it\'s a right leaf node.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_right_leaves(root: TreeNode) -> int: if not root: return 0 def dfs(node, is_right): if not node: return 0 if not node.left and not node.right: # it\'s a leaf return node.val if is_right else 0 return dfs(node.left, False) + dfs(node.right, True) return dfs(root, False)"},{"question":"# Problem Statement You are tasked with creating a Playlist Manager that allows users to manage their music playlists. Each playlist contains multiple songs, and each song has a title, artist, and duration. The manager should be able to add songs to a playlist, remove them, and compute the total duration of a playlist. # Requirements Implement a class `PlaylistManager` with the following methods: * `add_song(self, title: str, artist: str, duration: int) -> None`: Adds a song to the playlist. * `remove_song(self, title: str) -> bool`: Removes a song from the playlist by its title. Returns `True` if the song was successfully removed, otherwise `False`. * `get_total_duration(self) -> int`: Computes and returns the total duration of all songs in the playlist. * `get_playlist(self) -> List[Dict[str, Any]]`: Returns the entire playlist as a list of dictionaries. * `find_song(self, title: str) -> Union[Dict[str, Any], None]`: Returns the song details for the given title if it exists, otherwise `None`. # Input and Output Formats 1. **add_song** * **Input**: - `title` (str): The title of the song. - `artist` (str): The artist who performed the song. - `duration` (int): The duration of the song in seconds. * **Output**: None. 2. **remove_song** * **Input**: `title` (str): The title of the song to be removed. * **Output**: `True` if the song was removed; `False` otherwise. 3. **get_total_duration** * **Input**: None. * **Output**: An integer representing the total duration of the playlist in seconds. 4. **get_playlist** * **Input**: None. * **Output**: A list of dictionaries, each containing the details of a song (`title`, `artist`, `duration`). 5. **find_song** * **Input**: `title` (str): The title of the song to be found. * **Output**: A dictionary containing the song details (`title`, `artist`, `duration`) if found, otherwise `None`. # Example ```python playlist = PlaylistManager() # Test add_song playlist.add_song(\\"Song1\\", \\"Artist1\\", 300) playlist.add_song(\\"Song2\\", \\"Artist2\\", 200) playlist.add_song(\\"Song3\\", \\"Artist3\\", 400) # Test get_playlist assert playlist.get_playlist() == [ {\\"title\\": \\"Song1\\", \\"artist\\": \\"Artist1\\", \\"duration\\": 300}, {\\"title\\": \\"Song2\\", \\"artist\\": \\"Artist2\\", \\"duration\\": 200}, {\\"title\\": \\"Song3\\", \\"artist\\": \\"Artist3\\", \\"duration\\": 400}, ] # Test get_total_duration assert playlist.get_total_duration() == 900 # Test remove_song assert playlist.remove_song(\\"Song2\\") == True assert playlist.get_playlist() == [ {\\"title\\": \\"Song1\\", \\"artist\\": \\"Artist1\\", \\"duration\\": 300}, {\\"title\\": \\"Song3\\", \\"artist\\": \\"Artist3\\", \\"duration\\": 400}, ] assert playlist.get_total_duration() == 700 # Test find_song assert playlist.find_song(\\"Song1\\") == {\\"title\\": \\"Song1\\", \\"artist\\": \\"Artist1\\", \\"duration\\": 300} assert playlist.find_song(\\"Song2\\") == None ``` # Constraints: * The `title` and `artist` are strings containing up to 100 characters. * The `duration` is an integer representing the song duration in seconds (0 < duration <= 10^4).","solution":"from typing import List, Dict, Union, Any class PlaylistManager: def __init__(self): self.playlist = [] def add_song(self, title: str, artist: str, duration: int) -> None: Adds a song to the playlist. song = { \\"title\\": title, \\"artist\\": artist, \\"duration\\": duration } self.playlist.append(song) def remove_song(self, title: str) -> bool: Removes a song from the playlist by its title. Returns True if the song was successfully removed, otherwise False. for song in self.playlist: if song[\\"title\\"] == title: self.playlist.remove(song) return True return False def get_total_duration(self) -> int: Computes and returns the total duration of all songs in the playlist. total_duration = sum(song[\\"duration\\"] for song in self.playlist) return total_duration def get_playlist(self) -> List[Dict[str, Any]]: Returns the entire playlist as a list of dictionaries. return self.playlist def find_song(self, title: str) -> Union[Dict[str, Any], None]: Returns the song details for the given title if it exists, otherwise None. for song in self.playlist: if song[\\"title\\"] == title: return song return None"},{"question":"# Problem Statement Given a dictionary of `student_names` and their corresponding `test_scores`, implement a function that returns a list of names of students who scored above a given threshold. This function is useful in educational software to quickly identify high-performing students for commendations or advanced placement. # Requirements Function Signature ```python def top_performing_students(student_scores: dict, threshold: float) -> list: ``` Functionality Description - The function should accept two parameters: * `student_scores` (dict): A dictionary where keys are student names (strings) and values are their test scores (floats from 0 to 100). * `threshold` (float): A score threshold. - The function should return a list of student names (strings) who scored above the threshold. # Constraints 1. The `student_scores` dictionary will contain at least one student with a valid score. 2. The values in `student_scores` will be within the range of 0 to 100. 3. The `threshold` must be between 0 and 100. 4. The function should return an empty list if no student scores above the threshold. # Error Handling 1. Raise a `ValueError` if `student_scores` is not a dictionary. 2. Raise a `ValueError` if `threshold` is not a float or not within the valid range. # Example Usage ```python >>> student_scores = { ... \'Alice\': 89.5, ... \'Bob\': 67.3, ... \'Charlie\': 92.7, ... \'David\': 55.1 ... } >>> top_performing_students(student_scores, 70.0) [\'Alice\', \'Charlie\'] >>> top_performing_students(student_scores, 90.0) [\'Charlie\'] >>> top_performing_students(student_scores, 95.0) [] ``` In addition, the function should properly raise exceptions for incorrect argument types: ```python >>> top_performing_students([\'Alice\', \'Bob\'], 70.0) Traceback (most recent call last): ... ValueError: Expected dictionary for student_scores, found <class \'list\'> >>> top_performing_students(student_scores, 105) Traceback (most recent call last): ... ValueError: Expected float within range 0-100 for threshold, found <class \'int\'> ``` Ensure the function operates correctly and efficiently with the constraints and examples provided.","solution":"def top_performing_students(student_scores: dict, threshold: float) -> list: Returns a list of names of students who scored above a given threshold. Parameters: student_scores (dict): Dictionary with student names as keys and scores as values. threshold (float): The score threshold. Returns: list: List of student names who scored above the threshold. # Validate the student_scores input if not isinstance(student_scores, dict): raise ValueError(f\\"Expected dictionary for student_scores, found {type(student_scores)}\\") # Validate the threshold input if not isinstance(threshold, (int, float)): raise ValueError(f\\"Expected float for threshold, found {type(threshold)}\\") if not (0 <= threshold <= 100): raise ValueError(\\"Threshold must be between 0 and 100.\\") # Identify students who scored above the threshold high_scorers = [name for name, score in student_scores.items() if score > threshold] return high_scorers"},{"question":"# Problem Statement Given an integer `n`, generate all strings of length `n` that consist only of the characters \'A\' and \'B\', and return them in lexicographical order. **Function Signature:** ```python def generate_ab_strings(n: int) -> List[str]: Parameters: n (int): The length of the strings to be generated. Returns: List[str]: A list of all strings of length `n` containing only \'A\' and \'B\', ordered lexicographically. ``` # Input - An integer `n` (1 ≤ n ≤ 10), representing the length of the strings. # Output - A list of strings, where each string is of length `n` and consists only of the characters \'A\' and \'B\', ordered lexicographically. # Constraints - Ensure that the strings are generated efficiently, especially for the upper bound values of `n`. # Example ```python assert generate_ab_strings(2) == [\'AA\', \'AB\', \'BA\', \'BB\'] assert generate_ab_strings(3) == [\'AAA\', \'AAB\', \'ABA\', \'ABB\', \'BAA\', \'BAB\', \'BBA\', \'BBB\'] assert generate_ab_strings(1) == [\'A\', \'B\'] ``` # Explanation For `n = 2`, the strings of length 2 containing only \'A\' and \'B\' are `[\'AA\', \'AB\', \'BA\', \'BB\']`, in lexicographical order. For `n = 3`, the strings of length 3 are `[\'AAA\', \'AAB\', \'ABA\', \'ABB\', \'BAA\', \'BAB\', \'BBA\', \'BBB\']`. **Note**: * Consider using recursive or iterative techniques to generate the strings properly. * Ensure that your solution properly handles edge cases (e.g., very small or very large values of `n`).","solution":"def generate_ab_strings(n: int) -> list: Generate all strings of length n that consist only of the characters \'A\' and \'B\', in lexicographical order. :param n: Length of the strings to be generated. :return: A list of strings of length n composed of \'A\' and \'B\'. if n == 0: return [] # Recursive function to generate the strings def generate(current, length): if length == n: result.append(current) return generate(current + \'A\', length + 1) generate(current + \'B\', length + 1) result = [] generate(\\"\\", 0) return result"},{"question":"# Context You are developing a text processing application which aims to analyze text data to extract meaningful information and perform various transformations on the text. # Problem Statement Write a Python class `TextProcessor` that supports the following functionalities: 1. **Initialization**: Should initialize with a string of text. 2. **Word Count**: Implement a method to count the occurrence of each word. 3. **Find and Replace**: Implement a method to find all occurrences of a word and replace it with another word. 4. **Palindrome Check**: Implement a method to check if the text is a palindrome (ignoring spaces, punctuation, and case). 5. **String Representation**: A method to return a string representation of the processed text. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases, error handling, and different types of textual data. # Implementation Details 1. **Initialization**: ```python class TextProcessor: def __init__(self, text: str) -> None: ... ``` 2. **Word Count**: ```python def word_count(self) -> dict: ... ``` 3. **Find and Replace**: ```python def find_and_replace(self, old_word: str, new_word: str) -> None: ... ``` 4. **Palindrome Check**: ```python def is_palindrome(self) -> bool: ... ``` 5. **String Representation**: ```python def __str__(self) -> str: ... ``` # Constraints - The input text is guaranteed to be non-empty. - For word count, words are considered case-insensitive and punctuation should be ignored. - For find and replace, substitutions should be case-sensitive. - Palindrome check should ignore spaces, punctuation, and be case-insensitive. # Unit Tests Create a test class `TestTextProcessor` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and scenarios like text with special characters, mixed case words, etc. # Example ```python text = \\"A man a plan a canal Panama\\" processor = TextProcessor(text) # Test Word Count print(processor.word_count()) # Should print {\'a\': 3, \'man\': 1, \'plan\': 1, \'canal\': 1, \'panama\': 1} # Test Find and Replace processor.find_and_replace(\\"Panama\\", \\"Suez\\") print(str(processor)) # Should print \\"A man a plan a canal Suez\\" # Test Palindrome Check print(processor.is_palindrome()) # Should return True # Test String Representation print(str(processor)) # Should return \\"A man a plan a canal Panama\\" ``` # Notes - Use Python’s standard libraries and avoid any external dependencies. - Consider edge cases such as texts with punctuation, multiple spaces, and mixed casing for more rigorous testing.","solution":"import re from collections import Counter class TextProcessor: def __init__(self, text: str) -> None: self.text = text def word_count(self) -> dict: words = re.findall(r\'bw+b\', self.text.lower()) return dict(Counter(words)) def find_and_replace(self, old_word: str, new_word: str) -> None: self.text = self.text.replace(old_word, new_word) def is_palindrome(self) -> bool: clean_text = re.sub(r\'[^a-zA-Z0-9]\', \'\', self.text).lower() return clean_text == clean_text[::-1] def __str__(self) -> str: return self.text"},{"question":"# Context You are developing a spell checker program. The program needs to read a text file containing various words, identify if they are correctly spelled, and suggest corrections for misspelled words. You are provided with a dictionary of correctly spelled words. # Task Your task is to enhance the `spell_checker` function to read from a given text file and use the provided dictionary to: * Identify the misspelled words in the text. * Generate a list of potential corrections for each misspelled word. * Suggest the closest word from the dictionary based on the Levenshtein distance (edit distance) algorithm. # Requirements 1. Implement the `spell_checker` function. 2. The function should read words from the text file, compare them to the dictionary, and identify words that are not found in the dictionary. 3. For each misspelled word, suggest the closest word from the dictionary based on the Levenshtein distance. 4. Ensure the function handles edge cases smoothly, such as empty files or special characters. # Input - A text file provided as a string, `filename`. - A list of correctly spelled words provided as the dictionary, `dictionary`. # Output A dictionary where keys are the misspelled words and values are the closest suggested word from the dictionary. # Function Signature ```python def spell_checker(filename: str, dictionary: list) -> dict: ``` # Example ```python dictionary = [\\"hello\\", \\"world\\", \\"python\\", \\"programming\\", \\"spell\\", \\"checker\\"] # for a file content with: \\"helo worl pyhton proogramming spel cheker\\" spell_checker(\\"input.txt\\", dictionary) # expected output: # { # \\"helo\\": \\"hello\\", # \\"worl\\": \\"world\\", # \\"pyhton\\": \\"python\\", # \\"proogramming\\": \\"programming\\", # \\"spel\\": \\"spell\\", # \\"cheker\\": \\"checker\\" # } ``` # Performance - Time Complexity: Aim for O(n * m) where n is the number of words in the text file and m is the average length of words in the dictionary. - Space Complexity: Aim for O(k) additional space where k is the number of unique misspelled words. # Hints 1. Use the Levenshtein distance algorithm to measure the edit distance between words. 2. Utilize efficient file reading techniques to process the text file. 3. Consider caching previous computations for recurring words to enhance performance.","solution":"import re from collections import defaultdict def levenshtein_distance(word1, word2): Calculate the Levenshtein distance (edit distance) between two words. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): cost = 0 if word1[i - 1] == word2[j - 1] else 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost # Substitution ) return dp[m][n] def find_closest_word(word, dictionary): Find the closest matching word in the dictionary based on Levenshtein distance. min_distance = float(\'inf\') closest_word = None for dict_word in dictionary: distance = levenshtein_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word return closest_word def spell_checker(filename: str, dictionary: list) -> dict: Spell checker function to identify misspelled words and suggest corrections. # Read file content with open(filename, \'r\') as file: content = file.read().lower() # Extract words from content words = re.findall(r\'bw+b\', content) dictionary_set = set(dictionary) # Identify misspelled words misspelled_words = defaultdict(list) for word in words: if word not in dictionary_set: closest = find_closest_word(word, dictionary) misspelled_words[word] = closest return dict(misspelled_words)"},{"question":"**[Question 2]: Inverting a Binary Tree** Your task is to write a function that inverts a binary tree. This means swapping the left and right children for every node in the tree. # Function Signature ```python def invert_binary_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: pass ``` # Input - `root` (Optional[TreeNode]): The root node of the binary tree. If the tree is empty, `root` will be `None`. # Output - Return the root node of the inverted binary tree. # Constraints - The number of nodes in the tree is in the range `[0, 100]`. - `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The value of each node is an integer. # Example 1 Input: ``` 4 / 2 7 / / 1 3 6 9 ``` Output: ``` 4 / 7 2 / / 9 6 3 1 ``` # Example 2 Input: ``` 2 / 1 3 ``` Output: ``` 2 / 3 1 ``` # Performance Requirements - The solution should traverse each node in the binary tree once. - The function must handle empty trees without errors. # Scenario/Context You are dealing with a fundamental binary tree manipulation problem common in many programming challenges and coding interviews. Your task is to implement a function that swaps left and right children recursively or iteratively, ensuring the structure of the tree is correctly reversed.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"# Coding Assessment Question You are tasked with developing a function that analyzes a log file to identify the IP addresses with the highest number of failed login attempts. Objective Write a function called `analyze_login_attempts` that will: 1. Read a log file and parse the entries to find all failed login attempts. 2. Identify and count the number of failed attempts per unique IP address. 3. Store the results in a CSV file named \\"Failed_Login_Attempts.csv\\" with two columns: \\"IP Address\\" and \\"Failed Attempts\\". Function Signature ```python def analyze_login_attempts(log_file: str, output_file: str = \\"Failed_Login_Attempts.csv\\") -> None: pass ``` Input and Output Formats * **Input**: * `log_file`: A string specifying the path to a log file. * `output_file` (optional): A string specifying the output CSV file name. * **Output**: The function writes a CSV file with IP addresses and the count of their failed login attempts. Constraints * The log file format will contain lines structured as follows: ``` [Date Time] [IP Address] [Status] ``` - Example: ``` [2023-10-01 12:45:33] 192.168.1.1 SUCCESS [2023-10-01 12:46:15] 192.168.1.2 FAILED [2023-10-01 12:47:48] 192.168.1.1 FAILED ``` * Entries with the status \\"FAILED\\" should be considered in the analysis. * Ensure the CSV is written without data corruption or formatting issues. Performance Requirements * The solution should efficiently handle large log files. * Implement reasonable error handling for robustness without compromising performance. Additional Requirements * Write a `main` function that calls `analyze_login_attempts()` to demonstrate its usage. * Your solution should comply with best practices, including appropriate use of libraries, clean code, and detailed comments. Good luck and happy coding!","solution":"import csv def analyze_login_attempts(log_file: str, output_file: str = \\"Failed_Login_Attempts.csv\\") -> None: failed_attempts = {} with open(log_file, \'r\') as file: for line in file: parts = line.strip().split() status = parts[-1] ip_address = parts[-2] if status == \\"FAILED\\": if ip_address not in failed_attempts: failed_attempts[ip_address] = 0 failed_attempts[ip_address] += 1 with open(output_file, \'w\', newline=\'\') as csvfile: csv_writer = csv.writer(csvfile) csv_writer.writerow([\'IP Address\', \'Failed Attempts\']) for ip_address, count in failed_attempts.items(): csv_writer.writerow([ip_address, count]) def main(): analyze_login_attempts(\'logfile.txt\', \'Failed_Login_Attempts.csv\')"},{"question":"# Find the Most Frequent Number in an Array **Objective**: Implement a function that identifies and returns the most frequent number in an array. If there are multiple numbers with the same highest frequency, return the smallest one. **Task**: 1. **Core Functionality**: Implement a function `find_most_frequent` that takes in an array of integers and returns the most frequent integer. 2. **Handling Ties**: In case of a tie where multiple integers have the same highest frequency, return the smallest integer among them. 3. **Edge Cases**: Ensure the function handles edge cases such as an empty array or an array with all identical elements. **Input and Output Formats**: * **Input**: * `arr` (List[int]): A list of integers. * **Output**: * The most frequent integer in the array. In case of ties, the smallest integer among the most frequent ones. **Constraints**: * The length of the array should be between 0 and 10^5. * The integers in the array can range from -10^6 to 10^6. **Performance Requirements**: The function should run efficiently with time complexity O(n), where n is the length of the array, and space complexity O(n) to handle the frequency count. **Function Signature**: ```python def find_most_frequent(arr: List[int]) -> int: pass ``` **Examples**: 1. `find_most_frequent([1, 3, 3, 2, 1, 1])` should return `1` because `1` appears 3 times, more frequently than any other number. 2. `find_most_frequent([4, 4, 1, 1, 2, 2])` should return `1` because `1` and `4` both have the highest frequency (2 times), but `1` is smaller. 3. `find_most_frequent([])` should handle an empty array gracefully. **Notes**: 1. Ensure all edge cases such as an empty array or array with all unique elements are handled appropriately. 2. The function should handle negative integer values as well.","solution":"from typing import List from collections import defaultdict def find_most_frequent(arr: List[int]) -> int: if not arr: # handle empty array case return None frequency = defaultdict(int) for num in arr: frequency[num] += 1 max_freq = max(frequency.values()) most_frequent_numbers = [num for num, freq in frequency.items() if freq == max_freq] return min(most_frequent_numbers)"},{"question":"# Coding Assessment Question Objective: To demonstrate your understanding of sorting algorithms and their application, you need to implement a function that sorts a list of integers with a custom order of precedence. Scenario: Imagine you work at a digital book library. Each book has a unique numeric identifier. Your application requires frequent sorting of these identifiers based on a custom order that prioritizes even numbers over odd numbers and sorts them in increasing order. It\'s essential to make sure that the sort is efficient given the potentially large size of the list. Requirements: 1. **Function Name**: `custom_sort` 2. **Input**: A list of integers `books` where each integer represents a unique identifier of a book. 3. **Output**: A new list of integers sorted based on the custom order where: - Even numbers appear before odd numbers. - Even numbers are sorted in ascending order. - Odd numbers are sorted in ascending order. 4. **Constraints**: The list `books` can have up to `10^5` elements. 5. **Performance**: Aim for a time complexity that allows the solution to complete efficiently for large lists. Example: ```python >>> custom_sort([3, 1, 2, 4, 7, 8, 5]) [2, 4, 8, 1, 3, 5, 7] >>> custom_sort([10, 21, 12, 13, 14, 15]) [10, 12, 14, 13, 15, 21] >>> custom_sort([7, 3, 2, 0, 5, 8]) [0, 2, 8, 3, 5, 7] ``` Edge Cases to Consider: - Ensure your function handles an empty list correctly. - Handle cases where there are only even or only odd numbers. - Consider and handle larger inputs efficiently. ```python def custom_sort(books): # Separate even and odd numbers evens = [x for x in books if x % 2 == 0] odds = [x for x in books if x % 2 != 0] # Sort each list evens.sort() odds.sort() # Concatenate the sorted lists with evens first return evens + odds # Test cases print(custom_sort([3, 1, 2, 4, 7, 8, 5])) # Expected: [2, 4, 8, 1, 3, 5, 7] print(custom_sort([10, 21, 12, 13, 14, 15])) # Expected: [10, 12, 14, 13, 15, 21] print(custom_sort([7, 3, 2, 0, 5, 8])) # Expected: [0, 2, 8, 3, 5, 7] ```","solution":"def custom_sort(books): Sorts a list of book identifiers, prioritizing even numbers in ascending order followed by odd numbers in ascending order. evens = [x for x in books if x % 2 == 0] odds = [x for x in books if x % 2 != 0] evens.sort() odds.sort() return evens + odds"},{"question":"# Coding Question: Maximum Length of Repeated Subarray You are given two integer arrays `nums1` and `nums2`, and you need to find the maximum length of a subarray that appears in both arrays. Implement the function `find_max_length(nums1: list[int], nums2: list[int]) -> int` which returns the length of the longest common subarray. Input - `nums1`: A list of integers `nums1[0], nums1[1], ..., nums1[n-1]`, where `0 <= n <= 1000` and `-10^5 <= nums1[i] <= 10^5`. - `nums2`: A list of integers `nums2[0], nums2[1], ..., nums2[m-1]`, where `0 <= m <= 1000` and `-10^5 <= nums2[i] <= 10^5`. Output - Return an integer that represents the length of the longest common subarray. Constraints - Consider edge cases such as: empty arrays, arrays with no common subarray, and large arrays with substantial overlap. Examples ```python >>> find_max_length([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]) 3 >>> find_max_length([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) 1 >>> find_max_length([0, 0, 0], [0, 0, 1]) 2 >>> find_max_length([], [1, 2, 3, 4]) 0 >>> find_max_length([1, 1, 1], [1, 1, 1]) 3 ``` Performance Considerations The function should be efficient enough to handle cases where both input arrays are at their maximum length. Detailed Explanation: 1. Develop a dynamic programming solution to compute the lengths of common subarrays ending at each pair of indices `i` and `j`. 2. Utilize a 2D array `dp` where `dp[i][j]` stores the length of the longest common suffix of `nums1[:i]` and `nums2[:j]`. 3. Iterate through both arrays, updating the `dp` array and keeping track of the maximum length found. 4. Handle edge cases to ensure correct results and avoid index errors. By crafting challenges that test a candidate\'s ability to implement dynamic programming solutions effectively, we ensure the assessment accurately gauges their problem-solving skills and understanding of key computer science concepts.","solution":"def find_max_length(nums1, nums2): Returns the maximum length of a subarray that appears in both arrays. n, m = len(nums1), len(nums2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"# Question: Movie Database Aggregation You are given two APIs to fetch movie details: OMDB (Open Movie Database) and TMDb (The Movie Database). Your task is to implement a Python function that aggregates movie data from these two sources. The function should handle error scenarios such as invalid API keys or network issues gracefully. Function Signature ```python def get_movie_details(title: str) -> dict: Fetches and aggregates movie data from OMDB and TMDb for a given movie title. :param title: A string representing the movie title. :return: A dictionary containing the aggregated movie information. :raises ValueError: If no API keys are provided or no valid data is returned. pass ``` # Requirements 1. **Input**: A string `title` which is the name of the movie. 2. **Output**: A dictionary with keys \\"OMDB\\" and \\"TMDb\\" containing the respective movie data. 3. **Errors**: Raise a `ValueError` if neither API key is provided or if no valid data is fetched. # Constraints - Assume valid inputs for the movie title. - Handle network timeouts (10 seconds). - Use the following API endpoint formats: - OMDB: `http://www.omdbapi.com/` - TMDb: `https://api.themoviedb.org/3/search/movie` - Ensure the correctness of the API parameters. # Performance - The function should handle network latency gracefully and be resilient to API rate limits. # Example ```python # Example API keys for testing (use dummy keys, as they might not work). OMDB_API_KEY = \\"your_omdb_api_key\\" TMDB_API_KEY = \\"your_tmdb_api_key\\" # Define the function implementation here. title = \\"Inception\\" try: movie_details = get_movie_details(title) print(movie_details) except ValueError as e: print(repr(e)) ```","solution":"import requests OMDB_API_KEY = \\"your_omdb_api_key\\" TMDB_API_KEY = \\"your_tmdb_api_key\\" def get_omdb_data(title): url = f\\"http://www.omdbapi.com/?t={title}&apikey={OMDB_API_KEY}\\" try: response = requests.get(url, timeout=10) response.raise_for_status() # will throw an error for HTTP error codes return response.json() except requests.RequestException as e: print(f\\"Error fetching OMDB data: {e}\\") return None def get_tmdb_data(title): url = f\\"https://api.themoviedb.org/3/search/movie\\" params = {\\"api_key\\": TMDB_API_KEY, \\"query\\": title} try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() # will throw an error for HTTP error codes return response.json().get(\'results\', [])[0] if response.json().get(\'results\') else None except requests.RequestException as e: print(f\\"Error fetching TMDb data: {e}\\") return None def get_movie_details(title: str) -> dict: omdb_data = get_omdb_data(title) tmdb_data = get_tmdb_data(title) if not omdb_data and not tmdb_data: raise ValueError(\\"Unable to fetch data from both OMDB and TMDb\\") return {\\"OMDB\\": omdb_data, \\"TMDb\\": tmdb_data}"},{"question":"# Task Implement a function `optimized_fibonacci` that efficiently computes the n-th Fibonacci number using matrix exponentiation. # Scenarios Your function will be used in various mathematical computations where efficient determination of Fibonacci numbers is crucial. # Input - A single integer `n` representing the position in the Fibonacci sequence (0-indexed). # Output - An integer which is the n-th Fibonacci number. # Constraints 1. The input integer `n` will be a non-negative integer (0 ≤ n ≤ 10^9). 2. The function must be optimized for very large values of `n` using matrix exponentiation technique. # Requirements - Do not use simple recursion or iterative methods due to their inefficiency for large `n`. - Implement the matrix exponentiation method to achieve a time complexity of O(log n). # Hints - The Fibonacci number `F(n)` can be computed using the power of a transformation matrix. Specifically: ``` | F(n) | = | 1 1 |^n * | F(1) | | F(n-1) | | 1 0 | | F(0) | ``` - You can raise the matrix to the power of `n` using repeated squaring. # Example ```python def optimized_fibonacci(n: int) -> int: # Your implementation here pass # Example Test Cases: print(optimized_fibonacci(0)) # Expected output: 0 print(optimized_fibonacci(1)) # Expected output: 1 print(optimized_fibonacci(10)) # Expected output: 55 print(optimized_fibonacci(50)) # Expected output: 12586269025 print(optimized_fibonacci(100)) # Expected output: 354224848179261915075 ```","solution":"def matrix_multiply(A, B): Multiplies two 2x2 matrices A and B. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, n): Raises the matrix to the power n using exponentiation by squaring. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result def optimized_fibonacci(n): Returns the n-th Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 # Transformation matrix F = [[1, 1], [1, 0]] # Powerful transformation matrix to the n-1 result_matrix = matrix_power(F, n-1) # The top left element of the matrix is F(n) return result_matrix[0][0]"},{"question":"# Problem Statement Create a function to determine the minimum number of moves required to solve the Tower of Hanoi problem for `n` disks. The Tower of Hanoi problem involves moving disks from one rod to another, following specific rules: only one disk can be moved at a time, each move involves taking the top disk from one of the stacks and placing it on top of another stack, and no disk may be placed on top of a smaller disk. Write a function `minimumMoves(n: int) -> int` that returns the minimum number of moves required to solve the Tower of Hanoi problem for `n` disks. # Input Format - A single integer `n` (1 ≤ n ≤ 50) representing the number of disks. # Output Format - A single integer representing the minimum number of moves required to solve the Tower of Hanoi problem. # Example ```python >>> minimumMoves(1) 1 >>> minimumMoves(2) 3 >>> minimumMoves(3) 7 >>> minimumMoves(5) 31 ``` # Constraints - The function should handle values of `n` up to 50. # Guidelines - Utilize the known mathematical formula for the Tower of Hanoi, which states that the minimum number of moves required to solve the problem for `n` disks is (2^n - 1). - Ensure efficient calculation by leveraging exponentiation. # Solution ```python def minimumMoves(n: int) -> int: return 2**n - 1 ```","solution":"def minimumMoves(n: int) -> int: Returns the minimum number of moves required to solve the Tower of Hanoi problem for n disks. Parameters: n (int): Number of disks Returns: int: Minimum number of moves return 2**n - 1"},{"question":"# Question: Implement Advanced List Operations Write a class `ListOperations` that provides several utility functions to manipulate and analyze lists of integers. **Class Definition**: `ListOperations` **Methods**: 1. `reverse_list(nums: list) -> list`: Reverse the order of the list. 2. `sum_of_elements(nums: list) -> int`: Calculate the sum of all elements in the list. 3. `filter_odd(nums: list) -> list`: Return a list containing only the odd numbers from the original list. 4. `find_max(nums: list) -> int`: Find the maximum element in the list. 5. `unique_elements(nums: list) -> list`: Return a list of unique elements in the original list, preserving the order of their first appearance. **Input**: - All methods take a list of integers (`nums`). - The methods assume the input list is non-empty. **Output**: - Each method returns an appropriate data type as specified (list or int). **Constraints**: - Methods should handle edge cases such as lists containing only negative numbers, single-element lists, or lists with all elements being the same. # Example ```python ops = ListOperations() print(ops.reverse_list([1, 2, 3, 4])) # Output: [4, 3, 2, 1] print(ops.sum_of_elements([1, 2, 3, 4])) # Output: 10 print(ops.filter_odd([1, 2, 3, 4, 5])) # Output: [1, 3, 5] print(ops.find_max([1, 2, 3, 4])) # Output: 4 print(ops.unique_elements([1, 2, 2, 3, 3, 4])) # Output: [1, 2, 3, 4] ``` # Performance Requirements: - Time complexity should be efficient for lists of size up to 10^6. Implement the `ListOperations` class ensuring you handle all edge cases and return accurate results.","solution":"class ListOperations: @staticmethod def reverse_list(nums): Reverses the order of the list. return nums[::-1] @staticmethod def sum_of_elements(nums): Calculates the sum of all elements in the list. return sum(nums) @staticmethod def filter_odd(nums): Returns a list containing only the odd numbers from the original list. return [num for num in nums if num % 2 != 0] @staticmethod def find_max(nums): Finds the maximum element in the list. return max(nums) @staticmethod def unique_elements(nums): Returns a list of unique elements in the original list, preserving the order of their first appearance. seen = set() unique = [] for num in nums: if num not in seen: unique.append(num) seen.add(num) return unique"},{"question":"# Querying and Filtering Employee Data Design a class to manage employee record data and implement querying and filtering functionalities according to specified conditions. # Problem Statement 1. **Implementation**: - Implement a method for filtering employees by a specified department. - Implement a method to compute the average salary of employees in the database. - Implement a method to find all employees who join within a specific date range. 2. **Function Signature**: ```python from datetime import date from typing import List class Employee: def __init__(self, name: str, department: str, salary: float, join_date: date): self.name = name self.department = department self.salary = salary self.join_date = join_date class EmployeeDatabase: def __init__(self, employees: List[Employee]): self.employees = employees def filter_by_department(self, department: str) -> List[Employee]: Returns a list of employees in the specified department. pass def compute_average_salary(self) -> float: Computes the average salary of all employees. pass def find_by_join_date_range(self, start_date: date, end_date: date) -> List[Employee]: Finds employees who joined between start_date and end_date (inclusive). pass ``` # Input and Output - `filter_by_department`: - **Input**: A string representing the department name. - **Output**: A list of `Employee` objects within the specified department. - `compute_average_salary`: - **Input**: No input. - **Output**: A float representing the average salary of all employees. - `find_by_join_date_range`: - **Input**: Two `date` objects representing the start and end dates. - **Output**: A list of `Employee` objects who joined within the specified date range. # Constraints - Employees can belong to any department with names up to 50 characters long. - Salaries are positive floating-point numbers. - Date ranges can be from the year 1900 to the present year. # Example ```python from datetime import date employees = [ Employee(\\"John Doe\\", \\"Engineering\\", 70000, date(2020, 5, 20)), Employee(\\"Jane Smith\\", \\"Marketing\\", 65000, date(2019, 7, 15)), Employee(\\"Alice Johnson\\", \\"Engineering\\", 72000, date(2021, 1, 10)), Employee(\\"Bob Brown\\", \\"Sales\\", 50000, date(2018, 11, 30)), ] db = EmployeeDatabase(employees) # Filter by department engineering_employees = db.filter_by_department(\\"Engineering\\") print([e.name for e in engineering_employees]) # Expected: [\\"John Doe\\", \\"Alice Johnson\\"] # Compute average salary average_salary = db.compute_average_salary() print(average_salary) # Expected: 64250.0 # Find by join date range newcomers = db.find_by_join_date_range(date(2020, 1, 1), date(2021, 12, 31)) print([e.name for e in newcomers]) # Expected: [\\"John Doe\\", \\"Alice Johnson\\"] ``` # Note Ensure your solution can efficiently handle data operations on a list of employees of varying lengths, and that date manipulations are correctly implemented and validated.","solution":"from datetime import date from typing import List class Employee: def __init__(self, name: str, department: str, salary: float, join_date: date): self.name = name self.department = department self.salary = salary self.join_date = join_date class EmployeeDatabase: def __init__(self, employees: List[Employee]): self.employees = employees def filter_by_department(self, department: str) -> List[Employee]: return [employee for employee in self.employees if employee.department == department] def compute_average_salary(self) -> float: if not self.employees: return 0.0 total_salary = sum(employee.salary for employee in self.employees) return total_salary / len(self.employees) def find_by_join_date_range(self, start_date: date, end_date: date) -> List[Employee]: return [ employee for employee in self.employees if start_date <= employee.join_date <= end_date ]"},{"question":"# Scenario: You have been assigned the task of developing a tool for processing text data in a large document management system. One of the essential operations needed is to identify and extract all unique words from a given text, regardless of their case, and return them in alphabetical order. # Task: Write a function named `extract_unique_words` that extracts all unique words from a given text string and returns them as a list in alphabetical order. The function should ignore differences in case, treating \\"Word\\" and \\"word\\" as the same word. # Function Definition: 1. **extract_unique_words(text: str) -> List[str]** - Extracts all unique words from the given text and returns them in alphabetical order. # Input and Output Formats: - **Input**: - `text` (str): The text string from which unique words are to be extracted. - **Output**: - Returns a list of unique words in alphabetical order as strings. # Constraints: 1. The `text` will only contain characters from the English alphabet (both uppercase and lowercase) and spaces. 2. Raises appropriate exceptions for invalid inputs, such as empty strings or non-string inputs. # Examples: - **Example 1**: ```python extract_unique_words(\\"The quick brown Fox jumps over the lazy Dog\\") # Output: [\\"brown\\", \\"dog\\", \\"fox\\", \\"jumps\\", \\"lazy\\", \\"over\\", \\"quick\\", \\"the\\"] ``` - **Example 2**: ```python extract_unique_words(\\"Hello hello World\\") # Output: [\\"hello\\", \\"world\\"] ```","solution":"def extract_unique_words(text): Extracts all unique words from the given text and returns them in alphabetical order. Parameters: text (str): The text string from which unique words are to be extracted. Returns: List[str]: List of unique words in alphabetical order. if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") if not text.strip(): raise ValueError(\\"Input string must not be empty or just spaces\\") words = text.lower().split() unique_words = sorted(set(words)) return unique_words"},{"question":"# Context You are developing a chat application that involves real-time messaging between users. As part of the feature set, the application must display a log of the last `n` messages, but the message log should be managed efficiently to avoid performance bottlenecks as messages are exchanged. # Problem Statement Write a Python class to implement a `MessageLog` that uses a circular buffer to store the last `n` messages. The class should have the following requirements: 1. **Initialization**: Create a message log with a specified size. 2. **Add Message**: Add a new message to the log. 3. **Retrieve Log**: Retrieve the current log of messages in the order they were added, up to the maximum size. # Class Signature ```python class MessageLog: def __init__(self, size: int): Parameters: size: int -> The maximum size of the message log def add_message(self, message: str) -> None: Parameters: message: str -> The message to be added to the log def get_log(self) -> list: Returns: list -> The list of messages in the order they were added, up to the maximum size ``` # Input and Output - **Input**: - `size`: An integer specifying the maximum size of the message log. - `message`: A string representing a new message to be added to the log. - **Output**: - A list containing the current log of messages in the order they were added, up to the maximum size. # Constraints - The message log must maintain the order of messages as they are added. - When the log reaches its maximum size, new messages should overwrite the oldest messages (circular buffer behavior). - The `get_log` method should return the messages in the correct chronological order. # Example ```python log = MessageLog(3) log.add_message(\\"Message 1\\") log.add_message(\\"Message 2\\") print(log.get_log()) # Output: [\\"Message 1\\", \\"Message 2\\"] log.add_message(\\"Message 3\\") print(log.get_log()) # Output: [\\"Message 1\\", \\"Message 2\\", \\"Message 3\\"] log.add_message(\\"Message 4\\") print(log.get_log()) # Output: [\\"Message 2\\", \\"Message 3\\", \\"Message 4\\"] ``` # Test Case Validate your solution by: 1. Testing with different sizes of the message log. 2. Adding more messages than the log\'s size and ensuring proper overwrite behavior. 3. Ensuring the log order is maintained correctly.","solution":"class MessageLog: def __init__(self, size: int): Parameters: size: int -> The maximum size of the message log self.size = size self.messages = [None] * size self.current_index = 0 self.log_full = False def add_message(self, message: str) -> None: Parameters: message: str -> The message to be added to the log self.messages[self.current_index] = message self.current_index = (self.current_index + 1) % self.size if self.current_index == 0: self.log_full = True def get_log(self) -> list: Returns: list -> The list of messages in the order they were added, up to the maximum size if self.log_full: return self.messages[self.current_index:] + self.messages[:self.current_index] else: return self.messages[:self.current_index]"},{"question":"# Question: Expense Manager Application You are assigned to create an expense management system which consolidates records of various expenses and allows users to retrieve statistics about their expenses. The expense manager should support the ability to add new expenses and retrieve the total and average expense values. **Objectives:** 1. Implement a class `ExpenseManager` with the following methods: - `add_expense(amount: float) -> None`: Adds a new expense. The amount must be a positive number, otherwise raise a `ValueError` with the message \\"Expense amount must be positive\\". - `get_total_expenses() -> float`: Returns the total sum of all the expenses added. - `get_average_expense() -> float`: Returns the average amount of all the expenses. If no expenses have been added, it should return 0.0. **Constraints:** - The `amount` for expenses must be a positive float. - Ensuring correct handling of operations when there are no expenses yet is crucial. - The calculations must ensure proper float arithmetic to avoid significant rounding errors. **Function Signatures:** - `class ExpenseManager:` - `def __init__(self) -> None:` - `def add_expense(self, amount: float) -> None:` - `def get_total_expenses(self) -> float:` - `def get_average_expense(self) -> float:` **Example Usage:** ```python mgr = ExpenseManager() mgr.add_expense(12.50) mgr.add_expense(7.25) mgr.add_expense(20.00) print(mgr.get_total_expenses()) # Output: 39.75 print(mgr.get_average_expense()) # Output: 13.25 mgr.add_expense(50.00) print(mgr.get_total_expenses()) # Output: 89.75 print(mgr.get_average_expense()) # Output: 22.4375 ``` Your task is to implement the `ExpenseManager` class ensuring it behaves as described and accurately manages, calculates, and retrieves expense information.","solution":"class ExpenseManager: def __init__(self) -> None: self.expenses = [] def add_expense(self, amount: float) -> None: Adds a new expense. The amount must be a positive number, otherwise raises a ValueError. if amount <= 0: raise ValueError(\\"Expense amount must be positive\\") self.expenses.append(amount) def get_total_expenses(self) -> float: Returns the total sum of all the expenses added. return sum(self.expenses) def get_average_expense(self) -> float: Returns the average amount of all the expenses. If no expenses have been added, returns 0.0. if not self.expenses: return 0.0 return sum(self.expenses) / len(self.expenses)"},{"question":"# Coding Assessment Question: Implement a Dynamic Array with Additional Features Context You are provided with a simple dynamic array (similar to Python\'s list). However, you need to enhance it by adding certain functionality that improves its usability and performance for specific tasks. Task 1. **Capacity Management**: Modify the class to keep track of its capacity (maximum number of elements it can hold before resizing) and adjust the capacity dynamically as elements are added/removed. - When the array reaches its current capacity, double the capacity. - When the array\'s size falls below half of its capacity, half the capacity. 2. **Efficient Search**: Implement a method `contains(value)` to check if a value exists in the array. This method should use binary search if the array is sorted and linear search otherwise. - Implement an `is_sorted` property to check if the array is currently sorted. 3. **Sorting**: Implement a method `sort_array()` that sorts the array in ascending order. 4. **Element Removal**: Implement a method `remove_element(value)` to remove the first occurrence of a value from the array, if it exists. Implementation ```python class DynamicArray: def __init__(self, initial_capacity=2): self.capacity = initial_capacity self.size = 0 self.array = [None] * self.capacity self.sorted = False def add_element(self, value): if self.size == self.capacity: self._resize(2 * self.capacity) self.array[self.size] = value self.size += 1 self.sorted = False def remove_element(self, value): for i in range(self.size): if self.array[i] == value: for j in range(i, self.size - 1): self.array[j] = self.array[j + 1] self.size -= 1 self.array[self.size] = None if self.size <= self.capacity // 2: self._resize(self.capacity // 2) return def contains(self, value): if self.sorted: return self._binary_search(value) return self._linear_search(value) def sort_array(self): self.array = self.array[:self.size] self.array.sort() self.sorted = True def _resize(self, new_capacity): new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.capacity = new_capacity def _linear_search(self, value): for i in range(self.size): if self.array[i] == value: return True return False def _binary_search(self, value): left, right = 0, self.size - 1 while left <= right: mid = (left + right) // 2 if self.array[mid] == value: return True elif self.array[mid] < value: left = mid + 1 else: right = mid - 1 return False @property def is_sorted(self): return self.sorted ``` Input Format - The constructor takes an optional integer parameter `initial_capacity`, which sets the initial capacity of the dynamic array. - Method `add_element` takes a single value to be added to the dynamic array. - Method `remove_element` takes a single value to be removed from the dynamic array. - Method `contains` takes a single value to check existence in the dynamic array. Output Format - Method `contains` returns a boolean indicating whether the value is in the array. - Method `remove_element` updates the dynamic array and does not return a value. - Method `sort_array` sorts the dynamic array and does not return a value. Constraints - The values added to the array can be of any data type that supports comparison operations. - Ensure efficient resizing and element removal to maintain the array\'s performance. You should write your implementation within the given `DynamicArray` class template.","solution":"class DynamicArray: def __init__(self, initial_capacity=2): self.capacity = initial_capacity self.size = 0 self.array = [None] * self.capacity self.sorted = False def add_element(self, value): if self.size == self.capacity: self._resize(2 * self.capacity) self.array[self.size] = value self.size += 1 self.sorted = False def remove_element(self, value): for i in range(self.size): if self.array[i] == value: for j in range(i, self.size - 1): self.array[j] = self.array[j + 1] self.size -= 1 self.array[self.size] = None if self.size <= self.capacity // 2 and self.capacity > 2: self._resize(max(self.capacity // 2, 2)) return def contains(self, value): if self.sorted: return self._binary_search(value) return self._linear_search(value) def sort_array(self): self.array = self.array[:self.size] self.array.sort() self.sorted = True def _resize(self, new_capacity): new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.capacity = new_capacity def _linear_search(self, value): for i in range(self.size): if self.array[i] == value: return True return False def _binary_search(self, value): left, right = 0, self.size - 1 while left <= right: mid = (left + right) // 2 if self.array[mid] == value: return True elif self.array[mid] < value: left = mid + 1 else: right = mid - 1 return False @property def is_sorted(self): return self.sorted"},{"question":"--- [Question 2]: **Kruskal\'s Algorithm for Minimum Spanning Tree** Background: Kruskal\'s Algorithm is a popular algorithm in graph theory used to find the minimum spanning tree (MST) of a connected undirected graph. The algorithm works by sorting all the edges in the graph by their weight, then adding edges to the MST from the smallest weight to the largest, while avoiding cycles. # Problem Statement You are required to implement Kruskal\'s Algorithm to find the minimum spanning tree of a given connected, undirected graph. The graph will be provided as a list of edges with corresponding weights. # Function Signature ```python def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: ``` # Input * `n`: An integer representing the number of vertices in the graph. * `edges`: A `List[Tuple[int, int, int]]` where each tuple represents an edge `(u, v, w)` describing an edge between node `u` and node `v` with weight `w`. # Output * Returns a `List[Tuple[int, int, int]]` representing the edges in the minimum spanning tree (MST). Each tuple describes an edge `(u, v, w)`. # Constraints * `1 <= n <= 100` * Each edge\'s weight `w` is a non-negative integer `0 <= w <= 1000`. * The graph is guaranteed to be connected. # Performance Requirements * The implementation should have a time complexity of O(E log E), where E is the number of edges, and a space complexity of O(E). # Example ```python # Example 1 n = 4 edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] assert kruskal_mst(n, edges) == [(2, 3, 4), (0, 3, 5), (0, 1, 10)] # Example 2 n = 5 edges = [ (0, 1, 2), (0, 3, 6), (1, 2, 3), (1, 3, 8), (1, 4, 5), (2, 4, 7), (3, 4, 9) ] assert kruskal_mst(n, edges) == [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] ``` # Notes * Use a disjoint-set (union-find) data structure to efficiently handle cycle detection. * Ensure to sort edges based on their weights to process them in the correct order by Kruskal\'s Algorithm. ---","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: # Sort edges by their weights edges.sort(key=lambda x: x[2]) uf = UnionFind(n) mst = [] for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst.append((u, v, w)) return mst"},{"question":"# Coding Assessment Question **Context:** You are tasked with developing a scheduling system for a clinic that manages appointments efficiently. Your task is to implement a function that determines the next available time slot for a new appointment, given the clinic\'s operating hours and existing appointments. **Function Specification:** - **Function Name**: `find_next_available_slot` - **Input**: - `start_time` (str): The start time of the clinic\'s operating hours in the format \\"HH:MM\\". - `end_time` (str): The end time of the clinic\'s operating hours in the format \\"HH:MM\\". - `appointments` (list): A list of tuples where each tuple contains the start time and end time of an existing appointment in the format (\\"HH:MM\\", \\"HH:MM\\"). - `appointment_duration` (int): The duration of the new appointment in minutes. - **Output**: - A string representing the next available time slot for the new appointment in the format \\"HH:MM\\". If no slot is available, return \\"No available slots\\". **Input Constraints**: - `start_time`, `end_time`, and appointment times are valid time strings in \\"HH:MM\\" format. - `appointments` are sorted in ascending order by start time. - `appointment_duration` is a positive integer and a multiple of 5. **Edge Cases to Consider**: - Overlapping appointments. - Appointments that start or end exactly at the clinic\'s operating hours. - No available slots within the given operating hours. **Examples**: ```python >>> find_next_available_slot(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"09:30\\"), (\\"10:00\\", \\"10:30\\"), (\\"11:00\\", \\"11:30\\")], 30) \'09:30\' >>> find_next_available_slot(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"09:30\\"), (\\"09:30\\", \\"10:00\\"), (\\"10:00\\", \\"10:30\\")], 30) \'10:30\' >>> find_next_available_slot(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"09:15\\"), (\\"09:20\\", \\"09:35\\"), (\\"10:00\\", \\"10:15\\"), (\\"10:45\\", \\"11:00\\")], 15) \'09:35\' >>> find_next_available_slot(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"12:00\\"), (\\"13:00\\", \\"17:00\\")], 45) \'12:00\' >>> find_next_available_slot(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"12:00\\"), (\\"12:00\\", \\"16:00\\"), (\\"16:00\\", \\"17:00\\")], 30) \'No available slots\' ``` **Implementation Notes**: - Ensure the implementation accounts for the entire range of operating hours and correctly handles edge cases. - The function should return times in 24-hour format (\\"HH:MM\\") and should avoid using any external libraries beyond Python’s built-in `datetime` module for managing and manipulating time values.","solution":"from datetime import datetime, timedelta def find_next_available_slot(start_time, end_time, appointments, appointment_duration): Finds the next available time slot for a new appointment within the given operating hours and existing appointments. Parameters: - start_time (str): The start time of the clinic\'s operating hours in the format \\"HH:MM\\". - end_time (str): The end time of the clinic\'s operating hours in the format \\"HH:MM\\". - appointments (list): A list of tuples where each tuple contains the start time and end time of an existing appointment in the format (\\"HH:MM\\", \\"HH:MM\\"). - appointment_duration (int): The duration of the new appointment in minutes. Returns: - str: The next available time slot for the new appointment in the format \\"HH:MM\\". If no slot is available, return \\"No available slots\\". def to_minutes(time_str): h, m = map(int, time_str.split(\':\')) return h * 60 + m def to_time_str(minutes): h = minutes // 60 m = minutes % 60 return f\\"{h:02}:{m:02}\\" start_minutes = to_minutes(start_time) end_minutes = to_minutes(end_time) slots = [] current_time = start_minutes for app in appointments: app_start = to_minutes(app[0]) app_end = to_minutes(app[1]) if app_start > current_time and app_start - current_time >= appointment_duration: slots.append((current_time, app_start)) current_time = max(current_time, app_end) if end_minutes - current_time >= appointment_duration: slots.append((current_time, end_minutes)) for slot_start, slot_end in slots: if slot_end - slot_start >= appointment_duration: return to_time_str(slot_start) return \\"No available slots\\""},{"question":"# Problem Statement You are given an array of integers and an integer target. Your task is to find out whether two numbers in the array sum up to the given target. If such a pair exists, return the indices of the two numbers in a tuple (index1, index2). Note that the indices should be zero-based. If no such pair exists, return `None`. Your solution should aim to have O(n) time complexity. # Input - `nums`: A list of integers. - `target`: An integer. # Output - A tuple of two integers indicating the indices of the two numbers that sum up to the target, or `None` if no such pair exists. # Constraints - The list of integers can include both positive and negative numbers. - Length of the list will be at most 10^5. - Each input will have exactly one solution or none. # Examples ```python assert find_two_sum([2, 7, 11, 15], 9) == (0, 1) assert find_two_sum([3, 2, 4], 6) == (1, 2) assert find_two_sum([-1, -2, -3, -4, -5], -8) == (2, 4) assert find_two_sum([1, 2, 3, 4], 10) == None ``` # Requirements - Your implementation should have a time complexity of O(n). - You are allowed to use additional space proportional to the input size. # Notes - The indices in the returned tuple can be in any order that satisfies the condition. - Each input will have at most one valid pair that sums to the target.","solution":"def find_two_sum(nums, target): Returns a tuple of indices of the two numbers that add up to the target, or None if no such pair exists. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"# Divisor Count and Sum You are required to implement a function that takes a positive integer and returns the count of its divisors along with the sum of all divisors. The function should include input validation to ensure the provided input is a positive integer. Function Signature ```python def divisor_count_and_sum(number: int) -> tuple: Returns the count and sum of all divisors of the given number. Args: number (int): The number whose divisors are to be calculated. Returns: tuple: A tuple containing two elements - the count of divisors and the sum of all divisors. Raises: ValueError: If \'number\' is not a positive integer. ``` Example ```python >>> divisor_count_and_sum(6) (4, 12) # 1, 2, 3, 6 are the divisors of 6: count is 4, sum is 12 >>> divisor_count_and_sum(12) (6, 28) # 1, 2, 3, 4, 6, 12 are the divisors of 12: count is 6, sum is 28 ``` # Requirements 1. **Input Validation**: - Ensure `number` is a positive integer. If not, raise a `ValueError` with the message \\"Input number must be a positive integer.\\" 2. **Output Format**: - The function should return a tuple - the first element is the count of divisors, and the second element is the sum of all divisors. 3. **Constraints**: - Only positive integers need to be handled. - Do not use any external libraries for the implementation. # Objective This question tests the student\'s understanding of: - Iterating and checking divisors. - Tuple handling and multiple return values. - Input validation and error handling in Python.","solution":"def divisor_count_and_sum(number: int) -> tuple: Returns the count and sum of all divisors of the given number. Args: number (int): The number whose divisors are to be calculated. Returns: tuple: A tuple containing two elements - the count of divisors and the sum of all divisors. Raises: ValueError: If \'number\' is not a positive integer. if not isinstance(number, int) or number <= 0: raise ValueError(\\"Input number must be a positive integer.\\") divisor_count = 0 divisor_sum = 0 for i in range(1, number + 1): if number % i == 0: divisor_count += 1 divisor_sum += i return divisor_count, divisor_sum"},{"question":"# Linked List Node Insertion and Deletion You are tasked with implementing a linked list and performing several operations on it, such as insertion at different positions and deletion based on the value. You need to create a singly linked list where each node contains an integer value. Problem Statement Implement the following functions in Python to manage the linked list: 1. **`class Node`**: - Class representing a single node in a linked list. - **Attributes**: - `val`: integer value contained in the node. - `next`: reference to the next node in the linked list (initially `None`). 2. **`class LinkedList`**: - Class representing the singly linked list with the following methods: - **`__init__(self)`**: - Initializes an empty linked list. - **`insert_at_head(self, val: int) -> None`**: - Inserts a new node with the value `val` at the beginning of the list. - **Input**: - `val`: integer value to be added. - **`insert_at_end(self, val: int) -> None`**: - Inserts a new node with the value `val` at the end of the list. - **Input**: - `val`: integer value to be added. - **`insert_at_position(self, pos: int, val: int) -> bool`**: - Inserts a new node with the value `val` at the position `pos` (0-based index). - **Input**: - `pos`: position (index) where the new node should be inserted. - `val`: integer value to be added. - **Output**: - Return `True` if the node was successfully inserted; otherwise, return `False` (e.g., if the position is out of bounds). - **`delete_by_value(self, val: int) -> bool`**: - Deletes the first occurrence of a node with the value `val` from the list. - **Input**: - `val`: integer value to be deleted. - **Output**: - Return `True` if a node with the value `val` was found and deleted; otherwise, return `False` if no such node exists. 3. **`__str__(self) -> str`**: - Defines the string representation of the linked list for easier visualization. - **Output**: - A string containing all values in the linked list separated by arrows `->`. # Example ```python # Creating a linked list linked_list = LinkedList() # Inserting at head linked_list.insert_at_head(10) print(linked_list) # Output: \\"10\\" # Inserting at end linked_list.insert_at_end(20) print(linked_list) # Output: \\"10 -> 20\\" # Inserting at a specific position linked_list.insert_at_position(1, 15) print(linked_list) # Output: \\"10 -> 15 -> 20\\" linked_list.insert_at_position(0, 5) print(linked_list) # Output: \\"5 -> 10 -> 15 -> 20\\" # Deleting by value linked_list.delete_by_value(10) print(linked_list) # Output: \\"5 -> 15 -> 20\\" linked_list.delete_by_value(5) print(linked_list) # Output: \\"15 -> 20\\" linked_list.delete_by_value(100) # Value not in the list print(linked_list) # Output: \\"15 -> 20\\" ``` Ensure proper handling of edge cases such as empty list operations and out-of-bound insertions.","solution":"class Node: def __init__(self, val: int): Initializes a node with a given value and sets the next node to None. self.val = val self.next = None class LinkedList: def __init__(self): Initializes an empty linked list. self.head = None def insert_at_head(self, val: int) -> None: Insert a new node with the value val at the beginning of the list. new_node = Node(val) new_node.next = self.head self.head = new_node def insert_at_end(self, val: int) -> None: Insert a new node with the value val at the end of the list. new_node = Node(val) if self.head is None: self.head = new_node else: current = self.head while current.next is not None: current = current.next current.next = new_node def insert_at_position(self, pos: int, val: int) -> bool: Insert a new node with the value val at the position pos (0-based index). Return True if the node was successfully inserted, return False otherwise. if pos < 0: return False new_node = Node(val) if pos == 0: new_node.next = self.head self.head = new_node return True current = self.head index = 0 while current is not None and index < pos - 1: current = current.next index += 1 if current is None: return False new_node.next = current.next current.next = new_node return True def delete_by_value(self, val: int) -> bool: Delete the first occurrence of a node with the value val from the list. Return True if a node with the value val was found and deleted, return False otherwise. current = self.head previous = None while current is not None: if current.val == val: if previous is None: self.head = current.next else: previous.next = current.next return True previous = current current = current.next return False def __str__(self) -> str: Define the string representation of the linked list for easier visualization. values = [] current = self.head while current is not None: values.append(str(current.val)) current = current.next return \\" -> \\".join(values)"},{"question":"# Problem Statement: Validate and Normalize MAC Addresses You are working for a networking company that needs a utility to validate and normalize MAC (Media Access Control) addresses. MAC addresses are unique identifiers assigned to network interfaces for communications on the physical network segment. The standard format for MAC addresses is 6 octets, which can be represented in various formats such as `XX:XX:XX:XX:XX:XX`, `XXXX.XXXX.XXXX`, or `XX-XX-XX-XX-XX-XX`. **Objective:** Your task is to implement two functions, `validate_mac` and `normalize_mac`, that validate and normalize MAC addresses respectively. # Function 1: validate_mac **Input:** - `mac: str` - A string representing the MAC address to be validated. **Output:** - `valid: bool` - A boolean indicating whether the input string is a valid MAC address. # Function 2: normalize_mac **Input:** - `mac: str` - A string representing the MAC address to be normalized. **Output:** - `normalized_mac: str` - The normalized MAC address in the `XX:XX:XX:XX:XX:XX` format if the input is valid, otherwise an empty string. # Constraints: 1. The input to `validate_mac` can be any string. 2. Valid MAC address formats are: - `XX:XX:XX:XX:XX:XX` - `XX-XX-XX-XX-XX-XX` - `XXXX.XXXX.XXXX` - Where `X` is a hexadecimal digit (0-9, A-F). 3. The output of `normalize_mac` should be in the `XX:XX:XX:XX:XX:XX` format using uppercase letters. 4. Your implementation should handle any edge cases like incorrect lengths, invalid characters, or mixed formats. # Example: ```python def validate_mac(mac: str) -> bool: # Your implementation here pass def normalize_mac(mac: str) -> str: # Your implementation here pass # Test cases: # Validate assert validate_mac(\\"00:1A:2B:3C:4D:5E\\") == True assert validate_mac(\\"00-1A-2B-3C-4D-5E\\") == True assert validate_mac(\\"001A.2B3C.4D5E\\") == True assert validate_mac(\\"00:1A:2B:3C:4D:5Z\\") == False assert validate_mac(\\"00-1A-2B-3C-4D\\") == False # Normalize assert normalize_mac(\\"00:1A:2B:3C:4D:5E\\") == \\"00:1A:2B:3C:4D:5E\\" assert normalize_mac(\\"00-1A-2B-3C-4D-5E\\") == \\"00:1A:2B:3C:4D:5E\\" assert normalize_mac(\\"001A.2B3C.4D5E\\") == \\"00:1A:2B:3C:4D:5E\\" assert normalize_mac(\\"00:1A:2B:3C:4D:5Z\\") == \\"\\" assert normalize_mac(\\"00-1A-2B-3C-4D\\") == \\"\\" ``` Your solution should efficiently handle large inputs, provide proper validation, and ensure the correct format for output.","solution":"import re def validate_mac(mac: str) -> bool: Validates if the input string is a valid MAC address. Args: mac (str): The string representing the MAC address. Returns: bool: True if valid, False otherwise. # MAC address regex patterns for different formats patterns = [ r\'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})\', # XX:XX:XX:XX:XX:XX or XX-XX-XX-XX-XX-XX r\'^([0-9A-Fa-f]{4}.){2}[0-9A-Fa-f]{4}\' # XXXX.XXXX.XXXX ] # Check if any of the patterns match the input string for pattern in patterns: if re.match(pattern, mac): return True return False def normalize_mac(mac: str) -> str: Normalizes the input MAC address to the format XX:XX:XX:XX:XX:XX. Args: mac (str): The string representing the MAC address. Returns: str: The normalized MAC address in XX:XX:XX:XX:XX:XX format. Returns an empty string if the input is invalid. if not validate_mac(mac): return \\"\\" # Removing delimiters and converting to uppercase mac = re.sub(r\'[:-]\', \'\', mac).replace(\'.\', \'\').upper() # Reformatting to XX:XX:XX:XX:XX:XX normalized_mac = \':\'.join(mac[i:i+2] for i in range(0, 12, 2)) return normalized_mac"},{"question":"# Balanced Brackets in Code Given a string representing a piece of code, determine if the code contains balanced brackets. The brackets that need to be balanced are: `()`, `{}`, `[]`, and `<>`. A piece of code is said to have balanced brackets if for every opening bracket, there is a matching closing bracket in the correct order. **Problem Statement**: Write a function `is_balanced(code: str) -> bool` that checks if the given string of code has balanced brackets. **Input**: - A string `code` containing any number of characters, including the brackets `()`, `{}`, `[]`, and `<>`. **Output**: - A boolean value `True` if the brackets are balanced, and `False` otherwise. **Constraints**: - The input string can be of any length up to (10^5) characters. ```python def is_balanced(code: str) -> bool: This function checks if the input string has balanced brackets. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\', \'>\': \'<\'} for char in code: if char in matching_bracket.values(): # if it\'s an opening bracket stack.append(char) elif char in matching_bracket: # if it\'s a closing bracket if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return False return not stack # Example usage if __name__ == \\"__main__\\": example_code = \\"{[(<>)<()>]}\\" print(is_balanced(example_code)) # Should return True ``` **Explanation and Examples**: - `\\"{[(<>)<()>]}\\"` -> `True` - `\\"((([[[<>]]])))\\"` -> `True` - `\\"{[(<>)<()>]\\"` -> `False` (missing closing `}`) - `\\"[(])\\"` -> `False` (unbalanced brackets) **Note**: Test your solution with additional edge cases and different lengths of input strings to ensure robustness.","solution":"def is_balanced(code: str) -> bool: This function checks if the input string has balanced brackets. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\', \'>\': \'<\'} for char in code: if char in matching_bracket.values(): # if it\'s an opening bracket stack.append(char) elif char in matching_bracket: # if it\'s a closing bracket if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return False return not stack"},{"question":"# Problem Statement You need to simulate a simplified online book reader system. Implement the class `BookReader` that supports the following methods: - `add_book(book_id: int, title: str)`: - Adds a new book to the system with a unique `book_id` and `title`. - `start_reading(book_id: int)`: - Starts reading the book specified by `book_id`. - `get_current_book()`: - Returns the `book_id` and `title` of the currently reading book. If no book is being read, return `None`. - `stop_reading()`: - Stops reading the current book. If no book is being read, do nothing. # Constraints * The input `book_id` is always unique for each book and is a positive integer. * The `title` is a string consisting of printable ASCII characters. * The number of books added to the system does not exceed 10^5. # Example ```python reader = BookReader() reader.add_book(1, \\"The Great Gatsby\\") reader.add_book(2, \\"1984\\") assert reader.get_current_book() == None reader.start_reading(1) assert reader.get_current_book() == (1, \\"The Great Gatsby\\") reader.start_reading(2) assert reader.get_current_book() == (2, \\"1984\\") reader.stop_reading() assert reader.get_current_book() == None reader.start_reading(3) # starting a book that doesn\'t exist assert reader.get_current_book() == None ``` # Explanation 1. After adding \\"The Great Gatsby\\" and \\"1984\\", no book is currently being read. 2. When `start_reading(1)` is called, \\"The Great Gatsby\\" is now the current book. 3. Starting to read \\"1984\\" makes it the new current book. 4. Stopping reading means no book is currently being read. 5. Trying to start a non-existent book (id=3) does not change the current book. Implement the `BookReader` class to solve this problem efficiently.","solution":"class BookReader: def __init__(self): self.books = {} self.current_book_id = None def add_book(self, book_id: int, title: str): self.books[book_id] = title def start_reading(self, book_id: int): if book_id in self.books: self.current_book_id = book_id def get_current_book(self): if self.current_book_id is None: return None return (self.current_book_id, self.books[self.current_book_id]) def stop_reading(self): self.current_book_id = None"},{"question":"Binary Search Tree (BST) Operations You are asked to implement several key functions to manipulate a Binary Search Tree (BST). The BST should support insertion, searching, deletion, and inorder traversal to verify the correct structure of the tree. Problem Statement Implement the following functions in Python: 1. **`insert(root: \'TreeNode\', val: int) -> \'TreeNode\'`**: - This function inserts a new node with the given value `val` into the BST rooted at `root`. - **Input**: - `root`: the root node of the BST. - `val`: the integer value to insert. - **Output**: The root node of the BST after inserting the new value. 2. **`search(root: \'TreeNode\', val: int) -> bool`**: - This function checks whether a node with the given value `val` exists in the BST. - **Input**: - `root`: the root node of the BST. - `val`: the integer value to search for. - **Output**: `True` if a node with the value `val` exists in the BST, `False` otherwise. 3. **`delete(root: \'TreeNode\', val: int) -> \'TreeNode\'`**: - This function deletes the node with the given value `val` from the BST, maintaining the BST properties. - **Input**: - `root`: the root node of the BST. - `val`: the integer value to delete. - **Output**: The root node of the BST after deleting the specified value. 4. **`inorder_traversal(root: \'TreeNode\') -> list`**: - This function returns a list of the node values in the BST produced by an in-order traversal. - **Input**: - `root`: the root node of the BST. - **Output**: A list of node values in in-order traversal. # Additional Details Define the `TreeNode` class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example: ```python # Creating a BST root = TreeNode(5) root = insert(root, 2) root = insert(root, 8) root = insert(root, 1) root = insert(root, 3) # Searching for a value print(search(root, 2)) # Output: True print(search(root, 10)) # Output: False # Deleting a value root = delete(root, 2) # Checking the structure with an inorder traversal print(inorder_traversal(root)) # Output: [1, 3, 5, 8] ``` Ensure all the intermediate steps such as recursive calls for insertion, searching, and deletion, and maintaining the BST properties, are included in the logic.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root def search(root, val): if root is None: return False if val == root.val: return True elif val < root.val: return search(root.left, val) else: return search(root.right, val) def delete(root, val): if root is None: return root if val < root.val: root.left = delete(root.left, val) elif val > root.val: root.right = delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = get_min(root.right) root.val = min_larger_node.val root.right = delete(root.right, min_larger_node.val) return root def get_min(node): current = node while current.left is not None: current = current.left return current def inorder_traversal(root): res = [] if root is not None: res = inorder_traversal(root.left) res.append(root.val) res = res + inorder_traversal(root.right) return res"},{"question":"# Inventory Management with Backorder System You are tasked with extending an existing inventory management system to include a backorder feature when items are out of stock. This system should support adding items, updating quantities, handling sales, and managing backorders effectively. Requirements: 1. **Inventory Class**: Implement a class `Inventory` with methods to handle adding items, updating quantities, processing sales, and managing backorders. 2. **Backorder Mechanism**: If a sale is attempted for an out-of-stock item, the system should allow the sale to proceed, marking it as a backorder. When stock is replenished, fulfill the backorders automatically. 3. **Error Handling**: Include error handling for invalid operations such as attempting to reduce stock below zero when updating quantities. Technical Specifications: * **Class Methods**: - `add_item(item_name: str, quantity: int) -> None`: Adds a new item to the inventory or updates the quantity if the item already exists. - `update_quantity(item_name: str, quantity: int) -> None`: Updates the stock quantity of a specified item. - `process_sale(item_name: str, quantity: int) -> None`: Processes a sales transaction. If the item is out of stock, record the sale as a backorder. - `get_inventory_status() -> dict`: Returns the current inventory levels and backlog status. - `fulfill_backorders() -> None`: Processes and fulfills any backordered sales when stock becomes available. # Example ```python class Inventory: def __init__(self): # Initialize inventory and backorder systems self.stock = {} self.backorders = {} def add_item(self, item_name: str, quantity: int) -> None: # Implementation here def update_quantity(self, item_name: str, quantity: int) -> None: # Implementation here def process_sale(self, item_name: str, quantity: int) -> None: # Implementation here def get_inventory_status(self) -> dict: # Implementation here def fulfill_backorders(self) -> None: # Implementation here # Example Usage inventory = Inventory() inventory.add_item(\'Laptop\', 10) inventory.process_sale(\'Laptop\', 15) # Expect this to be backordered inventory.update_quantity(\'Laptop\', 5) # Expect this to fulfill the backorder print(inventory.get_inventory_status()) # View the status of inventory and backorders ``` **Constraints:** * Ensure proper synchronization for possible concurrent operations (if applicable). * Protect against invalid operations like processing a sale for a non-existent item. Create the `Inventory` class and implement the methods to handle the described functionality while ensuring robust error handling and efficient management of stock and backorders.","solution":"class Inventory: def __init__(self): self.stock = {} self.backorders = {} def add_item(self, item_name: str, quantity: int) -> None: if item_name in self.stock: self.stock[item_name] += quantity else: self.stock[item_name] = quantity self.fulfill_backorders(item_name) def update_quantity(self, item_name: str, quantity: int) -> None: if item_name not in self.stock: raise ValueError(f\\"Item \'{item_name}\' not found in inventory.\\") if self.stock[item_name] + quantity < 0: raise ValueError(f\\"Cannot reduce stock of {item_name} below zero.\\") self.stock[item_name] += quantity self.fulfill_backorders(item_name) def process_sale(self, item_name: str, quantity: int) -> None: if item_name not in self.stock: raise ValueError(f\\"Item \'{item_name}\' not found in inventory.\\") if self.stock[item_name] >= quantity: self.stock[item_name] -= quantity else: self.backorders[item_name] = self.backorders.get(item_name, 0) + quantity - self.stock[item_name] self.stock[item_name] = 0 def get_inventory_status(self) -> dict: return { \'stock\': self.stock.copy(), \'backorders\': self.backorders.copy() } def fulfill_backorders(self, item_name: str) -> None: if item_name in self.backorders and self.stock[item_name] > 0: fulfilled_qty = min(self.stock[item_name], self.backorders[item_name]) self.stock[item_name] -= fulfilled_qty self.backorders[item_name] -= fulfilled_qty if self.backorders[item_name] == 0: del self.backorders[item_name]"},{"question":"# Context Given a set of m-dimensional data points and their respective distances from an origin, we seek to perform vector normalization. Normalization is crucial in various fields including machine learning, signal processing, and statistics as it standardizes the data to fit within a consistent scale. # Task Implement a function that takes in a list of m-dimensional data points, normalizes each point with respect to Euclidean distance from the origin, and returns the list of normalized points. # Function to Implement ```python def normalize_points(data_points: list[list[float]]) -> list[list[float]]: Args: data_points: A list of data points (each being a list of m float numbers representing m-dimensional coordinates). Returns: A list of data points where each point is normalized by its Euclidean distance from the origin. pass ``` # Expected Constraints and Limitations - Each data point list will have a length of m (1 ≤ m ≤ 50). - The total number of data points n will be between 1 and 10^3. - All coordinate values will be floats between -10^3 and 10^3. - No data point will be the zero vector. # Requirements - Validate that no data point is the zero vector to avoid division by zero. - Perform normalization using the Euclidean distance formula. - The solution should efficiently handle the provided constraints with time complexity of O(n*m). # Example ```python data_points = [[3.0, 4.0], [1.0, 1.0, 1.0], [-3.0, -4.0, 0.0]] output = normalize_points(data_points) print(output) # Expected Output: # [[0.6, 0.8], [0.5773502691896257, 0.5773502691896257, 0.5773502691896257], [-0.6, -0.8, 0.0]] ```","solution":"import math def normalize_points(data_points: list[list[float]]) -> list[list[float]]: def euclidean_distance(point): return math.sqrt(sum(x ** 2 for x in point)) normalized_data_points = [] for point in data_points: distance = euclidean_distance(point) normalized_point = [x / distance for x in point] normalized_data_points.append(normalized_point) return normalized_data_points"},{"question":"# Question: Surround Region Flipping Scenario You are given an `m x n` board containing \'X\' and \'O\' characters. Your task is to capture all regions surrounded by \'X\'. A region is captured by flipping all \'O\'s into \'X\'s in that surrounded region. # Task Write a function: ```python def capture_regions(board: List[List[str]]) -> List[List[str]]: Capture all regions surrounded by \'X\' on the given board. A region is surrounded if it is completely enclosed by \'X\'. Flip all \'O\'s in such a region to \'X\'s. Args: - board: List of List of characters, representing the board layout. Returns: - The board with all surrounded regions captured. ``` # Input - `board`: A 2D list representing the m x n board, where each cell contains either \'X\' or \'O\'. # Output - Returns a 2D list representing the modified board. # Constraints - The input board\'s dimensions will be such that `1 <= m, n <= 200`. - The board only contains the characters \'X\' and \'O\'. # Performance Requirements - Ensure the solution can handle boards up to the maximum constraint efficiently. - Leverage depth-first search (DFS) or breadth-first search (BFS) for capturing surrounded regions. # Examples - `>>> capture_regions([[\'X\', \'X\', \'X\', \'X\'], [\'X\', \'O\', \'O\', \'X\'], [\'X\', \'X\', \'O\', \'X\'], [\'X\', \'O\', \'X\', \'X\']])` - Output: [[\'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\'], [\'X\', \'O\', \'X\', \'X\']] # Notes - \'O\'s on the boarder or connected to an \'O\' on the boarder should not be flipped. - Use an additional marker if needed to temporarily mark cells during the process to avoid premature flipping. - Start by marking all \'O\'s that are connected to the borders, then flip the remaining unmarked \'O\'s to \'X\', and finally revert the marker back to \'O\'. # Hints - Use a flood fill algorithm to start from the borders and mark all connected \'O\'s differently. - Traverse the board multiple times if necessary to correctly identify and flip surrounded regions.","solution":"def capture_regions(board): if not board or not board[0]: return board rows, cols = len(board), len(board[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != \'O\': return board[r][c] = \'A\' # Temporarily mark this \'O\' to \'A\' dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) # Start from borders and mark all connected \'O\'s for r in range(rows): for c in range(cols): if (r in {0, rows-1} or c in {0, cols-1}) and board[r][c] == \'O\': dfs(r, c) # Flip all remaining \'O\'s to \'X\', then flip \'A\' back to \'O\' for r in range(rows): for c in range(cols): if board[r][c] == \'O\': board[r][c] = \'X\' elif board[r][c] == \'A\': board[r][c] = \'O\' return board"},{"question":"# Array Subset Sum Problem Background The subset sum problem is a common problem in computer science, particularly in fields such as cryptography and algorithm design. Given a set of integers, the task is to determine whether there is a non-empty subset whose elements sum up to a given target value. While the problem can be solved using various approaches, a common method is using Dynamic Programming (DP) to efficiently determine the subset\'s existence. Task Implement a function to determine whether a non-empty subset of a given set of integers sums up to a specified target value. You may assume that all input integers are non-negative. Your function should have the following signature: ```python def subset_sum(nums: list[int], target: int) -> bool: ``` Constraints - The input list `nums` will have 1 to 100 elements. - Each element in `nums` will be between 1 and 1000. - The target value `target` will be between 1 and 100000. Example Usage ```python # Test cases assert subset_sum([1, 2, 3, 7], 6) == True, \\"Test Case 1 Failed\\" assert subset_sum([1, 2, 7, 1], 10) == True, \\"Test Case 2 Failed\\" assert subset_sum([1, 3, 4, 8], 12) == True, \\"Test Case 3 Failed\\" assert subset_sum([1, 2, 3, 4], 6) == True, \\"Test Case 4 Failed\\" assert subset_sum([1, 2, 3, 8], 7) == False, \\"Test Case 5 Failed\\" ``` Notes - Optimize the solution for efficient execution within the given constraints. - Consider edge cases like empty input list, small or large target values relative to the sum of all elements, and duplicate elements in the list. - Properly handle and document your code for readability and maintenance. Note: Write appropriate unit tests to verify your `subset_sum` function implementation.","solution":"def subset_sum(nums, target): Determines whether a non-empty subset of the given set of integers sums up to the target value. :param nums: List of non-negative integers. :param target: Target sum. :return: True if such a subset exists, otherwise False. n = len(nums) dp = [False] * (target + 1) dp[0] = True # A sum of 0 can always be achieved by choosing an empty subset for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"# Implementing a To-Do List Manager Context A To-Do List Manager is a fundamental tool used for keeping track of tasks that need to be completed. It allows users to add, update, mark as complete, and delete tasks. Additionally, it provides functionalities to organize and list tasks based on their completion status and due dates. Objective Write a Python class to manage a To-Do List. Your implementation should define methods that allow adding tasks, updating task details, marking tasks as complete, deleting tasks, and listing tasks based on their completion status and due dates. Core Implementation Requirements 1. Implement a class `ToDoListManager` with the following methods: - `__init__(self)`: Initializes an empty task list. - `add_task(self, name, due_date)`: Adds a new task with the specified name and due date. - `update_task(self, task_id, name=None, due_date=None)`: Updates the task details (name and/or due date) identified by `task_id`. - `complete_task(self, task_id)`: Marks the task identified by `task_id` as complete. - `delete_task(self, task_id)`: Deletes the task identified by `task_id`. - `list_tasks(self, show_completed=True)`: Lists all tasks, optionally filtering by completed status. - `list_overdue_tasks(self)`: Lists all tasks that are overdue based on the current date. Constraints - Each task should be uniquely identified by an `id` starting from 1, auto-incremented with each new task. - The `due_date` should be a string in the format \\"YYYY-MM-DD\\". - Display overdue tasks based on the current date in the \\"YYYY-MM-DD\\" format. Example Here\'s an example to illustrate the usage: ```python from datetime import datetime class ToDoListManager: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, name, due_date): self.tasks.append({ \\"id\\": self.next_id, \\"name\\": name, \\"due_date\\": due_date, \\"completed\\": False }) self.next_id += 1 def update_task(self, task_id, name=None, due_date=None): for task in self.tasks: if task[\\"id\\"] == task_id: if name: task[\\"name\\"] = name if due_date: task[\\"due_date\\"] = due_date break def complete_task(self, task_id): for task in self.tasks: if task[\\"id\\"] == task_id: task[\\"completed\\"] = True break def delete_task(self, task_id): self.tasks = [task for task in self.tasks if task[\\"id\\"] != task_id] def list_tasks(self, show_completed=True): return [(task[\\"id\\"], task[\\"name\\"], task[\\"due_date\\"], task[\\"completed\\"]) for task in self.tasks if task[\\"completed\\"] == show_completed] def list_overdue_tasks(self): today = datetime.now().strftime(\\"%Y-%m-%d\\") return [(task[\\"id\\"], task[\\"name\\"], task[\\"due_date\\"]) for task in self.tasks if task[\\"due_date\\"] < today and not task[\\"completed\\"]] # Example usage: if __name__ == \\"__main__\\": todo = ToDoListManager() todo.add_task(\\"Buy groceries\\", \\"2023-11-01\\") todo.add_task(\\"Workout\\", \\"2023-10-30\\") todo.complete_task(1) print(todo.list_tasks(show_completed=False)) print(todo.list_overdue_tasks()) ``` Your task is to complete the `ToDoListManager` class meeting the specified requirements.","solution":"from datetime import datetime class ToDoListManager: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, name, due_date): self.tasks.append({ \\"id\\": self.next_id, \\"name\\": name, \\"due_date\\": due_date, \\"completed\\": False }) self.next_id += 1 def update_task(self, task_id, name=None, due_date=None): for task in self.tasks: if task[\\"id\\"] == task_id: if name: task[\\"name\\"] = name if due_date: task[\\"due_date\\"] = due_date break def complete_task(self, task_id): for task in self.tasks: if task[\\"id\\"] == task_id: task[\\"completed\\"] = True break def delete_task(self, task_id): self.tasks = [task for task in self.tasks if task[\\"id\\"] != task_id] def list_tasks(self, show_completed=True): return [(task[\\"id\\"], task[\\"name\\"], task[\\"due_date\\"], task[\\"completed\\"]) for task in self.tasks if task[\\"completed\\"] == show_completed] def list_overdue_tasks(self): today = datetime.now().strftime(\\"%Y-%m-%d\\") return [(task[\\"id\\"], task[\\"name\\"], task[\\"due_date\\"]) for task in self.tasks if task[\\"due_date\\"] < today and not task[\\"completed\\"]]"},{"question":"# Question: Implementing Breadth-First Search and Shortest Path in a Grid You are tasked with implementing a Breadth-First Search (BFS) algorithm to find the shortest path from a starting point to a destination in a 2D grid where some cells are blocked. The grid is represented as a list of lists of integers, with 0 indicating a blocked cell and 1 indicating a free cell. The movement is allowed in four possible directions (up, down, left, right) and the path should not cross blocked cells. Your task is to implement the BFS algorithm to find and return the length of the shortest path from the start to the destination, without crossing any blocked cells. If there is no possible path, return -1. # Input and Output Specification * **Function to be implemented**: ```python def bfs_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: ``` * **Input**: - `grid` : List of lists of integers representing the grid. - `start` : A tuple representing the starting coordinates (starting row, starting column). - `end` : A tuple representing the destination coordinates (destination row, destination column). * **Output**: - An integer representing the length of the shortest path from `start` to `end`. If no path exists, return -1. **Example:** ```python grid = [ [1, 1, 0, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1], [0, 1, 0, 1, 0], [1, 1, 1, 1, 1] ] start = (0, 0) end = (4, 4) print(bfs_shortest_path(grid, start, end)) # Expected: 8, as the shortest path is found grid2 = [ [1, 1, 0, 0], [0, 1, 0, 1], [1, 1, 1, 1], [0, 0, 0, 1] ] start2 = (0, 0) end2 = (2, 2) print(bfs_shortest_path(grid2, start2, end2)) # Expected: 4, a clear shortest path avoiding 0s grid3 = [ [1, 1, 0], [0, 0, 1], [1, 1, 1] ] start3 = (0, 0) end3 = (2, 0) print(bfs_shortest_path(grid3, start3, end3)) # Expected: -1, no available route ``` # Requirements: * Implement the `bfs_shortest_path` function. * Handle the grid boundaries and ensure no paths go through blocked cells. * Utilize BFS to ensure the shortest path is found efficiently. # Constraints: * The grid size will be at least (3 times 3) and at most (1000 times 1000). * The grid will always contain at least one valid path of free cells between the start and end coordinates, except in the no-path scenario.","solution":"from collections import deque from typing import List, Tuple def bfs_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: if not grid or not grid[0] or grid[start[0]][start[1]] == 0 or grid[end[0]][end[1]] == 0: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 1: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"# Find the Difference Between Two Collections You are tasked with implementing two functions to determine the difference between two given collections (lists) of integers. The first function should compute the relative complement of the second list within the first list (i.e., the elements in the first list that are not in the second list). The second function should compute the symmetric difference between the two lists (i.e., the elements that are in either of the lists but not in both). Function 1: `relative_complement` Write a function that finds the elements that are present in the first list but not in the second list. ```python def relative_complement(list1: list[int], list2: list[int]) -> list[int]: Find the relative complement of the second list within the first list. Parameters: list1 (list[int]): The first input list. list2 (list[int]): The second input list. Returns: list[int]: A list containing elements present in list1 but not in list2. Raises: TypeError: If the inputs are not lists of integers. pass ``` Function 2: `symmetric_difference` Write a function that finds the symmetric difference between two lists. ```python def symmetric_difference(list1: list[int], list2: list[int]) -> list[int]: Find the symmetric difference between the first and the second list. Parameters: list1 (list[int]): The first input list. list2 (list[int]): The second input list. Returns: list[int]: A list containing elements that are in either list1 or list2 but not in both. Raises: TypeError: If the inputs are not lists of integers. pass ``` # Constraints * The input `list1` and `list2` will always be lists of integers. * The elements of the lists may contain duplicates. * Ensure the output lists do not contain duplicates. * You must handle the case of empty input lists correctly. # Performance Requirements * The functions should operate within reasonable time and space complexities as described in the analysis. Example Usage ```python assert relative_complement([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2] assert symmetric_difference([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 5, 6] ``` # Analysis * For the `relative_complement` function, the expected time complexity is O(n + m), where n is the length of list1 and m is the length of list2. * For the `symmetric_difference` function, the expected time complexity is O(n + m), where n is the length of list1 and m is the length of list2.","solution":"def relative_complement(list1: list[int], list2: list[int]) -> list[int]: Find the relative complement of the second list within the first list. Parameters: list1 (list[int]): The first input list. list2 (list[int]): The second input list. Returns: list[int]: A list containing elements present in list1 but not in list2. Raises: TypeError: If the inputs are not lists of integers. set2 = set(list2) return list(set([x for x in list1 if x not in set2])) def symmetric_difference(list1: list[int], list2: list[int]) -> list[int]: Find the symmetric difference between the first and the second list. Parameters: list1 (list[int]): The first input list. list2 (list[int]): The second input list. Returns: list[int]: A list containing elements that are in either list1 or list2 but not in both. Raises: TypeError: If the inputs are not lists of integers. set1, set2 = set(list1), set(list2) return list(set1.symmetric_difference(set2))"},{"question":"# Coding Assessment Question Problem Statement You are given a list of meeting time intervals consisting of start and end times. Your task is to write a function that determines if a person can attend all the given meetings. A person can attend all meetings if none of the meetings overlap. Function Signature ```python def can_attend_meetings(intervals): Determines if a person can attend all meetings without them overlapping. Parameters: intervals (List[Tuple[int, int]]): A list of tuples, where each tuple represents a meeting interval with a start and end time. Returns: bool: True if a person can attend all meetings, False otherwise. # your code here ``` Input Format - `intervals`: A list of tuples, where each tuple (start, end) represents a meeting interval. `start` is a non-negative integer representing the start time and `end` is a non-negative integer representing the end time. It is guaranteed that `start < end`. Output Format - A boolean value: `True` if a person can attend all meetings without any overlaps, `False` otherwise. Constraints - The number of intervals ( N ) ( (1 leq N leq 10^4) ). - `1 leq start, end leq 10^4`. Example Given the intervals: ```python intervals = [(0, 30), (5, 10), (15, 20)] ``` Calling `can_attend_meetings(intervals)` should return: ``` False ``` Given the intervals: ```python intervals = [(7, 10), (2, 4)] ``` Calling `can_attend_meetings(intervals)` should return: ``` True ``` # Requirements 1. Parse and sort the intervals by their start times. 2. Iterate through the intervals and check for any overlap. 3. Return `True` if no intervals overlap, otherwise return `False`.","solution":"def can_attend_meetings(intervals): Determines if a person can attend all meetings without them overlapping. Parameters: intervals (List[Tuple[int, int]]): A list of tuples, where each tuple represents a meeting interval with a start and end time. Returns: bool: True if a person can attend all meetings, False otherwise. # Sort intervals by their start times. intervals.sort(key=lambda x: x[0]) # Iterate through intervals to check for any overlap. for i in range(1, len(intervals)): # If the current meeting starts before the previous meeting ends, there\'s an overlap. if intervals[i][0] < intervals[i - 1][1]: return False return True"},{"question":"# Question You are required to implement a custom version of Dijkstra\'s algorithm that finds the shortest path in a weighted graph with edges that may have negative weights but no negative cycles. Instead of using a priority queue, use an adjacency list representation and optimize the algorithm for quick indexing and retrieval in the graph structure. # Problem Statement: Implement Dijkstra\'s algorithm with the following steps: - Initialize an adjacency list to represent the graph. - Track the shortest path distances using a simple dictionary. - Update distances using a relaxation technique without negative cycles exploiting. - Ensure the implementation avoids typical pitfalls of negative weights by checking the relaxation condition rigorously. # Input and Output: **Input**: - An integer `n` (1 ≤ `n` ≤ 1000) representing the number of vertices. - A list of edges, where each edge is a tuple `(u, v, w)` representing an edge from vertex `u` to vertex `v` with weight `w` (-100 ≤ `w` ≤ 100). **Output**: - A dictionary where the keys are the vertices and the values are the minimum distances from the source vertex `0`. # Constraints**: - The graph may contain negative weights but no negative weight cycles. - You cannot use a priority queue in your solution. - The graph is connected. # Performance Requirements**: - Aim to achieve a runtime complexity of O(n^2). # Example**: ```python Example 1: Input: n = 5, edges = [(0, 1, 2), (0, 3, 6), (1, 2, 3), (3, 1, 1), (2, 3, -2), (3, 4, 1), (4, 2, -1)] Output: {0: 0, 1: 2, 2: 5, 3: 3, 4: 4} Example 2: Input: n = 4, edges = [(0, 1, 4), (1, 2, -3), (2, 3, 2), (3, 1, -2)] Output: {0: 0, 1: 4, 2: 1, 3: 3} ``` Implement the `DijkstraAlgorithm` class accordingly. Ensure thorough testing and include edge cases.","solution":"def dijkstra(n, edges): Custom implementation of Dijkstra\'s algorithm with negative weights but no negative cycles. Parameters: n (int): Number of vertices. edges (list of tuples): Each tuple represents an edge (u, v, w), where u is the start vertex, v is the end vertex, and w is the weight of the edge. Returns: dict: Dictionary with vertices as keys and their minimum distances from the source vertex 0 as values. # Initialize adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distance dictionary dist = {i: float(\'inf\') for i in range(n)} dist[0] = 0 # Create a set to track vertices whose shortest path has been found found = set() # Implement the relaxation technique while len(found) < n: # Find the vertex with the smallest distance that is not yet processed min_dist = float(\'inf\') min_vertex = None for vertex in range(n): if vertex not in found and dist[vertex] < min_dist: min_dist = dist[vertex] min_vertex = vertex if min_vertex is None: break # Mark this vertex as processed found.add(min_vertex) # Update the distances for the adjacent vertices for neighbor, weight in graph[min_vertex]: if neighbor not in found: if dist[min_vertex] + weight < dist[neighbor]: dist[neighbor] = dist[min_vertex] + weight return dist"},{"question":"# Context You are a software engineer tasked with ensuring the efficient identification of strongly connected components in a directed graph. For this task, you need to leverage Tarjan\'s algorithm which is well known for its efficient approach in solving this problem. # Problem Statement Implement a **StronglyConnectedComponentsFinder** class that finds all strongly connected components (SCCs) in a directed graph using Tarjan\'s algorithm. Your class should encapsulate the core logic and optimizations to identify SCCs effectively. # Function Requirements 1. **Initializer**: `__init__(self, num_vertices: int) -> None` - Initialize the graph with a specified number of vertices. 2. **Add Edge**: `add_edge(self, u: int, v: int) -> None` - Add a directed edge from vertex `u` to vertex `v`. - Time Complexity: (O(1)) 3. **Find SCCs**: `find_sccs(self) -> list[list[int]]` - Find all strongly connected components in the graph. - Time Complexity: (O(V + E)) where (V) is the number of vertices and (E) is the number of edges. # Input Format - Inputs differ for each function and are described above where applicable. # Output Format - The output of `find_sccs` should be a list of lists, where each inner list contains the vertices of one strongly connected component. # Constraints - The graph will have at least one vertex and at most (10^4) vertices. - There can be at most (10^5) edges in the graph. # Example ```python # Initializing the graph with 5 vertices scc_finder = StronglyConnectedComponentsFinder(5) # Adding edges to the graph scc_finder.add_edge(0, 2) scc_finder.add_edge(2, 1) scc_finder.add_edge(1, 0) scc_finder.add_edge(0, 3) scc_finder.add_edge(3, 4) # Finding SCCs print(scc_finder.find_sccs()) # Outputs [[4], [3], [0, 1, 2]] or another permutation of these lists ``` In this example, the graph has three strongly connected components: one containing the vertices {4}, one containing the vertex {3}, and one containing the vertices {0, 1, 2}. Note that the order of SCCs or vertices within an SCC in the output may vary. Each component will be represented as a list of vertices.","solution":"class StronglyConnectedComponentsFinder: def __init__(self, num_vertices: int) -> None: self.num_vertices = num_vertices self.graph = [[] for _ in range(num_vertices)] self.index = 0 self.stack = [] self.indexes = [-1] * num_vertices self.lowlink = [0] * num_vertices self.on_stack = [False] * num_vertices self.sccs = [] def add_edge(self, u: int, v: int) -> None: self.graph[u].append(v) def find_sccs(self) -> list[list[int]]: for v in range(self.num_vertices): if self.indexes[v] == -1: self._strongly_connect(v) return self.sccs def _strongly_connect(self, v: int) -> None: self.indexes[v] = self.index self.lowlink[v] = self.index self.index += 1 self.stack.append(v) self.on_stack[v] = True for w in self.graph[v]: if self.indexes[w] == -1: self._strongly_connect(w) self.lowlink[v] = min(self.lowlink[v], self.lowlink[w]) elif self.on_stack[w]: self.lowlink[v] = min(self.lowlink[v], self.indexes[w]) if self.lowlink[v] == self.indexes[v]: scc = [] while True: w = self.stack.pop() self.on_stack[w] = False scc.append(w) if w == v: break self.sccs.append(scc)"},{"question":"# Coding Assessment Question Context In a digital circuit, an XOR gate is a logical gate that outputs true or 1 only when the two binary inputs to it are unequal. The XOR operation is also fundamental in many programming tasks, such as checksum calculations and certain operations in cryptography. Task Implement a function `xor_pattern` that generates a boolean matrix of size `n x n` based on an XOR gate evaluation. Each cell `(i, j)` in the matrix should contain the result of `XOR(i, j)`, where `i` and `j` range from `0` to `n-1`. Function Signature ```python def xor_pattern(n: int) -> List[List[int]]: ``` Input - `n` (integer): The size of the matrix. `1 <= n <= 20`. Output - A 2D list (matrix) of size `n x n`, where each element is either `0` or `1`. Example - Input: `n = 3` - Output: `[[0, 1, 1], [1, 0, 1], [1, 1, 0]]` - Explanation: The truth table for an XOR gate with inputs ranging from 0 to 2 is: ``` 0 1 1 1 0 1 1 1 0 ``` Constraints - Ensure that the matrix generated follows the XOR gate truth table rules for each combination of `i` and `j`. Requirements * **Edge Cases**: Handle cases where `n = 1` properly. * **Performance**: The function should run efficiently within the given constraints. Write a well-tested function to generate the XOR pattern. Make sure your implementation is robust and handles all edge cases.","solution":"from typing import List def xor_pattern(n: int) -> List[List[int]]: Generates a boolean matrix of size n x n based on XOR gate evaluation. Parameters: n (int): The size of the matrix. Returns: List[List[int]]: A matrix of size n x n with each element being the result of XOR(i, j). matrix = [] for i in range(n): row = [] for j in range(n): row.append(i ^ j) matrix.append(row) return matrix"},{"question":"# **Coding Assessment Question** Context: In a database management system, one of the crucial tasks is updating large sets of data. It is essential for the system to ensure that the updates are consistent and efficient, especially when dealing with linked records or dependencies. One common task is propagating updates through a linked list structure, where each node might depend on updates from adjacent nodes. Task: Implement an algorithm that updates a linked list such that each node’s value is updated by summing it with the value of the previous node. Write a function that takes the head of a singly linked list and updates each node accordingly. Function Signature: - `def update_linked_list(head: ListNode) -> None:` # Input: - `head`: The head node of a singly linked list where each node contains an integer value. # Output: - The function does not return a value but updates the list in place. # Constraints: - Each linked list will have at most `10^5` nodes. - Node values will be integers within the range of `[-10^3, 10^3]`. # Examples: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next # Example 1 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) update_linked_list(head) # The linked list should be updated to: 1 -> 3 -> 6 -> 10 # Example 2 head = ListNode(-1, ListNode(4, ListNode(5, ListNode(2)))) update_linked_list(head) # The linked list should be updated to: -1 -> 3 -> 8 -> 10 ``` **Note**: Ensure the function operates efficiently and handles edge cases properly, such as an empty linked list or lists with single or multiple nodes. Additional Requirements: - Write unit tests to validate the correctness of your implementation. - Make sure the function handles edge cases effectively (e.g., empty linked lists).","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def update_linked_list(head: ListNode) -> None: if not head: return current = head while current.next: current.next.value += current.value current = current.next"},{"question":"# Coding Assessment Question Scenario Develop a function that determines if a given positive integer is a well-formed palindrome in its binary representation. A \\"binary palindrome\\" is a number that reads the same forwards and backwards in binary form, similar to how \\"121\\" is a palindrome in decimal. Task Write a Python function named `is_binary_palindrome` that takes a positive integer and returns `True` if the binary representation of the number is a palindrome, otherwise returns `False`. Function Signature ```python def is_binary_palindrome(number: int) -> bool: pass ``` Input - `number`: A positive integer to evaluate. Output - A boolean value: `True` if the binary representation is a palindrome, `False` otherwise. Constraints - The input integer will be in the range of 1 to (10^{18}). Performance Requirements - The solution should handle the conversion and check efficiently. Examples ```python print(is_binary_palindrome(5)) # Should return True (binary: 101) print(is_binary_palindrome(9)) # Should return False (binary: 1001) print(is_binary_palindrome(7)) # Should return True (binary: 111) print(is_binary_palindrome(8)) # Should return False (binary: 1000) print(is_binary_palindrome(1)) # Should return True (binary: 1) ``` Constraints and Error Handling - If the input is not a positive integer, raise a `TypeError` stating \\"Input value must be a positive integer\\".","solution":"def is_binary_palindrome(number: int) -> bool: Checks if the binary representation of a number is a palindrome. Parameters: - number (int): A positive integer to check. Returns: - bool: True if the binary representation is a palindrome, False otherwise. if not isinstance(number, int) or number < 1: raise TypeError(\\"Input value must be a positive integer\\") binary_representation = bin(number)[2:] # Get binary string without \'0b\' prefix return binary_representation == binary_representation[::-1]"},{"question":"# Question: Implement a Rate Limiter Using Tokens You are required to implement a class, `RateLimiter`, which enforces rate limiting using the Token Bucket algorithm. This implementation should manage the flow of events such that they do not exceed a specified rate. Class Definition ```python class RateLimiter: def __init__(self, max_tokens: int, refill_rate: float): pass def allow_request(self) -> bool: pass ``` Parameters for Initialization * `max_tokens` (int): The maximum number of tokens in the bucket. * `refill_rate` (float): The rate (tokens per second) at which the bucket is refilled. Method * `allow_request() -> bool`: Should return `True` if a request is allowed (i.e., there are tokens available), and `False` otherwise. This method should also decrement the token count if a request is allowed. Constraints * The rate limiter should accurately track the time passed to refill the tokens. * Ensure that the system is thread-safe, meaning multiple threads can call `allow_request` concurrently without causing race conditions. Example Scenario ```python # Initialize a rate limiter that allows 10 requests per second. limiter = RateLimiter(10, 1.0) # Simulate 5 rapid requests, all of which should be allowed. results = [limiter.allow_request() for _ in range(5)] # Expected output: [True, True, True, True, True] # This scenario showcases that the first 5 requests are successfully allowed. print(results) ``` In the above example, `limiter.allow_request()` is called five times rapidly. All calls should return `True` since the rate limiter allows up to 10 requests per second, and only 5 requests were made. **Note**: You do not need to handle advanced time management beyond ensuring threads can safely interact with the limiter. The primary goal is ensuring the correct implementation of the token bucket algorithm and safe concurrent requests.","solution":"import time import threading class RateLimiter: def __init__(self, max_tokens: int, refill_rate: float): self.max_tokens = max_tokens self.refill_rate = refill_rate self.available_tokens = max_tokens self.last_checked = time.time() self.lock = threading.Lock() def _refill_tokens(self): current_time = time.time() time_diff = current_time - self.last_checked self.last_checked = current_time tokens_to_add = time_diff * self.refill_rate self.available_tokens = min(self.max_tokens, self.available_tokens + tokens_to_add) def allow_request(self) -> bool: with self.lock: self._refill_tokens() if self.available_tokens >= 1: self.available_tokens -= 1 return True else: return False"},{"question":"# Question You are given an implementation of a basic stack data structure. Extend this implementation to include a method that returns the maximum value in the stack at any point. Implement the following function: ```python class Stack: ... def get_max(self) -> int: Return the maximum value currently in the stack. :return: maximum value in the stack ``` Constraints: * The stack should be able to handle operations efficiently (push, pop, and get_max). * Assume all values pushed onto the stack are integers. * Your solution must achieve O(1) time complexity for the `get_max` method. Input: * No direct input is provided; instead, the method should be called after several stack operations. Output: * Maximum value in the stack as an integer. Example: Given the following stack operations: ```python s = Stack() s.push(3) s.push(5) print(s.get_max()) # Output: 5 s.push(2) s.push(1) print(s.get_max()) # Output: 5 s.pop() print(s.get_max()) # Output: 5 s.pop() print(s.get_max()) # Output: 3 ``` Notes: * Ensure that the stack remains functional for all standard stack operations (push, pop, is_empty, etc.). * You may modify the stack class construction or methods to support the `get_max` functionality efficiently.","solution":"class Stack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value: int): self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self): if self.stack: value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def is_empty(self): return len(self.stack) == 0 def get_max(self) -> int: if self.max_stack: return self.max_stack[-1] raise IndexError(\\"get_max from an empty stack\\")"},{"question":"# Merge Intervals: Scheduler Conflict Check Context: You are developing a scheduling application that allows users to book time slots for various activities throughout the day. To ensure there are no conflicts in the schedule, you need to implement a function that checks for overlapping intervals in the list of booked time slots. Problem: Write a function named `is_schedule_conflict` that takes in a list of tuples, where each tuple represents a booked time slot with a start and end time. The function should return `True` if there is any overlap between the time slots, otherwise return `False`. Specifications: 1. **Function Signature:** ```python def is_schedule_conflict(time_slots: List[Tuple[int, int]]) -> bool: Checks if there is any overlap between the given time slots. :param time_slots: List of tuples, each containing the start and end time of a booked slot (inclusive). :return: True if there is any conflict, otherwise False. ``` 2. **Input:** - `time_slots`: A list of tuples where each tuple `(start, end)` represents a booked time slot. Both `start` and `end` are integers. 3. **Output:** - `True` if there is at least one overlapping time slot, otherwise `False`. 4. **Constraints:** - All `start` and `end` values are non-negative integers. - Each time slot tuple `(start, end)` satisfies `0 <= start <= end`. Example Usage: ```python time_slots1 = [(1, 3), (4, 5), (6, 9), (2, 4)] is_schedule_conflict(time_slots1) # Should return True because (1, 3) and (2, 4) overlap time_slots2 = [(1, 2), (3, 5), (6, 7)] is_schedule_conflict(time_slots2) # Should return False as there are no overlapping slots ``` **Important:** - The function should correctly identify and handle overlapping intervals. - Efficiently handle the list of time slots, aiming for a time complexity better than O(n^2). # Example Explanation: - For `time_slots1`, there is a conflict because the interval `(1, 3)` overlaps with `(2, 4)`, hence the function returns `True`. - For `time_slots2`, there are no overlapping intervals, so the function returns `False`.","solution":"from typing import List, Tuple def is_schedule_conflict(time_slots: List[Tuple[int, int]]) -> bool: Checks if there is any overlap between the given time slots. :param time_slots: List of tuples, each containing the start and end time of a booked slot. :return: True if there is any conflict, otherwise False. # First, sort the time slots based on their start times sorted_time_slots = sorted(time_slots, key=lambda x: x[0]) # Traverse the sorted list and check for overlapping intervals for i in range(1, len(sorted_time_slots)): previous_end = sorted_time_slots[i - 1][1] current_start = sorted_time_slots[i][0] if current_start < previous_end: return True # There is a conflict return False # No conflicts found"},{"question":"# Binary Gap Finder Background The binary representation of a number can yield interesting insights. One such insight is the discovery of the longest sequence of consecutive zeros that is flanked by ones at both ends. This sequence is known as the binary gap. Task You are to write a function that determines the length of the longest binary gap for a given positive integer. The function should consider only the gaps between the most significant \'1\' and the least significant \'1\' in the binary representation of the number. Requirements - Write a function `find_binary_gap(n: int) -> int` that takes an integer `n` and returns the length (as an integer) of the longest binary gap within the binary representation of `n`. - The function should raise a `ValueError` if `n` is not a positive integer. - The function should raise a `TypeError` if `n` is not an integer. Function Signature ```python def find_binary_gap(n: int) -> int: pass ``` Input - An integer `n` (1 ≤ n ≤ 10^7) Output - Returns an integer which is the length of the longest binary gap. Constraints - The function should handle performance constraints efficiently, especially for large values of `n` up to 10,000,000. Example ```python print(find_binary_gap(9)) # Output: 2, because 9 in binary is 1001. print(find_binary_gap(20)) # Output: 1, because 20 in binary is 10100. print(find_binary_gap(529)) # Output: 4, because 529 in binary is 1000010001. print(find_binary_gap(15)) # Output: 0, because 15 in binary is 1111. ``` Notes - Pay attention to edge cases, such as numbers with no binary gaps. - Ensure that your implementation efficiently handles the transformation and analysis of binary representations. This question is designed to test your understanding of binary representations and your ability to implement efficient algorithms to solve real-world problems.","solution":"def find_binary_gap(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") binary_representation = bin(n)[2:] max_gap = 0 current_gap = 0 counting = False for bit in binary_representation: if bit == \'1\': if counting: max_gap = max(max_gap, current_gap) current_gap = 0 counting = True elif counting: current_gap += 1 return max_gap"},{"question":"# Coding Assessment Question **Objective**: Assess students\' ability to understand, implement, and optimize algorithms for unique problem-solving scenarios. **Background**: Sorting algorithms are fundamental techniques in computer science, used in various applications such as data analysis, searching, and organizing information. While Python provides built-in sorting functions, understanding and implementing custom sorting algorithms enhances problem-solving skills. Your task is to implement and optimize a custom sorting algorithm to order an array of integers and additionally return the number of swaps made during the sorting process. **Task**: 1. **Function Implementation**: Implement a function called `custom_sort_and_count` that: - Accepts a list of integers `arr`. - Returns a tuple containing two elements: - The sorted version of the input list. - The number of swaps made during the sorting process. 2. **Algorithm Choice**: - Implement a sorting algorithm of your choice (e.g., Bubble Sort, Insertion Sort, or Selection Sort). - Ensure your implementation tracks and counts the number of swaps made during the sort. 3. **Edge Cases**: Handle possible edge cases such as: - An empty list, which should return ([], 0). - Lists with identical elements which should return the list as-is with 0 swaps. **Input/Output**: - Input: `custom_sort_and_count(arr: List[int]) -> Tuple[List[int], int]` - `arr`: A list of integers to be sorted. - Output: Returns a tuple: - First element: A sorted list of integers. - Second element: An integer representing the number of swaps made during sorting. **Constraints**: - 0 ≤ len(arr) ≤ 10^5 - -10^5 ≤ arr[i] ≤ 10^5 **Performance Requirements**: - Your solution should efficiently handle lists up to the upper limit of length 10^5. # Example ```python from typing import List, Tuple def custom_sort_and_count(arr: List[int]) -> Tuple[List[int], int]: pass # Example Usage assert custom_sort_and_count([3, 1, 2, 4, 6]) == ([1, 2, 3, 4, 6], 2) assert custom_sort_and_count([5, 4, 3, 2, 1]) == ([1, 2, 3, 4, 5], 10) assert custom_sort_and_count([1, 2, 3, 4, 5]) == ([1, 2, 3, 4, 5], 0) assert custom_sort_and_count([]) == ([], 0) ``` Provide a well-commented and efficient solution to this problem.","solution":"from typing import List, Tuple def custom_sort_and_count(arr: List[int]) -> Tuple[List[int], int]: Sorts the array using Bubble Sort and counts the number of swaps made. Parameters: arr (List[int]): The list to be sorted. Returns: Tuple[List[int], int]: A tuple containing the sorted list and the number of swaps made. n = len(arr) num_swaps = 0 sorted_arr = arr[:] for i in range(n): for j in range(0, n-i-1): if sorted_arr[j] > sorted_arr[j+1]: # Swap elements sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j] num_swaps += 1 return sorted_arr, num_swaps"},{"question":"# Coding Question Problem Statement You are given an array of integers where each integer represents the height of a person in a queue. Your task is to reorder the queue so that all the shorter people come before all the taller people. If two people have the same height, they should remain in their original relative order. Implement the function: ```python def reorder_queue(heights: list) -> list: ... ``` # Input * A list of integers `heights` with 0 ≤ len(heights) ≤ 10^5, representing the heights of people in a queue. # Output * A list of integers representing the reordered queue where the people are sorted by height in ascending order, while preserving the relative order of people with the same height. # Constraints * The input list may contain duplicate integers. * The reordering should be stable, meaning that the relative order of people with the same height should be preserved. # Example ```python >>> reorder_queue([5, 3, 7, 3, 2, 5, 1]) [1, 2, 3, 3, 5, 5, 7] >>> reorder_queue([4, 4, 4, 4]) [4, 4, 4, 4] >>> reorder_queue([6, 1, 2, 5, 3]) [1, 2, 3, 5, 6] >>> reorder_queue([]) [] >>> reorder_queue([1]) [1] ``` # Additional Context The goal is to achieve a stable sort, which means you should not disrupt the original order of people with the same height. A commonly used algorithm that ensures stable sorting is the Timsort algorithm implemented in Python\'s `sorted()` function.","solution":"def reorder_queue(heights): Reorders the given queue so that all shorter people come before taller people while preserving the relative order of people with the same height. :param heights: list of integers representing heights of people :return: list of integers representing the reordered queue return sorted(heights)"},{"question":"# Array Manipulation Challenge In this challenge, you will perform operations on an array to manipulate specific indices and achieve the desired changes. Scenario You are tasked with implementing a function for an investment simulation tool. The function should process a series of operations to modify account balances stored in an array. Each operation will target a subsegment of the array and increment each element in that segment by a given value. Function Signature ```python def array_manipulation(n: int, operations: List[Tuple[int, int, int]]) -> List[int]: This function modifies the values in an initial array of zeros using the given set of operations. Args: n (int): The length of the array. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented as a tuple (start, end, increment). Returns: List[int]: The array after processing all operations. ``` Input - `n`: An integer representing the size of the array. - `operations`: A list of tuples, each containing three integers (`start`, `end`, `increment`). Output - The modified array after applying all the operations. Constraints - `1 <= n <= 10^7` - `1 <= len(operations) <= 2 * 10^5` - `1 <= start <= end <= n` - `1 <= increment <= 10^9` Examples ```python >>> array_manipulation(5, [(1, 2, 100), (2, 5, 100), (3, 4, 100)]) [100, 200, 200, 100, 100] >>> array_manipulation(10, [(1, 5, 10), (6, 10, 5), (3, 7, 15)]) [10, 10, 25, 25, 25, 20, 20, 5, 5, 5] ``` Requirements - Solutions must operate efficiently, particularly for large values of `n`. - The use of prefix sums or difference arrays is encouraged to achieve efficient updates. - Aim for an overall time complexity of O(n + m) where m is the number of operations. Tips - Use a difference array to record the effect of each operation, then compute the final array using a prefix sum to apply these effects. Implement the function `array_manipulation` and test it with the provided examples.","solution":"from typing import List, Tuple def array_manipulation(n: int, operations: List[Tuple[int, int, int]]) -> List[int]: This function modifies the values in an initial array of zeros using the given set of operations. Args: n (int): The length of the array. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented as a tuple (start, end, increment). Returns: List[int]: The array after processing all operations. # Initialize the array with zeros and one extra element for easier calculations result = [0] * (n + 1) # Apply each operation via a difference array approach for start, end, increment in operations: result[start - 1] += increment if end < n: result[end] -= increment # Convert the difference array to the final result array using prefix sums technique for i in range(1, n): result[i] += result[i - 1] return result[:n]"},{"question":"# Assignment: Implement a Balanced Binary Search Tree (BBST) Insertion and Deletion Your task is to implement a Balanced Binary Search Tree (specifically an AVL Tree) with insertion and deletion functionalities. The tree should automatically balance itself after each insertion and deletion to maintain optimal performance. # Task: 1. Implement the class `AVLTree` with key functionalities to insert and delete nodes while maintaining the tree balance. 2. Write the `insert` method to add a node with a given value, ensuring the tree remains balanced. * Input: * `value` - An integer value to be added to the tree. * Output: * None (the tree should be modified in-place). 3. Write the `delete` method to remove a node with a specified value, ensuring the tree remains balanced. * Input: * `value` - An integer value to be removed from the tree. * Output: * None (the tree should be modified in-place). # Constraints: * The tree should maintain the properties of an AVL Tree, i.e. for any node in the tree, the heights of its left and right subtrees can differ by at most one. * Handle edge cases such as deleting a node from an empty tree or inserting a duplicate value. * Ensure the tree rebalances appropriately after insertion and deletion operations. # Example: ```python class AVLTree: def __init__(self): self.root = None def insert(self, value): pass # Implement insertion logic here def delete(self, value): pass # Implement deletion logic here def in_order_traversal(root): if not root: return [] return in_order_traversal(root.left) + [root.value] + in_order_traversal(root.right) # Use case example avl_tree = AVLTree() # Inserting values avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) avl_tree.insert(40) avl_tree.insert(50) # Deleting a value avl_tree.delete(30) # Validate the tree structure with an in-order traversal assert in_order_traversal(avl_tree.root) == [10, 20, 40, 50] ``` # Notes: * Ensure that the AVL Tree implementation respects the balancing constraints after each operation. * Consider edge cases such as inserting or deleting from an initially empty tree, duplicate insertions, and deleting non-existent nodes. * Your implementation should efficiently handle large datasets and maintain O(log n) complexity for both insertion and deletion operations.","solution":"class AVLTreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def delete(self, value): self.root = self._delete(self.root, value) def _insert(self, node, value): if not node: return AVLTreeNode(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and value < node.left.value: return self._right_rotate(node) if balance < -1 and value > node.right.value: return self._left_rotate(node) if balance > 1 and value > node.left.value: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and value < node.right.value: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _delete(self, node, value): if not node: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Longest Common Subsequence Challenge You are given two strings `A` and `B`, and your task is to find the length of their longest common subsequence (LCS). The LCS of two strings is the longest sequence that can be derived from both strings by deleting some (or no) characters without changing the order of the remaining characters. # Function Signature: ```python def longest_common_subsequence(A: str, B: str) -> int: ``` # Input: - Two strings `A` and `B` each of length `n` and `m` respectively. - The strings consist of lowercase English letters only. # Output: - An integer representing the length of the longest common subsequence between `A` and `B`. # Example: Input: ```python A = \\"abcde\\" B = \\"ace\\" ``` Output: ```python 3 ``` Explanation: - The longest common subsequence between \\"abcde\\" and \\"ace\\" is \\"ace\\" which has a length of 3. # Constraints: - 1 <= n, m <= 1000 **Note**: - You should implement an efficient solution with time complexity less than O(n * m * log(n * m)). - Consider using dynamic programming to build the solution matrix. # Hint: - Construct a 2D array `dp` where `dp[i][j]` represents the length of LCS of the first `i` characters of `A` and the first `j` characters of `B`. - Initialize `dp` such that `dp[i][0] = 0` for all `i` (0≤i≤n) and `dp[0][j] = 0` for all `j` (0≤j≤m). - Iterate through the characters of both strings, updating the `dp` array according to whether characters match or not. --- This question aligns with the previously given question in terms of complexity, style, and format. It explores the dynamic programming technique which is a common and complementary area within the realm of algorithmic challenges.","solution":"def longest_common_subsequence(A: str, B: str) -> int: n, m = len(A), len(B) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"# Coding Assessment Question Objective Implement a function to determine the Nth Fibonacci number where the input value can be quite large. Ensure the implementation is optimized to handle such cases efficiently. Background The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 The sequence starts with 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on. The challenge is to compute the Nth Fibonacci number where N can be a very large integer. Task Implement the function `fibonacci(n: int) -> int` that computes the Nth Fibonacci number efficiently. Specifications * **Input**: A single integer `n` representing the position in the Fibonacci sequence. * **Output**: The function should return an integer representing the Nth Fibonacci number. Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 ``` Constraints 1. The input value `n` will be a non-negative integer (0 <= n <= 10^6). 2. The output may be very large; use efficient algorithms and data types to handle large results. Additional Notes * Ensure that your implementation is optimized to handle large values of `n` within a reasonable time. * Consider using matrix exponentiation or other advanced techniques to achieve the desired efficiency.","solution":"def fibonacci(n): Returns the Nth Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0]"},{"question":"# Question: Given a binary search tree (BST), implement a function to find the kth smallest element. If the tree has fewer than k elements, return a message indicating so. Use an iterative in-order traversal approach to solve this problem. # Objective: Enhance the `kth_smallest` function to find the kth smallest element in a binary search tree using iterative in-order traversal. Ensure the function handles edge cases such as trees with fewer elements than `k`. # Requirements: 1. **Input**: The root of a binary search tree and an integer `k`. * `root`: The root node of the BST. * `k`: An integer representing the position of the smallest element to find. 2. **Output**: The value of the kth smallest element as an integer, or a message indicating that the tree contains fewer than `k` elements. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Find the kth smallest element in a BST using iterative in-order traversal. Args: - root: Root node of the BST. - k: Integer representing the position of the smallest element to find. Returns: - The kth smallest element. Raises: - ValueError: If the tree has fewer than k elements. Example: >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 5) ValueError: The tree contains fewer than 5 elements. pass # Your code here ``` # Instructions: 1. Implement the `kth_smallest` function to find the kth smallest element using an iterative in-order traversal. 2. Handle edge cases, such as BSTs with fewer than `k` elements, by raising a `ValueError` with a clear message. 3. Ensure the function accurately identifies the kth smallest element for typical cases. # Constraints: - The BST will contain values ranging between `-10^5` and `10^5`. - The number of nodes in the tree will not exceed `10^4`. - `k` will be a positive integer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Find the kth smallest element in a BST using iterative in-order traversal. Args: - root: Root node of the BST. - k: Integer representing the position of the smallest element to find. Returns: - The kth smallest element. Raises: - ValueError: If the tree has fewer than k elements. stack = [] current = root count = 0 while stack or current: while current: stack.append(current) current = current.left current = stack.pop() count += 1 if count == k: return current.val current = current.right raise ValueError(f\\"The tree contains fewer than {k} elements.\\")"},{"question":"# Task: Implement and Validate a Recursive Factorial Function Problem Statement Your task is to implement a recursive function to calculate the factorial of a positive integer and ensure that it handles specific edge cases with appropriate validations. Factorial of a positive integer \'n\' is the product of all positive integers less than or equal to \'n\'. For example, factorial of 4 (denoted as 4!) is 4 * 3 * 2 * 1 = 24. Function Signature ```python def factorial(n: int) -> int: pass ``` Input - `n` (int): A positive integer for which the factorial is to be calculated. Output - **(int)**: The factorial of the input integer `n`. Constraints 1. `n` must be a non-negative integer. 2. If `n` is zero, the factorial is defined as 1. 3. If the input is not a positive integer, raise a `ValueError` with an appropriate message. Example ```python >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(-3) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> factorial(3.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> factorial(\'abc\') Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> factorial(10) 3628800 ``` Requirements - Implement the factorial function using a recursive approach. - Incorporate input validation to ensure that the input is a non-negative integer. - Raise appropriate errors if the input does not meet the criteria. - Optimize the function for clarity and efficiency.","solution":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n using recursion. Raises ValueError if the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 1 return n * factorial(n - 1)"},{"question":"# Context You are required to implement a basic `Queue` data structure with the following operations using two stacks. # Task Implement a `Queue` class using two stacks (`stack1` and `stack2`) that should pass the provided tests. The queue should implement First-In-First-Out (FIFO) order using stack operations. # Requirements 1. **Constructor**: `Queue()` initializes the queue. 2. **Methods**: * `enqueue(self, item)`: Adds an item to the end of the queue. * `dequeue(self)`: Removes the item from the front of the queue and returns it. If the queue is empty, raise an exception. * `peek(self)`: Returns the item at the front of the queue without removing it. If the queue is empty, raise an exception. * `is_empty(self)`: Returns `True` if the queue is empty, `False` otherwise. * `size(self)`: Returns the number of items in the queue. # Example ```python # Example usage of the Queue q = Queue() q.enqueue(10) q.enqueue(20) q.enqueue(30) assert q.peek() == 10 assert q.dequeue() == 10 assert q.dequeue() == 20 assert q.size() == 1 assert q.is_empty() == False q.dequeue() assert q.is_empty() == True # Trying to dequeue from an empty queue should raise an exception try: q.dequeue() except Exception: pass # Expected exception since queue is empty ``` You should ensure your implementation passes all the tests outlined in the provided test suite.","solution":"class Queue: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, item): self.stack1.append(item) def dequeue(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self): return not self.stack1 and not self.stack2 def size(self): return len(self.stack1) + len(self.stack2)"},{"question":"# Coding Assessment: Binary Tree Serialization and Deserialization Problem Statement You are tasked with implementing a pair of functions to serialize and deserialize a binary tree. Serialization is the process of converting a tree into a sequence of values that can be easily stored and transported. Deserialization is the reverse process, creating the tree back from the sequence of values. Your implementation should be able to handle binary trees of various structures, including completely unbalanced trees. The serialized format should be compact and use pre-order traversal where possible. Task Implement the following two functions in Python: 1. **serialize(root)**: Serializes a binary tree to a single string. 2. **deserialize(data)**: Deserializes the encoded data to reconstruct the binary tree. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Converts a binary tree to a single string. Parameters: root (TreeNode): The root of the binary tree. Returns: str: The serialized string representation of the binary tree. pass def deserialize(data): Converts a serialized string back to a binary tree. Parameters: data (str): The serialized string representation of the binary tree. Returns: TreeNode: The root of the binary tree. pass # Helper functions for testing def build_tree(values): from collections import deque if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while queue and i < len(values): node = queue.popleft() if values[i] is not None: node.left = TreeNode(values[i]) queue.append(node.left) i += 1 if i < len(values) and values[i] is not None: node.right = TreeNode(values[i]) queue.append(node.right) i += 1 return root def print_tree(root): from collections import deque if not root: return \\"[]\\" queue = deque([root]) result = [] while queue: node = queue.popleft() if node is None: result.append(\\"null\\") else: result.append(str(node.val)) queue.append(node.left) queue.append(node.right) return \\"[\\" + \\",\\".join(result).rstrip(\\",null\\") + \\"]\\" # Driver code for testing if __name__ == \\"__main__\\": import doctest doctest.testmod() # Construct a sample tree: [1,2,3,null,null,4,5] tree = build_tree([1, 2, 3, None, None, 4, 5]) serialized = serialize(tree) print(f\\"Serialized: {serialized}\\") deserialized_tree = deserialize(serialized) print(f\\"Deserialized Tree: {print_tree(deserialized_tree)}\\") ``` Constraints - The binary tree nodes\' values are an integer range [-1000, 1000]. - You may assume that the trees have no more than 10^4 nodes. - Ensure that your implementation is efficient in terms of both time and space. - Write comprehensive docstrings and comments to explain the purpose and logic of each function. - Handle edge cases such as empty trees or trees with only one node. Evaluation Your solution will be evaluated based on: 1. **Correctness**: Accurately serializing and deserializing the binary tree. 2. **Efficiency**: Meeting expected performance complexities. 3. **Robustness**: Handling various tree structures and edge cases gracefully. 4. **Readability**: Well-commented, clear, and easily understandable code. 5. **Testing**: Comprehensiveness of test cases written.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Converts a binary tree to a single string using pre-order traversal. Parameters: root (TreeNode): The root of the binary tree. Returns: str: The serialized string representation of the binary tree. def preorder(node): if not node: return \\"null\\" return str(node.val) + \\",\\" + preorder(node.left) + \\",\\" + preorder(node.right) return preorder(root) def deserialize(data): Converts a serialized string back to a binary tree using pre-order traversal. Parameters: data (str): The serialized string representation of the binary tree. Returns: TreeNode: The root of the binary tree. def build_tree(values): if values[0] == \\"null\\": values.pop(0) return None node = TreeNode(int(values.pop(0))) node.left = build_tree(values) node.right = build_tree(values) return node values = data.split(\\",\\") root = build_tree(values) return root"},{"question":"# Context: The efficiency of an electrical transmission system can be affected by the resistance of the transmission lines. To limit energy losses, it is essential to estimate the resistance of the transmission lines based on their properties. Electrical engineers often use this estimation to design and optimize power systems. Given the resistivity of the material, the length, and the cross-sectional area of the transmission line, you will implement a function to calculate the resistance of the transmission line. # Objective: Implement a function that calculates the resistance of a transmission line given its resistivity, length, and cross-sectional area. Your function should account for invalid input by raising appropriate exceptions. # Problem Statement: Write a function `calculate_resistance` that calculates the electrical resistance of a transmission line using the following formula: [ R = frac{rho cdot L}{A} ] where: - ( R ) is the resistance in ohms (Ω), - ( rho ) is the resistivity of the material in ohm-meters (Ω·m), - ( L ) is the length of the transmission line in meters (m), - ( A ) is the cross-sectional area in square meters (m²). Function Signature: ```python def calculate_resistance(resistivity: float, length: float, area: float) -> float: pass ``` Input: - `resistivity`: A floating-point number representing the resistivity in ohm-meters (Ω·m). Must be positive. - `length`: A floating-point number representing the length of the transmission line in meters (m). Must be positive. - `area`: A floating-point number representing the cross-sectional area in square meters (m²). Must be positive. Output: - Returns the resistance of the transmission line as a floating-point number. Constraints: - If the resistivity is less than or equal to 0 Ω·m, raise an `Exception` with message `\\"Resistivity must be greater than 0 Ω·m\\"`. - If the length is less than or equal to 0 m, raise an `Exception` with message `\\"Length must be greater than 0 m\\"`. - If the area is less than or equal to 0 m², raise an `Exception` with message `\\"Area must be greater than 0 m²\\"`. # Examples: ```python >>> calculate_resistance(1.68e-8, 1000, 1e-5) 1.68 >>> calculate_resistance(2.82e-8, 2000, 2e-5) 2.82 >>> calculate_resistance(-1.68e-8, 1000, 1e-5) Exception: Resistivity must be greater than 0 Ω·m >>> calculate_resistance(1.68e-8, 0, 1e-5) Exception: Length must be greater than 0 m >>> calculate_resistance(1.68e-8, 1000, -1e-5) Exception: Area must be greater than 0 m² ```","solution":"def calculate_resistance(resistivity: float, length: float, area: float) -> float: Calculate the resistance of a transmission line using the formula R = (resistivity * length) / area. Raises an exception if any of the input parameters are not positive. :param resistivity: The resistivity of the material in ohm-meters (Ω·m). :param length: The length of the transmission line in meters (m). :param area: The cross-sectional area in square meters (m²). :return: The resistance of the transmission line in ohms (Ω). if resistivity <= 0: raise Exception(\\"Resistivity must be greater than 0 Ω·m\\") if length <= 0: raise Exception(\\"Length must be greater than 0 m\\") if area <= 0: raise Exception(\\"Area must be greater than 0 m²\\") resistance = (resistivity * length) / area return resistance"},{"question":"Task Implement a Fibonacci Sequence generator and demonstrate how it is applied. Please follow the requirements below: # Scenario You are tasked with creating a Python function that generates the Fibonacci sequence up to the Nth term. # Function Signature ```python def generate_fibonacci(n: int) -> list: Generates the Fibonacci sequence up to the Nth term. Parameters: - n: An integer representing the number of terms in the sequence to generate. Returns: - A list of integers which are the first N terms of the Fibonacci sequence. ``` # Constraints 1. `n` will always be a non-negative integer. 2. If `n` is 0, return an empty list. 3. The Fibonacci sequence is defined as: - F(0) = 0, F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 # Examples ```python # Example 1 result = generate_fibonacci(5) print(result) # Expected output: # [0, 1, 1, 2, 3] # Example 2 result = generate_fibonacci(10) print(result) # Expected output: # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Performance Requirements - The function should be efficient and work within a reasonable time frame for large values of `n`. - Ensure readability and clarity of the code, making it easy to maintain and understand. Note: You are encouraged to use an iterative approach rather than a recursive one to avoid potential stack overflow issues with large `n`. --- Create your function in a Python environment and test it with various values to ensure it meets the above conditions.","solution":"def generate_fibonacci(n: int) -> list: Generates the Fibonacci sequence up to the Nth term. Parameters: - n: An integer representing the number of terms in the sequence to generate. Returns: - A list of integers which are the first N terms of the Fibonacci sequence. if n == 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Problem Statement You are tasked with writing a function that simulates the behavior of a simple text editor. The text editor operates on a single string of characters with the following commands: 1. \\"APPEND x\\" - Append the string `x` to the end of the current text. 2. \\"DELETE k\\" - Delete the last `k` characters of the current text. 3. \\"PRINT k\\" - Print the `k`-th character of the current text (1-based indexing). 4. \\"UNDO\\" - Undo the most recent operation (either an \\"APPEND\\" or \\"DELETE\\"). You need to implement a function that processes a list of such commands and returns a list of results for each \\"PRINT\\" command. # Function Signature ```python def text_editor(commands: list) -> list: Simulates a simple text editor with append, delete, print, and undo operations. Args: commands (list of str): A list of commands to be executed in the text editor. Returns: list: A list of results for each \\"PRINT\\" command. ``` # Input Constraints - `commands` is a list of strings, where each string represents a command in the form specified above. - The length of `commands` is between 1 and 10^4. - The length of any appended string `x` is between 1 and 10^3. - `k` in \\"DELETE k\\" and \\"PRINT k\\" is a positive integer that does not exceed the length of the current text. - The \\"UNDO\\" command only undoes the most recent \\"APPEND\\" or \\"DELETE\\" command, and there will always be at least one such command to undo when \\"UNDO\\" is given. - Each command is valid and follows the specification. # Output Format - Return a list of characters resulting from each \\"PRINT\\" command. # Example ```python commands = [ \\"APPEND abc\\", \\"APPEND def\\", \\"PRINT 3\\", \\"DELETE 3\\", \\"PRINT 3\\", \\"UNDO\\", \\"PRINT 3\\" ] print(text_editor(commands)) # Output: [\'c\', \'c\', \'f\'] ``` # Evaluation Criteria - Correctness: The function should correctly simulate the described text editor operations and return accurate results for all \\"PRINT\\" commands. - Efficiency: The function should handle large sequences of commands within a reasonable time frame. - Edge Cases: The function should effectively handle edge cases such as multiple consecutive \\"APPEND\\" or \\"DELETE\\" commands, alternating between commands, and continuous \\"UNDO\\" commands.","solution":"def text_editor(commands: list) -> list: result = [] current_text = \\"\\" history = [] for command in commands: if command.startswith(\\"APPEND\\"): to_append = command.split()[1] history.append(current_text) current_text += to_append elif command.startswith(\\"DELETE\\"): k = int(command.split()[1]) history.append(current_text) current_text = current_text[:-k] elif command.startswith(\\"PRINT\\"): k = int(command.split()[1]) result.append(current_text[k-1]) elif command == \\"UNDO\\": current_text = history.pop() return result"},{"question":"# Sensor Data Aggregation Description: You are tasked with creating a function that processes sensor data readings and aggregates them based on their timestamps. Sensor readings are timestamped and can be produced at regular or irregular intervals. Your function should aggregate the readings by computing the average value for each hour period. Objectives: 1. Implement the function `aggregate_sensor_data` that accepts a list of tuples. Each tuple will contain a timestamp in the format `YYYY-MM-DD HH:MM:SS` and a sensor reading value as a float. 2. Group the data by hour; each hour represented in the input should have its sensor readings averaged. 3. Return a dictionary where the keys are timestamps representing the start of each hour (`YYYY-MM-DD HH:00:00`), and the values are the average sensor readings for that hour. Function Signature: ```python def aggregate_sensor_data(readings: list[tuple[str, float]]) -> dict: pass ``` Constraints: - The input list can be empty, in which case the function should return an empty dictionary. - Sensor readings can occur at any minute within the hour; they should be aggregated to the nearest hour. - If no readings are present for an hour, do not include that hour in the output. Example: ```python readings = [ (\\"2023-03-25 14:01:45\\", 22.4), (\\"2023-03-25 14:20:30\\", 24.1), (\\"2023-03-25 15:05:15\\", 23.9), (\\"2023-03-25 14:45:00\\", 21.8), (\\"2023-03-25 15:45:00\\", 22.5) ] result = aggregate_sensor_data(readings) # Expected result: # { # \\"2023-03-25 14:00:00\\": 22.76, # \\"2023-03-25 15:00:00\\": 23.2 # } ``` # Testing: - Implement unit tests to validate the correct grouping and averaging of sensor readings. - Test edge cases such as empty input, all readings in the same hour, and varying input lengths and timestamps.","solution":"from collections import defaultdict from datetime import datetime def aggregate_sensor_data(readings): Aggregates sensor data readings by the nearest hour and computes the average for each hour. hourly_data = defaultdict(list) for timestamp, value in readings: hour = timestamp[:13] + \':00:00\' hourly_data[hour].append(value) result = {} for hour, values in hourly_data.items(): result[hour] = sum(values) / len(values) return result"},{"question":"**Context**: A binary heap is a complete binary tree where each node is smaller than its children (Min-Heap) or larger than its children (Max-Heap). This data structure is commonly used to implement priority queues. **Task**: Write a function `kth_smallest_in_heap(heap, k)` that finds the k-th smallest element in a given binary min-heap. The function should: - Take a list `heap` representing a binary min-heap and an integer `k` as input, where `1 <= k <= len(heap)`. - Return the k-th smallest element in the heap. **Constraints**: - The heap list contains integer elements. - The function should handle up to `10^5` elements efficiently. **Examples**: ```python >>> kth_smallest_in_heap([1, 3, 6, 5, 9, 8], 3) 6 >>> kth_smallest_in_heap([2, 4, 7, 10, 10, 9], 2) 4 >>> kth_smallest_in_heap([5, 7, 9, 14, 10, 12], 4) 10 >>> kth_smallest_in_heap([1, 2, 3, 4, 5], 5) 5 ``` *Hint*: Consider using a priority queue (min-heap) to efficiently find the k-th smallest element.","solution":"import heapq def kth_smallest_in_heap(heap, k): Finds the k-th smallest element in the given binary min-heap. :param heap: List[int] - A list representing a binary min-heap. :param k: int - The k-th position (1-based) to find the smallest element. :return: int - The k-th smallest element in the heap. # Create a min-heap to store the elements we need to process heapq.heapify(heap) # Extract elements from the heap k times to get the k-th smallest element kth_element = None for _ in range(k): kth_element = heapq.heappop(heap) return kth_element"},{"question":"# Context You are tasked with creating a simplified Priority Queue class in Python that supports inserting elements with priorities, retrieving the element with the highest priority, and removing elements. This class should mimic the behavior of a typical priority queue. # Problem Statement Implement a `PriorityQueue` class that supports the following methods: - `enqueue(self, elem, priority)`: Inserts an element with the given priority into the priority queue. - `dequeue(self)`: Removes and returns the element with the highest priority. Raises an `IndexError` if the queue is empty. - `peek(self)`: Returns the element with the highest priority without removing it from the queue. Raises an `IndexError` if the queue is empty. - `is_empty(self)`: Returns `True` if the priority queue is empty, `False` otherwise. - `size(self)`: Returns the number of elements in the priority queue. # Requirements 1. Your PriorityQueue should use a binary heap to maintain the order of elements. 2. The heap should be implemented as a min-heap where the element with the lowest priority number is considered the highest priority. 3. The PriorityQueue should aim for an average time complexity of O(log n) for insertion and deletion operations. # Constraints - You can assume that all elements and priorities are valid inputs. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class PriorityQueue: def __init__(self): # Initialize your data structure self.heap = [] def enqueue(self, elem, priority): # Insert element with given priority pass def dequeue(self): # Remove and return the element with the highest priority pass def peek(self): # Return the element with the highest priority without removing it pass def is_empty(self): # Check if the priority queue is empty pass def size(self): # Return the number of elements pass ``` # Example Usage ```python pq = PriorityQueue() pq.enqueue(\\"task1\\", 5) pq.enqueue(\\"task2\\", 1) print(pq.peek()) # Output: task2 print(pq.size()) # Output: 2 print(pq.dequeue()) # Output: task2 print(pq.is_empty()) # Output: False print(pq.dequeue()) # Output: task1 print(pq.is_empty()) # Output: True ``` This new question maintains the style, complexity, and general scope of the original question by requiring the implementation of a data structure with specific operations and average time complexity, similar to the provided `HashMap` class task.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def enqueue(self, elem, priority): heapq.heappush(self.heap, (priority, elem)) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty priority queue\\") return heapq.heappop(self.heap)[1] def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty priority queue\\") return self.heap[0][1] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"# Graph-based Shortest Path Algorithm Implementation Assessment Context You are tasked with implementing and enhancing a Dijkstra\'s Shortest Path algorithm. This will help ensure comprehension of aspects related to graph data structures, priority queues, and algorithmic efficiency. The functionality will be tested on both directed and undirected weighted graphs. Task 1. **Implement Graph Representation**: - Create an adjacency list representation of the graph. - Ensure the graph can handle weighted edges and both directed and undirected types. 2. **Implement Dijkstra\'s Algorithm**: - Implement Dijkstra\'s algorithm to find the shortest path from a source node to all other nodes in the graph. - Use a priority queue to ensure the efficiency of the algorithm. Expected Function Implementation 1. **Graph Representation (Adjacency List)**: ```python class Graph: def __init__(self, num_nodes, directed=False): # Your code here def add_edge(self, u, v, weight): # Your code here ``` 2. **Dijkstra\'s Algorithm**: ```python def dijkstra(graph: Graph, start_node: int) -> dict: # Your code here ``` Input and Output **Input**: - Number of nodes in the graph (integer) - List of edges as tuples (u, v, weight) - Type of graph (\'directed\' or \'undirected\') - Source node for Dijkstra\'s algorithm (integer) **Output**: - Dictionary containing the shortest distance from the source node to each other node in the format `{node: distance}` Constraints - The number of nodes should be a positive integer. - The edges should be a list of tuples (u, v, weight) where `u` and `v` are node identifiers and `weight` is a non-negative float or integer. - The source node should be a valid node identifier within the range of the number of nodes. Scenario Implement the required classes and methods, then validate their correctness by finding the shortest paths in given example graphs. Ensure that the algorithm is efficient and correctly handles both directed and undirected graphs.","solution":"import heapq class Graph: def __init__(self, num_nodes, directed=False): self.num_nodes = num_nodes self.directed = directed self.adjacency_list = {i: [] for i in range(num_nodes)} def add_edge(self, u, v, weight): self.adjacency_list[u].append((v, weight)) if not self.directed: self.adjacency_list[v].append((u, weight)) def dijkstra(graph, start_node): distances = {node: float(\'inf\') for node in range(graph.num_nodes)} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph.adjacency_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Exercise: Bracket Matching Validator **Objective**: Using the understanding of stack data structures and string manipulation, implement a function that validates if the given sequence of brackets is correctly matched. # Specification: 1. Write a function `is_valid_bracket_sequence(brackets: str) -> bool` that checks if the supplied bracket sequence is valid. A sequence is considered valid if: - Every opening bracket has a corresponding closing bracket. - Brackets are correctly nested. - The sequence may include three types of brackets: \'()\', \'[]\', \'{}\'. # Function Signature: ```python def is_valid_bracket_sequence(brackets: str) -> bool: Determines if the bracket sequence is valid. Parameters: brackets (str): The string containing only bracket characters to be validated. Returns: bool: True if the bracket sequence is valid, False otherwise. pass ``` # Constraints: * The input string `brackets` contains only characters \'()\', \'[]\', \'{}\'. * The length of the input string does not exceed 1000 characters. # Examples: ```python >>> is_valid_bracket_sequence(\'()\') True >>> is_valid_bracket_sequence(\'{[()]}\') True >>> is_valid_bracket_sequence(\'[(])\') False >>> is_valid_bracket_sequence(\'][\') False ``` # Context: You are tasked with creating a validation function to check the correctness of nested bracket sequences, which is essential in parsing expressions in compilers, ensuring mathematical expressions are well-formed in calculators, and maintaining the integrity of HTML/XML tags. # Notes: - Use a stack to manage the bracket pairs for efficient validation. - Design the function to handle potential edge cases where the string is empty or consists of unmatched brackets.","solution":"def is_valid_bracket_sequence(brackets: str) -> bool: Determines if the bracket sequence is valid. Parameters: brackets (str): The string containing only bracket characters to be validated. Returns: bool: True if the bracket sequence is valid, False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in brackets: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Problem Description Given a string containing alphabetic characters, spaces, and punctuation, write a function to determine the most frequently occurring character in the string. If there is a tie for most frequent character, return the lexicographically smallest character. Implement a function that: - **Function Name**: `most_frequent_char(s: str) -> str` - **Inputs**: `s` - a string consisting of alphabetic characters, spaces, and punctuation. The length of `s` is between 1 and 1000. - **Output**: Returns the most frequently occurring character in the string. # Constraints - Consider all alphabetic characters as case-sensitive (\'a\' and \'A\' are different). - Ignore spaces and punctuation in the determination of frequency. # Examples 1. **Example 1**: - **Input**: `s = \\"hello world\\"` - **Output**: `\\"l\\"` 2. **Example 2**: - **Input**: `s = \\"aabbCC\\"` - **Output**: `\\"C\\"` # Task Write your implementation considering the constraints. Ensure your solution effectively handles ties by returning the lexicographically smallest character. Optimize for both readability and efficiency.","solution":"from collections import Counter import string def most_frequent_char(s: str) -> str: Returns the most frequently occurring alphabetic character in the string s. If there is a tie, returns the lexicographically smallest character. Ignores spaces and punctuation. # Filter out non-alphabetic characters filtered_s = [char for char in s if char in string.ascii_letters] # Count the frequency of each character char_counts = Counter(filtered_s) # Determine the most frequent character considering lexicographical order for ties most_frequent = min(((-count, char) for char, count in char_counts.items()))[1] return most_frequent"},{"question":"# Question Context In data analysis or competitive programming, efficiently finding statistics on a list of integers can be a frequent task. One common requirement is to identify the smallest missing positive integer from a sequence, which can assist in various problem-solving contexts such as scheduling, indexing, and resource management. Task Write a function `smallest_missing_positive` that finds the smallest positive integer that is missing from an unsorted list of integers. Function Signature ```python def smallest_missing_positive(nums: list[int]) -> int: ``` Input * `nums` – a list of integers where the length of the list is between 1 and 100,000 inclusive, and each integer in the list can range from `-10^6` to `10^6`. Output * Return the smallest positive integer that is missing from the list. Examples ```python assert smallest_missing_positive([3, 4, -1, 1]) == 2 assert smallest_missing_positive([1, 2, 0]) == 3 assert smallest_missing_positive([7, 8, 9, 11, 12]) == 1 assert smallest_missing_positive([1, 2, 3, 4, 5, 6]) == 7 assert smallest_missing_positive([-1, -2, -3, -4]) == 1 ``` Explanation * The function should handle both positive and negative integers. * The smallest missing positive integer is the smallest positive number not present in the list. * A native solution would involve sorting, but more optimal solutions can use hash sets or index-based marking to achieve the result in linear time. * Pay attention to edge cases, such as lists filled with negative numbers or a sequence containing all positive integers from 1 to n. Constraints * Optimize for time and space complexity suitable for lists with up to 100,000 elements. * Do not use sort-based solutions as they may exceed acceptable time complexity for large inputs.","solution":"def smallest_missing_positive(nums: list[int]) -> int: Finds the smallest missing positive integer from an unsorted list of integers. n = len(nums) # Move all non-positive numbers and numbers greater than n to the end for i in range(n): while 0 < nums[i] <= n and nums[i] != nums[nums[i] - 1]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # The first index i such that nums[i] is not i + 1 is the answer for i in range(n): if nums[i] != i + 1: return i + 1 # If all positions are correct, answer is n + 1 return n + 1"},{"question":"# Log Analyzer As a system administrator, you are tasked with analyzing server log files to identify potential issues. You have a log file containing various entries, including error messages, warnings, and standard operational messages. Your goal is to parse the log file and extract entries based on severity level to help prioritize troubleshooting efforts. Task You need to implement the `extract_log_entries` function in Python, which filters log entries by their severity level and returns a list of corresponding messages. Function Signature ```python def extract_log_entries(log_file: str, severity: str) -> List[str]: ``` Input * `log_file`: A string representing the path to the log file. * `severity`: A string representing the severity level to filter by. Possible values are \\"ERROR\\", \\"WARNING\\", and \\"INFO\\". Output * Returns a list of strings, where each string is a log entry that matches the specified severity level. Constraints * The log file is a plain text file, with each line containing a log entry in the format `[SEVERITY] Message`, where `SEVERITY` is either \\"ERROR\\", \\"WARNING\\", or \\"INFO\\". * The log file may contain varying amounts of whitespace and newline characters around or within entries. * The severity levels are case-sensitive and should be matched exactly. * The log file can be very large, so consider memory efficiency. Examples ```python # Given content of `server.log`: # [INFO] Server started successfully # [WARNING] High memory usage detected # [ERROR] Failed to connect to database # [INFO] New user registered # [ERROR] Disk space critically low # Example usage: extract_log_entries(\\"path/to/server.log\\", \\"ERROR\\") # Should return: [\\"[ERROR] Failed to connect to database\\", \\"[ERROR] Disk space critically low\\"] extract_log_entries(\\"path/to/server.log\\", \\"INFO\\") # Should return: [\\"[INFO] Server started successfully\\", \\"[INFO] New user registered\\"] ``` Requirements * Read the log file line by line to avoid memory overuse. * Strip unnecessary whitespace from each line before processing. * Ensure that the output list maintains the order of entries as they appear in the log file. * Handle edge cases where the log file might be empty, contain no matching severity level, or include malformed entries.","solution":"from typing import List def extract_log_entries(log_file: str, severity: str) -> List[str]: matching_entries = [] with open(log_file, \'r\') as file: for line in file: line = line.strip() if line.startswith(f\'[{severity}]\'): matching_entries.append(line) return matching_entries"},{"question":"# Coding Assessment Question # Context You have been assigned to analyze a dataset consisting of daily rainfall measurements recorded over a period of days. Your task is to identify the longest period of consecutive days where the rainfall was consistently above a specified threshold. This will help in understanding consistent rainfall patterns over time. # Task Write a function `longest_rainy_streak(measurements: List[float], threshold: float) -> int` that determines the longest streak of consecutive days where the daily rainfall measurement is above a given `threshold`. # Function Signature ```python from typing import List def longest_rainy_streak(measurements: List[float], threshold: float) -> int: pass ``` # Input * `measurements` (List[float]): A list of daily rainfall measurements (0 ≤ len(measurements) ≤ 1,000,000; 0 ≤ measurements[i] ≤ 100). * `threshold` (float): The rainfall threshold to compare each day\'s measurement against (0 ≤ threshold ≤ 100). # Output * Returns an integer representing the length of the longest streak of consecutive days where the rainfall was above the `threshold`. # Example ```python >>> longest_rainy_streak([1.2, 2.5, 0.0, 4.7, 2.3, 5.0], 2.0) 3 >>> longest_rainy_streak([0.1, 0.2, 0.3, 0.4, 0.5], 1.0) 0 >>> longest_rainy_streak([], 1.0) 0 ``` # Constraints * The function should efficiently handle large lists, using O(n) time complexity and O(1) additional space complexity. * Ensure to consider edge cases, such as an empty list or no measurements above the threshold. # Notes * You may assume that the threshold will always be a valid float within the specified range. * Consider how you might optimize the solution to handle the upper bounds of input size efficiently.","solution":"from typing import List def longest_rainy_streak(measurements: List[float], threshold: float) -> int: max_streak = 0 current_streak = 0 for measurement in measurements: if measurement > threshold: current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 0 # In case the longest streak is at the end of the list max_streak = max(max_streak, current_streak) return max_streak"},{"question":"# Coding Assessment Question You are tasked with developing a function that retrieves weather data from a weather API for a specific city over a specified date range. The function should handle errors gracefully, support checking data retrieval frequency to avoid redundant API calls, and caché responses for performance optimization. Function Specification **Function Name**: `get_weather_data` **Input Parameters**: 1. `city_name`: (str) The name of the city for which the weather data is to be fetched. 2. `start_date`: (str) Start date in `YYYY-MM-DD` format. 3. `end_date`: (str) End date in `YYYY-MM-DD` format. 4. `check_frequency`: (int) Optional parameter defining the frequency in hours to check the weather data. Default is 24 hours. **Output**: - If successful, returns a list of dictionaries where each dictionary contains the date, temperature, humidity, and weather description. - In the case of failures, returns an appropriate error message or an empty list. **Constraints**: - The `start_date` should not be after the `end_date`. - Only dates within the API\'s available data range should be considered. - Implement a caching mechanism to store responses for previously fetched queries. Example Usage ```python def get_weather_data(city_name: str, start_date: str, end_date: str, check_frequency=24) -> list: # Your implementation here pass # Example call results = get_weather_data(\\"London\\", \\"2023-03-01\\", \\"2023-03-05\\") for weather in results: print(weather) ``` # Requirements: 1. **Error Handling**: Your implementation should gracefully handle API errors, invalid date ranges, and empty responses. 2. **Caching**: Implement a simple caching mechanism to save previous responses in memory and allow re-use when the same query is made more than once. 3. **Data Frequency**: Ensure that the function only retrieves data at intervals specified by `check_frequency` to avoid excessive API calls. 4. **Efficiency**: Optimize the solution to handle requests efficiently without significant performance degradation. 5. **Clear Documentation and Code**: Provide clear function and variable names, and ensure your code is well-documented. You have 2 hours to complete this task. Good luck!","solution":"import requests from datetime import datetime, timedelta # A simple in-memory cache cache = {} def get_weather_data(city_name: str, start_date: str, end_date: str, check_frequency=24) -> list: Fetches weather data for a city between start_date and end_date. Implements caching and checks the frequency of API calls. Parameters: - city_name (str): The city\'s name. - start_date (str): The start date in YYYY-MM-DD format. - end_date (str): The end date in YYYY-MM-DD format. - check_frequency (int): The frequency in hours to check weather data. Default is 24 hours. Returns: - List of dictionaries containing the date, temperature, humidity, and weather description. # Validate input dates try: start_dt = datetime.strptime(start_date, \'%Y-%m-%d\') end_dt = datetime.strptime(end_date, \'%Y-%m-%d\') if start_dt > end_dt: return \\"Start date should not be after end date.\\" except ValueError: return \\"Invalid date format. Use YYYY-MM-DD.\\" # Generating cache key cache_key = f\\"{city_name}_{start_date}_{end_date}\\" # Return cached response if available if cache_key in cache: return cache[cache_key] # Define API URL and parameters API_KEY = \'your_api_key_here\' # Replace with your actual API key BASE_URL = \\"http://api.weatherapi.com/v1/history.json\\" weather_data = [] current_date = start_dt # Loop through the date range based on the frequency while current_date <= end_dt: if current_date.hour % check_frequency == 0: # Format current date date_str = current_date.strftime(\'%Y-%m-%d\') # Define request parameters params = { \'key\': API_KEY, \'q\': city_name, \'dt\': date_str } try: response = requests.get(BASE_URL, params=params) response_data = response.json() if \'error\' in response_data: return response_data[\'error\'][\'message\'] for weather in response_data[\'forecast\'][\'forecastday\']: weather_data.append({ \\"date\\": weather[\\"date\\"], \\"temperature\\": weather[\\"day\\"][\\"avgtemp_c\\"], \\"humidity\\": weather[\\"day\\"][\\"avghumidity\\"], \\"description\\": weather[\\"day\\"][\\"condition\\"][\\"text\\"] }) except requests.exceptions.RequestException as e: return f\\"API request failed: {e}\\" # Increment date by check_frequency hours current_date += timedelta(hours=check_frequency) # Cache the response cache[cache_key] = weather_data return weather_data"},{"question":"# Coding Assessment Question Context Imagine you are tasked with creating a simple yet efficient booking system for a conference room. Each booking request consists of a start time and end time, and you must determine whether the room is available for the requested time slot without any overlaps. Problem Statement Implement the function `is_room_available` to determine if a conference room is available for a new booking request, considering the existing bookings. Function Signature ```python from typing import List, Tuple def is_room_available(existing_bookings: List[Tuple[int, int]], new_booking: Tuple[int, int]) -> bool: ``` Input * `existing_bookings` (List[Tuple[int, int]]): A list of tuples where each tuple represents an existing booking with start and end times (start_time, end_time). * `new_booking` (Tuple[int, int]): A tuple representing the new booking request with start and end times (start_time, end_time). Output * A boolean value indicating whether the room is available for the new booking (`True`) or not (`False`). Constraints * `0 <= start_time < end_time <= 1440` (Times are represented in minutes of a day, from 0 to 1440). * The new booking times are within the same constraints. * Existing bookings can be empty (i.e., no existing bookings). * Assume all times are given in the 24-hour format, converted to minutes from midnight. Example ```python >>> existing_bookings = [(60, 150), (200, 240), (300, 330)] >>> new_booking = (240, 300) >>> is_room_available(existing_bookings, new_booking) True >>> existing_bookings = [(60, 150), (200, 240), (300, 330)] >>> new_booking = (100, 250) >>> is_room_available(existing_bookings, new_booking) False ``` Notes - Ensure the function can efficiently handle the checking to support the time constraints. - Consider edge cases such as no existing bookings and bookings that exactly overlap with existing ones.","solution":"from typing import List, Tuple def is_room_available(existing_bookings: List[Tuple[int, int]], new_booking: Tuple[int, int]) -> bool: new_start, new_end = new_booking for start, end in existing_bookings: # Check if there is an overlap if new_start < end and new_end > start: return False return True"},{"question":"# Scenario You are developing a text processing application that facilitates efficient search within a body of text. One important feature is to identify the longest common substring (LCS) shared between two given strings. Your task is to implement an algorithm that computes this longest common substring. # Coding Task Write a function `longest_common_substring(s1: str, s2: str) -> str` that finds and returns the longest common substring between the two given strings. # Input 1. `s1` (str): The first input string. 2. `s2` (str): The second input string. # Output 1. A string representing the longest common substring found in both input strings. If there are multiple substrings with the maximum length, return any one of them. If no common substring exists, return an empty string. # Constraints 1. The input strings `s1` and `s2` will have a maximum length of 1000 characters. 2. The input strings will consist of lowercase alphabets only. 3. The program should have a time complexity better than O(n^3) to handle worst-case scenarios efficiently. # Performance Requirements 1. Efficient execution given the input size constraints. 2. Optimal space utilization. # Starter Code ```python def longest_common_substring(s1, s2): m, n = len(s1), len(s2) if m == 0 or n == 0: return \\"\\" # Create a table to store lengths of longest common suffixes of substrings # LCSuff[i][j] contains the length of the longest common suffix of s1[0..i-1] and s2[0..j-1]. LCSuff = [[0] * (n + 1) for _ in range(m + 1)] # To store the length of the longest common substring length = 0 # To store the ending point of the longest common substring in s1 end_pos = 0 # Building the LCSuff table in a bottom-up fashion for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: LCSuff[i][j] = 0 elif s1[i-1] == s2[j-1]: LCSuff[i][j] = LCSuff[i-1][j-1] + 1 if LCSuff[i][j] > length: length = LCSuff[i][j] end_pos = i - 1 else: LCSuff[i][j] = 0 # No common substring found if length == 0: return \\"\\" # The longest common substring is from end_pos - length + 1 to end_pos in s1 return s1[end_pos - length + 1: end_pos + 1] # Example: # s1 = \\"abcdef\\" # s2 = \\"zabdf\\" # result = longest_common_substring(s1, s2) # print(result) # Outputs \'ab\' ``` # Evaluation Criteria * Correctness: The functionality should align with traditional methods for identifying the longest common substring. * Efficiency: The implementation should handle the given constraints effectively. * Edge Case Handling: Properly handle cases where one or both strings are empty or no common substring exists.","solution":"def longest_common_substring(s1, s2): Function to find the longest common substring between two input strings s1 and s2. :param s1: The first input string. :param s2: The second input string. :return: The longest common substring between s1 and s2. m, n = len(s1), len(s2) if m == 0 or n == 0: return \\"\\" # Create a table to store lengths of longest common suffixes of substrings LCSuff = [[0] * (n + 1) for _ in range(m + 1)] # To store the length of the longest common substring length = 0 # To store the ending point of the longest common substring in s1 end_pos = 0 # Building the LCSuff table in a bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: LCSuff[i][j] = LCSuff[i-1][j-1] + 1 if LCSuff[i][j] > length: length = LCSuff[i][j] end_pos = i - 1 else: LCSuff[i][j] = 0 # No common substring found if length == 0: return \\"\\" # The longest common substring is from end_pos - length + 1 to end_pos in s1 return s1[end_pos - length + 1: end_pos + 1]"},{"question":"# Question: Compute the Next Smaller Permutation Given a list of unique integers, write a function `next_smaller_permutation(nums: List[int]) -> List[int]` that finds the next smaller permutation of the given list of integers in lexicographical order. If such permutation doesn’t exist, return the list sorted in descending order. Constraints - The input `nums` will always be a list of unique integers with length at least 1 and at most 1000 (1 ≤ len(nums) ≤ 1000). Function Signature ```python from typing import List def next_smaller_permutation(nums: List[int]) -> List[int]: # Your implementation here ``` Example ```python assert next_smaller_permutation([3, 2, 1]) == [3, 1, 2] assert next_smaller_permutation([1, 2, 3]) == [3, 2, 1] assert next_smaller_permutation([1, 3, 2]) == [1, 2, 3] assert next_smaller_permutation([5, 4, 3, 2, 1]) == [5, 4, 3, 1, 2] assert next_smaller_permutation([1]) == [1] ``` Explanation For the input `[3, 2, 1]`, the next permutation in the order that is smaller is `[3, 1, 2]`. For the input `[1, 2, 3]`, the next smaller permutation is `[3, 2, 1]` as there is no smaller permutation, thus returning it sorted in descending order. For `[1, 3, 2]`, the next smaller permutation is `[1, 2, 3]`. For `[5, 4, 3, 2, 1]`, the next smaller permutation is `[5, 4, 3, 1, 2]`. Your goal is to implement the function `next_smaller_permutation` to handle the provided examples and edge cases as outlined.","solution":"from typing import List def next_smaller_permutation(nums: List[int]) -> List[int]: n = len(nums) if n == 1: return nums # Find the rightmost number which is not in descending order i = n - 2 while i >= 0 and nums[i] <= nums[i + 1]: i -= 1 if i == -1: return sorted(nums, reverse=True) # Find the rightmost number which is smaller than nums[i] j = n - 1 while nums[j] >= nums[i]: j -= 1 # Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Reverse the sequence after i nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"# Problem Statement You have been tasked with developing a custom logging system that tracks events in a software application. The logs are stored in memory and should support efficient insertion and querying operations. Your goal is to implement two functions, `log_event` and `query_logs`. The `log_event` function records an event with a timestamp, and the `query_logs` function retrieves the events that occurred within a given time range. **Function 1: log_event** - **Input**: A string `event` and an integer `timestamp`. - `event` is a string representing the event to be logged. - `timestamp` is an integer representing the time the event occurred (in seconds since epoch). - **Output**: None. - **Behavior**: Store the event along with its timestamp in memory. **Function 2: query_logs** - **Input**: Two integers, `start_time` and `end_time`. - `start_time` is an integer representing the query start time (in seconds since epoch). - `end_time` is an integer representing the query end time (in seconds since epoch). - **Output**: A list of strings representing the events that occurred within the specified time range [start_time, end_time]. - **Behavior**: Retrieve all events that have timestamps within the time range, inclusive of both `start_time` and `end_time`. Return the events in the order they were logged. **Constraints**: - The `log_event` function may be called up to 10^5 times. - The `query_logs` function may be called up to 10^4 times. - Timestamps are guaranteed to be non-negative integers. - Event strings will have a maximum length of 100 characters. # Example ```python # Example Usage log_event(\\"start_process\\", 1609459200) log_event(\\"process_data\\", 1609459260) log_event(\\"end_process\\", 1609459320) events = query_logs(1609459200, 1609459260) print(events) # [\\"start_process\\", \\"process_data\\"] events = query_logs(1609459201, 1609459319) print(events) # [\\"process_data\\"] # Test Cases log_event(\\"event1\\", 1) log_event(\\"event2\\", 2) log_event(\\"event3\\", 3) assert query_logs(1, 2) == [\\"event1\\", \\"event2\\"] assert query_logs(2, 3) == [\\"event2\\", \\"event3\\"] assert query_logs(0, 4) == [\\"event1\\", \\"event2\\", \\"event3\\"] ``` **Scenario**: Imagine you are building a server that handles a high volume of incoming requests, and you need to log each request with its timestamp efficiently. From time to time, you also need to query the logs to analyze requests received in specific time intervals for debugging or monitoring purposes. **Edge Cases**: - Ensure proper handling of overlapping time intervals. - Handle the case when no events fall within the queried time range. - Efficiently store and retrieve logged events to handle the given constraints on the number of calls.","solution":"# Initialize an empty list to store event logs event_logs = [] def log_event(event, timestamp): Records an event with its timestamp. :param event: str, the event to be logged :param timestamp: int, the time the event occurred (in seconds since epoch) event_logs.append((timestamp, event)) def query_logs(start_time, end_time): Retrieves the events that occurred within the specified time range [start_time, end_time]. :param start_time: int, the query start time (in seconds since epoch) :param end_time: int, the query end time (in seconds since epoch) :return: list of str, the events within the specified time range return [event for timestamp, event in event_logs if start_time <= timestamp <= end_time]"},{"question":"**Question:** You are implementing a feature for your software that enables users to compress a string by eliminating consecutive duplicate characters and replacing them with a single character followed by the number of times it appears consecutively. For example, the string `\\"aaabbcc\\"` would be compressed to `\\"a3b2c2\\"`. If a character appears only once, it should not be followed by a number. **Task:** Write a Python function `compress_string(s: str) -> str` that compresses the given string by replacing sequences of the same character with the character followed by the count of occurrences. Use a linear pass through the string to implement this function. **Input:** * `s`: A non-empty string consisting of lowercase English letters (1 ≤ len(s) ≤ 1000) **Output:** * Returns the compressed version of the input string. **Example:** ```python compress_string(\\"aaabbcc\\") ``` Output: ```python \\"a3b2c2\\" ``` ```python compress_string(\\"abc\\") ``` Output: ```python \\"abc\\" ``` **Constraints:** * The input string consists only of lowercase English letters. * The length of the string will be at most 1000 characters. **Hint:** Iterate through the string, keeping track of the current character and its frequency. Build the result string by appending each character and its count (if greater than 1).","solution":"def compress_string(s: str) -> str: Compress the given string by replacing sequences of the same character with the character followed by the count of occurrences unless the character appears only once. if not s: return \\"\\" compressed_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed_str.append(s[i-1]) if count > 1: compressed_str.append(str(count)) count = 1 # add the last character and its count compressed_str.append(s[-1]) if count > 1: compressed_str.append(str(count)) return \'\'.join(compressed_str)"},{"question":"# Permutations and Unique Combinations You are working as a software engineer for a company that requires an application to generate unique combinations of a given string. The task is to write a function that accepts a string input and generates all unique combinations (subsets) of the characters in the string. The function should consider each character\'s frequency in the string. For example, for the string \\"aab,\\" it should generate unique combinations while maintaining the original frequency count of each character in the input string. **Function Signature:** ```python def unique_combinations(s: str) -> List[str]: Generate all unique combinations of characters in the given string. :param s: Input string :return: List of all unique combinations, sorted lexicographically pass ``` **Input:** - `s` (str): A string of English lowercase alphabets, with a length from 1 to 10. **Output:** - Returns a list of all unique combinations of characters sorted lexicographically. **Example Cases:** 1. Example 1: ```python print(unique_combinations(\\"aab\\")) # Output: [\\"\\", \\"a\\", \\"aa\\", \\"aab\\", \\"ab\\", \\"b\\"] ``` 2. Example 2: ```python print(unique_combinations(\\"abc\\")) # Output: [\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] ``` 3. Example 3: ```python print(unique_combinations(\\"aaa\\")) # Output: [\\"\\", \\"a\\", \\"aa\\", \\"aaa\\"] ``` **Constraints:** - The output list should not contain duplicate combinations. - The output list should be sorted lexicographically. Implement the `unique_combinations` function as specified above.","solution":"from itertools import combinations from typing import List def unique_combinations(s: str) -> List[str]: Generate all unique combinations of characters in the given string. :param s: Input string :return: List of all unique combinations, sorted lexicographically # Sort the string to ensure lexicographical order in combinations s = \'\'.join(sorted(s)) # Use a set to avoid duplicate combinations unique_combos = set() # Generate combinations of all lengths for i in range(len(s) + 1): for combo in combinations(s, i): unique_combos.add(\'\'.join(combo)) # Return the sorted list of unique combinations return sorted(unique_combos)"},{"question":"# Question: Implement Quicksort Algorithm with Visualization Your task is to create a function that implements the Quicksort algorithm and visualizes the sorting process using matplotlib. The goal is to sort an array of numbers while generating images showing the state of the array during each iteration of the partitioning process. # The Quicksort Function Implement the function `quicksort_visualize` with the following signature: ```python def quicksort_visualize( array: list[int], low: int = 0, high: int | None = None, visualize: bool = True ) -> list[tuple[int, ...]]: Performs the Quicksort algorithm on the provided array, and optionally visualizes the sorting process. Parameters: - array (list[int]): The array of integers to sort. - low (int): The starting index of the subarray to be sorted. - high (int | None): The ending index of the subarray to be sorted. - visualize (bool): Whether to visualize the sorting steps. Returns: - list[tuple[int, ...]]: A list of tuples representing the array state after each partitioning step when visualize is True; empty list otherwise. pass ``` # Requirements 1. **Quicksort Implementation**: Implement the Quicksort algorithm. 2. **Partitioning Steps**: Create a snapshot of the array after each partitioning step. 3. **Visualization using Matplotlib**: Use matplotlib to generate and save images of the array states during the sorting process. 4. **Side-by-Side Plot**: For each partitioning step, generate a plot showing the current state of the array and highlight the pivot element and the partition boundaries. 5. **Optional Visualization**: Allow the user to enable or disable the visualization through a parameter. # Example Usage Sort an array and visualize the process: ```python if __name__ == \\"__main__\\": import matplotlib.pyplot as plt array = [3, 6, 8, 10, 1, 2, 1] def plot_array_state(array, name): fig, ax = plt.subplots() ax.bar(range(len(array)), array) plt.savefig(name) plt.close(fig) states = quicksort_visualize(array, visualize=True) for i, state in enumerate(states): plot_array_state(state, f\\"array_state_{i}.png\\") print(\\"Quicksort complete. Check the generated images for the sorting process.\\") ``` # Constraints - The array contains integers, and its length is between [1, 1000]. - Array elements are integers within the range [-1000, 1000]. # Performance and Visualization Considerations - Ensure the implementation is efficient for arrays up to the upper limit of the specified constraints. - Optimize the visualization process to handle large arrays and ensure the images clearly show array states.","solution":"import matplotlib.pyplot as plt def quicksort_visualize(array, low=0, high=None, visualize=True): if high is None: high = len(array) - 1 steps = [] def partition(arr, low, high): i = low - 1 pivot = arr[high] for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] if visualize: steps.append(tuple(arr)) plot_array_state(arr, f\\"array_state_{len(steps)}.png\\", pivot, low, high) return i + 1 def quicksort(arr, low, high): if low < high: pi = partition(arr, low, high) quicksort(arr, low, pi - 1) quicksort(arr, pi + 1, high) def plot_array_state(array, name, pivot, low, high): fig, ax = plt.subplots() bars = ax.bar(range(len(array)), array) for i in range(len(array)): if array[i] == pivot: bars[i].set_color(\'r\') elif i < low or i > high: bars[i].set_color(\'gray\') plt.savefig(name) plt.close(fig) quicksort(array, low, high) return steps if visualize else [] # Example usage: if __name__ == \\"__main__\\": array = [3, 6, 8, 10, 1, 2, 1] states = quicksort_visualize(array, visualize=True) for i, state in enumerate(states): print(f\\"State {i}: {state}\\") print(\\"Quicksort complete. Check the generated images for the sorting process.\\")"},{"question":"# Problem Description You are tasked with writing a function to perform matrix multiplication using the Strassen algorithm. The Strassen algorithm is an efficient way to multiply two matrices by dividing and conquering. # Input and Output **Function Signature**: ```python def strassen_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: pass ``` **Inputs**: * `matrix1` (List[List[int]]): The first matrix to multiply. * `matrix2` (List[List[int]]): The second matrix to multiply. **Outputs**: * Returns the product matrix as a list of lists. # Constraints * Both matrices must be square matrices of size ( 2^n times 2^n ) where ( n geq 0 ). * The size of the matrices will be ( 2^k times 2^k ) where ( k ) is a non-negative integer. * The integers in the matrices will be in the range ([-10^9, 10^9]). # Example ```python matrix1 = [[1, 2], [3, 4]] matrix2 = [[5, 6], [7, 8]] result = strassen_multiply(matrix1, matrix2) print(result) # Output: [[19, 22], [43, 50]] ``` # Task Implement the `strassen_multiply` function using the Strassen algorithm, ensuring efficient and correct multiplication of the input square matrices. Be sure to handle edge cases where ( n = 0 ), which would result in ( 1 times 1 ) matrices. # Notes The Strassen algorithm involves recursively breaking down each matrix into submatrices and computing intermediary products to achieve a time complexity of approximately ( O(n^{2.81}) ). When implementing, keep these steps in mind: 1. Split the matrices into quadrants. 2. Compute 7 products using Strassen\'s formula. 3. Combine the intermediary products to form the result matrix.","solution":"from typing import List def strassen_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Multiplies two matrices using the Strassen algorithm. def add_matrix(A, B): Adds two matrices. n = len(A) return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)] def subtract_matrix(A, B): Subtracts matrix B from matrix A. n = len(A) return [[A[i][j] - B[i][j] for j in range(n)] for i in range(n)] def split_matrix(A): Splits the given matrix into quarters. n = len(A) mid = n // 2 return ( [row[:mid] for row in A[:mid]], [row[mid:] for row in A[:mid]], [row[:mid] for row in A[mid:]], [row[mid:] for row in A[mid:]] ) n = len(matrix1) if n == 1: return [[matrix1[0][0] * matrix2[0][0]]] A11, A12, A21, A22 = split_matrix(matrix1) B11, B12, B21, B22 = split_matrix(matrix2) M1 = strassen_multiply(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_multiply(add_matrix(A21, A22), B11) M3 = strassen_multiply(A11, subtract_matrix(B12, B22)) M4 = strassen_multiply(A22, subtract_matrix(B21, B11)) M5 = strassen_multiply(add_matrix(A11, A12), B22) M6 = strassen_multiply(subtract_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_multiply(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6) # Combine the results into a single matrix new_matrix = [[0] * n for _ in range(n)] mid = n // 2 for i in range(mid): for j in range(mid): new_matrix[i][j] = C11[i][j] new_matrix[i][j + mid] = C12[i][j] new_matrix[i + mid][j] = C21[i][j] new_matrix[i + mid][j + mid] = C22[i][j] return new_matrix"},{"question":"# Question You are tasked with creating a data transformation tool that swaps the first and last names in a list of `full_names` separated by spaces and capitalizes the initials of each name. The tool will involve both individual transformation of names and a comprehensive function that handles an entire list. Function Specifications: 1. **swap_and_capitalize_name(full_name: str) -> str** * Takes a `full_name` string consisting of a first name and a last name separated by a space. * Swaps the first and last names and capitalizes the first letter of each. * If the input does not meet the expected format (contains exactly one space), raise a `ValueError`. 2. **transform_name_list(name_list: list) -> list** * Takes a list of `full_name` strings. * Returns a new list where each name has been transformed using the `swap_and_capitalize_name` function. Input/Output Requirements: * A `full_name` string will only contain alphabetic characters and a single space separating the first and last name. * The `name_list` will be a non-empty list of such `full_name` strings. Constraints: * Maintain O(n) time complexity for both swapping and capitalizing names, where n is the length of the list. * Ensure robust error handling for any varieties in input format. Example: ```python def test_transform_name_list(): names = [\\"john doe\\", \\"jane smith\\", \\"alice jones\\"] transformed_names = transform_name_list(names) assert transformed_names == [\\"Doe John\\", \\"Smith Jane\\", \\"Jones Alice\\"] try: swapped_name = swap_and_capitalize_name(\\"JohnDoe\\") except ValueError as e: assert str(e) == \\"Input format is incorrect. Please ensure the name contains exactly one space.\\" test_transform_name_list() ``` Additional Context: Imagine you are developing this tool for a local event organizer who needs a way to process a list of participants for customized badges. This solution will help in automatically generating badges with a consistent format easily legible for all attendees. You are expected to implement these functions taking care to follow correct string manipulation and error handling principles.","solution":"def swap_and_capitalize_name(full_name: str) -> str: Swaps the first and last names in full_name and capitalizes the initials. :param full_name: A string containing a first and last name separated by a space. :return: A string with the last and first names swapped and capitalized. :raises ValueError: If the input does not exactly contain one space. parts = full_name.split() if len(parts) != 2: raise ValueError(\\"Input format is incorrect. Please ensure the name contains exactly one space.\\") first_name, last_name = parts return f\\"{last_name.capitalize()} {first_name.capitalize()}\\" def transform_name_list(name_list: list) -> list: Transforms a list of full name strings by swapping and capitalizing their parts. :param name_list: A list of strings where each string is a full name. :return: A new list where each full name has been transformed. return [swap_and_capitalize_name(name) for name in name_list]"},{"question":"# Balanced Parentheses Validator You are given a class `ParenthesesValidator` that checks for balanced parentheses in a string. Your task is to extend the functionality of this class to support validation of strings containing not only parentheses `()` but also square brackets `[]` and curly braces `{}`. # Problem Statement Implement the method `is_valid` in the `ParenthesesValidator` class to support validation of strings containing parentheses `()`, square brackets `[]`, and curly braces `{}`. The method should return `True` if the string is balanced and `False` otherwise. # Constraints 1. The input string may contain any characters, but you need to consider only the brackets `()`, `[]`, and `{}` for validation. 2. The length of the string is between 1 and 10^5 characters. # Input Format ```plaintext - A single string s containing characters including `()`, `[]`, and `{}`. ``` # Output Format ```plaintext - A boolean value indicating whether the string is balanced. ``` # Example ```python validator = ParenthesesValidator() result = validator.is_valid(\\"({[a+b]*[c-d]/(e+f)})\\") print(result) # Output should be: # True result = validator.is_valid(\\"[({]})\\") print(result) # Output should be: # False ``` # Implementation Extend the `ParenthesesValidator` class with the `is_valid` method. Complete the `is_valid` method in the following manner: 1. Use a stack to keep track of the opening brackets encountered. 2. For each closing bracket encountered, check if it matches the most recent opening bracket on the stack. 3. Ensure the string remains balanced throughout the traversal. ```python class ParenthesesValidator: def is_valid(self, s: str) -> bool: stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping.values(): stack.append(char) elif char in mapping.keys(): if stack == [] or mapping[char] != stack.pop(): return False return stack == [] ``` # Notes 1. Ignore all characters in the input string other than `()`, `[]`, and `{}` during validation. 2. Make sure the method is efficient and can handle long strings within the given constraints.","solution":"class ParenthesesValidator: def is_valid(self, s: str) -> bool: Validates if the given string has balanced parentheses, square brackets, and curly braces. Args: s (str): The input string containing characters including (), [], and {}. Returns: bool: True if the string is balanced, False otherwise. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping.values(): stack.append(char) elif char in mapping.keys(): if not stack or mapping[char] != stack.pop(): return False return not stack"},{"question":"You are given a list of integers `arr` and a target value `target`. You need to write a function `three_sum_closest(arr: List[int], target: int) -> int` that returns the sum of three integers in the list that is closest to the given target. You are allowed to assume that each input would have exactly one solution. # Example ```python >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([0, 0, 0], 1) 0 >>> three_sum_closest([1, 1, 1, 0], -100) 2 ``` # Constraints * `arr` will have at least 3 integers, and the length can be up to 3000. * Each integer in `arr` can be between `-10^3` and `10^3`. * The target is also an integer within the range `-10^4` to `10^4`. # Requirements 1. Implement the function efficiently to find the closest sum. 2. The solution should consider edge cases such as: - Multiple potential sums equally close to the target. - All elements in the array being the same. - Arrays with negative and positive values. # Performance Expectations * The solution should ideally have a time complexity of O(n^2). * The solution should use only constant extra space for variables, not including the input data.","solution":"from typing import List def three_sum_closest(arr: List[int], target: int) -> int: arr.sort() closest_sum = float(\'inf\') for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"Coding Assessment Question # Context You are developing a system that analyzes large datasets consisting of strings. One of the key functionalities required is the ability to find common prefixes among a collection of strings quickly. This will help in various tasks such as auto-completion, data compression, and fast string matching. # Task Implement a Trie (Prefix Tree) and provide a function to perform a common prefix search. # Function Specifications **Function 1: Construct the Trie** - **Function Name**: `build_trie` - **Input**: A list of strings (`words: List[str]`). - **Output**: The root of the Trie (`TrieNode`). **Function 2: Common Prefix Search** - **Function Name**: `find_common_prefix` - **Input**: - The root of the Trie (`root: TrieNode`). - A prefix to search for (`prefix: str`). - **Output**: A list of words that start with the given prefix (`List[str]`). # Constraints - You can assume each string contains only lowercase English letters. - Do not use any external Trie libraries. # Performance Requirements - Both functions should aim for linear or near-linear complexity with respect to the total length of the words in the list. # Example Usage ```python words = [ \\"apple\\", \\"apply\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"blueberry\\" ] root = build_trie(words) prefix = \\"ap\\" common_prefix_words = find_common_prefix(root, prefix) print(common_prefix_words) # Expected output could be [\\"apple\\", \\"apply\\", \\"apricot\\"] ``` # Notes - Ensure your Trie can handle edge cases, such as an empty list or strings with no common prefixes. - Your implementation should be efficient in both time and space, leveraging the Trie structure\'s properties effectively.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search_prefix(self, prefix): current_node = self.root for char in prefix: if char in current_node.children: current_node = current_node.children[char] else: return [] return self._words_with_prefix(current_node, prefix) def _words_with_prefix(self, node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): words.extend(self._words_with_prefix(next_node, prefix + char)) return words def build_trie(words): trie = Trie() for word in words: trie.insert(word) return trie.root def find_common_prefix(root, prefix): trie = Trie() trie.root = root return trie.search_prefix(prefix)"},{"question":"# Problem Description You are given a string of lowercase and uppercase letters. Your task is to implement a function that recursively counts the number of vowels (a, e, i, o, u) in the string. The function should be case-insensitive, i.e., it should treat \'A\' and \'a\' as the same vowel. # Function Signature ```python def count_vowels(s: str) -> int: pass ``` # Input * `s` (str): A string containing only alphabetic characters (both lowercase and uppercase). # Output * An integer representing the number of vowels in the string. # Constraints * The string can be empty. * The string will contain only alphabetic characters (no spaces, digits, or special characters). * The function must be implemented using recursion. # Example ```python # Test Case 1 assert count_vowels(\\"hello\\") == 2 # Test Case 2 assert count_vowels(\\"HELLO\\") == 2 # Test Case 3 assert count_vowels(\\"aEiOu\\") == 5 # Test Case 4 assert count_vowels(\\"Programming\\") == 3 # Test Case 5 assert count_vowels(\\"\\") == 0 ``` # Explanation: 1. In test case 1, the string \\"hello\\" contains two vowels: \'e\' and \'o\'. 2. In test case 2, the string \\"HELLO\\" also contains two vowels: \'E\' and \'O\', demonstrating case insensitivity. 3. In test case 3, the string \\"aEiOu\\" has all five vowels. 4. In test case 4, the string \\"Programming\\" includes three vowels: \'o\', \'a\', and \'i\'. 5. In test case 5, an empty string has zero vowels. Use the provided starting code to implement your solution. Make sure your function adheres to the function signature specified above.","solution":"def count_vowels(s: str) -> int: Recursively counts the number of vowels in the string s. vowels = \\"aeiou\\" s = s.lower() if len(s) == 0: return 0 if s[0] in vowels: return 1 + count_vowels(s[1:]) else: return count_vowels(s[1:])"},{"question":"# Problem Statement You are given a list of strings and a target word. Your task is to find the index of the first occurrence of the target word in the list. If the target word is not in the list, return `-1`. # Input - A list of strings `words`, where each string is non-empty. - A single string `target`, which is the word you are looking for. # Output - An integer representing the index of the first occurrence of the target word in the list, or `-1` if the target word is not found. # Constraints - `words` will be a non-empty list of non-empty strings. - `target` will be a non-empty string. # Function Signature ```python def find_word_index(words: list, target: str) -> int: ``` # Examples ```python >>> find_word_index([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"cherry\\") 2 >>> find_word_index([\\"apple\\", \\"banana\\", \\"banana\\", \\"date\\"], \\"banana\\") 1 >>> find_word_index([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"orange\\") -1 >>> find_word_index([\\"apple\\"], \\"apple\\") 0 >>> find_word_index([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"\\") Traceback (most recent call last): ... ValueError: The target word must be a non-empty string >>> find_word_index([], \\"apple\\") Traceback (most recent call last): ... ValueError: The input list must be non-empty ``` # Implementation Guidance 1. Validate the input to ensure that `words` is a non-empty list and `target` is a non-empty string. 2. Iterate through the list `words` to find the index of the first occurrence of `target`. 3. If the target word is found, return its index; otherwise, return `-1`. 4. Consider edge cases such as an empty list or target word, and handle these with appropriate error messages.","solution":"def find_word_index(words: list, target: str) -> int: Finds the index of the first occurrence of the target word in the list of words. :param words: List of strings (non-empty) :param target: Target word to find (non-empty string) :return: Index of the first occurrence of the target word, or -1 if not found # Validate input if not words: raise ValueError(\\"The input list must be non-empty\\") if not target: raise ValueError(\\"The target word must be a non-empty string\\") # Find the index of the first occurrence of target for index, word in enumerate(words): if word == target: return index return -1"},{"question":"New Question for Coding Assessment Context: You have been enrolled as a developer to work on problems related to the Fibonacci sequence, which frequently appears in computer science and mathematical applications. The two tasks at hand require generating terms of this sequence and calculating sums based on specific criteria. # Function 1: Generate Fibonacci Sequence **Description**: Write a function, `generate_fibonacci(n: int) -> List[int]`, that takes a positive integer `n` and returns a list of the first `n` terms in the Fibonacci sequence. The Fibonacci sequence is defined as: - F(1) = 0 - F(2) = 1 - F(n) = F(n-1) + F(n-2) for n > 2 - **Input**: An integer `n` (1 ≤ n ≤ 100) - **Output**: A list of integers containing the first `n` terms in the Fibonacci sequence # Function 2: Sum of Even Fibonacci Numbers **Description**: Write a function, `sum_even_fibonacci(limit: int) -> int`, that takes a positive integer `limit` and returns the sum of all even Fibonacci numbers less than or equal to `limit`. - **Input**: An integer `limit` (1 ≤ limit ≤ 10^6) - **Output**: An integer representing the sum of all even Fibonacci numbers not exceeding `limit` ```python from typing import List def generate_fibonacci(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. pass # Implement the function def sum_even_fibonacci(limit: int) -> int: Returns the sum of all even Fibonacci numbers less than or equal to the given limit. pass # Implement the function # Example Usage: # generate_fibonacci(10) -> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # sum_even_fibonacci(100) -> 44 (even Fibonacci numbers: 0, 2, 8, 34) ``` Notes: 1. Ensure your solutions are optimized for the given constraints. 2. Your functions should include necessary input validation and handle edge cases appropriately.","solution":"from typing import List def generate_fibonacci(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. if n <= 0: raise ValueError(\\"n should be a positive integer\\") fibonacci_sequence = [0, 1] # Generate the sequence up to n terms for _ in range(2, n): next_term = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_term) return fibonacci_sequence[:n] def sum_even_fibonacci(limit: int) -> int: Returns the sum of all even Fibonacci numbers less than or equal to the given limit. if limit <= 0: raise ValueError(\\"limit should be a positive integer\\") sum_even = 0 a, b = 0, 1 # Generate Fibonacci numbers and sum the even ones while a <= limit: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even"},{"question":"# Problem Parsing Nested Dictionaries Background: Parsing nested data structures is a common task in many programming applications, especially when dealing with configurations, data interchange formats like JSON, or complex data models. Nested dictionaries are a fundamental construct in Python that can represent hierarchical information. Task: You need to implement a function `get_value` that retrieves a value from a nested dictionary given a path. The path will be specified as a list of keys that must be followed in order to locate the desired value. Function Definition and Requirements: 1. `get_value(data: dict, path: list) -> any`: * **Input**: * `data`: A nested dictionary where each key is a string and values can be either other dictionaries or final values (strings, integers, etc.). * `path`: A list of strings representing the sequence of keys to follow in `data` to locate the value. * **Output**: The value found at the specified path. * **Constraints**: * If any key along the path does not exist, raise a `KeyError` with an appropriate error message. * If the end of the path is reached but the current item is not a dictionary, raise a `ValueError` indicating that the path is incorrect. Example Usage: ```python >>> data = { \'a\': {\'b\': {\'c\': 42}}, \'x\': {\'y\': {\'z\': \'Hello\'}} } >>> get_value(data, [\'a\', \'b\', \'c\']) 42 >>> get_value(data, [\'x\', \'y\', \'z\']) \'Hello\' >>> get_value(data, [\'a\']) {\'b\': {\'c\': 42}} >>> get_value(data, [\'a\', \'b\', \'x\']) Traceback (most recent call last): KeyError: \'x\' not found in the path. >>> get_value(data, [\'a\', \'b\', \'c\', \'d\']) Traceback (most recent call last): ValueError: The path is incorrect. ``` # Guidelines: * Focus on correctly navigating the nested dictionary structure according to the given path. * Ensure robust error handling for missing keys and incorrect path configurations. * Use standard dictionary operations and exception handling in Python. * Aim for clean, readable, and efficient code.","solution":"def get_value(data, path): Retrieves a value from a nested dictionary following a list of keys. :param data: dict, The nested dictionary from which to retrieve the value. :param path: list, The list of keys representing the path to the value. :return: The value located at the end of the path. :raises KeyError: If a key in the path does not exist in the dictionary. :raises ValueError: If the current item in the path is not a dictionary but more keys are provided. current = data for key in path: if not isinstance(current, dict): raise ValueError(f\\"The path is incorrect. {key} is not a part of a dictionary.\\") if key not in current: raise KeyError(f\\"\'{key}\' not found in the path.\\") current = current[key] return current"},{"question":"Determining Stability of a Robot Using Euler Angles # Context For robotics, understanding and maintaining the stability of a robot is crucial during its operation. Stability can be analyzed through the robot\'s orientation in the 3D space, which is often specified using Euler angles: roll (Φ), pitch (Θ), and yaw (Ψ). These angles represent rotation around the x, y, and z axis respectively. Given the robot\'s current orientation, you can determine if the robot is stable based on thresholds for each Euler angle. For this task, consider stability as the absolute value of each angle being less than or equal to 30 degrees. # Task Your task is to implement a Python function that checks the stability of a robot given its Euler angles. # Function Signature ```python def is_robot_stable(roll: float, pitch: float, yaw: float) -> bool: Determines if the robot is stable based on the provided Euler angles. Args: roll (float): The roll angle (in degrees) between -360 and 360. pitch (float): The pitch angle (in degrees) between -360 and 360. yaw (float): The yaw angle (in degrees) between -360 and 360. Returns: bool: True if the robot is stable, False otherwise. Examples: >>> is_robot_stable(10.0, 20.0, 15.0) True >>> is_robot_stable(35.0, 20.0, 15.0) False >>> is_robot_stable(-15.0, -20.0, -30.0) True >>> is_robot_stable(10.0, 45.0, 30.0) False # Constraints * -360 <= roll <= 360 * -360 <= pitch <= 360 * -360 <= yaw <= 360","solution":"def is_robot_stable(roll: float, pitch: float, yaw: float) -> bool: Determines if the robot is stable based on the provided Euler angles. Args: roll (float): The roll angle (in degrees) between -360 and 360. pitch (float): The pitch angle (in degrees) between -360 and 360. yaw (float): The yaw angle (in degrees) between -360 and 360. Returns: bool: True if the robot is stable, False otherwise. return abs(roll) <= 30 and abs(pitch) <= 30 and abs(yaw) <= 30"},{"question":"# Determine Cycle in a Directed Graph You are tasked with devising a function to determine if a directed graph contains a cycle. This question evaluates your ability to implement graph traversal algorithms and handle edge cases. Function: has_cycle Implement a function `has_cycle` that determines whether a given directed graph contains a cycle. The graph is represented by an adjacency list, where the keys are node identifiers and the values are lists of neighboring node identifiers. # Input: * `graph`: A dictionary representing the adjacency list of the graph (e.g., {0: [1], 1: [2], 2: [0]}). # Output: * A boolean value `True` if the graph contains a cycle, otherwise `False`. Example ```python graph1 = {0: [1], 1: [2], 2: [0], 3: [4]} graph2 = {0: [1], 1: [2], 2: [3], 3: []} print(has_cycle(graph1)) # Output: True (because of the cycle 0 -> 1 -> 2 -> 0) print(has_cycle(graph2)) # Output: False ``` # Constraints * The graph will have at least one node. * Node identifiers will be non-negative integers. * The graph may contain disconnected components. Hint - Use Depth-First Search (DFS) to explore the graph. - Keep track of nodes in the recursion stack to detect cycles.","solution":"def has_cycle(graph): Determine if a directed graph contains a cycle using Depth-First Search (DFS). :param graph: Dictionary representing the adjacency list of the graph :return: True if there is a cycle in the graph, False otherwise def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) # Traverse through all the adjacent nodes for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Context You have been working on improving a weather monitoring system that collects temperature data from multiple sensors placed at different locations. Each sensor records the temperature in either Celsius or Fahrenheit. You need to write a function that normalises this data by converting all temperature readings to Kelvin before they are further processed and stored. # Task Implement a function `normalized_temperature_conversion` that performs the conversion of temperature readings from Celsius or Fahrenheit to Kelvin. Your function should handle the following operations: * Validate the input parameters. * Use predefined conversion formulas for accurate conversion. * Ensure that only Celsius or Fahrenheit inputs are accepted. # Requirements * **Input**: * `temperature` (float): The numerical value of the temperature to be converted. * `from_unit` (string): The unit from which the temperature is to be converted. It can be either \\"Celsius\\" or \\"Fahrenheit\\". * **Output**: * A float representing the converted temperature value in Kelvin. * **Constraints**: * The input units must be either \\"Celsius\\" or \\"Fahrenheit\\". * If an unsupported unit is provided, raise a `ValueError` with a message indicating the supported units. * **Performance**: The function should run in constant time O(1). # Example ```python def normalized_temperature_conversion(temperature: float, from_unit: str) -> float: Convert temperature values from Celsius or Fahrenheit to Kelvin using predefined conversion formulas. Parameters: temperature : float: The numerical value to be converted. from_unit : str: The unit from which the value is to be converted (\\"Celsius\\" or \\"Fahrenheit\\"). Returns: float: Converted temperature value in Kelvin. Raises: ValueError: If `from_unit` is not supported. Example: >>> normalized_temperature_conversion(25, \\"Celsius\\") 298.15 >>> normalized_temperature_conversion(77, \\"Fahrenheit\\") 298.15 >>> normalized_temperature_conversion(100, \\"Kelvin\\") ValueError: Invalid \'from_unit\' value: \'Kelvin\'. Supported units: \'Celsius\', \'Fahrenheit\'. if from_unit == \\"Celsius\\": return temperature + 273.15 elif from_unit == \\"Fahrenheit\\": return (temperature - 32) * 5/9 + 273.15 else: raise ValueError(f\\"Invalid \'from_unit\' value: \'{from_unit}\'. Supported units: \'Celsius\', \'Fahrenheit\'.\\") # Test cases print(normalized_temperature_conversion(25, \\"Celsius\\")) # Output: 298.15 print(normalized_temperature_conversion(77, \\"Fahrenheit\\")) # Output: 298.15 print(normalized_temperature_conversion(100, \\"Kelvin\\")) # Raises ValueError ```","solution":"def normalized_temperature_conversion(temperature: float, from_unit: str) -> float: Convert temperature values from Celsius or Fahrenheit to Kelvin using predefined conversion formulas. Parameters: temperature : float: The numerical value to be converted. from_unit : str: The unit from which the value is to be converted (\\"Celsius\\" or \\"Fahrenheit\\"). Returns: float: Converted temperature value in Kelvin. Raises: ValueError: If `from_unit` is not supported. if from_unit == \\"Celsius\\": return temperature + 273.15 elif from_unit == \\"Fahrenheit\\": return (temperature - 32) * 5/9 + 273.15 else: raise ValueError(f\\"Invalid \'from_unit\' value: \'{from_unit}\'. Supported units: \'Celsius\', \'Fahrenheit\'.\\")"},{"question":"# Problem Statement Scenario You have been tasked with implementing a function that determines if a positive integer can be rearranged to create a palindrome. A number is considered a palindrome if it reads the same backward as forward. Task Write a function `can_form_palindrome` which takes a single positive integer as input and returns `True` if the digits of the integer can be rearranged to form a palindrome, and `False` otherwise. Input Format * A single positive integer `n` (1 ≤ `n` ≤ 10^9). Output Format * A boolean value: `True` if the digits can be rearranged to form a palindrome, `False` otherwise. Constraints * The input will always be a positive integer within the range [1, 10^9]. Example ```python can_form_palindrome(121) # Output: True can_form_palindrome(12321) # Output: True can_form_palindrome(123) # Output: False can_form_palindrome(443344) # Output: True ``` Notes * A number can form a palindrome if at most one digit has an odd frequency. * Consider potential performance implications for large input values and ensure your solution is efficient.","solution":"def can_form_palindrome(n): Determines if the digits of a positive integer can be rearranged to form a palindrome. Parameters: n (int): A positive integer. Returns: bool: True if the digits can be rearranged to form a palindrome, False otherwise. from collections import Counter # Convert the number to a string to iterate over digits and count them digit_count = Counter(str(n)) # Calculate how many digits have an odd count odd_count = sum(1 for count in digit_count.values() if count % 2 != 0) # For a number to be rearrangeable into a palindrome, # at most one digit can have an odd count return odd_count <= 1"},{"question":"# Array Rotation Operations **Context**: Array rotation is a common technique used in various applications, such as cryptography, data shuffling, and algorithm design. Your goal is to implement several operations to rotate an array either to the left or to the right by a given number of positions. **Tasks**: 1. `left_rotate(array: List[int], positions: int) -> List[int]`: Rotates the array to the left by the specified number of positions. 2. `right_rotate(array: List[int], positions: int) -> List[int]`: Rotates the array to the right by the specified number of positions. **Input and Output**: - **Input**: Each function takes an array of integers `array` (which may be empty) and an integer `positions`. - **Output**: Return a new array of integers after the rotation. **Constraints**: - `0 <= len(array) <= 10^5` - `0 <= positions <= 10^5` - Handle large values of `positions` efficiently by using modular arithmetic: positions = positions % len(array). **Performance Requirements**: The operations should run in O(n) time, where n is the length of the array, and use O(n) extra space. **Examples**: ```python assert left_rotate([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert right_rotate([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert left_rotate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert right_rotate([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] ``` **Note**: Implement the following functions in a single file named `array_rotation.py`: ```python from typing import List def left_rotate(array: List[int], positions: int) -> List[int]: if not array: return array positions = positions % len(array) return array[positions:] + array[:positions] def right_rotate(array: List[int], positions: int) -> List[int]: if not array: return array positions = positions % len(array) return array[-positions:] + array[:-positions] ``` **Explanation**: - In `left_rotate`, the array is split into two parts at the index `positions`, and they are concatenated in reverse order to achieve the left rotation. - In `right_rotate`, the array is split into two parts at the index `-positions`, and they are concatenated in reverse order to achieve the right rotation. This effectively shifts elements to the right.","solution":"from typing import List def left_rotate(array: List[int], positions: int) -> List[int]: if not array: return array positions = positions % len(array) return array[positions:] + array[:positions] def right_rotate(array: List[int], positions: int) -> List[int]: if not array: return array positions = positions % len(array) return array[-positions:] + array[:-positions]"},{"question":"# Challenge: Implement an XOR Gate for a List of Binary Inputs **Context**: You are developing a digital circuit simulator that includes various logic gates. One of your tasks is to implement an XOR gate that can process multiple binary inputs sequentially. **Problem**: Given a list of binary inputs (each either `0` or `1`), implement a function `xor_gate(inputs: List[int]) -> int` that computes the XOR operation across all inputs. For instance, if the inputs are `[1, 0, 1, 1]`, the computed XOR operation should output `1`. **Constraints**: 1. Each input will be either `0` or `1`. 2. The length of the list will be between `1` and `10^5`. **Input**: - A list `inputs` of length `n` where each element `inputs[i]` is either `0` or `1`. **Output**: - Return the result of the XOR operation applied to all elements in the list. **Performance Requirements**: - The function should process the input in linear time, O(n). **Example**: ```python >>> xor_gate([1, 0, 1, 1]) 1 >>> xor_gate([1, 1, 0]) 0 >>> xor_gate([0]) 0 >>> xor_gate([1]) 1 >>> xor_gate([1, 1, 1, 0, 1]) 0 ```","solution":"def xor_gate(inputs): Takes a list of binary inputs and returns the XOR result of all inputs. Args: inputs (List[int]): A list of integers where each integer is either 0 or 1. Returns: int: The result of XOR operation on all elements of the list. result = 0 for number in inputs: result ^= number return result"},{"question":"# Coding Assessment Question Context In a game of friendly programming competition, participants need to solve queries related to matrix operations. The operations include adding elements to the matrix and finding the maximum sum of elements in any submatrix. Problem Statement Implement the class `MatrixGame` which supports the following methods: 1. `__init__(self, rows: int, cols: int)`: This initializes the matrix game with a matrix of given `rows` and `cols` filled with zeros. 2. `add_element(self, row: int, col: int, value: int) -> None`: This method adds the `value` to the element at position `(row, col)` in the matrix. 3. `max_submatrix_sum(self) -> int`: This method returns the maximum sum of elements in any submatrix of the matrix. Input * Initialization of the class with two integers indicating the number of rows and columns. * Calls to `add_element` to update the matrix. * Calls to `max_submatrix_sum` to find and return the maximum sum of submatrix. Output * For each call to `max_submatrix_sum`, return an integer representing the maximum sum of any submatrix found in the current state of the matrix. Constraints 1. `1 ≤ rows, cols ≤ 200` 2. `|value| ≤ 10^4` for each addition. 3. `add_element` and `max_submatrix_sum` methods can be called multiple times. Example ```python game = MatrixGame(4, 3) game.add_element(1, 2, 5) game.add_element(0, 1, -3) game.add_element(2, 2, 7) assert game.max_submatrix_sum() == 12 # The submatrix [[0, 0, 0], [0, 0, 5], [0, 0, 7]] has the maximum sum game.add_element(0, 0, 2) assert game.max_submatrix_sum() == 16 # New maximum sum due to updated matrix state ``` Implementation Notes * Utilize dynamic programming to efficiently calculate the maximum submatrix sum. * Consider prefix sums or Kadane\'s algorithm adapted for 2D arrays for efficient calculations. * Ensure the solution works efficiently within the given constraints.","solution":"class MatrixGame: def __init__(self, rows, cols): self.rows = rows self.cols = cols self.matrix = [[0] * cols for _ in range(rows)] def add_element(self, row, col, value): self.matrix[row][col] += value def max_submatrix_sum(self): return self.kadane_2d() def kadane_2d(self): max_sum = -float(\'inf\') for left in range(self.cols): row_sum = [0] * self.rows for right in range(left, self.cols): for i in range(self.rows): row_sum[i] += self.matrix[i][right] max_sum = max(max_sum, self.kadane_1d(row_sum)) return max_sum def kadane_1d(self, arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Coding Assessment Question Context: As part of a scheduling application, you need to manage users\' meeting times. Meetings are defined by their start and end times, and you need to ensure that they do not overlap in a schedule. If two meetings do overlap, you will need to adjust the schedule by removing the minimum number of meetings required to make the remaining schedule conflict-free. Task: Write a function `min_meetings_to_remove(meetings: list[tuple[int, int]]) -> int` that accepts a list of tuples, where each tuple represents a meeting\'s start and end time. Your function should return the minimum number of meetings that need to be removed to ensure that no meetings overlap. Function Signature: ```python def min_meetings_to_remove(meetings: list[tuple[int, int]]) -> int: ``` Input: * A list of tuples `meetings` where each tuple contains two integers representing the start and end times of a meeting. * Example: `[(1, 2), (2, 3), (3, 4), (1, 3)]` Output: * An integer representing the minimum number of meetings that need to be removed to prevent any overlap. * Example: `1` Constraints: * The input list will contain between 1 and 10^5 tuples. * Each tuple will have two integers `0 <= start < end <= 10^5`. Example: ```python meetings = [(1, 2), (2, 3), (3, 4), (1, 3)] assert min_meetings_to_remove(meetings) == 1 meetings = [(1, 2), (1, 2), (1, 2)] assert min_meetings_to_remove(meetings) == 2 ``` Performance Requirements: * The solution should operate within O(n log n) time complexity for sorting and processing the meetings. Summary: Implement the `min_meetings_to_remove` function to efficiently determine the minimum number of meeting removals required for a conflict-free schedule. Address edge cases and ensure that the function scales to large input sizes.","solution":"def min_meetings_to_remove(meetings): Given a list of meetings with start and end times, return the minimum number of meetings that need to be removed to ensure that no meetings overlap. if not meetings: return 0 # First, sort meetings by their end times meetings.sort(key=lambda x: x[1]) # Initialize count of non-overlapping meetings count_non_overlapping = 1 # Track the end time of the last added meeting to the conflict-free set last_end_time = meetings[0][1] for i in range(1, len(meetings)): if meetings[i][0] >= last_end_time: # If the meeting does not overlap with the last added one, include it in the conflict-free set count_non_overlapping += 1 last_end_time = meetings[i][1] # The minimum number of meetings to remove is the total meetings minus the non-overlapping ones return len(meetings) - count_non_overlapping"},{"question":"# Reverse Words in a Sentence Context You have been given the task of manipulating strings in a specific way. The problem is to take a sentence and reverse every word individually but keep the word order intact. A word is defined as a sequence of non-space characters. The input sentence will not contain any leading or trailing spaces, and words will be separated by a single space. Task Write a function `reverse_words(sentence: str) -> str` that takes a sentence as input and returns a new sentence with each word reversed, while preserving the original word order. Example ``` Input: \\"hello world\\" Output: \\"olleh dlrow\\" Explanation: \\"hello\\" becomes \\"olleh\\" and \\"world\\" becomes \\"dlrow\\". Input: \\"coding is fun\\" Output: \\"gnidoc si nuf\\" Explanation: \\"coding\\" becomes \\"gnidoc\\", \\"is\\" becomes \\"si\\", and \\"fun\\" becomes \\"nuf\\". ``` # Constraints - The input `sentence` is a non-empty string and contains only lowercase English letters and spaces. - The length of `sentence` does not exceed 1000 characters.","solution":"def reverse_words(sentence: str) -> str: Takes a sentence and returns a string with each word reversed. :param sentence: a string containing a sentence :return: a string with each word in the sentence reversed words = sentence.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question Scenario: You are developing a feature for a photo editing application that allows users to apply various convolution filters to enhance their images. A convolution filter is a matrix that can be used to blur, sharpen, and detect edges in images. Your task is to implement a function that applies a given convolution filter to a grayscale image. Task: Implement a function that takes a grayscale image and a convolution filter matrix as input, applies the convolution filter to the image, and returns the resulting image as a matrix. Function: ```python def apply_convolution(image: List[List[int]], filter_matrix: List[List[float]]) -> List[List[int]]: Applies the given convolution filter to the grayscale image. Args: image (List[List[int]]): A 2D list representing the grayscale image where each element is a pixel value (0-255). filter_matrix (List[List[float]]): A 2D list representing the convolution filter matrix. Returns: List[List[int]]: A 2D list representing the filtered image. ``` Input: * `image` (List[List[int]]): A 2D array of integers where each integer is a pixel value ranging from 0 to 255. * `filter_matrix` (List[List[float]]): A 2D array of floats representing the convolution filter to be applied. The matrix dimensions are odd (e.g., 3x3, 5x5). Output: * A 2D array of integers representing the filtered image, where each integer is a pixel value ranging from 0 to 255. Constraints: * The dimensions of `image` and `filter_matrix` are both odd. * The image dimensions are at least as large as the filter dimensions. * Pixel values in the resulting image should be clamped to the 0-255 range. Example: ```python # Example grayscale image image = [ [10, 30, 50], [90, 110, 130], [170, 190, 210] ] # Example filter matrix for edge detection filter_matrix = [ [-1, -1, -1], [-1, 8, -1], [-1, -1, -1] ] # Apply the filter to the image filtered_image = apply_convolution(image, filter_matrix) print(filtered_image) # Output should be a 3x3 matrix with the applied convolution filter\'s result, clamped to the 0-255 range. ``` Would result in an edge-detected image matrix, clamped within the 0-255 range as required by typical image processing tasks. A correct implementation will correctly apply the convolution matrix to every pixel while correctly handling the edge cases and clamping values.","solution":"from typing import List def apply_convolution(image: List[List[int]], filter_matrix: List[List[float]]) -> List[List[int]]: height, width = len(image), len(image[0]) filter_size = len(filter_matrix) offset = filter_size // 2 def clamp(value): return max(0, min(255, value)) def apply_filter_at_pixel(row, col): result = 0 for i in range(filter_size): for j in range(filter_size): image_row = row + i - offset image_col = col + j - offset image_value = image[image_row][image_col] filter_value = filter_matrix[i][j] result += image_value * filter_value return clamp(int(result)) filtered_image = [[0] * width for _ in range(height)] for r in range(offset, height - offset): for c in range(offset, width - offset): filtered_image[r][c] = apply_filter_at_pixel(r, c) return filtered_image"},{"question":"# Coding Assessment Question Context You are tasked with implementing a stack data structure, specifically enhancing it to support retrieving the minimum element in O(1) time. This exercise verifies your understanding of stack operations and auxiliary data structures. Task Implement a `MinStack` class that supports the following methods: `push`, `pop`, `top`, and `get_min`. The `get_min` method should retrieve the minimum element in the stack in constant time. Function Specifications ```python class MinStack: def __init__(self): Initializes the stack object. pass def push(self, x: int) -> None: Pushes the element x onto the stack. pass def pop(self) -> None: Removes the element on top of the stack. pass def top(self) -> int: Gets the top element of the stack. pass def get_min(self) -> int: Retrieves the minimum element in the stack. pass ``` Constraints * You must implement the `MinStack` class methods with the following time complexities: * `push`: O(1) * `pop`: O(1) * `top`: O(1) * `get_min`: O(1) * All integer inputs are between -10^5 and 10^5. * The `MinStack` class should support standard stack operations while also allowing retrieval of the minimum element efficiently. Example Usage ```python >>> min_stack = MinStack() >>> min_stack.push(-2) >>> min_stack.push(0) >>> min_stack.push(-3) >>> min_stack.get_min() -3 >>> min_stack.pop() >>> min_stack.top() 0 >>> min_stack.get_min() -2 ``` Additional Information * An auxiliary stack can be used to maintain the minimum values at each stage of the stack\'s evolution.","solution":"class MinStack: def __init__(self): Initializes the stack object. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Pushes the element x onto the stack. self.stack.append(x) # If min_stack is empty or new element is smaller or equal to the top of min_stack if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top_element = self.stack.pop() # If the popped element is the same as the top of min_stack, pop from min_stack if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Gets the top element of the stack. if self.stack: return self.stack[-1] def get_min(self) -> int: Retrieves the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"# Scenario You are working with a simulated stock data generator that creates synthetic stock price sequences to test various financial models. One critical task is to identify significant trends within the generated sequence, particularly the longest increasing subsequence of stock prices. An increasing subsequence is defined as a sequence where each subsequent element is greater than the preceding one. For realistic datasets, the sequences can be quite long, and a naive approach to finding the longest increasing subsequence (LIS) may not be efficient. # Task Your task is to implement an efficient algorithm that finds the length of the longest increasing subsequence in a given list of stock prices. You are required to optimize the solution using dynamic programming with binary search. **Function to Implement**: ```python def length_of_LIS(prices: List[int]) -> int: This function should return the length of the longest increasing subsequence of the given list of stock prices \'prices\'. **Input**: - `prices`: a list of integers representing stock prices over time. **Output**: - An integer representing the length of the longest increasing subsequence in the list of stock prices. **Constraints**: - (1 leq text{len(prices)} leq 10^4) - (1 leq text{prices[i]} leq 10^4) # Steps to Complete 1. Analyze the list of stock prices to determine the longest increasing subsequence. 2. Implement the `length_of_LIS` function using a time complexity of (O(n log n)). 3. Use dynamic programming alongside binary search to optimize the process. **Example Usage**: ```python # Example 1: prices = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(length_of_LIS(prices)) # Output: 6 # Example 2: prices = [3, 10, 2, 1, 20] print(length_of_LIS(prices)) # Output: 3 # Example 3: prices = [3, 2] print(length_of_LIS(prices)) # Output: 1 ``` Explanation for Example 1: - The longest increasing subsequence is [10, 22, 33, 50, 60, 80], which has a length of 6.","solution":"from typing import List import bisect def length_of_LIS(prices: List[int]) -> int: This function returns the length of the longest increasing subsequence of the given list of stock prices \'prices\'. if not prices: return 0 lis = [] for price in prices: pos = bisect.bisect_left(lis, price) if pos < len(lis): lis[pos] = price else: lis.append(price) return len(lis)"},{"question":"# Coding Assessment Question Objective You are tasked with implementing a queue data structure using two stacks. The purpose of this exercise is to demonstrate your understanding of stack and queue concepts and ensure that you can effectively utilize these to simulate a queue through stack operations. Problem Statement Write a Python class `QueueUsingStacks` that simulates a queue using two stacks. Your class should support the following operations: 1. `enqueue(x: int) -> None`: Add an integer `x` to the end of the queue. 2. `dequeue() -> int`: Remove and return the integer from the front of the queue. If the queue is empty, return `-1`. 3. `peek() -> int`: Return the integer at the front of the queue without removing it. If the queue is empty, return `-1`. 4. `is_empty() -> bool`: Return `True` if the queue is empty, otherwise return `False`. # Input * There is no direct input to the class methods; operations are performed sequentially using method calls. # Output * The methods `dequeue()` and `peek()` should return appropriate values as described. # Constraints * You may assume that all operations will be valid, and there will be at most (10^4) operations performed across multiple method calls. # Example ```python class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: if self.is_empty(): return -1 if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> int: if self.is_empty(): return -1 if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not self.stack1 and not self.stack2 # Example Usage queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.is_empty())# Output: False print(queue.dequeue()) # Output: 2 print(queue.is_empty())# Output: True ``` # Requirements 1. Implement the queue functionality strictly using two stacks. 2. Ensure that each method operates efficiently given the constraint of up to (10^4) operations. 3. Properly handle scenarios where operations are performed on an empty queue. 4. Strive for clarity and readability in your implementation to facilitate understanding. Notes: * The enqueue operation should be O(1) in average time complexity. * The dequeue and peek operations should also be efficient, leveraging the secondary stack to minimize the need for repeated operations.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: if self.is_empty(): return -1 if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> int: if self.is_empty(): return -1 if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not self.stack1 and not self.stack2"},{"question":"# Problem Statement Dr. Stack is a researcher working in computational geometry and needs your help to compute the convex hull of a set of points on a 2D plane. The convex hull is the smallest convex polygon that can enclose all the given points. # The context Dr. Stack\'s current project involves analyzing spatial data to determine boundary envelopes. Your task is to implement an algorithm to identify these convex boundaries for sets of points represented by their x and y coordinates. # Function Specification Implement the `convex_hull` function that calculates the convex hull of a set of 2D points. Function Signature ```python def convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Inputs * `points`: A list of tuples, where each tuple contains two integers representing the x and y coordinates of a point. The length of the list is at least 3. Outputs * A list of tuples, representing the vertices of the convex hull in counterclockwise order starting from the vertex with the lowest y-coordinate (and lowest x-coordinate if there are ties). Constraints * Ensure that the input list contains unique tuples. * Assume that there are no duplicate points. # Example ```python points = [(0, 0), (1, 1), (2, 2), (3, 0), (3, 3), (0, 3)] hull = convex_hull(points) print(hull) # Expected output: [(0, 0), (3, 0), (3, 3), (0, 3)] ``` # Hints * Consider using Graham\'s scan or the Monotone chain algorithm to find the convex hull efficiently. * Ensure that you handle edge cases where points are collinear correctly.","solution":"def convex_hull(points): Computes the convex hull of a set of 2D points. Args: points: List[Tuple[int, int]] - a list of tuples representing the points. Returns: List[Tuple[int, int]] - the vertices of the convex hull in counterclockwise order. points = sorted(points) # Sort the points lexicographically (tuples compare like this) # Function to determine if the sequence of points a, b, c makes a counter-clockwise turn def ccw(a, b, c): return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]) > 0 # Build the lower hull lower = [] for p in points: while len(lower) >= 2 and not ccw(lower[-2], lower[-1], p): lower.pop() lower.append(p) # Build the upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and not ccw(upper[-2], upper[-1], p): upper.pop() upper.append(p) # Remove the last point of each half because they are repeated at the beginning of the other half return lower[:-1] + upper[:-1]"},{"question":"**Title**: Palindrome Substring Search **Context**: You are asked to implement functions to identify and utilize palindromic substrings within strings. Palindromes are strings that read the same forwards and backwards, and they are significant in fields like computational biology, data encryption, and text processing. **Task**: Implement two functions: `is_palindrome` and `longest_palindrome_substring`. # 1. Palindrome Checker **Function**: `is_palindrome(s: str) -> bool` **Description**: Write a function to check if a given string is a palindrome. **Input**: - `s`: A string of alphanumeric characters (case-insensitive). **Output**: - A boolean value indicating whether the string `s` is a palindrome. # 2. Longest Palindromic Substring **Function**: `longest_palindrome_substring(s: str) -> str` **Description**: Write a function to find the longest palindromic substring in a given string. **Input**: - `s`: A string of alphanumeric characters (case-insensitive). **Output**: - A string representing the longest palindromic substring in `s`. # Requirements and Constraints: 1. The implementation should be case-insensitive (e.g., \\"Aba\\" is considered a palindrome). 2. If there are multiple palindromic substrings of the longest length, return the one that appears first. 3. The solution should efficiently handle strings of length up to 1000 characters. **Example Cases**: **Case 1**: ```python assert is_palindrome(\\"Aba\\") == True assert is_palindrome(\\"abcd\\") == False ``` **Case 2**: ```python assert longest_palindrome_substring(\\"babad\\") == \\"bab\\" # \\"aba\\" is also correct assert longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" ``` Make sure to handle edge cases, such as single-character strings and strings without any palindromes longer than one character. Your implementation should focus on efficiency and clarity.","solution":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. The function is case-insensitive. cleaned_s = s.lower() return cleaned_s == cleaned_s[::-1] def longest_palindrome_substring(s: str) -> str: Finds the longest palindromic substring in a given string. The function is case-insensitive. if len(s) == 0: return \\"\\" def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left].lower() == s[right].lower(): left -= 1 right += 1 return s[left + 1:right] longest_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes single_center_palindrome = expand_around_center(i, i) if len(single_center_palindrome) > len(longest_palindrome): longest_palindrome = single_center_palindrome # Even length palindromes double_center_palindrome = expand_around_center(i, i + 1) if len(double_center_palindrome) > len(longest_palindrome): longest_palindrome = double_center_palindrome return longest_palindrome"},{"question":"# Coding Assessment Question: Implement Principal Component Analysis (PCA) Your task is to implement a Principal Component Analysis (PCA) based dimensionality reduction model. The model must be capable of processing a given dataset, identifying the principal components, and transforming the dataset to a lower-dimensional space using these components. Task Requirements: 1. **Function 1**: Standardize the dataset. - **Function Name**: `standardize_data` - **Input**: List of data points (`list of list of float`) - **Output**: Standardized dataset (`list of list of float`). 2. **Function 2**: Calculate the covariance matrix of the dataset. - **Function Name**: `covariance_matrix` - **Input**: Standardized dataset (`list of list of float`) - **Output**: Covariance matrix (`list of list of float`). 3. **Function 3**: Perform eigendecomposition on the covariance matrix. - **Function Name**: `eigendecomposition` - **Input**: Covariance matrix (`list of list of float`) - **Output**: List of eigenvalues (`list of float`), List of eigenvectors (`list of list of float`). 4. **Function 4**: Sort the eigenvalues and eigenvectors in descending order. - **Function Name**: `sort_eigenvalues_eigenvectors` - **Input**: List of eigenvalues (`list of float`), List of eigenvectors (`list of list of float`) - **Output**: Sorted eigenvalues (`list of float`), Sorted eigenvectors (`list of list of float`). 5. **Function 5**: Select the top k eigenvectors. - **Function Name**: `select_top_k_components` - **Input**: Sorted eigenvectors (`list of list of float`), Number of components to select (`int`) - **Output**: Top k eigenvectors (`list of list of float`). 6. **Function 6**: Transform the dataset to the lower-dimensional space. - **Function Name**: `transform_data` - **Input**: Standardized dataset (`list of list of float`), Top k eigenvectors (`list of list of float`) - **Output**: Transformed dataset (`list of list of float`). 7. **Function 7**: Evaluate the explained variance ratio of the selected components. - **Function Name**: `explained_variance_ratio` - **Input**: List of eigenvalues (`list of float`), Number of components to select (`int`) - **Output**: Explained variance ratio (`list of float`). Constraints: 1. Assume input data is numeric and contains no missing values. 2. Implement error handling for invalid inputs. 3. Optimize your solution for readability and performance. Example: ```python # Example 1. Standardizing the dataset standardized_data = standardize_data(data=[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]) # Example 2. Calculating the covariance matrix cov_matrix = covariance_matrix(standardized_data) # Example 3. Performing eigendecomposition eigenvalues, eigenvectors = eigendecomposition(cov_matrix) # Example 4. Sorting eigenvalues and eigenvectors sorted_eigenvalues, sorted_eigenvectors = sort_eigenvalues_eigenvectors(eigenvalues, eigenvectors) # Example 5. Selecting top k eigenvectors top_k_components = select_top_k_components(sorted_eigenvectors, k=1) # Example 6. Transforming the dataset transformed_data = transform_data(standardized_data, top_k_components) # Example 7. Calculating explained variance ratio explained_variance = explained_variance_ratio(eigenvalues, k=1) ``` You are allowed to use any standard libraries in Python to accomplish your task.","solution":"import numpy as np def standardize_data(data): Standardizes the dataset. Params: - data (list of list of float): Input dataset. Returns: - standardized_data (list of list of float): Standardized dataset. data = np.array(data) mean = np.mean(data, axis=0) std_dev = np.std(data, axis=0) standardized_data = (data - mean) / std_dev return standardized_data.tolist() def covariance_matrix(data): Calculates the covariance matrix of the dataset. Params: - data (list of list of float): Standardized dataset. Returns: - cov_matrix (list of list of float): Covariance matrix. data = np.array(data) cov_matrix = np.cov(data, rowvar=False) return cov_matrix.tolist() def eigendecomposition(cov_matrix): Performs eigendecomposition on the covariance matrix. Params: - cov_matrix (list of list of float): Covariance matrix. Returns: - eigenvalues (list of float): List of eigenvalues. - eigenvectors (list of list of float): List of eigenvectors. cov_matrix = np.array(cov_matrix) eigenvalues, eigenvectors = np.linalg.eig(cov_matrix) return eigenvalues.tolist(), eigenvectors.tolist() def sort_eigenvalues_eigenvectors(eigenvalues, eigenvectors): Sort the eigenvalues and corresponding eigenvectors in descending order. Params: - eigenvalues (list of float): List of eigenvalues. - eigenvectors (list of list of float): List of eigenvectors. Returns: - sorted_eigenvalues (list of float): Sorted eigenvalues. - sorted_eigenvectors (list of list of float): Sorted eigenvectors. idx = np.argsort(eigenvalues)[::-1] sorted_eigenvalues = np.array(eigenvalues)[idx] sorted_eigenvectors = np.array(eigenvectors)[:, idx] return sorted_eigenvalues.tolist(), sorted_eigenvectors.tolist() def select_top_k_components(sorted_eigenvectors, k): Select the top k eigenvectors. Params: - sorted_eigenvectors (list of list of float): Sorted eigenvectors. - k (int): Number of components to select. Returns: - top_k_eigenvectors (list of list of float): Top k eigenvectors. return np.array(sorted_eigenvectors)[:, :k].tolist() def transform_data(data, top_k_eigenvectors): Transform the dataset to the lower-dimensional space. Params: - data (list of list of float): Standardized dataset. - top_k_eigenvectors (list of list of float): Top k eigenvectors. Returns: - transformed_data (list of list of float): Transformed dataset. data = np.array(data) top_k_eigenvectors = np.array(top_k_eigenvectors) transformed_data = np.dot(data, top_k_eigenvectors) return transformed_data.tolist() def explained_variance_ratio(eigenvalues, k): Evaluate the explained variance ratio of the selected components. Params: - eigenvalues (list of float): List of eigenvalues. - k (int): Number of components to select. Returns: - explained_variance (list of float): Explained variance ratio. total_variance = sum(eigenvalues) explained_variance = [(eig / total_variance) for eig in eigenvalues[:k]] return explained_variance"},{"question":"# Palindrome Date Finder Given a range of dates, find all the dates within that range that are palindromic when written in the format `YYYYMMDD`. A date is considered palindromic if it reads the same backward as forward. **Problem Statement**: Write a function `find_palindrome_dates(start_date: str, end_date: str) -> list` which takes two dates in the format `YYYYMMDD` and returns a list of strings representing the palindromic dates in the same `YYYYMMDD` format within the given range. **Input**: - `start_date` (str): The starting date in the format `YYYYMMDD`, e.g., \'20230101\' for January 1st, 2023. - `end_date` (str): The ending date in the format `YYYYMMDD`, e.g., \'20231231\' for December 31st, 2023. **Output**: - A list of strings where each string is a date in the `YYYYMMDD` format and is palindromic. **Constraints**: - The `start_date` will always be less than or equal to the `end_date`. - Both `start_date` and `end_date` will be valid dates within the Gregorian calendar system. ```python from datetime import datetime, timedelta def is_palindrome(date_str: str) -> bool: Check if the given date string is a palindrome. return date_str == date_str[::-1] def find_palindrome_dates(start_date: str, end_date: str) -> list: Find all palindromic dates between the given start and end dates (inclusive). Parameters: - start_date (str): The starting date in \'YYYYMMDD\' format. - end_date (str): The ending date in \'YYYYMMDD\' format. Returns: - list of palindromic dates in \'YYYYMMDD\' format. palindromic_dates = [] current_date = datetime.strptime(start_date, \'%Y%m%d\') end_date_obj = datetime.strptime(end_date, \'%Y%m%d\') while current_date <= end_date_obj: date_str = current_date.strftime(\'%Y%m%d\') if is_palindrome(date_str): palindromic_dates.append(date_str) current_date += timedelta(days=1) return palindromic_dates # Example Usage: if __name__ == \\"__main__\\": start_date = \\"20230101\\" end_date = \\"20231231\\" print(find_palindrome_dates(start_date, end_date)) ``` **Note**: Make sure to handle edge cases like end of month and leap years in your implementation.","solution":"from datetime import datetime, timedelta def is_palindrome(date_str: str) -> bool: Check if the given date string is a palindrome. return date_str == date_str[::-1] def find_palindrome_dates(start_date: str, end_date: str) -> list: Find all palindromic dates between the given start and end dates (inclusive). Parameters: - start_date (str): The starting date in \'YYYYMMDD\' format. - end_date (str): The ending date in \'YYYYMMDD\' format. Returns: - list of palindromic dates in \'YYYYMMDD\' format. palindromic_dates = [] current_date = datetime.strptime(start_date, \'%Y%m%d\') end_date_obj = datetime.strptime(end_date, \'%Y%m%d\') while current_date <= end_date_obj: date_str = current_date.strftime(\'%Y%m%d\') if is_palindrome(date_str): palindromic_dates.append(date_str) current_date += timedelta(days=1) return palindromic_dates"},{"question":"# Problem: Matrix Diagonal Sum Context: You are working with square matrices in a computational mathematics project. You need to quickly compute the sum of the elements on the matrix\'s main diagonal and its anti-diagonal for further statistical analysis. Implement a function that efficiently calculates these sums while considering overlapping centers in odd-dimension matrices. Function Signature: ```python def diagonal_sums(matrix: list[list[int | float]]) -> tuple[int | float, int | float]: ``` Description: Implement a function `diagonal_sums` that calculates the sum of the main diagonal and the anti-diagonal for a given square matrix. The matrix is given as a list of lists, where each inner list represents a row of the matrix. Input: * `matrix`: A list of lists of integers or floats representing an `n x n` square matrix (where `n` is the number of rows and columns). Output: * Returns a tuple with two elements: 1. The sum of the main diagonal. 2. The sum of the anti-diagonal. In case of odd-dimension matrices where the center element overlaps in both diagonals, it should only be counted once in the sums. Constraints: * The matrix will always be square with dimensions `n x n` where `0 <= n <= 1000`. * The elements within the matrix are integers or floating-point numbers. * The matrix can be empty (i.e., `n = 0`), in which case both sums should be `0`. Examples: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert diagonal_sums(matrix1) == (15, 15) matrix2 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert diagonal_sums(matrix2) == (34, 34) matrix3 = [ [1, 2], [3, 4] ] assert diagonal_sums(matrix3) == (5, 5) matrix4 = [[1]] assert diagonal_sums(matrix4) == (1, 1) matrix5 = [] assert diagonal_sums(matrix5) == (0, 0) ``` Requirements: Ensure the function efficiently computes the diagonal sums even for large matrices and correctly handles edge cases such as empty matrices and integer or floating-point elements.","solution":"def diagonal_sums(matrix): n = len(matrix) if n == 0: return (0, 0) main_diagonal_sum = 0 anti_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] anti_diagonal_sum += matrix[i][n - 1 - i] return (main_diagonal_sum, anti_diagonal_sum)"},{"question":"Implementing a Simple Tic-Tac-Toe Game Validator **Scenario**: You are developing an online gaming platform, and one of the features is a simple Tic-Tac-Toe game. After a game is played on a 3x3 board, you need to validate the result to determine if there\'s a winner or if the game is a draw. **Task**: Write a function `validate_tic_tac_toe(board)` that checks the given Tic-Tac-Toe board to determine the result of the game. The function should return \'X\' if player X has won, \'O\' if player O has won, or \'Draw\' if neither player has won and no empty cells remain. **Function Signature**: ```python def validate_tic_tac_toe(board: List[List[str]]) -> str: ``` **Input**: * `board`: A 3x3 list of lists representing the Tic-Tac-Toe board, where each cell contains \'X\', \'O\', or \'\' (empty). **Output**: * A string that is either \'X\', \'O\', or \'Draw\' based on the board\'s status. **Constraints**: * The board will always be a 3x3 list of lists. * Each cell in the board will contain either \'X\', \'O\', or \'\'. **Example**: ```python print(validate_tic_tac_toe([ [\'X\', \'X\', \'X\'], [\'O\', \'O\', \'\'], [\'\', \'\', \'O\'] ])) # Expected output: \'X\' print(validate_tic_tac_toe([ [\'X\', \'O\', \'X\'], [\'O\', \'O\', \'X\'], [\'X\', \'X\', \'O\'] ])) # Expected output: \'Draw\' print(validate_tic_tac_toe([ [\'O\', \'O\', \'O\'], [\'X\', \'\', \'X\'], [\'\', \'X\', \'\'] ])) # Expected output: \'O\' print(validate_tic_tac_toe([ [\'O\', \'X\', \'X\'], [\'O\', \'O\', \'X\'], [\'X\', \'O\', \'\'] ])) # Expected output: \'O\' ``` **Notes**: - If both players have a winning line on the board, validate the board\'s status based on the first player who satisfies the winning condition from left to right and top to bottom.","solution":"from typing import List def validate_tic_tac_toe(board: List[List[str]]) -> str: def check_winner(player: str) -> bool: for i in range(3): # Check rows and columns if all([cell == player for cell in board[i]]) or all([board[j][i] == player for j in range(3)]): return True # Check diagonals if all([board[i][i] == player for i in range(3)]) or all([board[i][2 - i] == player for i in range(3)]): return True return False if check_winner(\'X\'): return \'X\' if check_winner(\'O\'): return \'O\' # Check if draw (no empty spots left) if all([cell != \'\' for row in board for cell in row]): return \'Draw\' return \'\'"},{"question":"# Problem Description You are tasked with creating a function that determines the profitability of harvesting a crop based on given price conditions and harvesting costs. The function must evaluate if the selling price is greater than the sum of all costs. The function should also validate inputs to ensure they are numeric. If any input is non-numeric, the function should raise a `TypeError`. # Function Signature ```python def is_profitable( selling_price: float, harvesting_cost: float, transportation_cost: float, storage_cost: float ) -> bool: pass ``` # Input * **selling_price** (float): A float number representing the price per unit of the crop. * **harvesting_cost** (float): A float number representing the cost per unit to harvest the crop. * **transportation_cost** (float): A float number representing the cost per unit to transport the crop. * **storage_cost** (float): A float number representing the cost per unit to store the crop. # Output * **profitable** (bool): Returns `True` if selling price is greater than the total costs, otherwise `False`. # Constraints * All input parameters must be numeric. * If any parameter is non-numeric, the function should raise a `TypeError`. # Examples ```python >>> is_profitable(10, 3, 2, 1) True >>> is_profitable(5, 1, 2, 3) False >>> is_profitable(15, 5, 5, 5) False >>> is_profitable(10, \\"3\\", 2, 1) Traceback (most recent call last): ... TypeError: All parameters must be numeric. ``` # Note - You may assume the input values are always provided in correct units and relations. - Ensure your function passes the provided examples and edge cases for validation.","solution":"def is_profitable(selling_price, harvesting_cost, transportation_cost, storage_cost): Determines if selling the crop is profitable based on given price conditions and costs. Args: selling_price (float): Price per unit of the crop. harvesting_cost (float): Cost per unit to harvest the crop. transportation_cost (float): Cost per unit to transport the crop. storage_cost (float): Cost per unit to store the crop. Returns: bool: True if the selling_price is greater than the sum of all costs, otherwise False. Raises: TypeError: If any of the inputs is not numeric. if not all(isinstance(x, (int, float)) for x in [selling_price, harvesting_cost, transportation_cost, storage_cost]): raise TypeError(\\"All parameters must be numeric.\\") total_cost = harvesting_cost + transportation_cost + storage_cost return selling_price > total_cost"},{"question":"# Matrix SpiraI Sum Given a matrix of integers, you are to compute the sum of the elements in a spiral order, starting from the top-left corner and moving clockwise. The matrix dimensions are given as M rows and N columns, where 1 ≤ M, N ≤ 1000. # Problem Statement Write a function `spiral_sum(matrix: List[List[int]]) -> int` that computes the sum of matrix elements traversed in a spiral manner. # Requirements Your function should handle large matrices efficiently and return the correct sum even for the maximum input sizes. # Input * A 2D list `matrix` of integers where the dimensions are between 1 x 1 and 1000 x 1000. # Output * An integer representing the sum of matrix elements in spiral order. # Constraints * The matrix dimensions (M and N) will always be valid integers within the specified range. * All elements in the matrix are guaranteed to be integers. # Performance Requirements * Your implementation should be efficient and complete within a reasonable time for matrices up to the maximum size of 1000 x 1000. # Scenario/Context Traversing a matrix in spiral order is a common problem often used to test the understanding of array manipulation and traversal techniques. It can also help in visualizing complex data structures and their orderly access patterns. # Example ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] sum_spiral = spiral_sum(matrix) print(sum_spiral) # Output should be 136 ``` In this example, the traversal order would be: 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10, and the sum of these numbers is 136.","solution":"from typing import List def spiral_sum(matrix: List[List[int]]) -> int: if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) left, right, top, bottom = 0, cols - 1, 0, rows - 1 spiral_sum = 0 while left <= right and top <= bottom: for col in range(left, right + 1): spiral_sum += matrix[top][col] top += 1 for row in range(top, bottom + 1): spiral_sum += matrix[row][right] right -= 1 if top <= bottom: for col in range(right, left - 1, -1): spiral_sum += matrix[bottom][col] bottom -= 1 if left <= right: for row in range(bottom, top - 1, -1): spiral_sum += matrix[row][left] left += 1 return spiral_sum"},{"question":"# Implementing a Recursive Binary Search You are tasked with implementing a recursive binary search function in Python. This function should take a sorted list and a target value, returning the index of the target value within the list, or `-1` if the target does not exist in the list. Function Signature ```python def recursive_binary_search(sorted_list: list, target: int, left: int = 0, right: int = None) -> int: ``` Parameters: - `sorted_list` (list): A list of integers sorted in ascending order. - `target` (int): The integer value to search for within the list. - `left` (int, optional): The left boundary of the search interval. Defaults to 0. - `right` (int, optional): The right boundary of the search interval. Defaults to `None`, which should be interpreted as `len(sorted_list) - 1`. Returns: - `int`: The index of the target within the list if found, otherwise `-1`. # Requirements: 1. If `right` is `None` at the initial call, set it to the length of the list minus one. 2. Perform a recursive binary search using the middle element of the interval. 3. Ensure the function returns the correct index of the target if found. 4. Handle the case where the target is not found by returning `-1`. # Constraints: - Input list length: ( 1 le text{len(sorted_list)} le 10^5 ) - Values in the sorted list and target: ( -10^9 le text{target}, text{value in sorted_list} le 10^9 ) # Example Usage: ```python sorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(recursive_binary_search(sorted_list, 5)) # 4 print(recursive_binary_search(sorted_list, 1)) # 0 print(recursive_binary_search(sorted_list, 10)) # 9 print(recursive_binary_search(sorted_list, -5)) # -1 print(recursive_binary_search(sorted_list, 11)) # -1 ``` Implement the `recursive_binary_search` function and ensure it passes the provided test cases.","solution":"def recursive_binary_search(sorted_list: list, target: int, left: int = 0, right: int = None) -> int: if right is None: right = len(sorted_list) - 1 if left > right: return -1 middle = (left + right) // 2 if sorted_list[middle] == target: return middle elif sorted_list[middle] < target: return recursive_binary_search(sorted_list, target, middle + 1, right) else: return recursive_binary_search(sorted_list, target, left, middle - 1)"},{"question":"# Coding Question: Neighboring Palindrome Numbers Context A number is considered a palindrome if it reads the same backward as forward. For example, 121 and 1221 are palindromes, whereas 123 is not. Given any integer `n`, its neighboring palindromes are defined as the closest palindromic numbers that are smaller and larger than `n`. Objective You are tasked with writing a function that computes the closest smaller and larger palindromes for a given number `n`. Function Signature ```python def find_neighboring_palindromes(n: int) -> (int, int): pass ``` Input - `n` (int): A positive integer (1 ≤ n ≤ 1,000,000,000). Output - Returns a tuple of two integers: - The largest palindrome less than `n`. - The smallest palindrome greater than `n`. Constraints - Ensure accurate results within the given constraints. - Optimize for both time and space complexity to handle large values of `n`. Example - `find_neighboring_palindromes(123)` should return `(121, 131)`. - `find_neighboring_palindromes(10)` should return `(9, 11)`. Additional Notes - Ensure edge cases such as single-digit numbers and large palindromic intervals are accounted for. - Validate the algorithm\'s performance with varying values of `n`.","solution":"def is_palindrome(num: int) -> bool: return str(num) == str(num)[::-1] def find_neighboring_palindromes(n: int) -> (int, int): smaller, larger = n - 1, n + 1 while not is_palindrome(smaller): smaller -= 1 while not is_palindrome(larger): larger += 1 return (smaller, larger) # Example usage # find_neighboring_palindromes(123) should return (121, 131). # find_neighboring_palindromes(10) should return (9, 11)."},{"question":"# Question: You are implementing a simplified text editing program with two primary operations: inserting text at a specified position and reversing a portion of the text within given range indices. Task: 1. **Function 1: `insert_text(original: str, text: str, index: int) -> str`** - Input: - `original`: A string representing the original text. - `text`: A string representing the text to be inserted. - `index`: An integer representing the position at which the text should be inserted. - Output: - A new string with `text` inserted into `original` at the specified `index`. - Implementation details: - Ensure that inserting at an index beyond the length of the original string appends the text at the end. - Handle the case where the index is negative by considering it from the end of the string. 2. **Function 2: `reverse_substring(text: str, start: int, end: int) -> str`** - Input: - `text`: A string representing the text to be modified. - `start`: An integer representing the starting index of the substring to be reversed. - `end`: An integer representing the ending index of the substring to be reversed (inclusive). - Output: - A new string with the substring from `start` to `end` reversed. - Implementation details: - Ensure that valid indices are provided; if not, handle gracefully. - Consider the inclusive behavior of the `end` index. - Ensure function works correctly even with an empty string or if start is equal to end. Examples: - Insert Text: ```python insert_text(\\"hello world\\", \\"beautiful \\", 6) # Output: \\"hello beautiful world\\" insert_text(\\"abc\\", \\"xyz\\", 10) # Output: \\"abcxyz\\" insert_text(\\"abc\\", \\"xyz\\", -1) # Output: \\"abxyzc\\" ``` - Reverse Substring: ```python reverse_substring(\\"hello world\\", 0, 4) # Output: \\"olleh world\\" reverse_substring(\\"abcde\\", 1, 3) # Output: \\"adcbe\\" reverse_substring(\\"abc\\", 0, 1) # Output: \\"bac\\" reverse_substring(\\"one\\", 0, 2) # Output: \\"eno\\" ``` Ensure your solution handles edge cases, such as large indices, negative indices, empty strings, and properly types the indices.","solution":"def insert_text(original: str, text: str, index: int) -> str: Inserts the given text into the original string at the specified index. if index < 0: index = len(original) + index if index > len(original): index = len(original) return original[:index] + text + original[index:] def reverse_substring(text: str, start: int, end: int) -> str: Reverses the portion of the text from start index to end index (inclusive). if start < 0: start = 0 if end >= len(text): end = len(text) - 1 if start > end: return text return text[:start] + text[start:end+1][::-1] + text[end+1:]"},{"question":"# Context: In data processing and analysis, it\'s common to encounter situations where you need to compress sequences of data by grouping identical elements. RLE (Run Length Encoding) is a simple and effective compression method for sequences with repeating elements. Understanding how to implement such algorithms is crucial for tasks involving data compression and optimization. # Problem Statement: You need to compress a given string using Run Length Encoding (RLE). Write a function `run_length_encoding` that receives a string and returns its RLE-compressed form. The compressed form should consist of characters from the original string followed by the count of consecutive repetitions. # Function Signature: ```python def run_length_encoding(data: str) -> str: ``` # Input: - `data`: a `str` consisting of uppercase and lowercase English letters (a-z, A-Z) and/or digits (0-9). # Output: - Returns a `str` representing the RLE-compressed form of the input string. # Constraints: - The input string will have a length between 1 and 1000. - If a character occurs more than 9 times consecutively, continue compressing in the same format (e.g., \\"aaaaaaaaaaa\\" -> \\"a9a2\\"). # Example: ```python >>> run_length_encoding(\\"aaabbcaaa\\") \'a3b2c1a3\' >>> run_length_encoding(\\"a\\") \'a1\' >>> run_length_encoding(\\"aabbcc\\") \'a2b2c2\' >>> run_length_encoding(\\"aaaaaaaaaaa\\") \'a9a2\' >>> run_length_encoding(\\"xyz\\") \'x1y1z1\' ``` # Additional Information: To help with your implementation, consider the following approach: 1. Traverse the input string and initialize a counter to keep track of the number of consecutive characters. 2. Whenever you encounter a different character from the previous one, append the character and the count to the result string. 3. Reset the counter and continue traversing until the end of the string. Make sure to handle edge cases, such as an input string with a single character or characters appearing more than 9 times consecutively.","solution":"def run_length_encoding(data: str) -> str: if not data: return \\"\\" result = [] current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 if count == 10: result.append(f\\"{current_char}9\\") count = 1 else: result.append(f\\"{current_char}{count}\\") current_char = char count = 1 result.append(f\\"{current_char}{count}\\") return \\"\\".join(result)"},{"question":"String Transformation Utility In various software development scenarios, it\'s often useful to perform transformations on strings, such as changing their case, reversing them, or removing duplicate characters. Your task is to implement a class `StringTransform` with the following methods to perform such operations efficiently: 1. **to_uppercase(s: str) -> str**: Convert the entire string `s` to uppercase. 2. **to_lowercase(s: str) -> str**: Convert the entire string `s` to lowercase. 3. **reverse_string(s: str) -> str**: Reverse the string `s`. 4. **remove_duplicate_characters(s: str) -> str**: Remove all duplicate characters from the string `s`, preserving the first occurrence and maintaining the original order of characters. 5. **is_palindrome(s: str) -> bool**: Check if the string `s` is a palindrome (a string that reads the same backward as forward). # Requirements: * The input `s` will be a non-empty string. * The methods should handle both uppercase and lowercase letters appropriately. * When comparing characters for duplicates or palindromes, consider the comparison to be case-sensitive. * Your implementation should be optimized for performance, especially considering the operations like removing duplicates and checking for palindromes. # Example: ```python class StringTransform: @staticmethod def to_uppercase(s: str) -> str: # Implement this method pass @staticmethod def to_lowercase(s: str) -> str: # Implement this method pass @staticmethod def reverse_string(s: str) -> str: # Implement this method pass @staticmethod def remove_duplicate_characters(s: str) -> str: # Implement this method pass @staticmethod def is_palindrome(s: str) -> bool: # Implement this method pass # Example Usage: assert StringTransform.to_uppercase(\\"Hello World\\") == \\"HELLO WORLD\\" assert StringTransform.to_lowercase(\\"Hello World\\") == \\"hello world\\" assert StringTransform.reverse_string(\\"Hello World\\") == \\"dlroW olleH\\" assert StringTransform.remove_duplicate_characters(\\"banana\\") == \\"ban\\" assert StringTransform.is_palindrome(\\"racecar\\") == True assert StringTransform.is_palindrome(\\"hello\\") == False ``` Implement the class `StringTransform` with the specified methods using efficient string manipulation techniques.","solution":"class StringTransform: @staticmethod def to_uppercase(s: str) -> str: return s.upper() @staticmethod def to_lowercase(s: str) -> str: return s.lower() @staticmethod def reverse_string(s: str) -> str: return s[::-1] @staticmethod def remove_duplicate_characters(s: str) -> str: seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result) @staticmethod def is_palindrome(s: str) -> bool: return s == s[::-1]"},{"question":"# Coding Assessment Question Scenario You are developing a library management system, and your current task involves organizing a collection of books in an efficient manner. One of the primary features is to ensure that books are sorted based on their publication years and authors\' last names. Task 1. **Function Implementation**: Implement a function `sort_books` that sorts a list of book objects first by publication year in ascending order, and then by author\'s last name in alphabetical order. 2. **Detailed Steps**: - Define the function `sort_books(books: List[Book]) -> List[Book]`. - The `Book` class is provided with attributes: ```python class Book: def __init__(self, title: str, author: str, publication_year: int): self.title = title self.author = author self.publication_year = publication_year ``` 3. **Requirements**: * The function should return a new list of books sorted as specified. * Use stable sorting to maintain relative order where necessary. 4. **Example**: ```python >>> book1 = Book(\\"Book A\\", \\"Smith\\", 2001) >>> book2 = Book(\\"Book B\\", \\"Johnson\\", 1999) >>> book3 = Book(\\"Book C\\", \\"Smith\\", 1999) >>> books = [book1, book2, book3] >>> sorted_books = sort_books(books) >>> [(book.title, book.author, book.publication_year) for book in sorted_books] [(\'Book B\', \'Johnson\', 1999), (\'Book C\', \'Smith\', 1999), (\'Book A\', \'Smith\', 2001)] ``` Constraints * **Input**: - The list will contain at least one book. - Authors\' names will be given in the format \\"Last name, First name\\". * **Expected Output**: - A new list of `Book` objects sorted by the specified criteria. Performance Requirements * The operations should run in O(n log n) time where n is the number of books. * The space complexity should be O(n) due to the auxiliary space required for sorting.","solution":"from typing import List class Book: def __init__(self, title: str, author: str, publication_year: int): self.title = title self.author = author self.publication_year = publication_year def sort_books(books: List[Book]) -> List[Book]: return sorted(books, key=lambda book: (book.publication_year, book.author.split(\\", \\")[0]))"},{"question":"# Restore Balance of a Binary Search Tree You are given a Binary Search Tree (BST) where the balance might be disrupted. Write a function `restore_balance(root)` that converts the given BST into a balanced BST and returns the root of the new balanced BST. Input * `root` is the root node of the BST. Each node has the structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * Return the root node of the balanced BST. Constraints * The tree will contain at least 0 and at most 10^4 nodes. * The values of the nodes are distinct integers. Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def restore_balance(root): # Function implementation here pass root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) balanced_root = restore_balance(root) assert balanced_root.val == 2 assert balanced_root.left.val == 1 assert balanced_root.right.val == 3 assert balanced_root.right.right.val == 4 ``` **Explanation**: The given BST was skewed to the right. Once balanced, the returned BST has a more balanced structure with root value 2.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def restore_balance(root): # Helper function to perform in-order traversal and collect the values def inorder_traversal(node, sorted_list): if node is not None: inorder_traversal(node.left, sorted_list) sorted_list.append(node.val) inorder_traversal(node.right, sorted_list) # Helper function to build a balanced BST from a sorted list def build_balanced_bst(sorted_list): if not sorted_list: return None mid = len(sorted_list) // 2 node = TreeNode(sorted_list[mid]) node.left = build_balanced_bst(sorted_list[:mid]) node.right = build_balanced_bst(sorted_list[mid+1:]) return node # Get the sorted list of values from in-order traversal of the original BST sorted_values = [] inorder_traversal(root, sorted_values) # Build and return the balanced BST from the sorted values return build_balanced_bst(sorted_values)"},{"question":"# Sum of Array with Excluded Elements Scenario A company that offers online coding assessments for job candidates wants to create a problem that tests a candidate\'s ability to manipulate arrays and practice fundamental programming skills simultaneously. Task You need to implement a function `sum_excluding_elements(arr: List[int], exclude: List[int]) -> int` that computes the sum of all elements in the input array, excluding the specified elements. Implementation Details * Your function should take two lists as input: `arr` and `exclude`. * `arr` is the main list containing the elements you need to sum. * `exclude` is a list of elements that should not be included in the sum. * The function should return the sum of elements in `arr`, excluding those present in `exclude`. Constraints * You may assume that `arr` and `exclude` contain only integers. * Each list can contain up to (10^5) elements. * The elements in `arr` may contain duplicates, but elements in `exclude` are unique. Example ```python >>> sum_excluding_elements([2, 1, 4, 5, 2, 4], [2, 4]) 6 >>> sum_excluding_elements([0, 3, 1, 0, 1], [0, 1]) 3 >>> sum_excluding_elements([5, 8, 13, 3], []) 29 >>> sum_excluding_elements([7, 5, 7, 10], [7]) 15 ``` Notes * Elements in `exclude` that aren\'t in `arr` can be ignored. * Ensure the function is optimized to handle large input sizes efficiently.","solution":"from typing import List def sum_excluding_elements(arr: List[int], exclude: List[int]) -> int: Returns the sum of all elements in `arr` excluding those present in `exclude`. Parameters: - arr (List[int]): The list of elements to sum. - exclude (List[int]): The list of elements to exclude from the sum. Returns: int: The sum of elements in `arr` excluding those in `exclude`. exclude_set = set(exclude) # Convert exclude list to set for O(1) lookups return sum(x for x in arr if x not in exclude_set)"},{"question":"# Expense Tracker Application Scenario Develop a simplified expense tracker application that records daily expenses under various categories. The goal is to keep track of how much has been spent in each category on any given day and provide a total expense for that day. Task You are required to implement the functions for tracking daily expenses and retrieving daily and category-wise totals. Function Signature ```python class ExpenseTracker: def __init__(self) -> None: pass def add_expense(self, date: str, category: str, amount: float) -> None: pass def get_daily_total(self, date: str) -> float: pass def get_category_total(self, date: str, category: str) -> float: pass ``` Requirements 1. **Initialization**: Set up an empty expense tracker. 2. **Add Expense**: Record an expense for a given date and category. * `date` is in the format \'YYYY-MM-DD\'. * `category` is a string representing the category (e.g., \'groceries\', \'transport\', etc.). * `amount` is a float representing the expense amount. 3. **Get Daily Total**: Retrieve the total expense for a given date. 4. **Get Category Total**: Retrieve the total expense for a given category on a specific date. Constraints * A date string will always be in \'YYYY-MM-DD\' format. * `amount` will be a non-negative float value. * Operations should allow retrieval of daily and category expenses in O(1) average time complexity. Examples ```python # Example 1 tracker = ExpenseTracker() tracker.add_expense(\\"2023-10-01\\", \\"groceries\\", 50.25) tracker.add_expense(\\"2023-10-01\\", \\"transport\\", 15.75) tracker.add_expense(\\"2023-10-01\\", \\"groceries\\", 20.50) tracker.add_expense(\\"2023-10-02\\", \\"groceries\\", 30.00) print(tracker.get_daily_total(\\"2023-10-01\\")) # Output: 86.50 print(tracker.get_category_total(\\"2023-10-01\\", \\"groceries\\")) # Output: 70.75 print(tracker.get_daily_total(\\"2023-10-02\\")) # Output: 30.00 print(tracker.get_category_total(\\"2023-10-02\\", \\"groceries\\")) # Output: 30.00 # Example 2 tracker = ExpenseTracker() tracker.add_expense(\\"2023-11-15\\", \\"utilities\\", 120.00) tracker.add_expense(\\"2023-11-15\\", \\"rent\\", 800.00) print(tracker.get_daily_total(\\"2023-11-15\\")) # Output: 920.00 print(tracker.get_category_total(\\"2023-11-15\\", \\"utilities\\")) # Output: 120.00 print(tracker.get_category_total(\\"2023-11-15\\", \\"rent\\")) # Output: 800.00 ```","solution":"class ExpenseTracker: def __init__(self) -> None: self.expenses = {} def add_expense(self, date: str, category: str, amount: float) -> None: if date not in self.expenses: self.expenses[date] = {} if category not in self.expenses[date]: self.expenses[date][category] = 0.0 self.expenses[date][category] += amount def get_daily_total(self, date: str) -> float: if date not in self.expenses: return 0.0 return sum(self.expenses[date].values()) def get_category_total(self, date: str, category: str) -> float: if date not in self.expenses or category not in self.expenses[date]: return 0.0 return self.expenses[date][category]"},{"question":"# Problem Statement: Write a function to implement the K-Nearest Neighbors (KNN) algorithm for a given dataset to classify input instances into their respective classes. The K value (number of neighbors to consider) will also be provided as an input. # Functions to Implement: 1. `knn_classification(train_X, train_y, test_X, k) -> list` **Parameters**: - `train_X` (list of lists): Training dataset containing input features. - `train_y` (list): Class labels for the training dataset. - `test_X` (list of lists): Testing dataset containing input features. - `k` (int): Number of nearest neighbors to consider. **Returns**: - `predicted_y` (list): Predicted class labels for the testing dataset. # Constraints: - The number of features for each instance is the same. - The class labels are integers starting from 0. - Do not use any external libraries for matrix operations. - K will always be less than or equal to the number of training instances. # Example: ```python train_X = [ [1.2, 2.3], [2.1, 3.1], [1.8, 1.9], [3.0, 3.3], [2.5, 2.8], [2.2, 5.3], [3.3, 4.5], [4.1, 4.0] ] train_y = [0, 1, 0, 1, 0, 1, 1, 1] test_X = [ [1.5, 2.5], [4.0, 4.5] ] k = 3 print(knn_classification(train_X, train_y, test_X, k)) # Output should be [0, 1] ``` # Hints: - Calculate the Euclidean distance between each test instance and all training instances. - Identify the K nearest neighbors and consider the most common class among them for classification.","solution":"import math from collections import Counter def euclidean_distance(instance1, instance2): Helper function to calculate the Euclidean distance between two instances. distance = sum((x - y) ** 2 for x, y in zip(instance1, instance2)) return math.sqrt(distance) def knn_classification(train_X, train_y, test_X, k): Perform K-Nearest Neighbors classification. Parameters: - train_X (list of lists): Training dataset containing input features. - train_y (list): Class labels for the training dataset. - test_X (list of lists): Testing dataset containing input features. - k (int): Number of nearest neighbors to consider. Returns: - predicted_y (list): Predicted class labels for the testing dataset. predicted_y = [] for test_instance in test_X: distances = [] for i, train_instance in enumerate(train_X): distance = euclidean_distance(test_instance, train_instance) distances.append((distance, train_y[i])) distances.sort(key=lambda x: x[0]) # Extract the labels of the k closest neighbors k_nearest_labels = [label for _, label in distances[:k]] # Determine the most common class label among the nearest neighbors most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predicted_y.append(most_common_label) return predicted_y"},{"question":"# Question: Design a Custom LRU Cache Context You are working as a software engineer tasked with optimizing memory management in a high-traffic web application. One common technique used to improve performance is the LRU (Least Recently Used) cache, which keeps track of frequently accessed data and evicts the least recently used items when the cache reaches its capacity. Task Implement a **Custom LRU Cache** class with specific functionalities to store and retrieve data with efficient access and eviction policies. # Requirements 1. **Class Signature**: `class LRUCache:` - Implement the following methods within the class: - `__init__(self, capacity: int)` - `get(self, key: int) -> int` - `put(self, key: int, value: int) -> None` 2. **Input**: - The `capacity` parameter of the constructor will be an integer indicating the maximum number of items the cache can hold. - The `get` method takes an integer `key` and returns the value associated with that key if it exists, otherwise -1. - The `put` method takes an integer `key` and an integer `value` and inserts the key-value pair into the cache. If the cache is at capacity, it should evict the least recently used item before inserting the new key-value pair. 3. **Output**: - The `get` method should return the value associated with the `key` or -1 if the `key` does not exist. - The `put` method does not return anything but modifies the internal state of the cache. 4. **Constraints**: - All operations (get and put) should be performed in **O(1)** time complexity. - The `capacity` will be a positive integer. # Performance Expectations - Efficient access and updates with **O(1)** time complexity. - Correct eviction of the least recently used items when the cache exceeds its capacity. Example ```python >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) # returns 1 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) # returns -1 (not found) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) # returns -1 (not found) -1 >>> cache.get(3) # returns 3 3 >>> cache.get(4) # returns 4 4 ``` # Note - Use of standard library data structures such as `OrderedDict` from `collections` module is allowed to achieve the specified time complexity. - Implement your own eviction policy logic if using simpler data structures.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # Mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove least recently used item"},{"question":"# Task You need to implement a function that checks if a given string is a valid number according to specific rules. The rules for a valid number are as follows: 1. **Integer**: A sequence of digits, possibly prefixed with a \'+\' or \'-\' sign. Examples: \\"123\\", \\"-45\\", \\"+678\\". 2. **Decimal Number**: A sequence of digits with a single decimal point, possibly prefixed with a \'+\' or \'-\' sign. It may have digits before the decimal point, after the decimal point, or both. Examples: \\"0.123\\", \\"-.456\\", \\"+78.9\\", \\"3.\\" 3. **Exponent**: An integer or decimal number followed by an \'e\' or \'E\', and then an integer (with optional \'+\' or \'-\' sign). Examples: \\"1e10\\", \\"-1.23E+4\\", \\"+.5e-7\\". # Requirements 1. **Function**: Implement the function `is_valid_number(s: str) -> bool` that checks if the input string is a valid number according to the above rules. 2. **Input**: A string `s` consisting of characters from a finite set `{0-9, +, -, ., e, E}`. 3. **Output**: A boolean value `True` if the string is a valid number, `False` otherwise. 4. **Constraints**: * The input string\'s length will be between 1 and 100 characters. * The input may contain whitespaces which should be ignored. # Example ```python def is_valid_number(s: str) -> bool: # Your implementation here # Test case print(is_valid_number(\\"123\\")) # Output: True print(is_valid_number(\\"3.14\\")) # Output: True print(is_valid_number(\\"-0.1\\")) # Output: True print(is_valid_number(\\"2e10\\")) # Output: True print(is_valid_number(\\"+.8E-4\\")) # Output: True print(is_valid_number(\\"12.34.56\\")) # Output: False print(is_valid_number(\\"abc\\")) # Output: False print(is_valid_number(\\" \\")) # Output: False print(is_valid_number(\\"+3.5e-2\\")) # Output: True print(is_valid_number(\\"1..2\\")) # Output: False ``` # Explanation - The function should first strip any leading or trailing whitespaces. - It should then check if the string conforms to the rules of a valid number. - An integer or decimal number can have an optional \'+\' or \'-\' sign at the beginning. - If there\'s an \'e\' or \'E\', it must be followed by an integer with an optional \'+\' or \'-\' sign. - The function should return `True` if all these conditions are satisfied, and `False` otherwise.","solution":"import re def is_valid_number(s: str) -> bool: Checks if the input string is a valid number according to the given rules. Arguments: s : str : The input string to validate. Returns: bool : True if the string is a valid number, False otherwise. # Strip leading and trailing whitespaces s = s.strip() # Define regex pattern for a valid number number_pattern = re.compile(r ^ # start of string [+-]? # optional sign ( # group for the base part (d+(.d*)?)| # digits with optional decimal point (.d+) # decimal numbers with at least one digit ) ([eE][+-]?d+)? # optional exponent part # end of string , re.VERBOSE) # Match the stripped string against the pattern match = re.match(number_pattern, s) return match is not None"},{"question":"# Coding Assessment Question You have been hired to improve the functionality of a personal finance application by adding a feature that allows users to track their monthly spending habits more effectively. As part of this enhancement, you need to build a function to generate a summary report of expenses for each category over a given month. # Task Write a function `monthly_expense_report(transactions: list, month: int) -> dict` that: 1. Takes a list of transaction records and a month (represented as an integer from 1 to 12). 2. Returns a dictionary where the keys are expense categories and the values are the total expenses for those categories within the specified month. # Constraints - Each transaction is represented as a dictionary with the following keys: - `\'date\'`: A string in the format \'YYYY-MM-DD\' - `\'amount\'`: A float representing the expense amount - `\'category\'`: A string indicating the expense category - The function should correctly handle invalid input, such as transactions that do not conform to the expected format or transactions with dates outside the specified month. - Assume the `transactions` list contains a reasonable number of entries (e.g., up to 10,000 transactions). # Input - `transactions` (list of dicts): A list of transaction records. - `month` (int): The month for which to generate the expense report (e.g., 1 for January, 2 for February). # Output - Returns a dictionary where keys are categories (str) and values are total expenses (float) for those categories in the specified month. # Example ```python transactions = [ {\'date\': \'2023-01-15\', \'amount\': 50.0, \'category\': \'Groceries\'}, {\'date\': \'2023-01-23\', \'amount\': 25.0, \'category\': \'Transportation\'}, {\'date\': \'2023-02-05\', \'amount\': 100.0, \'category\': \'Rent\'}, {\'date\': \'2023-01-30\', \'amount\': 40.0, \'category\': \'Groceries\'}, ] print(monthly_expense_report(transactions, 1)) ``` *Output*: ``` { \'Groceries\': 90.0, \'Transportation\': 25.0 } ``` # Implementation Notes - Extract the month from the `date` field in each transaction to filter the transactions that belong to the given month. - Group the filtered transactions by their categories and sum up the amounts for each category. - Handle edge cases such as invalid dates or missing data fields gracefully, possibly by logging errors and ignoring the invalid entries.","solution":"def monthly_expense_report(transactions, month): Generates a summary of monthly expenses by category. Args: transactions (list): A list of transaction records, each being a dictionary with \'date\', \'amount\', and \'category\' keys. month (int): The month (1-12) for which the expense report is generated. Returns: dict: A dictionary where keys are categories and values are total expenses for those categories in the specified month. report = {} for transaction in transactions: try: tx_date = transaction[\'date\'] tx_month = int(tx_date.split(\'-\')[1]) if tx_month == month: category = transaction[\'category\'] amount = float(transaction[\'amount\']) if category in report: report[category] += amount else: report[category] = amount except (KeyError, ValueError, IndexError): # Log the error or ignore invalid transaction record continue return report"},{"question":"# Coding Assessment Question: Text Similarity Analyzer Scenario You are developing a text similarity analyzer to evaluate the similarity between two pieces of text. This tool will help to detect plagiarism, identify duplicate content, and suggest similar articles. Problem Statement Implement a Python class `TextSimilarityAnalyzer` that includes methods to pre-process text and compute similarity metrics using different techniques. Specifically, you need to implement the following methods: 1. **Cosine Similarity**: [ text{CosineSimilarity} = frac{mathbf{A} cdot mathbf{B}}{|mathbf{A}| |mathbf{B}|} ] where (mathbf{A}) and (mathbf{B}) are the term frequency vectors of the two texts. 2. **Jaccard Similarity**: [ text{JaccardSimilarity} = frac{| A cap B |}{| A cup B |} ] where ( A ) and ( B ) are sets of words in the two texts. Requirements 1. The class should be initialized without any parameters. 2. Implement the following methods: - `preprocess(text)`: Tokenizes the text, removes punctuation, and converts it to lowercase. - `cosine_similarity(text1, text2)`: Computes cosine similarity between `text1` and `text2`. - `jaccard_similarity(text1, text2)`: Computes Jaccard similarity between `text1` and `text2`. 3. The calculations should handle edge cases like empty texts gracefully. Input/Output Format - **Input**: Strings representing the texts. - Example: ```python text1 = \\"This is a sample sentence.\\" text2 = \\"This sentence is a sample.\\" ``` - **Output**: Similarity score as a float. - **Constraints**: - Text length can vary but will fit in memory. - Similarity scores should be in the range [0, 1]. **Performance**: The solution should efficiently handle texts of moderate length. Example Scenario ```python # Example input texts text1 = \\"The quick brown fox jumps over the lazy dog.\\" text2 = \\"A quick brown dog outpaces a lazy fox.\\" # Initializing the class similarity_analyzer = TextSimilarityAnalyzer() # Preprocessing texts clean_text1 = similarity_analyzer.preprocess(text1) clean_text2 = similarity_analyzer.preprocess(text2) print(\\"Clean Text 1:\\", clean_text1) print(\\"Clean Text 2:\\", clean_text2) # Computing cosine similarity cosine_sim = similarity_analyzer.cosine_similarity(text1, text2) print(\\"Cosine Similarity:\\", cosine_sim) # Computing Jaccard similarity jaccard_sim = similarity_analyzer.jaccard_similarity(text1, text2) print(\\"Jaccard Similarity:\\", jaccard_sim) ``` **Implementation Details**: - Use appropriate tokenization and text cleaning methods for `preprocess()`. - Use `collections.Counter` or similar to generate term frequency vectors. - Utilize `numpy` for efficient cosine similarity calculation. - Handle potential issues like empty input texts or texts with no common words.","solution":"import re import numpy as np from collections import Counter class TextSimilarityAnalyzer: def preprocess(self, text): Tokenizes the text, removes punctuation, and converts it to lowercase. # Remove punctuation and make lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() # Tokenize text by splitting on whitespace tokens = text.split() return tokens def cosine_similarity(self, text1, text2): Computes cosine similarity between text1 and text2. # Preprocess the texts tokens1 = self.preprocess(text1) tokens2 = self.preprocess(text2) # Count term frequencies counter1 = Counter(tokens1) counter2 = Counter(tokens2) # Extract unique words unique_words = list(set(counter1.keys()).union(set(counter2.keys()))) # Create frequency vectors vec1 = np.array([counter1.get(word, 0) for word in unique_words]) vec2 = np.array([counter2.get(word, 0) for word in unique_words]) # Compute cosine similarity dot_product = np.dot(vec1, vec2) norm1 = np.linalg.norm(vec1) norm2 = np.linalg.norm(vec2) if norm1 == 0 or norm2 == 0: return 0.0 # to handle cases where one or both vectors are empty return dot_product / (norm1 * norm2) def jaccard_similarity(self, text1, text2): Computes Jaccard similarity between text1 and text2. # Preprocess the texts tokens1 = set(self.preprocess(text1)) tokens2 = set(self.preprocess(text2)) # Calculate intersection and union of sets intersection = tokens1.intersection(tokens2) union = tokens1.union(tokens2) if not union: return 0.0 # to handle case where both sets are empty return len(intersection) / len(union)"},{"question":"# Scenario: A large company monitors its network to identify potential security breaches. One of the indicators of a potential breach is an unusually high number of failed login attempts within a short time window. The company logs each attempt, including the timestamp and the username involved. # Task: Write a Python function that, given a list of login attempts and a time window, determines the number of distinct usernames with more than a specified number of failed login attempts within that window. # Function Signature: ```python def detect_brute_force(attempts: List[Tuple[str, str]], window: int, threshold: int) -> int: pass ``` # Input: - `attempts` (List[Tuple[str, str]]): A list of tuples where each tuple contains the username (str) and the timestamp of the attempt (str, format \\"YYYY-MM-DD HH:MM:SS\\"). - `window` (int): The time window in seconds. - `threshold` (int): The number of failed attempts that triggers a warning for potential brute force. # Output: - Returns an integer representing the number of distinct usernames with more than `threshold` failed login attempts within the specified `window`. # Constraints: - The time window is a positive integer (1 ≤ window ≤ 86400). - The threshold is a positive integer (1 ≤ threshold ≤ 100). - There can be up to 100,000 login attempt records. - The timestamps are in chronological order. # Example: ```python >>> attempts = [ (\\"alice\\", \\"2023-01-01 12:00:00\\"), (\\"bob\\", \\"2023-01-01 12:01:00\\"), (\\"alice\\", \\"2023-01-01 12:01:30\\"), (\\"alice\\", \\"2023-01-01 12:02:00\\"), (\\"bob\\", \\"2023-01-01 12:03:00\\"), (\\"alice\\", \\"2023-01-01 12:03:30\\"), (\\"bob\\", \\"2023-01-01 12:04:00\\"), (\\"alice\\", \\"2023-01-01 12:04:30\\") ] >>> detect_brute_force(attempts, 180, 3) 1 ``` # Requirements: - Ensure the solution is optimized for performance given the constraints. - Handle edge cases, such as no failed attempts or all attempts from single username. - Consider the robustness of timestamp parsing and window calculations.","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime, timedelta def detect_brute_force(attempts: List[Tuple[str, str]], window: int, threshold: int) -> int: Given a list of login attempts and a time window, determines the number of distinct usernames with more than a specified number of failed login attempts within that window. # Convert the window from seconds to a timedelta object window_timedelta = timedelta(seconds=window) # Convert timestamps to datetime objects and sort the list of attempts based on the timestamp attempts = [(username, datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\")) for username, timestamp in attempts] user_attempts = defaultdict(list) for username, timestamp in attempts: user_attempts[username].append(timestamp) brute_force_users = 0 for username, timestamps in user_attempts.items(): for i in range(len(timestamps)): count = 0 for j in range(i, len(timestamps)): if timestamps[j] - timestamps[i] <= window_timedelta: count += 1 else: break if count > threshold: brute_force_users += 1 break return brute_force_users"},{"question":"# Problem Statement Develop a function capable of calculating the nth Fibonacci number while taking into consideration potential optimization techniques. A Fibonacci number sequence is defined as: - `F(0) = 0` - `F(1) = 1` - For n >= 2, F(n) = F(n-1) + F(n-2) Given the potentially large size of `n`, traditional recursive approaches can become highly inefficient. Therefore, your implementation should leverage efficient methods to ensure performance and accuracy. Implement a function `fibonacci(n: int) -> int` that performs the following: # Input: - `n` (int): The position in the Fibonacci sequence (0-based index). # Output: - Return the Fibonacci number at the nth position as an integer. # Constraints: - `0 <= n <= 10^9` # Requirements: 1. The function must optimize performance for large values of `n`. 2. Consider using techniques such as memoization, iterative computation, or matrix exponentiation to improve efficiency. # Example Usage: ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 >>> fibonacci(100) 354224848179261915075 ``` # Conceptual Hints: - For large `n`, consider using matrix exponentiation or the iterative approach to avoid the high time complexity of the naive recursive method. - Be mindful of optimizing space complexity where possible. # Essential Information: - Ensure that the algorithm handles the very largest constraints efficiently. - Avoid solutions that may run into potential overflow issues or excessive computational time. # Additional Note: - Python\'s inherent support for large integers can be beneficial, but ensure the algorithm\'s logic is sound even with very high values of `n`.","solution":"def fibonacci(n): Calculate the nth Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Daily Temperature Spike You are tasked with implementing a function to determine the number of days after which the temperature will increase for each day in a list. Each day, you want to know how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, store 0 for that day. Problem Statement Implement a function `daily_temperatures` to determine the number of days one has to wait until a warmer temperature for each day. 1. **daily_temperatures(T: List[int]) -> List[int]**: - **Input**: - `T`: A list of integers representing the daily temperatures. - **Output**: Returns a list of integers where the value at each index is the number of days to wait for a warmer temperature. If there\'s no warmer temperature in the future, the value should be 0. Constraints * The length of the temperature list `T` is between 1 and 30000. * Each temperature is an integer in the range [30, 100]. Example ```python assert daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] assert daily_temperatures([30, 40, 50, 60]) == [1, 1, 1, 0] assert daily_temperatures([60, 50, 40, 30]) == [0, 0, 0, 0] ``` Function Definition ```python def daily_temperatures(T: List[int]) -> List[int]: pass ``` # Requirements - Use an appropriate algorithm to solve the problem efficiently. - Ensure your function handles edge cases as specified in the analysis. - Aim for an efficient solution with time complexity better than O(n^2).","solution":"from typing import List def daily_temperatures(T: List[int]) -> List[int]: Returns a list of integers where each element represents how many days you have to wait until a warmer temperature. If there is no warmer temperature in the future, put 0. result = [0] * len(T) stack = [] for i, temp in enumerate(T): while stack and T[stack[-1]] < temp: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"# Sudoku Solver Your task is to implement a Sudoku solver that takes a partially filled 9x9 grid and fills the empty cells, following the rules of Sudoku. Requirements 1. Implement the `SudokuSolver` class with the following methods: * `__init__(self, board: List[List[int]])`: Initializes the class with the given board. * `solve(self) -> bool`: Solves the Sudoku puzzle and returns True if a solution is found, otherwise returns False. * `is_valid(self, num: int, row: int, col: int) -> bool`: Checks if placing `num` at `(row, col)` is valid according to Sudoku rules. * `print_board(self) -> None`: Prints the current state of the board. Example Scenario ```python # Example usage of the SudokuSolver class. board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver(board) if solver.solve(): solver.print_board() else: print(\\"No solution exists\\") ``` Hints 1. Use a backtracking algorithm to find the solution. This involves trying each number from 1 to 9 in an empty cell and recursively solving the board until a valid solution is found. 2. For the `is_valid` method, ensure that the number is not repeated in the corresponding row, column, and 3x3 sub-grid. Testing Ensure your implementation passes the provided doctests or other testing mechanisms to validate correctness.","solution":"from typing import List class SudokuSolver: def __init__(self, board: List[List[int]]): self.board = board def solve(self) -> bool: empty_pos = self.find_empty() if not empty_pos: return True # Board is fully filled row, col = empty_pos for num in range(1, 10): if self.is_valid(num, row, col): self.board[row][col] = num if self.solve(): return True self.board[row][col] = 0 # Backtrack return False def find_empty(self): for i in range(len(self.board)): for j in range(len(self.board[i])): if self.board[i][j] == 0: return (i, j) return None def is_valid(self, num: int, row: int, col: int) -> bool: for i in range(9): if self.board[row][i] == num or self.board[i][col] == num: return False box_x = col // 3 box_y = row // 3 for i in range(box_y * 3, box_y * 3 + 3): for j in range(box_x * 3, box_x * 3 + 3): if self.board[i][j] == num: return False return True def print_board(self) -> None: for row in self.board: print(\\" \\".join(str(num) if num != 0 else \'.\' for num in row))"},{"question":"# Problem Statement Context You are designing a function that simulates a simple banking transaction system. The function should process a series of transactions for a single account and return the final balance after all transactions have been processed. Each transaction is represented by a tuple containing a transaction type (\\"deposit\\" or \\"withdraw\\") and an amount. Function Signature ```python def process_transactions(start_balance: float | str, transactions: list[tuple[str, float | str]]) -> float: ``` Input 1. `start_balance (float | str)`: The initial balance of the account. Should be convertible to a float. 2. `transactions (list[tuple[str, float | str]])`: A list of tuples where each tuple contains: - A string denoting the transaction type, either \\"deposit\\" or \\"withdraw\\". - An amount for the transaction that should be convertible to a float. Output * Returns a `float` of the final account balance after applying all transactions. If the input is invalid, return 0.0. Constraints * The function should validate the input before proceeding with any transactions. * If the initial balance or any transaction amount can\'t be converted to a float, treat the entire input as invalid. * Ensure that any withdrawal does not cause the balance to go below zero and ignore such transactions. Examples ```python >>> process_transactions(1000, [(\\"deposit\\", \\"500\\"), (\\"withdraw\\", \\"200\\"), (\\"withdraw\\", \\"2000\\")]) 1300.0 >>> process_transactions(1000, [(\\"withdraw\\", \\"500\\"), (\\"withdraw\\", 600)]) 500.0 >>> process_transactions(\\"invalid\\", [(\\"deposit\\", \\"500\\")]) 0.0 >>> process_transactions(1000, [(\\"invalid\\", \\"500\\")]) 0.0 >>> process_transactions(1000, [(\\"deposit\\", \\"200\\"), (\\"withdraw\\", \\"50.5\\")]) 1149.5 ``` Additional Requirements: 1. Use `float()` conversion to ensure `start_balance` and transaction amounts are properly handled. If they cannot be converted, return 0.0. 2. Ensure that the implementation handles invalid transactions by ignoring them and not processing them. 3. Prevent the balance from going negative and handle a zero or lower starting balance as invalid.","solution":"def process_transactions(start_balance: float | str, transactions: list[tuple[str, float | str]]) -> float: try: balance = float(start_balance) except ValueError: return 0.0 if balance < 0: return 0.0 for transaction in transactions: try: trans_type, amount = transaction amount = float(amount) except (ValueError, TypeError): return 0.0 if trans_type == \'deposit\': balance += amount elif trans_type == \'withdraw\': if balance >= amount: balance -= amount else: return 0.0 return balance"},{"question":"# Coding Assessment Question Context: You are working on a data analysis project that requires filtering and analyzing strings. One of the tasks involves processing a list of strings and identifying which strings are palindromes (i.e., strings that read the same forwards and backwards). To demonstrate your skills in string manipulation and list processing, you are tasked with writing a program that identifies and counts palindromes in a given list of strings. Task: 1. Implement a function to check if a given string is a palindrome. 2. Implement a function to filter out all palindromes from a list of strings. 3. Include a main function to accept a list of strings from users, identify the palindromes, and print both the count and the list of palindromes. Requirements: 1. **Function `is_palindrome(s: str) -> bool`** - Receive a string as input and return `True` if the string is a palindrome, `False` otherwise. 2. **Function `find_palindromes(strings: List[str]) -> List[str]`** - Receive a list of strings as input and return a list of strings that are palindromes. 3. **Function `main()`** - Accept a list of strings from the user. - Identify and count the palindromes using `is_palindrome` and `find_palindromes`. - Print the total count of palindromes and the list of palindromes. Constraints: - Input list size should be reasonably small (e.g. n ≤ 20). - The program should handle edge cases such as empty strings and case sensitivity. Example: For an input list `[\'level\', \'world\', \'radar\', \'python\', \'madam\']`: - `is_palindrome(\'level\')` should return `True`. - `is_palindrome(\'world\')` should return `False`. - `find_palindromes([\'level\', \'world\', \'radar\', \'python\', \'madam\'])` should return `[\'level\', \'radar\', \'madam\']`. **Sample Main Function Output:** ``` Enter a list of strings: [\'level\', \'world\', \'radar\', \'python\', \'madam\'] Total palindromes: 3 List of palindromes: [\'level\', \'radar\', \'madam\'] ```","solution":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. return s == s[::-1] def find_palindromes(strings: list) -> list: Filter and return a list of palindromes from the given list of strings. return [s for s in strings if is_palindrome(s)] def main(): Accept a list of strings from the user, identify palindromes, and print the count and list. # As we can\'t interactively take user input in a testable module, we\'ll simulate it here. test_input = [\'level\', \'world\', \'radar\', \'python\', \'madam\'] palindromes = find_palindromes(test_input) print(f\\"Total palindromes: {len(palindromes)}\\") print(f\\"List of palindromes: {palindromes}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Document Management System You are tasked with creating a document management system that allows users to store, update, and retrieve documents. Each document has a unique identifier, a title, and content body. You need to implement a class `DocumentManager` to manage the documents, along with the necessary methods to add, update, delete, and retrieve documents. # Task: Implement the class `DocumentManager`, with the following methods: 1. **Method `add_document(self, doc_id: int, title: str, content: str) -> None`:** * **Input**: * `doc_id`: An integer representing the unique identifier for the document. * `title`: A string representing the title of the document. * `content`: A string representing the content of the document. * **Behavior**: * Adds the document to the system. * Raise an exception if a document with the same `doc_id` already exists. 2. **Method `update_document(self, doc_id: int, title: str = None, content: str = None) -> None`:** * **Input**: * `doc_id`: An integer representing the unique identifier for the document. * `title`: An optional string representing the new title of the document (if provided). * `content`: An optional string representing the new content of the document (if provided). * **Behavior**: * Updates the title or content (or both) of the document identified by `doc_id`. * Raise an exception if a document with the specified `doc_id` does not exist. 3. **Method `delete_document(self, doc_id: int) -> None`:** * **Input**: * `doc_id`: An integer representing the unique identifier for the document. * **Behavior**: * Deletes the document identified by `doc_id`. * Raise an exception if a document with the specified `doc_id` does not exist. 4. **Method `get_document(self, doc_id: int) -> dict`:** * **Input**: * `doc_id`: An integer representing the unique identifier for the document. * **Output**: * Returns a dictionary with `title` and `content` of the document. * **Behavior**: * Retrieves the document identified by `doc_id`. * Raise an exception if a document with the specified `doc_id` does not exist. # Examples: ```python # Example usage of DocumentManager: dm = DocumentManager() # Adding documents dm.add_document(1, \\"Doc 1\\", \\"This is the content of document 1.\\") dm.add_document(2, \\"Doc 2\\", \\"This is the content of document 2.\\") # Updating a document dm.update_document(1, content=\\"Updated content for document 1.\\") # Getting a document print(dm.get_document(1)) # Output: {\'title\': \'Doc 1\', \'content\': \'Updated content for document 1.\'} # Deleting a document dm.delete_document(2) # Trying to get a deleted document try: print(dm.get_document(2)) # Should raise an exception except Exception as e: print(e) # Output: Document with id 2 does not exist. ``` # Additional Information: Ensure your methods handle edge cases and raise appropriate exceptions when invalid input or operations are attempted.","solution":"class DocumentManager: def __init__(self): self.documents = {} def add_document(self, doc_id: int, title: str, content: str) -> None: if doc_id in self.documents: raise ValueError(f\\"Document with id {doc_id} already exists.\\") self.documents[doc_id] = {\\"title\\": title, \\"content\\": content} def update_document(self, doc_id: int, title: str = None, content: str = None) -> None: if doc_id not in self.documents: raise ValueError(f\\"Document with id {doc_id} does not exist.\\") if title is not None: self.documents[doc_id][\\"title\\"] = title if content is not None: self.documents[doc_id][\\"content\\"] = content def delete_document(self, doc_id: int) -> None: if doc_id not in self.documents: raise ValueError(f\\"Document with id {doc_id} does not exist.\\") del self.documents[doc_id] def get_document(self, doc_id: int) -> dict: if doc_id not in self.documents: raise ValueError(f\\"Document with id {doc_id} does not exist.\\") return self.documents[doc_id]"},{"question":"# Coding Assessment Question Context You work for a shipping company that needs to efficiently categorize and process different types of shipments. Each shipment is characterized by its weight, volume, and destination. To optimize the shipping routes and processing, you need to classify the shipments based on these features. Task Write a function `classify_shipment` that, given historical shipment data and current shipment features, predicts the category of the current shipment using a K-Nearest Neighbors (KNN) algorithm. # Function Signature ```python def classify_shipment( x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, k: int ) -> np.ndarray: Classifies shipments using the K-Nearest Neighbors algorithm. Args: x_train: 2D ndarray of shape (m, n) representing the features of m historical shipments. y_train: 1D ndarray of shape (m,) representing the categories of m historical shipments. x_test: 2D ndarray of shape (p, n) representing the features of p shipments to be classified. k: Integer representing the number of nearest neighbors to consider. Returns: np.ndarray: A 1D array of shape (p,) containing the predicted categories for each shipment in x_test. ``` # Input and Output Format - **Input**: - `x_train` : An array of shape `(m, n)` where `m` represents the number of training samples and `n` represents the number of features (e.g., weight, volume, destination encoded as numbers). Each row corresponds to the features of one shipment. - `y_train` : An array of shape `(m,)` containing the categories corresponding to each shipment in `x_train`. - `x_test` : An array of shape `(p, n)`, representing the feature values of the shipments you want to classify. - `k` : An integer representing the number of nearest neighbors to consider in the KNN algorithm. - **Output**: A 1D array of shape `(p,)` containing the predicted categories for each shipment in `x_test`. # Constraints - Assume `1 <= m, p <= 10^5` and `1 <= n <= 50`. - The features and categories are non-negative integers. - `1 <= k <= 100`. # Example ```python x_train = np.array([ [10, 15, 1], [20, 25, 1], [30, 35, 2], [40, 45, 2], ]) y_train = np.array([0, 0, 1, 1]) x_test = np.array([ [15, 20, 1], [35, 40, 2] ]) k = 3 predicted_categories = classify_shipment(x_train, y_train, x_test, k) print(predicted_categories) # Expected output: array [0 1] ``` # Notes - Make sure to handle tie-breaking in case of equally distant neighbors with different categories. - You will need to use NumPy for efficient numerical operations. Hints 1. Compute the Euclidean distance between the test shipment and all training shipments. 2. Identify the k-nearest neighbors for each test shipment. 3. Use majority voting to determine the predicted category for each test shipment. This question should fit well within the existing set, maintaining consistency in style, length, and complexity.","solution":"import numpy as np from collections import Counter def classify_shipment(x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, k: int) -> np.ndarray: Classifies shipments using the K-Nearest Neighbors algorithm. Args: x_train: 2D ndarray of shape (m, n) representing the features of m historical shipments. y_train: 1D ndarray of shape (m,) representing the categories of m historical shipments. x_test: 2D ndarray of shape (p, n) representing the features of p shipments to be classified. k: Integer representing the number of nearest neighbors to consider. Returns: np.ndarray: A 1D array of shape (p,) containing the predicted categories for each shipment in x_test. def euclidean_distance(a, b): return np.sqrt(np.sum((a - b)**2)) predictions = np.zeros(x_test.shape[0], dtype=int) for i, test_sample in enumerate(x_test): # Compute distances to all x_train samples distances = np.array([euclidean_distance(test_sample, train_sample) for train_sample in x_train]) # Get the labels of the k nearest neighbors k_indices = np.argsort(distances)[:k] k_nearest_labels = y_train[k_indices] # Majority vote most_common = Counter(k_nearest_labels).most_common(1)[0][0] predictions[i] = most_common return predictions"},{"question":"# Problem Statement You are provided with a utility function `flatten_nested_list` that flattens a nested list of integers into a single list of integers. Using this utility function, implement a new function `product_of_nested_lists` which processes a list of lists, where each sublist contains numerical values, and returns a list containing the product of the elements of each sublist. # Requirements Function Signature ```python def product_of_nested_lists(nested_lists: list) -> list: ``` Input * `nested_lists`: A list of lists, where each sublist contains numerical values. Output * A list of floats, where each float is the product of the elements of a sublist from the input. Constraints * You may assume that the sublists contain at least one numerical value. * If a sublist is empty, its product should be considered as 1. # Example ```python >>> product_of_nested_lists([[2, 4, 6], [3, 6, 12], [1, 3, 5], [10, 15, 20, 25]]) [48.0, 216.0, 15.0, 75000.0] >>> product_of_nested_lists([[5, 15, 25], [3]]) [1875.0, 3.0] >>> product_of_nested_lists([[1, 2, 4], []]) [8.0, 1.0] ``` # Caveats * Ensure your function efficiently handles incorrect input types by raising appropriate exceptions. * Utilize the `flatten_nested_list` utility to flatten each sublist before computing the product, ensuring consistency in handling nested structures. This new problem aims to test the candidate\'s ability to process nested lists and perform operations on them, making it a suitable complement to the existing set.","solution":"from functools import reduce from operator import mul def flatten_nested_list(nested_list): Flattens a nested list. Example: >>> flatten_nested_list([1, [2, [3, 4]], 5]) [1, 2, 3, 4, 5] flat_list = [] for item in nested_list: if isinstance(item, list): flat_list.extend(flatten_nested_list(item)) else: flat_list.append(item) return flat_list def product_of_nested_lists(nested_lists): Takes a list of lists and returns a list containing the product of the elements of each sublist. if not all(isinstance(sublist, list) for sublist in nested_lists): raise ValueError(\\"Input must be a list of lists\\") products = [] for sublist in nested_lists: if sublist: flattened_sublist = flatten_nested_list(sublist) product = reduce(mul, flattened_sublist, 1) else: product = 1 products.append(float(product)) return products"},{"question":"```markdown Problem Statement # Missing Number You are given an array of distinct integers that represents a sequence of numbers from 0 to n inclusive, with exactly one number missing. Your task is to implement a function `find_missing_number(arr: List[int]) -> int` that finds the missing number. # Input - **arr**: A list of `n` distinct integers such that (0 leq arr[i] leq n). # Output Return the missing integer from the sequence. # Example ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 ``` # Constraints - The length of the input list will be within the range `[1, 10^5]`. - The elements of the list are guaranteed to be distinct and within the range `[0, len(arr)]`. # Requirements - The implementation should efficiently handle the provided constraints. - Your solution should have a time complexity of O(n) and a space complexity of O(1). # Implementation Notes You can use the formula for the sum of the first `n` natural numbers to find the missing number by calculating the expected sum and comparing it to the actual sum of the array. ```","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Find the missing number in the sequence. Args: arr (List[int]): A list of n distinct integers where 0 <= arr[i] <= n Returns: int: The missing integer from the sequence n = len(arr) # Total sum of first n natural numbers (including zero) expected_sum = n * (n + 1) // 2 # Sum of elements in the array actual_sum = sum(arr) # The missing number is the difference between the expected sum and actual sum return expected_sum - actual_sum"},{"question":"# Scenario Imagine you are involved in creating a software application that processes text. As part of the text processing capabilities, you need to identify and extract email addresses from a given string. Email addresses have a specific structure: they consist of a user name, an `@` symbol, a domain name, and a domain extension. Additionally, the user name may contain letters, digits, dots, hyphens, and underscores. # Problem Statement Write a Python function `extract_emails(text: str) -> List[str]` that takes a string `text` as input and returns a list of unique email addresses found within that string. Ensure that the email addresses conform to the general standards. # Constraints - The input string `text` may contain multiple sentences and a variety of characters. - Email addresses must follow the format: user_name@domain.extension - The domain name must contain only letters and digits. - The domain extension must be 2 to 4 letters long. # Input - A string `text` that may contain one or more email addresses embedded within it. # Output - A list of unique email addresses extracted from the input string. # Example ```python assert extract_emails(\\"Please contact us at support@example.com or sales@shop123.com. For further info, visit our site.\\") == [\\"support@example.com\\", \\"sales@shop123.com\\"] assert extract_emails(\\"Emails: user.name+spam@gmail.com_test-mail@my-domain.org another.fail@test. invalid.email@com\\") == [\\"user.name+spam@gmail.com\\", \\"_test-mail@my-domain.org\\"] ``` # Performance Requirements - The solution should effectively identify and extract emails with minimal false positives and handle large text inputs efficiently.","solution":"import re from typing import List def extract_emails(text: str) -> List[str]: Extracts unique email addresses from a given string `text`. Args: text (str): The input string containing potential email addresses. Returns: List[str]: A list of unique email addresses found in the input string. email_pattern = re.compile( r\'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,4}b\' ) # Find all matches using the regex pattern found_emails = email_pattern.findall(text) # Use set to remove duplicates and return as a list return list(set(found_emails))"},{"question":"# Coding Assessment Question: **Context**: You are working on a project that analyzes sequences of events based on a timeline. The goal is to identify gaps in the sequence where no events occur. **Task**: Write a Python function `find_gaps` that takes a list of tuples, where each tuple represents an event with a start time and an end time, and returns a list of tuples representing the time intervals during which no events occur. **Specifications**: * Function name: `find_gaps` * Input: * A list of tuples `events` where each tuple `event` consists of two integers `start` and `end` (0 <= start < end <= 10^6) * Output: * A list of tuples where each tuple represents the start and end times of gaps in the timeline. **Constraints**: * The events list is guaranteed to be sorted by start time. * Ensure that the gaps list is also sorted by start time. * Handle edge cases such as back-to-back events where no gaps exist. **Example**: ```python def find_gaps(events: list) -> list: Identify gaps in a sequence of events. Parameters: events (list): A list of tuples where each tuple consists of two integers, start and end times of an event. Returns: list: A list of tuples representing the gaps between events. Examples: >>> find_gaps([(1, 3), (5, 6), (7, 10)]) [(3, 5), (6, 7)] >>> find_gaps([(0, 2), (4, 7), (9, 10)]) [(2, 4), (7, 9)] >>> find_gaps([(0, 5)]) [] >>> find_gaps([(1, 2), (2, 3), (3, 4)]) [] pass ``` **Notes**: * Ensure that your function handles overlapping events correctly by not generating gaps within such overlaps. * Consider the efficiency of the implementation, especially for large input sizes.","solution":"def find_gaps(events): Identify gaps in a sequence of events. Parameters: events (list): A list of tuples where each tuple consists of two integers, start and end times of an event. Returns: list: A list of tuples representing the gaps between events. gaps = [] n = len(events) for i in range(n - 1): # If there\'s a gap between the end of the current event and the start of the next event if events[i][1] < events[i + 1][0]: gaps.append((events[i][1], events[i + 1][0])) return gaps"},{"question":"# Context: You are asked to create a function that generates all permutations of a given list of numbers. Permutations are unique arrangements of a list, and they do not consider order within the elements. # Task: **Implement** a function that generates all permutations of a list of numbers and another function that checks if two lists are permutations of each other. # Function Definitions: 1. **generate_permutations**(`nums: list[int]`) -> `list[list[int]]`: - **Input**: A list of integers `nums`. - **Output**: A list of lists, where each list is a unique permutation of `nums`. 2. **are_permutations**(`list1: list[int], list2: list[int]`) -> `bool`: - **Input**: Two lists of integers `list1` and `list2`. - **Output**: A boolean value `True` if `list1` and `list2` are permutations of each other, else `False`. # Constraints: - The input list to `generate_permutations` will have at most length 6. - The two input lists to `are_permutations` will have the same length and contain only unique integers. # Example: ```python from itertools import permutations class Permutations: @staticmethod def generate_permutations(nums: list[int]) -> list[list[int]]: # Your implementation here pass @staticmethod def are_permutations(list1: list[int], list2: list[int]) -> bool: # Your implementation here pass if __name__ == \\"__main__\\": nums = [1, 2, 3] perms = Permutations().generate_permutations(nums) print(perms) # Example output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] list1 = [1, 2, 3] list2 = [3, 1, 2] print(Permutations().are_permutations(list1, list2)) # Example output: True ``` **Example Usage**: ```python perms = Permutations.generate_permutations([1, 2, 3]) # perms => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] is_perm = Permutations.are_permutations([1, 2, 3], [3, 2, 1]) # is_perm => True ```","solution":"from itertools import permutations class Permutations: @staticmethod def generate_permutations(nums: list[int]) -> list[list[int]]: Generate all permutations of a list of numbers. :param nums: list of integers :return: list of lists, where each list is a permutation of nums return list(map(list, permutations(nums))) @staticmethod def are_permutations(list1: list[int], list2: list[int]) -> bool: Check if two lists are permutations of each other. :param list1: first list of integers :param list2: second list of integers :return: True if list1 and list2 are permutations of each other, else False return sorted(list1) == sorted(list2)"},{"question":"# Coding Assessment Question You are tasked with enhancing a function that processes and analyzes text data from an external API that provides sentence analysis (such as sentiment or keyword extraction). The current implementation retrieves and prints the raw result. As a developer, you need to add functionality to parse and structure this information in a meaningful way. Function Specifications You must write a function `analyze_text_data` that processes the text data from the API and returns a structured summary. **Function Signature**: ```python def analyze_text_data(text: str, api_key: str = \\"YOUR API KEY\\") -> dict: ``` **Expected Input**: - `text` (str): The text to be analyzed. - `api_key` (str): Your API key for the text analysis service. **Expected Output**: - Returns a dictionary with the following structure: ```python { \\"text\\": original_text, \\"summary\\": { \\"sentiment\\": sentiment_score, \\"keywords\\": [ \\"keyword1\\", \\"keyword2\\", ... ] } } ``` **Constraints**: - Handle API rate limits. If the limit is exceeded, the function should pause and retry after a specific time. - Ensure the function is robust against network issues and API key errors. - Limit the number of retries for failed requests to 3. - Handle and parse different possible formats of the API response gracefully. **Performance Requirements**: - Minimize the response time by optimizing API calls. - Ensure the function can process large text data efficiently without excessive memory usage. **Context**: Imagine you are developing a text analysis tool for a content management system to provide insights on the sentiment and trending keywords in articles. The structured summary will aid in understanding the text\'s impact and topics of interest. # Example Usage ```python result = analyze_text_data(text=\\"I love programming in Python!\\", api_key=\\"your_api_key\\") print(result) ``` # Example Output ```python { \\"text\\": \\"I love programming in Python!\\", \\"summary\\": { \\"sentiment\\": 0.95, \\"keywords\\": [ \\"programming\\", \\"Python\\" ] } } ```","solution":"import requests import time def analyze_text_data(text: str, api_key: str = \\"YOUR API KEY\\") -> dict: url = \\"https://api.text-analysis.com/analyze\\" headers = { \\"Authorization\\": f\\"Bearer {api_key}\\", \\"Content-Type\\": \\"application/json\\" } payload = { \\"text\\": text } retries = 3 for _ in range(retries): try: response = requests.post(url, headers=headers, json=payload) if response.status_code == 429: # Handling rate limit error time.sleep(1) # Wait for a second before retrying continue response.raise_for_status() data = response.json() sentiment_score = data.get(\\"sentiment\\", {}).get(\\"score\\", 0) keywords = data.get(\\"keywords\\", []) return { \\"text\\": text, \\"summary\\": { \\"sentiment\\": sentiment_score, \\"keywords\\": keywords } } except requests.exceptions.RequestException as e: print(f\\"Request failed: {e}\\") time.sleep(1) # Wait a second before retrying return { \\"text\\": text, \\"summary\\": { \\"sentiment\\": 0, \\"keywords\\": [] } }"},{"question":"# Coding Assessment Question You are given a directed graph representing a network of computers. Each computer is represented by a node, and each connection between two computers is represented by a directed edge. Your task is to implement a function to determine if there is a cycle in the graph, which would imply that data can circulate indefinitely among the computers, potentially causing issues. Write a function `has_cycle` that takes an integer `num_nodes` representing the number of nodes, and a list of tuples `edges` where each tuple (u, v) represents a directed edge from node `u` to node `v`. The function should return `True` if there is a cycle in the graph, otherwise return `False`. Function Signature ```python def has_cycle(num_nodes: int, edges: list[tuple[int, int]]) -> bool: pass ``` Input Format - `num_nodes`: An integer representing the number of nodes in the graph. - `edges`: A list of tuples where each tuple (u, v) represents a directed edge from node `u` to node `v`. Output Format A boolean value `True` if there is a cycle in the graph, otherwise `False`. Constraints - `1 <= num_nodes <= 1000` - `0 <= len(edges) <= 2000` - 0 <= u, v < num_nodes Example ```python num_nodes = 4 edges = [(0, 1), (1, 2), (2, 0), (3, 2)] print(has_cycle(num_nodes, edges)) # Output: True num_nodes = 3 edges = [(0, 1), (1, 2)] print(has_cycle(num_nodes, edges)) # Output: False ``` Performance Requirements - Your solution should be efficient with a time complexity of approximately O(V + E), where V is the number of vertices (nodes) and E is the number of edges. - The space complexity should be O(V + E). Good luck!","solution":"def has_cycle(num_nodes: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict, deque def build_graph(num_nodes, edges): graph = defaultdict(list) in_degree = [0] * num_nodes for u, v in edges: graph[u].append(v) in_degree[v] += 1 return graph, in_degree def is_cyclic(graph, in_degree, num_nodes): queue = deque([node for node in range(num_nodes) if in_degree[node] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return visited != num_nodes graph, in_degree = build_graph(num_nodes, edges) return is_cyclic(graph, in_degree, num_nodes)"},{"question":"# Problem Statement A streaming service wants to manage its server load by intelligently distributing video packets during peak hours. Each packet stream has an associated bitrate, and the company wants to periodically redistribute the packets to maintain a balanced load. You need to implement a function that merges two sorted lists of packet bitrates into a single sorted list. The function should work efficiently even for large input sizes and should also handle cases where duplicate bitrates exist in the input. Function Signature ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists of integers into a single sorted list. :param list1: A sorted list of integers representing the bitrates of video packets. :param list2: Another sorted list of integers representing the bitrates of video packets. :return: A merged and sorted list of all integers from both input lists. ``` Input - `list1`: A sorted list of integers. - `list2`: Another sorted list of integers. Output - A list of integers that contains all elements from `list1` and `list2` in sorted order. Constraints - Both lists may contain up to (10^5) integers. - The integers in each list are non-negative. - Duplicates are allowed and should be retained in the merged list. Example ```python assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([1, 2, 2], [2, 3, 4]) == [1, 2, 2, 2, 3, 4] assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] ``` Write an efficient implementation of the `merge_sorted_lists` function that handles the edge cases and performs well within the given constraints.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists of integers into a single sorted list. :param list1: A sorted list of integers representing the bitrates of video packets. :param list2: Another sorted list of integers representing the bitrates of video packets. :return: A merged and sorted list of all integers from both input lists. # Initialize pointers for both lists and the result list i, j = 0, 0 merged_list = [] # Traverse through both lists while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements of list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"Question: Implement a Simplified Traffic Light Controller # Scenario You are tasked with creating a software simulation of a traffic light system at a simple pedestrian crossing. The traffic light has three states: Green, Yellow, and Red, which control the traffic flow as follows: - Green: Cars are allowed to pass through. - Yellow: Cars should prepare to stop. - Red: Cars must stop. The system also needs to ensure that the traffic light transitions in the following specific order: ``` Green -> Yellow -> Red -> Green ``` # Task Write a class `TrafficLightController` that simulates the behavior of this traffic light system with the following requirements: - The initial state of the traffic light should be Green. - Provide methods to get the current state of the traffic light and to transition to the next state. # Class Signature ```python class TrafficLightController: def __init__(self): pass def get_state(self) -> str: pass def next_state(self): pass ``` # Methods - `__init__()`: Initialize the traffic light controller with the starting state as Green. - `get_state() -> str`: Return the current state of the traffic light as a string (\\"Green\\", \\"Yellow\\", or \\"Red\\"). - `next_state()`: Transition the traffic light to the next state following the specified order and update the current state. # Example ```python # Initialize the controller traffic_light = TrafficLightController() # Current state should be Green print(traffic_light.get_state()) # Output: \\"Green\\" # Transition to the next state, which should be Yellow traffic_light.next_state() print(traffic_light.get_state()) # Output: \\"Yellow\\" # Transition to the next state, which should be Red traffic_light.next_state() print(traffic_light.get_state()) # Output: \\"Red\\" # Transition to the next state, which should be Green again traffic_light.next_state() print(traffic_light.get_state()) # Output: \\"Green\\" ``` # Constraints - The transitions must strictly follow the order Green -> Yellow -> Red -> Green, and this cycle should repeat indefinitely. - Ensure your class methods are efficient and handle consecutive transitions correctly.","solution":"class TrafficLightController: def __init__(self): self.states = [\\"Green\\", \\"Yellow\\", \\"Red\\"] self.current_index = 0 def get_state(self) -> str: return self.states[self.current_index] def next_state(self): self.current_index = (self.current_index + 1) % len(self.states)"},{"question":"# Question You are a software engineer developing a logistics data analysis application. Your task is to write a function that finds the shortest path in a weighted directed graph representing a transportation network. # Function Description Implement the function `find_shortest_path` which takes in an adjacency matrix representing the weights of the edges in the graph, the index of the starting node, and the index of the destination node, and returns the shortest path as a list of nodes. # Input * A 2D list of integers `adjacency_matrix` of shape (n, n) representing the weighted adjacency matrix of the graph, where `adjacency_matrix[i][j]` is the weight of the edge from node `i` to node `j`. If there is no edge between nodes `i` and `j`, the value is `float(\'inf\')`. * An integer `start` representing the index of the starting node. * An integer `end` representing the index of the destination node. # Output * A list of integers representing the nodes in the shortest path from the start node to the end node. If there is no path, return an empty list. # Constraints * The graph contains between 1 and 1000 nodes. * Each weight in the adjacency matrix is a non-negative integer or `float(\'inf\')` for no direct path. * It is guaranteed that the start and end nodes are valid indices within the graph. # Performance Requirements * Your function should handle graphs with up to 1000 nodes efficiently. # Example ```python def find_shortest_path(adjacency_matrix: List[List[float]], start: int, end: int) -> List[int]: import heapq n = len(adjacency_matrix) dist = [float(\'inf\')] * n prev = [-1] * n dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor in range(n): if adjacency_matrix[current_node][neighbor] != float(\'inf\'): distance = current_dist + adjacency_matrix[current_node][neighbor] if distance < dist[neighbor]: dist[neighbor] = distance prev[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_node = end while current_node != -1: path.append(current_node) current_node = prev[current_node] path.reverse() if dist[end] == float(\'inf\'): return [] return path # Example usage: adjacency_matrix = [ [0, 2, float(\'inf\'), 1], [float(\'inf\'), 0, 3, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 0, 1], [float(\'inf\'), float(\'inf\'), 1, 0] ] start = 0 end = 2 shortest_path = find_shortest_path(adjacency_matrix, start, end) print(shortest_path) # Output: [0, 3, 2] ``` In the above example, the `find_shortest_path` function will determine the shortest path from the start node (0) to the end node (2).","solution":"from typing import List import heapq def find_shortest_path(adjacency_matrix: List[List[float]], start: int, end: int) -> List[int]: n = len(adjacency_matrix) dist = [float(\'inf\')] * n prev = [-1] * n dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor in range(n): if adjacency_matrix[current_node][neighbor] != float(\'inf\'): distance = current_dist + adjacency_matrix[current_node][neighbor] if distance < dist[neighbor]: dist[neighbor] = distance prev[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_node = end while current_node != -1: path.append(current_node) current_node = prev[current_node] path.reverse() if dist[end] == float(\'inf\'): return [] return path"},{"question":"# Problem Context Sorting algorithms are fundamental in computer science and are often taught as introductory examples of algorithmic thinking. They can vary significantly in their efficiency and implementation complexity. While standard library functions often provide optimized and reliable performance, implementing and understanding different sorting algorithms can be an essential learning experience. As an intermediate task, you are challenged to implement and compare the performance of different sorting algorithms. # Task You are asked to implement three different sorting algorithms: Bubble Sort, Merge Sort, and Quick Sort. You will then compare the performance of these algorithms on the same input to understand their relative efficiencies. # Requirements 1. **Implement the three sorting algorithms:** * `bubble_sort(arr)` * `merge_sort(arr)` * `quick_sort(arr)` 2. **Compare performance:** * Write a function `compare_sorts(inputs, n_runs)` that takes a list of input arrays and a number of runs. The function will run each sort function on the same list of inputs and average the execution time over the specified runs. # Input and Output Format 1. `bubble_sort` function: * **Input**: `arr (List[int])` * **Output**: Sorted list of integers. 2. `merge_sort` function: * **Input**: `arr (List[int])` * **Output**: Sorted list of integers. 3. `quick_sort` function: * **Input**: `arr (List[int])` * **Output**: Sorted list of integers. 4. `compare_sorts` function: * **Input**: `inputs (List[List[int]])`, and `n_runs (int)` * **Output**: A dictionary with average execution times for each sorting function. # Constraints * The input list can have up to 1000 elements. * The elements within the list can range from -1000 to 1000. * `n_runs`: Must be a positive integer. # Edge Cases * Lists with all identical elements. * Lists sorted in reverse order. * Lists with random elements. # Performance Expectations * Ensure the algorithms are implemented correctly with respect to their theoretical time complexities: * Bubble Sort: (O(n^2)) * Merge Sort: (O(n log n)) * Quick Sort: (O(n log n)) on average * Compare execution times correctly and handle timing with high precision. # Example Implement the three sorting algorithms and the comparison function and validate their correctness with test cases. **Sample Test** ```python import time from random import randint from typing import List, Dict def bubble_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def compare_sorts(inputs: List[List[int]], n_runs: int) -> Dict[str, float]: def average_time(func, data): start = time.time() for _ in range(n_runs): func(data[:]) end = time.time() return (end - start) / n_runs results = {} for sort_func in [bubble_sort, merge_sort, quick_sort]: name = sort_func.__name__ total_time = 0 for arr in inputs: total_time += average_time(sort_func, arr) results[name] = total_time / len(inputs) return results inputs = [[randint(-1000, 1000) for _ in range(1000)] for __ in range(5)] n_runs = 10 results = compare_sorts(inputs, n_runs) for sort_name, exec_time in results.items(): print(f\\"{sort_name}: {exec_time:.6f} seconds\\") ``` This question aligns with the original set by focusing on understanding and optimizing fundamental algorithms, this time extending into sorting and performance comparison.","solution":"import time from random import randint from typing import List, Dict def bubble_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def compare_sorts(inputs: List[List[int]], n_runs: int) -> Dict[str, float]: def average_time(func, data): total_time = 0 for _ in range(n_runs): start = time.time() func(data[:]) end = time.time() total_time += (end - start) return total_time / n_runs results = {} for sort_func in [bubble_sort, merge_sort, quick_sort]: name = sort_func.__name__ total_time = 0 for arr in inputs: total_time += average_time(sort_func, arr) results[name] = total_time / len(inputs) return results"},{"question":"# Array Product Except Self Problem Statement Given an array of integers `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must solve it without using division and in O(n) time complexity. Write a function `product_except_self(nums: List[int]) -> List[int]` that takes in: - `nums` (a list of integers): The input array. The function should return a list of integers representing the product of all elements except the one at each index. Example ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60] ``` Constraints - The length of `nums` is `n` where `1 <= n <= 10^5`. - `-30 <= nums[i] <= 30`. - The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer. Performance Requirements The solution must handle large input sizes up to the maximum constraints efficiently and must solve the problem in O(n) time complexity. Additional Notes Consider edge cases such as: - Arrays with zeros, which can significantly affect the product computations. - Arrays with negative numbers. - Arrays with only one element, where the return should logically be `[1]` since no other elements exist to multiply.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Initialize two arrays to keep track of the prefix and suffix products left_products = [1] * n right_products = [1] * n # Compute the prefix products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute the suffix products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Compute the result by multiplying the corresponding entries from the two arrays result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"# Question Overview You have been given a list of integers representing exam scores of students in a class. Your task is to develop a function that processes this list to produce the mode of the scores (the number that appears most frequently). If there is a tie for the mode, return the smallest number. # Problem Statement **Function Signature**: ```python def find_mode(scores: List[int]) -> int: pass ``` **Input**: - A list of integers `scores` where each integer (`0 ≤ scores[i] ≤ 100`) represents a student\'s exam score. `2 ≤ len(scores) ≤ 1000`. **Output**: - An integer representing the mode of the scores. In case of a tie, return the smallest number. # Constraints - The function should efficiently find the mode. - Handle the case of multiple modes by selecting the smallest one. - Consider edge cases such as all elements being the same. # Hints - Utilize Python\'s `collections.Counter` to count the frequency of each score. - Iterate through the counted scores to determine the mode, handling ties appropriately. # Additional Requirements - Include meaningful comments in your code explaining each step. - Ensure your solution passes the following test cases: ```python assert find_mode([50, 85, 90, 85, 76, 85, 90, 90, 90]) == 90 assert find_mode([30, 30, 40, 40, 20, 10]) == 30 assert find_mode([100, 90, 85, 100, 90, 100]) == 100 assert find_mode([10, 20, 30, 40, 50]) == 10 assert find_mode([55, 55, 55, 55]) == 55 ``` # Performance Testing - Your solution should handle the upper limit of the input size within a reasonable time frame (e.g., 1000 elements).","solution":"from typing import List from collections import Counter def find_mode(scores: List[int]) -> int: Returns the mode of the list of scores. In case of a tie, returns the smallest number. # Count the frequencies of each score counter = Counter(scores) # Find the highest frequency max_frequency = max(counter.values()) # Find the smallest score with the highest frequency mode = min(score for score, freq in counter.items() if freq == max_frequency) return mode"},{"question":"# Polynomial Addition Context You are asked to implement a function to add two polynomials and return the resulting polynomial in its simplified form. Each polynomial is represented as a list of integers, where each integer represents a coefficient, and the index represents the corresponding power of the variable. Task Write a function `add_polynomials` that adds two polynomials and returns the resulting polynomial as a list of coefficients. The resulting polynomial should be simplified, meaning that trailing zeros should be removed. Specifications **Function: add_polynomials** * **Input**: poly1 (list of ints), poly2 (list of ints) * **Output**: result (list of ints) Example ```python poly1 = [3, 0, 2] # Represents 3 + 0x + 2x^2 poly2 = [1, 2, 1] # Represents 1 + 2x + 1x^2 result = add_polynomials(poly1, poly2) # Expected Output: [4, 2, 3] assert add_polynomials([3, 0, 2], [1, 2, 1]) == [4, 2, 3] poly3 = [2, 3, 0, 0, 5] # Represents 2 + 3x + 5x^4 poly4 = [1, -3, 2] # Represents 1 - 3x + 2x^2 result = add_polynomials(poly3, poly4) # Expected Output: [3, 0, 2, 0, 5] assert add_polynomials([2, 3, 0, 0, 5], [1, -3, 2]) == [3, 0, 2, 0, 5] ``` Constraints 1. Each polynomial is represented as a list of integers, where each integer represents a coefficient, and the index represents the corresponding power of the variable. 2. The input polynomials can have different lengths. 3. The output list should not contain trailing zeros (except for the case where the result is zero itself).","solution":"def add_polynomials(poly1, poly2): Adds two polynomials and returns the resulting polynomial in its simplified form. # Determine the length of the longer polynomial max_length = max(len(poly1), len(poly2)) # Initialize the result polynomial with zeros result = [0] * max_length # Add the coefficients of the polynomials for i in range(max_length): coeff1 = poly1[i] if i < len(poly1) else 0 coeff2 = poly2[i] if i < len(poly2) else 0 result[i] = coeff1 + coeff2 # Remove trailing zeros while len(result) > 1 and result[-1] == 0: result.pop() return result"},{"question":"# Scenario: A software company is developing a social media application. One feature involves generating user statistics based on their activity. As part of the project, you need to implement a function that calculates the most frequent activity times within a given list of timestamps. # Problem Statement: Given a list of timestamps representing the times when users performed activities, return a list of the most common activity times sorted in increasing order. If a timestamp appears multiple times, it should be included in the result multiple times. # Function Signature: ```python def most_frequent_times(timestamps: List[str]) -> List[str]: ``` # Input: * `timestamps`: A List of strings, where each string is in the format \\"HH:MM\\" (24-hour clock). # Output: * Returns a List of strings representing the most frequent activity times in increasing order. # Constraints: * 1 <= len(timestamps) <= 10^5 * Each timestamp is a valid time in \\"HH:MM\\" format. # Example: ```python assert most_frequent_times([\\"12:30\\", \\"14:00\\", \\"12:30\\", \\"14:00\\", \\"14:00\\", \\"16:45\\"]) == [\\"14:00\\", \\"14:00\\", \\"14:00\\", \\"12:30\\", \\"12:30\\"] assert most_frequent_times([\\"09:15\\", \\"09:15\\", \\"11:30\\", \\"11:30\\", \\"11:30\\"]) == [\\"11:30\\", \\"11:30\\", \\"11:30\\", \\"09:15\\", \\"09:15\\"] assert most_frequent_times([\\"18:00\\", \\"06:00\\", \\"12:30\\", \\"18:00\\", \\"18:00\\"]) == [\\"18:00\\", \\"18:00\\", \\"18:00\\"] assert most_frequent_times([\\"00:00\\", \\"23:59\\", \\"00:00\\", \\"00:00\\"]) == [\\"00:00\\", \\"00:00\\", \\"00:00\\"] ``` # Additional Instructions: * The function should be case-sensitive, so \\"12:30\\" and \\"12:30\\" should be treated equally. * Ensure the function handles edge cases, such as an empty list or all unique timestamps. * The function should be efficient, particularly for large inputs. * You may assume the input list is always non-empty and contains valid timestamps.","solution":"from collections import Counter from typing import List def most_frequent_times(timestamps: List[str]) -> List[str]: Returns a list of the most common activity times sorted in increasing order. If a timestamp appears multiple times, it should be included in the result multiple times. # Count the occurrences of each timestamp counts = Counter(timestamps) # Generate a list of (timestamp, count) tuples and sort by timestamp sorted_counts = sorted(counts.items()) # Build the result list by repeating each timestamp according to its count result = [] for timestamp, count in sorted_counts: result.extend([timestamp] * count) return result"},{"question":"# Inverted Index for Document Retrieval Context An inverted index is a fundamental data structure used in search engines to map words to their locations in a set of documents. This structure allows efficient full-text searches, making it possible to quickly find all occurrences of a word. Building an efficient inverted index involves processing a collection of documents and creating a mapping from each unique word to the list of documents in which it appears. This is a common task in text processing and information retrieval systems. Task You will implement a function that constructs an inverted index from a given list of documents. Each document is represented as a string containing multiple words. Requirements 1. **Function Name**: `build_inverted_index` 2. **Inputs**: - `documents`: List of strings, where each string represents a document. 3. **Output**: - A dictionary where each key is a word, and the value is a list of indices of the documents (from the input list) that contain that word. Constraints - Words are case-insensitive (e.g., \\"Word\\" and \\"word\\" should be treated as the same word). - Remove punctuation and non-alphanumeric characters from words. - Words should be stored in the dictionary in lowercase. Performance Requirements - Your solution should efficiently handle up to 10,000 documents, each containing up to 1,000 words. Example ```python documents = [ \\"The quick brown fox\\", \\"Jumped over the lazy dog\\", \\"The quick and lazy dog\\", ] inverted_index = build_inverted_index(documents) expected_output = { \'the\': [0, 1, 2], \'quick\': [0, 2], \'brown\': [0], \'fox\': [0], \'jumped\': [1], \'over\': [1], \'lazy\': [1, 2], \'dog\': [1, 2], \'and\': [2] } print(inverted_index == expected_output) # Expected Output: True ```","solution":"import re from collections import defaultdict def build_inverted_index(documents): Constructs an inverted index from a given list of documents. Args: documents (list): List of strings, where each string represents a document. Returns: dict: A dictionary where each key is a word, and the value is a list of indices of the documents that contain that word. inverted_index = defaultdict(list) for index, document in enumerate(documents): # Converting document to lowercase and removing non-alphanumeric characters words = re.findall(r\'bw+b\', document.lower()) for word in set(words): # Using set to avoid duplicate entries in the same document inverted_index[word].append(index) return dict(inverted_index)"},{"question":"# Balanced Parentheses Validation and Counting **Scenario**: As a software developer, you need to ensure that the input strings provided by users contain well-formed parentheses. This task is critical for applications that require syntactically correct expressions, such as compilers and parsers. # Problem Statement Write a function `validate_and_count` that performs two tasks: 1. Validate whether a given string has balanced parentheses. 2. Count the number of balanced parentheses pairs. **Function Signature** ```python def validate_and_count(expression: str) -> tuple[bool, int]: pass ``` **Input/Output Format** * **Input**: - A string `expression` containing only the characters \'(\', \')\', and possibly other characters. * **Output**: - A tuple where the first element is a boolean indicating if the parentheses are balanced and the second element is an integer representing the number of balanced pairs. **Constraints** * The input string can have up to 10^6 characters. # Constraints/Edge Cases to Consider 1. Empty string 2. String with no parentheses 3. String with all opening or all closing parentheses 4. String with interleaved or nested parentheses # Requirements Implement the function `validate_and_count` and make sure it efficiently handles the upper limit of the input size. Explain the approach used to determine the balance and how the counting was performed. Discuss the time complexity of the implementation. ```python def validate_and_count(expression: str) -> tuple[bool, int]: stack = [] balanced_pairs = 0 for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if stack: stack.pop() balanced_pairs += 1 else: return (False, balanced_pairs) return (len(stack) == 0, balanced_pairs) # Sample Usage # expression = \\"(()(())())\\" # Result should be (True, 4) because the parentheses are balanced and there are 4 pairs. result = validate_and_count(\\"(()(())())\\") print(result) ```","solution":"def validate_and_count(expression: str) -> tuple[bool, int]: stack = [] balanced_pairs = 0 for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if stack: stack.pop() balanced_pairs += 1 else: return (False, balanced_pairs) return (len(stack) == 0, balanced_pairs)"},{"question":"# Context Sorting algorithms are fundamental for various computer science applications, including search optimization, database algorithms, and more. Understanding and implementing these algorithms can enhance problem-solving efficiency. # Problem Statement In this task, you need to implement the Quick Sort algorithm to sort an array of integers. Quick Sort is a divide-and-conquer algorithm, which works by selecting a \'pivot\' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. # Task Write a function `quick_sort` that takes a list of integers and sorts it in ascending order using the Quick Sort algorithm. # Function Signature ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` where 1 <= len(arr) <= 1000 and -10^6 <= arr[i] <= 10^6. # Output - The input list `arr`, sorted in ascending order. # Example Usage ```python # Example Usage arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = quick_sort(arr) print(sorted_arr) # Should output [1, 1, 2, 3, 6, 8, 10] arr = [10, 7, 8, 9, 1, 5] sorted_arr = quick_sort(arr) print(sorted_arr) # Should output [1, 5, 7, 8, 9, 10] ``` # Constraints 1. The implementation of the Quick Sort should be efficient in terms of both time and space complexity. 2. Consider edge cases such as an already sorted list, a list with all identical elements, and an empty list. 3. No built-in sorting functions are allowed. The use of helper functions within your code is encouraged for readability and structure.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Quick Sort algorithm. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Context You have been tasked with developing a feature for a banking application that identifies possible fraudulent transactions. A common technique involves tracking the number of transactions that occur within a certain timeframe. If the number of transactions exceeds a predefined threshold within that timeframe, an alert should be raised. # Task Implement a function `detect_fraudulent_activity` that monitors transactions and raises an alert if the number of transactions within any continuous window of time exceeds the threshold limit. Function Signature ```python def detect_fraudulent_activity(transactions: List[Tuple[int, int]], threshold: int, timeframe: int) -> bool: Given a list of transactions, each transaction consisting of a timestamp (in seconds) and an amount, implement a function to detect fraudulent activity. Args: transactions (List[Tuple[int, int]]): A list of tuples where each tuple contains the timestamp and the amount of the transaction. threshold (int): The maximum number of allowable transactions within the timeframe. timeframe (int): The timeframe (in seconds) within which the number of transactions must be monitored. Returns: bool: True if the number of transactions exceeds the threshold within the given timeframe, False otherwise. ``` Input * `transactions` (List[Tuple[int, int]]): A list of tuples where each tuple contains the timestamp (0 <= timestamp <= 10^6) and the amount of the transaction (amount > 0). * `threshold` (int): The threshold limit for transactions within the timeframe (1 <= threshold <= 10^3). * `timeframe` (int): The timeframe in seconds to monitor for transaction count (1 <= timeframe <= 10^6). Output * Returns a boolean value: * `True` if the number of transactions within any continuous window of `timeframe` seconds exceeds the `threshold`. * `False` otherwise. Examples ```python >>> detect_fraudulent_activity([(1, 100), (2, 200), (3, 150), (5, 250), (9, 300)], 3, 4) True >>> detect_fraudulent_activity([(1, 100), (2, 200), (8, 150), (12, 250), (15, 300)], 2, 5) False >>> detect_fraudulent_activity([(1, 100), (3, 200), (4, 150), (10, 250), (12, 300)], 2, 3) True ``` Requirements: * Ensure that the function accounts for overlapping windows of time. * Optimize the function for large input sizes, minimizing time complexity where possible. * Handle edge cases such as no transactions or all transactions occurring outside the timeframe.","solution":"def detect_fraudulent_activity(transactions, threshold, timeframe): Given a list of transactions, each transaction consisting of a timestamp (in seconds) and an amount, implement a function to detect fraudulent activity. Args: transactions (List[Tuple[int, int]]): A list of tuples where each tuple contains the timestamp and the amount of the transaction. threshold (int): The maximum number of allowable transactions within the timeframe. timeframe (int): The timeframe (in seconds) within which the number of transactions must be monitored. Returns: bool: True if the number of transactions exceeds the threshold within the given timeframe, False otherwise. if not transactions: return False transactions.sort() # Sort by timestamp n = len(transactions) for i in range(n): count = 1 # Start with the current transaction for j in range(i + 1, n): if transactions[j][0] - transactions[i][0] <= timeframe: count += 1 if count > threshold: return True else: break # No need to check further as they are sorted return False"},{"question":"# Real-time Chat Server Implementation Create a simple real-time chat server using WebSockets. The server should support multiple clients and broadcast messages to all connected clients. Below are the requirements: 1. **Handle Client Connections**: Accept incoming client connections and add them to the list of connected clients. 2. **Broadcast Messages**: When a message is received from a client, broadcast it to all connected clients. 3. **Handle Client Disconnections**: Remove the client from the list of connected clients when they disconnect. # Input and Output Input Messages from clients will be received through WebSocket connections in real-time. Output Messages will be broadcast to all connected clients in real-time. # Constraints * Use Python\'s `asyncio` and `websockets` libraries to implement the chat server. * The server should run on `localhost` and port `8765`. * Messages sent from clients are strings. * You can assume that the WebSocket clients handle the establishment of the connection and sending messages correctly. # Example Here is an example implementation outline to help you get started: ```python import asyncio import websockets from websockets import WebSocketServerProtocol connected_clients = set() async def register_client(client: WebSocketServerProtocol): connected_clients.add(client) print(f\\"{client.remote_address} connected\\") async def unregister_client(client: WebSocketServerProtocol): connected_clients.remove(client) print(f\\"{client.remote_address} disconnected\\") async def broadcast_message(message: str): if connected_clients: await asyncio.wait([client.send(message) for client in connected_clients]) async def handle_client(client: WebSocketServerProtocol, path): try: await register_client(client) async for message in client: await broadcast_message(message) except websockets.ConnectionClosed: pass finally: await unregister_client(client) async def main(): async with websockets.serve(handle_client, \\"localhost\\", 8765): await asyncio.Future() # Run forever if __name__ == \\"__main__\\": asyncio.run(main()) ``` Implement the above components to complete the task, ensuring to handle client connections and message broadcasting as required.","solution":"import asyncio import websockets from websockets import WebSocketServerProtocol connected_clients = set() async def register_client(client: WebSocketServerProtocol): connected_clients.add(client) print(f\\"{client.remote_address} connected\\") async def unregister_client(client: WebSocketServerProtocol): connected_clients.remove(client) print(f\\"{client.remote_address} disconnected\\") async def broadcast_message(message: str): if connected_clients: await asyncio.wait([client.send(message) for client in connected_clients]) async def handle_client(client: WebSocketServerProtocol, path): try: await register_client(client) async for message in client: await broadcast_message(message) except websockets.ConnectionClosed: pass finally: await unregister_client(client) async def main(): async with websockets.serve(handle_client, \\"localhost\\", 8765): await asyncio.Future() # Run forever if __name__ == \\"__main__\\": asyncio.run(main())"},{"question":"# Sorting Dictionary by Value Background You are working on a text processing application where one of the tasks is analyzing word frequency in a piece of text. After computing the frequency of each word, you need to sort this data to understand which words are the most common. Your goal is to write a function that sorts a dictionary by its values, returning the result as a list of tuples. Task Write a Python function `sort_dict_by_value(d: dict) -> list` that takes a dictionary where the keys are strings (words) and the values are integers (frequencies). The function should return a list of tuples sorted by the dictionary’s values in descending order. Each tuple should contain a key and its corresponding value. Input * One parameter: * `d` (dict): A dictionary where keys are strings and values are integers. Output * A list of tuples. Each tuple contains a string (key) and an integer (value), sorted by the values in descending order. Examples ```python >>> sort_dict_by_value({\'apple\': 5, \'banana\': 3, \'cherry\': 7}) [(\'cherry\', 7), (\'apple\', 5), (\'banana\', 3)] >>> sort_dict_by_value({\'red\': 2, \'blue\': 3, \'green\': 2}) [(\'blue\', 3), (\'red\', 2), (\'green\', 2)] >>> sort_dict_by_value({\'one\': 1, \'two\': 2, \'three\': 0}) [(\'two\', 2), (\'one\', 1), (\'three\', 0)] ``` Note: If two words have the same frequency, they should appear in the output in the order they appeared in the original dictionary.","solution":"def sort_dict_by_value(d): Sorts a dictionary by its values in descending order. Parameters: d (dict): A dictionary where keys are strings and values are integers. Returns: list: A list of tuples sorted by the dictionary\'s values in descending order. # Use sorted with a lambda function to sort by values in descending order return sorted(d.items(), key=lambda item: item[1], reverse=True)"},{"question":"# Problem Statement Create a function `find_closest_pair(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]` that finds and returns the pair of points that are closest to each other according to the Euclidean distance. # Input and Output Formats - **Input** - `points`: A list of tuples where each tuple contains two integers representing the x and y coordinates of a point. - **Output** - A tuple containing two tuples, each representing a point from the input list that form the closest pair. # Constraints - Each point will have integer coordinates in the range from `-1e4` to `1e4`. - There will be at least 2 points in the list. - If there are multiple pairs with the same minimum distance, return any one of them. # Example - **Example 1:** ```python find_closest_pair([(0, 0), (1, 1), (2, 2)]) ``` Expected Output: ```python ((0, 0), (1, 1)) ``` - **Example 2:** ```python find_closest_pair([(1, 2), (3, 4), (0, 0), (5, 5)]) ``` Expected Output: ```python ((1, 2), (0, 0)) ``` - **Example 3:** ```python find_closest_pair([(1, 2), (3, 4), (6, 7), (1, 3)]) ``` Expected Output: ```python ((1, 2), (1, 3)) ``` # Note The Euclidean distance between two points ((x1, y1)) and ((x2, y2)) is calculated as: [ text{distance} = sqrt{(x2 - x1)^2 + (y2 - y1)^2} ] Ensure your function efficiently handles the calculations and takes into account edge cases where distances might be very close.","solution":"import math def find_closest_pair(points): Returns the pair of points that are closest to each other according to the Euclidean distance. def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) min_distance = float(\'inf\') closest_pair = (points[0], points[1]) for i in range(len(points)): for j in range(i + 1, len(points)): dist = euclidean_distance(points[i], points[j]) if dist < min_distance: min_distance = dist closest_pair = (points[i], points[j]) return closest_pair"},{"question":"**Objective**: Design and implement a library management system function that tracks and modifies book availability. **Scenario**: You are to create a function `manage_books` that keeps track of book checkouts and returns in a library. The function should update the library\'s inventory and handle errors related to invalid operations, such as trying to check out a book that is not available or returning a book that was not checked out. Additionally, the system should be able to provide the current status of any requested book. **Guidelines**: - The function should effectively update the inventory upon each checkout or return operation. - Ensure proper error handling for invalid operations. - The function should manage an initial list of books, each characterized by its title and availability status. **Function Signature**: ```python def manage_books( operations: List[Tuple[str, str]], initial_inventory: Dict[str, int] ) -> Dict[str, int]: ``` **Input Format**: - `operations`: A list of tuples where each tuple contains a string indicating the operation (`\\"checkout\\"` or `\\"return\\"`) and a string indicating the title of the book. - `initial_inventory`: A dictionary where the keys are strings representing book titles and the values are integers representing the number of copies available. **Output Format**: - A dictionary representing the updated inventory after all operations have been successfully processed. **Constraints**: - All book titles are unique within the library. - Initial inventory values are non-negative integers. - Handle scenarios where multiple operations on the same book title occur. - Ensure operations are processed in the given order. **Examples**: ```python >>> initial_inventory = {\\"Python Programming\\": 3, \\"Data Structures\\": 2} >>> operations = [(\\"checkout\\", \\"Python Programming\\"), (\\"return\\", \\"Data Structures\\"), (\\"checkout\\", \\"Data Structures\\"), (\\"checkout\\", \\"Data Structures\\")] >>> manage_books(operations, initial_inventory) {\'Python Programming\': 2, \'Data Structures\': 1} >>> initial_inventory = {\\"Machine Learning\\": 1} >>> operations = [(\\"checkout\\", \\"Machine Learning\\"), (\\"checkout\\", \\"Machine Learning\\"), (\\"return\\", \\"Machine Learning\\"), (\\"checkout\\", \\"Machine Learning\\")] >>> manage_books(operations, initial_inventory) {\'Machine Learning\': 0} ``` **Important Considerations**: - Ensure that the function does not allow checking out more books than are available. - Prevent returning books that were not previously checked out. - Properly handle cases involving an empty inventory or operations list. - The function should output the final inventory state after executing all operations, reflecting the accurate number of copies available for each book. --- This question requires candidates to handle inventory management effectively, including error validation and sequencing of operations, providing a challenging yet familiar problem in the context of managing resources programmatically.","solution":"def manage_books(operations, initial_inventory): Manages the checkout and return of books in a library. Parameters: operations (List[Tuple[str, str]]): List of operations to perform, where each operation is a tuple with the action (\'checkout\' or \'return\') and the book title. initial_inventory (Dict[str, int]): Dictionary where the keys are book titles and the values are the initial number of copies available. Returns: Dict[str, int]: Updated inventory after performing all operations. # Copy the initial inventory to avoid modifying the input directly inventory = initial_inventory.copy() for action, title in operations: if title not in inventory: continue # Invalid operations for non-existent books, skip if action == \\"checkout\\": if inventory[title] > 0: inventory[title] -= 1 # If the book is not available, skip this operation elif action == \\"return\\": inventory[title] += 1 # Increase inventory on return return inventory"},{"question":"# Coding Assessment Question Context You are developing a feature for a scheduling application that needs to generate available time slots between given start and end times, excluding a list of busy intervals. You decide to create a function to automatically compute these available time slots as the time intervals where the user is free. Task Write a function `find_free_time_slots` that receives the start and end times of the required interval and a list of busy intervals, and returns a list of available time slots within this interval that do not overlap with the busy intervals. Each time slot should be represented as a tuple of start and end times, and all times are represented in \\"HH:MM\\" time format strings. Constraints - The start and end time for the interval will be valid \\"HH:MM\\" formatted strings. - The busy intervals list will contain tuples of start and end times, both in \\"HH:MM\\" format and valid. - All busy intervals will be within the given start and end times. - No busy intervals will overlap with each other. - Times are in 24-hour format. Function Signature ```python def find_free_time_slots(interval_start: str, interval_end: str, busy_intervals: list[tuple[str, str]]) -> list[tuple[str, str]]: pass ``` Expected Input and Output ```python >>> find_free_time_slots(\\"09:00\\", \\"17:00\\", [(\\"10:00\\", \\"11:00\\"), (\\"13:00\\", \\"14:00\\"), (\\"15:00\\", \\"16:00\\")]) [(\'09:00\', \'10:00\'), (\'11:00\', \'13:00\'), (\'14:00\', \'15:00\'), (\'16:00\', \'17:00\')] >>> find_free_time_slots(\\"08:00\\", \\"12:00\\", [(\\"08:30\\", \\"09:00\\"), (\\"10:00\\", \\"11:00\\")]) [(\'08:00\', \'08:30\'), (\'09:00\', \'10:00\'), (\'11:00\', \'12:00\')] >>> find_free_time_slots(\\"12:00\\", \\"20:00\\", []) [(\'12:00\', \'20:00\')] >>> find_free_time_slots(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"12:00\\"), (\\"12:00\\", \\"17:00\\")]) [] ``` Performance Requirements - Your implementation should preferably run in O(n) time complexity. - Aim for efficient handling of busy intervals and avoid unnecessary computations. - Ensure your time comparisons are correct and handle all edge cases, such as back-to-back intervals properly.","solution":"def find_free_time_slots(interval_start: str, interval_end: str, busy_intervals: list[tuple[str, str]]) -> list[tuple[str, str]]: Find free time slots within a given time interval excluding busy intervals. Parameters: interval_start (str): The start time of the desired interval in \\"HH:MM\\" format. interval_end (str): The end time of the desired interval in \\"HH:MM\\" format. busy_intervals (list[tuple[str, str]]): A list of busy intervals, each represented as a tuple of start and end times in \\"HH:MM\\" format. Returns: list[tuple[str, str]]: A list of available time slots within the given interval that do not overlap with the busy intervals. if not busy_intervals: return [(interval_start, interval_end)] busy_intervals.sort() free_slots = [] # Initial free slot before the first busy interval if interval_start < busy_intervals[0][0]: free_slots.append((interval_start, busy_intervals[0][0])) # Free slots between busy intervals for i in range(len(busy_intervals) - 1): if busy_intervals[i][1] < busy_intervals[i + 1][0]: free_slots.append((busy_intervals[i][1], busy_intervals[i + 1][0])) # Final free slot after the last busy interval if busy_intervals[-1][1] < interval_end: free_slots.append((busy_intervals[-1][1], interval_end)) return free_slots"},{"question":"# Task: Implement a Letter Counter with Case Sensitivity Option Write a function that counts the occurrences of each letter in a given string. The function should be able to handle case sensitivity based on an optional parameter. Specifically: 1. **Input Validation**: Ensure that the input is a string. If the input is not a string, raise a TypeError with the message \\"Invalid input: Input must be a string\\". 2. **Case Sensitivity**: The function should accept an optional boolean parameter `case_sensitive` (default to False). If `case_sensitive` is False, the function should treat \'A\' and \'a\' as the same letter. If `case_sensitive` is True, the function should distinguish between \'A\' and \'a\'. 3. **Letter Counting**: The function should return a dictionary with letters as keys and their counts as values. # Function Signature ```python def count_letters(input_string, case_sensitive=False): Count occurrences of each letter in the input string with optional case sensitivity. :param input_string: str :param case_sensitive: bool :return: dict: Dictionary with letter counts >>> count_letters(\\"Hello World!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> count_letters(\\"Hello World!\\", case_sensitive=True) {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'W\': 1, \'r\': 1, \'d\': 1} >>> count_letters(\\"Python is fun!\\") {\'p\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 2, \'i\': 1, \'s\': 1, \'f\': 1, \'u\': 1} >>> count_letters(\\"123\\", case_sensitive=True) {} >>> count_letters(123) Traceback (most recent call last): ... TypeError: Invalid input: Input must be a string # Your implementation here ``` # Constraints 1. The input must be a string. 2. If `case_sensitive` is False, the function should normalize the case of all letters before counting. 3. Only alphabetical characters should be counted; ignore numbers, punctuation, and spaces. # Example Usages - `count_letters(\\"Hello World!\\")` should return `{\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1}`. - `count_letters(\\"Hello World!\\", case_sensitive=True)` should return `{\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'W\': 1, \'r\': 1, \'d\': 1}`. - `count_letters(\\"Python is fun!\\")` should return `{\'p\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 2, \'i\': 1, \'s\': 1, \'f\': 1, \'u\': 1}`. - `count_letters(\\"123\\")` should return `{}`. - `count_letters(123)` should raise `TypeError: Invalid input: Input must be a string`.","solution":"def count_letters(input_string, case_sensitive=False): Count occurrences of each letter in the input string with optional case sensitivity. :param input_string: str :param case_sensitive: bool :return: dict: Dictionary with letter counts >>> count_letters(\\"Hello World!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> count_letters(\\"Hello World!\\", case_sensitive=True) {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'W\': 1, \'r\': 1, \'d\': 1} >>> count_letters(\\"Python is fun!\\") {\'p\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 2, \'i\': 1, \'s\': 1, \'f\': 1, \'u\': 1} >>> count_letters(\\"123\\", case_sensitive=True) {} >>> count_letters(123) Traceback (most recent call last): ... TypeError: Invalid input: Input must be a string if not isinstance(input_string, str): raise TypeError(\\"Invalid input: Input must be a string\\") if not case_sensitive: input_string = input_string.lower() count_dict = {} for char in input_string: if char.isalpha(): if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"# Question: Matrix Diagonal Sum You are tasked with implementing a function to compute the sum of the primary and secondary diagonals of a square matrix. The function should be able to handle matrices of any size. Function Specification ```python def diagonal_sum(matrix: list[list[float]]) -> tuple[float, float]: Computes the sums of the primary and secondary diagonals in a square matrix. Parameters: matrix (list of list of float): A square matrix (list of lists). Returns: tuple of float: A tuple where the first element is the sum of the primary diagonal and the second element is the sum of the secondary diagonal. Raises: ValueError: If the matrix is not square. Examples: >>> diagonal_sum([[1, 2], [3, 4]]) (5.0, 5.0) >>> diagonal_sum([[5, 0, 2], [1, 3, 4], [6, 7, 8]]) (16.0, 10.0) >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15.0, 15.0) >>> diagonal_sum([[1, 2], [3, 4], [5, 6]]) Traceback (most recent call last): ... ValueError: The provided matrix is not square. ``` Requirements 1. **Input Constraints**: * The matrix will be a list of lists of floats. * The function must handle only square matrices (n x n). 2. **Output**: * The function should return a tuple of floats, where the first float is the sum of the primary diagonal and the second float is the sum of the secondary diagonal. * If the matrix is not square, raise a `ValueError` with an appropriate message. 3. **Edge Cases**: * Handle cases with small matrices such as 1x1. * Raise exceptions for non-square matrices. * Ensure that floating-point inaccuracies are handled appropriately. Additional Information - Primary diagonal: Elements where the row index equals the column index. - Secondary diagonal: Elements where the row index plus the column index equals the size of the matrix minus 1. Performance Considerations Your solution should handle square matrices efficiently, ensuring the summation operations are performed accurately using floating-point arithmetic.","solution":"def diagonal_sum(matrix: list[list[float]]) -> tuple[float, float]: Computes the sums of the primary and secondary diagonals in a square matrix. Parameters: matrix (list of list of float): A square matrix (list of lists). Returns: tuple of float: A tuple where the first element is the sum of the primary diagonal and the second element is the sum of the secondary diagonal. Raises: ValueError: If the matrix is not square. Examples: >>> diagonal_sum([[1, 2], [3, 4]]) (5.0, 5.0) >>> diagonal_sum([[5, 0, 2], [1, 3, 4], [6, 7, 8]]) (16.0, 10.0) >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15.0, 15.0) >>> diagonal_sum([[1, 2], [3, 4], [5, 6]]) Traceback (most recent call last): ... ValueError: The provided matrix is not square. n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"The provided matrix is not square.\\") primary_diagonal_sum = 0.0 secondary_diagonal_sum = 0.0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return primary_diagonal_sum, secondary_diagonal_sum"},{"question":"# Question A stack data structure is a collection of elements with two principal operations: `push`, which adds an element to the collection, and `pop`, which removes the most recently added element that has not yet been removed. You are required to implement a Stack class in Python that supports the following operations: - `push(value)`: Adds a value to the top of the stack. - `pop()`: Removes and returns the value on the top of the stack. If the stack is empty, raise an `IndexError` with the message \\"pop from empty stack\\". - `is_empty()`: Returns `True` if the stack is empty and `False` otherwise. - `peek()`: Returns the value on the top of the stack without removing it. If the stack is empty, raise an `IndexError` with the message \\"peek from empty stack\\". Additionally, implement parameterized unit tests to verify the correctness of your `Stack` class implementation. Class Signature: ```python class Stack: def __init__(self): # Initialize an empty list to store stack elements def push(self, value: int): # Add `value` to the stack def pop(self) -> int: # Remove and return the top element of the stack, raise IndexError if empty def is_empty(self) -> bool: # Check if the stack is empty def peek(self) -> int: # Return the top element without removing it, raise IndexError if empty ``` Constraints: - Values processed by the stack will always be integers. Input: Functions will be called with the following parameters: - A method call to `push` with an integer value. - A method call to `pop` without any parameters. - A method call to `is_empty` without any parameters. - A method call to `peek` without any parameters. Output: - `push` should not return a value. - `pop` should return an integer (the top element of the stack). - `is_empty` should return a boolean (`True` or `False`). - `peek` should return an integer (the top element of the stack). Example: ```python stack = Stack() assert stack.is_empty() == True # The stack is initially empty stack.push(10) assert stack.peek() == 10 # The top element is now 10 stack.push(20) assert stack.pop() == 20 # The top element 20 is removed and returned assert stack.peek() == 10 # The top element is now 10 again assert stack.pop() == 10 # The top element 10 is removed and returned assert stack.is_empty() == True # The stack is empty again ``` Edge Cases: - Calling `pop` on an empty stack should raise an `IndexError` with the message \\"pop from empty stack\\". - Calling `peek` on an empty stack should raise an `IndexError` with the message \\"peek from empty stack\\". Use the following skeleton code to get started: ```python class Stack: def __init__(self): self._elements = [] def push(self, value: int): self._elements.append(value) def pop(self) -> int: if not self._elements: raise IndexError(\\"pop from empty stack\\") return self._elements.pop() def is_empty(self) -> bool: return len(self._elements) == 0 def peek(self) -> int: if not self._elements: raise IndexError(\\"peek from empty stack\\") return self._elements[-1] ```","solution":"class Stack: def __init__(self): self._elements = [] def push(self, value: int): self._elements.append(value) def pop(self) -> int: if not self._elements: raise IndexError(\\"pop from empty stack\\") return self._elements.pop() def is_empty(self) -> bool: return len(self._elements) == 0 def peek(self) -> int: if not self._elements: raise IndexError(\\"peek from empty stack\\") return self._elements[-1]"},{"question":"# Matrix Diagonal Sum Write a function that calculates the sum of the two main diagonals of a square matrix. Function Signature: ```python def diagonal_sum(matrix: List[List[int]]) -> int: ``` # Input: * `matrix`: A 2D list of integers representing a square matrix (i.e., number of rows equals the number of columns). # Output: * An integer representing the sum of the two main diagonals. Note that if the square matrix has an odd dimension, the middle element should only be included once. # Examples: ```python >>> diagonal_sum([[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 25 >>> diagonal_sum([[1, 2], ... [3, 4]]) 10 >>> diagonal_sum([[5]]) 5 >>> diagonal_sum([[1, 0, 0, 1], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [1, 0, 0, 1]]) 8 ``` # Constraints: * The input matrix is guaranteed to be a square matrix. * You may assume the matrix elements are integers. * The dimensions of the matrix will be in the range `[1, 200]`. # Additional Requirements: * Optimize your implementation to avoid redundancy in calculations, especially when dealing with the middle element in odd-dimensional matrices. * Your solution should handle edge cases, such as the smallest matrix size (1x1). # Hints: * Consider the indices of the elements that belong to the primary and secondary diagonals. * Be careful not to double-count the middle element if the matrix has an odd size.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: Returns the sum of the two main diagonals of a square matrix. If the matrix has an odd dimension, the middle element should only be included once. n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # primary diagonal total_sum += matrix[i][n - i - 1] # secondary diagonal if n % 2 == 1: total_sum -= matrix[n // 2][n // 2] # middle element was counted twice, subtract it once return total_sum"},{"question":"Coding Question: **Scenario:** You are developing a program to perform text processing for a content management system. One requirement is to convert a given text string into \\"Title Case\\", where the first letter of each word is capitalized, and all other letters are lowercase. However, certain \\"small words\\" should remain lowercase unless they are the first or last word in the title. **Task:** Write a function `title_case` that takes a string of text and converts it to title case, applying the specified rules for \\"small words\\". **Function Signature:** ```python def title_case(text: str, small_words: List[str]) -> str: pass ``` **Parameters:** * `text` (str): A string of text that needs to be converted to title case. * `small_words` (List[str]): A list of words that should remain lowercase unless they are the first or last word in the title. **Returns:** * str: The converted text in title case according to the specified rules. **Example:** ```python text = \\"the quick brown fox jumps over the lazy dog\\" small_words = [\\"the\\", \\"over\\"] assert title_case(text, small_words) == \\"The Quick Brown Fox Jumps over the Lazy Dog\\" text = \\"a quick brown fox\\" small_words = [\\"a\\"] assert title_case(text, small_words) == \\"A Quick Brown Fox\\" ``` **Constraints:** * The function should handle punctuation marks appropriately. * Ensure that words at the beginning and end of the text are always capitalized, even if they are in the `small_words` list. * The function should be efficient in both time and space complexity. **Performance Requirements:** The implementation should efficiently handle large texts with multiple words and punctuation marks.","solution":"from typing import List def title_case(text: str, small_words: List[str]) -> str: Converts a given text string to title case according to the rules, where small words remain lowercase unless they\'re the first or last word. if not text: return \\"\\" words = text.split() title_cased_words = [] for idx, word in enumerate(words): if idx == 0 or idx == len(words) - 1 or word.lower() not in small_words: title_cased_words.append(word.capitalize()) else: title_cased_words.append(word.lower()) return \\" \\".join(title_cased_words)"},{"question":"# Coding Assessment Question Context Dynamic programming is often used to solve optimization problems where solving subproblems optimally helps in solving the main problem efficiently. In this task, you are required to solve a problem using dynamic programming to optimize the number of ways to reach a certain target. Problem Description You are given an integer `target` and a list `nums` of distinct integers. Each integer in `nums` represents a step size that can be used to reach the target. Implement a function to count the number of distinct ways to reach exactly `target` by taking steps of sizes given in `nums`. Function Signature ```python def count_ways(target: int, nums: List[int]) -> int: pass ``` Input - `target` (int): The target number to be reached, where ( 0 leq text{target} leq 10^6 ) - `nums` (List[int]): A list of distinct integers representing step sizes, where ( 1 leq text{len(nums)} leq 50 ) and ( 1 leq text{nums}[i] leq 1000 ) Output - Return the number of distinct ways to reach the `target` using the step sizes provided in `nums`. Example ```python # Example 1 target = 4 nums = [1, 2, 3] assert count_ways(target, nums) == 7 # Example 2 target = 3 nums = [2] assert count_ways(target, nums) == 0 # Example 3 target = 6 nums = [1, 2, 3] assert count_ways(target, nums) == 24 ``` Constraints - You must use dynamic programming in your solution. - Your solution should be efficient in both time and space complexity. - Avoid using recursion with depth large enough to cause stack overflow.","solution":"from typing import List def count_ways(target: int, nums: List[int]) -> int: Returns the number of distinct ways to reach the target using step sizes in nums. dp = [0] * (target + 1) dp[0] = 1 # There is one way to reach zero, by doing nothing for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Scenario You are tasked with implementing a system for managing a library\'s collection of books. Each book is characterized by a title, an author, and the year it was published. The library needs a feature to search for books based on different criteria. # Task Write a class `Library` that keeps track of its collection and allows adding new books. Implement methods to search for books by title, author, or publication year. # Class Signature ```python class Library: def __init__(self): pass def add_book(self, title: str, author: str, year: int): pass def search_by_title(self, title: str) -> List[Dict[str, Union[str, int]]]: pass def search_by_author(self, author: str) -> List[Dict[str, Union[str, int]]]: pass def search_by_year(self, year: int) -> List[Dict[str, Union[str, int]]]: pass ``` # Input - The method `add_book` takes three parameters: a string `title`, a string `author`, and an integer `year`. - The method `search_by_title` takes a string `title` as a parameter and searches for books whose title contains the given string (case-insensitive). - The method `search_by_author` takes a string `author` as a parameter and searches for books written by the given author (case-insensitive). - The method `search_by_year` takes an integer `year` as a parameter and searches for books published in that year. # Output - Each search method returns a list of dictionaries, where each dictionary represents a book and contains the keys \'title\', \'author\', and \'year\'. If no books match the search criteria, the method returns an empty list. # Constraints - The library can store at most 10000 books. - Book titles and authors will always be alphanumeric strings of length between 1 and 100. - Years will be integers between 1000 and 9999. # Example ```python library = Library() library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(\\"1984\\", \\"George Orwell\\", 1949) library.add_book(\\"Brave New World\\", \\"Aldous Huxley\\", 1932) library.add_book(\\"Fahrenheit 451\\", \\"Ray Bradbury\\", 1953) assert library.search_by_title(\\"1984\\") == [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}] assert library.search_by_author(\\"Harper Lee\\") == [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}] assert library.search_by_year(1953) == [{\'title\': \'Fahrenheit 451\', \'author\': \'Ray Bradbury\', \'year\': 1953}] ``` # Implementation Details - Implement the `Library` class to efficiently add and search books. - Adhere to case-insensitive comparisons for title and author searches. - Handle edge cases such as no matches found, empty library, and multiple books matching search criteria.","solution":"from typing import List, Dict, Union class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, year: int): Adds a new book to the library collection. book = {\'title\': title, \'author\': author, \'year\': year} self.books.append(book) def search_by_title(self, title: str) -> List[Dict[str, Union[str, int]]]: Searches for books that contain the given title string (case-insensitive). title_lower = title.lower() return [book for book in self.books if title_lower in book[\'title\'].lower()] def search_by_author(self, author: str) -> List[Dict[str, Union[str, int]]]: Searches for books written by the given author (case-insensitive). author_lower = author.lower() return [book for book in self.books if author_lower in book[\'author\'].lower()] def search_by_year(self, year: int) -> List[Dict[str, Union[str, int]]]: Searches for books published in the given year. return [book for book in self.books if book[\'year\'] == year]"},{"question":"# Problem Statement Create a function that extracts and consolidates continuous ranges from a list of integers. The function should take a sorted list of unique integers and return a list of tuples representing continuous ranges within the input list. # Function Signature ```python def consolidate_ranges(nums: List[int]) -> List[Tuple[int, int]]: ``` # Input - `nums`: A sorted list of unique integers where `0 <= len(nums) <= 10^5`. # Output - A list of tuples, where each tuple `(a, b)` represents a continuous range `[a, a+1, ..., b]` within the input list. # Constraints - The list will be sorted in ascending order and contain no duplicate values. - The function should return a list of tuples that covers all elements in the input list. # Example ```python >>> consolidate_ranges([0, 1, 2, 4, 5, 7]) [(0, 2), (4, 5), (7, 7)] >>> consolidate_ranges([10]) [(10, 10)] >>> consolidate_ranges([1, 3, 5, 7, 9]) [(1, 1), (3, 3), (5, 5), (7, 7), (9, 9)] ``` # Notes - If the input list is empty, the output should be an empty list. - Each range should be represented as a tuple of two integers. If an integer stands alone (not part of a continuous range), it should still be wrapped in a tuple (e.g., `(7, 7)`). - Ensure the function handles all edge cases efficiently, especially large lists up to the constraint limits.","solution":"from typing import List, Tuple def consolidate_ranges(nums: List[int]) -> List[Tuple[int, int]]: if not nums: return [] ranges = [] start = nums[0] for i in range(1, len(nums)): if nums[i] != nums[i-1] + 1: ranges.append((start, nums[i-1])) start = nums[i] ranges.append((start, nums[-1])) return ranges"},{"question":"# Task: You are required to implement a class `QueueWithTwoStacks` that simulates the behavior of a queue using two stacks. The purpose of this exercise is to understand how a queue can be implemented using stack operations. # Requirements: - Implement the necessary methods to perform standard queue operations. - Ensure that operations maintain efficiency within the constraints of stack operations. # Detailed Function Requirements: 1. **`__init__()`**: Initializes two empty stacks for implementing the queue. * **Output**: None. 2. **`enqueue(item: int) -> None`**: Adds `item` to the end of the queue. * **Input**: `item` – the item to be added to the queue. * **Output**: None. 3. **`dequeue() -> int`**: Removes the item from the front of the queue and returns it. * **Output**: The item removed from the front of the queue. * **Constraints**: If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". 4. **`peek() -> int`**: Returns the item at the front of the queue without removing it. * **Output**: The item at the front of the queue. * **Constraints**: If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". 5. **`is_empty() -> bool`**: Returns `True` if the queue is empty, otherwise returns `False`. * **Output**: A boolean value indicating whether the queue is empty. # Constraints: - Implement the queue operations using two stacks. - Ensure that the time complexity of the `enqueue` and `dequeue` operations is amortized O(1). # Example Usage: ```python queue = QueueWithTwoStacks() queue.enqueue(10) queue.enqueue(20) print(queue.peek()) # Output: 10 print(queue.dequeue()) # Output: 10 print(queue.is_empty()) # Output: False queue.enqueue(30) print(queue.dequeue()) # Output: 20 print(queue.dequeue()) # Output: 30 print(queue.is_empty()) # Output: True ``` # Note: Your implementation should simulate a queue using only stack operations, showcasing an understanding of stack and queue behavior along with their interaction.","solution":"class QueueWithTwoStacks: def __init__(self): Initialize two stacks to simulate the behavior of a queue. self.stack1 = [] self.stack2 = [] def enqueue(self, item: int) -> None: Add item to the end of the queue. self.stack1.append(item) def dequeue(self) -> int: Remove item from the front of the queue and return it. If the queue is empty, raise an IndexError. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"Queue is empty\\") return self.stack2.pop() def peek(self) -> int: Get the item at the front of the queue without removing it. If the queue is empty, raise an IndexError. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"Queue is empty\\") return self.stack2[-1] def is_empty(self) -> bool: Returns True if the queue is empty, otherwise returns False. return not self.stack1 and not self.stack2"},{"question":"# Evaluate Expression Tree Problem Statement You are given the root of an expression tree. Your task is to write a function `evaluate_expression_tree` that evaluates the arithmetic expression represented by the tree and returns the result. An expression tree is a binary tree where: - Leaf nodes represent operands (integers). - Non-leaf nodes represent binary operators such as `+`, `-`, `*`, `/`. Function Signature ```python def evaluate_expression_tree(root: ExprNode) -> float: ``` Input - `root`: The root node of the expression tree. The `ExprNode` class has the following structure: ```python class ExprNode: def __init__(self, value: str, left: ExprNode = None, right: ExprNode = None): self.value = value self.left = left self.right = right ``` Output - Return the evaluated result of the expression as a float. Example ```python # Example 1: # \\"+\\" # / # \\"3\\" \\"4\\" root = ExprNode(\\"+\\", ExprNode(\\"3\\"), ExprNode(\\"4\\")) print(evaluate_expression_tree(root)) # Output: 7.0 # Example 2: # \\"*\\" # / # \\"+\\" \\"5\\" # / # \\"2\\" \\"3\\" root = ExprNode(\\"*\\", ExprNode(\\"+\\", ExprNode(\\"2\\"), ExprNode(\\"3\\")), ExprNode(\\"5\\")) print(evaluate_expression_tree(root)) # Output: 25.0 ``` Constraints - The number of nodes in the tree is in the range [1, 10^4]. - All the values at the leaf nodes are valid integers. - All the operator nodes will have either `+`, `-`, `*`, or `/` as values. - The division operator `/` should perform floating-point division. - Expression is always valid, no need to handle erroneous inputs. Additional Information - You may assume the `ExprNode` class is already defined in the environment as provided above. - Consider utilizing a recursive approach to evaluate the expression tree. Hints - Each operator node will have exactly two children. - You may find a depth-first traversal approach useful in evaluating the expression.","solution":"class ExprNode: def __init__(self, value: str, left: \'ExprNode\' = None, right: \'ExprNode\' = None): self.value = value self.left = left self.right = right def evaluate_expression_tree(root: ExprNode) -> float: if root.left is None and root.right is None: return float(root.value) left_value = evaluate_expression_tree(root.left) right_value = evaluate_expression_tree(root.right) if root.value == \'+\': return left_value + right_value elif root.value == \'-\': return left_value - right_value elif root.value == \'*\': return left_value * right_value elif root.value == \'/\': return left_value / right_value"},{"question":"# Question You are given a list of strings representing book titles in a library catalog. The titles are sorted in lexicographical order, but some titles appear multiple times due to multiple copies of the same book. Write a function `find_unique_titles(catalog: List[str]) -> List[str]` that returns a list of unique book titles while maintaining the order they appear in the provided catalog. The function should not use any additional data structures beyond what is necessary for the algorithm itself (i.e., you should not use a set or a dictionary to store titles during the operation). Instead, focus on a solution that makes a single pass through the catalog list. # Input - A list `catalog` where each element is a string representing a book title. The titles are sorted in lexicographical order. # Output - A list of unique book titles in the order they appear in the catalog. # Constraints - The length of the catalog can be up to 100,000. - Each title string has a length between 1 and 100 characters. - The titles contain only uppercase and lowercase English letters and spaces. Here is the skeleton of the function you need to implement: ```python from typing import List def find_unique_titles(catalog: List[str]) -> List[str]: # Your implementation here pass def test_find_unique_titles(): # Your test cases here pass if __name__ == \\"__main__\\": test_find_unique_titles() ``` # Example ```python catalog1 = [\\"A Tale of Two Cities\\", \\"A Tale of Two Cities\\", \\"Great Expectations\\", \\"Jane Eyre\\", \\"Jane Eyre\\", \\"Moby Dick\\"] print(find_unique_titles(catalog1)) # Output: [\\"A Tale of Two Cities\\", \\"Great Expectations\\", \\"Jane Eyre\\", \\"Moby Dick\\"] catalog2 = [\\"Harry Potter\\", \\"Harry Potter and the Chamber of Secrets\\", \\"Harry Potter and the Prisoner of Azkaban\\"] print(find_unique_titles(catalog2)) # Output: [\\"Harry Potter\\", \\"Harry Potter and the Chamber of Secrets\\", \\"Harry Potter and the Prisoner of Azkaban\\"] large_catalog = generate_large_catalog() # A large sorted list of book titles with duplicates print(find_unique_titles(large_catalog)) # Output should be tested for large input performance ``` # Performance Consideration Discuss the performance of your algorithm in terms of time complexity and any trade-offs that were made to achieve efficiency. Note that maintaining the order without using extra storage for seen titles ensures that the function operates within the optimal constraints for the problem.","solution":"from typing import List def find_unique_titles(catalog: List[str]) -> List[str]: Returns a list of unique book titles while maintaining the order they appear in the provided catalog. if not catalog: return [] unique_titles = [catalog[0]] # Initialize with the first title last_seen_title = catalog[0] for title in catalog[1:]: if title != last_seen_title: unique_titles.append(title) last_seen_title = title return unique_titles"},{"question":"# Question You are required to implement a function that calculates the nth Fibonacci number using both memoization and tabulation methods. Your implementation should handle large inputs efficiently, ensuring optimal performance. Function Signature ```python def fibonacci_memoization(n: int) -> int: def fibonacci_tabulation(n: int) -> int: ``` Requirements: 1. **Function 1**: `fibonacci_memoization(n: int) -> int` - Use memoization (top-down dynamic programming). - Should raise `ValueError` for negative integer inputs. - Ensure results are computed quickly even for large values of `n` up to 10^5. 2. **Function 2**: `fibonacci_tabulation(n: int) -> int` - Use tabulation (bottom-up dynamic programming). - Should handle inputs within the range of positive integers up to 10^5. - Ensure the solution performs efficiently without unnecessary recomputation. Input - `n`: A non-negative integer representing the position in the Fibonacci sequence for which the value needs to be computed. Output - Returns an integer representing the nth Fibonacci number. Constraints - `n` value must be a non-negative integer within the range `[0, 10^5]`. - Performance should be optimized to handle large inputs efficiently. Example ```python >>> fibonacci_memoization(10) 55 ``` ```python >>> fibonacci_tabulation(10) 55 ``` Scenario Consider providing an accurate and efficient solution, taking into account potential performance bottlenecks, especially for large inputs. Ensure both functions handle edge cases gracefully, including the case for `n = 0` and very large values close to the upper limit.","solution":"def fibonacci_memoization(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") memo = {0: 0, 1: 1} def fib_memo(n): if n in memo: return memo[n] memo[n] = fib_memo(n-1) + fib_memo(n-2) return memo[n] return fib_memo(n) def fibonacci_tabulation(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Problem Statement A sequence of moves on a 2D grid is represented by a string containing only the characters \'U\', \'D\', \'L\', \'R\' which represent moving up, down, left, and right respectively. Write a function to determine if a sequence of moves returns to the starting point. # Detailed Requirements * Define a function `returns_to_start(moves: str) -> bool` that evaluates the sequence. - \'U\' increments the Y-coordinate. - \'D\' decrements the Y-coordinate. - \'L\' decrements the X-coordinate. - \'R\' increments the X-coordinate. * The function should return `True` if the sequence returns to the starting point (0, 0) and `False` otherwise. # Input and Output - **Input**: A string `moves` representing the sequence of moves. - **Output**: A boolean value, `True` if the sequence brings you back to the starting point, otherwise `False`. # Constraints 1. The input string `moves` can have a length from 1 to 1000. 2. The input string contains only the characters \'U\', \'D\', \'L\', and \'R\'. # Example Case ```python returns_to_start(\\"UDLR\\") -> True returns_to_start(\\"UUDDLRL\\") -> False ``` # Explanation: The function takes the sequence of characters and simulates the movements on a 2D grid starting from (0, 0). In the first example, all movements cancel each other out, bringing the point back to the start, hence the function returns `True`. In the second example, the movements do not cancel each other out completely, hence the function returns `False`.","solution":"def returns_to_start(moves: str) -> bool: Determines if a sequence of moves on a 2D grid returns to the starting point. Parameters: moves (str): A string containing sequences of \'U\', \'D\', \'L\', \'R\'. Returns: bool: True if the sequence returns to the starting point, otherwise False. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Implement a Python function `find_kth_perfect_number` that takes an integer `k` and returns the k-th perfect number. A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding itself. # Requirements: 1. The function should handle edge cases such as non-positive `k`. 2. The function should return -1 for invalid inputs. # Input: - `k`: Integer representing the position in the sequence of perfect numbers. # Output: - The k-th perfect number as an integer. # Function Signature ```python def find_kth_perfect_number(k: int) -> int: pass ``` # Example ```python # Example usage: # Find the 1st perfect number: print(find_kth_perfect_number(1)) # Output: 6 # Find the 2nd perfect number: print(find_kth_perfect_number(2)) # Output: 28 # Find the 3rd perfect number: print(find_kth_perfect_number(3)) # Output: 496 # Find the 4th perfect number: print(find_kth_perfect_number(4)) # Output: 8128 # Handle invalid input: print(find_kth_perfect_number(0)) # Output: -1 print(find_kth_perfect_number(-1)) # Output: -1 ``` # Constraints: - The function must verify that `k` is a positive integer. - The function needs to be optimized to efficiently find the k-th perfect number, considering they are sparse. # Notes: - Use helper functions (`find_divisors`, `is_perfect_number`) to assist with your implementation. - Ensure appropriate error handling for edge cases. - Consider using properties of perfect numbers related to Mersenne primes for optimization.","solution":"def find_divisors(n): Returns a list of proper divisors of n (excluding the number itself). divisors = [] for i in range(1, n // 2 + 1): if n % i == 0: divisors.append(i) return divisors def is_perfect_number(n): Checks if the number n is a perfect number. return sum(find_divisors(n)) == n def find_kth_perfect_number(k): Finds the k-th perfect number. if k <= 0: return -1 perfect_numbers = [] num = 2 # Start checking from the smallest number greater than 1 while len(perfect_numbers) < k: if is_perfect_number(num): perfect_numbers.append(num) num += 1 return perfect_numbers[k-1]"},{"question":"# Problem Statement You are given a `n x n` matrix filled with integers where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Write a function `find_kth_smallest(matrix: List[List[int]], k: int) -> int` to find the k-th smallest element in the matrix. **Constraints**: 1. The input matrix will have dimensions within the range [1, 300]. 2. 1 ≤ k ≤ n*n 3. -10^9 ≤ matrix[i][j] ≤ 10^9 **Input**: - `matrix`: List of lists of integers (n x n) representing the matrix. - `k`: An integer representing the k-th smallest position (1-indexed). **Output**: - An integer representing the k-th smallest element in the matrix. **Example**: ```python # Example 1 matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 assert find_kth_smallest(matrix, k) == 13 # Example 2 matrix = [ [ -5, -4, -3], [ -2, 1, 2], [ 3, 4, 5] ] k = 4 assert find_kth_smallest(matrix, k) == -2 ``` **Explanation**: - In the first example, the kth(8th) smallest element in the matrix [1, 5, 9, 10, 11, 12, 13, 13, 15] is 13. - In the second example, the kth(4th) smallest element in the matrix [-5, -4, -3, -2, 1, 2, 3, 4, 5] is -2.","solution":"from typing import List import heapq def find_kth_smallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in the n x n matrix. n = len(matrix) min_heap = [] # Initialize pointers for the smallest element in each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the smallest element from the heap k-1 times # The kth smallest element will then be at the root of the heap. while k > 0: element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"# Problem Statement Create a function `balance_characters(text: str) -> bool` that checks whether a given string of characters is balanced. A string is considered balanced if each character that can be open has a corresponding close character and each pair of characters is properly nested. # Requirements and Constraints 1. **Input**: - `text`: A string containing any of the characters `()`, `{}`, `[]`. 2. **Output**: - Returns a boolean value indicating whether the input string is balanced. 3. **Constraints**: - The length of the input string is at most 10,000 characters. - The input string contains only the characters `()`, `{}`, `[]`. # Example **Input**: ```python text = \\"{[()]}\\" ``` **Output**: ```python True ``` **Input**: ```python text = \\"({[)]}\\" ``` **Output**: ```python False ``` # Instructions 1. Implement the function `balance_characters(text: str) -> bool` that determines if the input string is balanced. 2. The function should use a stack to help ensure that each opening character has a corresponding closing character and that the pairs are properly nested. 3. Test your function with various inputs to verify correctness. ```python def balance_characters(text: str) -> bool: stack = [] matching_pairs = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in text: if char in matching_pairs.values(): stack.append(char) elif char in matching_pairs.keys(): if stack == [] or matching_pairs[char] != stack.pop(): return False else: continue return stack == [] # Example usage: # text = \\"{[()]}\\" # result = balance_characters(text) ```","solution":"def balance_characters(text: str) -> bool: Returns True if the given text has balanced characters, otherwise False. stack = [] matching_pairs = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in text: if char in matching_pairs.values(): stack.append(char) elif char in matching_pairs.keys(): if stack == [] or matching_pairs[char] != stack.pop(): return False else: continue return stack == [] # Example usage: # text = \\"{[()]}\\" # result = balance_characters(text)"},{"question":"# Question: You are provided with a list of integers where each integer represents the height of a pillar. Your task is to compute the maximum area of water that can be contained between any two pillars, where the width between any two pillars is determined by the number of pillars between them including the pillars themselves. Write a Python function `max_water_area` that takes a list of integers representing the heights of the pillars and returns the maximum area of water that can be contained. Input Format: - A single list of integers `heights` (2 ≤ length ≤ 1000, 0 ≤ heights[i] ≤ 1000). Output Format: - A single integer representing the maximum area of water that can be contained between any two pillars. Constraints: - The function should efficiently compute the maximum area with an optimal solution. - Consider the usage of a two-pointer technique to ensure optimal time complexity. - Edge cases such as where all heights are zero should be handled gracefully. Example: ```python def max_water_area(heights: list) -> int: pass assert max_water_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_water_area([1, 1]) == 1 assert max_water_area([4, 3, 2, 1, 4]) == 16 assert max_water_area([1, 2, 1]) == 2 assert max_water_area([0, 0, 0, 0]) == 0 ``` Provide your implementation of the `max_water_area` function below: ```python def max_water_area(heights: list) -> int: left, right = 0, len(heights) - 1 max_area = 0 while left < right: # Calculate the width and current area width = right - left current_area = min(heights[left], heights[right]) * width # Update max_area if the current area is larger max_area = max(max_area, current_area) # Move the pointers based on the height comparison if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area # Test cases for validation print(max_water_area([1, 8, 6, 2, 5, 4, 8, 3, 7])) # Expected: 49 print(max_water_area([1, 1])) # Expected: 1 print(max_water_area([4, 3, 2, 1, 4])) # Expected: 16 print(max_water_area([1, 2, 1])) # Expected: 2 print(max_water_area([0, 0, 0, 0])) # Expected: 0 ``` Ensure your function efficiently handles various edge cases and optimizes for performance and memory utilization.","solution":"def max_water_area(heights: list) -> int: left, right = 0, len(heights) - 1 max_area = 0 while left < right: # Calculate the width and current area width = right - left current_area = min(heights[left], heights[right]) * width # Update max_area if the current area is larger max_area = max(max_area, current_area) # Move the pointers based on the height comparison if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Find the Unique Element in an Array of Pairs You are given an array of integers where every element appears exactly twice except for one element which appears only once. Implement a function that finds and returns the element that appears only once. # Function Signature ```python def find_unique_element(arr: list[int]) -> int: ``` # Input - A list of integers `arr` where: - Each integer appears exactly twice except for one integer which appears exactly once. - The list is not empty and contains at most `10^5` elements. # Output - Return the integer that appears only once in the list. # Constraints - The length of `arr` is at most `10^5`. - All integers in `arr` are between `-10^5` and `10^5`. # Examples 1. Input: `[4, 1, 2, 1, 2]` Output: `4` 2. Input: `[2, 2, 3, 3, 7, 5, 5]` Output: `7` 3. Input: `[7]` Output: `7` # Explanation - **Example 1**: All elements except 4 appear twice, so the unique element is 4. - **Example 2**: All elements except 7 appear twice, so the unique element is 7. - **Example 3**: The array has only one element which is 7, and it\'s unique. # Performance Requirements The function should be able to efficiently find the unique element in an input array of length up to `10^5`, ideally with a time complexity of O(n). # Notes - A potential approach could be using the XOR bitwise operator since XOR-ing two identical numbers results in 0 and XOR-ing a number with 0 results in the number itself. - Consider edge cases such as arrays with the minimum and maximum possible values of integers, as well as the smallest array size containing just one element. Implement the function `find_unique_element` to solve this problem.","solution":"def find_unique_element(arr: list[int]) -> int: Finds the unique element in a list where every other element appears exactly twice. Uses the XOR property which cancels out identical numbers. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Coding Assessment Question Scenario You are working on a weather data analysis project. Your task is to determine the number of continuous subarrays within a given array of daily temperatures where the temperatures consistently increase day by day. Task Implement a function `count_increasing_subarrays` that computes the number of continuous subarrays within a given list of temperatures where every element is greater than the previous one. Function Signature ```python def count_increasing_subarrays(temperatures: list[int]) -> int: pass ``` Input * `temperatures`: A list of integers representing the daily temperatures. Output * Returns an integer that is the count of subarrays where each element is greater than the previous one. Constraints * The length of the temperatures list is between 0 and 10^5. Performance Requirement * Aim for O(n) time complexity. Example ```python >>> count_increasing_subarrays([1, 3, 2, 4, 5]) 4 >>> count_increasing_subarrays([1, 2, 3, 4]) 10 >>> count_increasing_subarrays([4, 3, 2, 1]) 0 >>> count_increasing_subarrays([]) 0 ``` Explanation 1. In the first example, the subarrays are: * [1, 3] * [2, 4] * [4, 5] * [2, 4, 5] 2. In the second example, the subarrays are: * [1, 2] * [2, 3] * [3, 4] * [1, 2, 3] * [2, 3, 4] * [1, 2, 3, 4] 3. In the third example, there are no increasing subarrays. 4. In the fourth example, there are no elements, so the count is 0. Edge Cases * Verify behavior with an empty temperatures list which should return 0. * Check for handling of lists with one element which should return 0 because there can\'t be any subarrays. Additional Challenge Consider optimizing the implementation to use as little memory as possible.","solution":"def count_increasing_subarrays(temperatures: list[int]) -> int: n = len(temperatures) if n == 0: return 0 count = 0 length = 1 for i in range(1, n): if temperatures[i] > temperatures[i - 1]: length += 1 else: if length > 1: count += (length * (length - 1)) // 2 length = 1 if length > 1: count += (length * (length - 1)) // 2 return count"},{"question":"# Problem Statement You are provided with a function that needs to format a given list of integers into a string with a specific pattern. The pattern requires that you group numbers into pairs, separate these pairs with a hyphen, and within each pair, separate the numbers with a comma. If there is an odd number of integers, the final group will contain just one number. Your task is to implement this function with the following detailed specifications: 1. If the list is empty, the function should return an empty string. 2. If the list contains only one integer, return it as a string without any delimiters. 3. Ensure the formatted string follows the pattern described above. 4. Optimize the function to handle large lists efficiently. # Function Signature ```python def format_pairs(numbers: list) -> str: Format a given list of integers into a string with the pattern: pairs separated by hyphens and numbers within pairs separated by commas. Parameters: numbers (list): A list of integers to format. Returns: str: The formatted string. Examples: >>> format_pairs([1, 2, 3, 4, 5]) \'1,2-3,4-5\' >>> format_pairs([10, 20, 30]) \'10,20-30\' >>> format_pairs([7]) \'7\' >>> format_pairs([]) \'\' >>> format_pairs([1, 2, 3, 4, 5, 6, 7, 8]) \'1,2-3,4-5,6-7,8\' pass ``` # Constraints * The input list will always contain non-negative integers. * Consider edge cases such as an empty list and lists with a single number. * Avoid excessive string operations that might impact performance. # Expected Complexity * Ensure that your solution runs with a linear time complexity O(n), where n is the length of the list. * Be mindful of space complexity as well, aiming for O(n). # Notes * Test cases will be provided to check for correctness and efficiency. * Think about possible performance bottlenecks and how to overcome them.","solution":"def format_pairs(numbers: list) -> str: Format a given list of integers into a string with the pattern: pairs separated by hyphens and numbers within pairs separated by commas. Parameters: numbers (list): A list of integers to format. Returns: str: The formatted string. Examples: >>> format_pairs([1, 2, 3, 4, 5]) \'1,2-3,4-5\' >>> format_pairs([10, 20, 30]) \'10,20-30\' >>> format_pairs([7]) \'7\' >>> format_pairs([]) \'\' >>> format_pairs([1, 2, 3, 4, 5, 6, 7, 8]) \'1,2-3,4-5,6-7,8\' if not numbers: return \\"\\" formatted_pairs = [] i = 0 while i < len(numbers): if i + 1 < len(numbers): formatted_pairs.append(f\\"{numbers[i]},{numbers[i+1]}\\") i += 2 else: formatted_pairs.append(f\\"{numbers[i]}\\") break return \\"-\\".join(formatted_pairs)"},{"question":"# Problem Statement You are tasked with creating a function to perform basic matrix operations. Specifically, you need to implement a function to add two matrices. The function should adhere to the following specifications: # Function Signature ```python def add_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Add two matrices and return the resulting matrix. Args: matrix1 - The first matrix represented as a list of lists of integers. matrix2 - The second matrix represented as a list of lists of integers. Returns: A matrix represented as a list of lists of integers, which is the result of adding matrix1 and matrix2. Raises: ValueError - If the dimensions of the two matrices do not match. pass ``` # Input - `matrix1`: A list of lists of integers representing the first matrix. Each inner list represents a row in the matrix. - `matrix2`: A list of lists of integers representing the second matrix. Each inner list represents a row in the matrix. # Output - A list of lists of integers representing the resulting matrix after adding the corresponding elements of `matrix1` and `matrix2`. # Constraints - Both matrices will have the same dimensions. - Each dimension of the matrices will be at least 1x1 and at most 1000x1000. - Each element in the matrices is an integer between -10^9 and 10^9. - If the dimensions of the matrices do not match, the function should raise a ValueError. # Performance Requirements - The solution should handle the largest possible matrices efficiently, ideally in line with O(n * m), where `n` is the number of rows and `m` is the number of columns. # Example Given the input matrices: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` The output should be: ```python [ [10, 10, 10], [10, 10, 10], [10, 10, 10] ] ``` # Edge Cases - An empty matrix (0x0 dimension) should not occur as input. - Matrices with different dimensions should raise a ValueError. - Large matrices should be handled efficiently to avoid performance issues. Make sure your implementation is robust and handles all specified edge cases correctly. You should write your own tests to validate the correctness of your solution.","solution":"from typing import List def add_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Add two matrices and return the resulting matrix. Args: matrix1 - The first matrix represented as a list of lists of integers. matrix2 - The second matrix represented as a list of lists of integers. Returns: A matrix represented as a list of lists of integers, which is the result of adding matrix1 and matrix2. Raises: ValueError - If the dimensions of the two matrices do not match. if not matrix1 or not matrix2 or len(matrix1) != len(matrix2) or len(matrix1[0]) != len(matrix2[0]): raise ValueError(\\"The dimensions of the two matrices do not match.\\") result = [] for row1, row2 in zip(matrix1, matrix2): result_row = [a + b for a, b in zip(row1, row2)] result.append(result_row) return result"},{"question":"# Scenario You are tasked with developing software for an e-commerce platform that needs to determine the optimal order of order processing based on priority and submission time. Each order has a priority level and a submission timestamp. Higher priority orders should be processed first. If two orders have the same priority, the one with the earlier submission time should be processed first. # Question Write a function `optimal_order_processing(orders: List[Tuple[int, str]]) -> List[Tuple[int, str]]` to determine the optimal order processing sequence. The function should return a list of orders sorted by their priority in descending order, and by submission time in ascending order if priorities are the same. 1. **orders**: A list of tuples where each tuple consists of two elements: - `priority`: An integer representing the priority level of the order (higher value indicates higher priority). - `timestamp`: A string representing the submission time of the order in the format \\"YYYY-MM-DD HH:MM:SS\\". # Input/Output Format - **Input**: - `orders`: a list of tuples, with each tuple having an integer and a string. - **Output**: - A list of tuples sorted based on the described criteria. # Constraints - Assume the maximum length of the input list (orders) is (10^6). - The input timestamps are in a valid and consistent format. - All integer values for priorities are within a reasonable range for comparison. # Examples ```python assert optimal_order_processing([(4, \\"2023-01-01 10:00:00\\"), (3, \\"2023-01-01 09:00:00\\"), (4, \\"2023-01-01 09:00:00\\")]) == [(4, \\"2023-01-01 09:00:00\\"), (4, \\"2023-01-01 10:00:00\\"), (3, \\"2023-01-01 09:00:00\\")] assert optimal_order_processing([(1, \\"2022-05-01 13:45:20\\"), (2, \\"2021-05-01 10:15:00\\"), (1, \\"2022-05-01 13:45:21\\")]) == [(2, \\"2021-05-01 10:15:00\\"), (1, \\"2022-05-01 13:45:20\\"), (1, \\"2022-05-01 13:45:21\\")] assert optimal_order_processing([(5, \\"2023-08-15 12:30:00\\"), (5, \\"2023-08-15 12:30:01\\"), (3, \\"2023-08-14 11:00:00\\")]) == [(5, \\"2023-08-15 12:30:00\\"), (5, \\"2023-08-15 12:30:01\\"), (3, \\"2023-08-14 11:00:00\\")] assert optimal_order_processing([(2, \\"2021-04-21 09:30:00\\"), (2, \\"2021-04-21 09:30:00\\"), (1, \\"2021-04-21 09:00:00\\")]) == [(2, \\"2021-04-21 09:30:00\\"), (2, \\"2021-04-21 09:30:00\\"), (1, \\"2021-04-21 09:00:00\\")] ```","solution":"from typing import List, Tuple def optimal_order_processing(orders: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Determines the optimal order processing sequence based on priority and submission time. :param orders: List[Tuple[int, str]] - A list of tuples where each tuple includes an integer (priority) and a string (timestamp). :return: List[Tuple[int, str]] - The list of orders sorted by priority and submission time. return sorted(orders, key=lambda order: (-order[0], order[1]))"},{"question":"# Unique Character Frequency ***Scenario:*** You are working on a text analysis tool that generates summaries of documents based on the frequency of unique characters. In this task, you need to implement a function that takes a string input and returns a dictionary where each key is a unique character from the string, and the value is the count of that character in the string. # Problem Statement Implement a function `unique_char_frequency(text: str) -> dict` that calculates and returns the frequency of each unique character in a given string. # Function Signature ```python def unique_char_frequency(text: str) -> dict: pass ``` # Input * `text` (1 <= len(`text`) <= 100,000): A string consisting of characters (including letters, digits, punctuation, and whitespace). # Output * A dictionary where each key is a unique character from the input string, and the value is the number of occurrences of that character. # Examples 1. Input: `text = \\"hello\\"` Output: `{\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1}` 2. Input: `text = \\"aabbcc\\"` Output: `{\'a\': 2, \'b\': 2, \'c\': 2}` 3. Input: `text = \\"123 321\\"` Output: `{\'1\': 2, \'2\': 2, \'3\': 2, \' \': 1}` # Constraints or Considerations * Ensure your solution handles large strings efficiently. * Consider the performance for strings with diverse character sets. * Do not assume any restrictions on the character set apart from what the standard ASCII text may contain. # Performance Requirements * Expected to execute within reasonable time limits even for the upper bounds of input size. Remember to handle edge cases properly and document your code for clarity. Use concise comments to explain key parts of your implementation.","solution":"def unique_char_frequency(text: str) -> dict: Calculates the frequency of each unique character in the given string. Parameters: text (str): The input string. Returns: dict: A dictionary with each unique character as keys and their counts as values. frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Problem Statement You are required to implement a function that calculates the n-th Fibonacci number using memoization to optimize the calculation. Additionally, you should also implement a method that computes the n-th Fibonacci number using matrix exponentiation for even greater efficiency. # Function 1: `fibonacci_memo(n: int) -> int` * **Input Parameters**: - `n` (int): A non-negative integer representing the position in the Fibonacci sequence. * **Output**: - Returns an integer representing the n-th Fibonacci number. * **Constraints**: - 0 <= `n` <= 10^4. # Function 2: `fibonacci_matrix(n: int) -> int` * **Input Parameters**: - `n` (int): A non-negative integer representing the position in the Fibonacci sequence. * **Output**: - Returns an integer representing the n-th Fibonacci number. * **Constraints**: - 0 <= `n` <= 10^18. # Requirements: 1. Implement `fibonacci_memo(n: int) -> int` using memoization. 2. Implement `fibonacci_matrix(n: int) -> int` using matrix exponentiation for optimal time complexity. # Examples: Example 1 ```python >>> fibonacci_memo(10) 55 ``` Example 2 ```python >>> fibonacci_matrix(10) 55 ``` Example 3 ```python >>> fibonacci_memo(50) 12586269025 ``` Example 4 ```python >>> fibonacci_matrix(100) 354224848179261915075 ``` # Explanation: 1. `fibonacci_memo(10)` and `fibonacci_matrix(10)` both return 55, as the 10th Fibonacci number is 55. 2. `fibonacci_memo(50)` returns 12586269025 because it successfully uses memoization to compute the 50th Fibonacci number. 3. `fibonacci_matrix(100)` returns 354224848179261915075, efficiently calculating the 100th Fibonacci number using matrix exponentiation.","solution":"def fibonacci_memo(n: int) -> int: Calculates the n-th Fibonacci number using memoization. memo = {0: 0, 1: 1} def fib(n): if n not in memo: memo[n] = fib(n - 1) + fib(n - 2) return memo[n] return fib(n) def fibonacci_matrix(n: int) -> int: Calculates the n-th Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 def multiply_matrices(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_exponentiation(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_exponentiation(F, n - 1) return result_matrix[0][0]"},{"question":"# Context You have been hired to help enhance the security of an ecommerce platform by identifying potentially harmful user activities. As part of this, you need to analyze sequences of operations performed by users within certain time windows. # Task Implement a function `detect_pattern_activity(logs: List[Tuple[int, str]], time_window: int) -> List[str]` that identifies user IDs with a specific sequence of operations within the given time window. The sequence of operations to detect is: \\"login\\", \\"view_item\\", \\"add_to_cart\\", \\"checkout\\". # Input and Output * **Input**: * `logs` (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer timestamp and a string representing an operation and user ID in the format `\\"operation:user_id\\"`. * `time_window` (int): The time window (in seconds) within which to detect the pattern sequence. * **Output**: * A list of user IDs who have performed the sequence of operations within the specified time window. If no such pattern exists, return an empty list. # Constraints * Each log entry will have a distinct timestamp. * The operations \\"login\\", \\"view_item\\", \\"add_to_cart\\", and \\"checkout\\" will always be in the exact order specified for a valid pattern. # Example ```python example_logs = [ (1, \\"login:user1\\"), (2, \\"view_item:user1\\"), (3, \\"add_to_cart:user1\\"), (4, \\"checkout:user1\\"), (5, \\"login:user2\\"), (6, \\"view_item:user2\\"), (8, \\"add_to_cart:user2\\"), (10, \\"checkout:user2\\"), (11, \\"login:user3\\"), (15, \\"view_item:user3\\"), (20, \\"add_to_cart:user3\\"), (30, \\"checkout:user3\\") ] print(detect_pattern_activity(example_logs, 5)) # Expected Output: [\'user1\', \'user2\'] print(detect_pattern_activity(example_logs, 10)) # Expected Output: [\'user1\', \'user2\', \'user3\'] ``` # Performance Requirements The function should efficiently handle logs up to a length of 100,000 entries and support time windows up to 10,000 seconds. # Note Assume the logs are already sorted by timestamp and you do not need to handle input validation.","solution":"def detect_pattern_activity(logs, time_window): Detects user activity patterns within the given time window. Args: logs (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer timestamp and a string representing an operation and user ID in the format \\"operation:user_id\\". time_window (int): The time window (in seconds) within which to detect the pattern sequence. Returns: List[str]: A list of user IDs who have performed the sequence of operations within the specified time window. pattern = [\\"login\\", \\"view_item\\", \\"add_to_cart\\", \\"checkout\\"] user_operations = {} result = set() for timestamp, op_string in logs: op, user_id = op_string.split(\\":\\") if user_id not in user_operations: user_operations[user_id] = [] user_operations[user_id].append((timestamp, op)) # Check for the pattern in the user operations if len(user_operations[user_id]) >= 4: last_operations = user_operations[user_id][-4:] if [op for ts, op in last_operations] == pattern: if last_operations[-1][0] - last_operations[0][0] <= time_window: result.add(user_id) return list(result)"},{"question":"# Context You are developing a new feature for a social media application that needs to construct user-friendly URLs based on user profile names. A key part of this feature is generating \\"slugs\\" from profile names. # Task Implement a function `generate_slug` that converts a given string into a slug format. A slug is a URL-friendly version of a string, typically used for URLs and identifiers. # Requirements * Your function should take one parameter: a string `profile_name`. * Convert all characters to lowercase. * Replace any sequence of spaces or non-alphanumeric characters (excluding underscores) with a single hyphen. * Any leading or trailing hyphens should be removed. * The function should handle empty strings and return an empty string if the input is empty. * Add docstring and appropriate error handling as seen in the provided code snippets. # Function Signature ```python def generate_slug(profile_name: str) -> str: pass ``` # Example Usage ```python >>> generate_slug(\'John Doe\') \'john-doe\' >>> generate_slug(\'Hello, World!\') \'hello-world\' >>> generate_slug(\' Ninja_coder 007 \') \'ninja_coder-007\' >>> generate_slug(\'Python@3.8!\') \'python-3-8\' >>> generate_slug(\'\') \'\' ``` # Constraints and Considerations * You may use Python\'s standard library but avoid external libraries. * Ensure efficient and clear handling of different input cases, including empty strings and strings with special characters. * Focus on edge cases such as multiple consecutive spaces, special characters, and mixed case strings. * Make sure the function is robust and handles a wide range of inputs consistently.","solution":"import re def generate_slug(profile_name: str) -> str: Converts the input profile name to a slug format. Args: - profile_name (str): The profile name to be converted into a slug. Returns: - str: The generated slug. # Convert to lowercase profile_name = profile_name.lower() # Replace any sequence of spaces or non-alphanumeric characters (excluding underscores) with a single hyphen profile_name = re.sub(r\'[^a-z0-9_]+\', \'-\', profile_name) # Remove leading and trailing hyphens profile_name = profile_name.strip(\'-\') return profile_name"},{"question":"# Duplicate Number in a Range You are given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. There is exactly one duplicate number in `nums`, but it could be repeated more than once. Your task is to find the duplicate number without modifying the array and using constant extra space. **Function Signature**: ```python def find_duplicate(nums: list[int]) -> int: pass ``` # Input: * `nums` (list of integers): An array of integers where (1 leq text{len}(nums) leq 10^5). * Each element `nums[i]` is an integer such that (1 leq text{nums[i]} leq text{len}(nums) - 1). # Output: * Returns an integer representing the duplicate number in the array. # Examples: ```python >>> find_duplicate([1,3,4,2,2]) 2 >>> find_duplicate([3,1,3,4,2]) 3 ``` # Constraints: * You must solve the problem without modifying the input array (`nums`). * You must solve it using only constant extra space. * Your algorithm should run in linear time, (O(n)). # Requirements: 1. Utilize Floyd\'s Tortoise and Hare (Cycle Detection) algorithm to find the duplicate number efficiently without extra space. 2. Handle edge cases such as arrays where the duplicate appears at the beginning or end of the array. 3. Ensure the function returns the correct duplicate even if it appears multiple times. # Example Explanation: For `nums = [1, 3, 4, 2, 2]`, the duplicate number `2` appears twice in the array. Thus, the function should return `2`. For `nums = [3, 1, 3, 4, 2]`, the duplicate number `3` appears twice in the array. Thus, the function should return `3`.","solution":"def find_duplicate(nums): Returns the duplicate number in the list using Floyd\'s Tortoise and Hare algorithm. # Initialize the tortoise and hare tortoise = nums[0] hare = nums[0] while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"# Circular Linked List Operations You are required to implement a class representing a Circular Singly Linked List (CSLL) with essential operations like insertion, deletion, traversal, and finding the length of the list. Specifically, you need to create methods for these operations ensuring efficiency and maintaining the circular nature of the list: 1. **Node Insertions** - Insert elements at the end of the list while maintaining the circular link property. 2. **Element Deletion** - Implement node deletion effectively, considering various cases such as deleting the only node, deleting the head node, and deleting nodes from the middle/end. 3. **Traversal** - Perform traversal operations to retrieve a list of node values, showcasing the circular structure. 4. **Find List Length** - Calculate and return the length of the circular linked list. Implementation Details: 1. Create a `Node` data class to represent each node in the CSLL. 2. Implement a `CircularLinkedList` class that should support: - `insert(value: int) -> None`: Insert a single value into the CSLL. - `delete(value: int) -> bool`: Delete a value from the CSLL if it exists, returning `True` if the deletion was successful and `False` otherwise. - `traverse() -> List[int]`: Return a list of node values reflecting a complete cycle once through the CSLL. - `length() -> int`: Return the number of nodes in the CSLL. - `empty() -> bool`: Check if the list is empty. Constraints: - The CSLL starts empty. - Duplicate values cannot coexist in the list. - Deleting a non-existent value should not affect the list or produce an error. Example Usage: ```python >>> cll = CircularLinkedList() >>> cll.insert(10) >>> cll.insert(20) >>> cll.insert(30) >>> assert cll.traverse() == [10, 20, 30] >>> assert cll.length() == 3 >>> assert not cll.empty() >>> assert cll.delete(20) is True >>> assert cll.traverse() == [10, 30] >>> assert cll.length() == 2 >>> cll.insert(40) >>> assert cll.traverse() == [10, 30, 40] >>> assert cll.delete(50) is False >>> assert cll.traverse() == [10, 30, 40] # Nothing deleted since 50 does not exist. >>> assert cll.delete(10) is True >>> assert cll.traverse() == [30, 40] >>> cll.delete(30) >>> cll.delete(40) >>> assert cll.empty() is True ``` Submit your implementation with the following function and class signatures: ```python from typing import Optional, List class Node: def __init__(self, value: int, next: \'Optional[Node]\' = None) -> None: self.value: int = value self.next: Optional[Node] = next class CircularLinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int) -> None: pass def delete(self, value: int) -> bool: pass def traverse(self) -> List[int]: pass def length(self) -> int: pass def empty(self) -> bool: pass ```","solution":"from typing import Optional, List class Node: def __init__(self, value: int, next: \'Optional[Node]\' = None) -> None: self.value: int = value self.next: Optional[Node] = next class CircularLinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node new_node.next = new_node else: current = self.head while current.next != self.head: current = current.next current.next = new_node new_node.next = self.head def delete(self, value: int) -> bool: if not self.head: return False current = self.head prev = None found = False while True: if current.value == value: found = True break prev = current current = current.next if current == self.head: break if not found: return False if current == self.head: if current.next == self.head: self.head = None else: prev = self.head while prev.next != self.head: prev = prev.next self.head = current.next prev.next = self.head else: prev.next = current.next return True def traverse(self) -> List[int]: if not self.head: return [] result = [] current = self.head while True: result.append(current.value) current = current.next if current == self.head: break return result def length(self) -> int: if not self.head: return 0 count = 0 current = self.head while True: count += 1 current = current.next if current == self.head: break return count def empty(self) -> bool: return self.head is None"},{"question":"# Problem Statement Context: In robotics and automation, it often becomes necessary to execute a series of sequential commands. These commands might move a robotic arm to pick and place objects. Given a description of such a sequence, you must determine if all operations are valid and can be executed without error. Problem: Your task is to write a function that validates if a given sequence of commands adheres to the operational constraints of the robotic arm. The robotic arm starts at position 0 and can only move within a specified range. Function Signature: ```python def validate_robot_commands(commands: List[str], pos_range: Tuple[int, int]) -> bool: pass ``` # Input: 1. `commands` (List of str): A list of command strings where each command can be `\'LEFT\'`, `\'RIGHT\'`, `\'PICK\'`, or `\'PLACE\'`. 2. `pos_range` (Tuple of int): A tuple containing two integers representing the minimum and maximum positions the robotic arm can move to, inclusive. # Output: * Return a boolean value indicating whether all commands can be executed successfully without violating the constraints. # Constraints: - Each command string will be one of `\'LEFT\'`, `\'RIGHT\'`, `\'PICK\'`, or `\'PLACE\'`. - The position range will consist of two integers where the first number is less than or equal to the second. - The robotic arm maintains the ability to pick up or place an object only if there is one to be picked or placed, ensuring `PICK` comes before `PLACE`. # Examples: ```python >>> validate_robot_commands([\'RIGHT\', \'RIGHT\', \'PICK\', \'LEFT\', \'PLACE\'], (0, 2)) True >>> validate_robot_commands([\'RIGHT\', \'PICK\', \'RIGHT\', \'PLACE\', \'RIGHT\'], (0, 2)) False ``` # Notes: - Assume the robotic arm picks up or places exactly one object at a time and starts without holding any object. - Validate that the robotic arm does not move beyond specified positions in the range, i.e., it should not go below the minimum or above the maximum position. - The robotic arm should start without holding any objects, and no `PLACE` command should occur unless a `PICK` command has happened prior in the sequence. - Efficiently manage the sequence of commands to ensure real-time operation viability.","solution":"def validate_robot_commands(commands, pos_range): Validates if the given sequence of commands adheres to the operational constraints of the robotic arm. commands: List of str - A list of command strings. pos_range: Tuple of (int, int) - The minimum and maximum positions. returns: bool - Whether the commands can be executed successfully. current_position = 0 min_pos, max_pos = pos_range is_holding = False # To track if the robot is holding an object for command in commands: if command == \\"LEFT\\": current_position -= 1 elif command == \\"RIGHT\\": current_position += 1 elif command == \\"PICK\\": if is_holding: return False # Can\'t pick if already holding an object is_holding = True elif command == \\"PLACE\\": if not is_holding: return False # Can\'t place if not holding an object is_holding = False else: return False # Invalid command # Check if current position is within the range if current_position < min_pos or current_position > max_pos: return False # All commands are valid return True"},{"question":"Prime Factorization and Least Common Multiple # Context: Prime factorization is the process of determining the prime numbers that multiply together to give a certain original number. The least common multiple (LCM) of two integers is the smallest positive integer that is divisible by both. # Task: Implement a function `prime_lcm(a: int, b: int) -> int`. This function should compute the LCM of two numbers using their prime factorizations. # Function Signature: ```python def prime_lcm(a: int, b: int) -> int: ``` # Input: * **a (int)**: First number, (1 le a le 10^{6}) * **b (int)**: Second number, (1 le b le 10^{6}) # Output: * **int**: The LCM of (a) and (b) # Constraints: * Both (a) and (b) are positive integers. # Example: ```python assert prime_lcm(12, 15) == 60 assert prime_lcm(100, 75) == 300 ``` # Notes: To efficiently compute the prime factorization of a number, you can use the Sieve of Eratosthenes to first generate all prime numbers up to (10^6). Then, use those primes to determine the prime factors of (a) and (b). The LCM can be computed by taking the highest power of each prime that appears in the factorizations of (a) and (b). Here\'s a helper function to get you started with the Sieve of Eratosthenes: ```python def sieve(limit: int) -> list: is_prime = [True] * (limit + 1) p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, limit + 1) if is_prime[p]] return primes def prime_factors(n: int, primes: list) -> dict: factors = {} for prime in primes: while n % prime == 0: if prime not in factors: factors[prime] = 0 factors[prime] += 1 n //= prime if n == 1: break if n > 1: factors[n] = 1 return factors ``` Use these helper functions within your `prime_lcm` implementation to compute the least common multiple efficiently.","solution":"def sieve(limit: int) -> list: Generates a list of prime numbers up to the given limit using the Sieve of Eratosthenes algorithm. is_prime = [True] * (limit + 1) is_prime[0], is_prime[1] = False, False p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, limit + 1) if is_prime[p]] return primes def prime_factors(n: int, primes: list) -> dict: Returns a dictionary where keys are the prime factors of n and values are their respective powers. factors = {} for prime in primes: while n % prime == 0: if prime not in factors: factors[prime] = 0 factors[prime] += 1 n //= prime if n == 1: break if n > 1: factors[n] = 1 return factors def prime_lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of the numbers a and b using their prime factorizations. primes = sieve(10**6) factors_a = prime_factors(a, primes) factors_b = prime_factors(b, primes) lcm_factors = {} for prime in set(factors_a.keys()).union(set(factors_b.keys())): lcm_factors[prime] = max(factors_a.get(prime, 0), factors_b.get(prime, 0)) lcm = 1 for prime, power in lcm_factors.items(): lcm *= prime ** power return lcm"},{"question":"# Minimum Jump Count Given an array of positive integers represented as `heights`, where each element represents the maximum number of indices you can jump forward from that position, write a function to determine the minimum number of jumps required to reach the end of the array starting from the first element. If it is not possible to reach the end of the array, return -1. Function Signature ```python def min_jumps(heights: List[int]) -> int: ``` Input * A list of integers `heights` where 1 ≤ len(heights) ≤ 10000 and 1 ≤ heights[i] ≤ 1000. Output * An integer representing the minimum number of jumps needed to reach the end of the array, or -1 if it is not possible to reach the end. Constraints * You are always able to move forward by at least one index at each step. * Your solution should be efficient with a time complexity of O(n). Example ```python print(min_jumps([2, 3, 1, 1, 4])) # Output: 2 print(min_jumps([1, 1, 1, 1])) # Output: 3 print(min_jumps([0, 1, 2, 3])) # Output: -1 ``` Notes * Consider edge cases such as arrays where the end is unreachable due to a block with `0` height. * Implement an optimal solution using a greedy approach or dynamic programming to ensure it runs efficiently for large inputs.","solution":"def min_jumps(heights): Returns the minimum number of jumps required to reach the end of the array. If the end is not reachable, returns -1. n = len(heights) if n == 1: return 0 jumps = 0 farthest = 0 end_of_current_jump = 0 for i in range(n - 1): farthest = max(farthest, i + heights[i]) if i == end_of_current_jump: jumps += 1 end_of_current_jump = farthest if end_of_current_jump >= n - 1: return jumps return -1"},{"question":"# Problem Statement You are building a search engine and need to efficiently search large text corpora for occurrences of given phrases. One way to do this is by using the Knuth-Morris-Pratt (KMP) string matching algorithm, which preprocesses the pattern to create a partial match table, then uses this table to perform the search. # Task Write a Python function called `kmp_search` that performs pattern matching using the KMP algorithm. Your function should be able to perform both preprocessing to create the partial match table (also known as the \\"pi\\" table) and then use this table to search for occurrences of the pattern in the given text. # Function Signature ```python def kmp_search(text: str, pattern: str) -> list: pass ``` # Input * `text` (str): The text to search within. This string can be of arbitrary length. * `pattern` (str): The pattern to search for. This string can also be of arbitrary length but is typically shorter than the text. # Output * Returns a list of starting indices where the pattern is found in the text. If the pattern is not found, the list should be empty. # Constraints * Both `text` and `pattern` are non-empty strings. * The function should handle edge cases where the pattern is longer than the text gracefully by returning an empty list. # Example ```python >>> text = \\"ababcabcabababd\\" >>> pattern = \\"ababd\\" >>> kmp_search(text, pattern) [10] >>> text = \\"aaaaa\\" >>> pattern = \\"aa\\" >>> kmp_search(text, pattern) [0, 1, 2, 3] ``` # Explanation For the first example, the pattern \\"ababd\\" is found starting at index 10 in the text \\"ababcabcabababd\\". In the second example, the pattern \\"aa\\" is found at multiple starting positions (0, 1, 2, 3) in the text \\"aaaaa\\". Your function should efficiently handle the creation of the partial match table and perform the search without redundancy, ensuring optimal performance.","solution":"def kmp_search(text: str, pattern: str) -> list: def build_pi_table(pattern): m = len(pattern) pi = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = pi[j - 1] if pattern[i] == pattern[j]: j += 1 pi[i] = j return pi n = len(text) m = len(pattern) if m == 0: return [] pi = build_pi_table(pattern) result = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = pi[j - 1] if text[i] == pattern[j]: j += 1 if j == m: result.append(i - m + 1) j = pi[j - 1] return result"},{"question":"# Question: Create a Binary Tree Level Order Traversal Function Description Implement a function that performs a level order traversal on a binary tree and returns the values of the nodes in level order as a list of lists. Input - A binary tree where each node contains an integer value. Output - A list of lists, where each sublist represents one level of the tree. Constraints 1. If the root node is `None`, the function should return an empty list `[]`. Example Consider the binary tree: 3 / 9 20 / 15 7 ```plaintext Input: root = [3, 9, 20, None, None, 15, 7] Output: [[3], [9, 20], [15, 7]] Input: root = [] Output: [] ``` Definition for a binary tree node ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Additional Notes - Use a queue to assist in processing the nodes level by level. - Assume the values in the tree are unique integers for simplicity. Template ```python from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if root is None: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result # Example Usage # Construct the binary tree from the example above root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(level_order(root)) # Output: [[3], [9, 20], [15, 7]] ```","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if root is None: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result # Example Usage # Construct the binary tree from the example above root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(level_order(root)) # Output: [[3], [9, 20], [15, 7]]"},{"question":"# Coding Assessment Question **Context**: You are tasked with developing a feature for a text processing application that involves validating sequences of braces in a string. The goal is to ensure that all braces are correctly balanced and properly nested. Braces include parentheses `()`, curly brackets `{}`, and square brackets `[]`. **Task**: Write a function `is_valid_braces` that takes a string containing braces and returns `True` if the braces are correctly balanced and properly nested, and `False` otherwise. **Function Signature**: ```python def is_valid_braces(s: str) -> bool: ``` **Input**: * `s` - a string containing only the characters `()[]{}, of length `0 <= len(s) <= 10^5`. **Output**: * Return `True` if the string\'s braces are balanced and properly nested, otherwise return `False`. **Constraints**: * The input string can be empty, in which case it should return `True`. **Example**: ```python >>> is_valid_braces(\\"()\\") True >>> is_valid_braces(\\"([{}])\\") True >>> is_valid_braces(\\"([{]})\\") False >>> is_valid_braces(\\"((()))\\") True >>> is_valid_braces(\\"[{])\\") False >>> is_valid_braces(\\"{[()]}\\") True >>> is_valid_braces(\\")(\\") False >>> is_valid_braces(\\"()[]{}\\") True ``` **Note**: * The string must be traversed in a way that ensures the braces are correctly nested and balanced. * You can use auxiliary data structures like a stack to help with the validation of braces. Ensure your solution is optimized for time complexity, as the input length can be quite large.","solution":"def is_valid_braces(s: str) -> bool: Check if the braces in the string are correctly balanced and properly nested. :param s: str - String containing only braces characters \'()[]{}\' :return: bool - True if properly nested and balanced, False otherwise stack = [] braces = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in braces.values(): stack.append(char) elif char in braces.keys(): if stack == [] or braces[char] != stack.pop(): return False else: return False # invalid character detected return len(stack) == 0"},{"question":"# Problem Statement You are given a list of integers. Your task is to find the maximum sum of non-adjacent elements in the list. You can choose any elements from the list as long as they are not next to each other in the original list. # Task Write a function `max_non_adjacent_sum(lst: List[int]) -> int` that returns the maximum sum of non-adjacent elements in the list. # Input - A list of integers `lst` where `2 <= len(lst) <= 10^4`. - Each integer in the list (`-10^3 <= lst[i] <= 10^3`). # Output - Return an integer which is the maximum sum of non-adjacent elements in the list. # Constraints 1. The length of the list will be between 2 and 10,000 (inclusive). 2. Each integer in the list can range from -1,000 to 1,000 (inclusive). # Example - Given `lst = [3, 2, 5, 10, 7]`, the output should be `15` (3 + 5 + 7). - Given `lst = [-2, 1, 3, -4, 5]`, the output should be `8` (1 + 5). # Implementation Guide 1. Initialize two variables, `include` and `exclude`, to keep track of the maximum sums that include or exclude the current element. 2. Iterate through each element in the list, updating the `include` and `exclude` values. 3. At each step, `include` will be the previous `exclude` plus the current element, and `exclude` will be the maximum of the previous `include` and `exclude`. 4. Return the maximum of `include` and `exclude` after processing the entire list. ```python from typing import List def max_non_adjacent_sum(lst: List[int]) -> int: Returns the maximum sum of non-adjacent elements in the list. Parameters: lst (List[int]): The list of integers. Returns: int: The maximum sum of non-adjacent elements. if not lst: return 0 include = 0 exclude = 0 for num in lst: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude) # Example usage: print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Output: 15 print(max_non_adjacent_sum([-2, 1, 3, -4, 5])) # Output: 8 ``` # Summary This new question adheres to the formatting, length, difficulty, and topic coverage of the given sample question. It explores a different problem within the broader domain of algorithmic challenges, ensuring it fits seamlessly with the provided set.","solution":"from typing import List def max_non_adjacent_sum(lst: List[int]) -> int: Returns the maximum sum of non-adjacent elements in the list. Parameters: lst (List[int]): The list of integers. Returns: int: The maximum sum of non-adjacent elements. if not lst: return 0 include = 0 exclude = 0 for num in lst: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude) # Example usage: print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Output: 15 print(max_non_adjacent_sum([-2, 1, 3, -4, 5])) # Output: 8"},{"question":"# Problem Statement: You are tasked with writing a Python function to help manage a software development project. The function needs to calculate the estimated time to complete a set of tasks when given the completion time for a subset of the tasks and their dependencies. Specifically, the function should compute the total time in days to complete all tasks, considering the longest path through the dependency graph (i.e., the critical path). # Task: Write a function `calculate_project_duration()` that takes two arguments: - `tasks` (dict): A dictionary where keys are task names (strings) and values are their completion times in days (integers). - `dependencies` (list): A list of tuples where each tuple represents a dependency between tasks as (task1, task2), meaning task2 depends on task1. The function should return the total time in days to complete all tasks. Constraints: - All task completion times are positive integers. - The dependency list does not contain cycles. - Each task name is unique. Example: ```python def calculate_project_duration(tasks: dict[str, int], dependencies: list[tuple[str, str]]) -> int: pass # Your implementation here # Example Test Cases: tasks = { \'A\': 3, \'B\': 6, \'C\': 1, \'D\': 2, \'E\': 4 } dependencies = [ (\'A\', \'B\'), (\'A\', \'C\'), (\'B\', \'D\'), (\'C\', \'D\'), (\'D\', \'E\') ] print(calculate_project_duration(tasks, dependencies)) # 15 ``` # Requirements: - Use topological sorting or another graph algorithm to determine the critical path. - Handle cases with disjoint subgraphs correctly. Notes - Ensure your function can handle edge cases, such as tasks with no dependencies. - Consider writing helper functions as necessary to maintain code readability. - All expected outputs are integers.","solution":"from collections import defaultdict, deque def calculate_project_duration(tasks, dependencies): Calculates the total time to complete all tasks in a project based on dependencies. tasks: Dictionary of task names and their completion times. dependencies: List of tuples representing task dependencies. Returns the total time in days to complete all tasks. # Build the graph and initialize in-degree of each node graph = defaultdict(list) in_degree = {task: 0 for task in tasks} for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Identify starting nodes (no dependencies) queue = deque([node for node in tasks if in_degree[node] == 0]) # To store the maximum time to complete each task completion_time = {task: 0 for task in tasks} # Process the tasks while queue: current = queue.popleft() current_time = completion_time[current] + tasks[current] for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Update the completion time to the maximum of the current calculated time completion_time[neighbor] = max(completion_time[neighbor], current_time) # The total time to finish all tasks will be the maximum value in completion_time return max(completion_time[task] + tasks[task] for task in tasks)"},{"question":"# Context: You are tasked with building an application that helps users manage their personal library of books. This question involves implementing a function to manage and retrieve book information based on specific search criteria. Given a collection of books with their titles, authors, and publication years, you will need to implement a function to search the library by a specific author and sort the results by publication year. # Objective: Write a function `search_and_sort_books(books: List[Dict[str, Union[str, int]]], author: str) -> List[str]` that retrieves the titles of books written by the given author, sorted in ascending order by their publication year. # Input: - A list of dictionaries `books`, where each dictionary contains: - `title` (str): The title of the book. - `author` (str): The author of the book. - `year` (int): The publication year of the book. - A string `author`, representing the name of the author to search for. # Output: - A list of strings, representing the titles of the books written by the given author, sorted in ascending order by their publication year. If the author has no books in the list, return an empty list. # Constraints: - The `books` list will have at most 10^4 entries, and each book\'s `title`, `author`, or `year` will be valid and non-empty. - The `year` will be an integer between 1 and 2100. - The `title` and `author` strings will have a length between 1 and 100 characters. # Function Signature: ```python from typing import List, Dict, Union def search_and_sort_books(books: List[Dict[str, Union[str, int]]], author: str) -> List[str]: ``` # Examples: 1. `search_and_sort_books([{\'title\': \'Book A\', \'author\': \'Author 1\', \'year\': 2005}, {\'title\': \'Book B\', \'author\': \'Author 1\', \'year\': 2001}, {\'title\': \'Book C\', \'author\': \'Author 2\', \'year\': 1999}], \'Author 1\') -> [\'Book B\', \'Book A\']` 2. `search_and_sort_books([{\'title\': \'Book A\', \'author\': \'Author 1\', \'year\': 2005}], \'Author 2\') -> []` 3. `search_and_sort_books([{\'title\': \'Book A\', \'author\': \'Author 1\', \'year\': 2005}, {\'title\': \'Book B\', \'author\': \'Author 1\', \'year\': 2001}], \'Author 1\') -> [\'Book B\', \'Book A\']` # Explanation: Your task is to filter the books by the given author and then sort the resulting titles by their publication year in ascending order. # Notes: - Ensure to handle cases where the author has no books in the library by returning an empty list. - Focus on efficient searching and sorting techniques to handle the upper constraint of book entries.","solution":"from typing import List, Dict, Union def search_and_sort_books(books: List[Dict[str, Union[str, int]]], author: str) -> List[str]: This function retrieves the titles of books written by the given author, sorted in ascending order by their publication year. # Filter books by the given author filtered_books = [book for book in books if book[\'author\'] == author] # Sort the filtered books by publication year sorted_books = sorted(filtered_books, key=lambda x: x[\'year\']) # Extract titles from the sorted list sorted_titles = [book[\'title\'] for book in sorted_books] return sorted_titles"},{"question":"# Question You are responsible for creating a library system to manage book checkouts. Implement a basic version of this system focusing on logging checkouts and returns. To thoroughly test your library system, implement a function following these requirements: # Function to Implement Function Signature ```python class Library: def __init__(self): pass def checkout_book(self, book_title: str, user_id: int) -> bool: pass def return_book(self, book_title: str) -> bool: pass def is_book_checked_out(self, book_title: str) -> bool: pass ``` Methods and Input * `__init__`: Initializes the library with no books checked out. * `checkout_book`: Logs the checkout of a book. * `book_title` (string): The title of the book being checked out. * `user_id` (int): The ID of the user checking out the book. * Returns a boolean indicating whether the book checkout was successful. The checkout is only successful if the book is not already checked out. * `return_book`: Logs the return of a book. * `book_title` (string): The title of the book being returned. * Returns a boolean indicating whether the book return was successful. The return is only successful if the book was previously checked out. * `is_book_checked_out`: Checks if a book is currently checked out. * `book_title` (string): The title of the book being checked. * Returns a boolean indicating whether the book is currently checked out. # Examples ```python # Example 1 library = Library() assert library.checkout_book(\\"The Great Gatsby\\", 1) == True assert library.is_book_checked_out(\\"The Great Gatsby\\") == True assert library.return_book(\\"The Great Gatsby\\") == True assert library.is_book_checked_out(\\"The Great Gatsby\\") == False # Example 2 library = Library() assert library.checkout_book(\\"1984\\", 2) == True assert library.checkout_book(\\"1984\\", 3) == False assert library.return_book(\\"1984\\") == True assert library.return_book(\\"1984\\") == False ``` # Constraints * `book_title` will be a non-empty string of at most 100 characters consisting of only printable ASCII characters. * `user_id` will be a non-negative integer.","solution":"class Library: def __init__(self): self.checked_out_books = {} # Dictionary to keep track of checked out books def checkout_book(self, book_title: str, user_id: int) -> bool: if book_title in self.checked_out_books: return False self.checked_out_books[book_title] = user_id return True def return_book(self, book_title: str) -> bool: if book_title not in self.checked_out_books: return False del self.checked_out_books[book_title] return True def is_book_checked_out(self, book_title: str) -> bool: return book_title in self.checked_out_books"},{"question":"# Coding Question: Index of the First Missing Positive Integer Problem Statement: Given an unsorted integer array, you need to find the smallest missing positive integer. Your solution should handle large arrays efficiently and not use additional space beyond `O(1)` (constant space complexity, disregarding the input and output). Write a function `solution(arr: List[int]) -> int` where: - **Input**: - `arr` (a list of integers) - the list of unsorted integers. - **Output**: Output the smallest missing positive integer in the list. Function Signature: `def solution(arr: List[int]) -> int` **Examples**: ```python assert solution([1, 2, 0]) == 3 assert solution([3, 4, -1, 1]) == 2 assert solution([7, 8, 9, 11, 12]) == 1 ``` Constraints: - The list will contain between 1 and 10^6 elements. - The integers in the list will be in the range of `[-10^6, 10^6]`. Performance Requirements: - The solution should work in linear time `O(n)` and use constant space `O(1)`. **Hint**: Try using indexing strategies and swapping elements to their correct positions in the array to identify the smallest missing positive integer.","solution":"from typing import List def solution(arr: List[int]) -> int: n = len(arr) # Place each number in its right place # For example, when we find number 5, we swap it with the 5th element # arr[5]. Ignore numbers less than 1 and greater than n for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: # Swap arr[i] with arr[arr[i] - 1] arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # After rearrangement, the first place where its number is not right, return the place + 1 for i in range(n): if arr[i] != i + 1: return i + 1 # If all numbers are in their places, the answer is n + 1 return n + 1"},{"question":"# Coding Question: Graph Cycle Detection Problem Statement Consider a robust Graph data structure implemented using an adjacency list. Extend this implementation to include methods for detecting cycles in both undirected and directed graphs using Depth-First Search (DFS). Requirements 1. **Cycle Detection in Undirected Graph**: - Implement the `is_cyclic_undirected` method which detects the presence of a cycle in an undirected graph. - If the graph is empty or has no edges, return `False`. 2. **Cycle Detection in Directed Graph**: - Implement the `is_cyclic_directed` method which detects the presence of a cycle in a directed graph. - If the graph is empty or has no edges, return `False`. Method Signatures - `def is_cyclic_undirected(self) -> bool:` - `def is_cyclic_directed(self) -> bool:` Input and Output Formats - **Cycle Detection Methods**: - **Input**: No arguments. - **Output**: A boolean indicating whether there is a cycle in the graph. Constraints - The graph can have up to 10,000 vertices and 50,000 edges. Example Assume we initialize the graph with the following vertices and edges: ```python vertices = [1, 2, 3, 4, 5] edges_undirected = [[1, 2], [1, 3], [2, 4], [4, 3]] edges_directed = [[1, 2], [2, 3], [3, 1], [4, 5]] graph_undirected = GraphAdjacencyList(vertices, edges_undirected, directed=False) graph_directed = GraphAdjacencyList(vertices, edges_directed, directed=True) ``` - For `graph_undirected.is_cyclic_undirected()`, the output would be `True`. - For `graph_directed.is_cyclic_directed()`, the output would be `True`. Implementation ```python class GraphAdjacencyList(Generic[T]): # existing methods... def is_cyclic_undirected(self) -> bool: def dfs(v, parent): visited.add(v) for neighbor in self.adj_list[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif parent != neighbor: return True return False visited = set() for vertex in self.adj_list: if vertex not in visited: if dfs(vertex, None): return True return False def is_cyclic_directed(self) -> bool: def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in self.adj_list[v]: if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False visited = set() rec_stack = set() for vertex in self.adj_list: if vertex not in visited: if dfs(vertex): return True return False # Example of how to use: vertices = [1, 2, 3, 4, 5] edges_undirected = [[1, 2], [1, 3], [2, 4], [4, 3]] edges_directed = [[1, 2], [2, 3], [3, 1], [4, 5]] graph_undirected = GraphAdjacencyList(vertices, edges_undirected, directed=False) graph_directed = GraphAdjacencyList(vertices, edges_directed, directed=True) print(graph_undirected.is_cyclic_undirected()) # True print(graph_directed.is_cyclic_directed()) # True ``` - For `graph_undirected.is_cyclic_undirected()`, the output would be `True`. - For `graph_directed.is_cyclic_directed()`, the output would be `True`.","solution":"from typing import List, Dict, Set, Tuple class GraphAdjacencyList: def __init__(self, vertices: List[int], edges: List[Tuple[int, int]], directed: bool = False): self.vertices = vertices self.edges = edges self.directed = directed self.adj_list = self._create_adjacency_list() def _create_adjacency_list(self) -> Dict[int, List[int]]: adj_list = {v: [] for v in self.vertices} for (u, v) in self.edges: adj_list[u].append(v) if not self.directed: adj_list[v].append(u) return adj_list def is_cyclic_undirected(self) -> bool: def dfs(v, parent): visited.add(v) for neighbor in self.adj_list[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif parent != neighbor: return True return False visited = set() for vertex in self.adj_list: if vertex not in visited: if dfs(vertex, None): return True return False def is_cyclic_directed(self) -> bool: def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in self.adj_list[v]: if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False visited = set() rec_stack = set() for vertex in self.adj_list: if vertex not in visited: if dfs(vertex): return True return False"},{"question":"# Question: Implement a Function to Merge Two Sorted Lists You need to implement a function that takes two sorted lists and merges them into a single sorted list. The input lists will already be sorted in ascending order. Function Signature ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input * Two lists of integers called `list1` and `list2`. Output * A single list of integers sorted in ascending order. Constraints * Each input list will have a length between 0 and 1000. * Elements in the lists are between -10^6 and 10^6. * The merge should be done in linear time relative to the total number of elements in both lists. Requirements * Do not use any built-in sorting functions. * The algorithm must efficiently merge the two sorted lists. Example ```python print(merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] print(merge_sorted_lists([], [2, 4, 6, 8])) # Output: [2, 4, 6, 8] print(merge_sorted_lists([1, 3, 5, 7], [])) # Output: [1, 3, 5, 7] print(merge_sorted_lists([], [])) # Output: [] print(merge_sorted_lists([1, 2, 5], [1, 3, 4])) # Output: [1, 1, 2, 3, 4, 5] ``` Notes * Ensure to handle edge cases such as both lists being empty or one list being empty. * The implementation should be efficient, taking advantage of the fact that both lists are already sorted.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. Args: list1 (list[int]): first sorted list of integers. list2 (list[int]): second sorted list of integers. Returns: list[int]: a single sorted list containing all elements from list1 and list2. merged_list = [] i = j = 0 len1, len2 = len(list1), len(list2) while i < len1 and j < len2: if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len1: merged_list.append(list1[i]) i += 1 while j < len2: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Coding Assessment Question Scenario You are part of a software development team working on a simulation system that models the movement of objects in a 2D plane. To ensure optimized performance, you need to keep track of the positions and move objects based on a series of commands. Task You are required to write a function that processes a sequence of commands to manipulate the positions of objects in a 2D plane. Each command will be either: - Adding (or updating) an object with a given ID and coordinates. - Moving an object to a new set of coordinates. - Removing an object. - Finding and returning the coordinates of an object given its ID. Function Signature ```python def process_2d_movements(commands: List[Tuple[str, Union[int, Tuple[int, int]]]]) -> List[Tuple[int, int]]: Processes a sequence of commands and returns results of find operations. :param commands: A list of tuples where each tuple represents a command. - \\"add\\", (object_id, x, y): Adds a new object or updates an existing object with the given ID and coordinates. - \\"move\\", (object_id, new_x, new_y): Moves the object with the specified ID to the new coordinates. - \\"remove\\", object_id: Removes the specified object from the plane. - \\"find\\", object_id: Returns the current coordinates (x, y) of the specified object. :return: A list of coordinate tuples resulting from \\"find\\" operations. ``` Constraints 1. The `object_id` is guaranteed to be unique among active objects. 2. The `commands` list will contain up to (10^5) commands. 3. Coordinate values (x) and (y) are integers and may be negative or positive. Example Given the following commands: ```python commands = [ (\\"add\\", (1, 3, 4)), (\\"add\\", (2, -1, 5)), (\\"move\\", (1, 7, -8)), (\\"find\\", 1), (\\"remove\\", 2), (\\"find\\", 2), (\\"add\\", (3, 0, 0)) ] ``` The function should return: `[(7, -8), None]` because object 1\'s new coordinates after the move command are (7, -8), and object 2 is no longer in the plane after the remove command, resulting in `None`.","solution":"from typing import List, Tuple, Union def process_2d_movements(commands: List[Tuple[str, Union[int, Tuple[int, int]]]]) -> List[Tuple[int, int]]: objects = {} results = [] for command in commands: action = command[0] if action == \\"add\\": object_id, x, y = command[1] objects[object_id] = (x, y) elif action == \\"move\\": object_id, new_x, new_y = command[1] if object_id in objects: objects[object_id] = (new_x, new_y) elif action == \\"remove\\": object_id = command[1] if object_id in objects: del objects[object_id] elif action == \\"find\\": object_id = command[1] if object_id in objects: results.append(objects[object_id]) else: results.append(None) return results"},{"question":"# Calculating Statistical Metrics for Time Series Data You are working on analyzing time series data and need to compute several statistical metrics to understand its properties better. The metrics you need include the moving average and the exponential moving average. **Task**: 1. Implement functions to calculate the moving average and exponential moving average: - `def moving_average(data: list, window: int, ndigits: int = 3) -> list:` - `def exponential_moving_average(data: list, alpha: float, ndigits: int = 3) -> list:` 2. The moving average function should produce a list where each element is the average of the previous `window` elements, rounded to `ndigits` decimal places. 3. The exponential moving average function should produce a list where each element is calculated using the formula ( EMA_t = alpha cdot data_t + (1 - alpha) cdot EMA_{t-1} ), rounded to `ndigits` decimal places. 4. Handle any potential edge cases (e.g., empty lists, lists with fewer elements than the window size, alpha values out of range). **Function Signature**: ```python def moving_average(data: list, window: int, ndigits: int = 3) -> list: # your implementation here def exponential_moving_average(data: list, alpha: float, ndigits: int = 3) -> list: # your implementation here ``` # Expected Input and Output: * **Input Format**: - `data`: A list of numerical values `[float]` or `[int]`. - `window`: An integer specifying the number of data points for calculating the moving average. - `alpha`: A float value between 0 and 1 specifying the smoothing factor for the exponential moving average. - `ndigits`: An integer specifying the number of decimal places for rounding the result (default is 3). * **Output Format**: - A list of processed numbers rounded to the specified number of decimal places. # Constraints and Assumptions: - The list can be empty or contain fewer elements than the window size. - The alpha value for exponential moving average will be a valid float between 0 and 1. # Example Usage: ```python # Moving Average Examples: assert moving_average([1, 2, 3, 4, 5, 6, 7], 3) == [2.0, 3.0, 4.0, 5.0] assert moving_average([10, 20, 30, 40, 50], 2) == [15.0, 25.0, 35.0, 45.0] # Exponential Moving Average Examples: assert exponential_moving_average([1, 2, 3, 4, 5], 0.2) == [1.0, 1.2, 1.56, 2.048, 2.638] assert exponential_moving_average([10, 20, 30, 40, 50], 0.5) == [10.0, 15.0, 22.5, 31.25, 40.625] ``` # Notes: - Ensure the edge cases like empty lists and lists with fewer elements than the window size for moving average are effectively handled. - Performance considerations can include efficient use of loops and in-built mathematical functions.","solution":"def moving_average(data: list, window: int, ndigits: int = 3) -> list: Calculate the moving average over a window and round each result to ndigits decimal places. :param data: List of numbers. :param window: Window size for moving average. :param ndigits: Number of decimal places for rounding. :return: List of moving averages. if not data or window <= 0: return [] result = [] for i in range(len(data) - window + 1): window_avg = round(sum(data[i:i + window]) / window, ndigits) result.append(window_avg) return result def exponential_moving_average(data: list, alpha: float, ndigits: int = 3) -> list: Calculate the exponential moving average and round each result to ndigits decimal places. :param data: List of numbers. :param alpha: Smoothing factor. :param ndigits: Number of decimal places for rounding. :return: List of exponential moving averages. if not data or not (0 < alpha < 1): return [] ema = [round(data[0], ndigits)] for i in range(1, len(data)): ema_t = round(alpha * data[i] + (1 - alpha) * ema[-1], ndigits) ema.append(ema_t) return ema"},{"question":"# Problem Statement You are tasked with writing a function that calculates the factorial of a given integer ( n ). Your function should handle both iterative and recursive approaches. Implement a function `factorial` that computes the factorial using both methods and returns the results. # Function Signature ```python def factorial(n: int) -> (int, int): ``` # Input - An integer ( n ), where ( 0 leq n leq 20 ). # Output - A tuple of two integers, where the first integer is the factorial calculated iteratively, and the second integer is the factorial calculated recursively. # Constraints - You must handle invalid inputs by raising appropriate exceptions (e.g., non-integer, negative values). - Constraints ensure ( n ) is a valid integer within the given range. # Performance Requirements - Your implementation should be efficient, considering the constraints. # Example ```python assert factorial(5) == (120, 120) assert factorial(0) == (1, 1) assert factorial(10) == (3628800, 3628800) ``` # Notes - Ensure to handle edge cases and invalid inputs as specified in the constraints. - Consider the stack depth limitations while using the recursive approach.","solution":"def factorial(n: int) -> (int, int): Calculates the factorial of a given integer n using both iterative and recursive approaches. Args: n (int): The integer for which to calculate the factorial. Should be in the range 0 <= n <= 20. Returns: (int, int): A tuple where the first element is the factorial calculated iteratively, and the second element is the factorial calculated recursively. Raises: ValueError: If n is not an integer or is not in the range 0 <= n <= 20. if not isinstance(n, int) or n < 0 or n > 20: raise ValueError(\\"n must be an integer in the range 0 <= n <= 20\\") # Iterative approach def factorial_iterative(n): result = 1 for i in range(2, n + 1): result *= i return result # Recursive approach def factorial_recursive(n): if n == 0: return 1 else: return n * factorial_recursive(n - 1) return factorial_iterative(n), factorial_recursive(n)"},{"question":"# Coding Assessment Question: Merge K Sorted Lists You are given `k` sorted linked lists each representing a sorted sequence of integers. Your task is to merge all the `k` linked lists into one sorted linked list and return its head. Write a function that merges and returns the sorted linked list. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` # Input * `lists`: A list of `k` linked lists, where each linked list is represented by its head node. (0 ≤ k ≤ 10^4, 0 ≤ |lists[i]| ≤ 500, -10^4 ≤ lists[i][j] ≤ 10^4) # Output * Returns the head of the merged linked list. # Example ```python # Example 1: lists = [ ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6)) ] # Output: ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(4, ListNode(5, ListNode(6)))))))) # Example 2: lists = [] # Output: None # Example 3: lists = [None] # Output: None ``` # Constraints * Each linked list is sorted in non-decreasing order. # Requirements 1. Ensure the function is efficient to handle a large number of lists. 2. Consider edge cases such as an empty list of lists or a list containing empty linked lists. 3. Use a priority queue (or heap) to achieve an efficient merge. Ensure the overall time complexity is O(N log k) where N is the total number of nodes across all input lists.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None min_heap = [] for index, node in enumerate(lists): if node: # If the node is not None heapq.heappush(min_heap, (node.val, index, node)) dummy_head = ListNode(None) current = dummy_head while min_heap: # Pop the smallest value node val, index, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: # If there is a next node, push it onto the heap heapq.heappush(min_heap, (node.next.val, index, node.next)) return dummy_head.next"},{"question":"# Coding Assessment Question Problem Statement You are given an array of integers and an integer `x`. Implement a function that finds the length of the smallest subarray with a sum greater than or equal to `x`. If no such subarray exists, return 0. Function Signature ```python def smallest_subarray_with_given_sum(arr: list[int], x: int) -> int: Find the length of the smallest subarray with a sum greater than or equal to `x`. :param arr: List of integers. :param x: Integer threshold for subarray sum. :return: Length of the smallest subarray with a sum >= `x`. ``` Input Format * An array of integers. * An integer `x`. Output Format * An integer representing the length of the smallest subarray with a sum >= `x`. If no such subarray exists, return 0. Example ```python arr = [2, 1, 5, 2, 8] x = 7 print(smallest_subarray_with_given_sum(arr, x)) # Output: 1 (smallest subarray is [8]) ``` ```python arr = [2, 1, 5, 2, 3, 2] x = 7 print(smallest_subarray_with_given_sum(arr, x)) # Output: 2 (smallest subarray is [5, 2]) ``` ```python arr = [3, 4, 1, 1, 6] x = 8 print(smallest_subarray_with_given_sum(arr, x)) # Output: 3 (smallest subarray is [3, 4, 1]) ``` Constraints * The array can have up to 10^5 elements. * The values in the array are integers and can be positive, negative, or zero. * The input array will always have at least one element, and `x` will always be a positive integer. Implementation Notes * Make sure to handle edge cases, such as when the array is empty, when `x` is larger than the sum of the entire array, or when the array elements are all negative. * Ensure the function runs efficiently even for long arrays. * Consider using a sliding window approach to optimize the performance of your solution.","solution":"def smallest_subarray_with_given_sum(arr: list[int], x: int) -> int: Find the length of the smallest subarray with a sum greater than or equal to `x`. :param arr: List of integers. :param x: Integer threshold for subarray sum. :return: Length of the smallest subarray with a sum >= `x`. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"# Problem Statement You are tasked with implementing functions to handle basic operations on a custom data structure called `DoubleEndedQueue` (deque), which supports adding and removing elements from both ends of the queue. Implement the following methods for the `DoubleEndedQueue` class: 1. `enqueue_front(self, item: int) -> None`: Adds an element to the front of the deque. 2. `enqueue_rear(self, item: int) -> None`: Adds an element to the rear of the deque. 3. `dequeue_front(self) -> int`: Removes and returns the element from the front of the deque. If the deque is empty, return `-1`. 4. `dequeue_rear(self) -> int`: Removes and returns the element from the rear of the deque. If the deque is empty, return `-1`. 5. `peek_front(self) -> int`: Returns the element at the front without removing it. If the deque is empty, return `-1`. 6. `peek_rear(self) -> int`: Returns the element at the rear without removing it. If the deque is empty, return `-1`. 7. `is_empty(self) -> bool`: Returns `True` if the deque is empty, otherwise `False`. # Class Definition ```python class DoubleEndedQueue: def __init__(self): # Your code here def enqueue_front(self, item: int) -> None: # Your code here def enqueue_rear(self, item: int) -> None: # Your code here def dequeue_front(self) -> int: # Your code here def dequeue_rear(self) -> int: # Your code here def peek_front(self) -> int: # Your code here def peek_rear(self) -> int: # Your code here def is_empty(self) -> bool: # Your code here ``` # Input/Output Examples ```python dq = DoubleEndedQueue() assert dq.is_empty() == True dq.enqueue_front(10) dq.enqueue_rear(20) dq.enqueue_front(30) dq.enqueue_rear(40) assert dq.peek_front() == 30 assert dq.peek_rear() == 40 assert dq.dequeue_front() == 30 assert dq.dequeue_rear() == 40 assert dq.peek_front() == 10 assert dq.peek_rear() == 20 assert dq.dequeue_front() == 10 assert dq.dequeue_rear() == 20 assert dq.is_empty() == True assert dq.dequeue_front() == -1 assert dq.dequeue_rear() == -1 assert dq.peek_front() == -1 assert dq.peek_rear() == -1 ``` # Constraints * The elements added to the `DoubleEndedQueue` are all integers. * The queue can contain any number of elements and operations should perform efficiently.","solution":"class DoubleEndedQueue: def __init__(self): self.deque = [] def enqueue_front(self, item: int) -> None: self.deque.insert(0, item) def enqueue_rear(self, item: int) -> None: self.deque.append(item) def dequeue_front(self) -> int: if self.is_empty(): return -1 return self.deque.pop(0) def dequeue_rear(self) -> int: if self.is_empty(): return -1 return self.deque.pop() def peek_front(self) -> int: if self.is_empty(): return -1 return self.deque[0] def peek_rear(self) -> int: if self.is_empty(): return -1 return self.deque[-1] def is_empty(self) -> bool: return len(self.deque) == 0"},{"question":"# Question Implement a stack data structure with an additional method to find the minimum element in the stack in O(1) time. The stack should support the usual push, pop, and retrieve top operations along with this additional feature. Specific Requirements: 1. **Class Name**: MinStack 2. **Methods to Implement/Override**: * `__init__(self)`: Initialize the stack. * `push(self, item: int) -> None`: Add an item to the top of the stack. * `pop(self) -> int`: Remove and return the item from the top of the stack. * `top(self) -> int`: Return the item from the top of the stack without removing it. * `get_min(self) -> int`: Return the minimum item in the stack in O(1) time. 3. **Input**: Variably through method calls. 4. **Output**: Variably through method returns. Constraints: * Your structure should gracefully handle attempts to pop or retrieve the top item from an empty stack by raising an `IndexError`. Performance Requirements: * **Time Complexity**: * get_min() must be O(1). # Example Usage: ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.get_min()) # 3 stack.push(2) stack.push(1) print(stack.get_min()) # 1 print(stack.pop()) # 1 print(stack.get_min()) # 2 print(stack.top()) # 2 stack.pop() stack.pop() print(stack.get_min()) # 3 ``` Your implementation should pass the above cases and be optimized as described.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, item: int) -> None: self.stack.append(item) if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from an empty stack\\") item = self.stack.pop() if item == self.min_stack[-1]: self.min_stack.pop() return item def top(self) -> int: if not self.stack: raise IndexError(\\"top from an empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from an empty stack\\") return self.min_stack[-1]"},{"question":"# Problem Statement You are tasked with implementing a schedule management system for a simple bus route. The system should allow you to retrieve the next bus departure time given the current time. The bus operates on a regular schedule, with departures at specific intervals throughout the day. Implement a function to determine the next departure time. # Function Signature ```python def next_bus_departure(current_time: str, interval: int, start_time: str, end_time: str) -> str: pass ``` # Input 1. **current_time**: A string in the format \\"HH:MM\\" representing the current time in a 24-hour clock. 2. **interval**: An integer representing the interval in minutes between each bus departure. 3. **start_time**: A string in the format \\"HH:MM\\" representing the earliest departure time of the day. 4. **end_time**: A string in the format \\"HH:MM\\" representing the latest departure time of the day. No buses will depart after this time. # Output 1. A string in the format \\"HH:MM\\" representing the next bus departure time. # Constraints 1. **current_time**, **start_time**, and **end_time** are valid times in the format \\"HH:MM\\". 2. **interval** is a positive integer and will not exceed 1440 minutes (24 hours). 3. The bus schedule operates on intervals that ensure there is at least one departure between **start_time** and **end_time**. # Examples 1. If the current time is \\"09:35\\", the interval is 30 minutes, the start time is \\"08:00\\", and the end time is \\"20:00\\": ```python assert next_bus_departure(\\"09:35\\", 30, \\"08:00\\", \\"20:00\\") == \\"10:00\\" ``` 2. If the current time is \\"19:45\\", the interval is 15 minutes, the start time is \\"06:00\\", and the end time is \\"22:00\\": ```python assert next_bus_departure(\\"19:45\\", 15, \\"06:00\\", \\"22:00\\") == \\"20:00\\" ``` 3. If the current time is \\"05:30\\", the interval is 20 minutes, the start time is \\"06:00\\", and the end time is \\"22:00\\": ```python assert next_bus_departure(\\"05:30\\", 20, \\"06:00\\", \\"22:00\\") == \\"06:00\\" ``` # Error Handling - The function should raise a `TypeError` if any input parameter is not of the expected type (string for times, integer for interval). - The function should raise a `ValueError` if **current_time**, **start_time**, or **end_time** are not in the valid \\"HH:MM\\" format. # Notes - You can assume **current_time** is always within a single day and is always less than \\"24:00\\". - You can assume **start_time** is always less than **end_time**. - Consider edge cases, such as when the current time is very close to the end time of bus operations.","solution":"from datetime import datetime, timedelta def next_bus_departure(current_time: str, interval: int, start_time: str, end_time: str) -> str: Returns the next bus departure time given the current time, interval, start time, and end time. # Validating input types if not (isinstance(current_time, str) and isinstance(interval, int) and isinstance(start_time, str) and isinstance(end_time, str)): raise TypeError(\\"Input parameters must be of appropriate types (string for times, integer for interval).\\") # Validating time formats try: current_dt = datetime.strptime(current_time, \\"%H:%M\\") start_dt = datetime.strptime(start_time, \\"%H:%M\\") end_dt = datetime.strptime(end_time, \\"%H:%M\\") except ValueError: raise ValueError(\\"Time inputs must be in the format \'HH:MM\'.\\") # Initializing start, end, and interval time deltas start_delta = timedelta(hours=start_dt.hour, minutes=start_dt.minute) end_delta = timedelta(hours=end_dt.hour, minutes=end_dt.minute) current_delta = timedelta(hours=current_dt.hour, minutes=current_dt.minute) interval_delta = timedelta(minutes=interval) if current_delta < start_delta: return start_time next_departure = start_delta while next_departure <= end_delta: if current_delta < next_departure: next_departure_time = (datetime.min + next_departure).time() return next_departure_time.strftime(\\"%H:%M\\") next_departure += interval_delta raise ValueError(\\"No more bus departures today.\\") # Example usage: # print(next_bus_departure(\\"09:35\\", 30, \\"08:00\\", \\"20:00\\"))"},{"question":"# Problem Statement: Substring Concatenation You are working on a text-processing tool and need to implement a function that identifies all starting indices of substrings in a given string `s` that are a concatenation of each word in a given list of words exactly once and without any intervening characters. # Function Signature ```python def find_substring_indices(s: str, words: List[str]) -> List[int]: pass ``` # Input - A string `s` representing the main string in which to search for substrings. - A list of strings `words`, where each element is a base word. # Output - A list of integers representing the starting indices of the substrings in `s` that are a concatenation of each word in the list `words` exactly once. # Constraints - The string `s` and all words in `words` consist of lowercase English letters. - The length of `s` will not exceed 10,000 characters. - All words in `words` will have the same length. - The total length of all words combined will not exceed the length of `s`. # Example ```python # Given string and list of words find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) # Expected output: [0, 9] find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) # Expected output: [] find_substring_indices(\\"barfoofoobarthefoobarman\\", [\\"bar\\",\\"foo\\",\\"the\\"]) # Expected output: [6, 9, 12] ``` # Instructions 1. Implement the `find_substring_indices` function to look for all starting indices of substrings in `s` that are a concatenation of each word in `words` exactly once without any intervening characters. 2. Ensure the solution handles edge cases such as overlapping concatenations or no valid substrings. 3. The implementation should be efficient enough to handle the upper limits of the input constraints.","solution":"from typing import List def find_substring_indices(s: str, words: List[str]) -> List[int]: if not s or not words: return [] word_length = len(words[0]) num_words = len(words) total_length = word_length * num_words if len(s) < total_length: return [] from collections import Counter word_count = Counter(words) result = [] for i in range(word_length): left = i right = i current_count = Counter() count = 0 while right + word_length <= len(s): word = s[right:right + word_length] right += word_length if word in word_count: current_count[word] += 1 count += 1 while current_count[word] > word_count[word]: left_word = s[left:left + word_length] current_count[left_word] -= 1 count -= 1 left += word_length if count == num_words: result.append(left) else: current_count.clear() count = 0 left = right return result"},{"question":"# Recursive Sum of Digits You are given a positive integer `n` and you need to write a function that calculates the sum of the digits of `n` recursively until a single digit is obtained. Objective: Your task is to write a function `recursive_sum_of_digits` that performs the following operation: 1. Calculate the sum of the digits of the integer `n`. 2. If the resulting sum is a single digit, return that digit. 3. If the resulting sum has more than one digit, repeat step 1 with the new sum. Function Definition: ```python def recursive_sum_of_digits(n: int) -> int: Calculate the recursive sum of digits of a positive integer n until a single digit is obtained. :param n: The initial positive integer. :return: The single digit resulting from the recursive sum of digits. pass ``` Input: - The function takes a single integer `n`. Output: - The function returns a single integer which is the recursive sum of the digits. Constraints: - 1 leq n leq 10^9 Example: ```python assert recursive_sum_of_digits(9875) == 2 # Explanation: 9 + 8 + 7 + 5 = 29; 2 + 9 = 11; 1 + 1 = 2 assert recursive_sum_of_digits(12345) == 6 # Explanation: 1 + 2 + 3 + 4 + 5 = 15; 1 + 5 = 6 assert recursive_sum_of_digits(9) == 9 # Explanation: 9 is already a single digit assert recursive_sum_of_digits(999999999) == 9 # Explanation: 9*9 = 81; 8 + 1 = 9 ``` Hints: 1. You can use a helper function to calculate the sum of the digits of a number. 2. Check if the sum of digits is a single digit before making the recursive call. This question assesses your ability to work with recursion and understand the concepts of digit manipulation within number theory basics.","solution":"def recursive_sum_of_digits(n: int) -> int: Calculate the recursive sum of digits of a positive integer n until a single digit is obtained. :param n: The initial positive integer. :return: The single digit resulting from the recursive sum of digits. # Base case: If n is a single digit, return it if n < 10: return n # Calculate the sum of digits of n digit_sum = sum(int(digit) for digit in str(n)) # Recur with the new sum return recursive_sum_of_digits(digit_sum)"},{"question":"# Balanced Binary Tree Construction Background: A binary tree is a tree data structure in which each node has at most two children referred to as the left child and the right child. A balanced binary tree has the property that the height difference between the left and right subtrees of every node is at most 1. Building a balanced binary tree from a sorted array ensures that the constructed tree remains balanced, providing better search time complexity. Task: Implement a Python function that constructs a balanced binary tree from a sorted array. Further, you need to write a helper function to print the tree in a level-order traversal format. Requirements: 1. **Function Signature**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_array_to_bst(nums: List[int]) -> TreeNode: pass def print_level_order(root: TreeNode) -> List[int]: pass ``` 2. **Input**: * `nums` (List[int]): A sorted (ascending) list of integers. 3. **Output**: * `sorted_array_to_bst` should return the root node of the balanced binary tree. * `print_level_order` should return a list of integers representing the level order traversal of the tree. Constraints: * The length of the `nums` list is between 0 and 1000. * The elements of the list are unique integers in the range [-10^4, 10^4]. Performance: * Ensure the tree is balanced with a build time complexity of (O(n)). * The level order traversal should run with a time complexity of (O(n)). Example: ```python nums = [-10, -3, 0, 5, 9] root = sorted_array_to_bst(nums) print(print_level_order(root)) ``` Output: ``` [0, -10, 5, -3, 9] ``` Edge Cases: * Handle cases where the input list is empty. * Ensure the function works efficiently for both small and large input sizes. Explanation: - **sorted_array_to_bst**: * This function should take the sorted array and recursively build the balanced binary tree by selecting the middle element as the root for the current subtree. - **print_level_order**: * This function should traverse the tree in level order, creating a list of node values as they appear level-wise, from left to right.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: if not nums: return None def build_bst(low, high): if low > high: return None mid = (low + high) // 2 node = TreeNode(nums[mid]) node.left = build_bst(low, mid - 1) node.right = build_bst(mid + 1, high) return node return build_bst(0, len(nums) - 1) def print_level_order(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"# Scenario Imagine you are responsible for developing a simplified, in-memory cache system that supports basic operations and handles automatic eviction of the least recently used items. This cache system will be commonly used in scenarios where frequently accessed data needs to be fetched faster than from a database. # Problem Statement Implement a class called `LRUCache`. An `LRUCache` object should support the following methods: - `put(key: int, value: int) -> None`: Add a key-value pair to the cache. If the cache exceeds its capacity, it should evict the least recently used item. - `get(key: int) -> int`: Retrieve the value associated with the given key. If the key does not exist, return `-1`. - `__str__(self) -> str`: Return the string representation of the cache, listing keys in the order from most recently used to least recently used. # Input and Output Formats put - **Input**: key (int), value (int) - **Output**: None get - **Output**: value (int). Returns the value associated with the key or `-1` if the key does not exist. __str__ - **Output**: str, representing the keys in the cache from most recently used to least recently used. # Constraints - All keys are unique and are non-negative integers. - All values are integers. - The cache capacity is a positive integer. - Assume cache capacity is always greater than or equal to one. # Example ```python cache = LRUCache(2) cache.put(1, 10) cache.put(2, 20) print(cache) # Expected order: 2, 1 print(cache.get(1)) # Output: 10 (ordering now 1, 2) cache.put(3, 30) # Removes key 2 print(cache) # Expected order: 3, 1 print(cache.get(2)) # Output: -1 (not found) cache.put(4, 40) # Removes key 1 print(cache) # Expected order: 4, 3 print(cache.get(1)) # Output: -1 (not found) print(cache.get(3)) # Output: 30 print(cache.get(4)) # Output: 40 print(cache) # Expected order: 4, 3 ``` # Performance Requirements - The implementation should support O(1) time complexity for both `put` and `get` methods using appropriate data structures.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def get(self, key: int) -> int: if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def __str__(self) -> str: return \', \'.join(map(str, reversed(self.cache.keys())))"},{"question":"Array Rotation Function # Context In a programming challenge, you are required to manipulate arrays by rotating their elements. Array rotation is a frequent operation in various computer science applications, including data structures and algorithms, simulation problems, and even competitive programming contests. The goal is to develop a function capable of rotating an array either to the left or to the right by a specified number of positions. # Task Implement a function `rotate_array` that rotates the elements of an array. The function should: 1. Rotate the array either to the left or to the right. 2. Handle cases where the rotation count is greater than the length of the array. 3. Return a user-friendly message in case of empty input arrays. # Function Signature ```python def rotate_array(arr: list, direction: str, positions: int) -> list: pass ``` # Inputs and Outputs - **Input**: - `arr`: A list of integers to be rotated. - `direction`: A string specifying the direction of rotation, either \\"left\\" or \\"right\\". - `positions`: An integer specifying the number of positions to rotate the array. - **Output**: - A list of integers representing the rotated array. # Constraints - `arr` may be empty or contain up to (10^6) integers. - `direction` will always be either \\"left\\" or \\"right\\". - `positions` is a non-negative integer. - The function should handle edge cases such as empty arrays and rotations that are multiples of the array length. # Example Usage ```python assert rotate_array([1, 2, 3, 4, 5], \\"left\\", 2) == [3, 4, 5, 1, 2] assert rotate_array([1, 2, 3, 4, 5], \\"right\\", 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], \\"left\\", 7) == [3, 4, 5, 1, 2] assert rotate_array([], \\"left\\", 3) == \\"Cannot rotate an empty array\\" assert rotate_array([1, 2], \\"right\\", 2) == [1, 2] ``` # Notes 1. For a left rotation, elements are shifted towards the left, with the leftmost elements moving to the right end. 2. For a right rotation, elements are shifted towards the right, with the rightmost elements moving to the left end. 3. When the number of positions is greater than the length of the array, the effective number of positions to rotate should be calculated as `positions % len(arr)`.","solution":"def rotate_array(arr: list, direction: str, positions: int) -> list: if not arr: return \\"Cannot rotate an empty array\\" n = len(arr) # Use modulo to handle cases where positions > n positions %= n if direction == \\"left\\": return arr[positions:] + arr[:positions] elif direction == \\"right\\": return arr[-positions:] + arr[:-positions] else: return \\"Invalid direction. Use \'left\' or \'right\'.\\""},{"question":"# Recursive Factorial Sum Objective Write a function to calculate the sum of factorials for numbers from 1 to n through a recursive method. The factorial of a number is the product of all integers from 1 to that number. The sum of factorials involves adding up the factorial results for each integer in the provided range. Function Signature ```python def recursive_factorial_sum(n: int) -> int: ``` Input 1. `n`: An integer representing the upper bound of the range (inclusive) for which the sum of factorials is to be calculated. Output * The function should return an integer representing the sum of factorials from 1 to n. Example ```python assert recursive_factorial_sum(4) == 33 # 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33 assert recursive_factorial_sum(5) == 153 # 1! + 2! + 3! + 4! + 5! = 1 + 2 + 6 + 24 + 120 = 153 assert recursive_factorial_sum(6) == 873 # 1! + 2! + 3! + 4! + 5! + 6! = 1 + 2 + 6 + 24 + 120 + 720 = 873 ``` Constraints * `n` will not exceed 20. * Use recursion to implement both the factorial and summation processes. * Optimize the recursive calls to reduce stack depth as much as possible. Detailed Requirements * Implement a helper function to recursively calculate factorial values. * Another recursive function should iteratively compute the sum using the factorial helper function. * Avoid using loops in either the main function or the helper. * Ensure proper base cases for the recursion to prevent infinite recursion.","solution":"def factorial(n: int) -> int: Helper function to calculate the factorial of n recursively. if n == 1: return 1 else: return n * factorial(n-1) def recursive_factorial_sum(n: int) -> int: Function to calculate the sum of factorials from 1 to n recursively. if n == 1: return 1 else: return factorial(n) + recursive_factorial_sum(n-1)"},{"question":"**[Question 2]: String Transformations to Palindrome** You are required to implement a function that finds the minimum number of character insertions needed to make a given string a palindrome. # Background: A palindrome is a string that reads the same forward and backward. For example, \\"radar\\" and \\"madam\\" are palindromes. Given a string `s`, your task is to determine the minimum number of character insertions required to make it a palindrome. # Task: Implement a function named `min_insertions_for_palindrome(s)` that takes a string `s` and returns the minimum number of insertions required to make it a palindrome. # Function Signature: ```python def min_insertions_for_palindrome(s: str) -> int: ``` # Input: * A string `s` (1 <= len(s) <= 1000), consisting of lowercase letters. # Output: * An integer, the minimum number of insertions required to make the string a palindrome. # Constraints: * Efficiency is important; leverage dynamic programming or other efficient techniques to minimize time complexity. * You may assume the input string contains only lowercase letters. # Example: ```python >>> min_insertions_for_palindrome(\\"abc\\") 2 >>> min_insertions_for_palindrome(\\"abca\\") 1 ``` # Note: * Dynamic programming approach is suggested, utilize techniques such as finding the longest palindromic subsequence to determine the minimal insertions required.","solution":"def min_insertions_for_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the given string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for _ in range(n)] for _ in range(n)] # Fill the table for gap in range(1, n): for l in range(n - gap): h = l + gap if s[l] == s[h]: dp[l][h] = dp[l + 1][h - 1] else: dp[l][h] = min(dp[l][h - 1], dp[l + 1][h]) + 1 # The minimum number of insertions required will be found in dp[0][n-1] return dp[0][n-1]"},{"question":"# Coding Question - Implement a Stack with Minimum Retrieval in Constant Time Context You are tasked with implementing a stack that, in addition to standard push and pop operations, can retrieve the minimum element in the stack in constant time. This is useful in scenarios where you need to keep track of dynamic datasets and efficiently access their minimum values. Task Implement a `MinStack` class in Python with the following methods: 1. **`__init__(self) -> None`**: Initializes the stack. 2. **`push(self, item: int) -> None`**: Pushes an item onto the stack. 3. **`pop(self) -> int`**: Removes and returns the top item from the stack. If the stack is empty, raise an `IndexError`. 4. **`top(self) -> int`**: Returns the top item from the stack without removing it. If the stack is empty, raise an `IndexError`. 5. **`get_min(self) -> int`**: Returns the minimum item in the stack in constant time. If the stack is empty, raise an `IndexError`. 6. **`__str__(self) -> str`**: Returns a string representation of the stack (items separated by \' -> \' with the top at the end). 7. **`__len__(self) -> int`**: Returns the number of elements in the stack. Input and Output Formats: - `push` method will have an integer item as an input. - `pop` and `top` methods will return integer items. - `get_min` will return an integer item. - Ensure all exceptions are properly raised for invalid operations (e.g., popping from an empty stack, retrieving the minimum from an empty stack). Example: ```python ms = MinStack() ms.push(10) ms.push(20) ms.push(5) print(ms.get_min()) # 5 print(len(ms)) # 3 print(ms) # 10 -> 20 -> 5 print(ms.pop()) # 5 print(ms.get_min()) # 10 print(ms) # 10 -> 20 print(ms.top()) # 20 ms.push(3) ms.push(2) print(ms.get_min()) # 2 ms.pop() print(ms.get_min()) # 3 ms.pop() print(ms) # 10 -> 20 print(ms.is_empty()) # False indicates that the function is_empty() should be added to the class. ``` Constraints: - The stack will contain integers in the range -10^9 to 10^9. - The number of operations will not exceed 10^5. Performance Requirements: - `push`, `pop`, `top`, and `get_min` operations should be performed in O(1) time.","solution":"class MinStack: def __init__(self) -> None: # Initialize the stack and a stack to keep track of minimum values self.stack = [] self.min_stack = [] def push(self, item: int) -> None: self.stack.append(item) if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: if not self.stack: raise IndexError(\\"Pop from empty stack\\") item = self.stack.pop() if item == self.min_stack[-1]: self.min_stack.pop() return item def top(self) -> int: if not self.stack: raise IndexError(\\"Top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"Get min from empty stack\\") return self.min_stack[-1] def __str__(self) -> str: return \\" -> \\".join(map(str, self.stack)) def __len__(self) -> int: return len(self.stack) def is_empty(self) -> bool: return len(self.stack) == 0"},{"question":"# Question: Rotate Matrix Counter-Clockwise Context Matrix manipulation is a common task in programming, especially in graphics and data visualization. One frequent operation is rotating a matrix in different directions. Problem Given a 2D list (matrix) of size `n x n`, rotate the matrix 90 degrees counter-clockwise. Tasks Write a Python function `rotate_matrix_ccw(matrix: List[List[int]]) -> List[List[int]]` to rotate the input `n x n` matrix 90 degrees counter-clockwise. Input Format A 2D list `matrix` representing an `n x n` matrix, where each element is an integer. Output Format Return a new `n x n` matrix, rotated 90 degrees counter-clockwise. Constraints * ( 1 leq n leq 100 ) Examples ```python >>> rotate_matrix_ccw([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] >>> rotate_matrix_ccw([[1, 2], [3, 4]]) [[2, 4], [1, 3]] ``` Explanation For the first example: - The original `3x3` matrix: ``` 1 2 3 4 5 6 7 8 9 ``` - Rotated 90 degrees counter-clockwise: ``` 3 6 9 2 5 8 1 4 7 ```","solution":"from typing import List def rotate_matrix_ccw(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees counter-clockwise. :param matrix: 2D list of integers representing the matrix. :return: 2D list of integers representing the rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[n - 1 - j][i] = matrix[i][j] return rotated_matrix"},{"question":"Question # Context: You are given a list of words and a target word, and you need to determine the minimum number of character replacements required to convert one of the words in the list into the target word. If the exact match for the target word exists in the list, the answer would be zero. # Task: Write a Python function `min_replacements(words: List[str], target: str) -> int` that returns the minimum number of character replacements needed to convert any word in the list into the target word. The target word is guaranteed to have the same length as all the words in the list. # Input: - A required list of strings `words` representing the list of words. - A required string `target` representing the target word. # Output: - An integer representing the minimum number of character replacements needed. # Constraints: - 1 <= len(words) <= 1000 - All words including the target word have the same length. - Each word consists of lowercase English letters (a-z). # Example: ```python def min_replacements(words: List[str], target: str) -> int: pass # Your implementation here # Examples print(min_replacements([\\"apple\\", \\"ample\\", \\"axple\\"], \\"apply\\")) # Expected output: 1 (convert \\"apple\\" to \\"apply\\" with 1 replacement) print(min_replacements([\\"hello\\", \\"hallo\\", \\"hullo\\"], \\"hills\\")) # Expected output: 2 (convert \\"hello\\" to \\"hills\\" with 2 replacements) print(min_replacements([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\")) # Expected output: 3 (convert \\"def\\" to \\"xyz\\" with 3 replacements) ``` # Requirements: - Create a function that calculates the number of differing characters between two words. - Iterate through the list of words to find the word that needs the least number of replacements to match the target word. - Return the minimum number of replacements found. # Performance: - Ensure the solution handles up to the maximum constraint efficiently. - Consider edge cases where words might be very similar or vastly different from the target word. # Hints: - Utilize a helper function for calculating the number of different characters between two strings. - Iterate through all words and apply the helper function to determine the minimum replacements needed.","solution":"from typing import List def min_replacements(words: List[str], target: str) -> int: Returns the minimum number of character replacements needed to convert any word in the words list into the target word. def count_replacements(word1: str, word2: str) -> int: Helper function to count the number of differing characters between two words. return sum(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) return min(count_replacements(word, target) for word in words)"},{"question":"# Coding Assessment Question: **Scenario**: Dr. Y is studying the ecosystem of a forest and wants to model the population of a certain animal species over time. The population at any given time `t` is influenced by both natural growth and seasonal fluctuations. Dr. Y has formulated a recursive relationship to simulate this growth, but to successfully model long-term population trends, she needs an efficient implementation. **Task**: Implement a function that calculates the population at time `t` given the initial population and the recursive relationship. **Function Signature**: ```python def simulate_population_growth( initial_population: int, growth_rate: float, seasonal_effect: Callable[[int], float], time_period: int) -> int: Args: initial_population: The initial population at time t=0. growth_rate: The natural growth rate of the population per time period. seasonal_effect: A function that provides the seasonal effect modifier for given time t. This function accepts a single integer (time t) and returns a float. time_period: The number of time periods for which to simulate the population growth. Returns: The projected population at the end of the given time period. pass ``` **Input**: 1. `initial_population`: An integer representing the initial population size. 2. `growth_rate`: A float value representing the natural growth rate per time period. 3. `seasonal_effect`: A callable function that accepts an integer `t` (representing time) and returns a float that modifies the growth rate. 4. `time_period`: An integer representing the total number of time periods to simulate. **Output**: * An integer representing the simulated population after the given number of time periods. **Constraints**: * `initial_population` > 0 * `0 <= growth_rate <= 1` * `time_period` > 0 **Example:** ``` initial_population = 100 growth_rate = 0.05 seasonal_effect = lambda t: 1.0 if t % 2 == 0 else 1.1 time_period = 5 ``` **Example Call:** ```python result = simulate_population_growth( initial_population=100, growth_rate=0.05, seasonal_effect=lambda t: 1.0 if t % 2 == 0 else 1.1, time_period=5 ) print(result) # Example expected output: 127 (Note the actual output might vary based on the lambda function and growth rate) ``` **Note**: Ensure your implementation is optimized for performance, especially for large time periods. Consider how the seasonal effect impacts the population and ensure this is correctly represented by your function.","solution":"from typing import Callable def simulate_population_growth( initial_population: int, growth_rate: float, seasonal_effect: Callable[[int], float], time_period: int) -> int: Simulate the population growth over a given time period. Args: initial_population: The initial population at time t=0. growth_rate: The natural growth rate of the population per time period. seasonal_effect: A function that provides the seasonal effect modifier for given time t. This function accepts a single integer (time t) and returns a float. time_period: The number of time periods for which to simulate the population growth. Returns: The projected population at the end of the given time period. population = initial_population for t in range(1, time_period + 1): seasonal_modifier = seasonal_effect(t) population = population * (1 + growth_rate) * seasonal_modifier return int(population)"},{"question":"# Question Overview You are given a list of strings where each string represents a nested path separated by the forward slash (`/`) character. Your task is to convert this list into a hierarchical dictionary structure. Each element of the path should be a key in the dictionary, and the nested structure should represent the hierarchy of the path. If a path does not have any deeper nesting, it should map to an empty dictionary. Implement the function `convert_to_hierarchy` that takes a list of path strings and returns the hierarchical dictionary. Function Signature ```python def convert_to_hierarchy(paths: List[str]) -> Dict[str, Any]: pass ``` Input - paths: A list of strings where each string contains a nested path separated by the `/` character (1 ≤ len(paths) ≤ 1000). Output - The function should return a dictionary that represents the hierarchical structure of the paths. Example ```python paths = [ \\"a/b/c\\", \\"a/b/d\\", \\"a/e\\", \\"f/g/h\\", \\"f/g/i\\", \\"j\\" ] expected_output = { \\"a\\": { \\"b\\": { \\"c\\": {}, \\"d\\": {} }, \\"e\\": {} }, \\"f\\": { \\"g\\": { \\"h\\": {}, \\"i\\": {} } }, \\"j\\": {} } assert convert_to_hierarchy(paths) == expected_output ``` Constraints - The input strings will only contain alphanumeric characters and the forward slash (`/`) character. - All input strings are guaranteed to represent valid paths without any leading or trailing slashes. - The input list may contain paths with varying levels of nesting. Performance Requirements - The function should efficiently build the hierarchical dictionary, considering the potential depth and breadth of the paths.","solution":"from typing import List, Dict, Any def convert_to_hierarchy(paths: List[str]) -> Dict[str, Any]: hierarchy = {} for path in paths: parts = path.split(\'/\') current_level = hierarchy for part in parts: if part not in current_level: current_level[part] = {} current_level = current_level[part] return hierarchy"},{"question":"# Background As an administrator of a cloud storage system, you need to monitor user activity and restrict the most frequent file accesses during peak times to maintain system performance and ensure fair usage. You have a log of file access events that includes timestamps and file identifiers. Implement a solution to identify the most frequently accessed file during a specified peak period and recommend restricting further access to that file. # Problem Statement Write a function `most_frequent_file_during_peak` in Python that performs the following: 1. Accepts a list of file access events and the peak period start and end timestamps. 2. Filters the events to include only those within the specified peak period. 3. Identifies the file identifier that appears most frequently in the filtered list. 4. Returns the identifier of that file. # Function Signature ```python def most_frequent_file_during_peak(events: list, start_period: str, end_period: str) -> str: # your code here ``` # Input - `events` (list): A list of tuples, each containing a timestamp (in the format \'YYYY-MM-DD HH:MM:SS\') and a file identifier (string). - `start_period` (string): The start of the peak period in the format \'YYYY-MM-DD HH:MM:SS\'. - `end_period` (string): The end of the peak period in the format \'YYYY-MM-DD HH:MM:SS\'. # Output - (string): The file identifier that was accessed most frequently during the specified peak period. # Constraints - Ensure the function handles cases where multiple files have the same maximum access frequency. - In such cases, return any one of those identifiers. - Handle empty event lists and cases where no events fall within the peak period by returning an empty string. # Examples ```python events = [ (\'2023-10-01 12:00:00\', \'file1\'), (\'2023-10-01 12:00:05\', \'file2\'), (\'2023-10-01 12:01:00\', \'file1\'), (\'2023-10-01 12:02:00\', \'file3\'), (\'2023-10-01 12:02:30\', \'file1\') ] start_period = \'2023-10-01 12:00:00\' end_period = \'2023-10-01 12:02:00\' result = most_frequent_file_during_peak(events, start_period, end_period) print(result) # Output: \'file1\', since file1 appears most frequently in the given peak period. ``` # Notes - Ensure the function operates with time complexity efficient enough to process large logs. - Pay attention to edge cases such as: - Time periods that do not match any events. - Multiple files with the same access frequency.","solution":"from collections import Counter from datetime import datetime def most_frequent_file_during_peak(events: list, start_period: str, end_period: str) -> str: Identify the most frequently accessed file during a specified peak period. Parameters: events (list): A list of tuples, each containing a timestamp (in the format \'YYYY-MM-DD HH:MM:SS\') and a file identifier (string). start_period (string): The start of the peak period in the format \'YYYY-MM-DD HH:MM:SS\'. end_period (string): The end of the peak period in the format \'YYYY-MM-DD HH:MM:SS\'. Returns: string: The file identifier that was accessed most frequently during the specified peak period. start_dt = datetime.strptime(start_period, \'%Y-%m-%d %H:%M:%S\') end_dt = datetime.strptime(end_period, \'%Y-%m-%d %H:%M:%S\') filtered_events = [file_id for timestamp, file_id in events if start_dt <= datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') <= end_dt] if not filtered_events: return \\"\\" file_counter = Counter(filtered_events) most_common_file = file_counter.most_common(1)[0][0] return most_common_file"},{"question":"# Frequency Counter for Words in a Text You are required to create a function that counts the frequency of each word in a given piece of text. The words should be considered case-insensitively, meaning \\"The\\" and \\"the\\" should be counted as the same word. You will implement a solution that processes the input text and returns a dictionary where keys are the words (in lowercase) and the values are their respective counts. Function Signature ```python def word_frequency_counter(text: str) -> dict[str, int]: pass ``` Requirements 1. The function should accept a string of text and return a dictionary with words as keys and their frequencies as values. 2. Words should be compared in a case-insensitive manner. 3. The function must handle: - An empty string. - A string with punctuation marks (which should be ignored). - A string with multiple words separated by various types of whitespace. - A string with only one word. 4. Demonstrate your implementation by writing test cases for each of these edge cases. 5. Use Python\'s built-in assertion mechanism to validate your outputs. Constraints * You may use Python\'s built-in string and dictionary operations. * Ensure your solution handles large texts efficiently. Example Usage Here are some examples of expected input and output: ```python assert word_frequency_counter(\\"The cat and the hat.\\") == {\\"the\\": 2, \\"cat\\": 1, \\"and\\": 1, \\"hat\\": 1} assert word_frequency_counter(\\"Hello, hello, HELLO!\\") == {\\"hello\\": 3} assert word_frequency_counter(\\"A quick brown fox jumps over the lazy dog.\\") == {\\"a\\": 1, \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"the\\": 1, \\"lazy\\": 1, \\"dog\\": 1} assert word_frequency_counter(\\"\\") == {} assert word_frequency_counter(\\"Punctuation, should not; affect: word counting!\\") == {\\"punctuation\\": 1, \\"should\\": 1, \\"not\\": 1, \\"affect\\": 1, \\"word\\": 1, \\"counting\\": 1} assert word_frequency_counter(\\"OneWord\\") == {\\"oneword\\": 1} ``` Test your implementation rigorously to cover all edge cases. Explain in comments how each test case validates a specific aspect of the algorithm.","solution":"import re from collections import Counter def word_frequency_counter(text: str) -> dict: Returns a dictionary with the frequency of each word in the text. The words are case-insensitive. # Normalize case and remove punctuation normalized_text = re.sub(r\'[^ws]\', \'\', text.lower()) # Split into words words = normalized_text.split() # Count frequencies word_counts = Counter(words) return dict(word_counts)"},{"question":"# Prime Factorization and Query You are given a class `PrimeFactor` and two core functions `generate_primes` and `prime_factors`, which are used to prime factorize a number. Your task is to extend these implementations to handle multiple queries efficiently. # Problem Statement You need to process a list of numbers to find their prime factorizations. Moreover, you need to answer queries regarding the number of distinct prime factors of given numbers. # Task 1. **Function Implementation**: Implement a function `process_queries(numbers: List[int], queries: List[int]) -> List[int]` that provides the number of distinct prime factors for each queried number. 2. The function should: - **Input**: - `numbers`: A list of integers for which you need to prepare the prime factorizations. - `queries`: A list of integers where each integer represents a number for which you need to find the number of distinct prime factors. - **Output**: - A list of integers where each integer corresponds to a query, indicating the number of distinct prime factors of the queried number. 3. Use the given `PrimeFactor` class and methods provided to manage prime factorizations: ```python class PrimeFactor: Class to find prime factors and store the results def __init__(self): self.primes = [] self.min_prime = [] def generate_primes(self, n: int) -> None: Use sieve of Eratosthenes to generate primes up to n self.min_prime = [0] * (n + 1) self.min_prime[1] = 1 for i in range(2, n + 1): if self.min_prime[i] == 0: self.primes.append(i) for j in range(i, n + 1, i): if self.min_prime[j] == 0: self.min_prime[j] = i def prime_factors(self, num: int) -> List[int]: Return the distinct prime factors of num factors = [] while num != 1: smallest_prime = self.min_prime[num] factors.append(smallest_prime) while num % smallest_prime == 0: num //= smallest_prime return list(set(factors)) ``` # Example ```python numbers = [18, 28, 45] queries = [18, 28, 45] result = process_queries(numbers, queries) print(result) # Output: [2, 2, 2] ``` # Constraints - Elements in the `numbers` list will not exceed 10,000. - Numbers in the queries may go up to 10,000. - The number of numbers and queries will not exceed 2,000. Ensure the implementation is efficient and handles the input size within acceptable limits. Utilize the provided methods efficiently to solve the problem.","solution":"from typing import List class PrimeFactor: Class to find prime factors and store the results def __init__(self): self.primes = [] self.min_prime = [] def generate_primes(self, n: int) -> None: Use sieve of Eratosthenes to generate primes up to n self.min_prime = [0] * (n + 1) self.min_prime[1] = 1 for i in range(2, n + 1): if self.min_prime[i] == 0: self.primes.append(i) for j in range(i, n + 1, i): if self.min_prime[j] == 0: self.min_prime[j] = i def prime_factors(self, num: int) -> List[int]: Return the distinct prime factors of num factors = [] while num != 1: smallest_prime = self.min_prime[num] factors.append(smallest_prime) while num % smallest_prime == 0: num //= smallest_prime return list(set(factors)) def process_queries(numbers: List[int], queries: List[int]) -> List[int]: max_num = max(numbers) pf = PrimeFactor() pf.generate_primes(max_num) num_to_prime_factors_count = {} for number in numbers: num_to_prime_factors_count[number] = len(pf.prime_factors(number)) result = [] for query in queries: result.append(num_to_prime_factors_count.get(query, 0)) return result"},{"question":"# Problem Statement You are tasked with implementing a function that flattens a nested list of integers and returns the resulting flattened list. Your task is to write a function `flatten_list(nested_list: list) -> list` that takes in a nested list of integers and returns a single list containing all the integers in the original nested list. Input - A single nested list `nested_list` which can contain integers and/or other nested lists of integers. Output - A single list containing all the integers from the nested list, in the same order they appear when traversed depth-first. Examples 1. `flatten_list([1, [2, [3, 4], 5], 6])` should return `[1, 2, 3, 4, 5, 6]` 2. `flatten_list([[], 10, [20, [], 30], 40])` should return `[10, 20, 30, 40]` 3. `flatten_list([[1, 2, [3]], 4, [5, [6, [7]]]])` should return `[1, 2, 3, 4, 5, 6, 7]` Constraints - The input list will contain integers and/or other nested lists of integers. - The depth of nesting will not exceed 100. - The total number of integers in the nested list will not exceed 10^5. Requirements 1. The function should be efficient and work within the given constraints. 2. Properly handle various levels of nesting. 3. Focus on writing clean and understandable code. Notes - You may use recursion or an iterative approach to solve the problem. - Ensure the solution handles deeply nested structures effectively. - Focus on preserving the order of the elements as they appear in the original nested list.","solution":"def flatten_list(nested_list): Flattens a nested list of integers into a single list of integers. Args: nested_list (list): The nested list of integers. Returns: list: A single flattened list containing all the integers. flattened = [] def _flatten(nested): for element in nested: if isinstance(element, list): _flatten(element) else: flattened.append(element) _flatten(nested_list) return flattened"},{"question":"# Objective Implement a function that finds the second largest element in a given binary search tree (BST). # Problem Statement You need to write a function that returns the second largest element in a binary search tree. If the tree has fewer than 2 nodes, return -1. # Function Signature ```python def find_second_largest(root: TreeNode) -> int: pass ``` # Input * `root` (TreeNode): The root node of the binary search tree. It is guaranteed to be a valid BST node instance. # Output * Return the second largest element in the BST as an integer. # Constraints * The number of nodes in the tree is between `1` and `10^4`. # Performance Requirements * The function should run in `O(n)` time complexity in the worst case and use `O(h)` space complexity, where `n` is the number of nodes and `h` is the height of the tree. # Example Example 1 Constructed BST is: ``` 5 / 3 7 / 6 8 ``` * **Input**: `root = TreeNode(5)` * After setting up the tree, `root.left = TreeNode(3)`, `root.right = TreeNode(7)`, `root.right.left = TreeNode(6)`, `root.right.right = TreeNode(8)`. * **Output**: `7`, as the largest element is `8` and the second largest is `7`. Example 2 Constructed BST is: ``` 1 ``` * **Input**: `root = TreeNode(1)` * **Output**: `-1`, as there are fewer than 2 nodes in the tree. # Additional Notes * Consider traversing the tree to find the largest element first and then using that information to find the second largest element. * Ensure efficient handling of edge cases like single-node trees or trees where the second largest element is the parent of the largest element.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_second_largest(root: TreeNode) -> int: if not root or (not root.left and not root.right): return -1 def find_largest(node): while node.right: node = node.right return node parent = None current = root while current.right: parent = current current = current.right if current.left: second_largest = find_largest(current.left).val else: second_largest = parent.val if parent else -1 return second_largest"},{"question":"# Social Network Friend Suggestion Based on Mutual Interests You are tasked with implementing a function to suggest new friends to a user based on mutual interests in a simplified social network system. This problem will help assess your skills in graph traversal and algorithmic problem-solving. Problem Statement Design and implement the function `suggest_friends(user, graph)` which evaluates the social network graph and makes friend suggestions for the given user based on shared interests. # Function Definitions: 1. **`suggest_friends(user, graph)`**: - **Input**: - `user`: A string representing the user for whom friend suggestions are to be made. - `graph`: A dictionary where keys are user names (strings) and values are sets of interests (strings) pertaining to each user. - **Output**: A list of tuples where each tuple contains two elements: the suggested friend\'s name (string) and the count of shared interests (integer). The list should be sorted in descending order of shared interests. Example: ```python user = \'alice\' graph = { \'alice\': {\'music\', \'art\', \'technology\'}, \'bob\': {\'music\', \'sports\', \'technology\'}, \'carol\': {\'art\', \'technology\', \'gaming\'}, \'dave\': {\'gaming\', \'sports\'}, \'eve\': {\'music\', \'gaming\', \'art\'} } suggestions = suggest_friends(user, graph) print(suggestions) ``` Expected Output: ```python [(\'bob\', 2), (\'carol\', 2), (\'eve\', 2), (\'dave\', 0)] ``` # Additional Requirements: - Exclude the user themselves from the suggestions. - Handle edge cases such as users with no interests or a user not present in the graph. - Optimize your solution to work efficiently even as the size of the graph increases.","solution":"def suggest_friends(user, graph): Suggests new friends to a user based on mutual interests. Parameters: user (str): The user for whom friend suggestions are to be made. graph (dict): A dictionary where keys are user names (strings) and values are sets of interests (strings) pertaining to each user. Returns: list: A list of tuples with each tuple containing the suggested friend\'s name (string) and the count of shared interests (integer), sorted in descending order of shared interests. if user not in graph: return [] user_interests = graph.get(user, set()) suggestions = [] for friend, interests in graph.items(): if friend != user: shared_interests = user_interests & interests suggestions.append((friend, len(shared_interests))) # Sort suggestions by the number of shared interests in descending order suggestions.sort(key=lambda x: x[1], reverse=True) return suggestions"},{"question":"# Question: Managing Inventory in a Warehouse **Context:** In a warehouse management system, you are required to keep track of products and manage the inventory efficiently. Each product has a unique identifier, a name, and the available quantity in stock. You need to build a function to add new products, update existing products, and query the current stock levels. **Problem Statement:** Create a class `Warehouse` that supports adding products, updating quantities, and querying stock levels. Implement the following methods: 1. `add_product(product_id: int, name: str, quantity: int) -> None`: Adds a new product to the warehouse. If the product already exists, it should raise a `KeyError` with an appropriate error message. 2. `update_quantity(product_id: int, quantity: int) -> None`: Updates the quantity of an existing product. If the product does not exist, it should raise a `KeyError` with an appropriate error message. 3. `query_stock(product_id: int) -> int`: Returns the current stock level of the specified product. If the product does not exist, it should raise a `KeyError` with an appropriate error message. **Class Signature:** ```python class Warehouse: def __init__(self): pass def add_product(self, product_id: int, name: str, quantity: int) -> None: pass def update_quantity(self, product_id: int, quantity: int) -> None: pass def query_stock(self, product_id: int) -> int: pass ``` **Input:** * `product_id`: An integer representing the unique identifier of the product. * `name`: A string representing the name of the product. * `quantity`: An integer representing the quantity of the product to add or update. **Output:** * `add_product`: No return value. * `update_quantity`: No return value. * `query_stock`: An integer representing the quantity of the specified product. **Constraints:** * `product_id` must be a unique integer. * `name` must be a non-empty string. * `quantity` must be a non-negative integer. **Examples:** ```python # Example 1: wh = Warehouse() wh.add_product(1, \\"Widget\\", 100) wh.update_quantity(1, 150) print(wh.query_stock(1)) # Expected output: 150 # Example 2: wh.add_product(2, \\"Gadget\\", 50) print(wh.query_stock(2)) # Expected output: 50 # Example 3: wh.add_product(3, \\"Doodad\\", 25) wh.update_quantity(3, 75) print(wh.query_stock(3)) # Expected output: 75 # Example 4: try: wh.add_product(1, \\"Widget\\", 200) # This should raise an error as product_id 1 already exists. except KeyError as e: print(e) # Expected output: KeyError: Product with the given id already exists. # Example 5: try: wh.update_quantity(4, 10) # This should raise an error as product_id 4 does not exist. except KeyError as e: print(e) # Expected output: KeyError: Product with the given id does not exist. # Example 6: try: wh.query_stock(4) # This should raise an error as product_id 4 does not exist. except KeyError as e: print(e) # Expected output: KeyError: Product with the given id does not exist. ``` Ensure efficient handling of erroneous inputs and maintain the integrity of the data stored in the warehouse management system.","solution":"class Warehouse: def __init__(self): self.inventory = {} def add_product(self, product_id: int, name: str, quantity: int) -> None: if product_id in self.inventory: raise KeyError(f\\"Product with the given id already exists.\\") self.inventory[product_id] = {\\"name\\": name, \\"quantity\\": quantity} def update_quantity(self, product_id: int, quantity: int) -> None: if product_id not in self.inventory: raise KeyError(f\\"Product with the given id does not exist.\\") self.inventory[product_id][\\"quantity\\"] = quantity def query_stock(self, product_id: int) -> int: if product_id not in self.inventory: raise KeyError(f\\"Product with the given id does not exist.\\") return self.inventory[product_id][\\"quantity\\"]"},{"question":"# Coding Question: Palindrome String and Vowel Analysis Objective: You are tasked with writing three functions: one to check if a given string is a palindrome, another to count the number of vowels in the string, and a third function that integrates these two functionalities to analyze the string. Problem Statement: Write a function `analyze_string(s: str) -> tuple` that takes as input a string. This function should return a tuple containing: 1. A boolean indicating whether the string is a palindrome. 2. The count of vowels in the string. Function Signature: ```python def analyze_string(s: str) -> tuple: pass ``` Expected Input and Output: - **Input**: A string (e.g., \\"level\\") - **Output**: A tuple (boolean, int) where the first element is True if the string is a palindrome and False if it is not, and the second element is the count of vowels in the string. Constraints: - The input string will contain at least one character. - A single character string should be considered a palindrome. Performance Requirements: - Time complexity should be O(n) - Space complexity should be O(1) Example: ```python >>> analyze_string(\\"level\\") (True, 2) >>> analyze_string(\\"hello\\") (False, 2) >>> analyze_string(\\"A man a plan a canal Panama\\") (False, 10) ``` Additional Requirements: - Case should be ignored while checking for palindromes and counting vowels. - Vowels include \'a\', \'e\', \'i\', \'o\', \'u\' (both uppercase and lowercase). - If the input string either doesn’t contain any letters, it should still correctly identify palindromes and count vowels.","solution":"def is_palindrome(s: str) -> bool: Returns True if s is a palindrome, False otherwise s = s.lower() return s == s[::-1] def count_vowels(s: str) -> int: Returns the number of vowels in s vowels = \'aeiou\' return sum(1 for char in s.lower() if char in vowels) def analyze_string(s: str) -> tuple: Analyzes the string s and returns a tuple (is_palindrome, vowel_count) return (is_palindrome(s), count_vowels(s))"},{"question":"# Coding Question **Context**: A community center is organizing a series of workshops for kids and wants to track attendance for each session. They need a tool to help manage and report on this attendance data effectively. **Task**: Write a Python function `generate_attendance_report` that: 1. Takes a dictionary where keys are session names and values are lists of attendees. 2. Generates a summary report that shows each session along with the number of attendees and their names. 3. Supports saving the report to a file or printing it directly based on input parameters. **Function Signature**: ```python def generate_attendance_report(attendance: Dict[str, List[str]], file_path: str=None) -> None: Generates an attendance report for given sessions. If file_path is provided, saves the report to the file. Otherwise, prints the report. :param attendance: dict - the dictionary with session names as keys and lists of attendee names as values :param file_path: str - optional, the path to the file where the report should be saved pass ``` **Constraints**: * The function should handle empty lists of attendees correctly. * The function should gracefully handle invalid inputs by raising appropriate exceptions. * Ensure the report format matches the example in the given code snippet. **Example**: When calling `generate_attendance_report({\\"Session 1\\": [\\"Alice\\", \\"Bob\\"], \\"Session 2\\": [\\"Charlie\\"]})` without `file_path`: ``` Session 1: Number of attendees: 2 Attendees: Alice, Bob Session 2: Number of attendees: 1 Attendees: Charlie ``` When calling `generate_attendance_report({\\"Workshop A\\": [\\"David\\", \\"Eva\\", \\"Frank\\"]}, \\"attendance_report.txt\\")`, the content of `attendance_report.txt` should be: ``` Workshop A: Number of attendees: 3 Attendees: David, Eva, Frank ``` Here, **\\"attendance_report.txt\\"** is the name of the file to save the attendance report. Additionally, ensure your implementation considers performance implications for large attendance records and handles edge cases appropriately.","solution":"from typing import Dict, List def generate_attendance_report(attendance: Dict[str, List[str]], file_path: str=None) -> None: Generates an attendance report for given sessions. If file_path is provided, saves the report to the file. Otherwise, prints the report. :param attendance: dict - the dictionary with session names as keys and lists of attendee names as values :param file_path: str - optional, the path to the file where the report should be saved if not isinstance(attendance, dict): raise ValueError(\\"The attendance should be a dictionary\\") report_lines = [] for session, attendees in attendance.items(): if not isinstance(session, str) or not isinstance(attendees, list): raise ValueError(\\"Each key should be a string and each value should be a list of strings\\") attendees_list = \\", \\".join(attendees) report_lines.append(f\\"{session}:nNumber of attendees: {len(attendees)}nAttendees: {attendees_list}n\\") report = \\"n\\".join(report_lines) if file_path: with open(file_path, \'w\') as file: file.write(report) else: print(report)"},{"question":"# URL Shortener Service You are tasked with creating a URL shortening service similar to bit.ly. The service should generate a unique short URL for a given long URL and provide a way to retrieve the original long URL from a previously generated short URL. Your task is to implement a class `UrlShortener` which includes methods to: 1. **Shorten URL**: Create a short URL for a given long URL. 2. **Retrieve Original URL**: Given a short URL, retrieve the corresponding original long URL. # Requirements 1. Implement the class `UrlShortener` with the following methods: * **`__init__(self)`**: * Initialize any necessary data structures to store URL mappings. * **`shorten_url(self, long_url: str) -> str`**: * Generate a unique short URL for the provided long URL. * Store the mapping between the long URL and the short URL. * Handle the potential duplication by ensuring each long URL gets a unique short URL. * **`retrieve_url(self, short_url: str) -> str`**: * Look up and return the original long URL for the given short URL. * Handle scenarios where the short URL does not exist. 2. Consider edge cases and error handling, including invalid inputs and URL collisions. # Constraints * The short URL should be significantly shorter than the original URL and can use a combination of alphanumeric characters. * The service should handle at least 10,000 unique URLs. * Ensure that the service efficiently maps long URLs to short URLs and vice versa. # Example Usage ```python service = UrlShortener() # Shorten a long URL short_url = service.shorten_url(\\"https://www.example.com/some/very/long/url\\") print(f\\"Short URL: {short_url}\\") # Retrieve the original long URL from the short URL original_url = service.retrieve_url(short_url) print(f\\"Original URL: {original_url}\\") ``` # Expected Input & Output * **Input**: `shorten_url(\\"https://www.example.com/some/very/long/url\\")` * **Output**: `str` representing the generated short URL. * **Input**: `retrieve_url(\\"short_url\\")` * **Output**: `str` representing the original long URL. Implement the `UrlShortener` class as specified and ensure thorough testing for various scenarios.","solution":"import hashlib class UrlShortener: def __init__(self): self.url_map = {} self.short_url_prefix = \\"http://short.url/\\" def _generate_short_url(self, long_url: str) -> str: Helper method to generate a hash-based short URL from a long URL. hash_object = hashlib.md5(long_url.encode()) short_url_suffix = hash_object.hexdigest()[:8] # Use the first 8 characters of the hash short_url = self.short_url_prefix + short_url_suffix return short_url def shorten_url(self, long_url: str) -> str: Generate a unique short URL for the given long URL. Store the mapping between the long URL and the short URL. if not long_url: raise ValueError(\\"Invalid URL: URL cannot be empty\\") # Check if the long URL already exists short_url = self._generate_short_url(long_url) if short_url not in self.url_map: self.url_map[short_url] = long_url return short_url def retrieve_url(self, short_url: str) -> str: Retrieve the original long URL from the short URL. if not short_url.startswith(self.short_url_prefix): raise ValueError(\\"Invalid short URL\\") return self.url_map.get(short_url, \\"URL not found\\")"},{"question":"# Problem Statement You are given a list of integers where each integer represents the height of a building. Your task is to implement a function that finds the maximum area of water that can be trapped between the buildings, based on the skyline silhouette defined by the heights. # Function Signature ```python def max_trapped_water(heights: List[int]) -> int: pass ``` # Input * `heights`: A list of integers representing the heights of buildings. # Output * An integer representing the maximum area of water trapped. # Constraints * The list `heights` will have at least 2 elements and at most 100,000 elements. * Each element in `heights` will be a non-negative integer and less than or equal to 10,000. # Performance Requirements * Your algorithm should aim for a time complexity of O(n) where n is the number of buildings. # Example ```python heights = [1,8,6,2,5,4,8,3,7] print(max_trapped_water(heights)) # Expected Output: 49 ``` # Notes * The area of water trapped between two buildings is determined by the shorter building\'s height times the distance between the two buildings. * Ensure to handle edge cases where the heights potentially have zero water trapped. --- # Problem Approach 1. The optimal approach to this problem uses the two-pointer technique. Initialize two pointers at the beginning and end of the list. 2. Move the pointers towards each other, and at each step, calculate the area of the trapped water between the buildings at the pointers. 3. Record the maximum area and return it at the end. ---","solution":"def max_trapped_water(heights): Returns the maximum area of water that can be trapped between the buildings. :param list heights: List of non-negative integers representing the heights of buildings. :return: An integer representing the maximum area of water trapped. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Problem Statement You are tasked with implementing a Range-Sum Query Processor that supports both updating individual elements and querying the sum of elements within a specified range. # Requirements 1. **Initialization:** - Initialize the processor with an array of integers. 2. **Operations:** - **Update(i, x)**: Update the value at index `i` to `x`. - **Sum(l, r)**: Return the sum of the elements from index `l` to index `r` (inclusive). # Input Format - An integer `n` (number of elements in the array, `n > 0`). - A list of `n` integers representing the initial array. - A sequence of operations and their values. # Output Format - For a **sum** operation, return the computed sum for the specified range. # Constraints - The number of elements `n` is a positive integer. - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. - Each index used in operations is 0-based and within the range `[0, n-1]`. # Example ```python # Initial array: [1, 2, 3, 4, 5] # Sequence of operations operations = [ (\\"sum\\", 1, 3), # Output: 9 (\\"update\\", 2, 10), (\\"sum\\", 1, 3), # Output: 16 ] array = [1, 2, 3, 4, 5] processor = RangeSumQueryProcessor(array) for operation in operations: if operation[0] == \\"update\\": processor.update(operation[1], operation[2]) elif operation[0] == \\"sum\\": print(processor.sum(operation[1], operation[2])) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python class RangeSumQueryProcessor: def __init__(self, array: list) -> None: self.array = array self.n = len(array) self.prefix_sum = self._build_prefix_sum() def _build_prefix_sum(self): # Build the initial prefix sum array prefix_sum = [0] * (self.n + 1) for i in range(self.n): prefix_sum[i + 1] = prefix_sum[i] + self.array[i] return prefix_sum def update(self, i: int, x: int): # Update the element at index i and adjust the prefix sum delta = x - self.array[i] self.array[i] = x for j in range(i + 1, self.n + 1): self.prefix_sum[j] += delta def sum(self, l: int, r: int) -> int: # Return the sum of elements from index l to r return self.prefix_sum[r + 1] - self.prefix_sum[l] ``` # Notes - Pay close attention to the efficient update and sum operations to ensure short query times. - Handle edge cases such as empty array initialization or invalid index updates gracefully within your implementation.","solution":"class RangeSumQueryProcessor: def __init__(self, array: list) -> None: self.array = array self.n = len(array) self.prefix_sum = self._build_prefix_sum() def _build_prefix_sum(self): # Build the initial prefix sum array prefix_sum = [0] * (self.n + 1) for i in range(self.n): prefix_sum[i + 1] = prefix_sum[i] + self.array[i] return prefix_sum def update(self, i: int, x: int): # Update the element at index i and adjust the prefix sum delta = x - self.array[i] self.array[i] = x for j in range(i + 1, self.n + 1): self.prefix_sum[j] += delta def sum(self, l: int, r: int) -> int: # Return the sum of elements from index l to r return self.prefix_sum[r + 1] - self.prefix_sum[l]"},{"question":"# Coding Assessment Question Objective To test the ability to work with dictionaries and text processing in Python. Question You are provided with a large string representing a paragraph of text. Your task is to write a function that finds the longest word in the string that is not a common English stop word. Function Signature ```python def longest_non_stop_word(paragraph: str) -> str: Returns the longest word in the paragraph that is not a stop word. :param paragraph: A string representing a paragraph of text. :return: The longest word in the paragraph that is not a stop word. ``` Inputs 1. `paragraph`: A string containing a paragraph of text. (1 ≤ len(paragraph) ≤ 10^5) Outputs - A string representing the longest word in the paragraph that is not a stop word. Constraints - The function should ignore the case of the letters (e.g., treat \\"Word\\" and \\"word\\" as the same). - Punctuation should not be considered as part of words. - If multiple words have the same length, return the one that appears first in the paragraph. - Filter out common English stop words such as: \\"a\\", \\"the\\", \\"and\\", \\"in\\", \\"is\\", \\"it\\", \\"of\\", \\"to\\", \\"that\\", \\"with\\", \\"as\\", \\"for\\", \\"on\\", \\"was\\", \\"are\\", \\"by\\", \\"this\\", \\"which\\", \\"at\\". Example ```python >>> paragraph = \\"The quick brown fox jumps over the lazy dog. It was a bright cold day in April, and the clocks were striking thirteen.\\" >>> longest_non_stop_word(paragraph) \\"striking\\" >>> paragraph = \\"In the world of programming, Python is loved by many developers due to its simplicity and readability.\\" >>> longest_non_stop_word(paragraph) \\"programming\\" >>> paragraph = \\"Hello world!\\" >>> longest_non_stop_word(paragraph) \\"Hello\\" ``` Notes * Consider edge cases where the input string is empty or contains only stop words. * Optimize the function to run efficiently for large input sizes. * Use a predefined list of stop words for filtering. * Ensure to handle case insensitivity and punctuation properly. # Sample Implementation ```python def longest_non_stop_word(paragraph: str) -> str: stop_words = {\\"a\\", \\"the\\", \\"and\\", \\"in\\", \\"is\\", \\"it\\", \\"of\\", \\"to\\", \\"that\\", \\"with\\", \\"as\\", \\"for\\", \\"on\\", \\"was\\", \\"are\\", \\"by\\", \\"this\\", \\"which\\", \\"at\\"} def clean_word(word): return \'\'.join([char for char in word if char.isalpha()]) words = paragraph.lower().split() longest_word = \\"\\" for word in words: clean_w = clean_word(word) if clean_w and clean_w not in stop_words and len(clean_w) > len(longest_word): longest_word = clean_w return longest_word # Testing the function print(longest_non_stop_word(\\"The quick brown fox jumps over the lazy dog. It was a bright cold day in April, and the clocks were striking thirteen.\\")) # \\"striking\\" print(longest_non_stop_word(\\"In the world of programming, Python is loved by many developers due to its simplicity and readability.\\")) # \\"programming\\" print(longest_non_stop_word(\\"Hello world!\\")) # \\"Hello\\" ``` This question assesses the candidate\'s skills with strings, dictionaries, text cleaning, and applying basic algorithms efficiently. It aligns well with the original question set in terms of style, complexity, and domain.","solution":"def longest_non_stop_word(paragraph: str) -> str: stop_words = {\\"a\\", \\"the\\", \\"and\\", \\"in\\", \\"is\\", \\"it\\", \\"of\\", \\"to\\", \\"that\\", \\"with\\", \\"as\\", \\"for\\", \\"on\\", \\"was\\", \\"are\\", \\"by\\", \\"this\\", \\"which\\", \\"at\\"} def clean_word(word): return \'\'.join([char for char in word if char.isalpha()]) words = paragraph.lower().split() longest_word = \\"\\" for word in words: clean_w = clean_word(word) if clean_w and clean_w not in stop_words and len(clean_w) > len(longest_word): longest_word = clean_w return longest_word"},{"question":"# Time Conversion Utility **Context**: You are developing a time management application that involves working with time in various formats frequently. One common requirement is the need to convert time from one format to another easily and accurately. You need to implement a utility that converts time from a 12-hour format with an AM/PM indicator to a 24-hour format, ensuring proper handling and validation of the input. **Task**: Implement a function `convert_to_24_hour_format` that takes a time string in the 12-hour format along with an AM/PM indicator and converts it to the corresponding 24-hour format. **Function Signature**: ```python def convert_to_24_hour_format(time_str: str) -> str: pass ``` **Input**: * `time_str`: A string representing the time in 12-hour format with an AM/PM indicator (e.g., \\"02:30 PM\\", \\"11:45 AM\\"). **Output**: * A string representing the time in 24-hour format (e.g., \\"14:30\\", \\"11:45\\"). **Constraints**: * The input `time_str` will always be a valid time in 12-hour format. * The input time will be within the range \\"01:00 AM\\" to \\"12:59 PM\\". * Consider edge cases like \\"12:00 AM\\" (midnight) and \\"12:00 PM\\" (noon). * The function should return the 24-hour format in \\"HH:MM\\" format exactly. **Examples**: ```python print(convert_to_24_hour_format(\\"02:30 PM\\")) # Should return \\"14:30\\" print(convert_to_24_hour_format(\\"11:45 AM\\")) # Should return \\"11:45\\" print(convert_to_24_hour_format(\\"12:00 PM\\")) # Should return \\"12:00\\" print(convert_to_24_hour_format(\\"12:00 AM\\")) # Should return \\"00:00\\" ``` # Guidelines: 1. Ensure that your function correctly interprets the AM/PM indicators and converts the hour portion accurately. 2. The function should handle leading zeros appropriately in the hour and minute portions. 3. Test the function with various time inputs to ensure correctness and handle edge cases like midnight and noon. Note that the aim is to provide a robust and user-friendly time conversion utility that integrates seamlessly into your time management application. Make sure to validate and test thoroughly.","solution":"def convert_to_24_hour_format(time_str: str) -> str: Converts a 12-hour time format string to a 24-hour time format string. Args: time_str (str): A string representing the time in 12-hour format with AM/PM. Returns: str: A string representing the time in 24-hour format. # Extract the hour, minute, and AM/PM parts time, period = time_str.split(\' \') hour, minute = map(int, time.split(\':\')) # Convert hour based on AM/PM period if period == \\"AM\\": if hour == 12: # Midnight case hour = 0 elif period == \\"PM\\": if hour != 12: # Convert PM hour unless it\'s the 12 PM case hour += 12 # Return the formatted time in 24-hour format return f\\"{hour:02}:{minute:02}\\""},{"question":"# Problem Statement: Binary String Analysis You need to create a function that accepts a binary string and evaluates certain characteristics of the binary number. Specifically, the function will determine if the given binary string is a power of 2 and calculate the Hamming weight (the number of 1s in the binary string). # Function Signature ```python def analyze_binary_string(binary_string: str) -> tuple: pass ``` # Input * `binary_string` - A string representation of a binary number. Example: \\"1100\\", which can include leading zeros. # Output * A tuple containing two elements: 1. A boolean value indicating whether the binary string represents a power of 2. 2. An integer representing the Hamming weight of the binary string. # Constraints * The input string contains only characters `0` and `1`. * Input length is at least one character and up to 32 characters. # Requirements * Return a tuple with the results based on the binary string analysis. * A Hamming weight of a binary number is the sum of its `1` bits. * A binary string representing a power of 2 will have exactly one `1` bit and the rest `0` bits. # Example Usage ```python >>> analyze_binary_string(\\"1000\\") (True, 1) >>> analyze_binary_string(\\"1010\\") (False, 2) >>> analyze_binary_string(\\"110000\\") (False, 2) >>> analyze_binary_string(\\"00100\\") (True, 1) >>> analyze_binary_string(\\"00011\\") (False, 2) ``` # Additional Notes * You are not allowed to use Python’s built-in functions that directly convert binary to decimal to determine if it\'s a power of 2. * Ensure to handle and test edge cases such as strings with only one digit and strings with leading zeros.","solution":"def analyze_binary_string(binary_string: str) -> tuple: Analyzes a binary string to determine if it represents a power of 2 and calculates its Hamming weight. Parameters: binary_string (str): A string representing a binary number. Returns: tuple: A boolean indicating if it\'s a power of 2 and an integer representing the Hamming weight. # Removing leading zeros binary_string = binary_string.lstrip(\'0\') if not binary_string: return (False, 0) # Hamming weight calculation hamming_weight = sum(1 for bit in binary_string if bit == \'1\') # Check if the binary number is a power of 2 is_power_of_2 = hamming_weight == 1 return (is_power_of_2, hamming_weight)"},{"question":"# Problem Statement: You are given a list of integers representing the heights of vertical lines drawn at equal distance apart. Your task is to determine the maximum volume of water that can be trapped between two lines after raining. # Detailed Instructions: 1. **Initial State**: You have an array of integers `height`, where each integer represents the height of a vertical line at that position. 2. **Trapping Water**: The volume of water trapped between the lines at indices `i` and `j` is calculated as `(j - i) * min(height[i], height[j])`. 3. **Optimization**: Find the two lines that, together with the x-axis, form a container capable of holding the maximum volume of water. 4. **Output**: Return the maximum volume of water that can be trapped. # Input and Output: - **Input**: A list of non-negative integers representing the height of the vertical lines. - **Output**: An integer representing the maximum volume of water that can be trapped. # Constraints: - The length of the input list is at least 2. - Each value in the input list is a non-negative integer no larger than 10^4. - The maximum length of the list is 10^5. # Function Signature: ```python def max_water_volume(height: List[int]) -> int: pass ``` # Example: ```python >>> max_water_volume([1,8,6,2,5,4,8,3,7]) 49 ``` In this example, the maximum volume of water is trapped between the vertical lines at indices 1 and 8 with a max volume of 49 units. # Notes: - Utilize a two-pointer approach to solve this problem efficiently. - Ensure that your solution runs in O(n) time complexity and uses O(1) additional space. This question tests a candidate’s understanding of algorithms, specifically the two-pointer technique, and their ability to optimize for both time and space complexity.","solution":"def max_water_volume(height): Returns the maximum volume of water that can be trapped between the vertical lines. left, right = 0, len(height) - 1 max_volume = 0 while left < right: current_volume = (right - left) * min(height[left], height[right]) max_volume = max(max_volume, current_volume) if height[left] < height[right]: left += 1 else: right -= 1 return max_volume"},{"question":"# Problem Statement You are tasked with simulating a simple machine learning classifier based on linear regression. Your classifier will predict an output value given a single input value using the linear equation `y = mx + c`, where `m` is the slope and `c` is the y-intercept. Create a function `predict_output(m: float, c: float, x: float) -> float` that takes the slope `m`, the y-intercept `c`, and an input value `x`, and returns the predicted output value based on the linear equation. # Input - A float `m` representing the slope of the line. - A float `c` representing the y-intercept of the line. - A float `x` representing the input value. # Output - The function should return the predicted output value as a float. # Constraints - The inputs `m`, `c`, and `x` can be any real number. # Example - `predict_output(2.0, 1.0, 3.0)` should return `7.0` because (2.0 cdot 3.0 + 1.0 = 7.0). - `predict_output(0.5, -1.0, 4.0)` should return `1.0` because (0.5 cdot 4.0 - 1.0 = 1.0). # Implementation Note Ensure that your implementation correctly computes the output using the formula ( y = mx + c ) without any additional constraints or optimizations.","solution":"def predict_output(m: float, c: float, x: float) -> float: Predicts the output value based on the linear equation y = mx + c. Parameters: - m (float): Slope of the line. - c (float): Y-intercept of the line. - x (float): Input value. Returns: - float: The predicted output value. return m * x + c"},{"question":"# Fibonacci Number Checker You need to implement a function that determines whether a given number is a Fibonacci number. Fibonacci numbers form a sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1. Function Specification 1. **Function name**: `is_fibonacci_number` - **Input**: `number` (int) - the number to be checked. - **Output**: (bool) - `True` if the number is a Fibonacci number, otherwise `False`. - **Constraints**: - `number` should be a non-negative integer. Implementation Details To check if a number is a Fibonacci number, you can use a property of Fibonacci numbers: A number `n` is a Fibonacci number if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. Example *Inputs*: ```python print(is_fibonacci_number(34)) # Expected output: True print(is_fibonacci_number(35)) # Expected output: False print(is_fibonacci_number(144)) # Expected output: True print(is_fibonacci_number(150)) # Expected output: False ``` *Outputs*: ```python True False True False ``` If the `number` is not valid (negative or not an integer), the function should raise a `ValueError` with the message \\"Number must be a non-negative integer.\\" Requirements - Implement and thoroughly test the function. - Handle edge cases and invalid inputs appropriately. **Note**: - You can implement a helper function to check if a number is a perfect square. - Performance considerations should be taken into account for large numbers.","solution":"import math def is_perfect_square(x): Check if x is a perfect square. s = int(math.sqrt(x)) return s * s == x def is_fibonacci_number(number): Check if the number is a Fibonacci number. if not isinstance(number, int) or number < 0: raise ValueError(\\"Number must be a non-negative integer.\\") # A number is a Fibonacci number if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square n1 = 5 * number ** 2 + 4 n2 = 5 * number ** 2 - 4 return is_perfect_square(n1) or is_perfect_square(n2)"},{"question":"# Additional Question in Alignment with the Existing Set # Problem Statement You are required to implement a function that identifies the longest substring of distinct characters in a given string. The function should return the length of this longest substring. # Function Signature ```python def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring with distinct characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring with all distinct characters. Example: >>> length_of_longest_substring(\\"abcabcbb\\") 3 pass ``` # Constraints - The input string `s` can contain any printable ASCII characters. - The length of the string `s` is at most 10^5 characters. # Performance Requirements - The solution should efficiently handle inputs where the length of `s` is at most 10^5 characters, with a linear time complexity. # Example Usage ```python assert length_of_longest_substring(\\"abcabcbb\\") == 3 assert length_of_longest_substring(\\"bbbbb\\") == 1 assert length_of_longest_substring(\\"pwwkew\\") == 3 assert length_of_longest_substring(\\"abcdef\\") == 6 assert length_of_longest_substring(\\"\\") == 0 ``` # Implementation Notes Use a sliding window approach with a set to keep track of the characters in the current window. Adjust the window as necessary to maintain the property of having only distinct characters. This will allow you to achieve the required performance.","solution":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring with distinct characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring with all distinct characters. n = len(s) char_set = set() l = 0 max_length = 0 for r in range(n): while s[r] in char_set: char_set.remove(s[l]) l += 1 char_set.add(s[r]) max_length = max(max_length, r - l + 1) return max_length"},{"question":"**Question:** # Array Product Except Self Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The solution must be provided without using division and should have a time complexity of O(n). # Input: - `nums` (List[int]): The input array of integers. (2 <= len(nums) <= 10^5) # Output: - (List[int]): An output array such that each index `i` contains the product of all elements of `nums` except `nums[i]`. # Examples: ```python # Example Case 1 # Input: nums = [1, 2, 3, 4] # Output: [24, 12, 8, 6] # Explanation: The product array is calculated as follows: # answer[0] = 2 * 3 * 4 = 24 # answer[1] = 1 * 3 * 4 = 12 # answer[2] = 1 * 2 * 4 = 8 # answer[3] = 1 * 2 * 3 = 6 # Example Case 2 # Input: nums = [-1, 1, 0, -3, 3] # Output: [0, 0, 9, 0, 0] # Explanation: The product array is calculated as follows: # answer[0] = 1 * 0 * -3 * 3 = 0 # answer[1] = -1 * 0 * -3 * 3 = 0 # answer[2] = -1 * 1 * -3 * 3 = 9 # answer[3] = -1 * 1 * 0 * 3 = 0 # answer[4] = -1 * 1 * 0 * -3 = 0 ``` # Constraints: - The input list `nums` will always have at least two elements. - You are not allowed to use division in the solution. - The solution should have O(n) time complexity. # Hints: 1. Use two additional arrays to store the product of all elements to the left and to the right of each index. 2. Iterate through the list to fill these arrays and compute the final product array. Write your function implementation below: ```python from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) answer = [1] * length left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer # Testing the function print(product_except_self([1, 2, 3, 4])) # Output: [24, 12, 8, 6] print(product_except_self([-1, 1, 0, -3, 3])) # Output: [0, 0, 9, 0, 0] ```","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) answer = [1] * length left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"# Coding Assessment Question **Scenario**: You are working on a system that manages banking operations. One essential feature is to calculate and track the balance on multiple accounts after a certain number of transactions. Your task is to implement a function that processes a list of transactions and returns the final balances of the specified accounts. **Objective**: Write a function `calculate_balances` to: 1. Update account balances based on a list of transactions. 2. Return the final balance for each account in a dictionary format. **Function Signature**: ```python def calculate_balances(account_balances: dict[str, int], transactions: list[tuple[str, int]]) -> dict[str, int]: Update balances based on a list of transactions. Args: - account_balances (dict[str, int]): A dictionary with account numbers as keys and their initial balances as values. - transactions (list[tuple[str, int]]): A list of tuples, each representing a transaction where the first element is the account number (str) and the second element is the transaction amount (int). Returns: - dict[str, int]: A dictionary with updated account balances where keys are account numbers and values are their final balances. ``` **Constraints**: - **Input**: - `account_balances`: A non-empty dictionary where keys are account numbers (strings) and values are their initial balances (integers). - `transactions`: A list of tuples where each tuple contains an account number (string) and a transaction amount (integer). - **Output**: - A dictionary where each key is an account number and the corresponding value is the final balance after processing all transactions. **Example**: ```python account_balances = { \\"12345\\": 1000, \\"67890\\": 2000 } transactions = [ (\\"12345\\", -200), (\\"67890\\", 300), (\\"12345\\", 500), (\\"12345\\", -1000) ] result = calculate_balances(account_balances, transactions) Expected Output: { \\"12345\\": 300, \\"67890\\": 2300 } ``` **Guidelines for Implementation**: 1. **Transaction Processing**: Ensure that all transactions are applied in the order they are provided. 2. **Error Handling**: Handle cases where transactions refer to non-existent accounts by ignoring such transactions. 3. **Efficiency**: Aim for an efficient solution with a reasonable time complexity. 4. **Edge Cases**: Consider cases with negative balances, but assume that no transactions will result in invalid states beyond simple subtraction.","solution":"def calculate_balances(account_balances, transactions): Update balances based on a list of transactions. Args: - account_balances (dict[str, int]): A dictionary with account numbers as keys and their initial balances as values. - transactions (list[tuple[str, int]]): A list of tuples, each representing a transaction where the first element is the account number (str) and the second element is the transaction amount (int). Returns: - dict[str, int]: A dictionary with updated account balances where keys are account numbers and values are their final balances. for account_number, amount in transactions: if account_number in account_balances: account_balances[account_number] += amount return account_balances"},{"question":"# Context You are required to implement a rudimentary web crawler that can traverse web pages starting from a given URL and collect all hyperlinks. The crawler should be concurrent to speed up the process, using Python\'s `asyncio` and `aiohttp` libraries. It should limit the depth of traversal and the number of concurrent connections. # Problem Statement Implement a `WebCrawler` class that supports the following methods: - `fetch(self, url: str)`: Fetches the content of the URL and returns it as a string. - `extract_links(self, content: str)`: Extracts and returns a list of hyperlinks from the content. - `crawl(self, start_url: str, max_depth: int, max_concurrent: int)`: Starts crawling from the `start_url` up to a maximum depth of `max_depth` using at most `max_concurrent` concurrent network connections. # Requirements 1. Use `aiohttp` to handle asynchronous HTTP requests. 2. Use `asyncio` to manage concurrency. 3. Your crawler must respect the depth limit and should not revisit URLs once they have been processed. 4. Efficiently handle potential network errors. # Constraints - Use Python\'s built-in `html.parser` module or any other suitable library for HTML parsing. - Assume that the input URLs are within the same domain and well-formed. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python import aiohttp import asyncio from html.parser import HTMLParser from typing import List, Set class LinkExtractor(HTMLParser): def __init__(self): super().__init__() self.links = [] def handle_starttag(self, tag, attrs): if tag == \'a\': for attr, value in attrs: if attr == \'href\': self.links.append(value) class WebCrawler: def __init__(self): self.visited_urls = set() self.base_domain = \\"\\" async def fetch(self, url: str) -> str: # Fetch the content of the URL pass def extract_links(self, content: str) -> List[str]: # Extract and return hyperlinks from the content pass async def crawl(self, start_url: str, max_depth: int, max_concurrent: int): # Traverse web pages starting from start_url pass ``` # Example Usage ```python crawler = WebCrawler() async def main(): start_url = \'https://example.com\' max_depth = 2 max_concurrent = 10 await crawler.crawl(start_url, max_depth, max_concurrent) asyncio.run(main()) ```","solution":"import aiohttp import asyncio from html.parser import HTMLParser from urllib.parse import urljoin, urlparse from typing import List, Set class LinkExtractor(HTMLParser): def __init__(self): super().__init__() self.links = [] def handle_starttag(self, tag, attrs): if tag == \'a\': for attr, value in attrs: if attr == \'href\': self.links.append(value) class WebCrawler: def __init__(self): self.visited_urls = set() self.base_domain = \\"\\" async def fetch(self, url: str) -> str: async with aiohttp.ClientSession() as session: async with session.get(url) as response: return await response.text() def extract_links(self, content: str) -> List[str]: link_extractor = LinkExtractor() link_extractor.feed(content) return link_extractor.links async def _crawl(self, url: str, depth: int, max_depth: int, max_concurrent: int, semaphore: asyncio.Semaphore): if depth > max_depth or url in self.visited_urls: return self.visited_urls.add(url) try: async with semaphore: content = await self.fetch(url) links = self.extract_links(content) tasks = [] for link in links: full_url = urljoin(url, link) if urlparse(full_url).netloc == urlparse(url).netloc: tasks.append(asyncio.create_task(self._crawl(full_url, depth + 1, max_depth, max_concurrent, semaphore))) await asyncio.gather(*tasks) except Exception as e: print(f\\"Failed to fetch {url}: {e}\\") async def crawl(self, start_url: str, max_depth: int, max_concurrent: int): self.base_domain = urlparse(start_url).netloc semaphore = asyncio.Semaphore(max_concurrent) await self._crawl(start_url, 0, max_depth, max_concurrent, semaphore)"},{"question":"# Question: Implement an In-Place Merge Sort for Linked Lists Problem Statement Your task is to implement an in-place Merge Sort algorithm to sort a singly linked list. A singly linked list is a data structure where each node contains a data element and a pointer to the next node in the sequence. Merge sort is a divide-and-conquer algorithm that divides the list into sub-lists, sorts them, and then merges the sorted sub-lists. Input and Output * **Input**: A reference to the head node of the singly linked list. * **Output**: A reference to the head node of the sorted singly linked list. Constraints 1. The linked list can contain up to 1000 nodes. 2. Each node contains an integer value. 3. The algorithm should be implemented in-place, meaning no new lists should be created. 4. The solution should maintain O(n log n) time complexity. Example ```python # Define the linked list node class class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(head): result = [] while head: result.append(head.val) head = head.next return result # Example usage and testing head = ListNode(4, ListNode(2, ListNode(1, ListNode(3)))) sorted_head = merge_sort_linked_list(head) assert print_list(sorted_head) == [1, 2, 3, 4] head = ListNode(4, ListNode(5, ListNode(2, ListNode(3, ListNode(1))))) sorted_head = merge_sort_linked_list(head) assert print_list(sorted_head) == [1, 2, 3, 4, 5] head = None sorted_head = merge_sort_linked_list(head) assert print_list(sorted_head) == [] ``` Important Notes - You should account for edge cases, such as an empty list or a list with a single node. - Ensure that the original structure of the list nodes is maintained in place without creating any additional lists or arrays. Implementation ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head # Split the list into halves def split(head): slow, fast = head, head.next while fast and fast.next: slow, fast = slow.next, fast.next.next mid, slow.next = slow.next, None return head, mid # Merge two sorted lists def merge(l1, l2): dummy = tail = ListNode(-1) while l1 and l2: if l1.val < l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next tail.next = l1 or l2 return dummy.next # Recursively split and merge left, right = split(head) left = merge_sort_linked_list(left) right = merge_sort_linked_list(right) return merge(left, right) # Example usage if __name__ == \\"__main__\\": head = ListNode(4, ListNode(2, ListNode(1, ListNode(3)))) sorted_head = merge_sort_linked_list(head) print_list(sorted_head) # Expected output: [1, 2, 3, 4] ``` This question requires understanding of linked lists, dividing the list using a fast and slow pointer method, and merging two sorted linked lists, ensuring an in-place implementation ensuring O(n log n) time complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head # Split the list into halves def split(head): slow, fast = head, head.next while fast and fast.next: slow, fast = slow.next, fast.next.next mid, slow.next = slow.next, None return head, mid # Merge two sorted lists def merge(l1, l2): dummy = tail = ListNode(0) while l1 and l2: if l1.val < l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next tail.next = l1 or l2 return dummy.next # Recursively split and merge left, right = split(head) left = merge_sort_linked_list(left) right = merge_sort_linked_list(right) return merge(left, right)"},{"question":"# Problem Statement You are tasked with implementing a function to calculate the determinant of a given square matrix. Implement the function `calculate_determinant(matrix: np.ndarray) -> float`, which takes a 2D NumPy array `matrix` representing a square matrix, and returns the determinant of the matrix. # Input * `matrix`: A numpy array of shape (n, n), where (n) represents the number of rows and columns, denoting it a square matrix. # Output * A float representing the determinant of the matrix. # Constraints 1. You may assume the matrix sizes would not be larger than 10x10. 2. The entries in the matrix will be integers or floats. # Requirements * Implement an algorithm to calculate the determinant manually without using any built-in numpy functions directly offering the determinant. * Optimize for matrices up to the size of 10x10. * Handle edge cases such as zero rows/columns and ensure numerical precision. # Example ```python import numpy as np matrix = np.array([[1, 2], [3, 4]], dtype=float) # Example usage determinant = calculate_determinant(matrix) print(determinant) # Output should be -2.0 ```","solution":"import numpy as np def calculate_determinant(matrix: np.ndarray) -> float: Returns the determinant of a given square matrix. n = matrix.shape[0] def get_minor(matrix, i, j): Helper function to get the minor of the matrix excluding row i and column j minor = np.delete(matrix, i, axis=0) minor = np.delete(minor, j, axis=1) return minor def determinant_recursive(matrix): Recursive function to find the determinant using the Laplace expansion. if matrix.shape == (1, 1): # Base case for 1x1 matrix return matrix[0, 0] if matrix.shape == (2, 2): # Base case for 2x2 matrix return matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0] det = 0 for j in range(matrix.shape[1]): sign = (-1) ** j minor = get_minor(matrix, 0, j) det += sign * matrix[0, j] * determinant_recursive(minor) return det return determinant_recursive(matrix)"},{"question":"# Context: You are developing an analytics tool that processes log files from web servers. Part of the analysis requires identifying the most frequently accessed URLs within a given time frame in an efficient manner. # Problem Statement: Implement a function `most_frequent_urls` that takes a list of URLs and returns a list of the most frequent URLs in descending order of frequency. If there are ties, URLs should be returned in the order they first appeared in the input list. # Function Signature: ```python def most_frequent_urls(urls: List[str]) -> List[str]: pass ``` # Input: * `urls` (List[str]): A list of strings representing URLs (1 <= len(urls) <= 10^5). Each URL is a non-empty string with a maximum length of 2048 characters. # Output: * Returns a list of strings representing the URLs that are the most frequently accessed, in descending order of frequency. # Constraints: * The solution should handle large input sizes efficiently. * URLs with the same frequency should be listed in the order they first appeared. # Examples: ```python assert most_frequent_urls([]) == [] assert most_frequent_urls([\\"a.com\\", \\"b.com\\", \\"a.com\\", \\"c.com\\", \\"b.com\\", \\"a.com\\"]) == [\\"a.com\\", \\"b.com\\", \\"c.com\\"] assert most_frequent_urls([\\"a.com\\", \\"b.com\\", \\"c.com\\", \\"b.com\\", \\"a.com\\", \\"c.com\\"]) == [\\"a.com\\", \\"b.com\\", \\"c.com\\"] assert most_frequent_urls([\\"x.com\\"]) == [\\"x.com\\"] ``` # Additional Notes: * Consider using appropriate data structures to maintain the count and order efficiently. * Pay attention to edge cases such as empty input list or all URLs having the same frequency. * Ensure that your solution can scale and perform well with the maximum input size. # Evaluation: Your solution will be evaluated based on: * Correctness * Efficiency * Clarity and readability of the code * Handling of edge cases","solution":"from typing import List from collections import Counter, OrderedDict def most_frequent_urls(urls: List[str]) -> List[str]: if not urls: return [] counter = Counter(urls) ordered_counter = OrderedDict(sorted(counter.items(), key=lambda x: (-x[1], urls.index(x[0])))) return list(ordered_counter.keys())"},{"question":"# Minimum Jumps to Reach End of Array You are given an array of non-negative integers where each element represents the maximum number of steps you can take forward from that position. Your task is to find the minimum number of jumps required to reach the end of the array from the start. Function Signature ```python def min_jumps(arr: List[int]) -> int: ``` # Input * `arr` (List[int]): A list of non-negative integers representing the array. # Output * Returns an integer representing the minimum number of jumps required to reach the last index of the array starting from the first index. # Constraints * (1 leq text{len}(arr) leq 10000) * (0 leq arr[i] leq 10000) # Example ```python assert min_jumps([2, 3, 1, 1, 4]) == 2 ``` Explanation: The minimum number of jumps to reach the end of the array is 2: 1. Jump from index 0 to index 1. 2. Then jump from index 1 to index 4. # Requirements * Implement the function `min_jumps` using a greedy algorithm to efficiently find the minimum number of jumps. * Ensure that the function handles edge cases and is optimized to handle the upper limits of the constraints. # Notes * You can assume that you can always reach the last index of the array. * Consider optimizing the solution to run in linear time complexity.","solution":"from typing import List def min_jumps(arr: List[int]) -> int: if len(arr) <= 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(len(arr) - 1): farthest = max(farthest, i + arr[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= len(arr) - 1: break return jumps"},{"question":"# Scenario You are developing a task management application that includes a feature for assigning tasks to team members. The application needs to ensure that tasks are assigned evenly among team members according to their current task load. # Task Write a Python function, `assign_task_to_member(task: str, members: list[str], task_loads: dict[str, int]) -> dict[str, int]`, that assigns a new task to the team member with the least number of current tasks. # Requirements 1. **Function Signature**: ```python def assign_task_to_member(task: str, members: list[str], task_loads: dict[str, int]) -> dict[str, int]: ``` 2. **Input**: - `task`: A string representing the task description. - `members`: A list of strings, where each string is the name of a team member. - `task_loads`: A dictionary where keys are member names and values are the number of tasks currently assigned to them. 3. **Output**: A dictionary representing the updated task loads after assigning the new task. - The dictionary should have the same structure as `task_loads`. - The dictionary should include the key for the member assigned the new task, with their task load incremented by one. 4. **Constraints**: - Assume that `members` contains only unique names. - Assume that `task_loads` contains a valid entry for every member. - Handle possible empty input for `members` and `task_loads`. - If multiple members have the same minimal task load, assign the task to the member who appears first in the `members` list. # Example ```python task = \\"Complete the design document\\" members = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] task_loads = {\\"Alice\\": 3, \\"Bob\\": 5, \\"Charlie\\": 2} updated_task_loads = assign_task_to_member(task, members, task_loads) ``` Output: ```python { \\"Alice\\": 3, \\"Bob\\": 5, \\"Charlie\\": 3 } ``` # Additional Guidelines * Your function should handle the case where `members` and `task_loads` are empty by returning an empty dictionary. * Ensure the function is efficient and handles large input sizes gracefully. * Write a few test cases to validate your implementation.","solution":"def assign_task_to_member(task: str, members: list[str], task_loads: dict[str, int]) -> dict[str, int]: Assigns a new task to the team member with the least number of current tasks. Parameters: - task: A string representing the task description. - members: A list of strings, where each string is the name of a team member. - task_loads: A dictionary where keys are member names and values are the number of tasks currently assigned to them. Returns: - A dictionary representing the updated task loads after assigning the new task. if not members or not task_loads: return {} # Find the member with the least task load min_load = min(task_loads[member] for member in members) for member in members: if task_loads[member] == min_load: task_loads[member] += 1 break return task_loads"},{"question":"# Problem Statement Suppose you are developing a system for managing a collection of books. Each book is characterized by a title, an author, and a year of publication. Your task is to implement a system that can store this information, allow retrieval of all books by an author, and return a list of all books published before a certain year. Class and Function Descriptions 1. **Book**: - A class representing a book, defined by its title, author, and year of publication. - Provide an initializer (`__init__`) method that takes the title, author, and year as parameters and sets the corresponding instance variables. 2. **Library**: - A class representing a collection of books. - Methods: - **add_book(self, book: `Book`) -> None**: - Adds a book to the library\'s collection. - Input: A `Book` instance. - **get_books_by_author(self, author: str) -> list[`Book`]**: - Retrieves a list of all books by the given author. - Input: The author\'s name (string). - Output: A list of `Book` instances by that author. - **get_books_before_year(self, year: int) -> list[`Book`]**: - Retrieves a list of all books published before the given year (inclusive). - Input: A year (integer). - Output: A list of `Book` instances published before that year. # Constraints: - The input title and author will be strings containing letters, spaces, and other printable characters. - The input year will be a positive integer. - There will be no duplicate books (i.e., books with the exact same title, author, and year). # Implementation Implement the following classes: ```python class Book: def __init__(self, title: str, author: str, year: int): # Your implementation here pass class Library: def __init__(self): # Your implementation here pass def add_book(self, book: Book) -> None: # Your implementation here pass def get_books_by_author(self, author: str) -> list[Book]: # Your implementation here pass def get_books_before_year(self, year: int) -> list[Book]: # Your implementation here pass ``` Example Usage: ```python # Creating book instances book1 = Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) book3 = Book(\\"Go Set a Watchman\\", \\"Harper Lee\\", 2015) # Creating a library instance and adding books library = Library() library.add_book(book1) library.add_book(book2) library.add_book(book3) # Retrieving books by author print([book.title for book in library.get_books_by_author(\\"Harper Lee\\")]) # Output: [\'To Kill a Mockingbird\', \'Go Set a Watchman\'] # Retrieving books before a certain year print([book.title for book in library.get_books_before_year(1960)]) # Output: [\'The Great Gatsby\'] ``` --- This example demonstrates the use of classes to manage and query a collection of book objects, using methods for filtering and retrieving data based on specific criteria.","solution":"class Book: def __init__(self, title: str, author: str, year: int): self.title = title self.author = author self.year = year class Library: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: self.books.append(book) def get_books_by_author(self, author: str) -> list: return [book for book in self.books if book.author == author] def get_books_before_year(self, year: int) -> list: return [book for book in self.books if book.year < year]"},{"question":"# String Transformation You are given a string consisting of lowercase English letters and an integer. Your task is to perform string transformations based on the given integer following these rules: 1. For each letter in the string, convert it to its corresponding position in the alphabet (a -> 1, b -> 2, ..., z -> 26). 2. For each position, add the integer to it. 3. If the result is greater than 26, wrap around using modulo 26, ensuring the positions stay within the range 1 to 26. 4. Convert the positions back to their corresponding letters in the alphabet. Write a function `transform_string(s: str, k: int) -> str` that takes in a string `s` and an integer `k`, and returns the transformed string following the specified rules. # Input: - `s` (str): a string consisting of lowercase English letters. (1 <= len(s) <= 100) - `k` (int): an integer to transform the string. (1 <= k <= 100) # Output: - (str): the transformed string after applying the given rules. # Example: ```python # Example Case 1 # Input: s = \\"abc\\", k = 2 # Output: cde # Example Case 2 # Input: s = \\"xyz\\", k = 4 # Output: bcd # Example Case 3 # Input: s = \\"hello\\", k = 26 # Output: hello ``` # Constraints: - The transformation should handle wrapping within the alphabet (e.g., z -> a). - Ensure the code efficiently handles the transformation even for the maximum input size (len(s) = 100, k = 100). # Hints: 1. Use the ASCII values of the characters to compute their positions and handle the wrapping with modulo. 2. Pay attention to the conversion between numbers and letters. Write your function implementation below: ```python def transform_string(s: str, k: int) -> str: transformed_string = [] for char in s: # Convert character to its position in the alphabet (1-26) position = ord(char) - ord(\'a\') + 1 # Add the integer k to the position new_position = (position + k - 1) % 26 + 1 # Convert the new position back to a character new_char = chr(new_position + ord(\'a\') - 1) transformed_string.append(new_char) return \'\'.join(transformed_string) # Testing the function print(transform_string(\\"abc\\", 2)) # Output: \\"cde\\" print(transform_string(\\"xyz\\", 4)) # Output: \\"bcd\\" print(transform_string(\\"hello\\", 26)) # Output: \\"hello\\" ```","solution":"def transform_string(s: str, k: int) -> str: transformed_string = [] for char in s: # Convert character to its position in the alphabet (1-26) position = ord(char) - ord(\'a\') + 1 # Add the integer k to the position new_position = (position + k - 1) % 26 + 1 # Convert the new position back to a character new_char = chr(new_position + ord(\'a\') - 1) transformed_string.append(new_char) return \'\'.join(transformed_string)"},{"question":"# Animal Kingdom Tracking System You have been hired to design an animal tracking system for a wildlife reserve. Your task is to develop a system that tracks the movement of animals, updates their locations, and queries their current status. To achieve this, you will need to implement several functions that manage the animal locations comprehensively. Problem Statement Implement a set of functions to handle the tracking of animals and their movements within a wildlife reserve: 1. **add_animal(tracker: dict, animal_id: str, initial_location: tuple[int, int]) -> None**: Adds a new animal with its initial location to the tracker. 2. **move_animal(tracker: dict, animal_id: str, new_location: tuple[int, int]) -> bool**: Updates the location of an existing animal. Returns `True` if the update was successful, or `False` if the animal does not exist in the tracker. 3. **remove_animal(tracker: dict, animal_id: str) -> bool**: Removes an animal from the tracker. Returns `True` if the animal was successfully removed, or `False` if the animal does not exist in the tracker. 4. **query_location(tracker: dict, animal_id: str) -> Union[tuple[int, int], None]**: Queries the current location of an animal. Returns the location as a tuple `(x, y)` if the animal exists, or `None` if the animal does not exist in the tracker. Input: * `tracker`: A dictionary tracking the animals, where the key is `animal_id` (a string) and the value is the location tuple `(x, y)`. * `animal_id`: A string representing the unique identifier of an animal. * `initial_location`/`new_location`: A tuple of two integers representing the coordinates `(x, y)`, where x and y can be any integers. Output: * `None`: For `add_animal` and `move_animal` indicating operations are either completed or failed. * `bool` : For `move_animal` and `remove_animal` indicating if the operation was successful. * `tuple[int, int]` or `None`: For `query_location` indicating the current location of the animal or `None` if the animal does not exist. Constraints: * Each `animal_id` in the tracker will be unique. * The wildlife reserve grid is assumed to be infinite in all directions; hence there are no boundary restrictions on the location coordinates. Example: ```python # Example 1 tracker = {} add_animal(tracker, \'lion_001\', (10, 15)) assert query_location(tracker, \'lion_001\') == (10, 15) move_animal(tracker, \'lion_001\', (21, 45)) assert query_location(tracker, \'lion_001\') == (21, 45) assert remove_animal(tracker, \'lion_001\') == True assert query_location(tracker, \'lion_001\') == None # Example 2 tracker = {} add_animal(tracker, \'elephant_002\', (30, 25)) assert query_location(tracker, \'elephant_002\') == (30, 25) assert move_animal(tracker, \'giraffe_003\', (40, 60)) == False assert remove_animal(tracker, \'giraffe_003\') == False ``` Implementation Details: 1. **add_animal(tracker: dict, animal_id: str, initial_location: tuple[int, int]) -> None**: * Adds a new animal to the tracker at the specified initial location. 2. **move_animal(tracker: dict, animal_id: str, new_location: tuple[int, int]) -> bool**: * Moves the animal to the new location if it exists in the tracker. 3. **remove_animal(tracker: dict, animal_id: str) -> bool**: * Removes the animal from the tracker if it exists. 4. **query_location(tracker: dict, animal_id: str) -> Union[tuple[int, int], None]**: * Returns the current location of the animal if it exists. Ensure to implement each function following the provided signatures and descriptions.","solution":"from typing import Union, Tuple, Dict def add_animal(tracker: Dict[str, Tuple[int, int]], animal_id: str, initial_location: Tuple[int, int]) -> None: Adds a new animal with its initial location to the tracker. tracker[animal_id] = initial_location def move_animal(tracker: Dict[str, Tuple[int, int]], animal_id: str, new_location: Tuple[int, int]) -> bool: Updates the location of an existing animal. Returns `True` if the update was successful, or `False` if the animal does not exist in the tracker. if animal_id in tracker: tracker[animal_id] = new_location return True return False def remove_animal(tracker: Dict[str, Tuple[int, int]], animal_id: str) -> bool: Removes an animal from the tracker. Returns `True` if the animal was successfully removed, or `False` if the animal does not exist in the tracker. if animal_id in tracker: del tracker[animal_id] return True return False def query_location(tracker: Dict[str, Tuple[int, int]], animal_id: str) -> Union[Tuple[int, int], None]: Queries the current location of an animal. Returns the location as a tuple `(x, y)` if the animal exists, or `None` if the animal does not exist in the tracker. return tracker.get(animal_id, None)"},{"question":"# Linked List Cycle Detection and Removal Context In real-world applications, linked lists are a fundamental data structure often used to represent sequences of data. A common issue in linked lists is the introduction of cycles, where a node points back to a previous node, causing an infinite loop in traversal. Objective Refactor the provided `detect_and_remove_cycle` function to identify if a cycle exists in a given linked list. If a cycle is detected, the function should remove the cycle and return the head of the adjusted linked list. Function Signature ```python def detect_and_remove_cycle(head: ListNode) -> ListNode: Detects and removes a cycle in a linked list, if present. Parameters: head (ListNode): The head node of the linked list. Returns: ListNode: The head node of the linked list with no cycle. Example: >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = head.next # Introducing cycle >>> new_head = detect_and_remove_cycle(head) >>> print_linked_list(new_head) 1 -> 2 -> 3 -> None ``` Constraints and Requirements * **Input Constraints**: - `head` is the head node of a singly linked list. - A linked list node is defined as: ```python class ListNode: def __init__(self, x): self.val = x self.next = None ``` * **Output**: - The function must return the head of the linked list after ensuring no cycles remain. * **Cycle Detection**: - Implement cycle detection using Floyd\'s Tortoise and Hare algorithm. * **Cycle Removal**: - If a cycle is found, adjust the `next` pointer of the node causing the cycle to remove the cycle. * **Performance**: Ensure the function operates efficiently with a time complexity of O(n) and a space complexity of O(1). Example Use Case * A linked list 1 -> 2 -> 3 -> 4 -> 3 (cycle) should be transformed to 1 -> 2 -> 3 -> 4 -> None. Solution ```python class ListNode: def __init__(self, x): self.val = x self.next = None def detect_and_remove_cycle(head: ListNode) -> ListNode: if not head or not head.next: return head slow = head fast = head # Detect cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If cycle exists if slow == fast: slow = head # If the cycle is found at the head if slow == fast: while fast.next != slow: fast = fast.next else: while slow.next != fast.next: slow = slow.next fast = fast.next # Remove the cycle fast.next = None return head def print_linked_list(head): current = head while current: print(current.val, end=\\" -> \\") current = current.next print(\\"None\\") # Example usage if __name__ == \\"__main__\\": head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = head.next # Introducing cycle new_head = detect_and_remove_cycle(head) print_linked_list(new_head) # Expected output: 1 -> 2 -> 3 -> None ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detect_and_remove_cycle(head: ListNode) -> ListNode: if not head or not head.next: return head slow = head fast = head # Detect cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If cycle exists if slow == fast: slow = head # If the cycle is found right from the head if slow == fast: while fast.next != slow: fast = fast.next else: while slow.next != fast.next: slow = slow.next fast = fast.next # Remove the cycle fast.next = None return head"},{"question":"Problem Statement You are asked to evaluate the count of unique letters in a given string and then determine the number of substrings which have all characters identical. Your task is to implement a function that takes a string `s` and returns the total count of such substrings. # Function Signature ```python def count_identical_character_substrings(s: str) -> int: ``` # Input - `s` (1 ≤ len(s) ≤ 10000): A string consisting of lowercase English letters. # Output - An integer representing the number of substrings where all characters are identical. # Constraints - The given string contains only lowercase English letters. - Substrings are contiguous sequences within the string. # Performance Requirements - The function should handle the maximum length of input efficiently. # Example ```python count_identical_character_substrings(s=\\"aaabbaa\\") # Expected output: 10, which includes \'aaa\', \'aa\', \'a\', \'bb\', \'b\', \'bb\', \'a\', \'a\' count_identical_character_substrings(s=\\"abc\\") # Expected output: 3, which includes \'a\', \'b\', \'c\' ``` Write the implementation for the function `count_identical_character_substrings` according to the above specifications.","solution":"def count_identical_character_substrings(s: str) -> int: Returns the count of all substrings where characters are all identical. count = 0 n = len(s) i = 0 while i < n: length = 1 # count length of the segment of identical characters while i + 1 < n and s[i] == s[i + 1]: length += 1 i += 1 # number of substrings from this segment count += (length * (length + 1)) // 2 i += 1 return count"},{"question":"# Scenario: You are developing a feature for automatic grading of assignments in an online learning platform. One critical component is a function that compares two strings: a student\'s answer and the correct answer. However, the comparison isn\'t straightforward, as small variations and typos should be allowed to some extent. Therefore, a comprehension algorithm like the Damerau-Levenshtein distance is needed to determine the similarity between the two strings. # Task: Write a function that computes the Damerau-Levenshtein distance between two strings. This distance measures the minimum number of operations (insertions, deletions, substitutions, or adjacent transpositions of characters) required to transform one string into the other. # Function Signature: ```python def damerau_levenshtein_distance(s1: str, s2: str) -> int: pass ``` # Input: - `s1`: A string representing the student\'s answer. - `s2`: A string representing the correct answer. # Output: - Returns an integer representing the Damerau-Levenshtein distance between the two input strings. # Constraints: - The length of the strings will not exceed 10^3 characters. - Focus on writing an efficient implementation. # Example: ```python >>> s1 = \\"example\\" >>> s2 = \\"samples\\" >>> damerau_levenshtein_distance(s1, s2) 3 >>> s1 = \\"abc\\" >>> s2 = \\"acb\\" >>> damerau_levenshtein_distance(s1, s2) 1 ``` # Notes: - You may use dynamic programming to efficiently implement the function. - Take care of edge cases, such as one or both input strings being empty.","solution":"def damerau_levenshtein_distance(s1: str, s2: str) -> int: m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): cost = 0 if s1[i - 1] == s2[j - 1] else 1 dp[i][j] = min( dp[i - 1][j] + 1, # deletion dp[i][j - 1] + 1, # insertion dp[i - 1][j - 1] + cost # substitution ) if i > 1 and j > 1 and s1[i - 1] == s2[j - 2] and s1[i - 2] == s2[j - 1]: dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + 1) # transposition return dp[m][n]"},{"question":"# Question # Image Pixel Normalization Write a Python function that normalizes the pixel values of a given grayscale image. The function should take a two-dimensional numpy array representing the image as input. The pixel values should be scaled to a range of 0 to 1. Function Signature ```python def normalize_image(image: np.ndarray) -> np.ndarray: Parameters: image (np.ndarray): A 2D numpy array representing a grayscale image with pixel values in the range [0, 255] Returns: normalized_image (np.ndarray): The input numpy array, with pixel values normalized to the range [0, 1] ``` Input * A 2D numpy array `image` of shape (m, n) containing pixel values ranging from 0 to 255. Output * A 2D numpy array of the same shape as `image`, with pixel values normalized to the range [0, 1]. Example ```python >>> normalize_image(np.array([[0, 128, 255], [64, 192, 128]])) array([[0. , 0.502, 1. ], [0.251, 0.753, 0.502]]) ``` Constraints * The function should handle edge cases such as uniform images (all pixels having the same value). * Ensure numerical stability during normalization. * Time Complexity should be linear in relation to the total number of pixels in the image. # Implementation Requirements 1. Utilize numpy operations to achieve the normalization. 2. Ensure the function is optimized for performance and can handle large images efficiently. 3. Write at least three test cases to validate the correctness of your implementation.","solution":"import numpy as np def normalize_image(image: np.ndarray) -> np.ndarray: Parameters: image (np.ndarray): A 2D numpy array representing a grayscale image with pixel values in the range [0, 255] Returns: normalized_image (np.ndarray): The input numpy array, with pixel values normalized to the range [0, 1] # Convert the image to floating point for accurate division image_float = image.astype(np.float32) # Normalize the pixel values to the range [0, 1] normalized_image = image_float / 255.0 return normalized_image"},{"question":"# Pascal\'s Triangle Row Generation Pascal\'s Triangle is a triangular array constructed by summing adjacent elements in preceding rows. Given a non-negative integer (n), your task is to generate the (n)-th row of Pascal\'s Triangle. # Problem Statement Implement a function `generate_pascal_row` that generates the (n)-th row of Pascal\'s Triangle. # Constraints 1. 0 <= (n) <= 33 # Input Format ```plaintext - An integer (n), the row index to generate (0-indexed). ``` # Output Format ```plaintext - A list of integers representing the (n)-th row of Pascal\'s Triangle. ``` # Example ```python print(generate_pascal_row(0)) # Output should be: # [1] print(generate_pascal_row(3)) # Output should be: # [1, 3, 3, 1] ``` # Implementation Complete the function `generate_pascal_row` as follows: 1. Generate the (n)-th row of Pascal\'s Triangle. 2. Return the resulting row as a list of integers. ```python def generate_pascal_row(n: int) -> list: if n == 0: return [1] row = [1] for i in range(1, n + 1): row.append(row[i - 1] * (n - i + 1) // i) return row ``` # Notes 1. Optimize the function to run efficiently for (n) up to 33. 2. Ensure correct handling of rows starting from row 0 through row 33.","solution":"def generate_pascal_row(n: int) -> list: Generate the n-th row of Pascal\'s Triangle. :param n: Index of the row to generate (0-indexed) :return: A list of integers representing the n-th row of Pascal\'s Triangle if n == 0: return [1] row = [1] for k in range(1, n + 1): row.append(row[k - 1] * (n - k + 1) // k) return row"},{"question":"# Coding Assessment Question You are required to implement a function that checks if a given string represents a valid email address based on the following criteria: - The email address must contain exactly one \\"@\\" symbol. - The local part, which precedes the \\"@\\", must be non-empty and should only contain alphanumeric characters and the following special characters: \\".\\", \\"-\\", and \\"_\\". - The domain part, which follows the \\"@\\", must be made up of at least one period-separated segment. Each segment must contain only alphanumeric characters, and the final segment (the top-level domain or TLD) must be at least 2 characters long. **Function Signature**: ```python def is_valid_email(email: str) -> bool: Validate if the given string is a valid email address. Parameters: email (str): A string representing an email address. Returns: bool: True if the email is valid according to the described rules, False otherwise. Raises: TypeError: If input is not a string. ValueError: If the input string is empty. Sample Input/Output: >>> is_valid_email(\\"example.email@domain.com\\") True >>> is_valid_email(\\"user_name@domain.com\\") True >>> is_valid_email(\\"@domain.com\\") False >>> is_valid_email(\\"example.email@domain\\") False >>> is_valid_email(\\"user name@domain.com\\") False >>> is_valid_email(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> is_valid_email(12345) Traceback (most recent call last): ... TypeError: Expected a string as input ``` **Constraints**: * The function must handle input validation: * Should raise a `TypeError` for non-string inputs. * Should raise a `ValueError` for empty strings. * The input is guaranteed not to be `None`. **Scenarios**: 1. Mainstream inputs with varying combinations of valid and invalid local and domain parts. 2. Edge cases involving empty strings, non-string inputs, and invalid characters in both parts. 3. Typical use cases, ensuring robustness and reliability in email validation.","solution":"import re def is_valid_email(email: str) -> bool: Validate if the given string is a valid email address. Parameters: email (str): A string representing an email address. Returns: bool: True if the email is valid according to the described rules, False otherwise. Raises: TypeError: If input is not a string. ValueError: If the input string is empty. if not isinstance(email, str): raise TypeError(\\"Expected a string as input\\") if email == \\"\\": raise ValueError(\\"Empty string was passed to the function\\") # Define the regex pattern for a valid email address email_regex = re.compile( r\\"^[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)+\\" ) # Check against the regex if email_regex.match(email): local_part, domain_part = email.split(\'@\') tld = domain_part.split(\'.\')[-1] return len(tld) >= 2 return False"},{"question":"# Challenge: Array Rotation Validation **Context**: You are developing a utility to validate if an array has been rotated from another array. Rotation means that the array elements are shifted to the right or left by some positions. **Problem**: Given two lists, `original` and `rotated`, implement a function `is_rotation(original: List[int], rotated: List[int]) -> bool` that determines if `rotated` is a rotation of `original`. For example, if `original` is `[1, 2, 3, 4, 5]`, and `rotated` is `[4, 5, 1, 2, 3]`, the function should return `True`. **Constraints**: 1. The length of both lists will be between `1` and `10^5`. 2. Both lists will contain only integers. 3. Both lists are of the same length. **Input**: - Two lists `original` and `rotated`, both of length `n`. **Output**: - Return `True` if `rotated` is a rotation of `original`, otherwise return `False`. **Performance Requirements**: - The function should process the input in linear time, O(n). **Example**: ```python >>> is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) True >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) False >>> is_rotation([1], [1]) True >>> is_rotation([1, 1, 1, 1], [1, 1, 1, 1]) True ```","solution":"def is_rotation(original, rotated): Check if \'rotated\' is a rotation of \'original\'. :param original: List[int], the original array :param rotated: List[int], the rotated array :return: bool, True if \'rotated\' is a rotation of \'original\', False otherwise if len(original) != len(rotated): return False if not original: return False doubled_original = original + original rotated_len = len(rotated) for i in range(len(original)): if doubled_original[i:i + rotated_len] == rotated: return True return False"},{"question":"# Scenario: An e-commerce company needs to process a vast amount of transaction data to detect fraudulent activities. They decided to use a sliding window approach to efficiently analyze subsets of transaction amounts. Given a list of transaction amounts in the order they were received, the company wants to find the minimum and maximum transaction amounts within each sliding window of a fixed size. # Task: Write a Python function that, given a list of transaction amounts and a window size, returns two lists: one containing the minimum amounts and one containing the maximum amounts for each sliding window of the specified size. # Function Signature: ```python def sliding_window_min_max(transactions: list[int], window_size: int) -> (list[int], list[int]): pass ``` # Input: - `transactions` (list of int): A list of the transaction amounts. - `window_size` (int): The size of the sliding window. # Output: - Returns a tuple of two lists: 1. List of minimum amounts for each sliding window. 2. List of maximum amounts for each sliding window. # Constraints: - 1 ≤ len(transactions) ≤ 10^6 - 1 ≤ window_size ≤ len(transactions) - Each transaction amount is a positive integer. # Performance: - Optimize the function to handle large inputs efficiently, aiming for O(n) time complexity where n is the length of the transactions list. # Example: ```python >>> sliding_window_min_max([10, 20, 15, 30, 25, 40, 35], 3) ([10, 15, 15, 25, 25], [20, 30, 30, 40, 40]) ``` # Requirements: - Implement the function using efficient data structures, such as deques, to achieve the performance goals. - Ensure proper handling of edge cases such as small transaction lists or a window size of one.","solution":"from collections import deque def sliding_window_min_max(transactions: list[int], window_size: int) -> (list[int], list[int]): Returns two lists: - The minimum amounts for each sliding window of the specified size. - The maximum amounts for each sliding window of the specified size. if not transactions or window_size <= 0 or window_size > len(transactions): return [], [] min_deque = deque() max_deque = deque() min_list = [] max_list = [] for i, current_val in enumerate(transactions): # Remove elements not in the current window from min_deque while min_deque and min_deque[0] <= i - window_size: min_deque.popleft() # Remove elements not in the current window from max_deque while max_deque and max_deque[0] <= i - window_size: max_deque.popleft() # Remove elements that are greater than the current element for min_deque while min_deque and transactions[min_deque[-1]] >= current_val: min_deque.pop() # Remove elements that are less than the current element for max_deque while max_deque and transactions[max_deque[-1]] <= current_val: max_deque.pop() # Add the current element\'s index to both deques min_deque.append(i) max_deque.append(i) # Append the current minimum and maximum to the lists if i >= window_size - 1: min_list.append(transactions[min_deque[0]]) max_list.append(transactions[max_deque[0]]) return min_list, max_list"},{"question":"# Problem Statement A new scientific breakthrough requires calculating the depth of the key roots of a plant species based on recursive growth patterns. A root grows every day based on a specific formula where each root\'s depth on day `n` is dependent on the depths from previous days. Your task is to implement a function `calculate_depth(n: int) -> int`, which recursively computes the depth of the key root on the `n`-th day. The growth pattern is defined as follows: 1. On day 1, the depth of the root is `1`. 2. On day 2, the depth of the root is `1`. 3. From day 3 onwards, the depth of the root is given by the formula: - `depth(n) = depth(n-1) + depth(n-2)` However, the current recursive approach is highly inefficient for large values of `n`. Your task is to: 1. **Optimize** the `calculate_depth` function to compute the depth efficiently for large values of `n` using memoization or iterative approaches. 2. **Handle edge cases** by ensuring the function works for all valid input values. # Function Signature ```python def calculate_depth(n: int) -> int: ``` # Constraints * ( 1 leq n leq 10^6 ) * `n` is a positive integer. # Example ```python # Example 1 print(calculate_depth(5)) # should return 3 # Example 2 print(calculate_depth(10)) # should return 34 ``` # Requirements 1. **Optimization**: Implement a solution that avoids the high computational cost of exponential recursive calls. Use techniques such as memoization or iterative dynamic programming. 2. **Edge Cases**: Ensure the function handles the smallest and largest possible values of `n` correctly. Validate input constraints and return appropriate results.","solution":"def calculate_depth(n: int) -> int: Calculates the depth of the key root on the n-th day using an iterative approach to efficiently handle large values. if n == 1 or n == 2: return 1 prev, curr = 1, 1 for _ in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Problem Context Graph traversal is a fundamental concept in computer science with various applications such as social networks, web crawling, and pathfinding in maps. Given a graph represented as an adjacency list, you may need to perform different kinds of traversal techniques to explore the graph fully. # Task Write a function `depth_first_search(graph: dict, start: any) -> list` that performs a Depth-First Search (DFS) on a given graph and returns a list of nodes in the order they are visited. # Input and Output Format * **Input**: A dictionary `graph` where keys are nodes and values are lists of adjacent nodes, and a starting node `start`. - `graph`: Dictionary representing the adjacency list of the graph. - `start`: Node from which the DFS traversal starts. * **Output**: A list of nodes in the order visited by DFS. # Example ```python >>> graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } >>> depth_first_search(graph, \'A\') [\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'] >>> depth_first_search(graph, \'C\') [\'C\', \'A\', \'B\', \'D\', \'E\', \'F\'] ``` # Constraints - The graph is a simple, undirected graph. - Each node can have 0 or more adjacent nodes. - Assume there are no cycles in the graph. - The input graph will contain at least one node. # Note 1. Use a stack data structure explicitly or implicitly via recursion to implement the DFS. 2. Handle cases where a node might have no children (i.e., it’s a leaf node). # Performance Requirement Your solution should efficiently handle graphs with up to 1000 nodes and edges.","solution":"def depth_first_search(graph: dict, start: any) -> list: Perform Depth-First Search (DFS) on the graph from the starting node. :param graph: Dictionary representing the adjacency list of the graph. :param start: Node from which the DFS traversal starts. :return: List of nodes in the order they are visited by DFS. visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) # Add adjacent nodes to the stack in reverse order to maintain order in output stack.extend(reversed(graph.get(node, []))) return visited"},{"question":"# Coding Task: Image Manipulation with Bresenham\'s Line Algorithm You are tasked with implementing the Bresenham\'s Line Algorithm, which calculates the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two given points. # Objective Implement a method inside the `ImageEditor` class that uses Bresenham\'s algorithm to draw a line on a given image (represented as a 2D matrix). # Details Input * Two points `(x1, y1)` and `(x2, y2)` representing the coordinates of the start and end points of the line respectively. * A 2D matrix `image` of size `m x n` representing the image, where each cell can be modified to draw the line. Output * The modified 2D matrix where the cells on the line have been marked. Example ```python image = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] editor = ImageEditor(image) new_image = editor.draw_line(0, 0, 3, 3) for row in new_image: print(row) # Expected Output: # [1, 0, 0, 0] # [0, 1, 0, 0] # [0, 0, 1, 0] # [0, 0, 0, 1] ``` # Constraints * Ensure the method handles both horizontal, vertical, and diagonal lines correctly. * Modify the image in-place. * Use the Bresenham’s line algorithm to determine which pixels should be marked as part of the line. * The image matrix only contains zeros and ones, where ones represent a drawn line. # Performance Requirements * Time Complexity: O(n) where n is the number of pixels along the line. * Space Complexity: O(1) for the line drawing algorithm itself. # Notes * Your solution should not use any built-in functions for line drawing. * Ensure that lines are drawn consistently and accurately. ```python class ImageEditor: def __init__(self, image): self.image = image def draw_line(self, x1, y1, x2, y2): dx = abs(x2 - x1) dy = abs(y2 - y1) sx = 1 if x1 < x2 else -1 sy = 1 if y1 < y2 else -1 err = dx - dy while True: self.image[y1][x1] = 1 if x1 == x2 and y1 == y2: break e2 = 2 * err if e2 > -dy: err -= dy x1 += sx if e2 < dx: err += dx y1 += sy return self.image # Test cases to verify correctness of the implementation def test_bresenham_line(): image = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] editor = ImageEditor(image) new_image = editor.draw_line(0, 0, 3, 3) assert new_image == [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] image = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] editor = ImageEditor(image) new_image = editor.draw_line(0, 0, 0, 3) assert new_image == [ [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0] ] test_bresenham_line() ``` # Challenge * Beyond basic functionality, ensure that your implementation can handle edge cases such as drawing steep lines, shallow lines, and lines where start and end points are the same. Good luck!","solution":"class ImageEditor: def __init__(self, image): self.image = image def draw_line(self, x1, y1, x2, y2): dx = abs(x2 - x1) dy = abs(y2 - y1) sx = 1 if x1 < x2 else -1 sy = 1 if y1 < y2 else -1 err = dx - dy while True: self.image[y1][x1] = 1 if x1 == x2 and y1 == y2: break e2 = 2 * err if e2 > -dy: err -= dy x1 += sx if e2 < dx: err += dx y1 += sy return self.image"},{"question":"# Problem Statement Given a `map` object in Python that returns key-value pairs, your task is to implement the function `invert_map` which returns a new dictionary with each key-value pair inverted, i.e., values become keys and keys become values. If multiple keys have the same value in the original dictionary, the corresponding key in the inverted dictionary should store a list of all original keys. # Requirements 1. Implement a function called `invert_map` in Python. 2. The function should take a dictionary as input and return a new dictionary with keys and values inverted. 3. If multiple keys in the input dictionary have the same value, the new dictionary should have a list of these keys. 4. Ensure the solution handles edge cases, such as empty dictionaries and dictionaries with non-unique values properly. # Function Signature ```python def invert_map(input_map: dict) -> dict: pass ``` # Input * A dictionary where keys and values are both integers (e.g., `{1: 2, 3: 4, 5: 2}`). # Output * A dictionary with inverted key-value pairs (e.g., `{2: [1, 5], 4: [3]}`). # Constraints * The input dictionary can have up to 1000 key-value pairs. * The integers for both keys and values in the dictionary range from -10^4 to 10^4. # Example ```python assert invert_map({1: 2, 3: 4, 5: 2}) == {2: [1, 5], 4: [3]} assert invert_map({}) == {} assert invert_map({-2: -4, -3: -4, 4: -10}) == {-4: [-2, -3], -10: [4]} ``` # Notes - Handling edge cases is critical. Consider scenarios like empty input dictionaries. - The order of keys in lists of the inverted dictionary does not matter but should be consistent with Python\'s behavior. - Make sure to handle dictionaries with non-unique values properly to ensure a correct and efficient inversion.","solution":"def invert_map(input_map: dict) -> dict: Invert key-value pairs in the input dictionary. If multiple keys share the same value, the new dictionary key will map to a list of those original keys. :param input_map: Dictionary with keys and values to be inverted. :return: A dictionary with inverted key-value pairs. inverted_map = {} for key, value in input_map.items(): if value not in inverted_map: inverted_map[value] = [] inverted_map[value].append(key) return inverted_map"},{"question":"# Question You have been tasked with implementing various data structure manipulation functions in Python. These functions involve operations on stacks, queues, and linked lists. Below are the detailed descriptions of the functions you need to implement. 1. **Reverse Stack**: Write a function `reverse_stack(stack: List[int]) -> List[int]` that reverses the elements of the given stack. 2. **Queue Using Two Stacks**: Write a class `QueueUsingStacks` with the following methods: - `enqueue(element: int) -> None`: Adds an element to the end of the queue. - `dequeue() -> int`: Removes the element from the front of the queue and returns it. - `is_empty() -> bool`: Checks if the queue is empty and returns a boolean. 3. **Detect Cycle in Linked List**: Write a function `detect_cycle(head: ListNode) -> bool` that detects if there is a cycle in the given singly linked list. Assume `ListNode` is defined as: ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next ``` 4. **Merge Two Sorted Linked Lists**: Write a function `merge_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode` that merges two sorted linked lists and returns the head of the new sorted list. 5. **Implement Min Stack**: Write a class `MinStack` to support the following operations: - `push(x: int) -> None`: Pushes element x onto the stack. - `pop() -> None`: Removes the element on the top of the stack. - `top() -> int`: Gets the top element. - `get_min() -> int`: Retrieves the minimum element in the stack. Ensure your functions handle edge cases, and optimize for performance where possible. Below are the constraints and expected inputs/outputs for each function: 1. **Reverse Stack**: - **Input**: `stack` (a list of integers). - **Output**: A list with the elements in the reverse order. 2. **Queue Using Two Stacks**: - **Methods**: - `enqueue(element: int) -> None`: No output. - `dequeue() -> int`: Returns the integer that was dequeued. - `is_empty() -> bool`: Returns `True` if the queue is empty, otherwise returns `False`. 3. **Detect Cycle in Linked List**: - **Input**: `head` (head of the singly linked list). - **Output**: Boolean value indicating if there is a cycle (`True`) or not (`False`). 4. **Merge Two Sorted Linked Lists**: - **Input**: `l1` and `l2` (heads of two sorted singly linked lists). - **Output**: Head of the merged sorted list. 5. **Implement Min Stack**: - **Methods**: - `push(x: int) -> None`: No output. - `pop() -> None`: No output. - `top() -> int`: Returns the top element. - `get_min() -> int`: Returns the minimum element in the stack. Provide complete implementations of these functions with proper error handling, taking care of edge cases, performance optimizations, and ensuring correct results for different input scenarios.","solution":"from typing import List, Optional # Function to reverse a stack def reverse_stack(stack: List[int]) -> List[int]: return stack[::-1] # Queue implemented using two stacks class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, element: int) -> None: self.stack1.append(element) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def is_empty(self) -> bool: return not self.stack1 and not self.stack2 # Definition for singly-linked list class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next # Function to detect cycle in a linked list def detect_cycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False # Function to merge two sorted linked lists def merge_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next # Min stack implementation class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: return self.stack[-1] if self.stack else None def get_min(self) -> int: return self.min_stack[-1] if self.min_stack else None"},{"question":"# Problem Statement: You are required to implement a function that counts the number of unique integers in a list. The list can contain both positive and negative integers. Your implementation should be efficient, with a focus on optimal time and space complexity. # Function Signature: ```python def count_unique_integers(nums: List[int]) -> int: Count the number of unique integers in the given list. Parameters: nums (List[int]): The list of integers. Returns: int: The count of unique integers. ``` # Input: - A list of integers `nums` where: - The list can have length between 1 and 10^5. - Each integer in the list will be in the range ([-10^6, 10^6]). # Output: - An integer representing the count of unique integers in the list. # Examples: ```python # Example 1 input_list = [1, 2, 2, 3, 4, 4, 4, 5] print(count_unique_integers(input_list)) # Expected Output: 5 # Example 2 input_list = [-1, -2, -3, -4, -4, -3, -2, -1, 0] print(count_unique_integers(input_list)) # Expected Output: 5 # Example 3 input_list = [1000000, -1000000, 0, 0, 1000000, -1000000] print(count_unique_integers(input_list)) # Expected Output: 3 ``` **Note**: The solution should make use of appropriate data structures to ensure efficient handling of the input list.","solution":"def count_unique_integers(nums): Count the number of unique integers in the given list. Parameters: nums (List[int]): The list of integers. Returns: int: The count of unique integers. unique_integers = set(nums) return len(unique_integers)"},{"question":"# Scenario You have been asked to develop a function for a text-based game where specific letters hold special significance. One of the requirements is to create a function that checks whether a given letter sequence contains any special letters. A special letter is defined as any uppercase vowel (A, E, I, O, U). # Task Implement a function `contains_special_letters` that takes a string as input and returns True if the string contains at least one special letter, otherwise returns False. # Function Signature ```python def contains_special_letters(text: str) -> bool: Checks if the input text contains any special letters (i.e., uppercase vowels A, E, I, O, U). :param text: A string of characters. :return: Boolean value indicating the presence of at least one special letter. pass ``` # Input - A single string `text` which may contain uppercase and lowercase letters, digits, and special characters. # Output - A boolean value: True if there is at least one special letter in the input string, False otherwise. # Constraints - The length of the string `text` will be between 1 and (10^5). # Examples Example 1: ```python text = \\"HelloWorld\\" print(contains_special_letters(text)) # Output: False ``` Example 2: ```python text = \\"AmazIngAdventUre\\" print(contains_special_letters(text)) # Output: True (Contains \'A\' and \'U\') ``` Example 3: ```python text = \\"1234!@#\\" print(contains_special_letters(text)) # Output: False ``` # Additional Requirements - Your solution should handle up to (10^5) characters efficiently. - Ensure that your implementation checks for special letters with the minimum necessary complexity to achieve the desired output.","solution":"def contains_special_letters(text: str) -> bool: Checks if the input text contains any special letters (i.e., uppercase vowels A, E, I, O, U). :param text: A string of characters. :return: Boolean value indicating the presence of at least one special letter. special_letters = {\'A\', \'E\', \'I\', \'O\', \'U\'} return any(char in special_letters for char in text)"},{"question":"# Coding Challenge: **Problem Statement:** Given a list of integers, find and return the sum of all unique elements. An element is considered unique if it appears exactly once in the list. **Function Signature:** ```python def sum_of_unique_elements(nums: List[int]) -> int: ``` **Input:** - A list of integers (nums) where (1 leq len(nums) leq 1000) and (-1000 leq nums[i] leq 1000). **Output:** - An integer representing the sum of all unique elements in the list. **Examples:** ```python >>> sum_of_unique_elements([1, 2, 3, 2, 1, 4]) 7 >>> sum_of_unique_elements([5, 5, 5, 1]) 1 >>> sum_of_unique_elements([10, 20, 30]) 60 >>> sum_of_unique_elements([1, 1, 1, 1]) 0 ``` **Explanation:** - For `[1, 2, 3, 2, 1, 4]`, the unique elements are `[3, 4]` and their sum is `7`. - For `[5, 5, 5, 1]`, the unique element is `[1]` and its sum is `1`. - For `[10, 20, 30]`, all elements are unique, so their sum is `60`. - For `[1, 1, 1, 1]`, there are no unique elements, so the sum is `0`. **Constraints:** - The list will always be non-empty. - The list contains integers within the specified range. **Solve this problem by implementing the `sum_of_unique_elements` function. Ensure the solution accurately handles the given constraints and performs within expected limits.**","solution":"from typing import List def sum_of_unique_elements(nums: List[int]) -> int: Returns the sum of all unique elements in the list. An element is considered unique if it appears exactly once in the list. from collections import Counter element_counts = Counter(nums) return sum(key for key, value in element_counts.items() if value == 1)"},{"question":"# Maze Solver with Backtracking Objective: You are required to implement a function that solves a maze using backtracking. The maze is represented as a 2D list of integers where 0s represent open paths and 1s represent walls. Your task is to find a path from the start position `(0, 0)` to the end position `(n-1, m-1)` if one exists. Input: - A 2D list `maze` consisting of 0s and 1s representing the maze layout. Output: - A list of tuples `path` representing the coordinates of the cells in the path from the start to the end, or an empty list if no path exists. Constraints: - The maze will have at least one cell (1x1 minimum). - The start and end positions `(0, 0)` and `(n-1, m-1)` will always be open paths (0s). - You can move only in four possible directions: up, down, left, and right. Example Scenarios: ```python def maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: >>> maze_solver([[0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0]]) [(0, 0), (0, 2), (1, 2), (2, 2), (2, 1), (4, 1), (4, 2), (4, 3), (4, 4)] >>> maze_solver([[0, 1], ... [1, 0]]) [] def is_safe(maze, x, y, visited): return (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited def solve_maze(maze, x, y, path, visited): if x == len(maze) - 1 and y == len(maze[0]) - 1: path.append((x, y)) return True if is_safe(maze, x, y, visited): path.append((x, y)) visited.add((x, y)) if solve_maze(maze, x + 1, y, path, visited): return True if solve_maze(maze, x, y + 1, path, visited): return True if solve_maze(maze, x - 1, y, path, visited): return True if solve_maze(maze, x, y - 1, path, visited): return True path.pop() visited.remove((x, y)) return False path = [] visited = set() if solve_maze(maze, 0, 0, path, visited): return path else: return [] ``` You should implement the `maze_solver` function precisely and ensure its correct operation using examples provided in the docstring.","solution":"from typing import List, Tuple def maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: Finds a path from the top-left corner to the bottom-right corner in a maze. Args: maze (List[List[int]]): The maze represented as a 2D list filled with 0s and 1s. Returns: List[Tuple[int, int]]: A list of tuples representing the path, or an empty list if no path exists. >>> maze_solver([[0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0]]) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] >>> maze_solver([[0, 1], ... [1, 0]]) [] def is_safe(maze, x, y, visited): return (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited def solve_maze(maze, x, y, path, visited): if x == len(maze) - 1 and y == len(maze[0]) - 1: path.append((x, y)) return True if is_safe(maze, x, y, visited): path.append((x, y)) visited.add((x, y)) # Move right if solve_maze(maze, x, y + 1, path, visited): return True # Move down if solve_maze(maze, x + 1, y, path, visited): return True # Move left if solve_maze(maze, x, y - 1, path, visited): return True # Move up if solve_maze(maze, x - 1, y, path, visited): return True path.pop() visited.remove((x, y)) return False path = [] visited = set() if solve_maze(maze, 0, 0, path, visited): return path else: return []"},{"question":"# Max-stack Data Structure You are given a class `MaxStack` that maintains a stack data structure and supports operations to push, pop, and retrieve the maximum element from the stack efficiently. Your task is to enhance this class by implementing the `get_max()` method which retrieves the current maximum value in the stack in constant time. Methods to Implement ```python class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if self.stack: if self.stack[-1] == self.max_stack[-1]: self.max_stack.pop() return self.stack.pop() return -1 # or appropriate error value def get_max(self) -> int: pass ``` # Input You do not need to modify the constructor or any existing methods except for `get_max`. You must implement the `get_max` method which does not take any inputs. # Output The method should return the current maximum value within the stack. If the stack is empty, return an appropriate error value or indication. # Example ```python stack = MaxStack() stack.push(5) stack.push(1) stack.push(5) print(stack.get_max()) # should return 5 stack.pop() print(stack.get_max()) # should return 5 stack.pop() print(stack.get_max()) # should return 5 stack.pop() print(stack.get_max()) # should return an error value or indication of empty stack ``` # Constraints * You may assume that all elements pushed into the stack are integers. * The number of operations performed on the stack will be at most `10^4`. # Note 1. Focus on the efficiency of your solution to ensure that `get_max` operates in constant time. 2. Consider edge cases such as performing operations on an empty stack.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if self.stack: popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() return popped return -1 # or appropriate error value to indicate empty stack def get_max(self) -> int: if not self.max_stack: return -1 # or appropriate error value to indicate empty stack return self.max_stack[-1]"},{"question":"# Question You are tasked with implementing a file system simulation that supports the insertion of file paths and provides functionality to query the longest common prefix for a given list of file paths. Implement the following class and function: ```python class FileSystem: def __init__(self): self.paths = set() def add_path(self, path: str) -> None: Adds a new file path to the file system. :param path: string path :return: None def longest_common_prefix(self) -> str: Finds the longest common prefix out of all stored paths. :return: string longest common prefix among all paths ``` Constraints: * The file paths are represented as strings where each path component is separated by a forward slash (`/`). * All paths are absolute (start with `/`). * The logic should be efficient and handle a significant number of paths gracefully. Input: * File paths as strings, added one by one to the file system. Output: * The longest common prefix from all stored paths as a string. Example: Given the following paths: * `\\"/home/user1/docs\\"` * `\\"/home/user2/images\\"` * `\\"/home/user1/music\\"` ```python fs = FileSystem() fs.add_path(\\"/home/user1/docs\\") fs.add_path(\\"/home/user2/images\\") fs.add_path(\\"/home/user1/music\\") print(fs.longest_common_prefix()) # Output: \'/home/\' ```","solution":"class FileSystem: def __init__(self): self.paths = [] def add_path(self, path: str) -> None: Adds a new file path to the file system. :param path: string path :return: None self.paths.append(path) def longest_common_prefix(self) -> str: Finds the longest common prefix out of all stored paths. :return: string longest common prefix among all paths if not self.paths: return \\"\\" # Split the paths into their components split_paths = [path.split(\'/\') for path in self.paths] # Zip all paths components so we can compare each level zipped_paths = list(zip(*split_paths)) common_prefix = [] for components in zipped_paths: if all(component == components[0] for component in components): common_prefix.append(components[0]) else: break # Join the common parts and return them as a path return \'/\'.join(common_prefix) + \'/\' if common_prefix else \'/\'"},{"question":"# Question Context: You are tasked with implementing functionality for managing a collection of data items and querying subsets of this data. Your solution should ensure correctness and thoroughness through rigorous unit testing. # Problem Statement Implement a class called `DataCollection` in Python that supports adding, removing, and querying data items based on a given set of criteria. # Requirements 1. **Class Definition**: ```python class DataCollection: def __init__(self): pass def add_item(self, item: dict): pass def remove_item(self, key: str): pass def query_items(self, criteria: dict) -> list: pass ``` 2. **Behavior**: - The `add_item` method should accept a dictionary representing an item and add it to the collection. - The `remove_item` method should remove an item from the collection based on a unique identifier (key). - The `query_items` method should accept a dictionary representing criteria, and return a list of items that match all the criteria. 3. **Testing Requirements**: - Use `unittest` to write a comprehensive suite of unit tests covering various scenarios. - Verify that items are correctly added, removed, and queried from the collection. - Ensure that the system correctly handles edge cases such as querying with empty criteria, removing non-existent items, and adding duplicate keys. - Write at least one test to handle the scenario of querying an empty collection. # Expected Input and Output Formats - **Input**: - `item`: A dictionary representing the data item with arbitrary key-value pairs. Must include a unique key field. - `key`: A string representing the unique identifier of the item. - `criteria`: A dictionary representing the criteria to query items by key-value pairs. - **Output**: - `add_item`: No direct output, but the item is added to the collection. - `remove_item`: No direct output, but the specified item is removed from the collection. - `query_items`: A list of dictionaries representing the items that match the criteria. # Constraints - Assume that all items have a unique key and the keys are strings. - Assume that the collection fits within available system memory. - Ensure that the collection maintains consistency and integrity across operations. # Performance Requirements - The methods should handle typical operations within reasonable time constraints, taking into consideration the number of items and the complexity of queries. # Implementation You are required to implement the `DataCollection` class with the specified methods and a comprehensive suite of unit tests following the outlined specifications.","solution":"class DataCollection: def __init__(self): self.items = {} def add_item(self, item: dict): if \'key\' in item: self.items[item[\'key\']] = item def remove_item(self, key: str): if key in self.items: del self.items[key] def query_items(self, criteria: dict) -> list: results = [] for item in self.items.values(): match = True for crit_key, crit_value in criteria.items(): if crit_key not in item or item[crit_key] != crit_value: match = False break if match: results.append(item) return results"},{"question":"# Question: Optimize Image Processing Pipeline Context: You have been assigned to upgrade an existing image processing pipeline. The current implementation processes images sequentially, creating a significant bottleneck, especially with large sets of high-resolution images. Your task is to optimize the pipeline to handle batch processing more effectively. Requirements: 1. **Batch Processing**: Modify the pipeline to handle multiple images simultaneously to improve throughput. 2. **Concurrency**: Use multiprocessing or asynchronous operations for concurrent image processing. 3. **Scalability**: Ensure that the solution can scale with the number of images and handle large image files without crashing or significant slowdowns. Main Function Specification: ```python def process_images(image_paths: List[str], output_dir: str) -> None: Given a list of image paths, process the images and save the results to the specified output directory. Parameters: image_paths (List[str]): List of paths to image files to be processed. output_dir (str): Directory where the processed images will be saved. Returns: None pass ``` * **Input**: - `image_paths`: A list of file paths to images that need to be processed. - `output_dir`: A string representing the directory where the processed images should be saved. * **Output**: None. Processed images should be saved in the output directory with the same file names. Constraints: - The pipeline should handle up to 50 images simultaneously without exceeding memory limits. - Include error handling to manage potential issues such as file not found, unsupported image formats, and insufficient write permissions in the output directory. - Ensure processed images maintain the quality standards defined in the original images. * **Example**: ```python input_images = [\\"image1.jpg\\", \\"image2.png\\"] output_directory = \\"/processed_images/\\" # After processing, the images should be found in the output_directory # with the respective tasks performed on them (e.g., resizing, filtering, etc.). process_images(input_images, output_directory) ``` Performance Requirements: - Optimize the processing such that the average time to process an image does not exceed 1 second for an image of 1920x1080 resolution on a standard machine. Note: Provide a code solution with thorough documentation and test cases to demonstrate the efficiency gains achieved through concurrency and how the pipeline handles edge cases and errors.","solution":"import os from concurrent.futures import ThreadPoolExecutor, as_completed from PIL import Image from typing import List def process_image(image_path: str, output_dir: str) -> None: Process a single image and save it to the output directory. Parameters: image_path (str): Path to the image file to be processed. output_dir (str): Directory where the processed image will be saved. Returns: None try: with Image.open(image_path) as img: # Example processing: Convert to grayscale grayscale_img = img.convert(\\"L\\") # Save processed image to output directory with the same file name output_path = os.path.join(output_dir, os.path.basename(image_path)) grayscale_img.save(output_path) except Exception as e: print(f\\"Failed to process image {image_path}: {e}\\") def process_images(image_paths: List[str], output_dir: str) -> None: Given a list of image paths, process the images and save the results to the specified output directory. Parameters: image_paths (List[str]): List of paths to image files to be processed. output_dir (str): Directory where the processed images will be saved. Returns: None if not os.path.exists(output_dir): os.makedirs(output_dir) with ThreadPoolExecutor(max_workers=50) as executor: futures = {executor.submit(process_image, image_path, output_dir): image_path for image_path in image_paths} for future in as_completed(futures): try: future.result() except Exception as e: print(f\\"Error occurred in processing: {e}\\")"},{"question":"# Scenario You have been hired as a software engineer at a company that requires you to implement an authentication system for their internal tools. Your task is to create a login function that validates user credentials against a stored set of credentials. Each user has a username and a corresponding hashed password. The password verification should use a secure hashing algorithm, and you must ensure that passwords are not stored in plain text. # Task Implement the function `login` that follows these steps: 1. Accepts a username and a password. 2. Fetches the corresponding hashed password for the given username from a predefined dictionary of users. 3. Validates the provided password against the stored hashed password using a secure hash comparison method. 4. Returns \\"Login Successful\\" if the credentials are correct, otherwise \\"Login Failed\\". # Function Signature ```python from hashlib import sha256 def login(username: str, password: str) -> str: ``` # Input - `username`: A string representing the username. - `password`: A string representing the user\'s password. # Output - Returns a string: \\"Login Successful\\" if the username exists and the password matches, otherwise \\"Login Failed\\". # Constraints - The username will always be a non-empty string. - The password will be at least 8 characters long. - The stored hashed passwords are precomputed using the SHA-256 hashing algorithm. # Example User Data The predefined dictionary of users and hashed passwords is as follows: ```python users = { \'alice\': sha256(\'password123\'.encode()).hexdigest(), \'bob\': sha256(\'mypassword\'.encode()).hexdigest(), \'charlie\': sha256(\'passw0rd\'.encode()).hexdigest() } ``` # Example ```python print(login(\'alice\', \'password123\')) # Output should be \\"Login Successful\\" print(login(\'bob\', \'wrongpassword\')) # Output should be \\"Login Failed\\" print(login(\'unknown\', \'password123\')) # Output should be \\"Login Failed\\" ``` Use the provided function signature and implement the logic within the `login` function to achieve the described functionality.","solution":"from hashlib import sha256 # Example predefined dictionary of users and their hashed passwords users = { \'alice\': sha256(\'password123\'.encode()).hexdigest(), \'bob\': sha256(\'mypassword\'.encode()).hexdigest(), \'charlie\': sha256(\'passw0rd\'.encode()).hexdigest() } def login(username: str, password: str) -> str: # Fetch the stored hashed password for the given username hashed_password = users.get(username) # If the user doesn\'t exist, return \\"Login Failed\\" if hashed_password is None: return \\"Login Failed\\" # Hash the provided password hashed_input_password = sha256(password.encode()).hexdigest() # Compare the hashed input password with the stored hashed password if hashed_input_password == hashed_password: return \\"Login Successful\\" else: return \\"Login Failed\\""},{"question":"# Problem Statement Complete the function that determines if a given string of characters can be reorganized such that no two adjacent characters are the same. If such an arrangement is possible, return one of the possible reorganizations. If it\'s not possible, return an empty string. # Function Signature ```python def reorganize_string(s: str) -> str: pass ``` # Input and Output * **Input**: * `s` (str): A string consisting of lowercase English letters. * **Output**: * A string (str) that is a reorganization of `s` such that no two adjacent characters are the same, or an empty string if such a reorganization is not possible. # Constraints * The length of the string `s` will be between 1 and 500. * If the string consists of only one character, return the same single character. # Example ```python >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"\\" >>> reorganize_string(\\"vvvlo\\") \\"vlvov\\" ``` # Performance Requirements * Your solution should run in O(n log n) time due to potential sorting involved, and use O(n) additional space to store character counts and reorganized results. # Context The problem tests your ability to handle string manipulation, frequency counting, and the ability to determine the feasibility of a required condition (no adjacent characters the same). It also evaluates your understanding of prioritizing larger quantities strategically and using greedy algorithms for valid output formation.","solution":"from heapq import heappop, heappush from collections import Counter def reorganize_string(s: str) -> str: # Count frequency of each character freq = Counter(s) # Max heap of negative frequencies (since Python has only min heap) max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) # Result list to store reorganized string result = [] while len(max_heap) > 1: # Always take two most frequent characters count1, char1 = heappop(max_heap) count2, char2 = heappop(max_heap) # Append these two characters to the result result.extend([char1, char2]) # Decrease their count and push back to the heap if they are still available if -count1 > 1: heappush(max_heap, (count1 + 1, char1)) if -count2 > 1: heappush(max_heap, (count2 + 1, char2)) # If there\'s one character left, check if it can be placed at the end of the result if max_heap: count, char = heappop(max_heap) if -count > 1: return \\"\\" # Not possible to reorganize result.append(char) return \\"\\".join(result)"},{"question":"Movie Ratings System You are tasked with developing a lightweight movie rating system where users can rate movies and get statistics based on those ratings. Implement a class, `MovieRatings`, with the following methods: 1. `rate_movie(movie_name: str, rating: float) -> None`: Allows a user to rate a movie. If the movie is already rated, it will update the rating. 2. `get_average_rating(movie_name: str) -> float`: Calculates the average rating of a movie. If the movie has not been rated, return `None`. Function Signatures ```python class MovieRatings: def rate_movie(self, movie_name: str, rating: float) -> None: pass def get_average_rating(self, movie_name: str) -> float: pass ``` Input - `movie_name` (str): The name of the movie to rate or get statistics for. - `rating` (float): The rating given to the movie, a number between 0.0 and 5.0 (inclusive). Output - `rate_movie`: No return value. - `get_average_rating`: A float representing the average rating of the movie, or `None` if the movie has not been rated. Constraints - The movie ratings should only allow numbers between 0.0 and 5.0, inclusive. If a rating outside this range is provided, ignore the rating and do not update the system. - You can assume that movie names are case-sensitive and there are no duplicates. - This system will not handle multiple ratings from different users; each movie can only have one rating at a time. Example ```python m = MovieRatings() m.rate_movie(\'The Matrix\', 4.5) m.rate_movie(\'The Matrix\', 5.0) assert m.get_average_rating(\'The Matrix\') == 5.0 # since the last rating was 5.0 assert m.get_average_rating(\'Inception\') == None # because \'Inception\' has not been rated yet m.rate_movie(\'Inception\', 4.0) assert m.get_average_rating(\'Inception\') == 4.0 # Inception now has a rating of 4.0 ```","solution":"class MovieRatings: def __init__(self): self.ratings = {} # Dictionary to store movie ratings def rate_movie(self, movie_name: str, rating: float) -> None: # Ensure rating is within valid range if 0.0 <= rating <= 5.0: self.ratings[movie_name] = rating def get_average_rating(self, movie_name: str) -> float: # Return the rating if the movie has been rated, otherwise return None return self.ratings.get(movie_name, None)"},{"question":"# Sorting and Searching Combo Challenge In this task, you will implement two classes for sorting and searching operations based on provided specifications. Each class will focus on different scenarios requiring efficient implementations of common algorithms. Part A: CustomSortedList A list that remains sorted upon each insertion or removal. Implement the following methods: 1. `__init__(self)`: Initializes an empty list. 2. `insert(self, element: int)`: Inserts an element into the list while maintaining sorted order. Raise `OverFlowError` if the list exceeds 200 elements. 3. `remove(self, element: int)`: Removes the specified element from the list. Raise `ValueError` if the element is not found. 4. `__str__(self) -> str`: Returns a string representation of the list. Part B: CustomSearchableList A list that provides efficient search operations. Implement the following methods: 1. `__init__(self, elements: list)`: Initializes the list with given elements and sorts them. 2. `binary_search(self, target: int) -> int`: Performs a binary search for the target element and returns its index. Returns -1 if not found. 3. `contains(self, target: int) -> bool`: Returns whether the target element is in the list (should use `binary_search` internally). 4. `__str__(self) -> str`: Returns a string representation of the list. # Input and Output * `insert(element)` accepts a single integer element to insert. * `remove(element)` accepts a single integer element to remove. * `binary_search(target)` returns the index of the target element or -1 if not found. * `contains(target)` returns a boolean indicating the presence of the target element. * Instances of the classes should handle standard exceptions for overflow and element not found conditions. # Performance Requirements Ensure that your implementation meets the specified time complexities: * `insert`: O(n) for maintaining sorted order. * `remove`: O(n) for locating and removing the element. * `binary_search` and `contains`: O(log n) due to the sorted nature of the list. * String representation should be efficient. # Example ```python # Part A: CustomSortedList csl = CustomSortedList() csl.insert(10) csl.insert(2) csl.insert(5) print(csl) # [2, 5, 10] csl.remove(5) print(csl) # [2, 10] # Part B: CustomSearchableList csl = CustomSearchableList([30, 10, 20, 50]) print(csl) # [10, 20, 30, 50] print(csl.binary_search(20)) # 1 print(csl.contains(25)) # False print(csl.contains(50)) # True ``` Implement the classes `CustomSortedList` and `CustomSearchableList` with the specified methods and ensure your code passes the above examples.","solution":"class CustomSortedList: def __init__(self): self._list = [] def insert(self, element: int): if len(self._list) >= 200: raise OverflowError(\\"List exceeds maximum allowed size of 200 elements.\\") self._list.append(element) self._list.sort() # maintaining sorted order def remove(self, element: int): if element not in self._list: raise ValueError(f\\"Element {element} not found in the list.\\") self._list.remove(element) def __str__(self) -> str: return str(self._list) class CustomSearchableList: def __init__(self, elements: list): self._list = sorted(elements) def binary_search(self, target: int) -> int: left, right = 0, len(self._list) - 1 while left <= right: mid = left + (right - left) // 2 if self._list[mid] == target: return mid elif self._list[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def contains(self, target: int) -> bool: return self.binary_search(target) != -1 def __str__(self) -> str: return str(self._list)"},{"question":"# Scenario Our company needs to analyze various large datasets efficiently. One common task is converting a dataset of temperatures from Fahrenheit to Celsius to track climate trends. You\'re assigned to implement a function to perform this conversion for a list of temperature readings and return the results in Celsius, rounded to two decimal places. # Task Description Implement a function `convert_to_celsius` that takes a list of integers or floating-point numbers representing temperatures in Fahrenheit and returns a list of these temperatures converted to Celsius. # Function Signature ```python def convert_to_celsius(fahrenheit_temps: List[Union[int, float]]) -> List[float]: pass ``` # Input * A list `fahrenheit_temps` where each element is an integer or float representing a temperature in Fahrenheit. # Output * A list of floats where each element is the corresponding temperature in Celsius, rounded to two decimal places. # Constraints * The input list will contain at least 1 and at most 10^4 elements. * Temperatures in the input list will be between -459.67 (absolute zero in Fahrenheit) and 1,000,000 Fahrenheit. # Example Example 1 ```python fahrenheit_temps = [32, 212, 0, -40, 100] print(convert_to_celsius(fahrenheit_temps)) # Output: [0.00, 100.00, -17.78, -40.00, 37.78] ``` Example 2 ```python fahrenheit_temps = [451, -459.67, 77, 68, 104] print(convert_to_celsius(fahrenheit_temps)) # Output: [232.78, -273.15, 25.00, 20.00, 40.00] ``` # Notes * The formula to convert temperatures from Fahrenheit to Celsius is: [ C = frac{5}{9} times (F - 32) ] * Ensure to round the converted temperatures to two decimal places. * Use only the Python standard library.","solution":"from typing import List, Union def convert_to_celsius(fahrenheit_temps: List[Union[int, float]]) -> List[float]: Converts a list of temperatures from Fahrenheit to Celsius and returns the list of temperatures in Celsius. Each temperature is rounded to two decimal places. Parameters: fahrenheit_temps (List[Union[int, float]]): List of temperatures in Fahrenheit. Returns: List[float]: List of temperatures in Celsius, rounded to two decimal places. celsius_temps = [(5/9) * (temp - 32) for temp in fahrenheit_temps] return [round(c, 2) for c in celsius_temps]"},{"question":"# Question: Implement Counting Sort with a Twist **Context:** Counting Sort is a non-comparison-based sorting algorithm that sorts integers in O(n + k) time, where `n` is the number of elements in the input array and `k` is the range of the input. **Objective:** Your task is to implement the Counting Sort algorithm to sort an array of integers and enhance it to return not only the sorted array but also the number of occurrences of the most frequent element. **Function Signature:** ```python def counting_sort_with_frequency(array: list) -> tuple: Sorts the array using Counting Sort algorithm and returns a tuple with sorted array and the frequency of the most frequent element. Args: array (list): A list of integers to be sorted. Returns: tuple: A tuple containing the sorted array and an integer representing the frequency of the most frequent element. pass ``` **Requirements:** * Implement Counting Sort to sort the array. * Track and return the frequency of the most frequent element in the array. * Ensure the implementation efficiently handles a range of integer values, including negative numbers. **Input:** - A list of integers. The input list can be of any length, including zero. **Output:** - A tuple with the first element being the sorted list and the second element an integer representing the frequency of the most frequent element. **Constraints:** - The input list can contain integers in any order, including sorted, reverse sorted, or completely arbitrary. - Ensure the algorithm handles negative integers and the appropriate range for Counting Sort. **Examples:** ```python >>> counting_sort_with_frequency([4, 2, 2, 8, 3, 3, 1]) ([1, 2, 2, 3, 3, 4, 8], 2) >>> counting_sort_with_frequency([10, -10, 5, 0, -5, 3, 3, 10]) ([-10, -5, 0, 3, 3, 5, 10, 10], 2) >>> counting_sort_with_frequency([-1, -1, -1, -1]) ([-1, -1, -1, -1], 4) >>> counting_sort_with_frequency([5]) ([5], 1) >>> counting_sort_with_frequency([]) ([], 0) ``` **Edge Cases to Consider:** - Empty array `[]` - Arrays with duplicate elements, e.g., `[3, 3, 1, 1]` - Arrays with all identical elements, e.g., `[1, 1, 1, 1]` - Arrays containing negative and positive integers mixed together","solution":"def counting_sort_with_frequency(array: list) -> tuple: Sorts the array using Counting Sort algorithm and returns a tuple with sorted array and the frequency of the most frequent element. Args: array (list): A list of integers to be sorted. Returns: tuple: A tuple containing the sorted array and an integer representing the frequency of the most frequent element. if not array: return ([], 0) min_val = min(array) max_val = max(array) range_of_elements = max_val - min_val + 1 # Initialize count array count = [0] * range_of_elements output = [0] * len(array) # Store the count of each element for num in array: count[num - min_val] += 1 # Find the max frequency value max_frequency = max(count) # Modify count array to have position of elements for i in range(1, len(count)): count[i] += count[i - 1] # Create the output sorted array for num in reversed(array): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return (output, max_frequency)"},{"question":"# Longest Consecutive Sequence in an Array You are provided with an unsorted array of integers. Your task is to implement a method `longest_consecutive_sequence` that returns the length of the longest consecutive elements sequence. # Implement the following method: ```python def longest_consecutive_sequence(nums: List[int]) -> int: pass ``` # Function Specification * **Input**: * `nums` (List[int]): An array of integers. * **Output**: * Return the length (int) of the longest consecutive elements sequence in the given array. # Constraints * The array can contain up to 10^6 integers. * Integers are within the range of -10^9 to 10^9. Example ```python print(longest_consecutive_sequence([100, 4, 200, 1, 3, 2])) # Output: 4 print(longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1])) # Output: 9 print(longest_consecutive_sequence([])) # Output: 0 ``` # Explanation 1. In the first example, the longest consecutive sequence is [1, 2, 3, 4], which has a length of 4. 2. In the second example, the longest consecutive sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8], which has a length of 9. 3. In the third example, the input array is empty, so the longest consecutive sequence length is 0. This problem will test your understanding of hashing and your ability to solve array problems efficiently with an optimal approach.","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem: Generating Permutations of a List You need to implement a function to generate all possible permutations of a given list of integers. In mathematics, a permutation of a set is an arrangement of its members into a sequence or linear order. # Constraints and Requirements 1. **Input**: A list of distinct integers. 2. **Output**: A list of lists, where each inner list is a permutation of the input list. # Specifications 1. The input list will contain between 1 and 10 elements. 2. The input list can contain both positive and negative integers. 3. The output list should not contain duplicate permutations. # Function Signature ```python def generate_permutations(lst: list[int]) -> list[list[int]]: pass ``` # Example Usage ```python # Example 1 lst = [1, 2, 3] assert generate_permutations(lst) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] # Example 2 lst = [0, -1, 1] assert generate_permutations(lst) == [ [0, -1, 1], [0, 1, -1], [-1, 0, 1], [-1, 1, 0], [1, 0, -1], [1, -1, 0] ] # Example 3 lst = [5] assert generate_permutations(lst) == [ [5] ] ``` # Additional Considerations 1. Your function should use a helper function to recursively build each permutation. 2. The function should handle edge cases, like an empty list or a list with only one element, properly. 3. Avoid using built-in libraries for permutations for a better understanding of the algorithm.","solution":"def generate_permutations(lst): Generates all possible permutations of a given list of integers. Parameters: lst (list): A list of distinct integers. Returns: list: A list of lists where each inner list is a permutation of the input list. def backtrack(start, end): if start == end: # appending the copy of the list lst result.append(lst[:]) for i in range(start, end): # swap numbers lst[start], lst[i] = lst[i], lst[start] # generate permutations for the next numbers backtrack(start + 1, end) # backtrack (swap them back) lst[start], lst[i] = lst[i], lst[start] result = [] backtrack(0, len(lst)) return result"},{"question":"# Battery Charging Time Calculation You are tasked with writing a function to calculate the time required to fully charge a battery given a constant current and voltage. The battery\'s charge follows a linear growth pattern when charged with constant current. # Function Specification Implement the following function in Python: ```python def charging_time( battery_capacity: float, charge_current: float, charge_voltage: float, initial_charge: float ) -> float: Calculate the time required to fully charge a battery given a constant current and voltage. Parameters: - battery_capacity (float): Battery capacity in ampere-hours, must be positive. - charge_current (float): Charging current in amperes, must be positive. - charge_voltage (float): Charging voltage in volts, must be positive. - initial_charge (float): Initial charge in ampere-hours, must be positive and less than battery_capacity. Returns: - float: Time required to fully charge the battery in hours, rounded to three decimal places. Raises: - ValueError: If any of the parameters are non-positive or if initial_charge is greater than battery_capacity. Example Usage: >>> charging_time(50.0, 10.0, 12.0, 20.0) 3.0 >>> charging_time(100.0, 20.0, 24.0, 50.0) 2.5 >>> charging_time(60.0, 5.0, 14.0, 30.0) 6.0 ``` # Input and Output - **Input**: - `battery_capacity` (float): The total capacity of the battery in ampere-hours. Must be a positive value. - `charge_current` (float): The current used for charging in amperes. Must be a positive value. - `charge_voltage` (float): The voltage applied during charging in volts. Must be a positive value. - `initial_charge` (float): The initial charge of the battery in ampere-hours. Must be a positive value and less than the battery_capacity. - **Output**: The function should return the time required to fully charge the battery in hours as a float, rounded to three decimal places. # Constraints - All input values (battery_capacity, charge_current, charge_voltage, initial_charge) will be non-negative floating-point numbers. - The function must handle input validation and raise appropriate errors for non-positive values or if initial_charge is greater than battery_capacity. # Example: ```python >>> charging_time(50.0, 10.0, 12.0, 20.0) 3.0 >>> charging_time(100.0, 20.0, 24.0, 50.0) 2.5 >>> charging_time(60.0, 5.0, 14.0, 30.0) 6.0 >>> charging_time(-50.0, 10.0, 12.0, 20.0) Traceback (most recent call last): ... ValueError: Battery capacity must be positive. >>> charging_time(50.0, 10.0, 12.0, -20.0) Traceback (most recent call last): ... ValueError: Initial charge must be positive and less than battery capacity. ``` Implement the function according to the specification above and ensure it passes the provided test cases.","solution":"def charging_time( battery_capacity: float, charge_current: float, charge_voltage: float, initial_charge: float ) -> float: Calculate the time required to fully charge a battery given a constant current and voltage. Parameters: - battery_capacity (float): Battery capacity in ampere-hours, must be positive. - charge_current (float): Charging current in amperes, must be positive. - charge_voltage (float): Charging voltage in volts, must be positive. - initial_charge (float): Initial charge in ampere-hours, must be positive and less than battery_capacity. Returns: - float: Time required to fully charge the battery in hours, rounded to three decimal places. Raises: - ValueError: If any of the parameters are non-positive or if initial_charge is greater than battery_capacity. if battery_capacity <= 0: raise ValueError(\\"Battery capacity must be positive.\\") if charge_current <= 0: raise ValueError(\\"Charge current must be positive.\\") if charge_voltage <= 0: raise ValueError(\\"Charge voltage must be positive.\\") if initial_charge < 0: raise ValueError(\\"Initial charge must be positive.\\") if initial_charge >= battery_capacity: raise ValueError(\\"Initial charge must be less than battery capacity.\\") # Determine the amount of charge needed needed_charge = battery_capacity - initial_charge # Calculate the time required charge_time = needed_charge / charge_current return round(charge_time, 3)"},{"question":"# Coding Assessment Question: Implement Dijkstra\'s Algorithm with Priority Queue Context You are tasked with implementing Dijkstra\'s algorithm, a well-known shortest-path algorithm for graphs, using a priority queue (min-heap). This algorithm is crucial for finding the shortest path in a weighted graph with non-negative weights. You will complete a `Graph` class that must handle the insertion of edges and computation of shortest paths from a given source node. Task 1. **Graph Representation**: Implement methods to represent the graph using an adjacency list. 2. **Edge Insertion**: Implement a method to insert directed, weighted edges into the graph. 3. **Dijkstra\'s Algorithm**: Implement a method to find the shortest path from the given source node to a target node using a priority queue. Implementation ```python from heapq import heappush, heappop from collections import defaultdict import sys class Graph: def __init__(self): self.nodes = set() self.adj_list = defaultdict(list) def add_edge(self, from_node, to_node, weight): self.nodes.update([from_node, to_node]) self.adj_list[from_node].append((to_node, weight)) def dijkstra(self, start, end): heap = [(0, start)] distances = {node: sys.maxsize for node in self.nodes} distances[start] = 0 visited = set() while heap: current_distance, current_node = heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == end: return current_distance for neighbor, weight in self.adj_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) return sys.maxsize # Example usage: # g = Graph() # g.add_edge(\'A\', \'B\', 1) # g.add_edge(\'B\', \'C\', 2) # g.add_edge(\'A\', \'C\', 4) # print(g.dijkstra(\'A\', \'C\')) # Output should be 3 ``` Input Format - Method `add_edge` takes three parameters: `from_node` (str), `to_node` (str), and `weight` (int). - Method `dijkstra` takes two parameters: `start` (str) and `end` (str). Output Format - Method `dijkstra` returns an integer representing the shortest distance from the start node to the end node, or `sys.maxsize` if no path exists. Constraints - All edge weights are non-negative integers. - The graph does not contain cycles with negative weights. - Node identifiers are strings. Complete the implementation of the `Graph` class to perform the insertion of edges and computation of shortest path using Dijkstra\'s algorithm.","solution":"from heapq import heappush, heappop from collections import defaultdict import sys class Graph: def __init__(self): self.nodes = set() self.adj_list = defaultdict(list) def add_edge(self, from_node, to_node, weight): self.nodes.update([from_node, to_node]) self.adj_list[from_node].append((to_node, weight)) def dijkstra(self, start, end): heap = [(0, start)] distances = {node: sys.maxsize for node in self.nodes} distances[start] = 0 visited = set() while heap: current_distance, current_node = heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == end: return current_distance for neighbor, weight in self.adj_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) return sys.maxsize"},{"question":"# Cargo Ship Loading Optimization You are in charge of loading cargo onto a ship, and your objective is to maximize the total value of cargo while respecting the weight capacity of the ship. Each cargo item has a specific weight and value. The ship can carry a weight up to its capacity. Function Definition Write a function `max_cargo_value(items: list, capacity: int) -> float` that takes a list of cargo items and the weight capacity of the ship, and returns the maximum value achievable by optimally selecting cargo items, considering fractions of items if necessary. Input * `items` (List[Tuple[int, int]]): A list of tuples where each tuple represents a cargo item consisting of: - `weight` (int): The weight of the cargo item. - `value` (int): The value of the cargo item. * `capacity` (int): The weight capacity of the ship. Output * A float representing the maximum value achievable by optimally selecting and potentially fractioning cargo items. Constraints * Weight and value are positive integers. * The number of cargo items, n, will be in the range of [1, 1000]. * The weight of any item will not exceed 1000. * The ship\'s capacity will be in the range of [1, 10000]. Examples ```python assert max_cargo_value([(10, 60), (20, 100), (30, 120)], 50) == 240.0 assert max_cargo_value([(10, 40), (20, 100), (30, 120), (40, 200)], 60) == 300.0 ``` Explanation 1. In the first example, taking the item with weight 10 and value 60, the item with weight 20 and value 100, and a fraction (2/3) of the item with weight 30 and value 120 results in a maximum value of 240.0 for the total weight of 50. 2. In the second example, taking the item with weight 20 and value 100, and the item with weight 40 and value 200 results in a maximum value of 300.0 for a total weight of 60. Performance Requirements The solution must handle large inputs efficiently, by sorting items based on a value-to-weight ratio and making optimal decisions regarding full or fractional inclusion of items.","solution":"def max_cargo_value(items, capacity): # Calculate value per unit weight for each item items = sorted(items, key=lambda x: x[1] / x[0], reverse=True) max_value = 0.0 current_weight = 0 for weight, value in items: if current_weight + weight <= capacity: current_weight += weight max_value += value else: remaining_capacity = capacity - current_weight fraction = remaining_capacity / weight max_value += value * fraction break return max_value"},{"question":"# Context: You are working on a system to manage a library\'s inventory. Each book in the library is represented with a unique ID, a title, and an author\'s name. The library frequently performs two key operations: 1. Adding a new book to the inventory. 2. Searching for books by a specific author, sorted alphabetically by title. To manage these operations efficiently, you have decided to use a combination of a dictionary and a sorted data structure. # Task: Your task is to complete the given `LibraryInventory` class with the necessary functions `add_book` and `search_by_author` from the template provided. Below is the initial outline of the class: ```python class LibraryInventory: def __init__(self): # Implementation details self.inventory = {} # Dictionary to hold the books based on authors def add_book(self, book_id: int, title: str, author: str) -> None: # To be implemented by students def search_by_author(self, author: str) -> list: # To be implemented by students ``` # Requirements: - Implement the `add_book` method to add a book to the inventory with the given `book_id`, `title`, and `author`. Ensure that books by the same author are stored together and can be efficiently retrieved. - Implement the `search_by_author` method to return a list of book titles by the specified author, sorted alphabetically. # Constraints: - Each `book_id` is unique and is a positive integer. - The `title` and `author` are non-empty strings containing only alphabetical characters and spaces. - The library can contain up to 10^5 books. - Additions and searches should be optimized for performance given the size constraints. # Examples: ```python library = LibraryInventory() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(3, \\"1984\\", \\"George Orwell\\") library.add_book(4, \\"Animal Farm\\", \\"George Orwell\\") print(library.search_by_author(\\"George Orwell\\")) # Should output [\'1984\', \'Animal Farm\'] print(library.search_by_author(\\"F. Scott Fitzgerald\\")) # Should output [\'The Great Gatsby\'] library.add_book(5, \\"Brave New World\\", \\"Aldous Huxley\\") print(library.search_by_author(\\"Aldous Huxley\\")) # Should output [\'Brave New World\'] ``` # Notes: For the `add_book` method, you may consider using a dictionary where the key is the author\'s name and the value is a list of tuples representing books (title and book_id). To keep the titles sorted, you can use an appropriate data structure from a module like `sortedcontainers` or achieve sorted insertion manually.","solution":"from collections import defaultdict from bisect import insort class LibraryInventory: def __init__(self): self.inventory = defaultdict(list) def add_book(self, book_id: int, title: str, author: str) -> None: # Insert the book maintaining the sorted order of titles for the same author insort(self.inventory[author], (title, book_id)) def search_by_author(self, author: str) -> list: # Extract only the titles and return them sorted return [title for title, book_id in self.inventory.get(author, [])]"},{"question":"# Question: Implement a Merge Sort Variant: Comb Sort Context You are a software developer and have been asked to optimize the sorting algorithm of a legacy application dealing with large datasets. Given an array of integers, you decide to implement and test a more efficient sorting algorithm, Comb Sort, which is an improvement over Bubble Sort. Task Write a function `comb_sort(arr: List[int]) -> List[int]` that sorts an array of integers in ascending order using the Comb Sort algorithm. Comb Sort Algorithm 1. Calculate the initial gap size as the length of the array. 2. Reduce the gap size by the shrink factor (commonly 1.3) repeatedly until the gap is greater than 1. 3. Compare elements that are `gap` positions apart, and swap if necessary. 4. Continue this process until the array is sorted and the gap is finally reduced to 1 and no swaps are needed. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers to be sorted. Output - Return the sorted list of integers in ascending order. Constraints - The array can have up to `10000` integers. - Each integer in the array is within the range `-1000000` to `1000000`. - The array can include duplicate values. Example ```python arr = [34, 8, 64, 51, 32, 21] print(comb_sort(arr)) # Output: [8, 21, 32, 34, 51, 64] arr = [5, -3, 0, -10, 100, 45, 23, 65, 2] print(comb_sort(arr)) # Output: [-10, -3, 0, 2, 5, 23, 45, 65, 100] ``` Note While the Comb Sort algorithm improves on Bubble Sort by eliminating turtles, or small values near the end of the list, its biggest advantage comes from applying the gap reduction early on, improving performance on average. Be sure to take advantage of the shrinking gap and only swap elements when necessary.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sort an array of integers in ascending order using the Comb Sort algorithm. if not arr: return arr n = len(arr) gap = n shrink = 1.3 sorted = False while gap > 1 or not sorted: gap = int(gap / shrink) if gap < 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Question: Implementation of a Custom Sort Function **Context**: Sorting algorithms are fundamental in computer science, frequently used to organize and order data. Different scenarios may require specific sorting criteria beyond the usual ascending or descending order. Implementing a custom sort function allows you to specify unique conditions based on the requirements. **Task**: Create a custom sort function that sorts a list of dictionaries based on a specified key. Additionally, the function should allow sorting in both ascending and descending order and handle edge cases such as missing keys gracefully. **Function Signature**: ```python def custom_sort(data: list, sort_key: str, ascending: bool = True) -> list: Sort a list of dictionaries based on a specified key. Args: - data (list): A list of dictionaries to be sorted. - sort_key (str): The key within the dictionaries to sort by. - ascending (bool, optional): Whether to sort in ascending order (default: True). Returns: - list: The sorted list of dictionaries. # Example: # >>> data = [{\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Bob\', \'age\': 25}, {\'name\': \'Charlie\', \'age\': 35}] # >>> custom_sort(data, \'age\') # [{\'name\': \'Bob\', \'age\': 25}, {\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Charlie\', \'age\': 35}] # >>> custom_sort(data, \'age\', ascending=False) # [{\'name\': \'Charlie\', \'age\': 35}, {\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Bob\', \'age\': 25}] ``` **Requirements**: 1. The `custom_sort` function should sort a list of dictionaries based on a given key. 2. It should allow sorting in both ascending (default) and descending order. 3. If a dictionary in the list does not contain the specified key, it should handle it gracefully by placing the dictionary at the end of the sorted list. 4. Performance should be considered, ensuring the function can handle large datasets efficiently. **Hint**: * You may find the `sorted` function or the `sort` method in Python helpful. * Consider using the `key` parameter in sorting functions to specify custom sorting logic. **Input/Output**: * **Input**: A list of dictionaries `data`, a string `sort_key`, and an optional boolean `ascending`. * **Output**: A list of dictionaries sorted based on the specified key. ```python def custom_sort(data: list, sort_key: str, ascending: bool = True) -> list: return sorted(data, key=lambda x: x.get(sort_key, float(\'inf\')), reverse=not ascending) ```","solution":"def custom_sort(data: list, sort_key: str, ascending: bool = True) -> list: Sort a list of dictionaries based on a specified key. Args: - data (list): A list of dictionaries to be sorted. - sort_key (str): The key within the dictionaries to sort by. - ascending (bool, optional): Whether to sort in ascending order (default: True). Returns: - list: The sorted list of dictionaries. return sorted(data, key=lambda x: x.get(sort_key, float(\'inf\') if ascending else float(\'-inf\')), reverse=not ascending)"},{"question":"# Intersection of Two Linked Lists Context You are tasked with finding the intersection point of two singly linked lists in a data merging system. Given two singly linked lists, determine the node at which the two lists intersect. The intersecting node is defined as the first common node (by reference, not by value) that appears in both lists. Task Implement a function `get_intersection_node(headA: ListNode, headB: ListNode) -> Optional[ListNode]` that returns the node at which the intersection of two singly linked lists begins. If no intersection exists, return `None`. Function Signature ```python from typing import Optional class ListNode: def __init__(self, x: int): self.val = x self.next: Optional[ListNode] = None def get_intersection_node(headA: Optional[ListNode], headB: Optional[ListNode]) -> Optional[ListNode]: # Your code here ``` Additional Requirements * You should minimize the distance for pointer movement and avoid unnecessary traversals. Input/Output Format * **Input**: - `headA`: The head node of the first linked list (`ListNode` or `None` if the list is empty). - `headB`: The head node of the second linked list (`ListNode` or `None` if the list is empty). * **Output**: - The intersecting node if there is an intersection; otherwise, `None`. Constraints * The number of nodes in both linked lists combined is in the range `[0, 2000]`. * You must not modify the linked lists. * The values of the nodes are not necessarily unique. Examples ```python # Example 1: # Create intersecting linked lists # List A: 4 -> 1 -> 8 -> 4 -> 5 # List B: 5 -> 6 -> 1 -> 8 -> 4 -> 5 # The intersection starts at node with value 8 node_intersect = ListNode(8) node_intersect.next = ListNode(4) node_intersect.next.next = ListNode(5) headA = ListNode(4) headA.next = ListNode(1) headA.next.next = node_intersect headB = ListNode(5) headB.next = ListNode(6) headB.next.next = ListNode(1) headB.next.next.next = node_intersect result = get_intersection_node(headA, headB) print(result.val if result else None) # Output: 8 # Example 2: # List A: 1 -> 9 -> 1 -> 2 -> 4 # List B: 3 # No intersection headA = ListNode(1) headA.next = ListNode(9) headA.next.next = ListNode(1) headA.next.next.next = ListNode(2) headA.next.next.next.next = ListNode(4) headB = ListNode(3) result = get_intersection_node(headA, headB) print(result.val if result else None) # Output: None ``` Use the following helper function for testing your function: ```python def print_linked_list(head: Optional[ListNode]) -> None: current = head while current: print(current.val, end=\\" -> \\") current = current.next print(\\"None\\") # Example Test if __name__ == \\"__main__\\": # Example 1 node_intersect = ListNode(8) node_intersect.next = ListNode(4) node_intersect.next.next = ListNode(5) headA = ListNode(4) headA.next = ListNode(1) headA.next.next = node_intersect headB = ListNode(5) headB.next = ListNode(6) headB.next.next = ListNode(1) headB.next.next.next = node_intersect print_linked_list(headA) print_linked_list(headB) result = get_intersection_node(headA, headB) print(result.val if result else None) # Output: 8 # Example 2 headA = ListNode(1) headA.next = ListNode(9) headA.next.next = ListNode(1) headA.next.next.next = ListNode(2) headA.next.next.next.next = ListNode(4) headB = ListNode(3) print_linked_list(headA) print_linked_list(headB) result = get_intersection_node(headA, headB) print(result.val if result else None) # Output: None ``` Note You must not modify the original linked lists.","solution":"from typing import Optional class ListNode: def __init__(self, x: int): self.val = x self.next: Optional[ListNode] = None def get_intersection_node(headA: Optional[ListNode], headB: Optional[ListNode]) -> Optional[ListNode]: if not headA or not headB: return None p1, p2 = headA, headB while p1 != p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1"},{"question":"# Coding Assessment Question **Objective**: Test students\' ability to manipulate basic data structures and implement sorting algorithms. **Background**: Sorting algorithms are essential in computer science for organizing data. One common task involves sorting a list of tuples based on multiple elements. The code snippet provided defines an algorithm to sort tuples based on the first element, and your challenge is to extend this functionality to sort based on multiple elements. **Task**: 1. **Function Implementation**: Implement a function called `multi_key_sort` that: - Accepts a list of tuples and a list of sorting keys. - Returns the list of tuples sorted based on the provided keys. 2. **Sort Keys**: - The function should support sorting by multiple tuple elements in the order provided by the keys. - Handle both ascending and descending order, specified within the keys list. 3. **Edge Cases**: Consider edge cases such as: - Empty list of tuples. - Single tuple in the list. - All tuples having the same elements to be sorted. **Input/Output**: - Input: `multi_key_sort(data: List[Tuple], keys: List[Union[int, Tuple[int, bool]]]) -> List[Tuple]` - `data`: A list of tuples to be sorted. - `keys`: A list of sorting keys where each key is an integer representing the tuple index or a tuple with the index and a boolean for ascending/descending order. - Output: Returns the sorted list of tuples. **Constraints**: - 0 ≤ len(data) ≤ 10^4 - Each tuple contains up to 5 integer elements. - Keys are valid indices for the tuple elements. **Performance Requirements**: - Your solution should efficiently handle sorting based on multiple keys. # Example ```python def multi_key_sort(data: List[Tuple], keys: List[Union[int, Tuple[int, bool]]]) -> List[Tuple]: pass # Example Usage: data = [(1, 2, 3), (4, 1, 6), (2, 3, 2), (4, 2, 1)] # Sort by the second element in ascending order assert multi_key_sort(data, [1]) == [(4, 1, 6), (1, 2, 3), (4, 2, 1), (2, 3, 2)] # Sort by the third element in descending order, then by the first element in ascending order assert multi_key_sort(data, [(2, False), (0, True)]) == [(4, 1, 6), (1, 2, 3), (2, 3, 2), (4, 2, 1)] # Handle empty data assert multi_key_sort([], [0]) == [] # Handle single element data assert multi_key_sort([(5, 4, 3)], [1]) == [(5, 4, 3)] ``` Provide a well-commented and efficient solution to this problem.","solution":"from typing import List, Tuple, Union def multi_key_sort(data: List[Tuple], keys: List[Union[int, Tuple[int, bool]]]) -> List[Tuple]: Sorts a list of tuples based on multiple keys. :param data: A list of tuples to be sorted. :param keys: A list of sorting keys where each key is an integer representing the tuple index or a tuple with the index and a boolean for ascending/descending order. :return: The sorted list of tuples. for key in reversed(keys): if isinstance(key, int): data.sort(key=lambda x: x[key]) else: index, ascending = key data.sort(key=lambda x: x[index], reverse=not ascending) return data"},{"question":"# Problem Statement In a coordinate system, a point is defined by its (x) and (y) values. Given a list of points and the target point, calculate the Euclidean distance from each point to the target point and return a sorted list of points based on their distances from the target point. Write a function `sort_points_by_distance(points: List[Tuple[int, int]], target: Tuple[int, int]) -> List[Tuple[int, int]]` that takes as input a list of points (each point represented as a tuple of its (x) and (y) coordinates) and a target point, then returns a list of points sorted by their Euclidean distance to the target point. # Input: - A list of points, where each point is represented as a tuple `(x, y)` of integers. The list will contain at least one point and at most (10^4) points. - A target point represented as a tuple `(x, y)` of integers. # Output: - A list of points sorted by their Euclidean distance from the target point. If two points have the same distance from the target, preserve their relative order from the input list. # Constraints: - All input points and the target point will have integer coordinates. - Ensure the implementation handles large coordinate values efficiently. # Example: ```python >>> sort_points_by_distance([(1, 2), (3, 4), (0, 0)], (0, 0)) [(0, 0), (1, 2), (3, 4)] >>> sort_points_by_distance([(1, 2), (-1, -2), (3, 4), (0, 0)], (1, 1)) [(1, 2), (0, 0), (-1, -2), (3, 4)] ``` # Performance Requirements - The sorting algorithm should run in (O(n log n)) time complexity, where (n) is the number of points in the input list.","solution":"from typing import List, Tuple import math def euclidean_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: Returns the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def sort_points_by_distance(points: List[Tuple[int, int]], target: Tuple[int, int]) -> List[Tuple[int, int]]: Sorts a list of points by their Euclidean distance to the target point. return sorted(points, key=lambda point: euclidean_distance(point, target))"},{"question":"# Coding Question Scenario In data processing, it often becomes necessary to filter out noise from data to detect significant changes in values. Consider a scenario where you\'re given a list of temperature readings throughout the day. Your task is to write a function that identifies \\"spikes\\" in temperature - a spike is defined as a reading that is significantly higher than the preceding and succeeding readings. Task Implement the function `find_temperature_spikes` to identify spikes in the list of temperature readings. # Function Signature ```python def find_temperature_spikes(temperatures: list[float], threshold: float) -> list[int]: ``` # Input * `temperatures`: A list of floats representing temperature readings at regular intervals throughout the day. * `threshold`: A float representing the minimal difference to consider a reading a spike compared to its neighbors. # Output * A list of integers representing the indices of the temperature readings that are considered spikes. # Constraints * The length of `temperatures` will be between 1 and 10^5. * Each temperature reading will be a float between -50.0 and 50.0. * `threshold` will be a positive float. # Requirements 1. For a reading to be considered a spike, it must be higher than both its preceding and succeeding readings by at least `threshold` units. 2. The first and last readings of the list cannot be considered spikes as they lack both preceding and succeeding neighbors. 3. If there are no spikes in the input list, the function should return an empty list. # Example ```python # Input temperatures = [10.5, 15.2, 8.6, 7.7, 20.0, 12.3, 14.1, 5.5] threshold = 4.0 # Output [1, 4] # Explanation - The reading at index 1 (15.2) is a spike because it is higher than 10.5 and 8.6 by more than 4.0 units. - The reading at index 4 (20.0) is a spike because it is higher than 7.7 and 12.3 by more than 4.0 units. ``` # Notes - Ensure the function is optimized for efficiency, especially with large inputs. - Be mindful of edge cases such as very small or very large input lists and consider floating point comparison intricacies. **Edge cases to consider:** - The first and last readings should not be marked as spikes. - Multiple temperature readings with the same values. - Handling large lists without performance degradation.","solution":"def find_temperature_spikes(temperatures: list[float], threshold: float) -> list[int]: spikes = [] n = len(temperatures) for i in range(1, n - 1): if temperatures[i] > temperatures[i - 1] + threshold and temperatures[i] > temperatures[i + 1] + threshold: spikes.append(i) return spikes"},{"question":"Depth-First Search (DFS) Study Depth-First Search (DFS) is a fundamental algorithm used for traversing or searching through graph data structures. It starts at a given node and explores as far as possible along each branch before backtracking. # Problem Statement You are required to implement the DFS algorithm to traverse a graph, starting from a given node. Your task is to return a list of nodes in the order they were visited. # Input * A graph represented as an adjacency list, `graph`, where `graph[node]` is a list of neighbors for that node. * An integer `start` which is the starting node for the DFS traversal. # Output * Return a list of nodes in the order they were visited during the DFS traversal. # Constraints * The graph can be any connected or disconnected graph with 0 <= number of nodes <= 10^4. * The graph may have cycles. * Each node is represented by an integer, and each list of neighbors is comprised of integers. # Example: ```python >>> graph = { ... 0: [1, 2], ... 1: [0, 3, 4], ... 2: [0, 5], ... 3: [1], ... 4: [1], ... 5: [2] ... } >>> depth_first_search(graph, 0) [0, 1, 3, 4, 2, 5] >>> graph = { ... 0: [1], ... 1: [2], ... 2: [0, 3], ... 3: [3] ... } >>> depth_first_search(graph, 2) [2, 0, 1, 3] >>> graph = {} >>> depth_first_search(graph, 0) [] ``` # Task Implement the `depth_first_search` function as described.","solution":"def depth_first_search(graph, start): Performs a depth-first search on the graph starting from the node \'start\'. :param graph: dict, adjacency list representation of the graph :param start: int, the starting node for the DFS traversal :return: list, nodes visited in the order during DFS traversal if start not in graph: return [] visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(set(graph[node]) - set(visited)) return visited"},{"question":"# Coding Challenge: Inventory Management System You are tasked with developing a system that manages the inventory of a supermarket. The system should support adding items, removing an item when it is sold, and querying the current inventory status. Each item in the inventory has a unique identifier, name, quantity, and price. # Function Signature ```python class Inventory: def __init__(self): pass def add_item(self, item_id: str, name: str, quantity: int, price: float): pass def sell_item(self, item_id: str, quantity: int) -> bool: pass def query_inventory(self) -> list[list[str, str, int, float]]: pass ``` # Method Details - `add_item(item_id: str, name: str, quantity: int, price: float)`: Adds the specified quantity of an item to the inventory. If the item already exists, its quantity is increased by the specified amount. Each item is uniquely identified by its `item_id`. - `sell_item(item_id: str, quantity: int) -> bool`: Decreases the quantity of the specified item by the given amount. If the item does not exist or there is not enough stock to fulfill the request, the method returns `False`. Otherwise, it returns `True`. - `query_inventory() -> list[list[str, str, int, float]]`: Returns the current inventory as a list of lists, where each sublist contains the `item_id`, `name`, `quantity`, and `price` of an item. # Constraints - The identifier for each item (`item_id`) is a non-empty string. - The item name (`name`) is a non-empty string. - The quantity is an integer greater than or equal to 0. - The price is a float greater than or equal to 0.0. - The `Inventory` class should handle up to 10^3 items efficiently. # Requirements - Implement and validate the `Inventory` class and its methods. - Ensure appropriate handling of edge cases (e.g., attempting to sell more items than available). - The implementation must support the constraints and handle large numbers of items efficiently. # Example ```python inventory = Inventory() inventory.add_item(\\"1\\", \\"Apple\\", 50, 0.5) inventory.add_item(\\"2\\", \\"Banana\\", 100, 0.3) inventory.sell_item(\\"1\\", 20) inventory.add_item(\\"1\\", \\"Apple\\", 30, 0.5) inventory.sell_item(\\"2\\", 10) print(inventory.query_inventory()) # Output: [ # [\\"1\\", \\"Apple\\", 60, 0.5], # [\\"2\\", \\"Banana\\", 90, 0.3] # ] ``` This question aligns with the style and complexity of the provided sample, challenging the candidate to manage inventory with appropriate methods and to handle common scenarios in inventory management like adding, removing, and querying items.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_id: str, name: str, quantity: int, price: float): if item_id in self.items: self.items[item_id][\'quantity\'] += quantity else: self.items[item_id] = {\'name\': name, \'quantity\': quantity, \'price\': price} def sell_item(self, item_id: str, quantity: int) -> bool: if item_id in self.items and self.items[item_id][\'quantity\'] >= quantity: self.items[item_id][\'quantity\'] -= quantity return True return False def query_inventory(self) -> list[list]: return [[item_id, self.items[item_id][\'name\'], self.items[item_id][\'quantity\'], self.items[item_id][\'price\']] for item_id in self.items]"},{"question":"# Array Intersection Coding Challenge Overview You are given two arrays, and you need to find the intersection of these arrays. The intersection of two arrays contains only the elements that are present in both arrays. Problem Statement Implement a function `array_intersection(arr1: list, arr2: list) -> list` that takes two lists of integers `arr1` and `arr2`, and returns a list containing the elements that are present in both arrays. Each element in the result should appear as many times as it shows in both arrays. Input - `arr1`: A list of integers. - `arr2`: A list of integers. Output - A list of integers that represent the intersection of `arr1` and `arr2`. Constraints - Elements in the arrays can be positive, negative, or zero. - Both input arrays can contain duplicate values. - The input arrays are not sorted. Example ```python arr1 = [4, 9, 5] arr2 = [9, 4, 9, 8, 4] output = [4, 9] assert array_intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9] ``` ```python arr1 = [1, 2, 2, 1] arr2 = [2, 2] output = [2, 2] assert array_intersection([1, 2, 2, 1], [2, 2]) == [2, 2] ``` Notes - The output can be in any order. - Handle edge cases where one or both arrays are empty. - Aim to optimize for time and space complexity.","solution":"def array_intersection(arr1, arr2): Returns the intersection of two arrays such that each element in the result appears as many times as it shows in both arrays. from collections import Counter # Count the elements in both arrays counter1 = Counter(arr1) counter2 = Counter(arr2) result = [] # Find the intersection and record the minimal count of duplicates for element in counter1: if element in counter2: count = min(counter1[element], counter2[element]) result.extend([element] * count) return result"},{"question":"# Coding Assessment Question Context You have been assigned to create a module for a task scheduling system. The system needs to determine the next execution time for a given task based on a specified interval. The interval is defined in terms of days, hours, and minutes. Your task is to develop a function that calculates the future execution time of the task from a given current time. Objective Write a function that computes the future date and time based on the current date and time and a provided interval. The interval will be provided as a dictionary with keys `days`, `hours`, and `minutes`. Requirements 1. Implement the function `calculate_next_execution(current_time: str, interval: dict) -> str` where: - `current_time` is a string representing the current time in the format \\"YYYY-MM-DD HH:MM\\". - `interval` is a dictionary with three integer keys: `days`, `hours`, and `minutes`, representing the interval to add to the current time. 2. The function should return the next execution time as a string in the same format \\"YYYY-MM-DD HH:MM\\". 3. Handle edge cases such as month-end or year-end correctly, ensuring that the date arithmetic accounts for leap years and varying month lengths. Constraints * The `current_time` will always be a valid date-time string in the specified format. * The `interval` dictionary will always contain non-negative integers for days, hours, and minutes. Examples ```python from datetime import datetime, timedelta def calculate_next_execution(current_time: str, interval: dict) -> str: # Your implementation here pass # Example usage and results assert calculate_next_execution(\\"2023-03-14 14:45\\", {\\"days\\": 2, \\"hours\\": 3, \\"minutes\\": 15}) == \\"2023-03-16 18:00\\" assert calculate_next_execution(\\"2022-12-30 23:30\\", {\\"days\\": 1, \\"hours\\": 1, \\"minutes\\": 45}) == \\"2023-01-01 01:15\\" assert calculate_next_execution(\\"2020-02-28 12:00\\", {\\"days\\": 1, \\"hours\\": 0, \\"minutes\\": 0}) == \\"2020-02-29 12:00\\" # Leap year case assert calculate_next_execution(\\"2021-12-31 23:59\\", {\\"days\\": 0, \\"hours\\": 0, \\"minutes\\": 1}) == \\"2022-01-01 00:00\\" ``` Notes: * Utilize the `datetime` and `timedelta` modules from Python\'s standard library to handle date and time arithmetic. * Ensure your function is robust and can handle unexpected edge cases gracefully. * Include comments and error handling as needed to explain and ensure code clarity.","solution":"from datetime import datetime, timedelta def calculate_next_execution(current_time: str, interval: dict) -> str: Calculates the next execution time based on the current time and an interval. :param current_time: A string representing the current time in the format \\"YYYY-MM-DD HH:MM\\". :param interval: A dictionary with keys \'days\', \'hours\', and \'minutes\'. :return: A string representing the next execution time in the format \\"YYYY-MM-DD HH:MM\\". # Parse the current time string into a datetime object current_datetime = datetime.strptime(current_time, \\"%Y-%m-%d %H:%M\\") # Create a timedelta object from the interval dictionary delta = timedelta(days=interval[\'days\'], hours=interval[\'hours\'], minutes=interval[\'minutes\']) # Calculate the next execution time by adding the timedelta to the current datetime next_execution_time = current_datetime + delta # Return the next execution time as a formatted string return next_execution_time.strftime(\\"%Y-%m-%d %H:%M\\")"},{"question":"# Question: Implement a Function to Find the Longest Common Prefix using Horizontal Scanning You are given a list of strings. Your task is to implement a function that finds the longest common prefix string amongst an array of strings using the horizontal scanning method. **Input**: - A list of strings `strs`. **Output**: - A string representing the longest common prefix. **Function Signature**: ```python def longest_common_prefix(strs: list[str]) -> str: pass ``` # Constraints: 1. The input list `strs` will contain at most 10^3 elements. 2. Each string in `strs` will have a maximum length of 10^2. 3. All strings consist of only lowercase English letters. # Example: ```python >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"throne\\", \\"throne\\"]) \\"throne\\" >>> longest_common_prefix([]) \\"\\" ``` # Explanation: - The first example returns `\\"fl\\"` because it is the longest common prefix for all the strings. - The second example returns `\\"\\"` because there is no common prefix among the strings. - The third example returns `\\"inters\\"` because it is the longest common prefix for all the strings. - The fourth example returns `\\"throne\\"` because all strings are identical. - The fifth example returns `\\"\\"` because the list is empty. Your implementation should be efficient and handle various edge cases correctly to determine the longest common prefix.","solution":"def longest_common_prefix(strs: list[str]) -> str: if not strs: return \\"\\" prefix = strs[0] for string in strs[1:]: while not string.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"# Problem Statement You are needed to write a function `sort_and_filter_books` that processes a list of books to filter and sort them based on given criteria. The function has to: 1. Filter the books based on genre and publication year range. 2. Sort the filtered books by a specified attribute (e.g., title, author, publication year) either in ascending or descending order. 3. Handle cases where no books match the given criteria gracefully by returning an informative message. # Function Signature ```python def sort_and_filter_books( books: list, genre: str | None = None, year_range: tuple[int, int] | None = None, sort_by: str | None = None, ascending: bool = True ) -> list | str: Filter and sort a list of books based on specified criteria. Parameters: - books (list): A list of dictionaries, where each dictionary represents a book. - genre (str): The genre to filter the books by. Optional. - year_range (tuple): A tuple of two integers representing the start and end years for filtering books based on their publication year. Optional. - sort_by (str): The attribute to sort the books by. It can be \'title\', \'author\', or \'publication_year\'. Optional. - ascending (bool): The sorting order. True for ascending, False for descending. Default is True. Returns: - list | str: Either a sorted list of filtered books or a string message indicating no books matched the criteria. ``` # Input/Output Examples Input ```python books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author Y\\", \\"publication_year\\": 2001, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author X\\", \\"publication_year\\": 1995, \\"genre\\": \\"Non-Fiction\\"}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author Z\\", \\"publication_year\\": 2010, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author W\\", \\"publication_year\\": 2005, \\"genre\\": \\"Science Fiction\\"} ] sort_and_filter_books(books, genre=\\"Fiction\\", year_range=(2000, 2015), sort_by=\\"title\\", ascending=True) ``` Output ```python [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author Y\\", \\"publication_year\\": 2001, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author Z\\", \\"publication_year\\": 2010, \\"genre\\": \\"Fiction\\"} ] ``` # Input ```python sort_and_filter_books(books, genre=\\"Romance\\", year_range=(2000, 2020), sort_by=\\"author\\", ascending=False) ``` # Output ```python \\"No books matched the criteria.\\" ``` # Constraints and Requirements 1. The `books` parameter is mandatory. 2. The `genre`, `year_range`, and `sort_by` parameters are optional. If not provided, no filtering or sorting on that specific criterion will be done. 3. The `sort_by` parameter can accept values \\"title\\", \\"author\\", or \\"publication_year\\". 4. For the `year_range` parameter, if provided, it should be a tuple of two integers. 5. The `ascending` parameter is optional, defaulting to True. 6. Provide an informative message if no books match the criteria. # Performance Requirements 1. The function should efficiently handle lists containing up to 1000 books. # Context This function can be used for managing and displaying book collections, helping users to filter and sort books based on their preferred criteria.","solution":"def sort_and_filter_books( books, genre=None, year_range=None, sort_by=None, ascending=True ): Filter and sort a list of books based on specified criteria. Parameters: - books (list): A list of dictionaries, where each dictionary represents a book. - genre (str): The genre to filter the books by. Optional. - year_range (tuple): A tuple of two integers representing the start and end years for filtering books based on their publication year. Optional. - sort_by (str): The attribute to sort the books by. It can be \'title\', \'author\', or \'publication_year\'. Optional. - ascending (bool): The sorting order. True for ascending, False for descending. Default is True. Returns: - list | str: Either a sorted list of filtered books or a string message indicating no books matched the criteria. # Filter books based on the given genre if genre: books = [book for book in books if book.get(\\"genre\\") == genre] # Filter books based on the given year range if year_range: start_year, end_year = year_range books = [ book for book in books if start_year <= book.get(\\"publication_year\\") <= end_year ] # If no books are left after filtering if not books: return \\"No books matched the criteria.\\" # Sort books based on the given attribute, if any if sort_by in [\\"title\\", \\"author\\", \\"publication_year\\"]: books = sorted(books, key=lambda x: x.get(sort_by), reverse=not ascending) return books"},{"question":"# Genetic Algorithm Optimization for Function Maximization You have been provided with a basic genetic algorithm used for optimizing functions. Your task is to enhance its functionality by implementing the following operators: selection, crossover, and mutation for maximizing a given mathematical function. Task 1. Implement the tournament selection method to choose parents for crossover. 2. Implement a one-point crossover to generate offspring from selected parents. 3. Implement a mutation operator that randomly alters genes with a given mutation probability. 4. Modify the `GeneticAlgorithm` class to use these operators for evolving the population. Input and Output * **Input**: An objective function `func` to maximize, population size, number of generations, crossover probability, and mutation probability. * **Output**: The best solution found by the genetic algorithm and its corresponding fitness value. Constraints 1. Ensure your implementation maintains diversity in the population to avoid premature convergence. 2. Handle edge cases related to small population sizes and high mutation rates. 3. Validate your implementation with a few test cases to ensure stability and effectiveness of the optimization. Performance Requirements * The algorithm should efficiently handle a population size of up to 100 and evolve for up to 1000 generations. * The implementation should provide meaningful fitness improvements over successive generations. Example Scenario Optimize the function `f(x) = x^2 - 3x + 2` over the range [0, 10]. Use your enhanced genetic algorithm to find the maximum value within a specified number of generations. Implementation Complete the functions `tournament_selection`, `one_point_crossover`, and `mutate` in the `GeneticAlgorithm` class. Then update the method `evolve` to utilize these operators for evolving the population. Finally, provide a few test cases to verify your implementation. ```python import random class GeneticAlgorithm: def __init__(self, func, pop_size, num_generations, crossover_prob, mutation_prob): self.func = func self.pop_size = pop_size self.num_generations = num_generations self.crossover_prob = crossover_prob self.mutation_prob = mutation_prob self.population = [self.create_individual() for _ in range(pop_size)] def create_individual(self): Create a random individual for the initial population. return random.uniform(0, 10) def calculate_fitness(self, individual): return self.func(individual) def tournament_selection(self): Implement the tournament selection method. # Your code here def one_point_crossover(self, parent1, parent2): Implement the one-point crossover method. # Your code here def mutate(self, individual): Implement the mutation operator. # Your code here def evolve(self): Modify this method to use selection, crossover, and mutation to evolve the population. new_population = [] for _ in range(self.pop_size // 2): parent1 = self.tournament_selection() parent2 = self.tournament_selection() if random.random() < self.crossover_prob: child1, child2 = self.one_point_crossover(parent1, parent2) else: child1, child2 = parent1, parent2 if random.random() < self.mutation_prob: child1 = self.mutate(child1) if random.random() < self.mutation_prob: child2 = self.mutate(child2) new_population.extend([child1, child2]) self.population = new_population # Example test cases def test_genetic_algorithm(): def func(x): return x**2 - 3*x + 2 ga = GeneticAlgorithm(func, pop_size=50, num_generations=100, crossover_prob=0.7, mutation_prob=0.1) for _ in range(100): ga.evolve() best_solution = max(ga.population, key=ga.calculate_fitness) print(f\\"Best solution: {best_solution}, Fitness: {ga.calculate_fitness(best_solution)}\\") test_genetic_algorithm() ```","solution":"import random class GeneticAlgorithm: def __init__(self, func, pop_size, num_generations, crossover_prob, mutation_prob): self.func = func self.pop_size = pop_size self.num_generations = num_generations self.crossover_prob = crossover_prob self.mutation_prob = mutation_prob self.population = [self.create_individual() for _ in range(pop_size)] def create_individual(self): Create a random individual for the initial population. return random.uniform(0, 10) def calculate_fitness(self, individual): return self.func(individual) def tournament_selection(self): Implement the tournament selection method. tournament_size = 3 tournament = random.sample(self.population, tournament_size) fittest_individual = max(tournament, key=self.calculate_fitness) return fittest_individual def one_point_crossover(self, parent1, parent2): Implement the one-point crossover method. crossover_point = random.randint(1, 9) / 10 child1 = crossover_point * parent1 + (1 - crossover_point) * parent2 child2 = crossover_point * parent2 + (1 - crossover_point) * parent1 return child1, child2 def mutate(self, individual): Implement the mutation operator. mutation_value = random.uniform(-1, 1) mutated_individual = individual + mutation_value return min(max(mutated_individual, 0), 10) def evolve(self): Modify this method to use selection, crossover, and mutation to evolve the population. new_population = [] for _ in range(self.pop_size // 2): parent1 = self.tournament_selection() parent2 = self.tournament_selection() if random.random() < self.crossover_prob: child1, child2 = self.one_point_crossover(parent1, parent2) else: child1, child2 = parent1, parent2 if random.random() < self.mutation_prob: child1 = self.mutate(child1) if random.random() < self.mutation_prob: child2 = self.mutate(child2) new_population.extend([child1, child2]) self.population = new_population def run(self): for _ in range(self.num_generations): self.evolve() best_solution = max(self.population, key=self.calculate_fitness) return best_solution, self.calculate_fitness(best_solution)"},{"question":"# Question: Implement Custom Activation Function in Neural Network Layer You are enhancing a neural network by creating a custom activation function. The function should be a modified version of the ReLU (Rectified Linear Unit) called \\"Parametric ReLU\\" (PReLU), where the slope of the negative part is a parameter that can be learned. Task Implement the class `ParametricReLU` in Python that can be used as an activation function in a neural network library. This class should include methods to forward propagate and backpropagate through this activation function. Class Details - **Class**: `ParametricReLU` - **Methods**: - `__init__(self, alpha=0.1)`: Initialize the PReLU object with the slope `alpha` (default: 0.1). Alpha should be initialized as a learnable parameter. - `forward(self, X)`: Compute the forward pass through the PReLU activation function. - `backward(self, X, dout)`: Compute the backward pass through the PReLU activation, returning the gradient with respect to the input. # Details: - **Input**: - `X` (np.ndarray): Input array of shape `(batch_size, num_features)`. - `dout` (np.ndarray): Gradient of the loss with respect to the output of this layer, of shape `(batch_size, num_features)`. - **Output** (for methods): - `forward`: An array of the same shape as `X` representing the activated values. - `backward`: A tuple consisting of: - `dX` (np.ndarray): Gradient of the loss with respect to the input `X`, of the same shape as `X`. - `dalpha` (float): Gradient of the loss with respect to the parameter `alpha`. Example Usage ```python prelu = ParametricReLU(alpha=0.2) # Example forward pass X = np.array([[-1, 2], [0, -3]]) forward_output = prelu.forward(X) print(forward_output) # Output: [[-0.2 2.0], [0.0 -0.6]] # Example backward pass dout = np.array([[1, -1], [2, 2]]) dX, dalpha = prelu.backward(X, dout) print(dX) # Output: [[0.2 -1.0], [2.0 0.4]] print(dalpha) # Output: -3.0 ``` Hints - The forward pass applies the PReLU function: `PReLU(x) = max(alpha * x, x)`. - For the backward pass, compute gradients using chain rule and consider both paths: where the input is positive and where it is negative. - Make sure to handle edge cases where `alpha` could be updated during training. This task requires understanding neural network activations and backpropagation, both essential concepts in deep learning.","solution":"import numpy as np class ParametricReLU: def __init__(self, alpha=0.1): Initialize the PReLU object with the slope `alpha` (default: 0.1). self.alpha = alpha def forward(self, X): Compute the forward pass through the PReLU activation function. Parameters: X (np.ndarray): Input array of shape `(batch_size, num_features)`. Returns: np.ndarray: Activated values, same shape as X. self.input = X output = np.maximum(self.alpha * X, X) return output def backward(self, X, dout): Compute the backward pass through the PReLU activation. Parameters: X (np.ndarray): Input array of shape `(batch_size, num_features)`. dout (np.ndarray): Gradient of the loss with respect to the output of this layer, of shape `(batch_size, num_features)`. Returns: tuple: (dX, dalpha) dX (np.ndarray): Gradient of the loss with respect to the input `X`, of the same shape as `X`. dalpha (float): Gradient of the loss with respect to the parameter `alpha`. dX = np.where(X > 0, 1, self.alpha) * dout dalpha = np.sum(np.where(X <= 0, X, 0) * dout) return dX, dalpha"},{"question":"# Problem Statement You are developing a feature for a digital text editor that helps writers visualize the complexity and structure of their sentences. One of the features to be implemented is to identify and highlight the longest word in each sentence of a given text. If multiple words have the same maximum length, return the last occurrence. Write a function called `highlight_longest_words` that takes a multiline string and returns a list of the longest word in each sentence. Consider a sentence to be any sequence of words ending with a period (`.`), exclamation mark (`!`), or question mark (`?`). # Function Signature ```python def highlight_longest_words(text: str) -> list: This function identifies the longest word in each sentence of the given text. Args: text: A multiline string where sentences are terminated by a period (.), exclamation mark (!), or question mark (?). Returns: list of strings, with each string being the longest word in the corresponding sentence. ``` # Expected Input and Output - **Input**: - A multiline string where sentences are separated by periods (`.`), exclamation marks (`!`), or question marks (`?`). - **Output**: - A list of strings, each representing the longest word from the corresponding sentence in the input text. # Example ```python text = This is an example. Write a function that finds the longest words! Can you solve this problem? result = highlight_longest_words(text) print(result) # Output: [\'example\', \'function\', \'problem\'] ``` # Constraints - Sentences in the input string will be well-formed, ending with one of the specified punctuation marks. - Words are sequences of letters and may include apostrophes but exclude other punctuation. - Input text will always contain at least one sentence. # Evaluation - **Correctness**: Ensure that your function correctly identifies the longest word in each sentence, handling edge cases like multiple longest words and punctuation. - **Efficiency**: Your implementation should efficiently parse and process the text, even for larger inputs.","solution":"def highlight_longest_words(text: str) -> list: import re sentences = re.split(r\'[.!?]\', text) longest_words = [] for sentence in sentences: words = re.findall(r\'bw+b\', sentence) if not words: continue max_len = max(len(word) for word in words) longest_word = next(word for word in reversed(words) if len(word) == max_len) longest_words.append(longest_word) return longest_words"},{"question":"# Scenario You are tasked with designing a text editor that includes an auto-complete feature. This feature should suggest words based on the initial characters typed by the user. To build this feature, you need to implement a Trie (prefix tree) data structure that supports insertion of words and retrieval of suggestions based on a given prefix. # Task Write two classes to support the functionality of the autocomplete feature. # Class 1: `TrieNode` This class represents a single node in the Trie. Attributes - `children`: A dictionary storing the child nodes. - `is_end_of_word`: A boolean indicating if the node represents the end of a word. Methods - `__init__(self)`: Initializes the TrieNode. # Class 2: `Trie` This class represents the Trie itself. Methods - `__init__(self)`: Initializes the Trie with a root node. - `insert(self, word)`: Inserts a word into the Trie. - `suggestions(self, prefix)`: Returns a list of all words in the Trie that start with the given prefix. Example ```python # Create a new Trie trie = Trie() # Insert words into the Trie trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"heaven\\") trie.insert(\\"heavy\\") # Get suggestions for a prefix assert trie.suggestions(\\"he\\") == [\\"hell\\", \\"hello\\", \\"heaven\\", \\"heavy\\"] assert trie.suggestions(\\"hea\\") == [\\"heaven\\", \\"heavy\\"] assert trie.suggestions(\\"hel\\") == [\\"hell\\", \\"hello\\"] assert trie.suggestions(\\"h\\") == [\\"hell\\", \\"hello\\", \\"heaven\\", \\"heavy\\"] ``` Constraints - Consider the case sensitivity of the words. It is recommended to treat all words as having the same case (e.g., lower case) for simplicity. - Ensure the `insert` and `suggestions` functions are optimized for performance. - Handle edge cases where no words match the given prefix. # Notes - Avoid using existing libraries that implement Trie data structures. - Focus on ensuring your Trie efficiently supports insertion and retrieval operations. - The output list for suggestions should be sorted lexicographically.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _collect_all_words_from_node(self, node, prefix, result): if node.is_end_of_word: result.append(prefix) for char, child_node in node.children.items(): self._collect_all_words_from_node(child_node, prefix + char, result) def suggestions(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] result = [] self._collect_all_words_from_node(node, prefix, result) return sorted(result)"},{"question":"# Problem Statement: You are given a list of student test scores in the form of a dictionary, where the keys are student names and the values are lists of test scores. Your task is to implement a set of functions to perform the following operations: 1. Calculate the average score for each student. 2. Determine the student with the highest average score. 3. Group students based on their letter grade (A, B, C, D, F) according to their average score. # Requirements: 1. **Calculate average scores:** Implement a function that calculates the average score for each student and returns a dictionary with student names as keys and their respective average scores as values. 2. **Highest average score:** Implement a function that determines the student with the highest average score and returns the student\'s name and average score as a tuple. 3. **Group by grades:** Implement a function that groups students based on their letter grades according to their average scores and returns a dictionary with grades (\'A\', \'B\', \'C\', \'D\', \'F\') as keys and lists of student names as values. # Letter Grade Rules: - A: Average score >= 90 - B: 80 <= Average score < 90 - C: 70 <= Average score < 80 - D: 60 <= Average score < 70 - F: Average score < 60 # Function Signatures: ```python def calculate_average_scores(test_scores: dict) -> dict: def highest_average_score(test_scores: dict) -> tuple: def group_by_grades(average_scores: dict) -> dict: ``` # Input: - **test_scores**: A dictionary where keys are student names (strings) and values are lists of test scores (integers). # Output: - **calculate_average_scores**: Returns a dictionary with student names as keys and their average scores as values (rounded to 2 decimal places). - **highest_average_score**: Returns a tuple containing the student name with the highest average score and the average score itself. - **group_by_grades**: Returns a dictionary with letter grades (\'A\', \'B\', \'C\', \'D\', \'F\') as keys and lists of student names as values. # Constraints: - Each student will have at least one test score. - There will be at least one student in the input dictionary. - Scores will be integers ranging from 0 to 100. # Examples: ```python test_scores = { \\"Alice\\": [95, 85, 92], \\"Bob\\": [78, 81, 86], \\"Charlie\\": [55, 60, 65], \\"David\\": [99, 100, 98], \\"Eve\\": [45, 50, 47] } # Calculating average scores average_scores = calculate_average_scores(test_scores) assert average_scores == { \\"Alice\\": 90.67, \\"Bob\\": 81.67, \\"Charlie\\": 60.0, \\"David\\": 99.0, \\"Eve\\": 47.33 } # Determining highest average score student_with_highest_avg = highest_average_score(test_scores) assert student_with_highest_avg == (\\"David\\", 99.0) # Grouping by grades grades = group_by_grades(average_scores) assert grades == { \\"A\\": [\\"Alice\\", \\"David\\"], \\"B\\": [\\"Bob\\"], \\"C\\": [], \\"D\\": [\\"Charlie\\"], \\"F\\": [\\"Eve\\"] } ``` # Notes: - Ensure your solution is efficient and handles the constraints properly. - Do not alter the function signatures. - You may add helper functions if needed but ensure they follow the required logic and constraints.","solution":"def calculate_average_scores(test_scores: dict) -> dict: Calculate the average score for each student. average_scores = {} for student, scores in test_scores.items(): average_scores[student] = round(sum(scores) / len(scores), 2) return average_scores def highest_average_score(test_scores: dict) -> tuple: Determine the student with the highest average score. average_scores = calculate_average_scores(test_scores) highest_student = max(average_scores, key=average_scores.get) return (highest_student, average_scores[highest_student]) def group_by_grades(average_scores: dict) -> dict: Group students based on their letter grades according to their average scores. grades = {\'A\': [], \'B\': [], \'C\': [], \'D\': [], \'F\': []} for student, avg_score in average_scores.items(): if avg_score >= 90: grades[\'A\'].append(student) elif avg_score >= 80: grades[\'B\'].append(student) elif avg_score >= 70: grades[\'C\'].append(student) elif avg_score >= 60: grades[\'D\'].append(student) else: grades[\'F\'].append(student) return grades"},{"question":"# Problem Statement: Maze Path Finder In this task, you\'ll write a function that finds a path through a maze represented by a grid. The maze contains start and end points, and your job is to determine if there\'s a path from start to end, and if so, return the path. Requirements 1. **Function Signature**: ```python def find_maze_path( maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int] ) -> List[Tuple[int, int]]: ``` 2. **Parameters**: - `maze` (List[List[int]]): A 2D list representing the maze grid, where `0` represents a free path and `1` represents a wall. - `start` (Tuple[int, int]): A tuple of two integers representing the starting coordinates in the maze. - `end` (Tuple[int, int]): A tuple of two integers representing the ending coordinates in the maze. 3. **Output**: - The function should return a list of tuples representing the coordinates of the path from the start to the end. If no path exists, return an empty list. 4. **Constraints**: - The maze grid will always be a non-empty rectangle. - The start and end points will be within the bounds of the maze grid. - You can move up, down, left, or right, but not diagonally. - Ensure the function handles mazes with no valid path efficiently. - The function should terminate promptly for large maze grids. # Example Usage ```python # Example of a maze grid maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], ] start = (0, 0) # Start at top left corner end = (4, 4) # End at bottom right corner # Finding the path path = find_maze_path(maze, start, end) print(path) # Output could be: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ```","solution":"from typing import List, Tuple from collections import deque def find_maze_path( maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int] ) -> List[Tuple[int, int]]: Finds a path through a maze from start to end. Parameters: - maze: 2D list where 0 represents a free path and 1 represents a wall. - start: (x, y) tuple representing the starting point. - end: (x, y) tuple representing the ending point. Returns: - List of (x, y) tuples representing the path from start to end. - Empty list if no path exists. if not maze or not start or not end: return [] rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0 visited = set() queue = deque([(start, [start])]) visited.add(start) while queue: (current_x, current_y), path = queue.popleft() if (current_x, current_y) == end: return path for direction in directions: next_x, next_y = current_x + direction[0], current_y + direction[1] if is_valid(next_x, next_y) and (next_x, next_y) not in visited: visited.add((next_x, next_y)) queue.append(((next_x, next_y), path + [(next_x, next_y)])) return []"},{"question":"# Question Statement - Construct the LCS (Longest Common Subsequence) Matrix Given two strings X and Y, each of length not greater than 1000 (1 ≤ |X|, |Y| ≤ 1000), write a function `longest_common_subsequence_length` that computes the length of the longest common subsequence (LCS) of the two strings using dynamic programming. Your implementation should build an auxiliary matrix to store intermediate LCS lengths and save memory by using only two rows. # Input Format: * A single line with the first string X. * A single line with the second string Y. # Output Format: * A single integer - the length of the longest common subsequence. # Constraints: * Both strings consist of lower-case English letters only. * 1 ≤ length of X, Y ≤ 1000. # Example: Input: ``` abcdgh aedfhr ``` Output: ``` 3 ``` Explanation: The longest common subsequence of \\"abcdgh\\" and \\"aedfhr\\" is \\"adh\\", which has a length of 3. # Example 2: Input: ``` aggtab gxtxayb ``` Output: ``` 4 ``` Explanation: The longest common subsequence of \\"aggtab\\" and \\"gxtxayb\\" is \\"gtab\\", which has a length of 4. # Function Signature: ```python def longest_common_subsequence_length(X: str, Y: str) -> int: # Complete the function implementation ```","solution":"def longest_common_subsequence_length(X: str, Y: str) -> int: Returns the length of the longest common subsequence of strings X and Y. m, n = len(X), len(Y) # Initialize DP array with two rows dp = [[0] * (n + 1) for _ in range(2)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1 else: dp[i % 2][j] = max(dp[(i - 1) % 2][j], dp[i % 2][j - 1]) return dp[m % 2][n]"},{"question":"# Scenario You are working on a program that converts input strings to a format used in international aviation. Flight codes often consist of a combination of letters and numbers without any spaces, and the letters are always in uppercase. Your goal is to normalize these flight codes to adhere to this standard format. # Problem Statement Write a function `normalize_flight_code(code: str) -> str` that takes a string `code` and converts it to a valid flight code by removing any non-alphanumeric characters and converting all letters to uppercase. # Input/Output Format * **Input**: * A string `code` where the length of the string is between `1` and `1000` characters. * **Output**: * A string that represents the normalized flight code, adhering to the specified format. # Constraints * The input string may contain spaces, punctuation, and both uppercase and lowercase letters. * Handle empty strings gracefully by returning an empty result. * Assume input strings only contain valid Unicode characters. # Example ```python >>> normalize_flight_code(\\" aaBB123 \\") \\"AABB123\\" >>> normalize_flight_code(\\"abc-def-ghi\\") \\"ABCDEFGHI\\" >>> normalize_flight_code(\\"Flight 34\\") \\"FLIGHT34\\" >>> normalize_flight_code(\\" jetBlue 22 \\") \\"JETBLUE22\\" >>> normalize_flight_code(\\"\\") \\"\\" ``` # Guidance Implement the solution such that it effectively removes all unwanted characters and normalizes the string with a linear pass through the input. Leverage string manipulation techniques to achieve the desired format, ensuring that the function operates efficiently even for the maximum input length.","solution":"def normalize_flight_code(code: str) -> str: Normalizes the flight code by removing non-alphanumeric characters and converting letters to uppercase. Parameters: code (str): The input string to be normalized Returns: str: The normalized flight code # Remove non-alphanumeric characters and convert to uppercase normalized_code = \'\'.join(char.upper() for char in code if char.isalnum()) return normalized_code"},{"question":"# Coding Assessment Question Context: In computer graphics, the concept of color plays a crucial role. Colors are often represented by the RGB (Red, Green, Blue) color model, where each component can have a value between 0 and 255. Sometimes it is necessary to convert an RGB color to its hex representation for web development purposes. Task: Implement a function `rgb_to_hex` that converts an RGB color to its hexadecimal string representation. Specification: * **Function**: ```python def rgb_to_hex(red: int, green: int, blue: int) -> str: ``` * **Input**: * `red` - Red component of the color (integer, 0 ≤ red ≤ 255). * `green` - Green component of the color (integer, 0 ≤ green ≤ 255). * `blue` - Blue component of the color (integer, 0 ≤ blue ≤ 255). * **Output**: * Return the hexadecimal representation of the color as a string (e.g., \'#FFFFFF\' for white). * **Constraints**: * If any color component is outside the range 0 to 255, raise an Exception: * `Red value out of range` if red is invalid. * `Green value out of range` if green is invalid. * `Blue value out of range` if blue is invalid. Examples: ```python >>> rgb_to_hex(255, 0, 0) # red \'#FF0000\' >>> rgb_to_hex(0, 255, 0) # green \'#00FF00\' >>> rgb_to_hex(0, 0, 255) # blue \'#0000FF\' >>> rgb_to_hex(255, 255, 255) # white \'#FFFFFF\' >>> rgb_to_hex(256, 0, 0) # invalid red Traceback (most recent call last): ... Exception: Red value out of range >>> rgb_to_hex(0, -1, 0) # invalid green Traceback (most recent call last): ... Exception: Green value out of range >>> rgb_to_hex(0, 0, 512) # invalid blue Traceback (most recent call last): ... Exception: Blue value out of range ```","solution":"def rgb_to_hex(red: int, green: int, blue: int) -> str: Converts RGB color values to their hexadecimal representation. :param red: int - Red component (0 ≤ red ≤ 255) :param green: int - Green component (0 ≤ green ≤ 255) :param blue: int - Blue component (0 ≤ blue ≤ 255) :return: str - Hexadecimal representation of the color if not (0 <= red <= 255): raise Exception(\\"Red value out of range\\") if not (0 <= green <= 255): raise Exception(\\"Green value out of range\\") if not (0 <= blue <= 255): raise Exception(\\"Blue value out of range\\") return f\'#{red:02X}{green:02X}{blue:02X}\'"},{"question":"# Coding Assessment Question: Robot Vacuum Cleaner Path Problem Statement: You are tasked with programming a robot vacuum cleaner that operates in a room represented as a 2D grid. The grid contains only zeros (0) and ones (1), where a zero represents an empty cell the robot can clean, and a one represents an obstacle the robot cannot pass through. The robot can move in four directions: up, down, left, and right. Your objective is to write a function that determines if there exists a path from the robot\'s starting position (top-left cell) to the charging dock (bottom-right cell). Function Signature: ```python def can_reach_charging_dock(grid: list[list[int]]) -> bool: pass ``` Inputs: - `grid` (list[list[int]]): A 2D list representing the room (1 <= m, n <= 50). Outputs: - Returns a boolean value: `True` if the robot can reach the charging dock, `False` otherwise. Constraints: 1. The start (0,0) and the end (m-1, n-1) will always be zeros. 2. The robot can only traverse through cells containing zeros. 3. The robot can move up, down, left, or right but cannot move diagonally or pass through obstacles. Example: ```python grid = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] assert can_reach_charging_dock(grid) == True grid = [ [0, 0, 1, 0], [0, 1, 1, 0], [0, 1, 0, 1], [1, 0, 0, 0] ] assert can_reach_charging_dock(grid) == False ``` The function should correctly handle both small grids and be efficient enough for larger grids up to 50x50 in size. Hints: - Consider using Breadth-First Search (BFS) or Depth-First Search (DFS) to explore possible paths. - Keep track of visited cells to avoid infinite loops or revisiting cells.","solution":"from collections import deque def can_reach_charging_dock(grid: list[list[int]]) -> bool: Checks if there is a path from the top-left to the bottom-right of a grid Args: grid (list[list[int]]): 2D grid representing the room Returns: bool: True if path exists, False otherwise if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (m-1, n-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"Task # Inventory Management System You are in charge of developing a fundamental part of an inventory management system for a small business. Your task is to create functions that will help manage the inventory of products with their prices and quantities. Task: Create the following two functions: 1. `add_product(inventory: dict, product_name: str, price: float, quantity: int) -> None` 2. `calculate_total_value(inventory: dict) -> float` Function Details: 1. `add_product(inventory: dict, product_name: str, price: float, quantity: int) -> None` - **Parameters**: - `inventory` (dict): The dictionary representing the current inventory. The keys are product names (strings), and the values are lists with the price (float) and quantity (int) of the product. - `product_name` (str): The name of the product to add or update. - `price` (float): The price of the product. - `quantity` (int): The amount of product to add. - **Return**: None (updates the inventory in place). - **Behavior**: If the product already exists in the inventory, its price and quantity should be updated accordingly. If it does not exist, it should be added with the given price and quantity. 2. `calculate_total_value(inventory: dict) -> float` - **Parameters**: - `inventory` (dict): The dictionary representing the current inventory. The keys are product names (strings), and the values are lists with the price (float) and quantity (int) of the product. - **Return**: The total value (float) of all products in the inventory. This is calculated by summing up the product of the price and quantity of all items. Constraints: - The price will be a non-negative float. - The quantity will be a non-negative integer. - Assume product names are unique strings. Example: ```python inventory = {} add_product(inventory, \\"apple\\", 0.5, 10) add_product(inventory, \\"banana\\", 0.3, 5) add_product(inventory, \\"apple\\", 0.6, 5) # Updates price and quantity of apples print(inventory) # Output: {\'apple\': [0.6, 15], \'banana\': [0.3, 5]} total_value = calculate_total_value(inventory) print(total_value) # Output: 10.5 ``` Performance Requirements: - The `add_product` function should operate in O(1) time complexity on average. - The `calculate_total_value` function should operate in O(n) time complexity, where n is the number of different products in the inventory. - Space complexity should be O(k) for storing the inventory, where k is the number of different products.","solution":"def add_product(inventory, product_name, price, quantity): Adds or updates a product in the inventory. :param inventory: dict - The current inventory. :param product_name: str - The name of the product to add or update. :param price: float - The price of the product. :param quantity: int - The amount of product to add. if product_name in inventory: # Update the existing product\'s price and increase the quantity inventory[product_name][0] = price inventory[product_name][1] += quantity else: # Add the new product with given price and quantity inventory[product_name] = [price, quantity] def calculate_total_value(inventory): Calculates the total value of all products in the inventory. :param inventory: dict - The current inventory. :return: float - The total value of all products. total_value = 0.0 for price, quantity in inventory.values(): total_value += price * quantity return total_value"},{"question":"# Challenging Coding Assessment Question Context In computer graphics and game development, 2D grids (also known as matrices) are commonly used to represent a variety of elements such as game maps, pixel images, and more. Efficient traversal of these grids is crucial for numerous algorithms and functionalities like pathfinding, drawing, and simulation. Task Implement a function `longest_increasing_path(matrix: List[List[int]]) -> int` that returns the length of the longest increasing path in a 2D grid. The path can move in four possible directions: up, down, left, and right. You can assume all moves lead to valid positions within the grid. Input and Output Formats: ```python def longest_increasing_path(matrix: List[List[int]]) -> int: pass # Example usage: print(longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ])) # Output: 4 print(longest_increasing_path([ [3, 4, 5], [3, 2, 6], [2, 2, 1] ])) # Output: 4 ``` Constraints: * The length and width of the grid do not exceed 200 (1 <= len(matrix), len(matrix[0]) <= 200). * Each element in the matrix is an integer within the range [-10^5, 10^5]. Requirements: 1. **DFS with Memoization:** Use Depth-First Search (DFS) with memoization to store and reuse results of subproblems. 2. **Optimal Traversal:** Ensure the algorithm efficiently determines the longest path by avoiding redundant calculations. 3. **Edge Cases:** Handle matrices that have one row, one column, or uniform values appropriately. Performance Goals: * Aim for an O(m * n) time complexity where m is the number of rows and n is the number of columns, optimizing traversal and caching results effectively. * Efficiently manage space to store intermediate results, balancing between time and space complexity. Implement the `longest_increasing_path` function, ensuring it adheres to the above specifications and performs optimally for all given constraints.","solution":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) memo = [[-1] * cols for _ in range(rows)] def dfs(r, c): if memo[r][c] != -1: return memo[r][c] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]: length = 1 + dfs(nr, nc) max_length = max(max_length, length) memo[r][c] = max_length return max_length longest_path = 0 for r in range(rows): for c in range(cols): longest_path = max(longest_path, dfs(r, c)) return longest_path"},{"question":"# Unique String Merger Function - Maintain Order Scenario Given two strings, your task is to implement a function that merges them while maintaining the order of appearance of characters and ensuring no duplicate characters are used. Task Write a function `unique_string_merger(str1: str, str2: str) -> str` that: - Merges two input strings, `str1` and `str2`, into a single string. - Ensures the merged string contains unique characters only, maintaining the order of first appearance from the combined sequences of both input strings. - Treats the input strings as case-sensitive, meaning `A` and `a` are considered different characters. Input Format - Two non-empty strings `str1` and `str2`. Output Format - Returns a single string which is a merge of `str1` and `str2`, containing only unique characters and maintaining their original order of appearance. Constraints - Both strings will be non-empty and contain printable ASCII characters. - The length of each string will be up to 1000 characters. Examples ```python >>> unique_string_merger(\\"abc\\", \\"def\\") \\"abcdef\\" >>> unique_string_merger(\\"aA\\", \\"Aa\\") \\"aA\\" >>> unique_string_merger(\\"python\\", \\"rocks\\") \\"pythonrcks\\" >>> unique_string_merger(\\"abcabc\\", \\"123123\\") \\"abc123\\" >>> unique_string_merger(\\"hello\\", \\"world\\") \\"helowrd\\" ``` Implement the function `unique_string_merger` adhering to the conditions and ensure it handles all edge cases effectively.","solution":"def unique_string_merger(str1: str, str2: str) -> str: Merges two input strings into a single string with unique characters, maintaining the order of their first appearance in the combined sequences. seen = set() result = [] for char in str1 + str2: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Problem Statement: A company uses a simplified version of the COBOL language to perform daily revenue calculations. The syntax used for arithmetic calculations includes basic addition, subtraction, multiplication, and division. Given a string representing a single arithmetic operation in COBOL number formatting, your task is to evaluate the result of the operation. # Task: Write a function `evaluate_cobol_expression()` that takes a string argument: - `expression` (str): A string representing the COBOL arithmetic operation. The operations in the expression string will always include two operands and an operator (`+`, `-`, `*`, `/`). The operands and the operator will be separated by a single space. For example: - `\'23 + 7\'` should return `30` - `\'50 - 8\'` should return `42` - `\'4 * 5\'` should return `20` - `\'20 / 4\'` should return `5.0` The function should return the result of the operation as a float or integer, as appropriate. Constraints: - The expression will always contain valid integers for operands. - Division by zero is guaranteed not to occur. - The result should be a float if division is performed, otherwise an integer. Example: ```python def evaluate_cobol_expression(expression: str) -> float: pass # Your implementation here # Example Test Cases: print(evaluate_cobol_expression(\'23 + 7\')) # 30 print(evaluate_cobol_expression(\'50 - 8\')) # 42 print(evaluate_cobol_expression(\'4 * 5\')) # 20 print(evaluate_cobol_expression(\'20 / 4\')) # 5.0 ``` # Requirements: - Implement error checking for invalid expressions, raising a `ValueError` with the message \\"Invalid expression\\" if the syntax is not as expected. - Follow standard arithmetic rules for the operations. This question aligns with the given sample in terms of structure, complexity, and programming concepts, making it a cohesive addition to the set.","solution":"def evaluate_cobol_expression(expression: str): Evaluates a COBOL arithmetic expression that contains two operands separated by a single operation. :param expression: The COBOL arithmetic expression as a string (e.g., \\"23 + 7\\") :return: The result of the operation as either an int or float try: operand1, operator, operand2 = expression.split() operand1 = int(operand1) operand2 = int(operand2) if operator == \'+\': return operand1 + operand2 elif operator == \'-\': return operand1 - operand2 elif operator == \'*\': return operand1 * operand2 elif operator == \'/\': return operand1 / operand2 else: raise ValueError(\\"Invalid expression\\") except ValueError: raise ValueError(\\"Invalid expression\\")"},{"question":"Problem Description You are tasked with writing a function to simulate the game of rock-paper-scissors extended to include a scoring system. The game is played between two players, and they play multiple rounds. Determine the final score of each player after all rounds have been played. # Input - A list of strings, where each string represents one round of the game in the format \\"P1_move P2_move\\". The moves are represented as follows: - \\"R\\" for Rock - \\"P\\" for Paper - \\"S\\" for Scissors # Output - A tuple of two integers representing the final scores of Player 1 and Player 2, respectively. # Function Signature ```python def rock_paper_scissors_score(rounds: list[str]) -> tuple[int, int]: pass ``` # Constraints - Each input string is valid and contains exactly two moves. - The list of rounds can be of length 0 to 1000. - Each move in the input is either \\"R\\", \\"P\\", or \\"S\\". # Example ```python rounds = [ \\"R P\\", \\"S R\\", \\"P S\\", \\"R R\\", \\"P P\\", \\"S S\\" ] print(rock_paper_scissors_score(rounds)) # Output: (0, 3) ``` # Notes - Rock defeats Scissors, Scissors defeat Paper, and Paper defeats Rock. - If both players make the same move, it is a tie and no points are awarded for that round. - Player 1 scores a point if they win a round, and similarly, Player 2 scores a point if they win a round.","solution":"def rock_paper_scissors_score(rounds: list[str]) -> tuple[int, int]: Calculates the final scores of Player 1 and Player 2 after a series of rock-paper-scissors rounds. Args: - rounds (list): A list of strings where each string represents one round in the format \\"P1_move P2_move\\". Returns: - (tuple): A tuple of two integers representing the final scores of Player 1 and Player 2, respectively. score_p1, score_p2 = 0, 0 # Define the win conditions win_conditions = { (\\"R\\", \\"S\\"), # Rock beats Scissors (\\"S\\", \\"P\\"), # Scissors beat Paper (\\"P\\", \\"R\\") # Paper beats Rock } for round in rounds: p1_move, p2_move = round.split() if (p1_move, p2_move) in win_conditions: score_p1 += 1 elif (p2_move, p1_move) in win_conditions: score_p2 += 1 # If it\'s a tie, no score is awarded to either player return score_p1, score_p2"},{"question":"# Efficient Subarray Sum Calculation Background Given an integer array `nums` and an integer `k`, find the total number of continuous subarrays whose sum equals `k`. This problem tests your ability to use hash tables to efficiently solve array problems with cumulative sums. # Task 1. **Subarray Sum Equals K**: - Implement a function `subarray_sum` that takes in an integer array `nums` and an integer `k`. - Return the total count of continuous subarrays that sum to `k`. - Use an efficient approach to achieve additional constraints, like time complexity. Function Signature * `def subarray_sum(nums: List[int], k: int) -> int` # Constraints * The array `nums` will have at least 1 element and at most 10^4 elements. * Each element in the array will be between `-10^4` and `10^4`. # Examples ```python print(subarray_sum([1, 1, 1], 2)) # -> 2 print(subarray_sum([1, 2, 3], 3)) # -> 2 print(subarray_sum([10, 2, -2, -20, 10], -10)) # -> 3 ``` # Notes * Utilize a cumulative sum and hash table to achieve an efficient solution. * Consider edge cases such as an array with only one element, arrays with negative numbers, and when no subarray sums to `k`. * Make sure to handle large inputs and outputs effectively. --- Your task is to ensure the implementation of the function `subarray_sum` adheres to the guidelines and constraints provided. Optimize for time and space complexity, and handle edge cases appropriately.","solution":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Returns the number of continuous subarrays whose sum equals k. count = 0 curr_sum = 0 sum_map = {0: 1} # To handle the case where the subarray starts from index 0 for num in nums: curr_sum += num if (curr_sum - k) in sum_map: count += sum_map[curr_sum - k] if curr_sum in sum_map: sum_map[curr_sum] += 1 else: sum_map[curr_sum] = 1 return count"},{"question":"# **Problem Statement:** You are tasked with developing a program to manage a simple library catalog system. This system needs to record book information and allow users to search for books based on different criteria. # **Function Specification:** 1. **`add_book(catalog: dict[str, dict[str, str]], title: str, author: str, genre: str, year: str) -> dict[str, dict[str, str]]`** * **Input**: `catalog` (a dictionary representing the current library catalog), `title`, `author`, `genre`, and `year` (strings representing the book\'s information). * **Output**: The updated catalog with the new book added. Example: ```python >>> catalog = {} >>> add_book(catalog, \'The Great Gatsby\', \'F. Scott Fitzgerald\', \'Fiction\', \'1925\') {\'The Great Gatsby\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1925\'}} ``` 2. **`search_by_title(catalog: dict[str, dict[str, str]], title: str) -> dict[str, dict[str, str]]`** * **Input**: `catalog` (a dictionary representing the library catalog), `title` (a string representing the title or a partial title to search for). * **Output**: A dictionary of books that match the given title. If no books match, the output should be an empty dictionary. Example: ```python >>> catalog = { ... \'The Great Gatsby\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1925\'}, ... \'Gatsby Returns\': {\'author\': \'Unknown\', \'genre\': \'Fiction\', \'year\': \'2025\'} ... } >>> search_by_title(catalog, \'Gatsby\') {\'The Great Gatsby\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1925\'}, \'Gatsby Returns\': {\'author\': \'Unknown\', \'genre\': \'Fiction\', \'year\': \'2025\'}} ``` 3. **`search_by_author(catalog: dict[str, dict[str, str]], author: str) -> dict[str, str]`** * **Input**: `catalog` (a dictionary representing the library catalog), `author` (a string representing the author or a partial author name to search for). * **Output**: A dictionary of books written by the matching author(s). If no books match, the output should be an empty dictionary. Example: ```python >>> catalog = { ... \'The Great Gatsby\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1925\'}, ... \'Tender Is the Night\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1934\'} ... } >>> search_by_author(catalog, \'Fitzgerald\') {\'The Great Gatsby\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1925\'}, \'Tender Is the Night\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1934\'}} ``` 4. **`remove_book(catalog: dict[str, dict[str, str]], title: str) -> dict[str, dict[str, str]]`** * **Input**: `catalog` (a dictionary representing the library catalog), `title` (a string representing the title of the book to be removed). * **Output**: The updated catalog with the specified book removed. If the book does not exist, return the catalog unchanged. Example: ```python >>> catalog = { ... \'The Great Gatsby\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1925\'}, ... \'Tender Is the Night\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1934\'} ... } >>> remove_book(catalog, \'The Great Gatsby\') {\'Tender Is the Night\': {\'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': \'1934\'}} ``` # **Implementation Notes:** * For `add_book`, ensure that each book title in the catalog is unique. If a book with the same title already exists, update its details. * For `search_by_title` and `search_by_author`, make the search case-insensitive and match if the input parameter is a substring of the respective attribute in the catalog. * All output catalogs should maintain consistent structure for each book\'s information. # **Constraints:** * 1 ≤ length of `catalog` ≤ 1000 * 1 ≤ length of `title`, `author`, `genre`, `year` ≤ 100 * Input strings can contain alphabetic characters, numeric digits, spaces, and other punctuation marks. # **Performance Requirements:** * Operations for adding, searching, and removing books should be efficient enough to handle large catalogs within acceptable time limits for the given constraints. Good luck!","solution":"def add_book(catalog, title, author, genre, year): Adds or updates a book in the catalog. catalog[title] = { \'author\': author, \'genre\': genre, \'year\': year } return catalog def search_by_title(catalog, title): Searches for books by title (case-insensitive and partial matching). result = {k: v for k, v in catalog.items() if title.lower() in k.lower()} return result def search_by_author(catalog, author): Searches for books by author (case-insensitive and partial matching). result = {k: v for k, v in catalog.items() if author.lower() in v[\'author\'].lower()} return result def remove_book(catalog, title): Removes a book from the catalog by title. if title in catalog: del catalog[title] return catalog"},{"question":"# Coding Assessment Question Scenario: You are assisting in the development of a data analytics tool that requires computing certain statistics over a collection of numbers. One of the critical functions is calculating the moving average of a list of numbers as new data points are added. Task: Implement a class `MovingAverage` that maintains the moving average of numbers in a streaming fashion, meaning new numbers can be added, and the average is recalculated efficiently. # Requirements: 1. Implement the class `MovingAverage` with the following methods: - `__init__(self, size: int) -> None`: Initializes the `MovingAverage` with a window size. - `next(self, val: float) -> float`: Accepts a new number and returns the moving average of the last `size` numbers. 2. Ensure the class handles edge cases such as when the number of elements added is less than the window size. # Input Format: - The `MovingAverage` class will be instantiated with an integer representing the window size. - Call the `next` method with a float representing the new data point. # Output Format: - The `next` method returns the current moving average as a float. # Constraints: - Window size (1 leq text{size} leq 10^4). - The number of elements added (n leq 10^5). - Each element is a float. - Maintain an efficient solution considering the constraints. # Code: ```python from collections import deque class MovingAverage: def __init__(self, size: int) -> None: if size <= 0: raise ValueError(\\"Size must be positive\\") self.size = size self.queue = deque() self.sum = 0.0 def next(self, val: float) -> float: self.queue.append(val) self.sum += val if len(self.queue) > self.size: self.sum -= self.queue.popleft() return self.sum / len(self.queue) ``` # Example: ```python # Example usage moving_average = MovingAverage(3) print(moving_average.next(1)) # Output: 1.0 print(moving_average.next(10)) # Output: 5.5 print(moving_average.next(3)) # Output: 4.67 print(moving_average.next(5)) # Output: 6.0 ``` # Explanation: - **Input**: Instantiate `MovingAverage` with window size 3, and then call `next` with values 1, 10, 3, and 5. - **Process**: Keep track of the sum of the last `size` values, updating the queue and sum as new values are added. - **Output**: Return the moving average based on the current set of numbers within the window.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int) -> None: if size <= 0: raise ValueError(\\"Size must be positive\\") self.size = size self.queue = deque() self.sum = 0.0 def next(self, val: float) -> float: self.queue.append(val) self.sum += val if len(self.queue) > self.size: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"# Problem Statement You are tasked with implementing a function that validates if a given string can represent a numerical value. The function should handle both integer and floating-point representations, including optional signs and scientific notation. # Function Signature ```python def is_valid_number(s: str) -> bool: Validates whether the input string s is a valid numerical value. Parameters: s (str): The string to validate. Returns: bool: True if the string is a valid number, False otherwise. Example: >>> is_valid_number(\\"123\\") True >>> is_valid_number(\\"-123.45\\") True >>> is_valid_number(\\"1e10\\") True >>> is_valid_number(\\"3.14E-2\\") True >>> is_valid_number(\\"+-123\\") False >>> is_valid_number(\\"1a3\\") False pass ``` # Constraints - The input string `s` will have a length between 1 and 100 characters. - The string can contain digits, a single optional sign (`+` or `-`), an optional decimal point (`.`), and an optional exponent (`e` or `E`), where the exponent is followed by an optional sign and one or more digits. # Performance Requirements - The solution should efficiently handle the input constraints and ensure correctness for various edge cases. # Example Usage ```python assert is_valid_number(\\"123\\") == True assert is_valid_number(\\"-123.45\\") == True assert is_valid_number(\\"1e10\\") == True assert is_valid_number(\\"3.14E-2\\") == True assert is_valid_number(\\"1E\\") == False assert is_valid_number(\\"+.8\\") == True assert is_valid_number(\\"-.\\") == False assert is_valid_number(\\"\\") == False ``` # Implementation Notes Consider using state machines or regular expressions to validate the number based on the specified rules. Methods from the standard library, such as `float()`, should not be used directly to avoid unintended parsing behaviors not aligned with the required constraints.","solution":"import re def is_valid_number(s: str) -> bool: Validates whether the input string s is a valid numerical value. Parameters: s (str): The string to validate. Returns: bool: True if the string is a valid number, False otherwise. # Define the regex pattern for a valid number pattern = re.compile(r ^[+-]? # Optional leading sign ( # Start of capturing group for the number base (d+.d*)| # Digits before and after decimal point (e.g. 123.456, 123., .456) (.d+)| # Digits only after decimal point (.456) (d+) # Digits only before decimal point (123) ) # End of capturing group for number base ([eE][+-]?d+)? # Optional exponent part # End of string , re.VERBOSE) # Check if the string matches the pattern return bool(pattern.match(s))"},{"question":"# Background Simulated annealing is a probabilistic technique for approximating the global optimum of a given function. It is often used in optimization problems where the search space is vast and contains many local optima. The method is inspired by annealing in metallurgy, a technique involving heating and controlled cooling of a material to increase the size of its crystals and reduce defects. # Problem Statement Write a function `simulated_annealing(opt_func: Callable[[float], float], initial_temp: float, cooling_rate: float, initial_state: float, iterations: int) -> float` that uses the simulated annealing algorithm to find an approximate minimum of a given unary function. # Input - `opt_func`: A callable function that takes a single float input and returns a float output. - `initial_temp`: A float representing the initial temperature. - `cooling_rate`: A float between 0 and 1 representing the rate at which the temperature decreases. - `initial_state`: A float representing the starting point in the solution space. - `iterations`: An integer representing the number of iterations for the algorithm to run. # Output - A float representing the approximate minimum value found by the simulated annealing algorithm. # Constraints - The cooling rate should be between 0 and 1. - The number of iterations should be a positive integer. - The function does not need to check if the cooling rate is set appropriately, assume it will be a valid number. # Example ```python import math def objective_function(x): return x**2 + math.sin(5*x) initial_temp = 1000 cooling_rate = 0.99 initial_state = 0 iterations = 100 result = simulated_annealing(objective_function, initial_temp, cooling_rate, initial_state, iterations) print(result) # Output should be the approximate minimum of the function ``` # Notes - Simulated annealing involves perturbing the current state and accepting a new state based on a probability that decreases with temperature. - Ensure to implement the acceptance criterion based on the Metropolis algorithm. - Use random perturbations within a reasonable range to explore the solution space. # Hints - The temperature should be gradually reduced according to the cooling rate after each iteration. - Accept new states that are better, or worse states with a probability decreasing exponentially with negative change and temperature.","solution":"import math import random def simulated_annealing(opt_func, initial_temp, cooling_rate, initial_state, iterations): Perform simulated annealing to find the approximate minimum of opt_func. Parameters: - opt_func: the function to minimize - initial_temp: initial temperature for the annealing process - cooling_rate: rate at which temperature decreases (between 0 and 1) - initial_state: starting point in the solution space - iterations: number of iterations to run the algorithm Returns: - The approximate minimum value found by the algorithm. current_temp = initial_temp current_state = initial_state current_value = opt_func(current_state) for i in range(iterations): # Generate a new candidate state new_state = current_state + random.uniform(-1, 1) new_value = opt_func(new_state) # Calculate the difference in objective delta_value = new_value - current_value # Check if we should accept the new state if delta_value < 0 or random.uniform(0, 1) < math.exp(-delta_value / current_temp): current_state = new_state current_value = new_value # Cool down the temperature current_temp *= cooling_rate return current_value"},{"question":"Matrix Coverage Check # Context You are working on a grid-based game where you need to manage different objects placed on an MxN grid. A common requirement is to check if all cells in the grid are covered by objects. Each object can be represented as a list of cells it covers. Your task is to implement a function that verifies if all cells in the grid are covered by given objects. # Task Implement a function `is_grid_fully_covered` that checks whether a grid is fully covered by a list of objects. This function should: 1. Take the dimensions of the grid as parameters. 2. Take a list of objects, where each object is represented by a list of cells it covers. 3. Provide a user-friendly message specifying which cells are not covered if the grid is not fully covered. 4. Return `True` if all cells are covered, otherwise return `False`. # Function Signature ```python def is_grid_fully_covered(rows: int, cols: int, objects: list) -> bool: pass ``` # Inputs and Outputs - **Input**: - `rows`: An integer specifying the number of rows in the grid. - `cols`: An integer specifying the number of columns in the grid. - `objects`: A list of lists, where each sublist represents an object and contains tuples as cells that the object covers. - **Output**: - A boolean indicating whether all cells in the grid are fully covered. # Constraints - The values of `rows` and `cols` will always be positive integers. - Each cell is represented as a tuple (row_index, col_index). - The function should handle cases where objects may cover some cells multiple times. # Example Usage ```python assert is_grid_fully_covered(3, 3, [[(0,0), (0,1)], [(0,2), (1,0), (2,2)], [(1,1), (1,2), (2,0), (2,1)]]) == True assert is_grid_fully_covered(2, 2, [[(0,0)], [(1,0), (1,1)], [(0,1)]]) == True assert is_grid_fully_covered(2, 2, [[(0,0)], [(1,0), (1,1)]]) == False assert is_grid_fully_covered(2, 2, [[(0,0), (0,1)], [(1,1)]]) == False ``` # Notes 1. You can assume that the tuples provided will always be within the bounds of the grid. 2. Ensure the function checks efficiently without redundancy, aiming for optimal performance. 3. The output message for uncovered cells should be descriptive and provide feedback on which cells are missing coverage.","solution":"def is_grid_fully_covered(rows: int, cols: int, objects: list) -> bool: # Set to keep track of all required cells required_cells = {(r, c) for r in range(rows) for c in range(cols)} # Iterate over all objects and remove their covered cells from required_cells for obj in objects: for cell in obj: if cell in required_cells: required_cells.remove(cell) if required_cells: # If there are any cells left in required_cells, print them print(f\\"Cells not covered: {required_cells}\\") return False return True"},{"question":"Pathfinding in a Two-Dimensional Grid # Scenario You are working on a navigation system for a robot that moves in a two-dimensional grid. The grid consists of `open` cells where the robot can move and `blocked` cells where the robot cannot move. The task is to find the shortest path from the top-left corner (cell `(0, 0)`) to the bottom-right corner (cell `(n-1, m-1)`). # Task Write a function `shortest_path` that: 1. Takes a 2D list `grid` representing the grid. 2. Returns the length of the shortest path from the top-left corner to the bottom-right corner, or `-1` if no path exists. # Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: ``` # Input - `grid` (List[List[int]]): A 2D grid of integers where `0` represents an open cell and `1` represents a blocked cell. The grid will be non-empty with dimensions `n x m`. # Output - Returns the length of the shortest path (int), or `-1` if no path exists. # Constraints - The dimensions of the grid (`n`, `m`) will be between `1` and `1000`. - Cells `(0, 0)` and `(n-1, m-1)` are always open (i.e., `grid[0][0] == 0` and `grid[n-1][m-1] == 0`). # Examples ```python # Example 1 grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] # The shortest path from (0, 0) to (4, 4) is \\"down, down, right, right, right, down, down\\". # So, the length of the shortest path is 7. assert shortest_path(grid) == 7 # Example 2 grid = [ [0, 1], [1, 0] ] # There is no path from (0, 0) to (1, 1) due to all intermediate cells being blocked. # Therefore, the result should be -1. assert shortest_path(grid) == -1 ``` # Note You should use an algorithm like Breadth-First Search (BFS), which is suitable for finding the shortest path in an unweighted grid such as this one.","solution":"from typing import List from collections import deque def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in a 2D grid from top-left corner to bottom-right corner. if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[n - 1][m - 1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n - 1 and col == m - 1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited: if grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"# Coding Assessment Question Context String manipulation and pattern matching are common tasks in many programming scenarios. Using knowledge of string operations, you will need to develop a function that removes all occurrences of a given substring within a main string. The Task Implement a function that takes in two strings: `main_string` and `substring`. The function should return a new string that is the result of removing all instances of `substring` from `main_string`. Input - A string `main_string` (1 ≤ len(main_string) ≤ 10^5). - A string `substring` (1 ≤ len(substring) ≤ 10^5). Output A string with all occurrences of `substring` removed from `main_string`. Performance Requirements - Your solution should be efficient in terms of both time and space complexity. # Implementation Guide 1. Implement the main function `remove_substring(main_string: str, substring: str) -> str` using efficient string manipulation techniques: - Handle edge cases where `substring` is longer than `main_string`. - Use string methods provided by the language for efficient operations. - Avoid manual iteration over the string where possible to ensure optimal performance. 2. Test your implementation with various inputs to ensure correctness. # Example Usage ```python def remove_substring(main_string: str, substring: str) -> str: # Your code here # Example usage: print(remove_substring(\\"abcdefabcghi\\", \\"abc\\")) # Output: \\"defghi\\" print(remove_substring(\\"aaaaa\\", \\"a\\")) # Output: \\"\\" print(remove_substring(\\"hello world\\", \\" \\")) # Output: \\"helloworld\\" ```","solution":"def remove_substring(main_string: str, substring: str) -> str: Removes all occurrences of substring from main_string. Parameters: main_string (str): The main string from which to remove the substring. substring (str): The substring to be removed from the main string. Returns: str: The result string with all occurrences of substring removed from main_string. if not substring: return main_string return main_string.replace(substring, \\"\\")"},{"question":"# Binary Search Tree Balancing You are given a Binary Search Tree (BST) implementation with basic insert and find operations. Your task is to enhance the BST by adding the functionality to balance the tree. 1. **Tree Balancing**: Add a method that balances the BST by converting it into a Balanced Binary Search Tree (AVL Tree). Function Specifications 1. **balance(self)**: - Balances the BST to make it height-balanced, following the AVL tree properties. - Re-balancing should be optimized to ensure minimal tree rotations. Input and Output 1. **insert(self, value: int)**: - Inserts a value into the BST. - Maintains the properties of a Binary Search Tree. 2. **find(self, value: int) -> bool**: - Checks if a value exists in the tree, returning `True` if it does and `False` otherwise. 3. **balance(self)**: - Balances the BST and adjusts the tree to ensure it follows AVL properties after insertions. - No return value. Example ```python class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class BST: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return BSTNode(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def find(self, value): return self._find(self.root, value) def _find(self, node, value): if not node: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def balance(self): self.root = self._balance(self.root) def _balance(self, node): if not node: return None if self._get_balance(node) > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if self._get_balance(node) < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) node.left = self._balance(node.left) node.right = self._balance(node.right) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y # Example Usage: bst = BST() bst.insert(10) bst.insert(20) bst.insert(30) bst.insert(40) bst.insert(50) bst.insert(25) bst.balance() assert bst.find(25) == True assert bst.find(60) == False ``` Constraints - All values are unique integers. - Total number of nodes in the BST will not exceed 10^4. - Values are in the range -10^4 to 10^4. - Assume the Binary Search Tree is correctly implemented up to its current functionality. **Note**: Do not change the existing methods\' signatures in the provided `BST` class. Only add new methods or helper functions as required.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class BST: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return BSTNode(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def find(self, value): return self._find(self.root, value) def _find(self, node, value): if not node: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def balance(self): self.root = self._balance_tree() def _balance_tree(self): nodes = [] self._in_order_traversal(self.root, nodes) return self._sorted_array_to_bst(nodes, 0, len(nodes) - 1) def _in_order_traversal(self, node, nodes): if not node: return self._in_order_traversal(node.left, nodes) nodes.append(node.value) self._in_order_traversal(node.right, nodes) def _sorted_array_to_bst(self, arr, start, end): if start > end: return None mid = (start + end) // 2 node = BSTNode(arr[mid]) node.left = self._sorted_array_to_bst(arr, start, mid - 1) node.right = self._sorted_array_to_bst(arr, mid + 1, end) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def _get_height(self, node): if not node: return 0 return node.height"},{"question":"# Problem Statement You are given a string containing only the characters \'(\' and \')\'. Your task is to determine the minimum number of insertions, deletions, or replacements needed to make the string valid. A string is valid if every opening parenthesis \'(\' has a corresponding closing parenthesis \')\'. # Function Signature ```python def min_operations_to_make_valid(s: str) -> int: pass ``` # Input * `s`: A string of length `n` (`1 <= n <= 10^5`) containing only \'(\' and \')\'. # Output * Return an integer representing the minimum number of operations needed to make the string valid. # Constraints 1. The function should have a time complexity of O(n). 2. The algorithm should work in a single traversal of the string. # Example ```python assert min_operations_to_make_valid(\\"(()\\") == 1 assert min_operations_to_make_valid(\\"())\\") == 1 assert min_operations_to_make_valid(\\"))((\\") == 4 assert min_operations_to_make_valid(\\"()\\") == 0 ``` # Description 1. Traverse through the string and maintain a balance counter. 2. Increment the counter for every opening parenthesis \'(\' and decrement it for every closing parenthesis \')\'. 3. If the counter goes negative, it means there are unmatched closing parentheses, and we need to increment the count of required operations. 4. At the end of traversal, the balance counter will indicate the number of unmatched opening parentheses. 5. Sum up the necessary operations to balance both opening and closing parentheses.","solution":"def min_operations_to_make_valid(s: str) -> int: balance = 0 operations = 0 for char in s: if char == \'(\': balance += 1 else: # char == \')\' if balance > 0: balance -= 1 else: operations += 1 operations += balance return operations"},{"question":"# Playlist Duration Calculation Objective: Write a Python function to calculate the total duration of a playlist given a list of songs, where each song\'s duration is specified. Problem Description: You need to create a function `calculate_playlist_duration(playlist: list[dict]) -> str` that takes a list of dictionaries representing a playlist of songs and returns the total duration of the playlist in the format `HH:MM:SS`. Each dictionary contains the name and duration of a song in the format `MM:SS` or `HH:MM:SS`. Input: - `playlist`: a list of dictionaries where each dictionary has: - `name`: a string representing the name of the song. - `duration`: a string representing the duration of the song in `MM:SS` or `HH:MM:SS` format. Output: - A string representing the total duration of the playlist in `HH:MM:SS` format. Constraints: - The playlist can have any number of songs. - Each song duration will be formatted correctly and will be within reasonable length (e.g., less than 24 hours each). - The function should handle edge cases, such as an empty playlist. Requirements: 1. Parse each song\'s duration and convert it to seconds for summing. 2. Convert the total duration back to the `HH:MM:SS` format. 3. Handle the `MM:SS` and `HH:MM:SS` formats appropriately. 4. Ensure the function returns a consistent and correct format even for edge cases (e.g., 0 seconds). Example Usage: ```python playlist = [ {\\"name\\": \\"Song A\\", \\"duration\\": \\"03:45\\"}, {\\"name\\": \\"Song B\\", \\"duration\\": \\"01:15:30\\"}, {\\"name\\": \\"Song C\\", \\"duration\\": \\"05:25\\"} ] total_duration = calculate_playlist_duration(playlist) print(total_duration) # Output: \\"01:24:40\\" ``` Implementation Strategy: 1. Initialize a total duration counter in seconds. 2. Iterate through the playlist and convert each song\'s duration to seconds. 3. Sum the durations in seconds. 4. Convert the total duration in seconds back to the `HH:MM:SS` format. 5. Return the formatted total duration. ```python def calculate_playlist_duration(playlist: list[dict]) -> str: Calculate the total playlist duration in HH:MM:SS format. :param playlist: List of dictionaries with song name and duration. :return: Total duration of the playlist in HH:MM:SS format. total_seconds = 0 for song in playlist: duration = song[\'duration\'] parts = duration.split(\':\') if len(parts) == 2: # MM:SS minutes, seconds = map(int, parts) total_seconds += minutes * 60 + seconds elif len(parts) == 3: # HH:MM:SS hours, minutes, seconds = map(int, parts) total_seconds += hours * 3600 + minutes * 60 + seconds hours = total_seconds // 3600 remainder = total_seconds % 3600 minutes = remainder // 60 seconds = remainder % 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\" # Example usage playlist = [ {\\"name\\": \\"Song A\\", \\"duration\\": \\"03:45\\"}, {\\"name\\": \\"Song B\\", \\"duration\\": \\"01:15:30\\"}, {\\"name\\": \\"Song C\\", \\"duration\\": \\"05:25\\"} ] total_duration = calculate_playlist_duration(playlist) print(total_duration) # Output: \\"01:24:40\\" ``` Implement the function and include appropriate error handling, performance optimizations, and detailed comments/documentation.","solution":"def calculate_playlist_duration(playlist: list[dict]) -> str: Calculate the total playlist duration in HH:MM:SS format. :param playlist: List of dictionaries with song name and duration. :return: Total duration of the playlist in HH:MM:SS format. total_seconds = 0 for song in playlist: duration = song[\'duration\'] parts = duration.split(\':\') if len(parts) == 2: # MM:SS minutes, seconds = map(int, parts) total_seconds += minutes * 60 + seconds elif len(parts) == 3: # HH:MM:SS hours, minutes, seconds = map(int, parts) total_seconds += hours * 3600 + minutes * 60 + seconds hours = total_seconds // 3600 remainder = total_seconds % 3600 minutes = remainder // 60 seconds = remainder % 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\""},{"question":"# Coding Assessment Question: Implementation of Randomized Controlled Permutation Test Objective Demonstrate an understanding of statistical hypothesis testing by implementing a function to conduct a Randomized Controlled Permutation Test. Task Description Given two lists of numerical data representing the outcomes of two different groups, implement a function that performs a Randomized Controlled Permutation Test to evaluate whether the difference in means between the two groups is statistically significant. Function Signature ```python def permutation_test(group1: list[float], group2: list[float], num_permutations: int = 10000) -> float: Perform a Randomized Controlled Permutation Test to determine the p-value of the difference in means between the two groups. Input ===== - group1: A list of floats representing the outcomes of the first group. - group2: A list of floats representing the outcomes of the second group. - num_permutations: The number of permutations to perform for the test. Output ====== - p_value: The p-value resulting from the permutation test. ``` Input and Output - **Input**: - group1: A list of floats representing the outcomes of the first group. - group2: A list of floats representing the outcomes of the second group. - num_permutations: An integer representing the number of permutations to perform. - **Output**: - p_value: Float, the p-value resulting from the permutation test. Constraints - Both group1 and group2 will have lengths between 5 and 1000. - All elements in both group1 and group2 will be real numbers. - num_permutations will be a positive integer, typically large (e.g., 10000). Performance Requirements - The algorithm should run efficiently for the given constraints. Example ```python group1 = [22.1, 19.8, 21.5, 24.3, 23.1] group2 = [17.2, 18.5, 19.3, 16.8, 20.5] num_permutations = 10000 # Expected p_value: Should be calculated based on the permutation test result for the means of group1 and group2. p_value = permutation_test(group1, group2, num_permutations) print(f\\"P-value: {p_value}\\") ``` Ensure that the function employs an efficient method to compute the test.","solution":"import numpy as np def permutation_test(group1: list[float], group2: list[float], num_permutations: int = 10000) -> float: Perform a Randomized Controlled Permutation Test to determine the p-value of the difference in means between the two groups. Input ===== - group1: A list of floats representing the outcomes of the first group. - group2: A list of floats representing the outcomes of the second group. - num_permutations: The number of permutations to perform for the test. Output ====== - p_value: The p-value resulting from the permutation test. combined = np.array(group1 + group2) size_group1 = len(group1) observed_diff = np.mean(group1) - np.mean(group2) count_extreme = 0 for _ in range(num_permutations): np.random.shuffle(combined) new_group1 = combined[:size_group1] new_group2 = combined[size_group1:] new_diff = np.mean(new_group1) - np.mean(new_group2) if abs(new_diff) >= abs(observed_diff): count_extreme += 1 p_value = count_extreme / num_permutations return p_value"},{"question":"# Coding Question In this problem, you will implement a matrix multiplication algorithm that leverages the Strassen algorithm for efficient computation. This algorithm reduces the complexity compared to the standard matrix multiplication method. # Problem Statement Write a Python function `strassen_matrix_multiplication` that takes two square matrices as input and returns their product using Strassen\'s algorithm. # Function Signature ```python def strassen_matrix_multiplication(A, B): Perform matrix multiplication using Strassen\'s algorithm. Arguments: A -- First matrix (a list of lists, where each list represents a row). B -- Second matrix (a list of lists, where each list represents a row). Returns: A list of lists representing the product matrix. pass ``` # Input & Output * **Input**: - `A`: A square matrix of size ( 2^n times 2^n ), represented as a list of lists. - `B`: A square matrix of size ( 2^n times 2^n ), represented as a list of lists. * **Output**: - A square matrix of size ( 2^n times 2^n ), represented as a list of lists, which is the product of `A` and `B`. # Constraints - The size of the matrices will always be ( 2^n times 2^n ) for some integer ( n geq 1 ). - You should implement the Strassen\'s algorithm without explicitly reducing to the standard matrix multiplication for small sizes. # Helper Function (optional) You may find it useful to implement helper functions to perform tasks such as splitting the matrix into submatrices, adding and subtracting matrices, and recombining submatrices. # Example Given the matrices [A = begin{bmatrix} 1 & 2 3 & 4 end{bmatrix}] and [B = begin{bmatrix} 5 & 6 7 & 8 end{bmatrix}], the product matrix is [C = begin{bmatrix} 19 & 22 43 & 50 end{bmatrix}]. ```python A = [[1, 2], [3, 4]] B = [[5, 6], [7, 8]] C = strassen_matrix_multiplication(A, B) print(C) # Expected output: [[19, 22], [43, 50]] ``` # Notes - Ensure efficient computation to handle larger matrices (e.g., (n = 10) which results in (1024 times 1024) matrices) in reasonable time. - Consider edge cases such as handling matrices filled with zeros.","solution":"def add_matrix(A, B): size = len(A) return [[A[i][j] + B[i][j] for j in range(size)] for i in range(size)] def subtract_matrix(A, B): size = len(A) return [[A[i][j] - B[i][j] for j in range(size)] for i in range(size)] def split_matrix(M): n = len(M) mid = n // 2 A = [[M[i][j] for j in range(mid)] for i in range(mid)] B = [[M[i][j] for j in range(mid, n)] for i in range(mid)] C = [[M[i][j] for j in range(mid)] for i in range(mid, n)] D = [[M[i][j] for j in range(mid, n)] for i in range(mid, n)] return A, B, C, D def combine_matrix(A, B, C, D): top = [A[i] + B[i] for i in range(len(A))] bottom = [C[i] + D[i] for i in range(len(C))] return top + bottom def strassen_matrix_multiplication(A, B): n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) P1 = strassen_matrix_multiplication(add_matrix(A11, A22), add_matrix(B11, B22)) P2 = strassen_matrix_multiplication(add_matrix(A21, A22), B11) P3 = strassen_matrix_multiplication(A11, subtract_matrix(B12, B22)) P4 = strassen_matrix_multiplication(A22, subtract_matrix(B21, B11)) P5 = strassen_matrix_multiplication(add_matrix(A11, A12), B22) P6 = strassen_matrix_multiplication(subtract_matrix(A21, A11), add_matrix(B11, B12)) P7 = strassen_matrix_multiplication(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(P1, P4), P5), P7) C12 = add_matrix(P3, P5) C21 = add_matrix(P2, P4) C22 = add_matrix(subtract_matrix(add_matrix(P1, P3), P2), P6) return combine_matrix(C11, C12, C21, C22)"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},O={class:"card-container"},R={key:0,class:"empty-state"},N=["disabled"],z={key:0},P={key:1};function Y(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,N)):u("",!0)])}const D=c(F,[["render",Y],["__scopeId","data-v-9a67bb17"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/45.md","filePath":"quotes/45.md"}'),M={name:"quotes/45.md"},U=Object.assign(M,{setup(r){return(e,l)=>(n(),i("div",null,[x(D)]))}});export{B as __pageData,U as default};
