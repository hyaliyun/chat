import{_ as d,o as s,c as n,a as t,m as _,t as l,C as h,M as g,U as b,f as m,F as x,p as y,e as v,q}from"./chunks/framework.B1z0IdBH.js";const w={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function j(i,e,u,c,r,a){return s(),n("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(l(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(l(u.poem.solution),1)])])])}const E=d(w,[["render",j],["__scopeId","data-v-949c00dd"]]),R=JSON.parse(`[{"question":"def max_tasks(n: int, k: int, a: List[int]) -> int: Determines the maximum number of tasks that can be completed within a total time of k. Parameters: n (int): Number of tasks. k (int): Total time available. a (list of int): List of times each task takes. Returns: int: The maximum number of tasks that can be completed within the total time k. >>> max_tasks(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_tasks(5, 1, [2, 3, 4, 5, 6]) 0 >>> max_tasks(3, 10, [1, 2, 3]) 3 >>> max_tasks(1, 1, [1]) 1 >>> max_tasks(1, 0, [1]) 0 >>> max_tasks(1, 1, [2]) 0 >>> max_tasks(4, 1000000000, [100000000, 200000000, 300000000, 400000000]) 4 >>> max_tasks(6, 7, [2, 3, 3, 2, 1, 1]) 4","solution":"def max_tasks(n, k, a): Determines the maximum number of tasks that can be completed within a total time of k. Parameters: n (int): Number of tasks. k (int): Total time available. a (list of int): List of times each task takes. Returns: int: The maximum number of tasks that can be completed within the total time k. # Sort the tasks by their time requirements (ascending order) a.sort() time_spent = 0 tasks_completed = 0 # Iterate through the sorted times for time in a: if time_spent + time <= k: time_spent += time tasks_completed += 1 else: break return tasks_completed"},{"question":"def longest_same_parity_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the largest contiguous subarray where all elements have the same parity. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n and a list of integers. Returns: List[int]: A list of integers, each integer representing the length of the largest contiguous subarray of the same parity for each test case. Example: >>> longest_same_parity_subarray(2, [(7, [1, 2, 2, 2, 3, 4, 4]), (6, [5, 5, 5, 5, 5, 5])]) [3, 6] >>> longest_same_parity_subarray(1, [(5, [2, 2, 2, 2, 2])]) [5] >>> longest_same_parity_subarray(1, [(5, [1, 2, 3, 4, 5])]) [1] from solution import longest_same_parity_subarray def test_single_test_case(): t = 1 test_cases = [(7, [1, 2, 2, 2, 3, 4, 4])] assert longest_same_parity_subarray(t, test_cases) == [3] def test_multiple_test_cases(): t = 2 test_cases = [ (7, [1, 2, 2, 2, 3, 4, 4]), (6, [5, 5, 5, 5, 5, 5]) ] assert longest_same_parity_subarray(t, test_cases) == [3, 6] def test_all_same_parity(): t = 1 test_cases = [(5, [2, 2, 2, 2, 2])] assert longest_same_parity_subarray(t, test_cases) == [5] def test_no_repeats(): t = 1 test_cases = [(5, [1, 2, 3, 4, 5])] assert longest_same_parity_subarray(t, test_cases) == [1] def test_alternating_parity(): t = 1 test_cases = [(8, [1, 2, 1, 2, 1, 2, 1, 2])] assert longest_same_parity_subarray(t, test_cases) == [1] def test_single_element(): t = 1 test_cases = [(1, [7])] assert longest_same_parity_subarray(t, test_cases) == [1]","solution":"def longest_same_parity_subarray(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] max_length = 1 current_length = 1 for j in range(1, n): if arr[j] % 2 == arr[j - 1] % 2: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results"},{"question":"def min_total_cost(n: int, m: int, roads: List[Tuple[int, int, int, int]]) -> int: Find the minimum total installation cost to ensure all intersections are illuminated. Args: n: int - number of intersections m: int - number of roads roads: list of tuples - each tuple contains (u, v, l, c) Returns: int - minimum total cost to ensure all intersections are illuminated >>> min_total_cost(4, 5, [(0, 1, 10, 5), (0, 2, 6, 2), (0, 3, 5, 1), (1, 3, 15, 10), (2, 3, 4, 3)]) 8 >>> min_total_cost(2, 1, [(0, 1, 10, 1)]) 1 >>> min_total_cost(2, 2, [(0, 1, 10, 5), (0, 1, 15, 3)]) 3 >>> min_total_cost(1, 0, []) 0 >>> min_total_cost(3, 1, [(0, 1, 10, 4)]) 4 >>> min_total_cost(4, 5, [(0, 1, 1, 3), (1, 2, 2, 2), (2, 3, 3, 1), (0, 3, 4, 4), (1, 3, 10, 2)]) 6","solution":"def min_total_cost(n, m, roads): Find the minimum total installation cost to ensure all intersections are illuminated. Args: n: int - number of intersections m: int - number of roads roads: list of tuples - each tuple contains (u, v, l, c) Returns: int - minimum total cost to ensure all intersections are illuminated import heapq # Create adjacency list for the graph adj = [[] for _ in range(n)] for u, v, l, c in roads: adj[u].append((c, v)) adj[v].append((c, u)) # Use a min-heap to build our MST using Prim's algorithm min_heap = [(0, 0)] # (cost, node) visited = [False] * n total_cost = 0 while min_heap: cost, node = heapq.heappop(min_heap) if visited[node]: continue visited[node] = True total_cost += cost for edge_cost, neighbor in adj[node]: if not visited[neighbor]: heapq.heappush(min_heap, (edge_cost, neighbor)) return total_cost"},{"question":"def generate_sequence(n: int) -> list: Generate a sequence of length n such that for every integer k from 1 to n, there are exactly k numbers in the sequence that are divisible by k. Parameters: n (int): The length of the sequence. Returns: list: A sequence of integers of length n that satisfies the condition, or returns -1 if no such sequence exists. >>> generate_sequence(1) [1] >>> generate_sequence(2) [1, 2] >>> generate_sequence(3) [1, 2, 3] >>> generate_sequence(4) [1, 2, 3, 4] # Your code here","solution":"def generate_sequence(n): Generate a sequence of length n such that for every integer k from 1 to n, there are exactly k numbers in the sequence that are divisible by k. Parameters: n (int): The length of the sequence. Returns: list: A sequence of integers of length n that satisfies the condition, or returns -1 if no such sequence exists. if n == 1: return [1] sequence = [i for i in range(1, n + 1)] return sequence"},{"question":"def card_game_turns(n: int) -> int: Determine the total number of turns the game must continue until all players have received their initial cards back. >>> card_game_turns(1) 1 >>> card_game_turns(2) 2 >>> card_game_turns(5) 5 >>> card_game_turns(100000) 100000 >>> card_game_turns(1) 1","solution":"def card_game_turns(n: int) -> int: Returns the total number of turns until all players have received their initial cards back. return n"},{"question":"def is_love_sequence_possible(arr): Determines if the array can be rearranged to form a Love Sequence, i.e., with exactly one inversion. >>> is_love_sequence_possible([1, 3, 4, 2, 5]) == \\"YES\\" >>> is_love_sequence_possible([5, 3, 2, 4, 1]) == \\"YES\\" >>> is_love_sequence_possible([1, 2, 3, 4, 5]) == \\"YES\\" >>> is_love_sequence_possible([5, 4, 3, 2, 1]) == \\"YES\\" >>> is_love_sequence_possible([1, 3, 2]) == \\"YES\\" >>> is_love_sequence_possible([4, 3, 2, 1]) == \\"YES\\" >>> is_love_sequence_possible([1, 2]) == \\"YES\\" >>> is_love_sequence_possible([1]) == \\"NO\\" >>> is_love_sequence_possible([3, 2, 1]) == \\"YES\\" >>> is_love_sequence_possible([2, 1]) == \\"YES\\" >>> is_love_sequence_possible([2, 3, 4, 5, 1]) == \\"YES\\" >>> is_love_sequence_possible([1, 4, 5, 3, 2]) == \\"YES\\" >>> is_love_sequence_possible([10, 20, 30, 5]) == \\"YES\\"","solution":"def is_love_sequence_possible(arr): Determines if the array can be rearranged to form a Love Sequence, i.e., with exactly one inversion. n = len(arr) if n < 2: return \\"NO\\" arr.sort() # Now the sorted array has no inversions # If we swap the last two elements, we will have exactly one inversion arr[-1], arr[-2] = arr[-2], arr[-1] # Count the number of inversions to verify. inversions = 0 for i in range(n): for j in range(i+1, n): if arr[i] > arr[j]: inversions += 1 if inversions == 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def largest_square_subgrid(h: int, w: int, grid: List[str]) -> int: Returns the area of the largest square sub-grid that contains only 1's. Parameters: h (int): The number of rows in the grid. w (int): The number of columns in the grid. grid (List[str]): The grid containing '0's and '1's. Returns: int: The area of the largest square sub-grid containing only '1's. Examples: >>> largest_square_subgrid(4, 5, [\\"10111\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 9 >>> largest_square_subgrid(1, 5, [\\"11111\\"]) 1 >>> largest_square_subgrid(5, 1, [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"]) 1 >>> largest_square_subgrid(4, 4, [\\"0000\\", \\"0000\\", \\"0000\\", \\"0000\\"]) 0 >>> largest_square_subgrid(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 9 >>> largest_square_subgrid(3, 3, [\\"101\\", \\"111\\", \\"101\\"]) 1 >>> largest_square_subgrid(5, 4, [\\"1100\\", \\"1100\\", \\"0111\\", \\"0011\\", \\"0000\\"]) 4","solution":"def largest_square_subgrid(h, w, grid): Returns the area of the largest square sub-grid that contains only 1's. if h == 0 or w == 0: return 0 dp = [[0] * w for _ in range(h)] max_side = 0 for i in range(h): for j in range(w): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def count_distinct_days_with_checkouts(log: List[str]) -> int: Counts the number of distinct days on which at least one book was checked out. Args: log (list of str): The log of book operations. Returns: int: The number of distinct days with at least one checkout operation. from typing import List def test_example_case(): log = [ \\"2023-01-05OUT: Book A\\", \\"2023-01-06IN: Book B\\", \\"2023-01-05IN: Book A\\", \\"2023-01-07OUT: Book C\\", \\"2023-01-07OUT: Book D\\", \\"2023-01-08IN: Book E\\", \\"2023-01-05OUT: Book F\\" ] assert count_distinct_days_with_checkouts(log) == 2 def test_all_checkouts_in_one_day(): log = [ \\"2023-01-05OUT: Book A\\", \\"2023-01-05OUT: Book B\\", \\"2023-01-05OUT: Book C\\" ] assert count_distinct_days_with_checkouts(log) == 1 def test_all_checkins(): log = [ \\"2023-01-05IN: Book A\\", \\"2023-01-06IN: Book B\\", \\"2023-01-07IN: Book C\\" ] assert count_distinct_days_with_checkouts(log) == 0 def test_mixed_operations(): log = [ \\"2023-01-05OUT: Book A\\", \\"2023-01-06IN: Book B\\", \\"2023-01-07OUT: Book C\\", \\"2023-01-08OUT: Book D\\", \\"2023-01-09IN: Book E\\", \\"2023-01-10OUT: Book F\\", \\"2023-01-11IN: Book G\\" ] assert count_distinct_days_with_checkouts(log) == 4 def test_no_operations(): log = [] assert count_distinct_days_with_checkouts(log) == 0 def test_single_operation_out(): log = [\\"2023-01-05OUT: Book A\\"] assert count_distinct_days_with_checkouts(log) == 1 def test_single_operation_in(): log = [\\"2023-01-05IN: Book A\\"] assert count_distinct_days_with_checkouts(log) == 0","solution":"def count_distinct_days_with_checkouts(log): Counts the number of distinct days on which at least one book was checked out. Args: log (list of str): The log of book operations. Returns: int: The number of distinct days with at least one checkout operation. checkout_days = set() for record in log: date, operation_info = record[:10], record[10:] if \\"OUT\\" in operation_info: checkout_days.add(date) return len(checkout_days)"},{"question":"def farthest_house(n, coordinates): Finds the coordinates of the house that is farthest from the origin based on the Manhattan distance. Args: n: int - The number of houses. coordinates: list of tuples - A list containing the coordinates of the houses. Returns: tuple - The coordinates of the house that is farthest from the origin. Example: >>> farthest_house(5, [(1, 2), (3, 4), (-5, -6), (7, 8), (-9, 10)]) (-9, 10) >>> farthest_house(1, [(1000000, 1000000)]) (1000000, 1000000)","solution":"def farthest_house(n, coordinates): Finds the coordinates of the house that is farthest from the origin based on the Manhattan distance. Args: n: int - The number of houses. coordinates: list of tuples - A list containing the coordinates of the houses. Returns: tuple - The coordinates of the house that is farthest from the origin. max_distance = -1 farthest_house_coords = (0, 0) for coord in coordinates: x, y = coord distance = abs(x) + abs(y) if distance > max_distance: max_distance = distance farthest_house_coords = (x, y) return farthest_house_coords"},{"question":"from typing import List, Tuple def min_steps_to_target(N: int, M: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Calculate the minimum number of steps to reach the target position from the starting position in a grid. >>> min_steps_to_target( ... 4, 4, ... [\\"....\\", \\"..\\", \\"..#.\\", \\"..\\"], ... (1, 1), ... (3, 4) ... ) 5 >>> min_steps_to_target( ... 3, 3, ... [\\"#\\", \\"#.#\\", \\"#\\"], ... (2, 2), ... (3, 2) ... ) -1 >>> min_steps_to_target( ... 3, 3, ... [\\"...\\", \\"...\\", \\"...\\"], ... (1, 1), ... (1, 1) ... ) 0 >>> min_steps_to_target( ... 2, 2, ... [\\"..\\", \\"..\\"], ... (1, 1), ... (2, 2) ... ) 2 >>> min_steps_to_target( ... 5, 5, ... [\\".....\\", \\"..#..\\", \\".....\\", \\"..#..\\", \\".....\\"], ... (1, 1), ... (5, 5) ... ) 8","solution":"from collections import deque def min_steps_to_target(N, M, grid, start, target): x_s, y_s = start x_t, y_t = target # Directions for moving up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Convert to 0-indexed for easier array handling x_s -= 1 y_s -= 1 x_t -= 1 y_t -= 1 # Edge case if start and target are same if (x_s, y_s) == (x_t, y_t): return 0 # Initialize visited matrix visited = [[False] * M for _ in range(N)] queue = deque([(x_s, y_s, 0)]) # (x, y, steps) visited[x_s][y_s] = True while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': if (nx, ny) == (x_t, y_t): return steps + 1 queue.append((nx, ny, steps + 1)) visited[nx][ny] = True return -1 # If no path is found # Example usage if __name__ == \\"__main__\\": N, M = 4, 4 grid = [ \\"....\\", \\"..\\", \\"..#.\\", \\"..\\" ] start = (1, 1) target = (3, 4) print(min_steps_to_target(N, M, grid, start, target)) # Output should be 5"},{"question":"def min_operations(s1: str, s2: str) -> int: Determine the minimum number of operations needed to transform s1 into s2. Given two strings s1 and s2 of the same length n, transform s1 into s2 using the fewest number of operations. In one operation, you can take any character in s1 that is different from the corresponding character in s2 and change it to the corresponding character in s2. Input: s1 and s2, each of length n (1 ≤ n ≤ 1000) Output: The minimum number of operations required to transform s1 into s2. Examples: >>> min_operations(\\"abcde\\", \\"abfgh\\") 3 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"abc\\", \\"abx\\") 1 >>> min_operations(\\"abc\\", \\"xyz\\") 3 >>> min_operations(\\"a\\" * 1000, \\"b\\" * 1000) 1000","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. operations = 0 for i in range(len(s1)): if s1[i] != s2[i]: operations += 1 return operations"},{"question":"def count_valleys(terrain): Returns the number of valleys in the given terrain. A valley is a sequence of consecutive heights that strictly decreases to a minimum point and then strictly increases. >>> count_valleys([5, 3, 1, 2, 4]) == 1 >>> count_valleys([1, 2, 3, 4, 5]) == 0 >>> count_valleys([5, 4, 1, 2, 3, 4, 1, 3]) == 2 >>> count_valleys([5, 4, 3, 2, 1]) == 0 >>> count_valleys([1, 2, 3, 4, 5]) == 0 >>> count_valleys([5, 3, 1, 4, 6, 3, 1, 4]) == 2 >>> count_valleys([6, 5, 4, 3, 2, 1, 2, 2]) == 1","solution":"def count_valleys(terrain): Returns the number of valleys in the given terrain. A valley is a sequence of consecutive heights that strictly decreases to a minimum point and then strictly increases. n = len(terrain) if n < 3: return 0 valleys = 0 i = 1 while i < n - 1: if terrain[i - 1] > terrain[i] < terrain[i + 1]: left = i - 1 while left > 0 and terrain[left] > terrain[left - 1]: left -= 1 right = i + 1 while right < n - 1 and terrain[right] > terrain[right + 1]: right += 1 valleys += 1 i = right # skip to the end of the current valley else: i += 1 return valleys"},{"question":"def min_rounds_to_execute_threads(n: int, t: int, a: List[int]) -> int: Determines the minimum number of rounds required to execute all threads within the given threshold time t. Parameters: n (int): The number of threads. t (int): The threshold time. a (list): List of execution times of the threads. Returns: int: The minimum number of rounds. Examples: >>> min_rounds_to_execute_threads(5, 10, [2, 3, 7, 4, 8]) 1 >>> min_rounds_to_execute_threads(6, 5, [11, 2, 8, 3, 1, 7]) 3","solution":"from math import ceil def min_rounds_to_execute_threads(n, t, a): Determines the minimum number of rounds required to execute all threads within the given threshold time t. Parameters: n (int): The number of threads. t (int): The threshold time. a (list): List of execution times of the threads. Returns: int: The minimum number of rounds. a.sort() rounds = ceil(a[-1] / t) return rounds"},{"question":"def find_unique_element(arr): Finds the element that occurs only once in the array. Parameters: arr (list): List of integers where each element occurs twice except one that occurs once. Returns: int: The element that occurs only once. Examples: >>> find_unique_element([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_element([1, 2, 3, 2, 1]) 3","solution":"def find_unique_element(arr): Finds the element that occurs only once in the array. Parameters: arr (list): List of integers where each element occurs twice except one that occurs once. Returns: int: The element that occurs only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element # Example run: # print(find_unique_element([4, 3, 2, 4, 1, 3, 2])) # Output: 1"},{"question":"def largest_square(grid: List[List[str]]) -> int: Determine the size of the largest square sub-grid that can fit entirely into the given grid without overlapping any walls. Args: grid (List[List[str]]): A 2D list representing the grid, where each cell is either a wall ('#') or an empty space ('.'). Returns: int: The size of the largest square sub-grid that contains only empty spaces ('.'). Example: >>> grid1 = [ ... ['.', '.', '#', '.', '.'], ... ['.', '.', '.', '.', '.'], ... ['#', '.', '#', '.', '.'], ... ['.', '.', '.', '#', '.'] ... ] >>> largest_square(grid1) 2 >>> grid2 = [ ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#'] ... ] >>> largest_square(grid2) 0","solution":"def largest_square(grid): n = len(grid) m = len(grid[0]) if not grid: return 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List from itertools import permutations def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def can_form_prime(digit_string: str) -> str: Determine if any permutation of the digit string can form a prime number. >>> can_form_prime('197') 'YES' >>> can_form_prime('123') 'NO' >>> can_form_prime('37') 'YES' def solve(T: int, digit_strings: List[str]) -> List[str]: Process multiple test cases and determine if permutations can form a prime number. >>> solve(3, ['197', '123', '37']) ['YES', 'NO', 'YES'] def process_input_output(input_data: str): Process input and output for the given test cases. >>> process_input_output('3n197n123n37n') YES NO YES","solution":"from itertools import permutations def is_prime(num): This function checks if a given number is a prime. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def can_form_prime(digit_string): This function checks if any permutation of the digit string can form a prime number. for perm in permutations(digit_string): num = int(''.join(perm)) if is_prime(num): return \\"YES\\" return \\"NO\\" def solve(T, digit_strings): This function processes multiple test cases. results = [] for s in digit_strings: results.append(can_form_prime(s)) return results def process_input_output(input_data): This function processes the input and output based on the given specification. lines = input_data.split('n') T = int(lines[0]) digit_strings = lines[1:T + 1] results = solve(T, digit_strings) for result in results: print(result)"},{"question":"def can_escape_maze(n: int, m: int, maze: List[List[str]]) -> str: Determine if it is possible to escape the maze from the top-left to the bottom-right >>> can_escape_maze(4, 4, [['.', '.', '.', '.'], ['#', '#', '.', '#'], ['.', '.', '.', '.'], ['.', '.', '#', '.']]) \\"YES\\" >>> can_escape_maze(3, 3, [['.', '#', '#'], ['.', '#', '.'], ['#', '#', '.']]) \\"NO\\"","solution":"def can_escape_maze(n, m, maze): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' def dfs(x, y): if not is_valid(x, y): return False if x == n - 1 and y == m - 1: return True maze[x][y] = '#' for dx, dy in directions: if dfs(x + dx, y + dy): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def min_days_to_inspect(n: int, lampposts: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determines the minimum number of days required to fully inspect all lampposts in the range of streets from l to r, inclusive. :param n: int, number of streets :param lampposts: list of int, number of lampposts on each street :param queries: list of tuples, each containing two integers l and r representing a query :return: list of int, minimum number of days required for each query >>> min_days_to_inspect(5, [2, 3, 1, 7, 4], [(1, 3), (2, 5), (1, 5)]) [3, 4, 5] >>> min_days_to_inspect(3, [1, 1, 1], [(1, 1), (2, 3), (1, 3)]) [1, 2, 3] >>> min_days_to_inspect(4, [4, 5, 6, 7], [(1, 4), (1, 2), (3, 4)]) [4, 2, 2] >>> min_days_to_inspect(6, [3, 3, 3, 3, 3, 3], [(1, 6), (2, 3), (4, 6)]) [6, 2, 3]","solution":"def min_days_to_inspect(n, lampposts, queries): Determines the minimum number of days required to fully inspect all lampposts in the range of streets from l to r, inclusive. :param n: int, number of streets :param lampposts: list of int, number of lampposts on each street :param queries: list of tuples, each containing two integers l and r representing a query :return: list of int, minimum number of days required for each query results = [] for l, r in queries: results.append(r - l + 1) return results"},{"question":"def max_score_difference(n: int, scores: List[int]) -> int: Returns the maximum difference between any two contestant scores. Parameters: n (int): Number of contestants scores (list of int): List of scores of contestants Returns: int: The maximum difference between any two scores >>> max_score_difference(5, [-1, 2, 3, -4, 5]) == 9 >>> max_score_difference(4, [1, 2, 3, 4]) == 3 >>> max_score_difference(3, [-5, -3, -4]) == 2 >>> max_score_difference(5, [-10, -5, 0, 5, 10]) == 20 >>> max_score_difference(1, [42]) == 0 >>> max_score_difference(2, [-1000000000, 1000000000]) == 2000000000 >>> max_score_difference(3, [7, 7, 7]) == 0","solution":"def max_score_difference(n, scores): Returns the maximum difference between any two contestant scores. Parameters: n (int): Number of contestants scores (list of int): List of scores of contestants Returns: int: The maximum difference between any two scores max_score = max(scores) min_score = min(scores) return max_score - min_score"},{"question":"def find_winner(n: int, scores: List[Tuple[int, int, int]]) -> int: Miha loves organizing bowling tournaments. For each tournament, Miha needs to arrange games between participants so that every participant plays with each other exactly once. Each game yields a score to each participant, and Miha needs to track the scores to determine the winner. The problem is to find the participant with the highest total score. >>> find_winner(1, []) == 1 >>> find_winner(2, [(1, 2, 10)]) == 1 >>> find_winner(3, [(1, 2, 10), (1, 3, 20), (2, 3, 30)]) == 3 >>> find_winner(3, [(1, 2, 10), (1, 3, 15), (2, 3, 5)]) == 1 >>> find_winner(3, [(1, 2, 1000), (1, 3, 2000), (2, 3, 3000)]) == 3 >>> find_winner(3, [(1, 2, 1), (1, 3, 1), (2, 3, 1)]) == 1","solution":"def find_winner(n, scores): total_scores = [0] * (n + 1) for x, y, s in scores: total_scores[x] += s total_scores[y] += s max_score = max(total_scores) for i in range(1, n + 1): if total_scores[i] == max_score: return i"},{"question":"def batch_cupcake_orders(n: int, orders: List[int]) -> List[Tuple[int, int]]: Combines consecutive orders of the same type into batches. :param n: int - the number of orders :param orders: list of int - the type IDs of the cupcakes in the order they were ordered :return: list of tuples - each tuple contains the cupcake type ID and the number of consecutive orders for that type >>> batch_cupcake_orders(1, [1]) [(1, 1)] >>> batch_cupcake_orders(3, [1, 2, 3]) [(1, 1), (2, 1), (3, 1)] >>> batch_cupcake_orders(4, [2, 2, 2, 2]) [(2, 4)] >>> batch_cupcake_orders(8, [1, 1, 2, 2, 2, 3, 3, 1]) [(1, 2), (2, 3), (3, 2), (1, 1)] >>> batch_cupcake_orders(0, []) [] >>> batch_cupcake_orders(6, [1, 2, 1, 2, 1, 2]) [(1, 1), (2, 1), (1, 1), (2, 1), (1, 1), (2, 1)]","solution":"def batch_cupcake_orders(n, orders): Combines consecutive orders of the same type into batches. :param n: int - the number of orders :param orders: list of int - the type IDs of the cupcakes in the order they were ordered :return: list of tuples - each tuple contains the cupcake type ID and the number of consecutive orders for that type if n == 0: return [] result = [] current_type = orders[0] count = 1 for i in range(1, n): if orders[i] == current_type: count += 1 else: result.append((current_type, count)) current_type = orders[i] count = 1 result.append((current_type, count)) # Append the last batch return result"},{"question":"def max_full_laps(n: int, m: int, resistances: List[int], staminas: List[int]) -> int: Determines the maximum number of full laps each racer can complete. Parameters: - n (int): number of terrain segments - m (int): number of racers - resistances (list of int): terrain resistance for each segment - staminas (list of int): initial stamina levels for each racer Returns: - int: maximum number of full laps the racers can complete >>> max_full_laps(5, 3, [3, 1, 4, 2, 5], [20, 25, 30]) 4 >>> max_full_laps(1, 1, [10], [100]) 10 >>> max_full_laps(3, 3, [5, 5, 5], [30, 30, 30]) 6 >>> max_full_laps(2, 2, [100, 100], [200, 200]) 2 >>> max_full_laps(2, 2, [10, 10], [1, 1]) 0","solution":"def max_full_laps(n, m, resistances, staminas): Determines the maximum number of full laps each racer can complete. Parameters: - n (int): number of terrain segments - m (int): number of racers - resistances (list of int): terrain resistance for each segment - staminas (list of int): initial stamina levels for each racer Returns: - int: maximum number of full laps the racers can complete total_resistance = sum(resistances) max_laps = 0 for stamina in staminas: max_laps += stamina // total_resistance return max_laps"},{"question":"def min_difference(n: int, weights: List[int]) -> int: Roz works in a warehouse and is responsible for arranging boxes in stacks. Each box has a weight, and weight distribution between stacks needs to be balanced as much as possible. Roz receives a delivery of n boxes and wants to distribute them into exactly two stacks such that the difference in total weight between the two stacks is minimized. Given a number of boxes and their weights, find the minimal possible difference between the weights of two stacks formed from these boxes. >>> min_difference(5, [8, 5, 3, 3, 2]) 1 >>> min_difference(1, [10]) 10 >>> min_difference(4, [5, 5, 5, 5]) 0 >>> min_difference(3, [1, 2, 3]) 0 >>> min_difference(3, [10, 20, 30]) 0 >>> min_difference(5, [4, 8, 6, 3, 12]) 1","solution":"def min_difference(n, weights): Given a number of boxes and their weights, find the minimal possible difference between the weights of two stacks formed from these boxes. total_weight = sum(weights) half_total_weight = total_weight // 2 possible_sums = {0} for weight in weights: new_sums = possible_sums.copy() for current_sum in possible_sums: new_sum = current_sum + weight new_sums.add(new_sum) possible_sums = new_sums closest_sum = max(filter(lambda x: x <= half_total_weight, possible_sums)) other_sum = total_weight - closest_sum return abs(other_sum - closest_sum)"},{"question":"def min_possible_max_value(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given multiple test cases, each consisting of an array of positive integers, transform each array into a non-decreasing array by adding minimal positive integers to each element. Find the minimum possible value of the maximum element in the resulting array after performing the transformation for each test case. >>> min_possible_max_value(2, [(4, [4, 2, 1, 3]), (3, [1, 2, 3])]) [4, 3] results = [] # Implement the solution return results # Example Test Cases def test_case_1(): t = 2 test_cases = [ (4, [4, 2, 1, 3]), (3, [1, 2, 3]) ] assert min_possible_max_value(t, test_cases) == [4, 3] def test_case_2(): t = 1 test_cases = [ (5, [1, 3, 3, 2, 5]) ] assert min_possible_max_value(t, test_cases) == [5] def test_case_3(): t = 1 test_cases = [ (6, [1, 2, 2, 2, 2, 2]) ] assert min_possible_max_value(t, test_cases) == [2] def test_case_4(): t = 1 test_cases = [ (2, [1000000000, 1000000000]) ] assert min_possible_max_value(t, test_cases) == [1000000000] def test_case_5(): t = 1 test_cases = [ (3, [3, 3, 3]) ] assert min_possible_max_value(t, test_cases) == [3]","solution":"def min_possible_max_value(t, test_cases): results = [] for case in test_cases: n, arr = case prefix_max = arr[0] for i in range(1, n): if arr[i] < prefix_max: arr[i] += prefix_max - arr[i] prefix_max = max(prefix_max, arr[i]) results.append(prefix_max) return results"},{"question":"def max_total_grass_eaten(n: int, t: int, grass_per_minute: List[int]) -> int: Calculate the maximum total amount of grass eaten by alpacas in t minutes. Parameters: n (int): Number of alpacas / spots (3 ≤ n ≤ 1000) t (int): Number of minutes (1 ≤ t ≤ 1000) grass_per_minute (list of int): Amount of grass eaten per minute by each alpaca (1 ≤ ai ≤ 100) Returns: int: Maximum total amount of grass eaten by all alpacas in t minutes. from solution import max_total_grass_eaten def test_case_1(): assert max_total_grass_eaten(4, 3, [5, 3, 2, 6]) == 48 def test_case_2(): assert max_total_grass_eaten(5, 5, [4, 2, 1, 3, 5]) == 75 def test_case_3(): assert max_total_grass_eaten(3, 2, [10, 10, 10]) == 60 def test_case_4(): assert max_total_grass_eaten(3, 10, [1, 2, 3]) == 60 def test_case_5(): assert max_total_grass_eaten(6, 7, [7, 6, 5, 4, 3, 2]) == 189","solution":"def max_total_grass_eaten(n, t, grass_per_minute): Calculate the maximum total amount of grass eaten by alpacas in t minutes. Parameters: n (int): Number of alpacas / spots (3 ≤ n ≤ 1000) t (int): Number of minutes (1 ≤ t ≤ 1000) grass_per_minute (list of int): Amount of grass eaten per minute by each alpaca (1 ≤ ai ≤ 100) Returns: int: Maximum total amount of grass eaten by all alpacas in t minutes. # Since alpacas only move to spots that will be occupied by their neighbors clockwise and # thus will fight, the optimal solution is each alpaca just eats at its initial spot. max_grass = sum(grass_per_minute) * t return max_grass"},{"question":"from typing import List def min_blocks(transactions: List[int], block_size: int) -> int: Determines the minimum number of blocks needed to store all transactions given the block size. No transactions can be split across blocks. pass # Unit tests def test_min_blocks_single_block(): assert min_blocks([50, 70, 30, 20, 40], 100) == 3 def test_min_blocks_exact_fit(): assert min_blocks([150, 100, 50], 200) == 2 def test_min_blocks_large_transaction(): assert min_blocks([1, 2, 3, 1000, 5], 1000) == 2 def test_min_blocks_small_transactions(): assert min_blocks([1, 1, 1, 1, 1], 3) == 2 def test_min_blocks_one_large_transaction(): assert min_blocks([1000], 1000) == 1 def test_min_blocks_varying_sizes(): assert min_blocks([1, 100, 1, 100, 1, 100], 100) == 4 def test_min_blocks_more_complex_fit(): assert min_blocks([200, 150, 250, 300], 500) == 3 if __name__ == \\"__main__\\": test_min_blocks_single_block() test_min_blocks_exact_fit() test_min_blocks_large_transaction() test_min_blocks_small_transactions() test_min_blocks_one_large_transaction() test_min_blocks_varying_sizes() test_min_blocks_more_complex_fit() print(\\"All tests passed.\\")","solution":"from typing import List def min_blocks(transactions: List[int], block_size: int) -> int: Determines the minimum number of blocks needed to store all transactions given the block size. No transactions can be split across blocks. transactions.sort(reverse=True) blocks = 0 current_block_remaining = 0 for transaction in transactions: if transaction > current_block_remaining: blocks += 1 current_block_remaining = block_size - transaction else: current_block_remaining -= transaction return blocks"},{"question":"MOD = 10**9 + 7 def num_ways_to_form_amount(n: int) -> int: Determine the number of ways to form the exact amount of money \`n\` using coins with denominations that are powers of two. >>> num_ways_to_form_amount(4) 16 >>> num_ways_to_form_amount(7) 128 >>> num_ways_to_form_amount(15) 32768 pass def solve(t: int, amounts: List[int]) -> List[int]: Process multiple test cases and return the results as a list. >>> solve(3, [4, 7, 15]) [16, 128, 32768] >>> solve(2, [0, 1]) [1, 2] >>> solve(1, [10**6]) [787487593] pass","solution":"MOD = 10**9 + 7 def num_ways_to_form_amount(n): Determine the number of ways to form the exact amount of money \`n\` using coins with denominations that are powers of two. return pow(2, n, MOD) def solve(t, amounts): Process multiple test cases and return the results as a list. results = [] for n in amounts: results.append(num_ways_to_form_amount(n)) return results"},{"question":"def max_subsequence_sum(n: int, k: int, A: List[int]) -> int: Determine the maximum sum of any subsequence of length k from the given array A. Parameters: n (int): The size of the array A k (int): The number of elements in the subsequence A (list): List of integers Returns: int: Maximum sum of any subsequence of length k Examples: >>> max_subsequence_sum(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_subsequence_sum(5, 2, [-1, -2, -3, -4, -5]) -3 >>> max_subsequence_sum(5, 3, [-1, 2, 3, -4, 5]) 10 >>> max_subsequence_sum(1, 1, [100]) 100 >>> max_subsequence_sum(4, 4, [4, 3, 2, 1]) 10 >>> max_subsequence_sum(6, 3, [1000000000, 1000000000, 1000000000, -1000000000, -1000000000, -1000000000]) 3000000000 >>> max_subsequence_sum(5, 3, [0, 0, 0, 0, 0]) 0","solution":"def max_subsequence_sum(n, k, A): Returns the maximum sum of any subsequence of length k from the given array A. Parameters: n (int): The size of the array A k (int): The number of elements in the subsequence A (list): List of integers Returns: int: Maximum sum of any subsequence of length k # Sort the array in descending order A.sort(reverse=True) # Sum the first k elements return sum(A[:k])"},{"question":"def max_score(n: int, skill_ratings: List[int]) -> int: Determines the maximum possible overall score of the competition. Parameters: n (int): Number of participants (even number between 2 and 100). skill_ratings (list): A list of integers representing the skill ratings of each participant. Returns: int: Maximum possible overall score of the competition. >>> max_score(4, [4, 7, 2, 6]) 13 >>> max_score(6, [5, 5, 5, 5, 5, 5]) 15 >>> max_score(4, [1, 2, 3, 4]) 7 >>> max_score(6, [10, 20, 30, 40, 50, 60]) 150 >>> max_score(4, [0, 5, 5, 5]) 10 >>> max_score(100, [i for i in range(1, 101)]) 2550","solution":"def max_score(n, skill_ratings): Returns the maximum possible overall score of the competition. Parameters: n (int): Number of participants (even number between 2 and 100). skill_ratings (list): A list of integers representing the skill ratings of each participant. Returns: int: Maximum possible overall score of the competition. # Sort skills in descending order to maximize score skill_ratings.sort(reverse=True) # The maximum score is obtained by summing the first half of the sorted ratings max_score = sum(skill_ratings[:n//2]) return max_score"},{"question":"def min_steps_maze(maze, N, M): Finds the minimum number of steps to reach the bottom-right corner of the grid or returns -1 if not possible. >>> min_steps_maze([\\".....\\", \\".#.#.\\", \\".....\\", \\".#.\\", \\".....\\"], 5, 5) 8 >>> min_steps_maze([\\".....\\", \\".#.#.\\", \\"..#..\\", \\"#\\", \\".....\\"], 5, 5) -1 >>> min_steps_maze([\\".\\"], 1, 1) 0 >>> min_steps_maze([\\"#..\\", \\"...\\", \\"...\\"], 3, 3) -1 >>> min_steps_maze([\\"...\\", \\"...\\", \\"..#\\"], 3, 3) -1 >>> min_steps_maze([\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"], 5, 5) 8","solution":"from collections import deque def min_steps_maze(maze, N, M): Finds the minimum number of steps to reach the bottom-right corner of the grid or returns -1 if not possible. if maze[0][0] == '#' or maze[N-1][M-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == N - 1 and y == M - 1: # Reached goal return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and maze[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def max_distinct_species(n: int, k: int, species: List[int]) -> int: Returns the maximum number of distinct species in any subsegment of length k. Parameters: n (int): Number of plots. k (int): Length of the subsegment. species (list of int): List of species in each plot. Returns: int: Maximum number of distinct species in any subsegment of length k. >>> max_distinct_species(7, 3, [1, 2, 1, 3, 4, 2, 3]) 3 >>> max_distinct_species(5, 3, [1, 1, 1, 1, 1]) 1 >>> max_distinct_species(5, 3, [1, 2, 3, 4, 5]) 3 pass import pytest def test_example_case(): assert max_distinct_species(7, 3, [1, 2, 1, 3, 4, 2, 3]) == 3 def test_all_same_species(): assert max_distinct_species(5, 3, [1, 1, 1, 1, 1]) == 1 def test_all_different_species(): assert max_distinct_species(5, 3, [1, 2, 3, 4, 5]) == 3 def test_subsegment_length_1(): assert max_distinct_species(5, 1, [1, 2, 3, 2, 1]) == 1 def test_full_length_subsegment(): assert max_distinct_species(5, 5, [1, 2, 3, 2, 1]) == 3 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_distinct_species(n, k, species): Returns the maximum number of distinct species in any subsegment of length k. Parameters: n (int): Number of plots. k (int): Length of the subsegment. species (list of int): List of species in each plot. Returns: int: Maximum number of distinct species in any subsegment of length k. from collections import defaultdict species_count = defaultdict(int) max_distinct = 0 current_distinct = 0 # Initialize the first subsegment for i in range(k): if species_count[species[i]] == 0: current_distinct += 1 species_count[species[i]] += 1 max_distinct = current_distinct # Slide the window across the plot line for i in range(k, n): # Remove the first element of the previous subsegment if species_count[species[i - k]] == 1: current_distinct -= 1 species_count[species[i - k]] -= 1 # Add the new element of the current subsegment if species_count[species[i]] == 0: current_distinct += 1 species_count[species[i]] += 1 # Update the maximum distinct species count max_distinct = max(max_distinct, current_distinct) return max_distinct # Example usage n = 7 k = 3 species = [1, 2, 1, 3, 4, 2, 3] print(max_distinct_species(n, k, species)) # Output: 3"},{"question":"def validate_sequence(n: int, sequence: str) -> str: Determines if the given sequence of symbols follows the described pattern. >>> validate_sequence(6, '@#&#@&') == \\"VALID\\" >>> validate_sequence(9, '@@#&&&#@') == \\"INVALID\\" >>> validate_sequence(3, '@#&') == \\"VALID\\"","solution":"def validate_sequence(n, sequence): if n % 3 != 0: return \\"INVALID\\" grouped_blocks = [sequence[i:i+3] for i in range(0, n, 3)] for block in grouped_blocks: if len(set(block)) != 3 or '@' not in block or '#' not in block or '&' not in block: return \\"INVALID\\" return \\"VALID\\""},{"question":"def determine_winner(n: int, array: List[int]) -> str: Determines the winner (Masha or Friend) of the game given the initial array. Parameters: n (int): The number of elements in the array. array (list of int): The initial array. Returns: str: 'Masha' if Masha wins, 'Friend' otherwise. >>> determine_winner(3, [1, 2, 3]) \\"Masha\\" >>> determine_winner(4, [1, 1, 1, 1]) \\"Friend\\" >>> determine_winner(5, [1, 2, 2, 2, 3]) \\"Masha\\" >>> determine_winner(6, [1, 2, 1, 2, 1, 2]) \\"Masha\\" >>> determine_winner(1000, [5]*1000) \\"Friend\\" >>> determine_winner(1, [10]) \\"Friend\\" >>> determine_winner(2, [1, 2]) \\"Masha\\"","solution":"def determine_winner(n, array): Determines the winner (Masha or Friend) of the game given the initial array. Parameters: n (int): The number of elements in the array. array (list of int): The initial array. Returns: str: 'Masha' if Masha wins, 'Friend' otherwise. # Determine the number of unique elements in the array unique_elements = len(set(array)) # If all elements are already equal, Friend wins if unique_elements == 1: return \\"Friend\\" else: return \\"Masha\\""},{"question":"def min_reversals_needed(n: int, arr: List[int]) -> int: Returns the minimum number of reversals needed to make the array non-decreasing. >>> min_reversals_needed(5, [3, 2, 3, 1, 2]) 2 >>> min_reversals_needed(1, [1]) 0 >>> min_reversals_needed(3, [3, 2, 1]) 1 >>> min_reversals_needed(5, [1, 2, 3, 4, 5]) 0 >>> min_reversals_needed(6, [1, 3, 2, 2, 5, 4]) 2 >>> min_reversals_needed(7, [1, 3, 5, 7, 6, 4, 2]) 1 >>> min_reversals_needed(8, [5, 1, 2, 3, 4, 4, 6, 7]) 1 >>> min_reversals_needed(2, [2, 1]) 1 pass","solution":"def min_reversals_needed(n, arr): Returns the minimum number of reversals needed to make the array non-decreasing. # We need to count the disordered segments disordered_segments = 0 in_segment = False for i in range(1, n): if arr[i] < arr[i-1]: if not in_segment: disordered_segments += 1 in_segment = True else: in_segment = False return disordered_segments"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers and an integer target, return the indices of the two numbers that add up to the target. Example Usage: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] pass","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"def max_teams(n: int, d: int, skill_levels: List[int]) -> int: Function to compute the maximum number of teams with the given constraints. n : int : Number of participants d : int : Maximum allowed difference in skill levels between teammates skill_levels : list of int : List of skill levels of participants in non-decreasing order Returns: int : Maximum number of teams that can be formed >>> max_teams(5, 2, [1, 2, 3, 5, 7]) 2 >>> max_teams(4, 1, [1, 3, 5, 7]) 0 >>> max_teams(4, 4, [1, 2, 3, 4]) 2 >>> max_teams(3, 1, [1, 2, 4]) 1 >>> max_teams(5, 1, [1, 2, 4, 5, 7]) 2 >>> max_teams(6, 10, [1, 11, 21, 31, 41, 51]) 3","solution":"def max_teams(n, d, skill_levels): Function to compute the maximum number of teams with the given constraints. n : int : Number of participants d : int : Maximum allowed difference in skill levels between teammates skill_levels : list of int : List of skill levels of participants in non-decreasing order Returns: int : Maximum number of teams that can be formed teams = 0 i = 0 while i < n - 1: if skill_levels[i + 1] - skill_levels[i] <= d: teams += 1 i += 2 else: i += 1 return teams"},{"question":"def can_transform(s1: str, s2: str) -> int: Determine if it is possible to transform s1 into s2 through a series of mutations. If it is possible, return the minimum number of mutations required; otherwise, return -1. >>> can_transform(\\"AGCT\\", \\"TCGA\\") 4 >>> can_transform(\\"ATCG\\", \\"ATCG\\") 0 >>> can_transform(\\"A\\", \\"T\\") 1 >>> can_transform(\\"AAA\\", \\"TTT\\") 3 >>> can_transform(\\"AGCT\\", \\"TGXA\\") -1 >>> can_transform(\\"BGCT\\", \\"TGCA\\") -1 >>> can_transform(\\"AGCT\\", \\"TGCAAA\\") -1 # Write your code here","solution":"def min_mutations(s1, s2): Determine the minimum number of mutations needed to transform s1 to s2. If it's not possible, return -1. if len(s1) != len(s2): return -1 mutations = 0 for i in range(len(s1)): if s1[i] != s2[i]: mutations += 1 return mutations def can_transform(s1, s2): Check if it is possible to transform s1 into s2. A transformation is possible if all characters in s1 and s2 are in the set {'A', 'T', 'C', 'G'}. valid_chars = {'A', 'T', 'C', 'G'} if all(c in valid_chars for c in s1) and all(c in valid_chars for c in s2): return min_mutations(s1, s2) else: return -1"},{"question":"import math from typing import List, Tuple def nearest_neighbor_path(n: int, coordinates: List[Tuple[int, int, int]]) -> List[int]: Creates a path that starts from one animal and visits each other animal exactly once by always moving to the nearest unvisited animal. Args: n (int): number of animals coordinates (List[Tuple[int, int, int]]): List of tuples representing the coordinates of each animal. Returns: List[int]: a list of indices representing the order in which the animals are visited (1-based index). >>> nearest_neighbor_path(1, [(0, 0, 0)]) [1] >>> nearest_neighbor_path(2, [(0, 0, 0), (1, 1, 1)]) [1, 2] >>> nearest_neighbor_path(3, [(0, 0, 0), (1, 1, 1), (2, 2, 2)]) [1, 2, 3] >>> nearest_neighbor_path(4, [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3)]) [1, 2, 3, 4] >>> nearest_neighbor_path(3, [(0, 0, 0), (-1, -1, -1), (2, 2, 2)]) [1, 2, 3]","solution":"import math def nearest_neighbor_path(n, coordinates): def euclidean_distance(a, b): return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2 + (a[2] - b[2])**2) visited = [False] * n current_index = 0 visited[current_index] = True path = [current_index + 1] for _ in range(n - 1): nearest_distance = float('inf') nearest_index = -1 for i in range(n): if not visited[i]: dist = euclidean_distance(coordinates[current_index], coordinates[i]) if dist < nearest_distance: nearest_distance = dist nearest_index = i visited[nearest_index] = True path.append(nearest_index + 1) current_index = nearest_index return path # Example usage: # n = 4 # coordinates = [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3)] # print(nearest_neighbor_path(n, coordinates)) # Output: [1, 2, 3, 4]"},{"question":"def longestTwoDistinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. Params: s: A single string of lowercase English letters. Returns: The length of the longest substring that contains at most two distinct characters. Examples: >>> longestTwoDistinct(\\"abcabcabc\\") 2 >>> longestTwoDistinct(\\"eceba\\") 3 >>> longestTwoDistinct(\\"ccaabbb\\") 5","solution":"def longestTwoDistinct(s): Returns the length of the longest substring with at most two distinct characters. if len(s) == 0: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: char_map[s[right]] += 1 else: char_map[s[right]] = 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def hiking_trip(initial_coordinates, steps): Determine if Sam will return to the starting point after following all the steps. Args: initial_coordinates (tuple): A tuple containing the starting x and y coordinates. steps (list): A list of strings representing the steps taken (\\"Up\\", \\"Down\\", \\"Left\\", \\"Right\\"). Returns: str: \\"YES\\" if Sam returns to the starting point, otherwise \\"NO\\". Examples: >>> hiking_trip((3, 3), [\\"Up\\", \\"Right\\", \\"Down\\", \\"Left\\"]) 'YES' >>> hiking_trip((1, 1), [\\"Up\\", \\"Up\\", \\"Right\\"]) 'NO' >>> hiking_trip((2, 2), [\\"Down\\", \\"Right\\", \\"Up\\", \\"Left\\"]) 'YES' >>> hiking_trip((5, 5), []) 'YES' >>> hiking_trip((4, 4), [\\"Left\\", \\"Right\\"]) 'YES' >>> hiking_trip((4, 4), [\\"Up\\", \\"Down\\"]) 'YES'","solution":"def hiking_trip(initial_coordinates, steps): x, y = initial_coordinates for step in steps: if step == \\"Up\\": y += 1 elif step == \\"Down\\": y -= 1 elif step == \\"Left\\": x -= 1 elif step == \\"Right\\": x += 1 return \\"YES\\" if (x, y) == initial_coordinates else \\"NO\\""},{"question":"def can_make_all_elements_equal(n: int, arr: List[int]) -> str: Determines whether it is possible to make all elements in the list equal by performing the given operation. Parameters: n (int): The number of elements in the list. arr (list of int): The list of integers. Returns: str: \\"YES\\" if it is possible to make all elements in the list equal; otherwise, \\"NO\\". >>> can_make_all_elements_equal(3, [1, 2, 3]) == \\"YES\\" >>> can_make_all_elements_equal(3, [1, 2, 4]) == \\"NO\\" >>> can_make_all_elements_equal(1, [10]) == \\"YES\\" >>> can_make_all_elements_equal(4, [5, 5, 5, 5]) == \\"YES\\" >>> can_make_all_elements_equal(4, [1000000, 1000000, 1000000, 1000000]) == \\"YES\\" >>> can_make_all_elements_equal(4, [2, 4, 6, 8]) == \\"YES\\" >>> can_make_all_elements_equal(5, [1, 2, 3, 5, 7]) == \\"NO\\" >>> n = 100000 >>> arr = [1] * n >>> can_make_all_elements_equal(n, arr) == \\"YES\\" pass","solution":"def can_make_all_elements_equal(n, arr): Determines whether it is possible to make all elements in the list equal by performing the given operation. Parameters: n (int): The number of elements in the list. arr (list of int): The list of integers. Returns: str: \\"YES\\" if it is possible to make all elements in the list equal; otherwise, \\"NO\\". total_sum = sum(arr) if total_sum % n == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_almost_non_decreasing(n: int, seq: List[int]) -> bool: Determines if sequence is almost non-decreasing by removing at most one element. # Your code here def almost_non_decreasing_sequences(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines for multiple test cases whether each sequence is almost non-decreasing. >>> almost_non_decreasing_sequences(5, [(5, [4, 2, 3, 3, 4]), (6, [4, 2, 1, 3, 3, 4]), (5, [1, 2, 3, 4, 5]), (4, [3, 1, 2, 3]), (3, [3, 3, 3])]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] # Unit tests def test_single_case_almost_non_decreasing(): assert is_almost_non_decreasing(5, [4, 2, 3, 3, 4]) == True assert is_almost_non_decreasing(6, [4, 2, 1, 3, 3, 4]) == False assert is_almost_non_decreasing(5, [1, 2, 3, 4, 5]) == True assert is_almost_non_decreasing(4, [3, 1, 2, 3]) == True assert is_almost_non_decreasing(3, [3, 3, 3]) == True def test_multiple_case_almost_non_decreasing(): test_cases = [(5, [4, 2, 3, 3, 4]), (6, [4, 2, 1, 3, 3, 4]), (5, [1, 2, 3, 4, 5]), (4, [3, 1, 2, 3]), (3, [3, 3, 3])] assert almost_non_decreasing_sequences(5, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] def test_edge_cases(): assert is_almost_non_decreasing(1, [5]) == True # Single element is non-decreasing assert is_almost_non_decreasing(2, [2, 1]) == True # Directly decreasing: [2->_] or [_->1] assert is_almost_non_decreasing(2, [1, 2]) == True # Already non-decreasing assert is_almost_non_decreasing(3, [1, 2, 1]) == True # Removing either 1 or 2 can make it non-decreasing test_cases = [(1, [1]), (2, [2, 1]), (2, [1, 2])] assert almost_non_decreasing_sequences(3, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_almost_non_decreasing(n, seq): Determines if sequenece is almost non-decreasing by removing at most one element. def is_non_decreasing(seq): for i in range(len(seq) - 1): if seq[i] > seq[i + 1]: return False return True for i in range(n): if is_non_decreasing(seq[:i] + seq[i+1:]): return True return False def almost_non_decreasing_sequences(t, test_cases): results = [] for i in range(t): n, seq = test_cases[i] result = is_almost_non_decreasing(n, seq) results.append(\\"YES\\" if result else \\"NO\\") return results"},{"question":"from typing import List, Tuple def graph_queries(n: int, m: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the minimum value among the vertices that are at most \`k\` edges away from vertex \`u\` for each query. Args: n (int): Number of vertices in the graph. m (int): Number of edges in the graph. values (List[int]): Values associated with each vertex. edges (List[Tuple[int, int]]): List of edges, where each edge is represented as a tuple of two integers. queries (List[Tuple[int, int]]): List of queries, where each query is represented as a tuple of two integers (u, k). Returns: List[int]: The results of the queries. Example: >>> graph_queries(5, 4, [4, 2, 8, 6, 7], [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 2), (5, 1), (4, 0)]) [2, 6, 6] >>> graph_queries(3, 2, [10, 1, 5], [(1, 2), (2, 3)], [(1, 1), (2, 2), (3, 0)]) [1, 1, 5] from solution import graph_queries def test_case_1(): n = 5 m = 4 values = [4, 2, 8, 6, 7] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [(1, 2), (5, 1), (4, 0)] expected = [2, 6, 6] assert graph_queries(n, m, values, edges, queries) == expected def test_case_2(): n = 3 m = 2 values = [10, 1, 5] edges = [(1, 2), (2, 3)] queries = [(1, 1), (2, 2), (3, 0)] expected = [1, 1, 5] assert graph_queries(n, m, values, edges, queries) == expected def test_case_3(): n = 4 m = 4 values = [10, 20, 30, 40] edges = [(1, 2), (2, 3), (3, 4), (1, 3)] queries = [(1, 1), (2, 2), (4, 3)] expected = [10, 10, 10] assert graph_queries(n, m, values, edges, queries) == expected def test_case_4(): n = 6 m = 5 values = [3, 6, 2, 1, 5, 4] edges = [(1, 2), (2, 3), (4, 5), (5, 6), (3, 4)] queries = [(1, 3), (6, 2), (4, 1)] expected = [1, 1, 1] assert graph_queries(n, m, values, edges, queries) == expected def test_case_5(): n = 2 m = 1 values = [15, 25] edges = [(1, 2)] queries = [(1, 1), (2, 0)] expected = [15, 25] assert graph_queries(n, m, values, edges, queries) == expected","solution":"from collections import deque, defaultdict import sys def graph_queries(n, m, values, edges, queries): # Create adjacency list representation of the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) results = [] # Process each query using BFS for u, k in queries: queue = deque([(u, 0)]) # (current node, distance) visited = set([u]) min_value = values[u - 1] while queue: current, dist = queue.popleft() if dist > k: continue min_value = min(min_value, values[current - 1]) for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) results.append(min_value) return results"},{"question":"def max_apples(n: int, m: int, grid: List[List[int]]) -> int: This function takes the dimensions of the grid (n, m) and the grid itself as input, and returns the maximum number of apples that can be collected starting from the top-left corner and ending at the bottom-right corner, moving only right or down. >>> max_apples(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_apples(1, 5, [ ... [0, 100, 0, 0, 0] ... ]) 100 >>> max_apples(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_apples(1, 1, [ ... [5] ... ]) 5 >>> max_apples(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_apples(4, 4, [ ... [1, 3, 1, 0], ... [0, 1, 3, 1], ... [2, 1, 2, 2], ... [0, 2, 0, 3] ... ]) 15 >>> max_apples(2, 3, [ ... [5, 1, 0], ... [4, 0, 6] ... ]) 15","solution":"def max_apples(n, m, grid): This function takes the dimensions of the grid (n, m) and the grid itself as input, and returns the maximum number of apples that can be collected starting from the top-left corner and ending at the bottom-right corner, moving only right or down. # Create a 2D array dp to store the maximum apples that can be collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the dp array with the values of the apples in the grid dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the maximum apples collected return dp[n-1][m-1]"},{"question":"def can_cut_cake(n: int, m: int, grid: List[str]) -> str: Determine if it is possible to cut the cake such that each piece contains exactly one cherry. :param n: Number of rows in the cake :param m: Number of columns in the cake :param grid: List of strings representing the cake grid, where '.' is an empty cell and 'C' is a cherry :return: \\"YES\\" if it's possible to cut the cake with each piece containing exactly one cherry, otherwise \\"NO\\" >>> can_cut_cake(3, 4, [\\".C..\\", \\"....\\", \\"..C.\\"]) \\"YES\\" >>> can_cut_cake(3, 3, [\\".C.\\", \\"C.C\\", \\".C.\\"]) \\"NO\\"","solution":"def can_cut_cake(n, m, grid): # Count the number of cherries total_cherries = sum(row.count('C') for row in grid) # If no cherries, it's trivially possible as there is no cherry to separate if total_cherries == 0: return \\"YES\\" # Check each row and column whether the cherries can be isolated cherries_per_row = [row.count('C') for row in grid] cherries_per_col = [sum(grid[i][j] == 'C' for i in range(n)) for j in range(m)] # Each row or column must have either 0 or 1 cherry for it to be possible to cut if all(x <= 1 for x in cherries_per_row) and all(x <= 1 for x in cherries_per_col): return \\"YES\\" else: return \\"NO\\""},{"question":"def is_prefix_sum_non_negative(n: int, arr: List[int]) -> str: Determine if the sum of every prefix of the array is non-negative. Parameters: n (int): The length of the array arr (list): List of integers representing the array Returns: str: \\"YES\\" if the sum of every prefix is non-negative, otherwise \\"NO\\" >>> is_prefix_sum_non_negative(5, [1, 2, -3, 4, 5]) 'YES' >>> is_prefix_sum_non_negative(4, [1, -2, 3, -4]) 'NO'","solution":"def is_prefix_sum_non_negative(n, arr): Function to determine if the sum of every prefix of the array is non-negative. Parameters: n (int): Length of the array arr (list): List of integers representing the array Returns: str: \\"YES\\" if the sum of every prefix is non-negative, otherwise \\"NO\\" prefix_sum = 0 for num in arr: prefix_sum += num if prefix_sum < 0: return \\"NO\\" return \\"YES\\""},{"question":"def can_ants_move_within_distance(n: int, positions: List[Tuple[int, int, int, int, int, int]]) -> str: Determine if there exists a single threshold distance d where every ant moved less than or equal to d units from t1 to t2. >>> can_ants_move_within_distance(3, [(1, 2, 3, 4, 5, 6), (0, 0, 0, 1, 1, 1), (2, 3, 4, 5, 6, 7)]) == \\"YES 5.196152422706632\\" >>> can_ants_move_within_distance(1, [(0, 0, 0, 0, 0, 0)]) == \\"YES 0.0\\"","solution":"def can_ants_move_within_distance(n, positions): from math import sqrt max_distance_sq = 0 # maximum squared distance any ant has moved for pos in positions: x, y, z, a, b, c = pos dist_sq = (x - a) ** 2 + (y - b) ** 2 + (z - c) ** 2 max_distance_sq = max(max_distance_sq, dist_sq) max_distance = sqrt(max_distance_sq) # Calculate the actual distance return f\\"YES {max_distance}\\" # Example usage: # \`positions\` is a list of tuples, each containing six integers (x, y, z, a, b, c) positions = [(1, 2, 3, 4, 5, 6), (0, 0, 0, 1, 1, 1), (2, 3, 4, 5, 6, 7)] print(can_ants_move_within_distance(3, positions)) # This is just an example call."},{"question":"def findPeak(arr: List[int]) -> int: Finds the peak element in a bitonic sequence array. >>> findPeak([1, 3, 8, 12, 9, 4, 2]) 3 >>> findPeak([10, 20, 30, 40, 50, 40, 30, 20]) 4 >>> findPeak([1, 20, 50, 40, 30]) 2 >>> findPeak([1, 1000000000, 1]) 1 >>> findPeak([1, 2, 3, 4, 5, 4, 3]) 4 >>> findPeak([10, 20, 30, 40, 50, 40, 30, 20, 10]) 4","solution":"def findPeak(arr): Finds the peak element in a bitonic sequence array using binary search. Args: arr: List of integers representing the bitonic sequence. Returns: Index of the peak element in the array. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def electoral_college(n: int, state_votes: List[int], party_votes: List[int]) -> Tuple[int, int, str]: Determines the total number of electoral votes for each party and decides which party won the election. Parameters: n (int): The number of states. state_votes (list of int): List of electoral college votes for each state. party_votes (list of int): List indicating which party won the electoral votes of each state. Returns: tuple: A tuple containing total electoral votes for Party A, total electoral votes for Party B, and the result of the election as a string. >>> electoral_college(4, [5, 3, 3, 2], [1, 0, 1, 0]) (8, 5, \\"Party A wins\\") >>> electoral_college(3, [4, 4, 4], [1, 1, 0]) (8, 4, \\"Party A wins\\") >>> electoral_college(2, [3, 3], [1, 0]) (3, 3, \\"Tie\\")","solution":"def electoral_college(n, state_votes, party_votes): Determines the total number of electoral votes for each party and decides which party won the election. Parameters: n (int): The number of states. state_votes (list of int): List of electoral college votes for each state. party_votes (list of int): List indicating which party won the electoral votes of each state. Returns: tuple: A tuple containing total electoral votes for Party A, total electoral votes for Party B, and the result of the election as a string. total_votes_party_a = sum(state_votes[i] for i in range(n) if party_votes[i] == 1) total_votes_party_b = sum(state_votes[i] for i in range(n) if party_votes[i] == 0) if total_votes_party_a > total_votes_party_b: result = \\"Party A wins\\" elif total_votes_party_b > total_votes_party_a: result = \\"Party B wins\\" else: result = \\"Tie\\" return (total_votes_party_a, total_votes_party_b, result)"},{"question":"def count_special_numbers_in_range(l: int, r: int) -> int: Determines the number of \\"special numbers\\" (divisible by both 3 and 5) in a given range [l, r]. >>> count_special_numbers_in_range(1, 15) 1 >>> count_special_numbers_in_range(10, 30) 2 def process_queries(queries: List[Tuple[int, int]]) -> List[int]: Processes multiple queries to determine the number of \\"special numbers\\" (divisible by both 3 and 5) for each range specified. >>> process_queries([(1, 15), (10, 30), (100, 150)]) [1, 2, 4] from typing import List, Tuple def test_specific_ranges(): assert count_special_numbers_in_range(1, 15) == 1 assert count_special_numbers_in_range(10, 30) == 2 assert count_special_numbers_in_range(15, 45) == 3 assert count_special_numbers_in_range(14, 29) == 1 def test_large_ranges(): assert count_special_numbers_in_range(1, 10**18) == (10**18) // 15 assert count_special_numbers_in_range(10**17, 10**18) == (10**18 // 15) - (10**17 // 15) + (1 if 10**17 % 15 == 0 else 0) def test_edge_cases(): assert count_special_numbers_in_range(1, 1) == 0 assert count_special_numbers_in_range(10**18, 10**18) == (1 if 10**18 % 15 == 0 else 0) assert count_special_numbers_in_range(15, 15) == 1 assert count_special_numbers_in_range(14, 15) == 1 def test_process_queries(): queries = [ (1, 15), (10, 30), (100, 150) ] expected_results = [1, 2, 4] assert process_queries(queries) == expected_results","solution":"def count_special_numbers_in_range(l, r): def count_special_numbers(n): if n < 15: return 0 return n // 15 return count_special_numbers(r) - count_special_numbers(l - 1) def process_queries(queries): results = [] for l, r in queries: results.append(count_special_numbers_in_range(l, r)) return results"},{"question":"def can_sort_matrix(n: int, m: int, matrix: List[List[int]]) -> str: Determines if the matrix can be rearranged such that all rows and columns are sorted in non-decreasing order. Args: n : int : number of rows m : int : number of columns matrix : List[List[int]] : the matrix Returns: str : \\"YES\\" if the matrix can be sorted as required, \\"NO\\" otherwise Example: >>> can_sort_matrix(3, 3, [ ... [3, 2, 1], ... [6, 1, 4], ... [5, 4, 3] ... ]) == \\"YES\\" >>> can_sort_matrix(2, 2, [ ... [1, 2], ... [3, 1] ... ]) == \\"NO\\"","solution":"def can_sort_matrix(n, m, matrix): Determines if the matrix can be rearranged such that all rows and columns are sorted in non-decreasing order. Args: n : int : number of rows m : int : number of columns matrix : List[List[int]] : the matrix Returns: str : \\"YES\\" if the matrix can be sorted as required, \\"NO\\" otherwise sorted_rows = sorted([sorted(row) for row in matrix]) sorted_cols = sorted([sorted(col) for col in zip(*matrix)]) return \\"YES\\" if all(sorted_rows[i][j] == sorted_cols[j][i] for i in range(n) for j in range(m)) else \\"NO\\" # Example usage if __name__ == \\"__main__\\": n1, m1 = 3, 3 matrix1 = [ [3, 2, 1], [6, 1, 4], [5, 4, 3] ] print(can_sort_matrix(n1, m1, matrix1)) # Expected: YES n2, m2 = 2, 2 matrix2 = [ [1, 2], [3, 1] ] print(can_sort_matrix(n2, m2, matrix2)) # Expected: NO"},{"question":"def can_assemble(parts_info, available_parts): Determines if the given set of parts can be assembled without compatibility issues. >>> can_assemble([\\"A 1 B\\", \\"B 1 A\\", \\"C 0\\", \\"D 2 A B\\"], [\\"A\\", \\"C\\"]) == \\"YES\\" >>> can_assemble([\\"A 1 B\\", \\"B 1 A\\", \\"C 0\\", \\"D 2 A B\\"], [\\"A\\", \\"C\\", \\"D\\"]) == \\"NO\\" >>> can_assemble([\\"A 0\\"], [\\"A\\"]) == \\"YES\\" >>> can_assemble([\\"A 0\\", \\"B 0\\", \\"C 0\\"], [\\"A\\", \\"B\\"]) == \\"YES\\" >>> can_assemble([\\"A 2 B C\\", \\"B 1 A\\", \\"C 1 A\\"], [\\"A\\", \\"B\\", \\"C\\"]) == \\"NO\\" def parse_input(input_string): Parses the input string into parts_info and available_parts. >>> input_string = '3nA 1 BnB 1 CnC 0n3 A B C' >>> parse_input(input_string) == ([\\"A 1 B\\", \\"B 1 C\\", \\"C 0\\"], [\\"A\\", \\"B\\", \\"C\\"])","solution":"def can_assemble(parts_info, available_parts): Determines if the given set of parts can be assembled without compatibility issues. Parameters: parts_info: List of tuples where each tuple contains a part and its incompatible parts available_parts: List of parts to be assembled Returns: str: \\"YES\\" if assembly is possible without any incompatible parts, otherwise \\"NO\\" incompatible_dict = {} for part_info in parts_info: part, *incompatibles = part_info.split() incompatible_dict[part] = set(incompatibles) for i, part in enumerate(available_parts): if part in incompatible_dict: for incompatible_part in incompatible_dict[part]: if incompatible_part in available_parts: return \\"NO\\" return \\"YES\\" def parse_input(input_string): Parses the input string into parts_info and available_parts. Parameters: input_string: str Returns: tuple: (parts_info, available_parts) lines = input_string.strip().split('n') n = int(lines[0]) parts_info = [] for i in range(1, n + 1): parts_info.append(lines[i]) k_line = lines[n + 1].split() k = int(k_line[0]) available_parts = k_line[1:] return parts_info, available_parts # Example Input input_string = 4 A 1 B B 1 A C 0 D 2 A B 3 A C D # Parse Example Input parts_info, available_parts = parse_input(input_string) # Check and Print Result print(can_assemble(parts_info, available_parts))"},{"question":"import math from typing import List, Tuple def min_points_to_move_inside_circle(r: int, n: int, points: List[Tuple[int, int]]) -> int: Determine the minimum number of points that need to be moved so that all points lie either on the edge or inside the circle with radius r centered at the origin. >>> min_points_to_move_inside_circle(3, 3, [(2, 2), (-1, 1), (1, -1)]) 0 >>> min_points_to_move_inside_circle(1, 3, [(2, 2), (-3, 1), (4, -1)]) 3 >>> min_points_to_move_inside_circle(3, 3, [(4, -3), (-2, -2), (1, 1)]) 1 >>> min_points_to_move_inside_circle(1000000000, 3, [(1000000000, 1000000000), (-999999999, -999999999), (1, 1)]) 2 >>> min_points_to_move_inside_circle(3, 3, [(3, 0), (0, 3), (-3, 0)]) 0","solution":"import math def min_points_to_move_inside_circle(r, n, points): def squared_distance(x, y): return x * x + y * y radius_squared = r * r count_outside = 0 for x, y in points: if squared_distance(x, y) > radius_squared: count_outside += 1 return count_outside"},{"question":"def min_subgrid_irrigations(n: int, m: int, garden: List[str]) -> int: Determines the minimum number of subgrid irrigation operations needed to water all plants in the garden. Args: n: an integer, the number of rows in the garden. m: an integer, the number of columns in the garden. garden: a list of strings representing the garden grid, where '.' represents an empty cell and '*' represents a plant. Returns: An integer, the minimum number of subgrid irrigation operations required to water all plants. >>> min_subgrid_irrigations(1, 5, [\\".*.*.\\"]) 2 >>> min_subgrid_irrigations(4, 5, [ ... \\".*..*\\", ... \\"****.\\", ... \\".*...\\", ... \\"...*.\\" ... ]) 3 >>> min_subgrid_irrigations(4, 6, [ ... \\"******\\", ... \\"******\\", ... \\"******\\", ... \\"******\\" ... ]) 1 >>> min_subgrid_irrigations(4, 5, [ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ]) 0 >>> min_subgrid_irrigations(5, 5, [ ... \\"*....\\", ... \\".*...\\", ... \\"..*..\\", ... \\"...*.\\", ... \\"....*\\" ... ]) 5","solution":"def min_subgrid_irrigations(n, m, garden): visited = [[False] * m for _ in range(n)] def bfs(row, col): from collections import deque q = deque([(row, col)]) visited[row][col] = True while q: r, c = q.popleft() for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and garden[nr][nc] == '*': visited[nr][nc] = True q.append((nr, nc)) count = 0 for i in range(n): for j in range(m): if garden[i][j] == '*' and not visited[i][j]: bfs(i, j) count += 1 return count"},{"question":"from typing import List def min_substrings_with_at_least_one_one(s: str) -> int: Returns the minimum number of contiguous substrings needed to partition the given string such that each contiguous substring contains at least one '1'. >>> min_substrings_with_at_least_one_one(\\"110100111\\") == 3 >>> min_substrings_with_at_least_one_one(\\"1001\\") == 2 >>> min_substrings_with_at_least_one_one(\\"1111\\") == 1 >>> min_substrings_with_at_least_one_one(\\"0000\\") == 0 >>> min_substrings_with_at_least_one_one(\\"1010101\\") == 4 def solve(test_cases: List[str]) -> List[int]: Given a list of binary strings, returns a list of integers where each integer represents the minimum number of contiguous substrings for each input string such that each substring contains at least one '1'. >>> solve([\\"110100111\\", \\"1001\\", \\"1111\\", \\"0000\\", \\"1010101\\"]) == [3, 2, 1, 0, 4]","solution":"def min_substrings_with_at_least_one_one(s: str) -> int: Returns the minimum number of contiguous substrings needed to partition the given string such that each contiguous substring contains at least one '1'. if '1' not in s: return 0 count = 0 in_one_segment = False for char in s: if char == '1': if not in_one_segment: count += 1 in_one_segment = True else: in_one_segment = False return count def solve(test_cases): results = [] for s in test_cases: results.append(min_substrings_with_at_least_one_one(s)) return results"},{"question":"def max_height_difference(n, heights): Returns the maximum difference in height that can be achieved by moving forward on the trail. Parameters: n (int): number of points on the trail heights (list): heights of the points on the trail Returns: int: maximum difference in height >>> max_height_difference(5, [1, 2, 3, 4, 5]) 4 >>> max_height_difference(5, [5, 4, 3, 2, 1]) 0 >>> max_height_difference(5, [1, 3, 2, 5, 4]) 4 >>> max_height_difference(1, [1]) 0 >>> max_height_difference(1, [100000]) 0 >>> max_height_difference(3, [5, 5, 5]) 0 >>> max_height_difference(4, [2, 2, 2, 3]) 1 >>> max_height_difference(7, [10, 4, 5, 1, 7, 3, 2]) 6 >>> max_height_difference(6, [1, 6, 3, 2, 4, 10]) 9","solution":"def max_height_difference(n, heights): Returns the maximum difference in height that can be achieved by moving forward on the trail. Parameters: n (int): number of points on the trail heights (list): heights of the points on the trail Returns: int: maximum difference in height min_height = float('inf') max_difference = 0 for height in heights: if height < min_height: min_height = height max_difference = max(max_difference, height - min_height) return max_difference"},{"question":"from typing import List, Tuple def min_steps_to_reach_destination(n: int, m: int, field: List[str], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Returns the minimum number of steps required to reach the destination block from the start block in a mystical forest. :param n: Number of rows in the field. :param m: Number of columns in the field. :param field: List of strings representing the field where '.' is an empty block and '*' is a block occupied by creatures. :param start: Tuple (xS, yS) indicating the starting block coordinates. :param destination: Tuple (xD, yD) indicating the destination block coordinates. :return: The minimum number of steps to reach the destination block, or -1 if it is not possible. pass # Test Cases def test_example_case(): n = 5 m = 5 field = [ \\".....\\", \\".*.*.\\", \\".....\\", \\".***.\\", \\".....\\", ] start = (1, 1) destination = (5, 5) assert min_steps_to_reach_destination(n, m, field, start, destination) == 8 def test_no_possible_path(): n = 3 m = 3 field = [ \\".*.\\", \\"***\\", \\".*.\\" ] start = (1, 1) destination = (3, 3) assert min_steps_to_reach_destination(n, m, field, start, destination) == -1 def test_direct_path(): n = 3 m = 3 field = [ \\"...\\", \\"...\\", \\"...\\" ] start = (1, 1) destination = (3, 3) assert min_steps_to_reach_destination(n, m, field, start, destination) == 4 def test_same_row_path(): n = 1 m = 5 field = [ \\"..*..\\" ] start = (1, 1) destination = (1, 5) assert min_steps_to_reach_destination(n, m, field, start, destination) == -1 def test_edge_case_minimum_field(): n = 1 m = 2 field = [ \\"..\\" ] start = (1, 1) destination = (1, 2) assert min_steps_to_reach_destination(n, m, field, start, destination) == 1","solution":"from collections import deque def min_steps_to_reach_destination(n, m, field, start, destination): Returns the minimum number of steps required to reach the destination block from the start block in a mystical forest. :param n: Number of rows in the field. :param m: Number of columns in the field. :param field: List of strings representing the field where '.' is an empty block and '*' is a block occupied by creatures. :param start: Tuple (xS, yS) indicating the starting block coordinates. :param destination: Tuple (xD, yD) indicating the destination block coordinates. :return: The minimum number of steps to reach the destination block, or -1 if it is not possible. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and field[x][y] == '.' visited = [[False] * m for _ in range(n)] xS, yS = start xD, yD = destination queue = deque([(xS-1, yS-1, 0)]) # Note: converting to zero-based index visited[xS-1][yS-1] = True while queue: x, y, steps = queue.popleft() if (x, y) == (xD-1, yD-1): # Destination reached return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1 # Example Inputs n = 5 m = 5 field = [ \\".....\\", \\".*.*.\\", \\".....\\", \\".***.\\", \\".....\\", ] start = (1, 1) destination = (5, 5) # Example Output result = min_steps_to_reach_destination(n, m, field, start, destination) print(result) # Output: 8"},{"question":"def is_subsequence(n: int, m: int, X: List[int], Y: List[int]) -> str: Determine if sequence Y is a subsequence of sequence X. Parameters: n (int): Length of sequence X. m (int): Length of sequence Y. X (list of int): Sequence X. Y (list of int): Sequence Y. Returns: str: \\"YES\\" if Y is a subsequence of X, \\"NO\\" otherwise. >>> is_subsequence(6, 3, [1, 3, 2, 1, 5, 7], [3, 1, 7]) \\"YES\\" >>> is_subsequence(6, 3, [1, 3, 2, 1, 5, 7], [3, 7, 1]) \\"NO\\"","solution":"def is_subsequence(n, m, X, Y): Determine if sequence Y is a subsequence of sequence X. Parameters: n (int): Length of sequence X. m (int): Length of sequence Y. X (list of int): Sequence X. Y (list of int): Sequence Y. Returns: str: \\"YES\\" if Y is a subsequence of X, \\"NO\\" otherwise. i, j = 0, 0 while i < n and j < m: if X[i] == Y[j]: j += 1 i += 1 return \\"YES\\" if j == m else \\"NO\\""},{"question":"from typing import List def can_reach_end(n: int, m: int, maze: List[str]) -> str: Returns \\"YES\\" if it is possible to reach the bottom-right cell from the top-left cell, otherwise returns \\"NO\\". pass # Test cases def test_maze1(): n, m = 5, 5 maze = [ \\".....\\", \\".#.\\", \\".#...\\", \\".#.\\", \\".....\\" ] assert can_reach_end(n, m, maze) == \\"YES\\" def test_maze2(): n, m = 3, 3 maze = [ \\"#.#\\", \\"#.#\\", \\".#.\\", ] assert can_reach_end(n, m, maze) == \\"NO\\" def test_maze3(): n, m = 1, 1 maze = [ \\".\\" ] assert can_reach_end(n, m, maze) == \\"YES\\" def test_maze4(): n, m = 2, 2 maze = [ \\"\\", \\"\\" ] assert can_reach_end(n, m, maze) == \\"NO\\" def test_maze5(): n, m = 2, 2 maze = [ \\"..\\", \\"..\\" ] assert can_reach_end(n, m, maze) == \\"YES\\"","solution":"def can_reach_end(n, m, maze): Returns \\"YES\\" if it is possible to reach the bottom-right cell from the top-left cell, otherwise returns \\"NO\\". from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def is_transformation_possible(s: str, t: str, rules: List[List[str]]) -> str: Determine if it is possible to transform the string s into the string t using the provided replacement rules. Args: s (str): Original string. t (str): Target string. rules (List[List[str]]): List of replacement rules where the first element is the character and the rest are possible replacements. Returns: str: \\"POSSIBLE\\" if transformation is possible, otherwise \\"IMPOSSIBLE\\". Examples: >>> is_transformation_possible(\\"ab\\", \\"cd\\", [['a', 'c'], ['b', 'd']]) \\"POSSIBLE\\" >>> is_transformation_possible(\\"abc\\", \\"defg\\", [['a', 'd'], ['b', 'e'], ['c', 'f']]) \\"IMPOSSIBLE\\" >>> is_transformation_possible(\\"ab\\", \\"ef\\", [['a', 'c'], ['b', 'd']]) \\"IMPOSSIBLE\\" >>> is_transformation_possible(\\"ab\\", \\"ef\\", [['a', 'c'], ['c', 'e'], ['b', 'd'], ['d', 'f']]) \\"POSSIBLE\\" >>> is_transformation_possible(\\"abc\\", \\"abc\\", [['a', 'x'], ['b', 'y'], ['c', 'z']]) \\"POSSIBLE\\"","solution":"def is_transformation_possible(s, t, rules): from collections import defaultdict, deque if len(s) != len(t): return \\"IMPOSSIBLE\\" # Create a dictionary of rules replacement_dict = defaultdict(set) for rule in rules: key, replacements = rule[0], rule[1:] replacement_dict[key].update(replacements) # BFS to check if transformation from s to t is possible def can_transform(start_char, end_char): if start_char == end_char: return True queue = deque() queue.append(start_char) visited = set() while queue: current = queue.popleft() if current in visited: continue visited.add(current) for neighbor in replacement_dict[current]: if neighbor == end_char: return True if neighbor not in visited: queue.append(neighbor) return False for sc, tc in zip(s, t): if not can_transform(sc, tc): return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\" # Example usage: # s = \\"ab\\" # t = \\"cd\\" # rules = [ # ['a', 'c'], # ['b', 'd'] # ] # print(is_transformation_possible(s, t, rules)) # Output: \\"POSSIBLE\\""},{"question":"def max_efficiencies(n: int, q: int, efficiencies: List[int], queries: List[int]) -> List[int]: This function returns the maximum efficiency of a well among the first k wells for each query. Parameters: n (int): Number of wells. q (int): Number of queries. efficiencies (list of int): List containing the efficiencies of the wells. queries (list of int): List containing the queries. Returns: list of int: List containing the maximum efficiencies for each query. Example: >>> max_efficiencies(5, 3, [3, 5, 2, 8, 6], [2, 4, 5]) [5, 8, 8]","solution":"def max_efficiencies(n, q, efficiencies, queries): This function returns the maximum efficiency of a well among the first k wells for each query. Parameters: n (int): Number of wells. q (int): Number of queries. efficiencies (list of int): List containing the efficiencies of the wells. queries (list of int): List containing the queries. Returns: list of int: List containing the maximum efficiencies for each query. # Precompute prefix maximums for efficiencies prefix_max = [0] * n prefix_max[0] = efficiencies[0] for i in range(1, n): prefix_max[i] = max(prefix_max[i - 1], efficiencies[i]) result = [] for k in queries: result.append(prefix_max[k - 1]) return result # Example usage: n, q = 5, 3 efficiencies = [3, 5, 2, 8, 6] queries = [2, 4, 5] print(max_efficiencies(n, q, efficiencies, queries)) # Output: [5, 8, 8]"},{"question":"def minimize_max_distance(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: In an ancient kingdom, there are several cities connected by bidirectional roads. Each road has a length, which is an integer. The kingdom wants to construct a new capital city that minimizes the maximum travel distance from this capital to any other city. Your task is to help the kingdom find the optimal location for the new capital city. Given the number of cities and the roads, determine the maximum distance from the new capital to the furthest city. :param n: number of cities :param m: number of roads :param roads: list of tuples containing the roads (u, v, w) :return: minimized maximum travel distance from the optimal capital to the furthest city >>> minimize_max_distance(5, 6, [(1, 2, 3), (1, 3, 4), (1, 4, 5), (2, 4, 2), (3, 4, 1), (3, 5, 1)]) 4 >>> minimize_max_distance(1, 0, []) 0 >>> minimize_max_distance(2, 1, [(1, 2, 5)]) 5","solution":"import heapq def dijkstra(adj, start, n): distances = [float('inf')] * n distances[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > distances[u]: continue for v, weight in adj[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances def minimize_max_distance(n, m, roads): adj = [[] for _ in range(n)] for u, v, w in roads: adj[u-1].append((v-1, w)) adj[v-1].append((u-1, w)) min_max_distance = float('inf') for city in range(n): distances = dijkstra(adj, city, n) max_distance_from_city = max(distances) min_max_distance = min(min_max_distance, max_distance_from_city) return min_max_distance # Input format for the function n = 5 m = 6 roads = [ (1, 2, 3), (1, 3, 4), (1, 4, 5), (2, 4, 2), (3, 4, 1), (3, 5, 1) ] print(minimize_max_distance(n, m, roads)) # Output: 4"},{"question":"def longest_even_sum_subsequence(n: int, sequence: List[int]) -> Tuple[int, List[int]]: Returns the length of the longest subsequence with an even sum and the subsequence itself. >>> longest_even_sum_subsequence(6, [1, 2, 3, 4, 5, 6]) (5, [2, 3, 4, 5, 6]) >>> longest_even_sum_subsequence(6, [2, 4, 6, 8, 10, 12]) (6, [2, 4, 6, 8, 10, 12]) >>> longest_even_sum_subsequence(1, [2]) (1, [2]) >>> longest_even_sum_subsequence(1, [3]) (0, []) >>> longest_even_sum_subsequence(5, [1, 3, 5, 7, 9]) (4, [1, 3, 5, 9]) >>> longest_even_sum_subsequence(6, [1, 2, 3, 4, 5, 8]) (5, [1, 2, 4, 5, 8])","solution":"def longest_even_sum_subsequence(n, sequence): Returns the length of the longest subsequence with an even sum and the subsequence itself. total_sum = sum(sequence) if total_sum % 2 == 0: return n, sequence # If the total sum is odd, we need to remove the smallest odd element for i, num in enumerate(sequence): if num % 2 != 0: modified_sequence = sequence[:i] + sequence[i+1:] return n - 1, modified_sequence # If we cannot find any odd element to remove, return empty as the sequence itself can't be even. return 0, [] # Example usage: # n = 6 # sequence = [1, 2, 3, 4, 5, 6] # print(longest_even_sum_subsequence(n, sequence))"},{"question":"def min_operations_to_zero(n: int, binary_string: str) -> int: Given a binary string, determines the minimum number of operations required to make all bits '0'. In one operation, you can select any bit and flip it only if there is at least one '1' from the start of the string to the position you selected. Args: n (int): The length of the binary string. binary_string (str): A binary string consisting of '0's and '1's. Returns: int: The minimum number of operations required to make all bits '0'. Examples: >>> min_operations_to_zero(5, \\"11010\\") 3 >>> min_operations_to_zero(5, \\"00000\\") 0 >>> min_operations_to_zero(4, \\"1111\\") 4 >>> min_operations_to_zero(1, \\"0\\") 0 >>> min_operations_to_zero(1, \\"1\\") 1 >>> min_operations_to_zero(6, \\"101010\\") 3 >>> min_operations_to_zero(8, \\"00001111\\") 4","solution":"def min_operations_to_zero(n, binary_string): Given a binary string, determines the minimum number of operations required to make all bits '0'. In one operation, you can select any bit and flip it only if there is at least one '1' from the start of the string to the position you selected. operations = 0 for bit in binary_string: if bit == '1': operations += 1 return operations"},{"question":"def min_servers_needed(n: int, capacities: List[int], required_power: int) -> int: Returns the minimum number of servers needed to reach or exceed the required processing power. If it is not possible, returns -1. >>> min_servers_needed(5, [3, 1, 4, 2, 5], 11) 3 >>> min_servers_needed(3, [1, 2, 3], 10) -1 >>> min_servers_needed(4, [2, 3, 4, 5], 9) 2 >>> min_servers_needed(4, [2, 2, 2, 2], 8) 4 >>> min_servers_needed(5, [10, 20, 30, 40, 50], 35) 1 >>> min_servers_needed(3, [10, 15, 20], 20) 1 >>> min_servers_needed(1000, [i for i in range(1, 1001)], 500500) 1000","solution":"def min_servers_needed(n, capacities, required_power): Returns the minimum number of servers needed to reach or exceed the required processing power. If it is not possible, returns -1. capacities.sort(reverse=True) current_power = 0 server_count = 0 for capacity in capacities: current_power += capacity server_count += 1 if current_power >= required_power: return server_count return -1"},{"question":"def has_cycle(n: int, intersections: List[int]) -> str: This function checks if there is a cycle in Rita's journey. :param n: Number of intersections :param intersections: List of intersections visited :return: \\"YES\\" if there is a cycle, otherwise \\"NO\\" >>> has_cycle(6, [1, 2, 3, 4, 2, 5]) \\"YES\\" >>> has_cycle(5, [1, 3, 4, 5, 6]) \\"NO\\" >>> has_cycle(7, [1, 2, 3, 4, 5, 6, 1]) \\"YES\\" >>> has_cycle(1, [1]) \\"NO\\" >>> has_cycle(10, [1, 2, 3, 4, 5, 6, 7, 8, 4, 10]) \\"YES\\"","solution":"def has_cycle(n, intersections): This function checks if there is a cycle in Rita's journey. :param n: Number of intersections (int) :param intersections: List of intersections visited (list of int) :return: \\"YES\\" if there is a cycle, otherwise \\"NO\\" visited = set() for intersection in intersections: if intersection in visited: return \\"YES\\" visited.add(intersection) return \\"NO\\""},{"question":"def longest_vowel_subsequence(n: int, s: str) -> int: Returns the length of the longest subsequence that contains each vowel ('a', 'e', 'i', 'o', 'u') at least once. Args: n (int): The length of the string s (str): The string consisting of lowercase English letters Returns: int: The length of the longest subsequence, or -1 if no such subsequence exists Examples: >>> longest_vowel_subsequence(21, \\"abcdefahijklmnopqrstu\\") 21 >>> longest_vowel_subsequence(10, \\"abcdefghij\\") -1 >>> longest_vowel_subsequence(15, \\"aeioubcdfghjklm\\") 15 >>> longest_vowel_subsequence(30, \\"abcdefghijklmnopqrstuvwxyzaaeiou\\") 30 >>> longest_vowel_subsequence(7, \\"aeiouaa\\") 7","solution":"def longest_vowel_subsequence(n, s): Returns the length of the longest subsequence that contains each vowel ('a', 'e', 'i', 'o', 'u') at least once. # Define the required vowels vowels = set('aeiou') current_vowels = set() max_length = -1 for i in range(n): if s[i] in vowels: current_vowels.add(s[i]) if len(current_vowels) == 5: max_length = n - i break if len(current_vowels) == 5: return n else: return -1"},{"question":"def bacteria_population(N: int) -> int: Returns the number of bacteria present after N minutes. Each bacterium splits into two every minute. :param N: int - The number of minutes (0 ≤ N ≤ 10^9) :return: int - The number of bacteria after N minutes. >>> bacteria_population(0) == 1 >>> bacteria_population(1) == 2 >>> bacteria_population(5) == 32 >>> bacteria_population(10) == 1024 >>> bacteria_population(30) == 1073741824 # 2 ** 30","solution":"def bacteria_population(N): Returns the number of bacteria present after N minutes. Each bacterium splits into two every minute. :param N: int - The number of minutes (0 ≤ N ≤ 10^9) :return: int - The number of bacteria after N minutes. return 2 ** N"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring which contains unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abac\\") == 3 >>> length_of_longest_substring(\\"AaBbCc\\") == 6 >>> length_of_longest_substring(\\"\\") == 0","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_map = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def earliest_complete_time(n: int, startTimes: List[int], times: List[int]) -> int: Calculate the earliest time at which all participants complete the marathon. :param n: Number of participants :param startTimes: List of start times for each participant. :param times: List of completion times for each participant. :return: Earliest time at which all participants have completed the marathon. >>> earliest_complete_time(3, [1, 2, 3], [5, 4, 3]) 6 >>> earliest_complete_time(3, [1, 1, 1], [5, 5, 5]) 6","solution":"def earliest_complete_time(n, startTimes, times): Calculate the earliest time at which all participants complete the marathon. :param n: Number of participants :param startTimes: List of start times for each participant. :param times: List of completion times for each participant. :return: Earliest time at which all participants have completed the marathon. end_times = [startTimes[i] + times[i] for i in range(n)] return max(end_times)"},{"question":"def max_photos_joined(n: int, widths: List[int]) -> int: Determines the maximum number of photos that can be joined into a single, continuous panorama while maintaining the parity of their widths (even or odd). Parameters: n (int): Number of panoramic photos. widths (list of int): List containing the widths of the photos. Returns: int: The maximum number of photos that can be joined. pass from typing import List def test_example_case(): assert max_photos_joined(5, [2, 4, 1, 3, 5]) == 5 def test_all_even(): assert max_photos_joined(4, [2, 4, 6, 8]) == 4 def test_all_odd(): assert max_photos_joined(3, [1, 3, 5]) == 3 def test_mixed(): assert max_photos_joined(6, [10, 13, 6, 11, 7, 2]) == 6 def test_single_even(): assert max_photos_joined(1, [8]) == 1 def test_single_odd(): assert max_photos_joined(1, [9]) == 1 def test_large_input(): n = 10**5 widths = [i for i in range(1, n + 1)] assert max_photos_joined(n, widths) == n","solution":"def max_photos_joined(n, widths): Determines the maximum number of photos that can be joined into a single, continuous panorama while maintaining the parity of their widths (even or odd). Parameters: n (int): Number of panoramic photos. widths (list of int): List containing the widths of the photos. Returns: int: The maximum number of photos that can be joined. even_photos = [w for w in widths if w % 2 == 0] odd_photos = [w for w in widths if w % 2 == 1] return len(even_photos) + len(odd_photos)"},{"question":"import heapq from collections import defaultdict def find_even_weight_path(n, m, edges, s, t): Given an undirected graph with n nodes and m edges, determine if there exists a path between two given nodes such that the sum of weights of edges along the path is an even number. If there is, return the path; if there are multiple paths, return the path with the minimum weight sum. If no such path exists, return -1. >>> find_even_weight_path(5, 6, [(1, 2, 6), (1, 3, 8), (2, 4, 10), (3, 4, 11), (4, 5, 2), (3, 5, 9)], 1, 5) [1, 2, 4, 5] or [1, 3, 4, 5] >>> find_even_weight_path(4, 3, [(1, 2, 1), (2, 3, 3), (3, 4, 5)], 1, 4) -1 >>> find_even_weight_path(3, 2, [(1, 2, 4), (2, 3, 6)], 1, 3) [1, 2, 3] >>> find_even_weight_path(4, 4, [(1, 2, 2), (1, 3, 10), (2, 3, 4), (3, 4, 6)], 1, 4) [1, 2, 3, 4]","solution":"import heapq from collections import defaultdict def find_even_weight_path(n, m, edges, s, t): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Applying Dijkstra's algorithm to find the shortest path def dijkstra(start): dist = {i: (float('inf'), []) for i in range(1, n + 1)} dist[start] = (0, [start]) pq = [(0, start, [start])] while pq: current_dist, current_node, path = heapq.heappop(pq) if current_dist > dist[current_node][0]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor][0]: dist[neighbor] = (distance, path + [neighbor]) heapq.heappush(pq, (distance, neighbor, path + [neighbor])) return dist dist = dijkstra(s) if dist[t][0] == float('inf') or dist[t][0] % 2 != 0: return -1 else: return dist[t][1] # Sample usage n = 5 m = 6 edges = [ (1, 2, 6), (1, 3, 8), (2, 4, 10), (3, 4, 11), (4, 5, 2), (3, 5, 9) ] s, t = 1, 5"},{"question":"def maximum_minimum_sum(n: int, k: int, nums: List[int]) -> int: Determine the maximum possible minimum sum of elements among the k subarrays. >>> maximum_minimum_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> maximum_minimum_sum(1, 1, [10]) 10 >>> maximum_minimum_sum(4, 2, [1, 1, 1, 1]) 2 >>> maximum_minimum_sum(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]) 15 >>> maximum_minimum_sum(6, 3, [3, 3, 3, 3, 3, 3]) 6 >>> maximum_minimum_sum(5, 5, [5, 10, 15, 20, 25]) 25 >>> maximum_minimum_sum(5, 1, [5, 10, 15, 20, 25]) 75","solution":"def can_divide(nums, k, min_sum): current_sum = 0 subarrays = 1 for num in nums: if current_sum + num > min_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True def maximum_minimum_sum(n, k, nums): left, right = max(nums), sum(nums) answer = left while left <= right: mid = (left + right) // 2 if can_divide(nums, k, mid): answer = mid right = mid - 1 else: left = mid + 1 return answer"},{"question":"def smallest_submatrix_sum(n: int, m: int, k: int, matrix: List[List[int]]) -> int: Identify the smallest sum of a submatrix of size k x k within an n x m matrix. >>> smallest_submatrix_sum(4, 4, 2, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 14 >>> smallest_submatrix_sum(1, 1, 1, [[5]]) == 5 >>> smallest_submatrix_sum(2, 2, 2, [[1, 2], [3, 0]]) == 6 >>> smallest_submatrix_sum(3, 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 12 >>> smallest_submatrix_sum(3, 3, 2, [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -28 pass","solution":"def smallest_submatrix_sum(n, m, k, matrix): min_sum = float('inf') for i in range(n - k + 1): for j in range(m - k + 1): current_sum = 0 for x in range(k): for y in range(k): current_sum += matrix[i + x][j + y] if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"def reduce_string(s: str) -> int: Reduces the string by removing adjacent equal characters. Returns the reduced string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack) def minimum_length_after_operations(t: int, test_cases: List[str]) -> List[int]: Accepts the number of test cases and list of strings, and returns the minimum lengths of each string after operations. >>> minimum_length_after_operations(3, [\\"abbac\\", \\"aab\\", \\"abcde\\"]) [1, 1, 5] >>> minimum_length_after_operations(2, [\\"abcd\\", \\"xyz\\"]) [4, 3] >>> minimum_length_after_operations(2, [\\"aaaa\\", \\"bbbbbb\\"]) [0, 0] >>> minimum_length_after_operations(2, [\\"abccba\\", \\"abba\\"]) [0, 0] >>> minimum_length_after_operations(2, [\\"a\\", \\"b\\"]) [1, 1] >>> minimum_length_after_operations(1, [\\"abababab\\"]) [8] >>> minimum_length_after_operations(1, [\\"abccbaabccba\\"]) [0] results = [] for s in test_cases: results.append(reduce_string(s)) return results","solution":"def reduce_string(s): Reduces the string by removing adjacent equal characters. Returns the reduced string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack) def minimum_length_after_operations(t, test_cases): Accepts the number of test cases and list of strings, and returns the minimum lengths of each string after operations. results = [] for s in test_cases: results.append(reduce_string(s)) return results"},{"question":"from typing import List def autocomplete(variable_names: List[str], prefix: str) -> List[str]: Returns a list of variable names that start with the given prefix. >>> autocomplete(['myvar', 'variable', 'varsetup', 'experiment', 'testcase', 'validator'], 'var') == ['variable', 'varsetup'] >>> autocomplete(['myvar', 'variable', 'varsetup', 'experiment', 'testcase', 'validator'], 'xyz') == [] >>> autocomplete(['abc', 'abcd', 'abcde', 'abcf'], 'abc') == ['abc', 'abcd', 'abcde', 'abcf'] pass def test_autocomplete_basic(): assert autocomplete(['myvar', 'variable', 'varsetup', 'experiment', 'testcase', 'validator'], 'var') == ['variable', 'varsetup'] def test_autocomplete_no_match(): assert autocomplete(['myvar', 'variable', 'varsetup', 'experiment', 'testcase', 'validator'], 'xyz') == [] def test_autocomplete_partial_match(): assert autocomplete(['abc', 'abcd', 'abcde', 'abcf'], 'abc') == ['abc', 'abcd', 'abcde', 'abcf'] def test_autocomplete_full_match(): assert autocomplete(['alpha', 'beta', 'gamma'], 'alpha') == ['alpha'] def test_autocomplete_empty_list(): assert autocomplete([], 'alpha') == [] def test_autocomplete_single_character_prefix(): assert autocomplete(['a', 'ab', 'abc', 'b'], 'a') == ['a', 'ab', 'abc'] def test_autocomplete_prefix_longer_than_any_name(): assert autocomplete(['short', 'longer', 'longest'], 'verylongprefix') == []","solution":"def autocomplete(variable_names, prefix): Returns a list of variable names that start with the given prefix. :param variable_names: List of variable names :param prefix: Prefix string to match :return: List of variable names that start with the prefix result = [name for name in variable_names if name.startswith(prefix)] return result"},{"question":"def max_score(n: int, m: int, k: int, z: int, scoring_zones: List[Tuple[int, int, int]]) -> int: Determines the maximum score Zara can achieve by shooting k arrows at the specified scoring zones. Parameters: n (int): The number of rows of the target. m (int): The number of columns of the target. k (int): The number of arrows Zara can shoot. z (int): The number of scoring zones on the target. scoring_zones (list of tuples): Each tuple contains three integers (xi, yi, si) representing the coordinates (xi, yi) of the scoring zone and the score si for hitting that zone. Returns: int: The maximum score Zara can achieve. from typing import List, Tuple def test_max_score(): assert max_score(10, 10, 3, 5, [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)]) == 750 assert max_score(10, 10, 1, 5, [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)]) == 300 assert max_score(10, 10, 5, 5, [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)]) == 1000 assert max_score(10, 10, 10, 5, [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)]) == 1000 assert max_score(10, 10, 0, 5, [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)]) == 0","solution":"def max_score(n, m, k, z, scoring_zones): Determines the maximum score Zara can achieve by shooting k arrows at the specified scoring zones. Parameters: n (int): The number of rows of the target. m (int): The number of columns of the target. k (int): The number of arrows Zara can shoot. z (int): The number of scoring zones on the target. scoring_zones (list of tuples): Each tuple contains three integers (xi, yi, si) representing the coordinates (xi, yi) of the scoring zone and the score si for hitting that zone. Returns: int: The maximum score Zara can achieve. # Extract scores from the scoring_zones and sort in descending order scores = sorted([si for _, _, si in scoring_zones], reverse=True) # Take the highest k scores max_score = sum(scores[:k]) return max_score # Example usage: # n = 10, m = 10, k = 3 # z = 5 # scoring_zones = [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)] # Output should be 750 print(max_score(10, 10, 3, 5, [(2, 3, 100), (4, 5, 200), (6, 7, 150), (8, 9, 300), (1, 4, 250)]))"},{"question":"from typing import List, Dict, Union, Any def restructure_table(employees: List[Dict[str, Union[int, Any]]], department_id: int) -> List[Dict[str, int]]: Reformats the employees table to make it easier to query information. Specifically, for a given department, calculates the total salary of employees directly managed by each manager in that department and the number of employees each manager directly manages. Args: employees (List[Dict[str, Union[int, Any]]]): A list of dictionaries representing the employees table. Each dictionary has the keys: 'id', 'salary', 'manager_id', and 'department_id'. department_id (int): The id of the department to query. Returns: List[Dict[str, int]]: A list of dictionaries where each dictionary represents a manager with keys 'manager_id', 'total_salary', and 'num_employees'. Example: >>> employees = [ ... {'id': 1, 'salary': 1000, 'manager_id': None, 'department_id': 1}, ... {'id': 2, 'salary': 800, 'manager_id': 1, 'department_id': 1}, ... {'id': 3, 'salary': 750, 'manager_id': 1, 'department_id': 1}, ... {'id': 4, 'salary': 500, 'manager_id': 2, 'department_id': 1}, ... {'id': 5, 'salary': 600, 'manager_id': 2, 'department_id': 2}] >>> restructure_table(employees, 1) [{'manager_id': 1, 'total_salary': 1550, 'num_employees': 2}, {'manager_id': 2, 'total_salary': 500, 'num_employees': 1}] >>> restructure_table([], 1) [] # Your code here def test_example_case(): employees = [ {'id': 1, 'salary': 1000, 'manager_id': None, 'department_id': 1}, {'id': 2, 'salary': 800, 'manager_id': 1, 'department_id': 1}, {'id': 3, 'salary': 750, 'manager_id': 1, 'department_id': 1}, {'id': 4, 'salary': 500, 'manager_id': 2, 'department_id': 1}, {'id': 5, 'salary': 600, 'manager_id': 2, 'department_id': 2} ] department_id = 1 expected_output = [ {'manager_id': 1, 'total_salary': 1550, 'num_employees': 2}, {'manager_id': 2, 'total_salary': 500, 'num_employees': 1} ] assert restructure_table(employees, department_id) == expected_output def test_single_manager_multiple_employees(): employees = [ {'id': 1, 'salary': 1000, 'manager_id': None, 'department_id': 1}, {'id': 2, 'salary': 800, 'manager_id': 1, 'department_id': 1}, {'id': 3, 'salary': 750, 'manager_id': 1, 'department_id': 1} ] department_id = 1 expected_output = [ {'manager_id': 1, 'total_salary': 1550, 'num_employees': 2} ] assert restructure_table(employees, department_id) == expected_output def test_multiple_managers_single_employee_each(): employees = [ {'id': 1, 'salary': 1000, 'manager_id': None, 'department_id': 1}, {'id': 2, 'salary': 800, 'manager_id': 1, 'department_id': 1}, {'id': 3, 'salary': 750, 'manager_id': 2, 'department_id': 1} ] department_id = 1 expected_output = [ {'manager_id': 1, 'total_salary': 800, 'num_employees': 1}, {'manager_id': 2, 'total_salary': 750, 'num_employees': 1} ] assert restructure_table(employees, department_id) == expected_output def test_no_employees_in_department(): employees = [ {'id': 1, 'salary': 1000, 'manager_id': None, 'department_id': 1}, {'id': 2, 'salary': 800, 'manager_id': 1, 'department_id': 1}, {'id': 3, 'salary': 750, 'manager_id': 1, 'department_id': 1}, {'id': 4, 'salary': 500, 'manager_id': 2, 'department_id': 2} ] department_id = 3 expected_output = [] assert restructure_table(employees, department_id) == expected_output def test_managers_with_no_direct_reports(): employees = [ {'id': 1, 'salary': 1000, 'manager_id': None, 'department_id': 1}, {'id': 2, 'salary': 800, 'manager_id': 1, 'department_id': 2}, {'id': 3, 'salary': 750, 'manager_id': 2, 'department_id': 2} ] department_id = 1 expected_output = [] assert restructure_table(employees, department_id) == expected_output","solution":"from typing import List, Dict, Union, Any def restructure_table(employees: List[Dict[str, Union[int, Any]]], department_id: int) -> List[Dict[str, int]]: # Dictionary to keep track of the total salary and the number of employees for each manager in the given department manager_info = {} # Iterate through the employees for employee in employees: # We only consider employees within the specified department if employee['department_id'] == department_id and employee['manager_id'] is not None: manager_id = employee['manager_id'] if manager_id not in manager_info: manager_info[manager_id] = {'total_salary': 0, 'num_employees': 0} manager_info[manager_id]['total_salary'] += employee['salary'] manager_info[manager_id]['num_employees'] += 1 # Convert the dictionary to a list of dictionaries as specified in the problem statement result = [] for manager_id, info in manager_info.items(): result.append({ 'manager_id': manager_id, 'total_salary': info['total_salary'], 'num_employees': info['num_employees'] }) return result"},{"question":"def simulate_lunascript(operations: List[str]) -> List[Tuple[str, int]]: Simulate the behavior of variable initialization and assignment in LunaScript. >>> simulate_lunascript([\\"decl a\\", \\"decl b\\", \\"assign a 10\\", \\"decl c\\", \\"assign c 7\\"]) [(\\"a\\", 10), (\\"b\\", 2), (\\"c\\", 7)] >>> simulate_lunascript([\\"decl x\\", \\"decl y\\", \\"decl z\\"]) [(\\"x\\", 1), (\\"y\\", 2), (\\"z\\", 3)] >>> simulate_lunascript([\\"decl x\\", \\"assign x 100\\", \\"decl y\\", \\"assign y 200\\", \\"decl z\\", \\"assign z 300\\"]) [(\\"x\\", 100), (\\"y\\", 200), (\\"z\\", 300)] >>> simulate_lunascript([\\"decl a\\", \\"assign a 15\\", \\"decl b\\", \\"assign b 20\\", \\"decl c\\", \\"assign c 25\\", \\"assign a 30\\"]) [(\\"a\\", 30), (\\"b\\", 20), (\\"c\\", 25)] >>> simulate_lunascript([\\"decl b\\", \\"decl a\\", \\"decl c\\", \\"assign b 5\\", \\"assign a 3\\", \\"assign c 7\\"]) [(\\"a\\", 3), (\\"b\\", 5), (\\"c\\", 7)]","solution":"def simulate_lunascript(operations): variables = {} global_counter = 1 for operation in operations: parts = operation.split() if parts[0] == \\"decl\\": var_name = parts[1] variables[var_name] = global_counter global_counter += 1 elif parts[0] == \\"assign\\": var_name = parts[1] value = int(parts[2]) variables[var_name] = value sorted_vars = sorted(variables.items()) return sorted_vars"},{"question":"def longest_consecutive_subsequence(cards: List[Tuple[str, str]]) -> int: Find the longest subsequence of cards where all cards have the same suit and the ranks are in increasing consecutive order. >>> longest_consecutive_subsequence([(\\"2\\", \\"H\\"), (\\"3\\", \\"H\\"), (\\"4\\", \\"H\\"), (\\"9\\", \\"C\\"), (\\"10\\", \\"S\\")]) 3 >>> longest_consecutive_subsequence([(\\"2\\", \\"H\\"), (\\"4\\", \\"H\\"), (\\"7\\", \\"H\\"), (\\"9\\", \\"C\\"), (\\"10\\", \\"S\\")]) 1 >>> longest_consecutive_subsequence([(\\"2\\", \\"H\\"), (\\"3\\", \\"H\\"), (\\"4\\", \\"H\\"), (\\"5\\", \\"H\\"), (\\"6\\", \\"H\\")]) 5 >>> longest_consecutive_subsequence([(\\"2\\", \\"H\\")]) 1 >>> longest_consecutive_subsequence([]) 0","solution":"def longest_consecutive_subsequence(cards): suits = {'H': [], 'D': [], 'C': [], 'S': []} rank_to_value = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13} # Separate cards by suits and convert rank to numerical value for rank, suit in cards: suits[suit].append(rank_to_value[rank]) def find_longest_sequence(ranks): ranks = sorted(ranks) longest = current = 1 if ranks else 0 for i in range(1, len(ranks)): if ranks[i] == ranks[i-1] + 1: current += 1 else: longest = max(longest, current) current = 1 longest = max(longest, current) return longest max_length = 0 for suit in suits: max_length = max(max_length, find_longest_sequence(suits[suit])) return max_length"},{"question":"def form_teams(player_count: int, skill_levels: List[int]) -> Union[int, List[List[int]]]: Returns the number of teams that can be formed and the indices of players in each team. Each team must have exactly three players whose skill levels sum approximately the same. If it is impossible to form one or more teams, returns -1. Parameters: player_count (int): The total number of players. skill_levels (List[int]): The skill levels of the players. Returns: Union[int, List[List[int]]]: A list containing the number of teams and their respective player indices. If teams cannot be formed, returns -1. Examples: >>> form_teams(6, [10, 20, 30, 40, 50, 60]) [2, [1, 2, 3], [4, 5, 6]] >>> form_teams(6, [60, 20, 10, 30, 40, 50]) [2, [3, 2, 4], [5, 6, 1]] >>> form_teams(5, [10, 20, 30, 40, 50]) -1 pass","solution":"def form_teams(player_count, skill_levels): Returns the number of teams that can be formed and the indices of players in each team. Parameters: player_count: int - The total number of players. skill_levels: List[int] - The skill levels of the players. Returns: result: List - A list containing the number of teams and their respective player indices. If teams cannot be formed, returns -1. if player_count % 3 != 0: return -1 skill_levels_with_indices = [(skill, index) for index, skill in enumerate(skill_levels, start=1)] skill_levels_with_indices.sort() teams = [] for i in range(0, player_count, 3): team = skill_levels_with_indices[i:i+3] teams.append([player[1] for player in team]) return [len(teams)] + teams def solve(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) skills = list(map(int, data[1:])) result = form_teams(n, skills) if result == -1: print(result) else: print(result[0]) for team in result[1:]: print(\\" \\".join(map(str, team)))"},{"question":"def rearrange_cubes(n: int, cubes: List[int]) -> Tuple[str, List[int]]: Rearranges the cubes so the cubes with odd sizes are on the bottom in increasing order and cubes with even sizes are on top in decreasing order. Parameters: n (int): Number of cubes. cubes (List[int]): The sizes of the cubes. Returns: Tuple[str, List[int]]: \\"YES\\" and the rearranged list if possible, otherwise \\"NO\\". >>> rearrange_cubes(7, [5, 3, 6, 1, 8, 4, 2]) (\\"YES\\", [1, 3, 5, 8, 6, 4, 2]) >>> rearrange_cubes(5, [1, 3, 5, 7, 9]) (\\"YES\\", [1, 3, 5, 7, 9]) >>> rearrange_cubes(4, [2, 4, 6, 8]) (\\"YES\\", [8, 6, 4, 2]) >>> rearrange_cubes(6, [1, 2, 3, 4, 5, 6]) (\\"YES\\", [1, 3, 5, 6, 4, 2]) >>> rearrange_cubes(1, [1]) (\\"YES\\", [1]) >>> rearrange_cubes(2, [2, 1]) (\\"YES\\", [1, 2])","solution":"def rearrange_cubes(n, cubes): Rearranges the cubes so the cubes with odd sizes are on the bottom in increasing order and cubes with even sizes are on top in decreasing order. Parameters: n (int): Number of cubes. cubes (List[int]): The sizes of the cubes. Returns: Tuple[str, List[int]]: \\"YES\\" and the rearranged list if possible, otherwise \\"NO\\". odds = sorted([cube for cube in cubes if cube % 2 != 0]) evens = sorted([cube for cube in cubes if cube % 2 == 0], reverse=True) arranged_cubes = odds + evens return \\"YES\\", arranged_cubes"},{"question":"def min_operations_to_transform(x: int, y: int) -> int: Determine the minimum number of operations required to transform x into y using the multiply by 2 and subtract 1 operations. Examples: >>> min_operations_to_transform(2, 3) 2 >>> min_operations_to_transform(5, 8) 2 >>> min_operations_to_transform(7, 5) 2 >>> min_operations_to_transform(1, 10) 6 >>> min_operations_to_transform(10, 1) 9 pass def solve(test_cases: list) -> list: Given a list of test cases, returns the minimum number of operations required for each case. Examples: >>> solve([(2, 3), (5, 8), (7, 5), (1, 10), (10, 1)]) [2, 2, 2, 6, 9] pass","solution":"def min_operations_to_transform(x, y): operations = 0 while x != y: if x < y: if y % 2 == 0: y = y // 2 else: y += 1 else: operations += x - y break operations += 1 return operations def solve(test_cases): results = [] for x, y in test_cases: results.append(min_operations_to_transform(x, y)) return results"},{"question":"from typing import List def can_meet(grid: List[List[str]]) -> str: Determine if Alice and Bob can meet on the grid. Alice starts at the top-left corner (0, 0) and Bob at the bottom-right corner (n-1, m-1). Each cell is either empty ('.') or blocked ('#'). They can move up, down, left, or right to an adjacent cell. >>> can_meet([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 'Yes' >>> can_meet([['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.']]) 'No' >>> can_meet([['.']]) 'Yes' >>> can_meet([['#']]) 'No' >>> can_meet([['.', '.'], ['#', '#']]) 'No' >>> can_meet([['#', '#', '.'], ['#', '.', '.'], ['.', '.', '.']]) 'No'","solution":"def can_meet(grid): def bfs(start, n, m): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = [start] visited = set() visited.add(start) while queue: x, y = queue.pop(0) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return visited n = len(grid) m = len(grid[0]) # If start or end position are blocked, return \\"No\\" if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"No\\" alice_reachable = bfs((0, 0), n, m) bob_reachable = bfs((n-1, m-1), n, m) if alice_reachable & bob_reachable: return \\"Yes\\" return \\"No\\""},{"question":"def maximize_unique_topics(n: int, k: int, sessions: List[Tuple[int, str]]) -> Tuple[int, List[int]]: This function returns the maximum number of unique topics Alexander can retain and the order of sessions to achieve this. :param n: int, number of sessions :param k: int, maximum number of consecutive days Alexander can retain topics :param sessions: list of tuples, each tuple contains an integer d and a string of length d :return: tuple, (maximum number of unique topics retained, list of session indices) >>> maximize_unique_topics(3, 7, [(4, \\"abcd\\"), (3, \\"cde\\"), (5, \\"efgab\\")]) (5, [1, 2]) >>> maximize_unique_topics(1, 5, [(3, \\"abc\\")]) (3, [1]) >>> maximize_unique_topics(1, 2, [(3, \\"abc\\")]) (0, [])","solution":"def maximize_unique_topics(n, k, sessions): This function returns the maximum number of unique topics Alexander can retain and the order of sessions to achieve this. :param n: int, number of sessions :param k: int, maximum number of consecutive days Alexander can retain topics :param sessions: list of tuples, each tuple contains an integer d and a string of length d :return: tuple, (maximum number of unique topics retained, list of session indices) topics = [] indices = [] for i in range(n): d, session_topics = sessions[i] if d <= k: topics.append(set(session_topics)) indices.append(i+1) if not topics: return 0, [] unique_topics = set() retained_sessions = [] current_days = 0 for i, topic_set in enumerate(topics): if current_days + len(topic_set) <= k: unique_topics.update(topic_set) retained_sessions.append(indices[i]) current_days += len(topic_set) else: break return len(unique_topics), retained_sessions"},{"question":"def find_two_sum_indices(n, t, array): Determines if there are two distinct integers in the array whose sum equals t. Parameters: n (int): Length of the array. t (int): Target sum. array (list of int): List of integers. Returns: str: \\"YES\\" followed by indices if a pair is found, else \\"NO\\". >>> find_two_sum_indices(4, 9, [2, 7, 11, 15]) \\"YESn1 2\\" >>> find_two_sum_indices(3, 10, [1, 2, 3]) \\"NO\\" >>> find_two_sum_indices(4, 0, [-1, 1, 2, -2]) \\"YESn1 2\\"","solution":"def find_two_sum_indices(n, t, array): Determines if there are two distinct integers in the array whose sum equals t. Parameters: n (int): Length of the array. t (int): Target sum. array (list of int): List of integers. Returns: str: \\"YES\\" followed by indices if a pair is found, else \\"NO\\". seen = {} for i in range(n): complement = t - array[i] if complement in seen: return f\\"YESn{seen[complement] + 1} {i + 1}\\" seen[array[i]] = i return \\"NO\\""},{"question":"def min_operations_to_alternate(n: int, s: str) -> int: Determine the minimum number of operations required to transform the string into an alternating character sequence. >>> min_operations_to_alternate(4, \\"baaa\\") 1 >>> min_operations_to_alternate(1, \\"a\\") 0 >>> min_operations_to_alternate(1, \\"b\\") 0 >>> min_operations_to_alternate(6, \\"ababab\\") 0 >>> min_operations_to_alternate(6, \\"bababa\\") 0 >>> min_operations_to_alternate(4, \\"aaaa\\") 2 >>> min_operations_to_alternate(4, \\"bbbb\\") 2 >>> min_operations_to_alternate(5, \\"ababa\\") 0 >>> min_operations_to_alternate(5, \\"babaa\\") 1 >>> min_operations_to_alternate(100000, \\"a\\" * 100000) 50000 >>> min_operations_to_alternate(100000, \\"b\\" * 100000) 50000","solution":"def min_operations_to_alternate(n, s): def mismatch_count(pattern, s): return sum(1 for i in range(len(s)) if s[i] != pattern[i % 2]) pattern1 = \\"ab\\" * (n // 2) + \\"a\\" * (n % 2) pattern2 = \\"ba\\" * (n // 2) + \\"b\\" * (n % 2) ops_pattern1 = mismatch_count(pattern1, s) ops_pattern2 = mismatch_count(pattern2, s) return min(ops_pattern1, ops_pattern2)"},{"question":"from typing import List def is_palindrome_possible(s: str) -> bool: Determine if it is possible to transform the string \`s\` into a palindrome by reversing any of its substrings. >>> is_palindrome_possible(\\"aab\\") True >>> is_palindrome_possible(\\"racecar\\") True >>> is_palindrome_possible(\\"civic\\") True >>> is_palindrome_possible(\\"abcdef\\") False # Implementation will be provided here. def transform_possible_to_palindrome(test_cases: List[str]) -> List[str]: Given a list of strings, determine whether each string can be transformed into a palindrome using the allowed operations. >>> transform_possible_to_palindrome([\\"aab\\", \\"racecar\\", \\"civic\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> transform_possible_to_palindrome([\\"aabbccdde\\", \\"aabbccdd\\", \\"aabbccddee\\", \\"ab\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> transform_possible_to_palindrome([\\"a\\"]) [\\"YES\\"] # Implementation will be provided here. if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def is_palindrome_possible(s): Determine if it is possible to transform the string \`s\` into a palindrome by reversing any of its substrings. # Count the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters that have an odd frequency odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # If there is more than 1 character with an odd frequency, it is not possible to form a palindrome return odd_count <= 1 def transform_possible_to_palindrome(test_cases): results = [] for s in test_cases: if is_palindrome_possible(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def process_operations(n: int, q: int, arr: List[int], operations: List[str]) -> List[int]: Process operations on an array and return results of point queries Args: n : int : Number of elements in the array q : int : Number of operations arr : list[int] : Initial values of the array operations : list[str] : List of operation strings Returns: list[int] : Result of each query operation >>> process_operations(5, 4, [1, 2, 3, 4, 5], [\\"add 1 3 10\\", \\"get 2\\", \\"add 2 5 5\\", \\"get 4\\"]) [12, 9] >>> process_operations(3, 3, [100, 200, 300], [\\"add 1 2 50\\", \\"get 1\\", \\"get 2\\"]) [150, 250] >>> process_operations(4, 3, [1, 2, 3, 4], [\\"get 1\\", \\"get 2\\", \\"get 3\\"]) [1, 2, 3] >>> process_operations(3, 1, [10, 20, 30], [\\"get 3\\"]) [30]","solution":"def process_operations(n, q, arr, operations): Process operations on an array and return results of point queries Args: n : int : Number of elements in the array q : int : Number of operations arr : list[int] : Initial values of the array operations : list[str] : List of operation strings Returns: list[int] : Result of each query operation # Initialize a difference array diff = [0] * (n + 1) # Helper function to apply the difference array to the original array def apply_diff(arr, diff): for i in range(n): if i == 0: arr[i] += diff[i] else: diff[i] += diff[i - 1] arr[i] += diff[i] results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 x = int(parts[3]) diff[l] += x if r + 1 < n: diff[r + 1] -= x elif parts[0] == \\"get\\": i = int(parts[1]) - 1 apply_diff(arr, diff) results.append(arr[i]) # Clear difference array as it has been applied diff = [0] * (n + 1) return results"},{"question":"def longest_increasing_subarray(n: int, step_counts: List[int]) -> int: Find the length of the longest subarray with strictly increasing step counts. Args: n (int): The number of days. step_counts (List[int]): A list of integers representing Lara's step counts for n days. Returns: int: The length of the longest subarray with strictly increasing step counts. >>> longest_increasing_subarray(6, [10, 20, 30, 10, 40, 50]) 3 >>> longest_increasing_subarray(5, [3, 3, 3, 3, 3]) 1 >>> longest_increasing_subarray(8, [1, 2, 3, 4, 3, 4, 5, 6]) 4 >>> longest_increasing_subarray(1, [5]) 1 >>> longest_increasing_subarray(5, [1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray(7, [1, 3, 5, 4, 2, 6, 8]) 3 >>> longest_increasing_subarray(4, [10, 10, 10, 10]) 1","solution":"def longest_increasing_subarray(n, step_counts): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if step_counts[i] > step_counts[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Example usage n = 6 step_counts = [10, 20, 30, 10, 40, 50] print(longest_increasing_subarray(n, step_counts)) # Output should be 3"},{"question":"def min_operations_to_make_increasing(arr: List[int]) -> int: Returns the minimum number of operations needed to make the array strictly increasing. >>> min_operations_to_make_increasing([4, 3, 2, 1, 6, 8]) 3 >>> min_operations_to_make_increasing([10, 1, 2, 3, 4]) 1 >>> min_operations_to_make_increasing([1, 2, 3]) 0 >>> min_operations_to_make_increasing([1]) 0 >>> min_operations_to_make_increasing([1, 2, 3, 4, 5]) 0 >>> min_operations_to_make_increasing([5, 4, 3, 2, 1]) 4 >>> min_operations_to_make_increasing([3, 1, 4, 2, 5]) 2","solution":"def min_operations_to_make_increasing(arr): Returns the minimum number of operations needed to make the array strictly increasing. n = len(arr) # We need to find the length of the longest increasing subsequence (LIS) first # In this case we use patience sorting method to find LIS in O(n log n) from bisect import bisect_right def lis_length(arr): lis = [] for val in arr: pos = bisect_right(lis, val) if pos < len(lis): lis[pos] = val else: lis.append(val) return len(lis) length_of_lis = lis_length(arr) # Minimum operations needed to make the array strictly increasing return n - length_of_lis"},{"question":"def compute_subgrid_sums(grid, queries): Compute the sums of all integers in specified subgrids of a given grid. Arguments: grid -- 2D list of integers representing the grid queries -- list of tuples (r1, c1, r2, c2) representing the subgrid queries Returns: list of integers where each integer is the sum of the respective subgrid from solution import compute_subgrid_sums def test_example(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(0, 0, 1, 1), (1, 1, 2, 2)] assert compute_subgrid_sums(grid, queries) == [12, 28] def test_single_cell_subgrid(): grid = [ [1, 2], [3, 4] ] queries = [(0, 0, 0, 0), (1, 1, 1, 1)] assert compute_subgrid_sums(grid, queries) == [1, 4] def test_entire_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(0, 0, 2, 2)] assert compute_subgrid_sums(grid, queries) == [45] def test_row_subgrid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 0, 1, 2)] assert compute_subgrid_sums(grid, queries) == [15] def test_column_subgrid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(0, 1, 2, 1)] assert compute_subgrid_sums(grid, queries) == [15]","solution":"def compute_subgrid_sums(grid, queries): Compute the sums of all integers in specified subgrids of a given grid. Arguments: grid -- 2D list of integers representing the grid queries -- list of tuples (r1, c1, r2, c2) representing the subgrid queries Returns: list of integers where each integer is the sum of the respective subgrid # Precompute the prefix sum n = len(grid) m = len(grid[0]) prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i+1][j+1] = grid[i][j] + prefix_sum[i+1][j] + prefix_sum[i][j+1] - prefix_sum[i][j] results = [] for r1, c1, r2, c2 in queries: total = (prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1]) results.append(total) return results"},{"question":"def validate_orders(n: int, m: int, orders: List[List[int]]) -> List[str]: Validate orders for an ice cream store which offers up to 3 scoops of flavors with optional toppings. Args: n (int): Number of available flavors m (int): Number of available toppings orders (List[List[int]]): List of orders with specified number of scoops with flavors and toppings Returns: List[str]: List indicating if orders are \\"VALID\\" or \\"INVALID\\" >>> validate_orders(5, 3, [[2, 1, 1, 2, 2], [3, 6, 0, 2, 1, 3, 3], [1, 4, 1]]) [\\"VALID\\", \\"INVALID\\", \\"VALID\\"] >>> validate_orders(4, 2, [[2, 2, 1, 4, 0], [1, 5, 1], [3, 3, 2, 2, 0, 1, 1], [3, 4, 3, 1, 0, 2, 2]]) [\\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"INVALID\\"] >>> validate_orders(1, 1, [[1, 1, 1], [1, 1, 0], [1, 2, 0]]) [\\"VALID\\", \\"VALID\\", \\"INVALID\\"]","solution":"def validate_orders(n, m, orders): results = [] for order in orders: k = order[0] valid = True for i in range(k): flavor, topping = order[2 * i + 1], order[2 * i + 2] if not (1 <= flavor <= n) or not (0 <= topping <= m): valid = False break results.append(\\"VALID\\" if valid else \\"INVALID\\") return results"},{"question":"from typing import List, Tuple def minimum_knights(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of knights needed to ensure every city in the kingdom is protected. Args: n (int): Number of cities. m (int): Number of roads. roads (List[Tuple[int, int]]): List of roads, where each road connects two cities. Returns: int: Minimum number of knights needed to protect all cities. >>> minimum_knights(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) 2 >>> minimum_knights(6, 2, [(1, 2), (3, 4)]) 4 >>> minimum_knights(1, 0, []) 1 >>> minimum_knights(3, 0, []) 3 >>> minimum_knights(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 pass def test_example_case(): n = 6 m = 6 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] assert minimum_knights(n, m, roads) == 2 def test_disconnected_graph(): n = 6 m = 2 roads = [(1, 2), (3, 4)] assert minimum_knights(n, m, roads) == 4 def test_single_city(): n = 1 m = 0 roads = [] assert minimum_knights(n, m, roads) == 1 def test_no_roads(): n = 3 m = 0 roads = [] assert minimum_knights(n, m, roads) == 3 def test_complete_graph(): n = 4 m = 6 roads = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert minimum_knights(n, m, roads) == 1","solution":"def minimum_knights(n, m, roads): from collections import defaultdict, deque def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 1: return 1 graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 for city in range(1, n + 1): if not visited[city]: bfs(city, visited) components += 1 return components"},{"question":"def min_operations_to_palindrome(s: str) -> int: Calculate the minimum number of operations required to transform the given string into a palindrome. >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0 def solve(test_cases: List[str]) -> List[int]: Given a list of strings, return a list with the minimum number of operations required to make each string a palindrome. >>> solve([\\"ab\\"]) [1] >>> solve([\\"abb\\", \\"abc\\"]) [1, 1] >>> solve([\\"racecar\\", \\"a\\", \\"aa\\"]) [0, 0, 0] >>> solve([\\"abcd\\", \\"abcba\\", \\"abcde\\"]) [2, 0, 2] >>> solve([\\"a\\" * 1000, \\"a\\" * 500 + \\"b\\" * 500]) [0, 500]","solution":"def min_operations_to_palindrome(s): length = len(s) count = 0 for i in range(len(s) // 2): if s[i] != s[length - i - 1]: count += 1 return count def solve(test_cases): results = [] for s in test_cases: results.append(min_operations_to_palindrome(s)) return results"},{"question":"def most_frequent_interval(sensor_data: List[List[int]]) -> List[int]: Returns the most frequent interval between consecutive data points for each sensor. Parameters: sensor_data (list of lists): Each sublist consists of the first integer n followed by n integers representing timestamps. Returns: list: A list of most frequent intervals for each sensor. Examples: >>> most_frequent_interval([[5, 1, 3, 5, 7, 9]]) [2] >>> most_frequent_interval([[4, 2, 5, 8, 11]]) [3] >>> most_frequent_interval([[5, 10, 20, 30, 40, 50]]) [10]","solution":"def most_frequent_interval(sensor_data): Returns the most frequent interval between consecutive data points for each sensor. Parameters: sensor_data (list of lists): Each sublist consists of the first integer n followed by n integers representing timestamps. Returns: list: A list of most frequent intervals for each sensor. from collections import Counter results = [] for data in sensor_data: n = data[0] timestamps = data[1:] intervals = [timestamps[i] - timestamps[i - 1] for i in range(1, n)] if len(intervals) == 0: results.append(0) continue interval_counts = Counter(intervals) most_frequent_interval = min([interval for interval, count in interval_counts.items() if count == max(interval_counts.values())]) results.append(most_frequent_interval) return results # Example usage: # sensor_data = [ # [5, 1, 3, 5, 7, 9], # [4, 2, 5, 8, 11], # [5, 10, 20, 30, 40, 50] # ] # print(most_frequent_interval(sensor_data)) # Output: [2, 3, 10]"},{"question":"def min_insertions_to_make_beautiful(s: str) -> int: Calculate the minimum number of characters to be inserted to make the string beautiful (i.e., have no two identical consecutive characters). Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of insertions required. >>> min_insertions_to_make_beautiful(\\"abc\\") == 0 >>> min_insertions_to_make_beautiful(\\"abb\\") == 1 >>> min_insertions_to_make_beautiful(\\"aabb\\") == 2 >>> min_insertions_to_make_beautiful(\\"a\\") == 0 >>> min_insertions_to_make_beautiful(\\"aaaaa\\") == 4","solution":"def min_insertions_to_make_beautiful(s): Calculate the minimum number of characters to be inserted to make the string beautiful (i.e., have no two identical consecutive characters). Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of insertions required. insertions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: insertions += 1 return insertions"},{"question":"from typing import List, Tuple def minimum_travel_cost(n: int, roads: List[Tuple[int, int, int]]) -> int: In a kingdom, there are n cities connected by m bidirectional roads. The cities are numbered from 1 to n. Each road connects two different cities and has a certain travel cost associated with it. Determine the minimum total travel cost of a new road network such that every city is accessible from every other city and as many of the existing roads are reused as possible. >>> minimum_travel_cost(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> minimum_travel_cost(3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] # This will hold the resultant MST i = 0 # Initial index for sorted edges e = 0 # Initial index for result[] edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimum_travel_cost(n, roads): return kruskal(n, roads)"},{"question":"def min_subarray_length(S: int, array: List[int]) -> int: Given an array of integers, find the length of the shortest contiguous subarray such that the sum of this subarray is greater than or equal to a given integer S. If there isn't one, return 0 instead. >>> min_subarray_length(15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> min_subarray_length(100, [1, 2, 3]) 0 >>> min_subarray_length(5, [1, 2, 5, 3]) 1 >>> min_subarray_length(21, [1, 2, 3, 4, 5, 6]) 6 >>> min_subarray_length(5, [6, 1, 4, 2]) 1 >>> min_subarray_length(15, [1, 2, 3, 4, 5, 10]) 2 pass # Your implementation here","solution":"def min_subarray_length(S, array): from sys import maxsize N = len(array) min_length = maxsize current_sum = 0 start = 0 for end in range(N): current_sum += array[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= array[start] start += 1 return min_length if min_length != maxsize else 0 # Example Usage of the function # N and S N = 10 S = 15 array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(min_subarray_length(S, array)) # Expected output: 2"},{"question":"def find_distinct_words(N, words, M, pairs): Determine all distinct words that can be formed by substituting synonyms in the given set of words. >>> N = 3 >>> words = [\\"happy\\", \\"joy\\", \\"cheerful\\"] >>> M = 2 >>> pairs = [(\\"happy\\", \\"joy\\"), (\\"joy\\", \\"cheerful\\")] >>> count, result = find_distinct_words(N, words, M, pairs) >>> count 3 >>> result [\\"cheerful\\", \\"happy\\", \\"joy\\"] >>> N = 4 >>> words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] >>> M = 0 >>> pairs = [] >>> count, result = find_distinct_words(N, words, M, pairs) >>> count 4 >>> result [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] >>> N = 3 >>> words = [\\"cat\\", \\"feline\\", \\"kitty\\"] >>> M = 2 >>> pairs = [(\\"cat\\", \\"feline\\"), (\\"feline\\", \\"kitty\\")] >>> count, result = find_distinct_words(N, words, M, pairs) >>> count 3 >>> result [\\"cat\\", \\"feline\\", \\"kitty\\"] >>> N = 5 >>> words = [\\"sun\\", \\"star\\", \\"moon\\", \\"satellite\\", \\"planet\\"] >>> M = 3 >>> pairs = [(\\"sun\\", \\"star\\"), (\\"moon\\", \\"satellite\\"), (\\"sun\\", \\"moon\\")] >>> count, result = find_distinct_words(N, words, M, pairs) >>> count 5 >>> result [\\"moon\\", \\"planet\\", \\"satellite\\", \\"star\\", \\"sun\\"]","solution":"def find_distinct_words(N, words, M, pairs): from collections import defaultdict # Helper function to perform DFS and find all connected words def dfs(word, seen, graph): stack = [word] component = set() while stack: current_word = stack.pop() if current_word not in seen: seen.add(current_word) component.add(current_word) for neighbor in graph[current_word]: if neighbor not in seen: stack.append(neighbor) return component # Create a graph representation of synonyms graph = defaultdict(set) for word1, word2 in pairs: graph[word1].add(word2) graph[word2].add(word1) # Use DFS to find all connected components seen = set() synonym_sets = [] for word in words: if word not in seen: component = dfs(word, seen, graph) synonym_sets.append(component) # Find distinct words by substituting synonyms distinct_words = set() for synonym_set in synonym_sets: distinct_words |= synonym_set result_list = sorted(distinct_words) return len(result_list), result_list # Sample usage N = 3 words = [\\"happy\\", \\"joy\\", \\"cheerful\\"] M = 2 pairs = [(\\"happy\\", \\"joy\\"), (\\"joy\\", \\"cheerful\\")] distinct_count, distinct_words = find_distinct_words(N, words, M, pairs) print(distinct_count) for word in distinct_words: print(word)"},{"question":"from typing import List, Tuple def minimum_travel_time(n: int, t: List[int], d: List[int]) -> int: Calculates the minimum travel time from the start station to the end station. Parameters: n (int): The number of stations. t (list): The list of travel times between consecutive stations. d (list): The list of delays at each station. Returns: int: The minimum total travel time. pass def process_input(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Processes multiple test cases to determine minimum travel times. Parameters: T (int): Number of test cases. test_cases (list): List of tuples containing (n, t, d) for each test case. Returns: list: List of minimum total travel times for each test case. pass def test_minimum_travel_time_case_1(): n = 3 t = [10, 15] d = [5, 0, 10] assert minimum_travel_time(n, t, d) == 40 def test_minimum_travel_time_case_2(): n = 4 t = [5, 10, 20] d = [3, 5, 0, 2] assert minimum_travel_time(n, t, d) == 45 def test_process_input(): T = 2 test_cases = [ (3, [10, 15], [5, 0, 10]), (4, [5, 10, 20], [3, 5, 0, 2]) ] assert process_input(T, test_cases) == [40, 45]","solution":"def minimum_travel_time(n, t, d): Calculates the minimum travel time from the start station to the end station. Parameters: n (int): The number of stations. t (list): The list of travel times between consecutive stations. d (list): The list of delays at each station. Returns: int: The minimum total travel time. total_time = d[0] # Initial delay at the start station for i in range(n - 1): total_time += t[i] + d[i + 1] return total_time def process_input(T, test_cases): Processes multiple test cases to determine minimum travel times. Parameters: T (int): Number of test cases. test_cases (list): List of tuples containing (n, t, d) for each test case. Returns: list: List of minimum total travel times for each test case. results = [] for i in range(T): n, t, d = test_cases[i] results.append(minimum_travel_time(n, t, d)) return results"},{"question":"from typing import List def min_moves(m: int, n: int, grid: List[str]) -> int: Determine the minimum number of moves required for the robot to reach the target position in the grid. The warehouse is represented by an m x n grid, where each cell can either be: - An open space (.) - A wall (#) - The robot's starting position (R) - The target position (T) The robot can move up, down, left, or right to any adjacent open space cell. It cannot move through walls. The robot's goal is to reach the target position in the minimum number of moves. If it is impossible for the robot to reach the target, the program should output -1. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[str]): The grid representation. Returns: int: The minimum number of moves required for the robot to reach the target, or -1 if it is impossible. Examples: >>> m, n = 5, 5 >>> grid = [ ... \\"R...#\\", ... \\".#.#.\\", ... \\".#..#\\", ... \\".#.\\", ... \\"...T.\\" ... ] >>> min_moves(m, n, grid) 7 >>> m, n = 3, 3 >>> grid = [ ... \\"R.#\\", ... \\"#\\", ... \\"..T\\" ... ] >>> min_moves(m, n, grid) -1 >>> m, n = 2, 2 >>> grid = [ ... \\"R.\\", ... \\".T\\" ... ] >>> min_moves(m, n, grid) 2 >>> m, n = 1, 2 >>> grid = [ ... \\"RT\\" ... ] >>> min_moves(m, n, grid) 1 >>> m, n = 100, 100 >>> grid = [ [\\".\\" for _ in range(100)] for _ in range(100) ] >>> grid[0][0] = 'R' >>> grid[99][99] = 'T' >>> min_moves(m, n, grid) 198","solution":"from collections import deque def min_moves(m, n, grid): def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#': yield nx, ny start = None target = None for i in range(m): for j in range(n): if grid[i][j] == 'R': start = (i, j) elif grid[i][j] == 'T': target = (i, j) if not start or not target: return -1 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_subsequence_sum(n: int, k: int, sequence: List[int]) -> int: Returns the maximum sum of a subsequence of length k in the given sequence. Example: >>> max_subsequence_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_subsequence_sum(4, 2, [-1, -2, -3, -4]) -3 >>> max_subsequence_sum(6, 3, [3, -1, 4, -1, 5, -9]) 12 >>> max_subsequence_sum(1, 1, [10]) 10 >>> max_subsequence_sum(6, 6, [1, 2, 3, 4, 5, 6]) 21 >>> max_subsequence_sum(2, 1, [-1, -2]) -1 >>> max_subsequence_sum(7, 3, [5, -2, -2, 4, 3, 1, -1]) 12 ...","solution":"def max_subsequence_sum(n, k, sequence): Returns the maximum sum of a subsequence of length k in the given sequence. # Sort the sequence in descending order sorted_sequence = sorted(sequence, reverse=True) # Take the first k elements from the sorted sequence max_sum = sum(sorted_sequence[:k]) return max_sum"},{"question":"def merge_sorted_arrays(n, arr1, arr2): Merges two sorted arrays into a single sorted array using the merge step of the Merge Sort algorithm. Parameters: - n (int): The length of the arrays arr1 and arr2. - arr1 (list of int): The first sorted array. - arr2 (list of int): The second sorted array. Returns: - list of int: The merged and sorted array. Example: >>> merge_sorted_arrays(3, [1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] from solution import merge_sorted_arrays def test_merge_basic(): arr1 = [1, 3, 5] arr2 = [2, 4, 6] result = merge_sorted_arrays(3, arr1, arr2) assert result == [1, 2, 3, 4, 5, 6] def test_merge_all_elements_smaller_in_first(): arr1 = [1, 2, 3, 4, 5] arr2 = [6, 7, 8, 9, 10] result = merge_sorted_arrays(5, arr1, arr2) assert result == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_merge_all_elements_smaller_in_second(): arr1 = [6, 7, 8, 9, 10] arr2 = [1, 2, 3, 4, 5] result = merge_sorted_arrays(5, arr1, arr2) assert result == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_merge_with_negative_numbers(): arr1 = [-3, -2, -1] arr2 = [0, 1, 2] result = merge_sorted_arrays(3, arr1, arr2) assert result == [-3, -2, -1, 0, 1, 2] def test_merge_with_duplicate_elements(): arr1 = [1, 3, 3, 5] arr2 = [2, 3, 3, 6] result = merge_sorted_arrays(4, arr1, arr2) assert result == [1, 2, 3, 3, 3, 3, 5, 6]","solution":"def merge_sorted_arrays(n, arr1, arr2): Merges two sorted arrays into a single sorted array using the merge step of the Merge Sort algorithm. Parameters: - n (int): The length of the arrays arr1 and arr2. - arr1 (list of int): The first sorted array. - arr2 (list of int): The second sorted array. Returns: - list of int: The merged and sorted array. merged_array = [] i, j = 0, 0 while i < n and j < n: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Add any remaining elements from arr1 or arr2 while i < n: merged_array.append(arr1[i]) i += 1 while j < n: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def max_profit(arr: List[int], n: int, k: int) -> int: Returns the maximum profit if it meets the threshold \`k\`. Otherwise, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4], 6, 5) 5 >>> max_profit([7, 1, 5, 3, 6, 4], 6, 7) 0 >>> max_profit([7, 6, 4, 3, 1], 5, 2) 0 >>> max_profit([7], 1, 5) 0 >>> max_profit([1, 2, 3, 4, 5], 5, 0) 4 >>> max_profit([1, 2, 3, 4, 5], 5, 4) 4 >>> max_profit([1000000000, 1, 1000000000], 3, 999999999) 999999999","solution":"def max_profit(arr, n, k): Returns the maximum profit if it meets the threshold \`k\`. Otherwise, returns 0. if n <= 1: return 0 min_price = arr[0] max_profit = 0 for i in range(1, n): # Compare current price with min_price and update max_profit accordingly max_profit = max(max_profit, arr[i] - min_price) # Update min_price to be the lowest price seen so far min_price = min(min_price, arr[i]) return max_profit if max_profit >= k else 0"},{"question":"def library_loan_system(n: int, transactions: List[int]) -> List[int]: This function takes in the number of transactions and a list of transactions and returns the final state of books in the library (positive for loaned out, negative for returned). Parameters: n (int): The number of transactions transactions (list of int): List of transaction identifiers Returns: list: A list of unique book identifiers sorted in ascending order (positive for loaned out, negative for returned) >>> library_loan_system(6, [1, 2, 3, -1, -2, 4]) [3, 4] >>> library_loan_system(5, [1, -1, 2, 2, -2]) [2] >>> library_loan_system(4, [1, 2, 3, 4]) [1, 2, 3, 4] >>> library_loan_system(4, [1, -1, 2, -2]) []","solution":"def library_loan_system(n, transactions): This function takes in the number of transactions and a list of transactions and returns the final state of books in the library Parameters: n (int): The number of transactions transactions (list of int): List of transaction identifiers Returns: list: A list of unique book identifiers sorted in ascending order (positive for loaned out, negative for returned) book_state = {} for transaction in transactions: book_id = abs(transaction) if transaction > 0: book_state[book_id] = book_state.get(book_id, 0) + 1 else: book_state[book_id] = max(book_state.get(book_id, 0) - 1, 0) final_state = [] for book_id in sorted(book_state): if book_state[book_id] > 0: final_state.append(book_id) return final_state"},{"question":"from typing import List def is_valid(board: List[List[int]], row: int, col: int, num: int) -> bool: Check if a number can be placed in a given position on the Sudoku board. >>> is_valid([ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ], 0, 2, 4) == True >>> is_valid([ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ], 0, 2, 5) == False pass def solve(board: List[List[int]]) -> bool: Solve the Sudoku puzzle. pass def can_solve_sudoku(board: List[List[int]]) -> str: Determine if a valid Sudoku board can be achieved from the given board. >>> can_solve_sudoku([ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ]) == \\"YES\\" >>> can_solve_sudoku([ [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0] ]) == \\"YES\\" pass def check_sudoku_cases(t: int, test_cases: List[List[List[int]]]) -> List[str]: Check multiple Sudoku cases. >>> check_sudoku_cases(2, [ [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ], [ [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0] ] ]) == [\\"YES\\", \\"YES\\"] pass","solution":"def is_valid(board, row, col, num): # Check the row for c in range(9): if board[row][c] == num: return False # Check the column for r in range(9): if board[r][col] == num: return False # Check the 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): if board[r][c] == num: return False return True def solve(board): for r in range(9): for c in range(9): if board[r][c] == 0: for num in range(1, 10): if is_valid(board, r, c, num): board[r][c] = num if solve(board): return True board[r][c] = 0 return False # If no number is valid in this cell return True # Solved successfully def can_solve_sudoku(board): if solve(board): return \\"YES\\" else: return \\"NO\\" def check_sudoku_cases(t, test_cases): results = [] for i in range(t): board = test_cases[i] results.append(can_solve_sudoku(board)) return results"},{"question":"from typing import List def count_ways(n: int, weights: List[int]) -> int: Returns the number of distinct ways to organize the rocks into a single box maintaining the non-decreasing order. >>> count_ways(4, [3, 1, 2, 2]) 12 >>> count_ways(1, [5]) 1 >>> count_ways(3, [2, 2, 2]) 1 >>> count_ways(3, [1, 2, 3]) 6 >>> count_ways(5, [1, 1, 2, 2, 2]) 10 # Unit Tests def test_count_ways_example_1(): assert count_ways(4, [3, 1, 2, 2]) == 12 def test_count_ways_single_rock(): assert count_ways(1, [5]) == 1 def test_count_ways_all_identical_weights(): assert count_ways(3, [2, 2, 2]) == 1 def test_count_ways_unique_weights(): assert count_ways(3, [1, 2, 3]) == 6 def test_count_ways_multiple_repetitions(): assert count_ways(5, [1, 1, 2, 2, 2]) == 10 def test_count_ways_large_input(): large_input = [i % 10 for i in range(1000)] assert count_ways(1000, large_input) == math.factorial(1000) // (math.factorial(100) ** 10)","solution":"import math from collections import Counter def count_ways(n, weights): Returns the number of distinct ways to organize the rocks into a single box maintaining the non-decreasing order. # Count occurrences of each weight counter = Counter(weights) # Calculate the total number of permutations of the multiset numerator = math.factorial(n) denominator = 1 for value in counter.values(): denominator *= math.factorial(value) return numerator // denominator # Example usage number_of_rocks = 4 rocks_weights = [3, 1, 2, 2] distinct_ways = count_ways(number_of_rocks, rocks_weights) print(distinct_ways)"},{"question":"def count_paths(T: int, test_cases: List[Tuple[int, int, int, List[Tuple[int, int]]]]) -> List[int]: Given the number of test cases, find the number of distinct paths for each test case for a robot to reach the bottom-right cell from the top-left cell in a grid with blocked cells. >>> count_paths(2, [(3, 3, 1, [(2, 2)]), (3, 3, 2, [(2, 2), (2, 3)])]) [2, 1] >>> count_paths(1, [(3, 3, 0, [])]) [6] >>> count_paths(1, [(3, 3, 1, [(1, 1)])]) [0] >>> count_paths(1, [(3, 3, 1, [(3, 3)])]) [0]","solution":"def count_paths(T, test_cases): MOD = 1_000_000_007 def compute_paths(N, M, blocked_set): if (1, 1) in blocked_set or (N, M) in blocked_set: return 0 dp = [[0] * (M + 1) for _ in range(N + 1)] dp[1][1] = 1 for i in range(1, N + 1): for j in range(1, M + 1): if (i, j) != (1, 1) and (i, j) not in blocked_set: dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD return dp[N][M] results = [] for case in test_cases: N, M, B, blocked_cells = case blocked_set = set(blocked_cells) result = compute_paths(N, M, blocked_set) results.append(result) return results"},{"question":"def final_robot_position(commands: str) -> (int, int): This function takes a string of commands and returns the final position (x, y) of the robot. >>> final_robot_position(\\"UD\\") (0, 0) >>> final_robot_position(\\"LLRR\\") (0, 0) >>> final_robot_position(\\"UUDDLLRR\\") (0, 0) >>> final_robot_position(\\"UUU\\") (0, 3) >>> final_robot_position(\\"RRRDD\\") (3, -2) >>> final_robot_position(\\"\\") (0, 0) def process_test_cases(test_cases: List[str]) -> List[(int, int)]: This function processes a list of test cases, where each test case is a string of commands. Returns a list of resulting positions for each test case. >>> process_test_cases([\\"UD\\", \\"LLRR\\", \\"UUDDLLRR\\"]) [(0, 0), (0, 0), (0, 0)] >>> process_test_cases([\\"UUU\\", \\"RRRDD\\", \\"\\"]) [(0, 3), (3, -2), (0, 0)]","solution":"def final_robot_position(commands): This function takes a string of commands and returns the final position (x, y) of the robot. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y def process_test_cases(test_cases): This function processes a list of test cases, where each test case is a string of commands. Returns a list of resulting positions for each test case. results = [] for commands in test_cases: final_position = final_robot_position(commands) results.append(final_position) return results"},{"question":"from typing import List, Tuple def max_path_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: You are given a tree (a connected undirected graph with no cycles) with n vertices. Each vertex has a value associated with it. Your task is to find the maximum sum of values along any path in the tree. A path is defined as a sequence of vertices where each adjacent pair of vertices in the sequence is connected by an edge in the tree. Examples: >>> max_path_sum(5, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) 15 >>> max_path_sum(3, [10, 20, 30], [(1, 2), (1, 3)]) 60 >>> max_path_sum(4, [5, 5, 5, 5], [(1, 2), (1, 3), (1, 4)]) 20 >>> max_path_sum(1, [100], []) 100 >>> max_path_sum(2, [1, 2], [(1, 2)]) 3","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) def build_tree(edges, n): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def max_path_sum(n, values, edges): tree = build_tree(edges, n) visited = [False] * (n + 1) max_sum = [0] * (n + 1) def dfs(node): visited[node] = True curr_sum = values[node - 1] for neighbor in tree[node]: if not visited[neighbor]: curr_sum += dfs(neighbor) max_sum[node] = max(max_sum[node], curr_sum) return curr_sum for i in range(1, n + 1): if not visited[i]: dfs(i) return max(max_sum) # Example usage: n = 5 values = [1, 2, 3, 4, 5] edges = [ (1, 2), (2, 3), (3, 4), (4, 5) ] print(max_path_sum(n, values, edges)) # Output: 15"},{"question":"class Garden: def __init__(self, flowerbeds): self.flowerbeds = flowerbeds self.n = len(flowerbeds) def update(self, x, y): Remove exactly y flowers from the x-th flowerbed. self.flowerbeds[x - 1] -= y def query_total(self, x): Print the total number of flowers in the x-th flowerbed after performing all operations up to the current point. return self.flowerbeds[x - 1] def query_section(self, x, y): Print the total number of flowers in the flowerbeds from x to y inclusive, after performing all operations up to the current point. return sum(self.flowerbeds[x - 1:y]) def process_queries(flowerbeds, queries): Process and handle the queries on the garden. >>> flowerbeds = [10, 20, 30, 40, 50] >>> queries = [ ... [1, 2, 5], # Update: 2nd flowerbed, remove 5 flowers => [10, 15, 30, 40, 50] ... [2, 2], # Query Total: 2nd flowerbed => 15 ... [3, 1, 3], # Query Section: 1st to 3rd flowerbed => 10 + 15 + 30 = 55 ... [2, 4], # Query Total: 4th flowerbed => 40 ... ] >>> expected_results = [15, 55, 40] >>> process_queries(flowerbeds, queries) == expected_results True garden = Garden(flowerbeds) results = [] for query in queries: if query[0] == 1: garden.update(query[1], query[2]) elif query[0] == 2: results.append(garden.query_total(query[1])) elif query[0] == 3: results.append(garden.query_section(query[1], query[2])) return results # Unit test def test_update(): garden = Garden([10, 20, 30, 40, 50]) garden.update(2, 5) assert garden.flowerbeds == [10, 15, 30, 40, 50] def test_query_total(): garden = Garden([10, 15, 30, 40, 50]) assert garden.query_total(2) == 15 def test_query_section(): garden = Garden([10, 15, 30, 40, 50]) assert garden.query_section(1, 3) == 55 assert garden.query_section(2, 4) == 85 def test_process_queries(): flowerbeds = [10, 20, 30, 40, 50] queries = [ [1, 2, 5], # Update: 2nd flowerbed, remove 5 flowers => [10, 15, 30, 40, 50] [2, 2], # Query Total: 2nd flowerbed => 15 [3, 1, 3], # Query Section: 1st to 3rd flowerbed => 10 + 15 + 30 = 55 [2, 4], # Query Total: 4th flowerbed => 40 ] expected_results = [15, 55, 40] assert process_queries(flowerbeds, queries) == expected_results","solution":"class Garden: def __init__(self, flowerbeds): self.flowerbeds = flowerbeds self.n = len(flowerbeds) def update(self, x, y): self.flowerbeds[x - 1] -= y def query_total(self, x): return self.flowerbeds[x - 1] def query_section(self, x, y): return sum(self.flowerbeds[x - 1:y]) def process_queries(n, queries): garden = Garden(n) results = [] for query in queries: if query[0] == 1: garden.update(query[1], query[2]) elif query[0] == 2: results.append(garden.query_total(query[1])) elif query[0] == 3: results.append(garden.query_section(query[1], query[2])) return results"},{"question":"def generate_lcg_sequence(a: int, c: int, m: int, X0: int, k: int) -> list: Generates the first k numbers in the sequence using a Linear Congruential Generator (LCG). Parameters: a (int): Multiplier c (int): Increment m (int): Modulus X0 (int): Initial seed k (int): Number of terms to generate Returns: list: The first k numbers in the LCG sequence pass def format_lcg_sequence(a: int, c: int, m: int, X0: int, k: int) -> str: Generates and formats the first k numbers in the LCG sequence as a space-separated string. Parameters: a (int): Multiplier c (int): Increment m (int): Modulus X0 (int): Initial seed k (int): Number of terms to generate Returns: str: Space-separated string of k numbers in the LCG sequence pass # Example usage: # >>> format_lcg_sequence(2, 3, 5, 1, 10) # \\"1 0 3 4 1 0 3 4 1 0\\" from solution import generate_lcg_sequence, format_lcg_sequence def test_generate_lcg_sequence(): assert generate_lcg_sequence(2, 3, 5, 1, 10) == [1, 0, 3, 4, 1, 0, 3, 4, 1, 0] assert generate_lcg_sequence(1, 1, 10, 0, 5) == [0, 1, 2, 3, 4] assert generate_lcg_sequence(4, 1, 8, 2, 6) == [2, 1, 5, 5, 5, 5] assert generate_lcg_sequence(3, 0, 7, 4, 4) == [4, 5, 1, 3] def test_format_lcg_sequence(): assert format_lcg_sequence(2, 3, 5, 1, 10) == \\"1 0 3 4 1 0 3 4 1 0\\" assert format_lcg_sequence(1, 1, 10, 0, 5) == \\"0 1 2 3 4\\" assert format_lcg_sequence(4, 1, 8, 2, 6) == \\"2 1 5 5 5 5\\" assert format_lcg_sequence(3, 0, 7, 4, 4) == \\"4 5 1 3\\"","solution":"def generate_lcg_sequence(a, c, m, X0, k): Generates the first k numbers in the sequence using a Linear Congruential Generator (LCG). Parameters: a (int): Multiplier c (int): Increment m (int): Modulus X0 (int): Initial seed k (int): Number of terms to generate Returns: list: The first k numbers in the LCG sequence sequence = [X0] for _ in range(1, k): X0 = (a * X0 + c) % m sequence.append(X0) return sequence def format_lcg_sequence(a, c, m, X0, k): Generates and formats the first k numbers in the LCG sequence as a space-separated string. Parameters: a, c, m, X0, k as described in \`generate_lcg_sequence\`. Returns: str: Space-separated string of k numbers in the LCG sequence sequence = generate_lcg_sequence(a, c, m, X0, k) return ' '.join(map(str, sequence))"},{"question":"def count_woodlands(n: int, m: int, grid: List[List[int]]) -> int: Counts the number of distinct woodlands in the grid. :param n: Rows count of the grid. :param m: Columns count of the grid. :param grid: 2D list representing the grid. :return: Number of distinct woodlands. >>> count_woodlands(4, 5, [ ... [1, 1, 0, 0, 0], ... [0, 1, 0, 0, 1], ... [1, 0, 0, 1, 1], ... [0, 0, 0, 0, 1] ... ]) 3 >>> count_woodlands(3, 3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 5 >>> count_woodlands(2, 2, [ ... [1, 1], ... [1, 1] ... ]) 1 >>> count_woodlands(1, 1, [ ... [0] ... ]) 0 >>> count_woodlands(3, 3, [ ... [0, 0, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) 2","solution":"def count_woodlands(n, m, grid): Counts the number of distinct woodlands in the grid. :param n: Rows count of the grid. :param m: Columns count of the grid. :param grid: 2D list representing the grid. :return: Number of distinct woodlands. def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < n and 0 <= j < m and grid[i][j] == 1: grid[i][j] = -1 stack.extend([(i-1, j), (i+1, j), (i, j-1), (i, j+1)]) woodlands_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: dfs(i, j) woodlands_count += 1 return woodlands_count # Example usage (this part will not be included in the final solution for the exercise) n = 4 m = 5 grid = [ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 1] ] print(count_woodlands(n, m, grid)) # Output should be 3"},{"question":"def contains_all_digits(s: str) -> str: Checks if the string s contains all digits from 0 to 9 at least once. >>> contains_all_digits(\\"202345678901234567890\\") 'Yes' >>> contains_all_digits(\\"todayis20thnof2021year\\") 'No' >>> contains_all_digits(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRST\\") 'No' >>> contains_all_digits(\\"12345!@#%^&*()67890_+-=\\") 'Yes' >>> contains_all_digits(\\"11223344556677889999555\\") 'No' >>> contains_all_digits(\\"a1b2c3d4e5f6g7h8i9j0\\") 'Yes' >>> contains_all_digits(\\"0123456789\\") 'Yes' pass","solution":"def contains_all_digits(s): Checks if the string s contains all digits from 0 to 9 at least once. digit_set = set('0123456789') for char in s: if char in digit_set: digit_set.remove(char) if not digit_set: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def min_operations_to_make_good(numbers: List[int]) -> int: Determine the minimum number of operations required to make all elements in the array distinct. >>> min_operations_to_make_good([1, 2, 3, 4, 5]) 0 >>> min_operations_to_make_good([1, 1, 2, 3]) 1 >>> min_operations_to_make_good([1, 1, 1, 1, 1]) 4 >>> min_operations_to_make_good([1000000000, 1000000000]) 1 >>> min_operations_to_make_good([4, 5, 4, 5]) 2 >>> min_operations_to_make_good([10]) 0 >>> min_operations_to_make_good([1, 2, 3, 2, 3]) 2 >>> min_operations_to_make_good([1,2,3,4,5,6,7,8,9,10,1]) 1","solution":"def min_operations_to_make_good(numbers): Determine the minimum number of operations required to make all elements in the array distinct. import collections n = len(numbers) # Count the occurrences of each number counter = collections.Counter(numbers) # Set to keep track of all available unique numbers unique_numbers = set(numbers) operations = 0 # Iterate over the elements to find duplicates for number, count in counter.items(): while count > 1: # More than 1 occurrence count -= 1 operations += 1 new_number = number + 1 # Find a new unique number while new_number in unique_numbers: new_number += 1 unique_numbers.add(new_number) return operations"},{"question":"from typing import List def max_people_allocated(n: int, m: int, people: List[List[int]], rooms: List[List[int]]) -> int: Returns the maximum number of people that can be allocated to rooms given the constraints. :param n: Number of people :param m: Number of rooms :param people: List of people's attributes :param rooms: List of room's capacity and requirements :return: Maximum number of people that can be allocated # Implementation Here # Unit tests def test_example_case(): n = 4 m = 2 people = [ [2, 4], [4, 6], [5, 10], [7, 8] ] rooms = [ [2, 5, 7], [3, 2, 3] ] assert max_people_allocated(n, m, people, rooms) == 5 def test_no_allocations_due_to_requirements(): n = 3 m = 1 people = [ [1, 2], [2, 3], [3, 4] ] rooms = [ [2, 5, 5] ] assert max_people_allocated(n, m, people, rooms) == 0 def test_exact_fit_for_room_capacity(): n = 4 m = 1 people = [ [4, 4], [2, 2], [3, 3], [1, 1] ] rooms = [ [2, 1, 1] ] assert max_people_allocated(n, m, people, rooms) == 2 def test_multiple_rooms_with_overlapping_requirements(): n = 5 m = 3 people = [ [4, 4], [5, 5], [6, 6], [7, 7], [8, 8] ] rooms = [ [2, 4, 4], [2, 5, 5], [1, 7, 7] ] assert max_people_allocated(n, m, people, rooms) == 5 def test_large_input(): n = 1000 m = 1 people = [[i+1] * 5 for i in range(n)] rooms = [[1000, 1, 1, 1, 1, 1]] assert max_people_allocated(n, m, people, rooms) == 1000","solution":"def max_people_allocated(n, m, people, rooms): Returns the maximum number of people that can be allocated to rooms given the constraints. :param n: Number of people :param m: Number of rooms :param people: List of people's attributes :param rooms: List of room's capacity and requirements :return: Maximum number of people that can be allocated # Function to check if a person can be allocated to a room def can_allocate(person, room_requirements): for i in range(len(room_requirements)): if person[i] < room_requirements[i]: return False return True # Sorting rooms by capacity in descending order to maximize utilization rooms_sorted = sorted(rooms, key=lambda x: -x[0]) total_allocated = 0 for room in rooms_sorted: capacity = room[0] requirements = room[1:] allocated = 0 for person in people: if allocated < capacity and can_allocate(person, requirements): allocated += 1 total_allocated += allocated return total_allocated"},{"question":"def knapsack(n, W, items): Returns the maximum value that can be carried in a knapsack with capacity W. :param n: Number of gemstones. :param W: Maximum weight capacity of the knapsack. :param items: List of tuples, where each tuple contains weight and value of each gemstone. :return: Maximum value that can be carried. pass def parse_input(data): Parses input data for the knapsack problem. :param data: Multiline string where the first line contains two integers n and W, and each of the next n lines contains two integers wi and vi. :return: Tuple containing n, W and a list of tuples with each tuple containing weight and value of each gemstone. pass # You can use the following test cases to evaluate your implementation. if __name__ == \\"__main__\\": def test_knapsack_example1(): data = 4 10 5 10 4 40 6 30 4 50 n, W, items = parse_input(data) assert knapsack(n, W, items) == 90 def test_knapsack_example2(): data = 3 50 10 60 20 100 30 120 n, W, items = parse_input(data) assert knapsack(n, W, items) == 220 def test_knapsack_minimal_case(): data = \\"1 1n1 10\\" n, W, items = parse_input(data) assert knapsack(n, W, items) == 10 def test_knapsack_bag_too_small(): data = \\"2 1n2 10n3 20\\" n, W, items = parse_input(data) assert knapsack(n, W, items) == 0 def test_knapsack_heavy_gem_still_fits(): data = \\"2 5n1 10n6 15\\" n, W, items = parse_input(data) assert knapsack(n, W, items) == 10 def test_knapsack_all_gems_fit(): data = \\"3 6n1 10n2 20n3 30\\" n, W, items = parse_input(data) assert knapsack(n, W, items) == 60 test_knapsack_example1() test_knapsack_example2() test_knapsack_minimal_case() test_knapsack_bag_too_small() test_knapsack_heavy_gem_still_fits() test_knapsack_all_gems_fit()","solution":"def knapsack(n, W, items): Returns the maximum value that can be carried in a knapsack with capacity W. :param n: Number of gemstones. :param W: Maximum weight capacity of the knapsack. :param items: List of tuples, where each tuple contains weight and value of each gemstone. :return: Maximum value that can be carried. # Initialize the DP table dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): wi, vi = items[i-1] for w in range(1, W + 1): if wi > w: dp[i][w] = dp[i-1][w] else: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + vi) return dp[n][W] # Parsing input example to illustrate def parse_input(data): lines = data.split('n') n, W = map(int, lines[0].split()) items = [] for i in range(1, n + 1): wi, vi = map(int, lines[i].split()) items.append((wi, vi)) return n, W, items # Example usage if __name__ == \\"__main__\\": data = 4 10 5 10 4 40 6 30 4 50 n, W, items = parse_input(data) print(knapsack(n, W, items)) # Output: 90"},{"question":"def min_moves(n: int, m: int, board: List[str]) -> int: Returns the minimum number of moves required for Jamie to reach the bottom-right corner of the board, or -1 if it is not possible. >>> min_moves(5, 5, [\\".....\\", \\".#...\\", \\".#.#.\\", \\".#.#.\\", \\".....\\"]) 8 >>> min_moves(4, 4, [\\"\\", \\"\\", \\"\\", \\"\\"]) -1 >>> min_moves(1, 1, [\\".\\"]) 0 >>> min_moves(3, 2, [\\"..\\", \\"#.\\", \\"..\\"]) 3 >>> min_moves(5, 5, [\\"..#..\\", \\"..#..\\", \\".....\\", \\".#.#.\\", \\".....\\"]) 8","solution":"from collections import deque def min_moves(n, m, board): Returns the minimum number of moves required for Jamie to reach the bottom-right corner of the board, or -1 if it is not possible. # Directions for movement (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If reached bottom-right corner if x == n - 1 and y == m - 1: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and board[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If no path found return -1"},{"question":"class GadgetStore: def __init__(self, sales): Initialize the GadgetStore with sales data and build the segment tree. pass def update(self, idx, value): Update the daily sales number of the x-th device to y. pass def sum_range(self, left, right): Calculate the sum of daily sales numbers of devices from index l to index r (inclusive). pass def process_queries(n, q, sales, queries): Process multiple queries to find the sum of sales numbers for any subarray, or update the sales number for a specific device. Args: n : int : number of devices q : int : number of queries sales : List[int] : initial daily sales numbers of the devices queries : List[List[int]] : queries to process Returns: List[int] : results of sum range queries >>> process_queries(5, 3, [2, 4, 5, 1, 6], [[2, 1, 3], [1, 3, 10], [2, 2, 5]]) [11, 21] pass def test_process_queries(): n = 5 q = 3 sales = [2, 4, 5, 1, 6] queries = [ [2, 1, 3], [1, 3, 10], [2, 2, 5], ] expected_output = [11, 21] assert process_queries(n, q, sales, queries) == expected_output def test_process_queries_single_update(): n = 1 q = 1 sales = [5] queries = [ [1, 1, 10] ] expected_output = [] assert process_queries(n, q, sales, queries) == expected_output def test_process_queries_single_sum(): n = 1 q = 1 sales = [5] queries = [ [2, 1, 1] ] expected_output = [5] assert process_queries(n, q, sales, queries) == expected_output def test_process_queries_update_and_sum(): n = 3 q = 4 sales = [3, 7, 9] queries = [ [2, 1, 3], [1, 2, 5], [2, 1, 3], [2, 2, 3], ] expected_output = [19, 17, 14] assert process_queries(n, q, sales, queries) == expected_output","solution":"class GadgetStore: def __init__(self, sales): self.sales = sales self.n = len(sales) self.segment_tree = [0] * (4 * self.n) self.build_segment_tree(0, self.n - 1, 0) def build_segment_tree(self, start, end, node): if start == end: self.segment_tree[node] = self.sales[start] else: mid = (start + end) // 2 self.build_segment_tree(start, mid, 2*node + 1) self.build_segment_tree(mid + 1, end, 2*node + 2) self.segment_tree[node] = self.segment_tree[2*node + 1] + self.segment_tree[2*node + 2] def update(self, idx, value): self.update_segment_tree(0, self.n - 1, idx - 1, value, 0) def update_segment_tree(self, start, end, idx, value, node): if start == end: self.sales[idx] = value self.segment_tree[node] = value else: mid = (start + end) // 2 if start <= idx <= mid: self.update_segment_tree(start, mid, idx, value, 2*node + 1) else: self.update_segment_tree(mid + 1, end, idx, value, 2*node + 2) self.segment_tree[node] = self.segment_tree[2*node + 1] + self.segment_tree[2*node + 2] def sum_range(self, left, right): return self.query_segment_tree(0, self.n - 1, left - 1, right - 1, 0) def query_segment_tree(self, start, end, left, right, node): if left <= start and end <= right: return self.segment_tree[node] if end < left or start > right: return 0 mid = (start + end) // 2 return self.query_segment_tree(start, mid, left, right, 2*node + 1) + self.query_segment_tree(mid + 1, end, left, right, 2*node + 2) def process_queries(n, q, sales, queries): gadget_store = GadgetStore(sales) results = [] for query in queries: if query[0] == 1: gadget_store.update(query[1], query[2]) elif query[0] == 2: result = gadget_store.sum_range(query[1], query[2]) results.append(result) return results"},{"question":"def clean_route(n: int, log: List[Tuple[float, float, float]]) -> List[Tuple[float, float, float]]: Removes redundant consecutive data points from the log. Args: n: int: number of logged data points log: List[Tuple[float, float, float]]: list of logged data points, each entry is a tuple (t, x, y) Returns: List[Tuple[float, float, float]]: cleaned list of logged data points from typing import List, Tuple def test_clean_route_no_redundant(): log = [(1, 40.7128, -74.0060), (2, 40.7128, -74.0059), (3, 40.7128, -74.0060), (4, 40.7130, -74.0062), (5, 40.7130, -74.0062)] expected = [(1, 40.7128, -74.0060), (2, 40.7128, -74.0059), (3, 40.7128, -74.0060), (4, 40.7130, -74.0062)] assert clean_route(len(log), log) == expected def test_clean_route_with_redundant(): log = [(1, 39.1234, -84.5034), (2, 39.1234, -84.5034), (3, 39.1240, -84.5038), (4, 39.1240, -84.5038), (5, 39.1247, -84.5042), (6, 39.1247, -84.5042)] expected = [(1, 39.1234, -84.5034), (3, 39.1240, -84.5038), (5, 39.1247, -84.5042)] assert clean_route(len(log), log) == expected def test_clean_route_single_entry(): log = [(1, 39.1234, -84.5034)] expected = [(1, 39.1234, -84.5034)] assert clean_route(len(log), log) == expected def test_clean_route_all_redundant(): log = [(1, 39.1234, -84.5034), (2, 39.1234, -84.5034), (3, 39.1234, -84.5034)] expected = [(1, 39.1234, -84.5034)] assert clean_route(len(log), log) == expected def test_clean_route_no_entries(): log = [] expected = [] assert clean_route(len(log), log) == expected","solution":"def clean_route(n, log): Removes redundant consecutive data points from the log. Args: n : int : number of logged data points log : list : list of logged data points, each entry is a tuple (t, x, y) Returns: list : cleaned list of logged data points if n == 0: return [] cleaned_log = [log[0]] for i in range(1, n): if log[i][1:] != log[i-1][1:]: # checks if current coordinates are different from previous cleaned_log.append(log[i]) return cleaned_log # Example usage: # n = int(input()) # log = [tuple(map(float, input().split())) for _ in range(n)] # cleaned_log = clean_route(n, log) # for entry in cleaned_log: # print(f\\"{entry[0]} {entry[1]} {entry[2]}\\")"},{"question":"from typing import List def shortest_path(lab: List[List[str]], m: int, n: int) -> int: Determines the shortest path from the top-left corner to the bottom-right corner avoiding hazardous cells. :param lab: List of Lists representing the laboratory matrix :param m: Number of rows :param n: Number of columns :return: The length of the shortest path, or -1 if it is not possible to reach the destination. >>> lab = [ ... ['1', '1', '1', '1'], ... ['1', '0', '0', '1'], ... ['1', '1', '1', '1'], ... ['1', '2', '2', '1'] ... ] >>> shortest_path(lab, 4, 4) 7 >>> lab = [ ... ['1', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '1'] ... ] >>> shortest_path(lab, 4, 4) -1 >>> lab = [ ... ['0', '1', '1', '1'], ... ['1', '0', '0', '1'], ... ['1', '1', '1', '1'], ... ['1', '2', '2', '1'] ... ] >>> shortest_path(lab, 4, 4) -1 >>> lab = [ ... ['1', '1', '1', '1'], ... ['1', '0', '0', '1'], ... ['1', '1', '1', '1'], ... ['1', '2', '2', '0'] ... ] >>> shortest_path(lab, 4, 4) -1 >>> lab = [ ... ['1'] ... ] >>> shortest_path(lab, 1, 1) 1","solution":"from collections import deque def shortest_path(lab, m, n): Determines the shortest path from the top-left corner to the bottom-right corner avoiding hazardous cells. :param lab: List of Lists representing the laboratory matrix :param m: Number of rows :param n: Number of columns :return: The length of the shortest path, or -1 if it is not possible to reach the destination. if lab[0][0] != '1' or lab[m-1][n-1] != '1': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist + 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and lab[nx][ny] == '1': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_simultaneous_generation(events: List[str]) -> int: Returns the maximum amount of power generated simultaneously based on the events. Args: events (list of str): List of event strings in the format \\"+ G X\\" or \\"- C X\\". Returns: int: The maximum simultaneous power generation. >>> max_simultaneous_generation([\\"+ 1 10\\", \\"+ 2 20\\", \\"- 1 5\\", \\"+ 3 15\\", \\"- 2 10\\"]) 40 >>> max_simultaneous_generation([\\"+ 1 10\\", \\"+ 2 15\\", \\"+ 3 20\\"]) 45 >>> max_simultaneous_generation([\\"+ 1 10\\", \\"+ 2 20\\", \\"- 1 10\\", \\"- 2 20\\"]) 30 >>> max_simultaneous_generation([\\"+ 1 10\\", \\"+ 2 20\\", \\"- 1 5\\", \\"+ 3 15\\", \\"- 2 10\\", \\"- 3 5\\"]) 40 >>> max_simultaneous_generation([\\"+ 1 10\\"]) 10 >>> max_simultaneous_generation([]) 0 >>> max_simultaneous_generation([\\"+ 1 50\\", \\"+ 2 30\\", \\"- 1 25\\", \\"+ 3 15\\", \\"- 2 10\\"]) 80","solution":"def max_simultaneous_generation(events): Returns the maximum amount of power generated simultaneously based on the events. Args: events (list of str): List of event strings in the format \\"+ G X\\" or \\"- C X\\". Returns: int: The maximum simultaneous power generation. current_power = {} max_power = 0 current_total_power = 0 for event in events: operation, id, amount = event.split() amount = int(amount) if operation == '+': if id in current_power: current_power[id] += amount else: current_power[id] = amount current_total_power += amount else: current_power[id] -= amount current_total_power -= amount if current_total_power > max_power: max_power = current_total_power return max_power # Example usage for manual testing if __name__ == \\"__main__\\": n = 5 events = [\\"+ 1 10\\", \\"+ 2 20\\", \\"- 1 5\\", \\"+ 3 15\\", \\"- 2 10\\"] print(max_simultaneous_generation(events)) # Output: 45"},{"question":"import heapq from collections import defaultdict import sys def dijkstra_shortest_path(N, M, edges): Determine the shortest path distance from the starting node to any other node in an undirected graph. Args: N (int): Number of nodes. M (int): Number of edges. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w). Returns: List[int]: A list of integers where the i-th integer represents the shortest travel cost from node 1 to node i+1. If a node is not reachable, the cost is -1. Example: >>> dijkstra_shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1), (2, 4, 3), (4, 5, 2)]) [0, 4, 2, 3, 5] >>> dijkstra_shortest_path(3, 1, [(1, 2, 3)]) [0, 3, -1]","solution":"import heapq from collections import defaultdict import sys def dijkstra_shortest_path(N, M, edges): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dist = [sys.maxsize] * (N + 1) dist[1] = 0 min_heap = [(0, 1)] # (cost, node) while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for neighbor, weight in graph[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) result = [] for i in range(1, N + 1): if dist[i] == sys.maxsize: result.append(-1) else: result.append(dist[i]) return result"},{"question":"def optimal_price(prices: List[int], revenues: List[int]) -> int: Given a list of prices and corresponding list of revenues, this function returns the price point that yields the maximum revenue. If there are multiple price points with the same maximum revenue, the smallest one is returned. >>> optimal_price([20, 10, 20, 30, 10], [1000, 2000, 1500, 2500, 2000]) == 30 >>> optimal_price([10], [100]) == 10","solution":"def optimal_price(prices, revenues): Given a list of prices and corresponding list of revenues, this function returns the price point that yields the maximum revenue. If there are multiple price points with the same maximum revenue, the smallest one is returned. max_revenue = max(revenues) optimal_prices = [price for price, revenue in zip(prices, revenues) if revenue == max_revenue] return min(optimal_prices)"},{"question":"def max_path_sum(matrix: List[List[int]]) -> int: Calculate the maximum sum of values you can collect from the top-left corner to the bottom-right corner of the matrix. >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...]) 29 >>> max_path_sum([ ... [5] ...]) 5 >>> max_path_sum([ ... [1, 2, 3, 4] ...]) 10 >>> max_path_sum([ ... [1], ... [2], ... [3], ... [4] ...]) 10 >>> max_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ...]) 12 >>> max_path_sum([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...]) 0 >>> max_path_sum([ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ...]) 27","solution":"def max_path_sum(matrix): n = len(matrix) m = len(matrix[0]) # Create a dp table with the same dimensions as the matrix dp = [[0] * m for _ in range(n)] # Initialize the top-left cell dp[0][0] = matrix[0][0] # Fill in the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill in the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] # The bottom-right cell contains the maximum path sum return dp[n - 1][m - 1]"},{"question":"def longest_subarray_with_average_at_least_T(n: int, T: int, apples: List[int]) -> int: Given an array of integers representing the number of apples in crates, find the length of the longest subarray such that the average number of apples in that subarray is greater than or equal to a given threshold T. :param n: The number of crates :param T: The threshold number of apples :param apples: List of integers representing the number of apples in each crate :return: The length of the longest subarray with an average number of apples ≥ T >>> longest_subarray_with_average_at_least_T(5, 4, [1, 3, 5, 7, 9]) 3 >>> longest_subarray_with_average_at_least_T(5, 10, [1, 2, 3, 4, 5]) 0 >>> longest_subarray_with_average_at_least_T(5, 4, [4, 4, 4, 4, 4]) 5 >>> longest_subarray_with_average_at_least_T(1, 1, [1]) 1 >>> longest_subarray_with_average_at_least_T(1, 2, [1]) 0 >>> longest_subarray_with_average_at_least_T(6, 5, [5, 6, 7, 8, 5, 5]) 6 >>> longest_subarray_with_average_at_least_T(6, 7, [5, 6, 7, 8, 9, 10]) 4","solution":"def longest_subarray_with_average_at_least_T(n, T, apples): left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += apples[right] while left <= right and current_sum < T * (right - left + 1): current_sum -= apples[left] left += 1 if current_sum >= T * (right - left + 1): max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def min_steps_to_escape_labyrinth(n: int, m: int, grid: List[str], sx: int, sy: int, ex: int, ey: int) -> int: Determine the minimum number of steps required for Alex to escape the labyrinth. Args: n (int): Number of rows in the labyrinth. m (int): Number of columns in the labyrinth. grid (List[str]): Representation of the labyrinth. sx (int): Starting row position (1-based index). sy (int): Starting column position (1-based index). ex (int): Exit row position (1-based index). ey (int): Exit column position (1-based index). Returns: int: Minimum number of steps to reach the exit, or -1 if unreachable. Example: >>> n, m = 5, 6 >>> grid = [ ... '', ... '#....#', ... '#.', ... '#....#', ... '' ... ] >>> min_steps_to_escape_labyrinth(n, m, grid, 2, 2, 4, 4) 4 >>> n, m = 3, 3 >>> grid = [ ... '#', ... '#.#', ... '#', ... ] >>> min_steps_to_escape_labyrinth(n, m, grid, 2, 2, 2, 2) 0 >>> n, m = 3, 3 >>> grid = [ ... '#', ... '#.#', ... '#', ... ] >>> min_steps_to_escape_labyrinth(n, m, grid, 2, 2, 1, 1) -1","solution":"from collections import deque def min_steps_to_escape_labyrinth(n, m, grid, sx, sy, ex, ey): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' queue = deque([(sx-1, sy-1, 0)]) visited = set((sx-1, sy-1)) while queue: x, y, steps = queue.popleft() if (x, y) == (ex-1, ey-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def count_unique_subarrays(n: int, k: int, elevations: List[int]) -> int: Counts the number of unique contiguous subarrays of length k from the elevation profile array. Parameters: n (int): The length of the elevation profile array. k (int): The size of subarrays to consider. elevations (list): The elevation profile array. Returns: int: The number of unique contiguous subarrays of length k. # Example test cases def test_count_unique_subarrays_example(): assert count_unique_subarrays(5, 3, [1, 2, 1, 2, 3]) == 3 def test_count_unique_subarrays_single_element(): assert count_unique_subarrays(1, 1, [1]) == 1 def test_count_unique_subarrays_all_same_elements(): assert count_unique_subarrays(5, 2, [2, 2, 2, 2, 2]) == 1 def test_count_unique_subarrays_no_repeats(): assert count_unique_subarrays(5, 1, [1, 2, 3, 4, 5]) == 5 def test_count_unique_subarrays_large_k(): assert count_unique_subarrays(5, 5, [1, 2, 3, 4, 5]) == 1 def test_count_unique_subarrays_mixed_elements(): assert count_unique_subarrays(7, 3, [1, 2, 1, 2, 3, 2, 1]) == 5","solution":"def count_unique_subarrays(n, k, elevations): Counts the number of unique contiguous subarrays of length k from the elevation profile array. Parameters: n (int): The length of the elevation profile array. k (int): The size of subarrays to consider. elevations (list): The elevation profile array. Returns: int: The number of unique contiguous subarrays of length k. unique_subarrays = set() for i in range(n - k + 1): subarray = tuple(elevations[i:i+k]) unique_subarrays.add(subarray) return len(unique_subarrays)"},{"question":"def count_connected_groups(n: int, m: int, relationships: List[Tuple[int, int]]) -> int: Determine the number of distinct groups of connected users on a social media platform. >>> count_connected_groups(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)]) == 2 >>> count_connected_groups(1, 0, []) == 1 >>> count_connected_groups(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1 >>> count_connected_groups(4, 0, []) == 4 >>> count_connected_groups(6, 3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> count_connected_groups(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 1","solution":"def count_connected_groups(n, m, relationships): # Create an adjacency list to represent the graph adj_list = [[] for _ in range(n + 1)] # Add edges to the adjacency list for u, v in relationships: adj_list[u].append(v) adj_list[v].append(u) # Function to perform DFS and mark all the connected users def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) visited = [False] * (n + 1) num_groups = 0 # Perform DFS for each unvisited user for user in range(1, n + 1): if not visited[user]: visited[user] = True dfs(user, visited) num_groups += 1 return num_groups"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given an underground cave system with n chambers and m tunnels, returns the shortest path length from entrance chamber (1) to exit chamber (n). Parameters: n (int): Number of chambers. m (int): Number of tunnels. edges (List[Tuple[int, int, int]]): Each tuple represents a tunnel (u, v, w) where u and v are chambers connected by a tunnel with length w. Returns: int: Length of the shortest path from chamber 1 to chamber n. If no path exists, returns -1. Examples: >>> shortest_path(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 10)]) 9 >>> shortest_path(4, 2, [(1, 2, 3), (3, 4, 2)]) -1 pass def test_shortest_path(): Unit tests for the shortest_path function. # Test case 1: Example case n, m = 4, 4 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 10) ] assert shortest_path(n, m, edges) == 9 # Test case 2: No path n, m = 4, 2 edges = [ (1, 2, 3), (3, 4, 2) ] assert shortest_path(n, m, edges) == -1 # Test case 3: Single edge direct path n, m = 2, 1 edges = [ (1, 2, 5) ] assert shortest_path(n, m, edges) == 5 # Test case 4: Two equal paths n, m = 4, 4 edges = [ (1, 2, 5), (2, 4, 5), (1, 3, 5), (3, 4, 5) ] assert shortest_path(n, m, edges) == 10 # Test case 5: All paths lead to the same length n, m = 3, 3 edges = [ (1, 2, 2), (2, 3, 3), (1, 3, 5) ] assert shortest_path(n, m, edges) == 5","solution":"import heapq def shortest_path(n, m, edges): # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Distance array dist = [float('inf')] * (n + 1) dist[1] = 0 # Min-heap priority queue pq = [(0, 1)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for neighbor, weight in graph[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist[n] if dist[n] != float('inf') else -1"},{"question":"def find_min_difference(n: int, weights: List[int]) -> int: You are given n packages, each with a weight specified in an array. Your task is to equally distribute these packages into two delivery vans such that the difference between the total weights of the packages in the two vans is minimized. If it is not possible to distribute the packages exactly equally, output the closest possible minimum difference. >>> find_min_difference(5, [1, 2, 3, 4, 5]) 1 >>> find_min_difference(3, [4, 7, 15]) 4","solution":"def find_min_difference(n, weights): total_weight = sum(weights) half_total_weight = total_weight // 2 dp = [0] * (half_total_weight + 1) for weight in weights: for j in range(half_total_weight, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) closest_to_half = dp[half_total_weight] return abs(total_weight - 2 * closest_to_half)"},{"question":"def has_cycle_of_length_4(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Function to determine if there exists a cycle of exactly 4 vertices in an undirected graph. >>> has_cycle_of_length_4(5, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) 'YES' >>> has_cycle_of_length_4(4, 3, [(1, 2), (2, 3), (3, 4)]) 'NO' pass # Your code goes here def test_example_1(): n = 5 m = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)] assert has_cycle_of_length_4(n, m, edges) == \\"YES\\" def test_example_2(): n = 4 m = 3 edges = [(1, 2), (2, 3), (3, 4)] assert has_cycle_of_length_4(n, m, edges) == \\"NO\\" def test_no_edges(): n = 4 m = 0 edges = [] assert has_cycle_of_length_4(n, m, edges) == \\"NO\\" def test_large_cycle(): n = 6 m = 7 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 4)] assert has_cycle_of_length_4(n, m, edges) == \\"NO\\" def test_small_graph_4_cycle(): n = 4 m = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)] assert has_cycle_of_length_4(n, m, edges) == \\"YES\\" def test_disconnected_graph_with_4_cycle(): n = 8 m = 7 edges = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7), (7, 4), (5, 7)] assert has_cycle_of_length_4(n, m, edges) == \\"YES\\" def test_disconnected_graph_without_4_cycle(): n = 8 m = 6 edges = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7), (7, 4)] assert has_cycle_of_length_4(n, m, edges) == \\"NO\\"","solution":"def has_cycle_of_length_4(n, m, edges): Function to determine if there exists a cycle of exactly 4 vertices in an undirected graph from collections import defaultdict # Create adjacency list graph = defaultdict(set) for u, v in edges: graph[u].add(v) graph[v].add(u) # Check for a cycle of length 4 for u in range(1, n + 1): # To avoid recombinations in different calls neighbours = list(graph[u]) for i in range(len(neighbours)): for j in range(i + 1, len(neighbours)): v = neighbours[i] w = neighbours[j] # If there is an edge between neighbours v and w then we have a 4-cycle if v in graph[w]: return \\"YES\\" return \\"NO\\""},{"question":"def find_largest_gap_id(messages: List[Tuple[int, int]]) -> int: Finds the message ID that follows the largest gap between message timestamps. Args: messages (list of tuples): A list where each tuple contains a timestamp and a message ID Returns: int: The message ID that follows the largest gap >>> find_largest_gap_id([(1, 1001), (3, 1002), (10, 1003), (13, 1004), (15, 1005)]) 1003 >>> find_largest_gap_id([(5, 2002), (6, 2003), (8, 2004), (20, 2005)]) 2005 def test_find_largest_gap_id(): assert find_largest_gap_id([(1, 1001), (3, 1002), (10, 1003), (13, 1004), (15, 1005)]) == 1003 assert find_largest_gap_id([(5, 2002), (6, 2003), (8, 2004), (20, 2005)]) == 2005 assert find_largest_gap_id([(2, 3001), (5, 3002), (9, 3003), (10, 3004)]) == 3003 assert find_largest_gap_id([(1, 4001), (2, 4002)]) == 4002 # Only two messages, gap between them is the max def test_find_largest_gap_id_unordered_messages(): assert find_largest_gap_id([(10, 1003), (1, 1001), (15, 1005), (3, 1002), (13, 1004)]) == 1003 assert find_largest_gap_id([(8, 2004), (20, 2005), (6, 2003), (5, 2002)]) == 2005 def test_find_largest_gap_id_same_timestamps(): assert find_largest_gap_id([(1, 5001), (1, 5002), (1, 5003), (2, 5004)]) == 5004 # only gap is from 1 to 2","solution":"def find_largest_gap_id(messages): Finds the message ID that follows the largest gap between message timestamps. Args: messages (list of tuples): A list where each tuple contains a timestamp and a message ID Returns: int: The message ID that follows the largest gap max_gap = 0 max_gap_id = None # Sort messages by timestamp messages.sort(key=lambda msg: msg[0]) for i in range(1, len(messages)): current_gap = messages[i][0] - messages[i - 1][0] if current_gap > max_gap: max_gap = current_gap max_gap_id = messages[i][1] return max_gap_id"},{"question":"from typing import List def min_total_road_length(n: int, graph: List[List[int]]) -> int: Calculate the minimum total length of roads required to connect all towns. This function uses Prim's Algorithm to compute the Minimum Spanning Tree (MST) of an adjacency matrix representing the road lengths between towns. Parameters: n (int): Number of towns graph (List[List[int]]): A matrix representing the lengths of the roads between all pairs of towns Returns: int: The total length of the roads in the MST Examples: >>> min_total_road_length(3, [[0, 1, 3], [1, 0, 2], [3, 2, 0]]) 3 >>> min_total_road_length(2, [[0, 4], [4, 0]]) 4 pass def test_example(): graph = [ [0, 1, 3], [1, 0, 2], [3, 2, 0] ] assert min_total_road_length(3, graph) == 3 def test_symmetric_graph(): graph = [ [0, 10, 20], [10, 0, 30], [20, 30, 0] ] assert min_total_road_length(3, graph) == 30 def test_four_towns(): graph = [ [0, 2, 3, 4], [2, 0, 1, 5], [3, 1, 0, 7], [4, 5, 7, 0] ] assert min_total_road_length(4, graph) == 7 def test_disconnected_graph(): graph = [ [0, 1, float('inf')], [1, 0, 2], [float('inf'), 2, 0] ] assert min_total_road_length(3, graph) == 3 def test_two_towns(): graph = [ [0, 4], [4, 0] ] assert min_total_road_length(2, graph) == 4 def test_max_towns(): n = 50 graph = [[0 if i == j else i + j for j in range(n)] for i in range(n)] assert min_total_road_length(n, graph) > 0 # Just checking if the function runs for the largest input","solution":"def prims_algorithm(n, graph): Function to calculate the minimum total length of roads required to connect all towns using Prim's Algorithm. :param n: Number of towns :param graph: Adjacency matrix representing lengths of the roads :return: Total length of the roads in the MST # Initialize all keys as infinite, and min heap key = [float('inf')] * n parent = [-1] * n mst_set = [False] * n key[0] = 0 # Starting from the first node total_length = 0 for _ in range(n): # Find the vertex with the minimum key value from the set of vertices not yet included in MST min_key = float('inf') u = -1 for v in range(n): if not mst_set[v] and key[v] < min_key: min_key = key[v] u = v mst_set[u] = True total_length += min_key # Update key value and parent index of the adjacent vertices of the picked vertex for v in range(n): # graph[u][v] is non zero only for adjacent vertices of u # mst_set[v] is false for vertices not yet included in MST # Update the key only if graph[u][v] is smaller than key[v] if graph[u][v] and not mst_set[v] and graph[u][v] < key[v]: key[v] = graph[u][v] parent[v] = u return total_length def min_total_road_length(n, graph): return prims_algorithm(n, graph)"},{"question":"from typing import List def findMaxLength(nums: List[int]) -> int: Find the maximum length of a contiguous subarray with an equal number of 0s and 1s. >>> findMaxLength([0, 1, 0, 0, 1, 1, 0]) 6 >>> findMaxLength([0, 1, 1, 1, 0, 0]) 6 pass import pytest from solution import findMaxLength def test_example_1(): assert findMaxLength([0, 1, 0, 0, 1, 1, 0]) == 6 def test_example_2(): assert findMaxLength([0, 1, 1, 1, 0, 0]) == 6 def test_all_zeroes(): assert findMaxLength([0, 0, 0, 0]) == 0 def test_all_ones(): assert findMaxLength([1, 1, 1, 1]) == 0 def test_alternating_zeros_and_ones(): assert findMaxLength([0, 1, 0, 1, 0, 1, 0, 1]) == 8 def test_single_zero_and_one(): assert findMaxLength([0, 1]) == 2 def test_zeroes_and_ones_with_no_contiguous_subarray(): assert findMaxLength([0, 1, 1, 0, 1]) == 4 def test_large_input(): large_list = [0, 1] * 50000 # 100000 elements alternating 0 and 1 assert findMaxLength(large_list) == 100000","solution":"def findMaxLength(nums): Returns the maximum length of a contiguous subarray with equal number of 0s and 1s. # Initialize variables to store the result and prefix sum max_length = 0 prefix_sum = 0 # Dictionary to store the first occurrence of a prefix sum sum_indices = {0: -1} for i in range(len(nums)): # Update prefix sum: treat 0 as -1 and 1 as +1 prefix_sum += -1 if nums[i] == 0 else 1 if prefix_sum in sum_indices: # If the prefix sum has been seen before, # calculate length of the subarray max_length = max(max_length, i - sum_indices[prefix_sum]) else: # Store the first occurrence of the prefix sum sum_indices[prefix_sum] = i return max_length"},{"question":"def longest_special_substring(k: int, s: str) -> int: Finds the length of the longest special substring with exactly k unique characters. Parameters: k (int): The number of unique characters in the substring. s (str): The input string. Returns: int: The length of the longest special substring with exactly k unique characters. Examples: >>> longest_special_substring(3, \\"abcabcabc\\") 9 >>> longest_special_substring(1, \\"aaaaa\\") 5 >>> longest_special_substring(2, \\"a\\") 0 >>> longest_special_substring(3, \\"aabbcc\\") 6 >>> longest_special_substring(2, \\"aaabbbccc\\") 6 >>> longest_special_substring(1, \\"a\\") 1 >>> longest_special_substring(26, \\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> longest_special_substring(3, \\"a\\") 0","solution":"def longest_special_substring(k, s): Finds the length of the longest special substring with exactly k unique characters. Parameters: k (int): The number of unique characters in the substring. s (str): The input string. Returns: int: The length of the longest special substring with exactly k unique characters. from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 left = 0 right = 0 char_count = defaultdict(int) max_length = 0 while right < n: char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def organize_albums(n: int, m: int, p: int, playlists: List[List[int]]) -> Union[List[List[int]], str]: Organize songs into n albums ensuring at least p songs per album. Args: n : int : number of albums m : int : number of playlists p : int : minimum number of songs per album playlists : List[List[int]] : list of playlists with song identifiers Returns: Union[List[List[int]], str] : list of albums with song identifiers or \\"No solution\\" if not possible >>> organize_albums(2, 3, 2, [[3, 1, 2, 3], [3, 2, 3, 4], [3, 4, 5, 6]]) [[1, 4], [2, 3, 5, 6]] >>> organize_albums(3, 3, 2, [[3, 1, 2, 3], [3, 1, 2, 3], [3, 1, 2, 3]]) \\"No solution\\"","solution":"def organize_albums(n, m, p, playlists): from collections import defaultdict, Counter # Step 1: Gather all unique songs all_songs = set() for playlist in playlists: all_songs.update(playlist[1:]) if len(all_songs) < n * p: return \\"No solution\\" # Step 2: Create a counter for the frequency of each song song_counter = Counter() for playlist in playlists: for song in playlist[1:]: song_counter[song] += 1 # Step 3: Sort songs based on frequency and then identifier sorted_songs = sorted(song_counter.items(), key=lambda x: (-x[1], x[0])) # Step 4: Distribute songs to albums albums = [[] for _ in range(n)] idx = 0 for song, _ in sorted_songs: albums[idx].append(song) idx = (idx + 1) % n # Verify if the solution is valid for album in albums: if len(album) < p: return \\"No solution\\" return albums"},{"question":"def max_blocks(n: int, m: int) -> tuple: Returns the maximum number of blocks that can be placed by robots and the grid configuration. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. Returns: tuple: (max_blocks, grid) where max_blocks is an integer and grid is a list of strings. >>> max_blocks(1, 1) (1, ['#']) >>> max_blocks(2, 2) (2, ['#.', '.#']) >>> max_blocks(3, 3) (5, ['#.#', '.#.', '#.#'])","solution":"def max_blocks(n, m): Returns the maximum number of blocks that can be placed by robots and the grid configuration. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. Returns: tuple: (max_blocks, grid) where max_blocks is an integer and grid is a list of strings. grid = [['.' for _ in range(m)] for _ in range(n)] max_blocks = 0 for i in range(n): for j in range(m): if (i % 2 == 0 and j % 2 == 0): grid[i][j] = '#' max_blocks += 1 elif (i % 2 == 1 and j % 2 == 1): grid[i][j] = '#' max_blocks += 1 return max_blocks, [''.join(row) for row in grid] # Example of running the function print(max_blocks(5, 5))"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[str]) -> List[int]: Process multiple queries to modify the list and extract certain information. Parameters: n (int): The size of the list. q (int): The number of queries. arr (List[int]): The initial elements of the list. queries (List[str]): The queries to process. Returns: List[int]: Results for each query of the second type. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [\\"2 1 3\\", \\"1 3 10\\", \\"2 2 4\\"]) [6, 16] >>> process_queries(4, 2, [1, 2, 3, 4], [\\"1 1 10\\", \\"2 1 4\\"]) [19] >>> process_queries(3, 3, [3, 2, 1], [\\"2 1 2\\", \\"1 2 5\\", \\"2 1 3\\"]) [5, 9] >>> process_queries(3, 1, [1, 2, 3], [\\"2 1 3\\"]) [6] >>> process_queries(3, 3, [5, 5, 5], [\\"1 3 10\\", \\"1 2 20\\", \\"2 1 3\\"]) [35] pass","solution":"def process_queries(n, q, arr, queries): results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": x = int(parts[1]) - 1 # Converting 1-indexed to 0-indexed y = int(parts[2]) arr[x] = y elif parts[0] == \\"2\\": l = int(parts[1]) - 1 # Converting 1-indexed to 0-indexed r = int(parts[2]) - 1 # Converting 1-indexed to 0-indexed results.append(sum(arr[l:r + 1])) return results # Example usage: n, q = 5, 3 arr = [1, 2, 3, 4, 5] queries = [\\"2 1 3\\", \\"1 3 10\\", \\"2 2 4\\"] print(process_queries(n, q, arr, queries)) # Output should be [6, 16]"},{"question":"def minimum_cost_to_connect_castles(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost to connect all castles or return -1 if impossible. Args: n (int): The number of castles. m (int): The number of roads. roads (List[Tuple[int, int, int]]): List of roads described by tuples (u, v, w) where u and v are castles connected by road with cost w. Returns: int: The minimum construction cost to connect all castles, or -1 if it is not possible. >>> minimum_cost_to_connect_castles(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 3)]) 4 >>> minimum_cost_to_connect_castles(3, 0, []) -1 >>> minimum_cost_to_connect_castles(1, 0, []) 0 >>> minimum_cost_to_connect_castles(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> minimum_cost_to_connect_castles(5, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 5, 10)]) 4","solution":"def minimum_cost_to_connect_castles(n, m, roads): Determine the minimum cost to connect all castles or return -1 if impossible. Parameters: n : int : number of castles m : int : number of roads roads : list of tuples : each tuple contains three integers (u, v, w) where u, v are castles connected by a road with cost w Returns: int : minimum construction cost or -1 if all castles cannot be connected if m == 0: return -1 if n > 1 else 0 parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY roads.sort(key=lambda x: x[2]) # Sort edges based on cost total_cost = 0 connected_components = n for u, v, w in roads: if find(u - 1) != find(v - 1): union(u - 1, v - 1) total_cost += w connected_components -= 1 if connected_components == 1: return total_cost return -1 def process_input(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) roads = [] index = 2 for _ in range(m): u, v, w = int(data[index]), int(data[index+1]), int(data[index+2]) roads.append((u, v, w)) index += 3 return n, m, roads"},{"question":"def find_components(n, edges): Uses DFS to find components in an undirected graph. graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component = [-1] * (n + 1) def dfs(node, comp_id): stack = [node] while stack: u = stack.pop() if not visited[u]: visited[u] = True component[u] = comp_id for v in graph[u]: if not visited[v]: stack.append(v) comp_id = 0 for i in range(1, n + 1): if not visited[i]: comp_id += 1 dfs(i, comp_id) return component def solve(test_cases): results = [] for n, m, edges, queries in test_cases: component = find_components(n, edges) for a, b in queries: if component[a] == component[b]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Parsing input and invoking the solution function def main(input_str): Determines if there is a path between pairs of nodes in an undirected graph. Args: input_str (str): Multiline string representing multiple test cases. Returns: str: Results of queries for each test case, 'YES' or 'NO', separated by newlines. >>> main(\\"1n5 3n1 2n2 3n4 5n3n1 3n1 4n4 5\\") \\"YESnNOnYES\\" data = input_str.strip().split() idx = 0 t = int(data[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(data[idx]) m = int(data[idx + 1]) idx += 2 edges = [] for _ in range(m): u = int(data[idx]) v = int(data[idx + 1]) edges.append((u, v)) idx += 2 q = int(data[idx]) idx += 1 queries = [] for _ in range(q): a = int(data[idx]) b = int(data[idx + 1]) queries.append((a, b)) idx += 2 test_cases.append((n, m, edges, queries)) results = solve(test_cases) return \\"n\\".join(results) # Example test cases def test_solution_case1(): input_str = \\"1n5 3n1 2n2 3n4 5n3n1 3n1 4n4 5\\" expected_output = \\"YESnNOnYES\\" assert main(input_str.strip()) == expected_output def test_solution_case2(): input_str = \\"1n4 2n1 2n3 4n2n1 4n2 3\\" expected_output = \\"NOnNO\\" assert main(input_str.strip()) == expected_output def test_solution_case3(): input_str = \\"1n6 4n1 2n2 3n4 5n5 6n4n1 3n1 4n4 6n2 3\\" expected_output = \\"YESnNOnYESnYES\\" assert main(input_str.strip()) == expected_output def test_solution_case4(): input_str = \\"1n3 1n1 2n2n1 3n2 3\\" expected_output = \\"NOnNO\\" assert main(input_str.strip()) == expected_output def test_solution_case5(): input_str = \\"1n2 1n1 2n1n1 2\\" expected_output = \\"YES\\" assert main(input_str.strip()) == expected_output","solution":"def find_components(n, edges): Uses DFS to find components in an undirected graph. graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component = [-1] * (n + 1) def dfs(node, comp_id): stack = [node] while stack: u = stack.pop() if not visited[u]: visited[u] = True component[u] = comp_id for v in graph[u]: if not visited[v]: stack.append(v) comp_id = 0 for i in range(1, n + 1): if not visited[i]: comp_id += 1 dfs(i, comp_id) return component def solve(test_cases): results = [] for n, m, edges, queries in test_cases: component = find_components(n, edges) for a, b in queries: if component[a] == component[b]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Parsing input and invoking the solution function def main(input_str): data = input_str.strip().split() idx = 0 t = int(data[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(data[idx]) m = int(data[idx + 1]) idx += 2 edges = [] for _ in range(m): u = int(data[idx]) v = int(data[idx + 1]) edges.append((u, v)) idx += 2 q = int(data[idx]) idx += 1 queries = [] for _ in range(q): a = int(data[idx]) b = int(data[idx + 1]) queries.append((a, b)) idx += 2 test_cases.append((n, m, edges, queries)) results = solve(test_cases) return \\"n\\".join(results) # Example usage: example_input = 1 5 3 1 2 2 3 4 5 3 1 3 1 4 4 5 print(main(example_input.strip()))"},{"question":"def largest_square_area(m: int, n: int, field: List[str]) -> int: Returns the area of the largest square of fertile land that can be planted. m: int, number of rows n: int, number of columns field: list of strings, each with n characters ('1' or '0'), representing the grid. >>> largest_square_area(3, 4, [\\"1010\\", \\"1111\\", \\"0110\\"]) 4 >>> largest_square_area(1, 5, [\\"11101\\"]) 1 >>> largest_square_area(4, 1, [\\"1\\", \\"1\\", \\"0\\", \\"1\\"]) 1 >>> largest_square_area(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 9 >>> largest_square_area(2, 2, [\\"00\\", \\"00\\"]) 0 >>> largest_square_area(5, 6, [\\"101000\\", \\"101011\\", \\"111011\\", \\"111000\\", \\"100000\\"]) 4","solution":"def largest_square_area(m, n, field): Returns the area of the largest square of fertile land that can be planted. m: int, number of rows n: int, number of columns field: list of strings, each with n characters ('1' or '0'), representing the grid. # Create a DP table to store the size of the largest square ending at (i, j) dp = [[0] * n for _ in range(m)] max_square_length = 0 for i in range(m): for j in range(n): if field[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 # Square of size 1 since it's on the edge else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # Update the maximum square length max_square_length = max(max_square_length, dp[i][j]) # Return the area of the largest square return max_square_length ** 2 # Example usage: # m, n = 3, 4 # field = [\\"1010\\", \\"1111\\", \\"0110\\"] # print(largest_square_area(m, n, field)) # Output: 4"},{"question":"def determine_winner(n: int, m: int) -> str: Determines the winner of the game based on optimal play. Dreamoon wins if the number of cells in the grid (n * m) is odd. Satsuki wins if the number of cells in the grid (n * m) is even. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: \\"Dreamoon\\" if Dreamoon will win the game, \\"Satsuki\\" otherwise. >>> determine_winner(2, 2) \\"Satsuki\\" >>> determine_winner(3, 3) \\"Dreamoon\\" >>> determine_winner(1, 1000) \\"Satsuki\\" >>> determine_winner(999, 999) \\"Dreamoon\\" >>> determine_winner(1000, 1000) \\"Satsuki\\" >>> determine_winner(1, 1) \\"Dreamoon\\"","solution":"def determine_winner(n, m): Determines the winner of the game based on optimal play. Dreamoon wins if the number of cells in the grid (n * m) is odd. Satsuki wins if the number of cells in the grid (n * m) is even. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: \\"Dreamoon\\" if Dreamoon will win the game, \\"Satsuki\\" otherwise. if n * m % 2 == 1: return \\"Dreamoon\\" else: return \\"Satsuki\\""},{"question":"from typing import List def min_delivery_distance(N: int, M: int, grid: List[List[str]]) -> int: Finds the minimum distance needed to reach the destination from the start, avoiding obstacles (represented by '#'). :param N: Number of rows :param M: Number of columns :param grid: 2D list representing the city grid :return: Minimum distance, or -1 if no path exists >>> min_delivery_distance(5, 5, [['.', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '.', '.', '#', '.'], ['.', '#', '#', '#', '.'], ['.', '.', '.', '.', '.']]) 8 >>> min_delivery_distance(3, 3, [['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.']]) -1 >>> min_delivery_distance(1, 1, [['.']]) 0 >>> min_delivery_distance(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 4 >>> min_delivery_distance(3, 3, [['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) -1","solution":"from collections import deque def min_delivery_distance(N, M, grid): Finds the minimum distance needed to reach the destination from the start, avoiding obstacles (represented by '#'). :param N: Number of rows :param M: Number of columns :param grid: 2D list representing the city grid :return: Minimum distance, or -1 if no path exists if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0)]) distances = [[-1]*M for _ in range(N)] distances[0][0] = 0 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and distances[nx][ny] == -1: distances[nx][ny] = distances[x][y] + 1 queue.append((nx, ny)) return distances[N-1][M-1]"},{"question":"def minimize_max_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Tom the Gardener is planning to grow a unique sequence of plants in his garden. Each type of plant is represented by a unique integer height. Tom wants to plant his plants in such a way that the absolute difference between the heights of any two adjacent plants is minimized as much as possible. Given an array of integers representing the heights of plants, help Tom determine the sequence of plants that minimizes the maximum absolute difference between the heights of adjacent plants. Args: t (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): a list of tuples where each tuple contains an integer n - the number of plants, and a list of n integers representing the heights of the plants. Returns: List[List[int]]: a list of lists where each list contains a permutation of the array such that the maximum absolute difference between heights of adjacent plants is minimized. >>> minimize_max_difference(1, [(3, [1, 3, 2])]) [[1, 3, 2]] >>> minimize_max_difference(3, [(3, [1, 3, 2]), (4, [10, 1, 8, 2]), (5, [6, 3, 9, 2, 5])]) [[1, 3, 2], [1, 10, 2, 8], [2, 9, 3, 6, 5]]","solution":"def minimize_max_difference(t, test_cases): res = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] heights.sort() # To achieve the minimized maximum difference, we can alternate picking elements starting from the ends permutation = [] left, right = 0, n - 1 while left <= right: if left == right: permutation.append(heights[left]) else: permutation.append(heights[left]) permutation.append(heights[right]) left += 1 right -= 1 res.append(permutation) return res # Example usage: # T = 3 # Test cases = [(3, [1, 3, 2]), (4, [10, 1, 8, 2]), (5, [6, 3, 9, 2, 5])] # Output: [[1, 3, 2], [1, 10, 2, 8], [2, 9, 3, 6, 5]]"},{"question":"def find_pair_sum(n, k, participants): Determines if there are two distinct participants whose combined spending exactly equals the given amount k. :param n: Number of participants :param k: Target sum :param participants: List of spending amounts :return: \\"YES\\" if such pair exists, otherwise \\"NO\\" pass # Unit test to validate the solution def test_find_pair_sum_exists(): assert find_pair_sum(4, 9, [1, 4, 5, 11]) == \\"YES\\" assert find_pair_sum(5, 10, [1, 2, 3, 7, 4]) == \\"YES\\" assert find_pair_sum(3, 6, [1, 2, 4]) == \\"YES\\" def test_find_pair_sum_not_exists(): assert find_pair_sum(4, 20, [1, 4, 5, 11]) == \\"NO\\" assert find_pair_sum(3, 10, [1, 2, 7]) == \\"NO\\" assert find_pair_sum(5, 3, [1, 1, 1, 1, 1]) == \\"NO\\" def test_find_pair_sum_same_element(): assert find_pair_sum(4, 2, [1, 1, 1, 1]) == \\"YES\\" assert find_pair_sum(6, 10, [1, 2, 5, 3, 4, 6]) == \\"YES\\" assert find_pair_sum(2, 5, [2, 3]) == \\"YES\\" assert find_pair_sum(2, 4, [2, 2]) == \\"YES\\" def test_find_pair_sum_large_numbers(): assert find_pair_sum(3, 1000000000, [999999999, 1, 2]) == \\"YES\\" assert find_pair_sum(3, 2000000000, [1000000000, 1000000000, 1]) == \\"YES\\" assert find_pair_sum(4, 1500000000, [1000000000, 500000000, 1000000000, 500000000]) == \\"YES\\"","solution":"def find_pair_sum(n, k, participants): Determines if there are two distinct participants whose combined spending exactly equals the given amount k. :param n: Number of participants :param k: Target sum :param participants: List of spending amounts :return: \\"YES\\" if such pair exists, otherwise \\"NO\\" seen = set() for amount in participants: if (k - amount) in seen: return \\"YES\\" seen.add(amount) return \\"NO\\""},{"question":"def can_become_non_decreasing_with_one_reverse(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to make the array non-decreasing by reversing exactly one subarray of length at least 2. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains: - An integer (n): The length of the array. - A list of integers: The elements of the array. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_become_non_decreasing_with_one_reverse(3, [(5, [5, 4, 3, 2, 1]), (4, [1, 3, 2, 4]), (4, [5, 1, 2, 3])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_become_non_decreasing_with_one_reverse(1, [(6, [1, 2, 5, 4, 3, 6])]) [\\"YES\\"]","solution":"def can_become_non_decreasing_with_one_reverse(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] # Create a copy of the array and sort it sorted_a = sorted(a) # Determine the first and last index where the elements differ l, r = 0, n-1 while l < n and a[l] == sorted_a[l]: l += 1 while r >= 0 and a[r] == sorted_a[r]: r -= 1 # If l >= r, the array is already sorted or can be made sorted by reversing the found subarray if l >= r: results.append(\\"YES\\") else: # Reverse the subarray and check if the entire array becomes sorted subarr = a[l:r+1][::-1] if a[:l] + subarr + a[r+1:] == sorted_a: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def hiking_route(n: int, m: int, trails: List[Tuple[int, int]]) -> List: Determines the route Franco should take to explore the hiking area. Franco should return to the starting point after visiting all landmarks if possible. Args: n: An integer representing the number of landmarks. m: An integer representing the number of trails. trails: A list of tuples, where each tuple (u, v) represents a trail between landmarks u and v. Returns: A list: [\\"Cycle\\", sequence_of_landmarks] if a cycle completing the tour is possible. [\\"Path\\", number_of_landmarks_visited, sequence_of_landmarks] otherwise. Examples: >>> hiking_route(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) [\\"Cycle\\", 1, 2, 3, 4, 5, 1] >>> hiking_route(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) [\\"Path\\", 6, 1, 2, 3, 4, 5, 6]","solution":"from collections import defaultdict, deque def hiking_route(n, m, trails): graph = defaultdict(list) for u, v in trails: graph[u].append(v) graph[v].append(u) def dfs(v, visited, parent): visited[v] = True path.append(v) for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, visited, v): return True elif neighbor != parent: path.append(neighbor) return True path.pop() return False visited = [False] * (n + 1) path = [] if dfs(1, visited, -1) and len(path) > 1 and path[-1] == path[0]: return [\\"Cycle\\"] + path visited = [False] * (n + 1) path = [] def bfs(start): q = deque([start]) visited[start] = True while q: v = q.popleft() path.append(v) for neighbor in graph[v]: if not visited[neighbor]: visited[neighbor] = True q.append(neighbor) bfs(1) return [\\"Path\\", len(path)] + path"},{"question":"def maximum_sum_subgrid(n: int, m: int, grid: List[List[int]]) -> int: Find the maximum sum of any subgrid (subrectangle) within an n x m grid of integers. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list containing integers which represents the grid. Returns: int: The maximum sum of any subgrid. >>> maximum_sum_subgrid(3, 3, [ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9] ... ]) 9 >>> maximum_sum_subgrid(1, 1, [ ... [5] ... ]) 5 >>> maximum_sum_subgrid(2, 2, [ ... [-1, -2], ... [-3, -4] ... ]) -1 >>> maximum_sum_subgrid(3, 3, [ ... [2, -1, 2], ... [-1, 2, -1], ... [2, -1, 2] ... ]) 6 >>> maximum_sum_subgrid(4, 5, [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29","solution":"def maximum_sum_subgrid(n, m, grid): Function to find the maximum sum of any subgrid in a given n x m grid. Uses Kadane's algorithm extended to 2D arrays. max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): # Add current column elements to temp array for i in range(n): temp[i] += grid[i][right] # Apply Kadane's algorithm on temp array current_max = temp[0] best_max = temp[0] for i in range(1, n): current_max = max(temp[i], current_max + temp[i]) if current_max > best_max: best_max = current_max # Update global maximum if best_max > max_sum: max_sum = best_max return max_sum"},{"question":"def minimum_operations_to_sort_array(t, test_cases): The function calculates the minimum number of operations needed to sort the array in ascending order. The array consists of unique integers and the allowed operations are: 1. Choose two adjacent elements and swap them. 2. Choose any element and move it to the front of the array. The input consists of t, the number of test cases, and test_cases, a list of tuples. Each tuple contains an integer n (length of the array), and a list of n unique integers. Returns a list of integers where each integer represents the number of operations needed for the corresponding test case. >>> minimum_operations_to_sort_array(1, [(4, [1, 2, 3, 4])]) [0] >>> minimum_operations_to_sort_array(1, [(1, [1])]) [0] >>> minimum_operations_to_sort_array(1, [(5, [5, 4, 3, 2, 1])]) [3] >>> minimum_operations_to_sort_array(1, [(3, [3, 1, 2])]) [2] >>> minimum_operations_to_sort_array(2, [(4, [2, 4, 1, 3]), (3, [3, 2, 1])]) [2, 3] >>> minimum_operations_to_sort_array(1, [(5, [1, 2, 3, 4, 5])]) [0] >>> minimum_operations_to_sort_array(1, [(3, [1, 3, 2])]) [1] >>> minimum_operations_to_sort_array(1, [(4, [4, 2, 3, 1])]) [3]","solution":"def minimum_operations_to_sort_array(t, test_cases): results = [] for i in range(t): n, array = test_cases[i] operations = 0 sorted_array = sorted(array) if array == sorted_array: results.append(operations) continue if array[0] == sorted_array[0] or array[-1] == sorted_array[-1]: operations = 1 elif array[0] == sorted_array[-1] and array[-1] == sorted_array[0]: operations = 3 else: operations = 2 results.append(operations) return results"},{"question":"def calculate_experience(events: List[str]) -> List[int]: Process a list of events and calculate the total XP gained after each 'total' query. Parameters: events (List[str]): A list of events. Each event is a string that indicates either a quest, a battle, or a total XP query. Returns: List[int]: A list of total XP values after each 'total' event. Example: >>> calculate_experience([\\"quest 50\\", \\"battle 10 3\\", \\"total\\", \\"quest 40\\", \\"battle 20 2\\", \\"total\\"]) [110, 230] >>> calculate_experience([\\"quest 50\\", \\"total\\"]) [50] >>> calculate_experience([\\"battle 10 3\\", \\"total\\"]) [60] # Implementation Here def test_single_quest(): events = [\\"quest 50\\", \\"total\\"] assert calculate_experience(events) == [50] def test_single_battle(): events = [\\"battle 10 3\\", \\"total\\"] assert calculate_experience(events) == [60] def test_mixed_events(): events = [\\"quest 50\\", \\"battle 10 3\\", \\"total\\", \\"quest 40\\", \\"battle 20 2\\", \\"total\\"] assert calculate_experience(events) == [110, 230] def test_multiple_totals(): events = [\\"quest 50\\", \\"total\\", \\"battle 10 3\\", \\"total\\"] assert calculate_experience(events) == [50, 110] def test_no_events(): events = [] assert calculate_experience(events) == [] def test_only_totals(): events = [\\"total\\", \\"total\\"] assert calculate_experience(events) == [0, 0]","solution":"def calculate_experience(events): total_xp = 0 results = [] for event in events: parts = event.split() if parts[0] == 'quest': total_xp += int(parts[1]) elif parts[0] == 'battle': strength = int(parts[1]) number = int(parts[2]) total_xp += strength * 2 * number elif parts[0] == 'total': results.append(total_xp) return results"},{"question":"def has_triplet_with_sum(arr, target): This function checks if there are three distinct elements in the array whose sum is equal to the target sum. Parameters: arr (list): A list of integers. target (int): Target sum to find in the array. Returns: str: \\"YES\\" if such a triplet exists, otherwise \\"NO\\". >>> has_triplet_with_sum([1, 2, 4, 5, 6, 7], 10) == \\"YES\\" >>> has_triplet_with_sum([1, 2, 4, 5, 6, 7], 50) == \\"NO\\" >>> has_triplet_with_sum([-1, 0, 1, 2, -2, -4], 0) == \\"YES\\" >>> has_triplet_with_sum([-3, -1, -2, -5, -4], -10) == \\"YES\\" >>> has_triplet_with_sum([1, 2, 2, 3, 4, 5], 9) == \\"YES\\" >>> has_triplet_with_sum(list(range(1, 1001)), 2500) == \\"YES\\"","solution":"def has_triplet_with_sum(arr, target): This function checks if there are three distinct elements in the array whose sum is equal to the target sum. Parameters: arr (list): A list of integers. target (int): Target sum to find in the array. Returns: str: \\"YES\\" if such a triplet exists, otherwise \\"NO\\". arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: triplet_sum = arr[i] + arr[left] + arr[right] if triplet_sum == target: return \\"YES\\" elif triplet_sum < target: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def max_length_of_ones(n: int, k: int, s: str) -> int: Returns the maximum length of a contiguous substring of '1's that can be obtained by making at most k flips. Parameters: n (int): Length of the binary string s k (int): Maximum number of flip operations allowed s (str): Binary string consisting of characters '0' and '1' Returns: int: Maximum length of contiguous substring of '1's after at most k flips def test_max_length_of_ones_example_case(): assert max_length_of_ones(6, 1, \\"010101\\") == 3 def test_max_length_of_ones_no_flips_needed(): assert max_length_of_ones(6, 1, \\"111111\\") == 6 assert max_length_of_ones(6, 0, \\"111111\\") == 6 def test_max_length_of_ones_no_possible_flips(): assert max_length_of_ones(6, 0, \\"000000\\") == 0 def test_max_length_of_ones_all_flips_needed(): assert max_length_of_ones(6, 6, \\"000000\\") == 6 def test_max_length_of_ones_mixed_case(): assert max_length_of_ones(8, 2, \\"10011010\\") == 5 def test_max_length_of_ones_edge_case_large_n(): n = 10**5 s = \\"1\\" * (n//2) + \\"0\\" * (n//2) assert max_length_of_ones(n, n//2, s) == n","solution":"def max_length_of_ones(n, k, s): Returns the maximum length of a contiguous substring of '1's that can be obtained by making at most k flips. Parameters: n (int): Length of the binary string s k (int): Maximum number of flip operations allowed s (str): Binary string consisting of characters '0' and '1' Returns: int: Maximum length of contiguous substring of '1's after at most k flips left, right = 0, 0 max_length = 0 flip_count = 0 while right < n: if s[right] == '0': flip_count += 1 while flip_count > k: if s[left] == '0': flip_count -= 1 left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def max_card_value_sum(n: int, m: int, card_values: List[int]) -> int: Determines the maximum sum of card values from a subset of players where each card value is unique. Args: n (int): Number of players. m (int): Maximum card value. card_values (list of int): List of integers where each integer represents the card value drawn by the i-th player. Returns: int: Maximum possible sum of card values with unique values. Examples: >>> max_card_value_sum(5, 10, [1, 2, 3, 4, 5]) 15 >>> max_card_value_sum(3, 5, [2, 2, 2]) 2 >>> max_card_value_sum(5, 10, [4, 2, 2, 4, 1]) 7 >>> max_card_value_sum(1, 1, [1]) 1 >>> max_card_value_sum(5, 5, [1, 3, 2, 1, 3]) 6","solution":"def max_card_value_sum(n, m, card_values): Determines the maximum sum of card values from a subset of players where each card value is unique. Args: n (int): Number of players. m (int): Maximum card value. card_values (list of int): List of integers where each integer represents the card value drawn by the i-th player. Returns: int: Maximum possible sum of card values with unique values. unique_card_values = list(set(card_values)) return sum(unique_card_values)"},{"question":"def min_road_segments(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of road segments to be built such that all buildings are part of a single connected component. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: A list of strings representing the city map where '.' represents an empty cell and 'B' represents a building :return: The minimum number of road segments needed to connect all buildings >>> min_road_segments(3, 4, [\\".B..\\", \\"..B.\\", \\"....\\"]) 1 >>> min_road_segments(4, 5, [\\"B....\\", \\".....\\", \\"..B..\\", \\"....B\\"]) 2 >>> min_road_segments(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> min_road_segments(3, 3, [\\"BBB\\", \\"BBB\\", \\"BBB\\"]) 0 >>> min_road_segments(3, 3, [\\"...\\", \\".B.\\", \\"...\\"]) 0 pass def test_example_1(): n, m = 3, 4 grid = [ \\".B..\\", \\"..B.\\", \\"....\\" ] assert min_road_segments(n, m, grid) == 1 def test_example_2(): n, m = 4, 5 grid = [ \\"B....\\", \\".....\\", \\"..B..\\", \\"....B\\" ] assert min_road_segments(n, m, grid) == 2 def test_no_buildings(): n, m = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert min_road_segments(n, m, grid) == 0 def test_all_connected(): n, m = 3, 3 grid = [ \\"BBB\\", \\"BBB\\", \\"BBB\\" ] assert min_road_segments(n, m, grid) == 0 def test_single_building(): n, m = 3, 3 grid = [ \\"...\\", \\".B.\\", \\"...\\" ] assert min_road_segments(n, m, grid) == 0","solution":"def min_road_segments(n, m, grid): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start): queue = deque([start]) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 'B': visited[nx][ny] = True queue.append((nx, ny)) visited = [[False] * m for _ in range(n)] components = 0 for i in range(n): for j in range(m): if grid[i][j] == 'B' and not visited[i][j]: visited[i][j] = True bfs((i, j)) components += 1 return max(components - 1, 0) # Read input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] for i in range(n): grid.append(data[2 + i]) # Compute and print the result print(min_road_segments(n, m, grid)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Dict, Union def find_spot(parking_spots: List[Dict], vehicle_type: str, special_group: str = None) -> Union[int, None]: Locates an available parking spot for a given vehicle type and special group. Args: - parking_spots (List[Dict]): A list of dictionaries representing parking spots. - vehicle_type (str): The type of vehicle that needs parking. - special_group (str, optional): The special group entitlement of the vehicle, if any. Returns: - An integer representing the id of the suitable parking spot, or None if no suitable spot is found. Example: >>> parking_spots = [ ... {\\"id\\": 1, \\"status\\": \\"available\\", \\"vehicle_type\\": \\"car\\", \\"reserved\\": None}, ... {\\"id\\": 2, \\"status\\": \\"occupied\\", \\"vehicle_type\\": \\"car\\", \\"reserved\\": None}, ... {\\"id\\": 3, \\"status\\": \\"available\\", \\"vehicle_type\\": \\"motorcycle\\", \\"reserved\\": \\"VIP\\"}, ... {\\"id\\": 4, \\"status\\": \\"available\\", \\"vehicle_type\\": \\"car\\", \\"reserved\\": \\"VIP\\"} ... ] >>> find_spot(parking_spots, \\"car\\") 1 >>> find_spot(parking_spots, \\"motorcycle\\") None >>> find_spot(parking_spots, \\"motorcycle\\", \\"VIP\\") 3 >>> find_spot(parking_spots, \\"car\\", \\"VIP\\") 4","solution":"from typing import List, Dict, Union def find_spot(parking_spots: List[Dict], vehicle_type: str, special_group: str = None) -> Union[int, None]: Locates an available parking spot for a given vehicle type and special group. Args: - parking_spots (List[Dict]): A list of dictionaries representing parking spots. - vehicle_type (str): The type of vehicle that needs parking. - special_group (str, optional): The special group entitlement of the vehicle, if any. Returns: - An integer representing the id of the suitable parking spot, or None if no suitable spot is found. for spot in sorted(parking_spots, key=lambda x: x[\\"id\\"]): if spot[\\"status\\"] == \\"available\\" and spot[\\"vehicle_type\\"] == vehicle_type: if spot[\\"reserved\\"] is None or spot[\\"reserved\\"] == special_group: return spot[\\"id\\"] return None"},{"question":"import heapq from typing import List, Tuple, Union def find_minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Determine the weight of the minimum spanning tree (MST) for a given undirected graph. The graph is described by n vertices and a list of edges where each edge is represented by a tuple (u, v, w). If an MST exists, return the sum of weights of the MST. If no MST exists, return \\"IMPOSSIBLE\\". >>> find_minimum_spanning_tree(4, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)]) 6 >>> find_minimum_spanning_tree(3, []) \\"IMPOSSIBLE\\" >>> find_minimum_spanning_tree(1, []) 0 def test_example_case(): edges = [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)] assert find_minimum_spanning_tree(4, edges) == 6 def test_no_edges(): assert find_minimum_spanning_tree(3, []) == \\"IMPOSSIBLE\\" def test_single_vertex_no_edges(): assert find_minimum_spanning_tree(1, []) == 0 def test_single_vertex_with_edges(): edges = [(1, 2, 4)] assert find_minimum_spanning_tree(1, edges) == \\"IMPOSSIBLE\\" def test_disconnected_graph(): edges = [(1, 2, 4), (3, 4, 3)] assert find_minimum_spanning_tree(4, edges) == \\"IMPOSSIBLE\\" def test_already_connected_graph(): edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1)] assert find_minimum_spanning_tree(4, edges) == 3 def test_more_complex_case(): edges = [(1, 2, 1), (2, 3, 2), (3, 4, 4), (1, 4, 3), (1, 3, 5), (2, 4, 4)] assert find_minimum_spanning_tree(4, edges) == 6","solution":"import heapq def find_minimum_spanning_tree(n, edges): if n == 1: return 0 if edges == [] else \\"IMPOSSIBLE\\" if n > 1 and not edges: return \\"IMPOSSIBLE\\" adj = [[] for _ in range(n + 1)] for u, v, w in edges: adj[u].append((w, v)) adj[v].append((w, u)) pq = [(0, 1)] # (weight, vertex) min_cost = 0 visited = [False] * (n + 1) num_edges = 0 while pq and num_edges < n: w, u = heapq.heappop(pq) if visited[u]: continue visited[u] = True min_cost += w num_edges += 1 for weight, v in adj[u]: if not visited[v]: heapq.heappush(pq, (weight, v)) if num_edges < n: return \\"IMPOSSIBLE\\" return min_cost"},{"question":"def minimum_subgroups(n: int, target: int, sizes: List[int]) -> int: Returns the minimum number of subgroups required to store all files without exceeding the target size in any subgroup. Parameters: n (int): The number of files. target (int): The target size of each subgroup. sizes (List[int]): The sizes of the files. Returns: int: The minimum number of subgroups required. Examples: >>> minimum_subgroups(5, 10, [2, 3, 7, 5, 8]) 3 >>> minimum_subgroups(1, 10, [5]) 1 >>> minimum_subgroups(4, 10, [2, 3, 5, 10]) 2 >>> minimum_subgroups(5, 1000, [200, 300, 500, 100, 900]) 2 >>> minimum_subgroups(3, 1, [2, 3, 4]) 3 >>> minimum_subgroups(3, 5, [1, 4, 4]) 2","solution":"def minimum_subgroups(n, target, sizes): Returns the minimum number of subgroups required to store all files without exceeding the target size in any subgroup. sizes.sort(reverse=True) subgroups = [] for size in sizes: placed = False for subgroup in subgroups: if sum(subgroup) + size <= target: subgroup.append(size) placed = True break if not placed: subgroups.append([size]) return len(subgroups)"},{"question":"def max_subarray_sum(arr): Helper function to calculate the maximum subarray sum using Kadane's Algorithm. >>> max_subarray_sum([3, -2, 5]) == 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([0, -3, 1, 3, -1, 2]) == 5 def process_queries(queries): Processes a list of queries and returns the results for type 3 queries. Parameters: queries (list of str): A list of queries in string format. Returns: list of int: The results of type 3 queries. >>> process_queries([\\"1 3\\", \\"1 -2\\", \\"1 5\\", \\"3\\", \\"2\\", \\"3\\"]) == [6, 3] >>> process_queries([\\"1 1\\", \\"1 2\\", \\"1 3\\", \\"1 4\\", \\"1 5\\", \\"3\\"]) == [15] >>> process_queries([\\"1 -1\\", \\"1 -2\\", \\"1 -3\\", \\"3\\", \\"1 4\\", \\"1 5\\", \\"3\\"]) == [-1, 9] >>> process_queries([\\"3\\"]) == [0] >>> process_queries([\\"1 1\\", \\"1 -1\\", \\"1 2\\", \\"2\\", \\"3\\"]) == [1]","solution":"def max_subarray_sum(arr): Helper function to calculate the maximum subarray sum using Kadane's Algorithm. if not arr: return 0 max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_queries(queries): Processes a list of queries and returns the results for type 3 queries. Parameters: queries (list of str): A list of queries in string format. Returns: list of int: The results of type 3 queries. arr = [] results = [] for query in queries: parts = query.split() if parts[0] == '1': arr.append(int(parts[1])) elif parts[0] == '2': if arr: arr.pop() elif parts[0] == '3': results.append(max_subarray_sum(arr)) return results"},{"question":"def max_length_equal_01_subarray(n: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray with equal number of 1s and 0s. Parameters: n (int): Length of the array arr (list): List of integers (0s and 1s) Returns: int: Maximum length of the subarray with equal number of 1s and 0s. pass import pytest def test_example_case(): assert max_length_equal_01_subarray(8, [1, 0, 0, 1, 0, 1, 1, 0]) == 8 def test_no_subarray(): assert max_length_equal_01_subarray(3, [1, 1, 1]) == 0 assert max_length_equal_01_subarray(1, [0]) == 0 def test_all_zeros(): assert max_length_equal_01_subarray(4, [0, 0, 0, 0]) == 0 def test_all_ones(): assert max_length_equal_01_subarray(4, [1, 1, 1, 1]) == 0 def test_mixed_values(): assert max_length_equal_01_subarray(6, [0, 1, 0, 1, 1, 0]) == 6 assert max_length_equal_01_subarray(5, [1, 0, 1, 0, 1]) == 4 def test_alternating(): assert max_length_equal_01_subarray(10, [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]) == 10","solution":"def max_length_equal_01_subarray(n, arr): Returns the length of the longest contiguous subarray with equal number of 1s and 0s Parameters: n (int): Length of the array arr (list): List of integers (0s and 1s) Returns: int: Maximum length of the subarray with equal number of 1s and 0s # Dictionary to store the first occurrence of each prefix sum prefix_sum_map = {0: -1} max_len = 0 prefix_sum = 0 for i in range(n): # Treat 0 as -1 and 1 as +1 for prefix sum if arr[i] == 0: prefix_sum -= 1 else: prefix_sum += 1 # If the prefix sum was seen before, we found a subarray with equal 0s and 1s if prefix_sum in prefix_sum_map: max_len = max(max_len, i - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = i return max_len"},{"question":"def max_defensive_capability(n: int, k: int, defenses: List[int]) -> int: Given the number of gates n and consecutive gates to close k, this function returns the maximum sum of the defensive capabilities of any k consecutive gates in a circular fortress. >>> max_defensive_capability(7, 3, [1, 2, 3, 4, 5, 6, 7]) == 18 >>> max_defensive_capability(1, 1, [100]) == 100 >>> max_defensive_capability(4, 4, [1, 1, 1, 1]) == 4 >>> max_defensive_capability(6, 4, [1, 10, 10, 10, 1, 1]) == 31 >>> max_defensive_capability(5, 2, [1, 1, 1, 1, 1]) == 2 >>> max_defensive_capability(5, 2, [5, 3, 8, 2, 4]) == 11 >>> max_defensive_capability(4, 2, [1000000000, 1000000000, 1000000000, 1000000000]) == 2000000000","solution":"def max_defensive_capability(n, k, defenses): Given the number of gates n and consecutive gates to close k, this function returns the maximum sum of the defensive capabilities of any k consecutive gates in a circular fortress. # Concatenate the array with itself to simulate the circular array defenses = defenses + defenses # Initial sum of the first k consecutive gates curr_sum = sum(defenses[:k]) max_sum = curr_sum # Use sliding window for i in range(1, n): curr_sum = curr_sum - defenses[i-1] + defenses[i+k-1] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"def min_duration_to_collect_potions(n: int, k: int, durations: List[int]) -> int: Returns the minimum duration required to collect exactly k potion bottles in a single walk. :param n: int - number of fountains. :param k: int - number of potion bottles needed. :param durations: List[int] - durations of the fountains. :return: int - minimum duration required. >>> min_duration_to_collect_potions(4, 5, [8, 1, 4, 9]) 4 >>> min_duration_to_collect_potions(3, 10, [5, 5, 5]) 5 >>> min_duration_to_collect_potions(5, 15, [4, 4, 4, 4, 4]) 4 >>> min_duration_to_collect_potions(3, 5, [1, 2, 3]) 3 >>> min_duration_to_collect_potions(6, 9, [1, 1, 1, 1, 1, 10]) 10 >>> min_duration_to_collect_potions(1, 1, [1000000]) 1000000","solution":"def min_duration_to_collect_potions(n, k, durations): Returns the minimum duration required to collect exactly k potion bottles in a single walk. :param n: int - number of fountains. :param k: int - number of potion bottles needed. :param durations: List[int] - durations of the fountains. :return: int - minimum duration required. left, right = 1, max(durations) result = right while left <= right: mid = (left + right) // 2 current_sum = 0 max_dur = 0 temp_sum = 0 for duration in durations: if duration > mid: if temp_sum > 0: max_dur = max(max_dur, temp_sum) current_sum += temp_sum temp_sum = 0 continue temp_sum += duration if temp_sum >= k: max_dur = mid current_sum += temp_sum break if temp_sum > 0 and temp_sum < k: max_dur = max(max_dur, temp_sum) current_sum += temp_sum if current_sum >= k: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def max_combined_power(n: int, k: int, obelisks: List[List[int]]) -> int: Calculate the maximum possible combined power by selecting exactly k obelisks from the n available obelisks. :param n: Number of obelisks :param k: Number of obelisks to select :param obelisks: List of lists, where each list contains the strengths of stones in each obelisk :return: The maximum possible combined power >>> max_combined_power(3, 2, [ >>> [3, 10, 20, 30], >>> [2, 40, 50], >>> [1, 100] >>> ]) == 145 >>> max_combined_power(1, 1, [ >>> [3, 10, 20, 30] >>> ]) == 20 >>> max_combined_power(3, 2, [ >>> [3, 10, 10, 10], >>> [3, 10, 10, 10], >>> [3, 10, 10, 10] >>> ]) == 20 >>> max_combined_power(2, 1, [ >>> [100] + [i for i in range(1, 101)], >>> [1, 1000] >>> ]) == 1000 >>> max_combined_power(1, 1, [ >>> [1, 1] >>> ]) == 1","solution":"def max_combined_power(n, k, obelisks): Calculate the maximum possible combined power by selecting exactly k obelisks from the n available obelisks. :param n: Number of obelisks :param k: Number of obelisks to select :param obelisks: List of lists, where each list contains the strengths of stones in each obelisk :return: The maximum possible combined power powers = [] # Calculate the power of each obelisk for obelisk in obelisks: m = obelisk[0] stones = obelisk[1:] power = sum(stones) / m powers.append(power) # Sort powers in descending order powers.sort(reverse=True) # Sum the top k powers combined_power = sum(powers[:k]) # Return the floor value of the combined power return int(combined_power)"},{"question":"def find_winner(n: int, lap_time_records: List[List[int]]) -> int: Determine the car with the minimum total race time based on given lap time intervals. >>> find_winner(3, [[2, 5, 3, 4, 2], [3, 6, 1, 2, 3, 4, 2], [2, 5, 5, 6, 1]]) 2 >>> find_winner(1, [[2, 5, 3, 4, 2]]) 1 >>> find_winner(2, [[2, 3, 2, 2, 4], [2, 7, 1, 1, 7]]) 1 or 2 >>> find_winner(4, [[2, 5, 3, 4, 2], [3, 6, 1, 2, 3, 4, 2], [2, 5, 5, 6, 1], [1, 3, 8]]) 2 >>> find_winner(2, [[1, 1000000000, 10000], [1, 999999999, 10000]]) 2","solution":"def find_winner(n, lap_time_records): min_time = float('inf') winner_index = -1 for i in range(n): k, *times = lap_time_records[i] total_time = sum([times[j] * times[j + 1] for j in range(0, 2 * k, 2)]) if total_time < min_time: min_time = total_time winner_index = i + 1 # Use 1-based indexing for the answer return winner_index"},{"question":"def max_balance_factor(n: int, s: str) -> int: Calculate the maximum possible balance factor of the binary string after any number of flips. :param n: Length of the binary string :param s: The binary string :return: The maximum possible balance factor >>> max_balance_factor(5, \\"11010\\") 3 >>> max_balance_factor(3, \\"000\\") 3 >>> max_balance_factor(6, \\"111111\\") 6","solution":"def max_balance_factor(n, s): Calculate the maximum possible balance factor of the binary string after any number of flips. :param n: Length of the binary string :param s: The binary string :return: The maximum possible balance factor # Initial balance factor is the number of ones minus the number of zeros initial_balance = s.count('1') - s.count('0') # To find the maximum possible balance after flipping any contiguous subsegment, # we need to flip such that the count of zeros becomes the count of ones and vice versa. # Hence the maximum balance we can achieve is maximum(n - count of ones, n - count of zeros) num_ones = s.count('1') num_zeros = s.count('0') return max(num_ones, num_zeros) # Example Usage # n = 5 # s = \\"11010\\" # print(max_balance_factor(n, s)) # Output: 3"},{"question":"from typing import List def min_subarray_len(arr: List[int], S: int) -> int: Find the shortest subarray length such that its sum is greater than or equal to a given value S. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1], 5) 5 >>> min_subarray_len([2, 3, 1, 2], 15) -1 pass # Implement the function here def test_min_subarray_len_basic(): # Basic functionality tests assert min_subarray_len([2, 3, 1, 2, 4, 3], 7) == 2 assert min_subarray_len([1, 1, 1, 1, 1, 1], 5) == 5 assert min_subarray_len([2, 3, 1, 2], 15) == -1 def test_min_subarray_len_single_element(): # Edge case tests with single element arrays assert min_subarray_len([10], 10) == 1 assert min_subarray_len([5], 10) == -1 def test_min_subarray_len_large_S(): # Cases where S is very large relative to array elements assert min_subarray_len([1, 2, 3, 4, 5], 15) == 5 assert min_subarray_len([1, 2, 3, 4, 5], 16) == -1 def test_min_subarray_len_entire_array(): # Cases where the whole array must be taken to satisfy S assert min_subarray_len([1, 2, 3, 4, 5], 15) == 5 def test_min_subarray_len_subarrays(): # General test cases with clear subarrays not at the beginning or end assert min_subarray_len([1, 4, 4, 3, 2, 1], 6) == 2 assert min_subarray_len([1, 2, 3, 4, 5], 11) == 3 assert min_subarray_len([1, 2, 3, 4, 5], 12) == 3 def test_min_subarray_len_edge_cases(): # Edge cases with empty or one element not meeting S assert min_subarray_len([1], 2) == -1 assert min_subarray_len([], 1) == -1","solution":"from typing import List def min_subarray_len(arr: List[int], S: int) -> int: n = len(arr) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += arr[right] while current_sum >= S: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_workshops(d: int, n: int, workshops: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping workshops Bob can attend. :param d: Total number of days :param n: Number of workshops :param workshops: List of tuples, where each tuple (si, ti) represents the start day and duration of a workshop :return: Maximum number of non-overlapping workshops pass # Testing the function def test_example_1(): assert max_workshops(10, 3, [(1, 3), (2, 5), (6, 2)]) == 2 def test_example_2(): assert max_workshops(20, 4, [(1, 10), (5, 7), (10, 5), (17, 3)]) == 2 def test_single_workshop(): assert max_workshops(15, 1, [(5, 7)]) == 1 def test_all_non_overlapping(): assert max_workshops(15, 3, [(1, 3), (5, 5), (11, 3)]) == 3 def test_all_overlapping(): assert max_workshops(10, 3, [(1, 3), (2, 3), (3, 3)]) == 1 def test_partial_overlap(): assert max_workshops(15, 5, [(1, 3), (2, 2), (4, 5), (11, 3), (13, 1)]) == 3","solution":"def max_workshops(d, n, workshops): Returns the maximum number of non-overlapping workshops Bob can attend. :param d: Total number of days :param n: Number of workshops :param workshops: List of tuples, where each tuple (si, ti) represents the start day and duration of a workshop :return: Maximum number of non-overlapping workshops # Calculate end time for each workshop workshops = [(s, s + t - 1) for s, t in workshops] # Sort workshops based on their end times workshops.sort(key=lambda x: x[1]) max_count = 0 current_end = 0 for start, end in workshops: if start > current_end: max_count += 1 current_end = end return max_count"},{"question":"def compute_c_values(data_points): Given a list of n tuples where each tuple contains two integers (ai, bi), computes a list of (n-1) tuples where each tuple is the sum of adjacent points. Args: data_points (List[Tuple[int, int]]): List of tuples representing the data points. Returns: List[Tuple[int, int]]: List of tuples representing the computed ci values. Example: >>> compute_c_values([(1, 2), (3, 4), (5, 6)]) [(4, 6), (8, 10)]","solution":"def compute_c_values(data_points): Given a list of n tuples where each tuple contains two integers (ai, bi), computes a list of (n-1) tuples where each tuple is the sum of adjacent points. ci_values = [] for i in range(len(data_points) - 1): a1, b1 = data_points[i] a2, b2 = data_points[i+1] ci_values.append((a1 + a2, b1 + b2)) return ci_values"},{"question":"from itertools import combinations def can_prepare_k_dishes(n, m, k, pantry, dishes): Determines if exactly k distinct dishes can be prepared with the given ingredients in the pantry. Args: n (int): The number of different types of dishes. m (int): The number of different ingredients. k (int): The number of different dishes to prepare. pantry (list[int]): List of available quantity of each ingredient. dishes (list[list[int]]): List of lists representing the quantity of each ingredient needed for each dish. Returns: str: \\"YES\\" if exactly k dishes can be prepared, otherwise \\"NO\\". pass # Implement the function def feasible_combination(combo, pantry, dishes): Checks if the given combination of dishes can be made with the available pantry stock. Args: combo (tuple[int]): Indices of selected dishes. pantry (list[int]): Available quantity of each ingredient. dishes (list[list[int]]): The ingredient requirements for each dish. Returns: bool: True if the combination can be prepared, False otherwise. pass # Implement the function # Test cases def test_example(): n, m, k = 5, 4, 3 pantry = [10, 10, 10, 10] dishes = [ [2, 0, 1, 1], [3, 4, 0, 0], [0, 2, 2, 3], [1, 0, 0, 1], [4, 1, 4, 0] ] assert can_prepare_k_dishes(n, m, k, pantry, dishes) == \\"YES\\" def test_no_possible_dishes(): n, m, k = 3, 3, 2 pantry = [5, 5, 5] dishes = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert can_prepare_k_dishes(n, m, k, pantry, dishes) == \\"NO\\" def test_exact_ingredients(): n, m, k = 3, 3, 2 pantry = [4, 4, 4] dishes = [ [2, 2, 2], [2, 2, 2], [5, 5, 5] ] assert can_prepare_k_dishes(n, m, k, pantry, dishes) == \\"YES\\" def test_single_dish_enough_ingredients(): n, m, k = 1, 3, 1 pantry = [10, 10, 10] dishes = [ [5, 5, 5] ] assert can_prepare_k_dishes(n, m, k, pantry, dishes) == \\"YES\\" def test_not_enough_ingredients(): n, m, k = 2, 2, 2 pantry = [5, 5] dishes = [ [3, 2], [3, 3] ] assert can_prepare_k_dishes(n, m, k, pantry, dishes) == \\"NO\\"","solution":"from itertools import combinations def can_prepare_k_dishes(n, m, k, pantry, dishes): Determines if exactly k distinct dishes can be prepared with the given ingredients in the pantry. Args: n (int): The number of different types of dishes. m (int): The number of different ingredients. k (int): The number of different dishes to prepare. pantry (list[int]): List of available quantity of each ingredient. dishes (list[list[int]]): List of lists representing the quantity of each ingredient needed for each dish. Returns: str: \\"YES\\" if exactly k dishes can be prepared, otherwise \\"NO\\". for combo in combinations(range(n), k): if feasible_combination(combo, pantry, dishes): return \\"YES\\" return \\"NO\\" def feasible_combination(combo, pantry, dishes): Checks if the given combination of dishes can be made with the available pantry stock. Args: combo (tuple[int]): Indices of selected dishes. pantry (list[int]): Available quantity of each ingredient. dishes (list[list[int]]): The ingredient requirements for each dish. Returns: bool: True if the combination can be prepared, False otherwise. required = [0] * len(pantry) for dish_index in combo: for ingredient_index in range(len(pantry)): required[ingredient_index] += dishes[dish_index][ingredient_index] for idx in range(len(pantry)): if required[idx] > pantry[idx]: return False return True"},{"question":"def find_min_initial_operations(n: int, m: int, dependencies: List[Tuple[int, int]], op: int) -> int: Determine the minimum number of initial operations that need to be successful for a given operation to be successful. Args: n (int): The number of operations. m (int): The number of dependencies. dependencies (List[Tuple[int, int]]): A list of tuples (a, b) representing that operation \`a\` must succeed before operation \`b\`. op (int): The target operation. Returns: int: The minimum number of initial operations that need to be successful for the target operation to be successful. Example: >>> find_min_initial_operations(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 5) 1 >>> find_min_initial_operations(5, 0, [], 3) 0 >>> find_min_initial_operations(6, 5, [(1, 4), (2, 4), (3, 5), (4, 6), (5, 6)], 6) 2 >>> find_min_initial_operations(6, 3, [(1, 3), (2, 3), (4, 5)], 3) 2 >>> find_min_initial_operations(3, 1, [(1, 2)], 2) 1 >>> find_min_initial_operations(7, 6, [(1, 3), (1, 2), (2, 4), (3, 5), (4, 6), (5, 7)], 7) 1","solution":"def find_min_initial_operations(n, m, dependencies, op): from collections import defaultdict, deque # Create an adjacency list for the operations graph graph = defaultdict(list) for a, b in dependencies: graph[b].append(a) # Function to perform BFS to find all dependencies for a given operation def find_dependencies(target): queue = deque([target]) visited = set() while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited # Find all dependencies for the given operation all_dependencies = find_dependencies(op) # Minimum initial operations are those with no incoming edges in the all_dependencies set initial_operations = set(all_dependencies) for key in all_dependencies: for neighbor in graph[key]: if neighbor in initial_operations: initial_operations.remove(neighbor) return len(initial_operations)"},{"question":"import heapq from typing import List, Tuple def shortest_path_in_kingdom(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the shortest path from town 1 to town n in the kingdom of Zorvian. :param n: int, number of towns :param m: int, number of roads :param roads: list of tuples, containing (u, v, w) representing roads :return: int, shortest path length from town 1 to town n, or -1 if no path exists >>> shortest_path_in_kingdom(4, 4, [(1, 2, 100), (2, 3, 200), (3, 4, 300), (1, 4, 700)]) == 600 >>> shortest_path_in_kingdom(4, 2, [(1, 2, 100), (3, 4, 200)]) == -1 >>> shortest_path_in_kingdom(2, 1, [(1, 2, 50)]) == 50 >>> shortest_path_in_kingdom(3, 3, [(1, 2, 100), (2, 3, 100), (1, 3, 300)]) == 200 >>> shortest_path_in_kingdom(5, 7, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1), (1, 5, 10)]) == 6","solution":"import heapq def shortest_path_in_kingdom(n, m, roads): Find the shortest path from town 1 to town n. :param n: int, number of towns :param m: int, number of roads :param roads: list of tuples, containing (u, v, w) representing roads :return: int, shortest path length from town 1 to town n, or -1 if no path exists graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path pq = [(0, 1)] # (distance, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[1] = 0 while pq: current_dist, current_node = heapq.heappop(pq) if current_node == n: return current_dist if current_dist > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[n] == float('inf') else distances[n] # Example usage: # n = 4 # m = 4 # roads = [(1, 2, 100), (2, 3, 200), (3, 4, 300), (1, 4, 700)] # print(shortest_path_in_kingdom(n, m, roads)) # Output: 600"},{"question":"def check_clock_set_properly(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determines if Pline's clock is set properly for each test case. Args: T : int : Number of test cases test_cases : list : List of T tuples, each containing: - int n : Number of binary strings for the test case - list : n binary hour strings Returns: list : \\"YES\\" or \\"NO\\" for each test case from typing import List, Tuple def test_all_valid_hours(): binary_strings = [format(i, '05b') for i in range(24)] assert check_clock_set_properly(1, [(24, binary_strings)]) == [\\"YES\\"] def test_missing_one_hour(): binary_strings = [format(i, '05b') for i in range(24) if i != 23] assert check_clock_set_properly(1, [(23, binary_strings)]) == [\\"NO\\"] def test_duplicate_hours(): binary_strings = [format(i, '05b') for i in range(23)] + ['00000'] assert check_clock_set_properly(1, [(24, binary_strings)]) == [\\"NO\\"] def test_random_invalid_set(): binary_strings = ['00000', '00001', '00010', '00011', '00100', '00101', '00110', '00111', '01000', '01001', '01010', '01011', '01100', '01101', '01110', '01111', '10000', '10001', '10010', '10011', '10100', '10101', '10110', '11011'] assert check_clock_set_properly(1, [(24, binary_strings)]) == [\\"NO\\"] def test_multiple_cases(): case1 = (24, [format(i, '05b') for i in range(24)]) case2 = (24, [format(i, '05b') for i in range(23)] + ['00000']) case3 = (48, [format(i, '05b') for i in range(24)] * 2) case4 = (24, ['00000', '00001', '00010', '00011', '00100', '00101', '00110', '00111', '01000', '01001', '01010', '01011', '01100', '01101', '01110', '01111', '10000', '10001', '10010', '10011', '10100', '10101', '10110', '11011']) assert check_clock_set_properly(4, [case1, case2, case3, case4]) == [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def check_clock_set_properly(T, test_cases): Determines if Pline's clock is set properly for each test case. Args: T : int : Number of test cases test_cases : list : List of T tuples, each containing: - int n : Number of binary strings for the test case - list : n binary hour strings Returns: list : \\"YES\\" or \\"NO\\" for each test case results = [] for case in test_cases: n, binary_strings = case if n != 24: results.append(\\"NO\\") continue binary_hour_set = set(binary_strings) valid_hour_set = set(format(i, '05b') for i in range(24)) if binary_hour_set == valid_hour_set: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def count_connected_components(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the number of connected components in the network. :param n: The number of computers in the network. :param m: The number of direct cables. :param connections: A list of tuples representing direct cables between computers. :return: The number of connected components. >>> count_connected_components(4, 2, [(1, 2), (3, 4)]) 2 >>> count_connected_components(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> count_connected_components(5, 0, []) 5 >>> count_connected_components(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> count_connected_components(7, 4, [(1, 2), (3, 4), (5, 6), (6, 7)]) 3","solution":"def count_connected_components(n, m, connections): from collections import defaultdict, deque # Initialize adjacency list for the graph graph = defaultdict(list) # Build the graph for u, v in connections: graph[u].append(v) graph[v].append(u) # Array to keep track of visited nodes visited = [False] * (n + 1) def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Counting connected components connected_components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i) connected_components += 1 return connected_components"},{"question":"def max_magical_fruits(n: int, fruits: List[int]) -> int: Finds the maximum number of magical fruits that can be collected from any continuous subarray. >>> max_magical_fruits(5, [-1, 2, 3, -5, 4]) 5 >>> max_magical_fruits(4, [1, 2, 3, 4]) 10 >>> max_magical_fruits(3, [-1, -2, -3]) 0 >>> max_magical_fruits(6, [2, 3, -6, 4, 5, -2]) 9 >>> max_magical_fruits(1, [3]) 3 >>> max_magical_fruits(1, [-3]) 0 >>> max_magical_fruits(6, [1, -2, 3, 4, -1, 6]) 12","solution":"def max_magical_fruits(n, fruits): Finds the maximum number of magical fruits that can be collected from any continuous subarray. :param n: Number of trees. :param fruits: List of integers representing the number of fruits on each tree. :return: Maximum number of magical fruits that can be collected. max_sum = float('-inf') current_sum = 0 for fruit in fruits: current_sum = max(fruit, current_sum + fruit) max_sum = max(max_sum, current_sum) return max(max_sum, 0)"},{"question":"def min_total_congestion(n, m, roads, k): Calculate the minimum possible total congestion score in a city by assigning traffic officers to access roads. Args: n (int): number of districts m (int): number of roads roads (list): list of tuples representing the roads (u, v, c) where u and v are districts connected by the road and c is the congestion score. k (int): number of traffic officers Returns: int: minimum possible total congestion score Examples: >>> min_total_congestion(3, 3, [(1, 2, 4), (2, 3, 5), (1, 3, 2)], 1) 6 >>> min_total_congestion(4, 4, [(1, 2, 3), (2, 3, 8), (3, 4, 6), (1, 4, 1)], 2) 4 >>> min_total_congestion(3, 3, [(1, 2, 10), (2, 3, 10), (1, 3, 10)], 3) 0 >>> min_total_congestion(3, 3, [(1, 2, 7), (2, 3, 4), (1, 3, 12)], 0) 23 >>> min_total_congestion(5, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 1, 5)], 2) 6 >>> min_total_congestion(1, 0, [], 0) 0","solution":"def min_total_congestion(n, m, roads, k): Calculate the minimum possible total congestion score. Args: n (int): number of districts m (int): number of roads roads (list): list of tuples representing the roads (u, v, c) k (int): number of traffic officers Returns: int: minimum possible total congestion score congestion_scores = [c for u, v, c in roads] # Sort congestion scores in descending order to target highest scores first congestion_scores.sort(reverse=True) # If k >= m, it means we can assign traffic officers to all roads if k >= m: return 0 # Remove the top k congested roads for i in range(k): congestion_scores[i] = 0 # Calculate the remaining congestion return sum(congestion_scores)"},{"question":"def collect_max_carrots(grid: List[List[str]]) -> int: Given an n x m grid, Marisa the Rabbit needs to collect all the carrots placed on the grid while avoiding the foxes. Each cell in the grid can be empty ('.'), contain a carrot ('C'), or have a fox ('F'). Marisa can move up, down, left, or right but cannot move into a cell containing a fox. Marisa starts at the top-left corner (1,1) and wants to find the maximum number of carrots she can collect while reaching the bottom-right corner (n,m). If not possible to reach the bottom-right corner, return -1. Args: grid (List[List[str]]): The n x m grid representing the farm. Returns: int: The maximum number of carrots collected or -1 if the bottom-right corner is not reachable. >>> collect_max_carrots([ ... ['.', '.', '.', 'F', '.'], ... ['C', '.', 'C', '.', '.'], ... ['.', 'F', 'F', '.', 'C'], ... ['C', '.', '.', '.', 'C'], ... ['.', '.', 'C', '.', '.'] ... ]) 3 >>> collect_max_carrots([ ... ['.', '.', '.', 'F', '.'], ... ['C', '.', 'C', 'F', '.'], ... ['.', 'F', 'F', '.', 'C'], ... ['C', '.', 'F', 'F', 'C'], ... ['.', '.', 'C', 'F', '.'] ... ]) -1 >>> collect_max_carrots([ ... ['.', 'C'], ... ['.', '.'] ... ]) 1 >>> collect_max_carrots([ ... ['.', '.'], ... ['.', '.'] ... ]) 0 >>> collect_max_carrots([ ... ['.'] ... ]) 0","solution":"def collect_max_carrots(grid): from collections import deque n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 0)]) # (x, y, carrots) visited = [[False] * m for _ in range(n)] visited[0][0] = True max_carrots = -1 while queue: x, y, carrots = queue.popleft() if x == n-1 and y == m-1: if carrots > max_carrots: max_carrots = carrots for dx, dy in directions: nx, ny, nc = x + dx, y + dy, carrots if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] != 'F': if grid[nx][ny] == 'C': nc += 1 visited[nx][ny] = True queue.append((nx, ny, nc)) if max_carrots == -1: return -1 return max_carrots"},{"question":"def solve(n: int, q: int, s: str, queries: List[str]) -> List[str]: Solve the given problem with string updates and palindrome queries. Args: n (int): Length of the string. q (int): Number of queries. s (str): The initial string. queries (List[str]): List of queries. Returns: List[str]: List of responses for ISPALINDROME queries. Example: >>> solve(5, 5, \\"ababa\\", [\\"ISPALINDROME 1 3\\", \\"UPDATE 3 c\\", \\"ISPALINDROME 1 3\\", \\"ISPALINDROME 2 5\\", \\"UPDATE 3 a\\", \\"ISPALINDROME 1 5\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> solve(4, 4, \\"abcd\\", [\\"ISPALINDROME 1 4\\", \\"UPDATE 2 b\\", \\"ISPALINDROME 1 4\\", \\"UPDATE 3 b\\"]) [\\"NO\\", \\"NO\\"] >>> solve(1, 2, \\"a\\", [\\"ISPALINDROME 1 1\\", \\"UPDATE 1 b\\"]) [\\"YES\\"] >>> solve(5, 5, \\"abcde\\", [\\"UPDATE 1 x\\", \\"UPDATE 2 y\\", \\"UPDATE 3 z\\", \\"ISPALINDROME 1 5\\", \\"ISPALINDROME 1 1\\"]) [\\"NO\\", \\"YES\\"]","solution":"def solve(n, q, s, queries): Solves the given problem with string updates and palindrome queries. :param n: Length of the string :param q: Number of queries :param s: The initial string :param queries: List of queries :return: List of responses for ISPALINDROME queries s = list(s) # Convert to list for mutable operations results = [] # Store results for ISPALINDROME queries for query in queries: parts = query.split() if parts[0] == \\"UPDATE\\": x = int(parts[1]) - 1 c = parts[2] s[x] = c elif parts[0] == \\"ISPALINDROME\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 substring = s[l:r+1] if substring == substring[::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def solve_connectivity(n, m, subway_lines, queries): Determine if districts in queries are connected by at least one subway line without switching. Args: n (int): Number of districts. m (int): Number of subway lines. subway_lines (List[List[int]]): Describes the subway lines where each sublist contains districts connected by that subway line. queries (List[Tuple[int, int]]): Queries to check if two districts are connected. Returns: List[str]: \\"YES\\" if districts are connected, otherwise \\"NO\\" for each query. Example: >>> n = 5, m = 2 >>> subway_lines = [[1, 2, 3], [3, 4]] >>> queries = [(1, 3), (1, 4), (2, 5), (3, 4)] >>> solve_connectivity(n, m, subway_lines, queries) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find_parent(parent, x) rootY = find_parent(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def solve_connectivity(n, m, subway_lines, queries): parent = list(range(n + 1)) rank = [0] * (n + 1) for line in subway_lines: for i in range(1, len(line)): union(parent, rank, line[i - 1], line[i]) results = [] for a, b in queries: if find_parent(parent, a) == find_parent(parent, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def does_robot_return_to_origin(moves: str) -> str: Determines if the robot returns to the origin after performing all moves. >>> does_robot_return_to_origin('UD') 'YES' >>> does_robot_return_to_origin('LL') 'NO' def robotic_journey(test_cases): Determines for each test case if the robot returns to the origin after performing all moves. >>> robotic_journey(['UD', 'LL', 'UUDDLRLR']) ['YES', 'NO', 'YES'] >>> robotic_journey(['L', 'R', 'UDLR', 'DULR']) ['NO', 'NO', 'YES', 'YES']","solution":"def does_robot_return_to_origin(moves: str) -> str: Determines if the robot returns to the origin after performing all moves. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\" def robotic_journey(test_cases): results = [] for moves in test_cases: result = does_robot_return_to_origin(moves) results.append(result) return results # Example Usage: # test_cases = ['UD', 'LL', 'UUDDLRLR'] # print(robotic_journey(test_cases)) # Output: ['YES', 'NO', 'YES']"},{"question":"def can_be_strictly_increasing(n: int, k: int, array: List[int]) -> str: Determines if an array can be made strictly increasing by modifying at most k elements. Parameters: n (int): The size of the array. k (int): The maximum number of elements that can be modified. array (list of int): The input array of integers. Returns: str: \\"YES\\" if the array can be made strictly increasing by modifying at most k elements, otherwise \\"NO\\". >>> can_be_strictly_increasing(5, 1, [1, 2, 3, 0, 5]) == \\"YES\\" >>> can_be_strictly_increasing(5, 1, [5, 4, 3, 2, 1]) == \\"NO\\" >>> can_be_strictly_increasing(4, 0, [1, 2, 3, 4]) == \\"YES\\" >>> can_be_strictly_increasing(4, 2, [4, 1, 3, 2]) == \\"YES\\" >>> can_be_strictly_increasing(4, 1, [4, 1, 3, 2]) == \\"NO\\" >>> can_be_strictly_increasing(3, 0, [1, 2, 3]) == \\"YES\\" >>> can_be_strictly_increasing(2, 1, [2, 2]) == \\"YES\\" >>> can_be_strictly_increasing(2, 0, [2, 2]) == \\"NO\\" >>> can_be_strictly_increasing(100000, 1, list(range(1, 100001))) == \\"YES\\" >>> can_be_strictly_increasing(100000, 100000, [100000]*100000) == \\"YES\\"","solution":"def can_be_strictly_increasing(n, k, array): Determines if an array can be made strictly increasing by modifying at most k elements. Parameters: n (int): The size of the array. k (int): The maximum number of elements that can be modified. array (list of int): The input array of integers. Returns: str: \\"YES\\" if the array can be made strictly increasing by modifying at most k elements, otherwise \\"NO\\". def can_increase_with_modifications(arr, max_modifications): modifications = 0 for i in range(1, len(arr)): if arr[i-1] >= arr[i]: modifications += 1 if modifications > max_modifications: return False # Simulate the minimal possible change if i == 1 or arr[i-2] < arr[i]: arr[i-1] = arr[i] - 1 else: arr[i] = arr[i-1] + 1 return True return \\"YES\\" if can_increase_with_modifications(array.copy(), k) else \\"NO\\""},{"question":"class SegmentTree: def __init__(self, data, default=float('inf'), func=min): self._default = default self._func = func self._len = len(data) self._size = self._len * 2 self._tree = [default] * self._size self._build(data) def _build(self, data): for i in range(self._len): self._tree[self._len + i] = data[i] for i in range(self._len - 1, 0, -1): self._tree[i] = self._func(self._tree[i * 2], self._tree[i * 2 + 1]) def update(self, pos, value): pos += self._len self._tree[pos] = value while pos > 1: pos //= 2 self._tree[pos] = self._func(self._tree[2 * pos], self._tree[2 * pos + 1]) def range_query(self, left, right): result = self._default left += self._len right += self._len + 1 while left < right: if left % 2 == 1: result = self._func(result, self._tree[left]) left += 1 if right % 2 == 1: right -= 1 result = self._func(result, self._tree[right]) left //= 2 right //= 2 return result def range_multiply(self, left, right, value): for i in range(left - 1, right): self.update(i, self._tree[self._len + i] * value) def process_operations(n, arr, operations): Process operations on an array where operations can be: 1) Multiply each element in a subarray by a given number. 2) Find the minimum value in a subarray. 3) Update the value at a specific index. Args: n (int): Size of the array. arr (List[int]): Initial values of the array. operations (List[Tuple]): List of operations to be performed. Returns: List[int]: Results of the find minimum operations. Example: >>> process_operations(5, [1, 2, 3, 4, 5], [(2, 1, 5), (1, 2, 4, 2), (2, 2, 4), (3, 1, 10), (2, 1, 3)]) [1, 4, 4] def test_process_operations(): n = 5 arr = [1, 2, 3, 4, 5] operations = [ (2, 1, 5), # Should return 1 (1, 2, 4, 2), # Multiply the range [2, 4] by 2 -> arr = [1, 4, 6, 8, 5] (2, 2, 4), # Should return 4 (3, 1, 10), # Update index 1 to 10 -> arr = [10, 4, 6, 8, 5] (2, 1, 3) # Should return 4 ] results = process_operations(n, arr, operations) assert results == [1, 4, 4] def test_process_operations_large(): n = 10 arr = [i + 1 for i in range(n)] operations = [ (1, 1, 5, 3), # Multiply the range [1, 5] by 3 (2, 1, 5), # Should return 3 (after multiplying 1,2,3,4,5 -> 3,6,9,12,15) (3, 5, 1), # Update index 5 to 1 -> arr=[3,6,9,12,1,6,7,8,9,10] (2, 5, 10) # Should return 1 ] results = process_operations(n, arr, operations) assert results == [3, 1] def test_process_operations_mixed(): n = 7 arr = [7, 1, 5, 3, 9, 4, 6] operations = [ (2, 1, 7), # Should return 1 (1, 1, 3, 2), # Multiply the range [1, 3] by 2 -> arr = [14, 2, 10, 3, 9, 4, 6] (2, 1, 3), # Should return 2 (3, 4, 0), # Update index 4 to 0 -> arr=[14, 2, 10, 0, 9, 4, 6] (2, 3, 5), # Should return 0 ] results = process_operations(n, arr, operations) assert results == [1, 2, 0]","solution":"class SegmentTree: def __init__(self, data, default=float('inf'), func=min): self._default = default self._func = func self._len = len(data) self._size = self._len * 2 self._tree = [default] * self._size self._build(data) def _build(self, data): for i in range(self._len): self._tree[self._len + i] = data[i] for i in range(self._len - 1, 0, -1): self._tree[i] = self._func(self._tree[i * 2], self._tree[i * 2 + 1]) def update(self, pos, value): pos += self._len self._tree[pos] = value while pos > 1: pos //= 2 self._tree[pos] = self._func(self._tree[2 * pos], self._tree[2 * pos + 1]) def range_query(self, left, right): result = self._default left += self._len right += self._len + 1 while left < right: if left % 2 == 1: result = self._func(result, self._tree[left]) left += 1 if right % 2 == 1: right -= 1 result = self._func(result, self._tree[right]) left //= 2 right //= 2 return result def range_multiply(self, left, right, value): for i in range(left - 1, right): self.update(i, self._tree[self._len + i] * value) def process_operations(n, arr, operations): seg_tree = SegmentTree(arr) results = [] for op in operations: if op[0] == 1: _, l, r, x = op seg_tree.range_multiply(l - 1, r - 1, x) elif op[0] == 2: _, l, r = op results.append(seg_tree.range_query(l - 1, r - 1)) elif op[0] == 3: _, k, x = op seg_tree.update(k - 1, x) return results"},{"question":"from itertools import permutations MOD = 10**9 + 7 def count_valid_rearrangements(n, stamps, k): Returns the number of valid rearrangements where the absolute difference between sizes of any two adjacent stamps is at least k, modulo 10^9 + 7. >>> count_valid_rearrangements(3, [1, 5, 9], 3) 6 >>> count_valid_rearrangements(4, [1, 4, 7, 10], 3) 24 >>> count_valid_rearrangements(4, [1, 2, 3, 4], 5) 0 >>> count_valid_rearrangements(2, [1, 1000], 999) 2 >>> count_valid_rearrangements(3, [10, 20, 30], 10) 6","solution":"from itertools import permutations MOD = 10**9 + 7 def count_valid_rearrangements(n, stamps, k): Returns the number of valid rearrangements where the absolute difference between sizes of any two adjacent stamps is at least k, modulo 10^9 + 7. def is_valid_permutation(perm): for i in range(n - 1): if abs(perm[i] - perm[i + 1]) < k: return False return True valid_count = 0 for perm in permutations(stamps): if is_valid_permutation(perm): valid_count += 1 return valid_count % MOD"},{"question":"class SegmentTree: def __init__(self, data): Initialize the segment tree with data. pass # Complete the segment tree initialization def update(self, index, value): Update the segment tree at a specific index with new value. pass # Implement the update method for the segment tree def range_min(self, l, r): Query the minimum value in the range [l, r). pass # Implement the range minimum query method def process_queries(n, q, arr, queries): Process a list of queries to update elements and report minimum values in subarrays. >>> process_queries(5, 3, [1, 3, 2, 4, 5], [[2, 1, 3], [1, 2, 1], [2, 1, 3]]) [1, 1] >>> process_queries(4, 2, [4, 5, 6, 7], [[1, 2, 3], [2, 2, 4]]) [3] >>> process_queries(4, 4, [10, 20, 30, 40], [[1, 1, 5], [2, 1, 2], [1, 4, 0], [2, 3, 4]]) [5, 0] >>> process_queries(5, 1, [1, 2, 3, 4, 5], [[2, 1, 5]]) [1] >>> process_queries(5, 2, [3, 2, 1, 2, 3], [[2, 1, 3], [2, 3, 5]]) [1, 1] pass # Implement the function to handle the queries using the segment tree","solution":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [float('inf')] * (2 * n) # Initialize the segment tree for i in range(n): self.tree[n + i] = data[i] for i in range(n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Update the segment tree pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_min(self, l, r): # Query the minimum in the range [l, r) res = float('inf') l += self.n r += self.n while l < r: if l % 2: res = min(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(n, q, arr, queries): seg_tree = SegmentTree(arr) results = [] for query in queries: if query[0] == 1: _, x, y = query seg_tree.update(x - 1, y) # Array is 1-indexed, so convert to 0-indexed elif query[0] == 2: _, l, r = query min_val = seg_tree.range_min(l - 1, r) # Array is 1-indexed, so convert to 0-indexed results.append(min_val) return results"},{"question":"def max_energy_drop(n: int, m: int, grid: List[List[int]]) -> int: Calculate the maximum energy drop in the city grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): A 2D list containing the elevation values of the grid. Returns: int: The maximum energy drop in the city. Examples: >>> max_energy_drop(1, 1, [[1]]) == 0 >>> max_energy_drop(1, 4, [[1, 2, 3, 8]]) == 5 >>> max_energy_drop(4, 1, [[1], [3], [5], [9]]) == 4 >>> max_energy_drop(3, 4, [[1, 3, 4, 5], [4, 2, 8, 3], [6, 7, 3, 1]]) == 6 >>> max_energy_drop(2, 2, [[1, 1000000], [1000000, 1]]) == 999999 >>> max_energy_drop(2, 2, [[1, 1], [1, 1]]) == 0","solution":"def max_energy_drop(n, m, grid): max_drop = 0 for i in range(n): for j in range(m): if i > 0: max_drop = max(max_drop, abs(grid[i][j] - grid[i - 1][j])) if j > 0: max_drop = max(max_drop, abs(grid[i][j] - grid[i][j - 1])) if i < n - 1: max_drop = max(max_drop, abs(grid[i][j] - grid[i + 1][j])) if j < m - 1: max_drop = max(max_drop, abs(grid[i][j] - grid[i][j + 1])) return max_drop"},{"question":"def tibonacci(a, b, c, k): Computes the k-th term of the Tibonacci sequence given the first three terms a, b, and c. pass def process_queries(queries): Process multiple queries to calculate Tibonacci sequence terms. pass # Test Cases def test_tibonacci(): assert tibonacci(1, 1, 1, 1) == 1 assert tibonacci(1, 1, 1, 2) == 1 assert tibonacci(1, 1, 1, 3) == 1 assert tibonacci(1, 1, 1, 4) == 3 assert tibonacci(1, 1, 1, 5) == 5 assert tibonacci(1, 1, 1, 6) == 9 assert tibonacci(1, 2, 3, 4) == 6 assert tibonacci(1, 2, 3, 5) == 11 assert tibonacci(1, 2, 3, 6) == 20 def test_process_queries(): queries = [ (1, 1, 1, 4), (1, 2, 3, 6), (0, 0, 0, 10) ] expected_results = [3, 20, 0] results = process_queries(queries) assert results == expected_results queries = [ (1, 1, 1, 1), (1, 1, 1, 2), (1, 1, 1, 3) ] expected_results = [1, 1, 1] results = process_queries(queries) assert results == expected_results","solution":"def tibonacci(a, b, c, k): Computes the k-th term of the Tibonacci sequence given the first three terms a, b, and c. if k == 1: return a elif k == 2: return b elif k == 3: return c # We store the first three terms t1, t2, t3 = a, b, c # Iterate to find the k-th term for _ in range(4, k + 1): t1, t2, t3 = t2, t3, t1 + t2 + t3 return t3 def process_queries(queries): Process multiple queries to calculate Tibonacci sequence terms. results = [] for a, b, c, k in queries: results.append(tibonacci(a, b, c, k)) return results"},{"question":"def longest_alternating_subsequence(arr: List[int]) -> int: Return the length of the longest alternating subsequence. An alternating sequence is a sequence where consecutive elements alternate between increasing and decreasing. >>> longest_alternating_subsequence([1, 5, 4, 9, 8, 6, 3, 7]) 6 >>> longest_alternating_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) 8 >>> longest_alternating_subsequence([1, 3, 2, 4, 5, 3, 2, 6]) 6 >>> longest_alternating_subsequence([1, 2, 3]) 2 >>> longest_alternating_subsequence([3, 2, 1]) 2 >>> longest_alternating_subsequence([]) 0 >>> longest_alternating_subsequence([1]) 1 >>> longest_alternating_subsequence([5, 5, 5, 5, 5]) 1 >>> longest_alternating_subsequence([1, 1000]) 2 >>> longest_alternating_subsequence([1000, 1]) 2 >>> longest_alternating_subsequence([1, 1000, 1]) 3 >>> longest_alternating_subsequence([1000, 1, 1000]) 3","solution":"def longest_alternating_subsequence(arr): Return the length of the longest alternating subsequence. An alternating sequence is a sequence where consecutive elements alternate between increasing and decreasing. n = len(arr) if n == 0: return 0 up = down = 1 for i in range(1, n): if arr[i] > arr[i - 1]: up = down + 1 elif arr[i] < arr[i - 1]: down = up + 1 return max(up, down) def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) arr = list(map(int, data[1:n + 1])) result = longest_alternating_subsequence(arr) print(result)"},{"question":"from typing import List, Union def generate_sequence(n: int, d: int) -> Union[List[int], str]: Generates a sequence of length \`n\` starting with 1 and adding the difference \`d\`. If a number recurs, it continues from the next number until the sequence reaches length \`n\`. :param n: Length of the sequence :param d: Difference to be added :return: List of \`n\` unique numbers starting from 1 or \\"No\\" if not possible. # Implementation here # Unit tests def test_generate_sequence_example1(): assert generate_sequence(5, 2) == [1, 3, 5, 7, 9] def test_generate_sequence_example2(): assert generate_sequence(5, 4) == [1, 5, 9, 13, 17] def test_generate_sequence_example3(): assert generate_sequence(1, 1000) == [1] def test_generate_sequence_example4(): assert generate_sequence(5, 3) == [1, 4, 7, 10, 13] def test_generate_sequence_single_element(): assert generate_sequence(1, 1) == [1] def test_generate_sequence_max_diff(): assert generate_sequence(3, 1000) == [1, 1001, 2001] def test_generate_sequence_large_n(): result = generate_sequence(100, 1) for i in range(100): assert result[i] == i + 1","solution":"def generate_sequence(n, d): Generates a sequence of length n starting with 1 and adding the difference d. If a number recurs, it continues from the next number until the sequence reaches length n. :param n: Length of the sequence :param d: Difference to be added :return: List of n unique numbers starting from 1 or \\"No\\" if not possible. sequence = [] current_num = 1 seen_numbers = set() while len(sequence) < n: if current_num not in seen_numbers: sequence.append(current_num) seen_numbers.add(current_num) current_num += d return sequence"},{"question":"def max_books_on_shelf(n, L, books): Determines the maximum number of books that Peter can place on the shelf and the required height. :param n: Number of books :param L: Length of the shelf :param books: List of tuples, each with (width, height) of the books :return: Tuple of two integers (max number of books, height of the shelf) Example: >>> max_books_on_shelf(5, 10, [(1, 2), (2, 1), (3, 5), (4, 2), (4, 1)]) (4, 5) >>> max_books_on_shelf(3, 15, [(5, 2), (5, 3), (5, 4)]) (3, 4) >>> max_books_on_shelf(4, 1, [(2, 1), (3, 2), (5, 1), (6, 4)]) (0, 0) pass","solution":"def max_books_on_shelf(n, L, books): Determines the maximum number of books that Peter can place on the shelf and the required height. :param n: Number of books :param L: Length of the shelf :param books: List of tuples, each with (width, height) of the books :return: Tuple of two integers (max number of books, height of the shelf) # Sort books by their width books.sort(key=lambda x: x[0]) total_width = 0 max_height = 0 count = 0 for width, height in books: if total_width + width <= L: total_width += width max_height = max(max_height, height) count += 1 else: break return count, max_height"},{"question":"def top_k_players(n: int, k: int, players_data: List[List[int]]) -> List[int]: Determines the top k players based on their scores. Parameters: n (int): The number of players. k (int): The number of top players to determine. players_data (list of lists): Each inner list contains the number of cards followed by the values of the cards for a player. Returns: list: The indices (1-based) of the top k players in descending order of their scores. Example: >>> top_k_players(5, 3, [[3, 5, 2, 9], [4, 8, 3, 2, 6], [2, 10, 7], [5, 1, 2, 3, 4, 5], [4, 7, 7, 7, 7]]) [5, 2, 3] # Your code here import pytest from solution import top_k_players def test_example_case(): n, k = 5, 3 players_data = [ [3, 5, 2, 9], [4, 8, 3, 2, 6], [2, 10, 7], [5, 1, 2, 3, 4, 5], [4, 7, 7, 7, 7] ] assert top_k_players(n, k, players_data) == [5, 2, 3] def test_single_player(): n, k = 1, 1 players_data = [[3, 5, 2, 9]] assert top_k_players(n, k, players_data) == [1] def test_all_players_tied(): n, k = 3, 2 players_data = [ [2, 10, 20], [2, 10, 20], [2, 10, 20] ] assert top_k_players(n, k, players_data) == [1, 2] def test_different_scores(): n, k = 4, 2 players_data = [ [3, 1, 1, 1], # score: 3 [3, 2, 2, 2], # score: 6 [3, 3, 3, 3], # score: 9 [3, 4, 4, 4] # score: 12 ] assert top_k_players(n, k, players_data) == [4, 3] def test_large_input(): n = 100000 k = 1 players_data = [[1, 1000]] * n assert top_k_players(n, k, players_data) == [1]","solution":"def top_k_players(n, k, players_data): Determines the top k players based on their scores. Parameters: n (int): The number of players. k (int): The number of top players to determine. players_data (list of lists): Each inner list contains the number of cards followed by the values of the cards for a player. Returns: list: The indices (1-based) of the top k players in descending order of their scores. scores = [] # Calculate the score for each player for idx, data in enumerate(players_data): score = sum(data[1:]) # data[0] is the number of cards, data[1:] are the card values scores.append((score, idx + 1)) # Store score and 1-based index # Sort scores primarily by score in descending order and by index in ascending order scores.sort(key=lambda x: (-x[0], x[1])) # Extract the top k player indices top_k_indices = [score[1] for score in scores[:k]] return top_k_indices"},{"question":"def can_transform_string(A, B, rules): Determine if it is possible to transform string \`A\` into string \`B\` given the transformation rules. :param A: The source string. :param B: The target string. :param rules: List of character transformation rules. :return: \\"YES\\" if string \`A\` can be transformed to string \`B\`, else \\"NO\\". >>> can_transform_string(\\"abc\\", \\"bbc\\", [('a', 'b'), ('b', 'c')]) \\"YES\\" >>> can_transform_string(\\"abcd\\", \\"aabc\\", [('b', 'a')]) \\"NO\\" def solve_adas_game(test_cases): Process multiple test cases and determine if string \`A\` can be transformed into string \`B\` for each case. :param test_cases: List of tuples, where each tuple contains: - N: Length of the strings - M: Number of transformation rules - A: The source string - B: The target string - rules: List of transformation rules :return: List of results (\\"YES\\" or \\"NO\\") for each test case. >>> solve_adas_game([(3, 2, \\"abc\\", \\"bbc\\", [('a', 'b'), ('b', 'c')]), (4, 1, \\"abcd\\", \\"aabc\\", [('b', 'a')])]) [\\"YES\\", \\"NO\\"] def test_can_transform_string(): test_cases = [ (3, 2, \\"abc\\", \\"bbc\\", [('a', 'b'), ('b', 'c')]), (4, 1, \\"abcd\\", \\"aabc\\", [('b', 'a')]), (3, 3, \\"abc\\", \\"acc\\", [('a', 'b'), ('b', 'c'), ('a', 'c')]), (3, 0, \\"abc\\", \\"abc\\", []), (2, 2, \\"ab\\", \\"aa\\", [('a', 'b'), ('b', 'a')]) ] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] results = solve_adas_game(test_cases) assert results == expected def test_edge_cases(): # Minimal test case test_cases = [(1, 0, \\"a\\", \\"a\\", [])] expected = [\\"YES\\"] results = solve_adas_game(test_cases) assert results == expected # No transformation rules test_cases = [ (3, 0, \\"abc\\", \\"abc\\", []), (3, 0, \\"abc\\", \\"acc\\", []) ] expected = [\\"YES\\", \\"NO\\"] results = solve_adas_game(test_cases) assert results == expected # Full transformation path needed test_cases = [ (3, 3, \\"abc\\", \\"ddd\\", [('a', 'd'), ('b', 'd'), ('c', 'd')]) ] expected = [\\"YES\\"] results = solve_adas_game(test_cases) assert results == expected # Impossible transformation due to cycle prevention test_cases = [ (3, 3, \\"abc\\", \\"ddd\\", [('a', 'b'), ('b', 'c'), ('c', 'd')]), (3, 2, \\"bac\\", \\"ddd\\", [('a', 'c'), ('b', 'd')]) ] expected = [\\"YES\\", \\"NO\\"] results = solve_adas_game(test_cases) assert results == expected","solution":"def can_transform_string(A, B, rules): from collections import defaultdict, deque # Create graph from rules graph = defaultdict(list) for u, v in rules: graph[u].append(v) # Perform BFS to find all reachable characters from any given character reachability = {char: set() for char in \\"abcdefghijklmnopqrstuvwxyz\\"} for start in \\"abcdefghijklmnopqrstuvwxyz\\": queue = deque([start]) visited = {start} while queue: char = queue.popleft() reachability[start].add(char) for neighbor in graph[char]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Check if we can transform A to B for a_char, b_char in zip(A, B): if b_char not in reachability[a_char]: return \\"NO\\" return \\"YES\\" def solve_adas_game(test_cases): results = [] for N, M, A, B, rules in test_cases: result = can_transform_string(A, B, rules) results.append(result) return results"},{"question":"def min_mixing_operations(n, concentrations): This function calculates the minimum number of mixing operations required to achieve a single bottle with the sum of concentrations. :param n: int - The number of bottles :param concentrations: List[int] - The concentration levels of each bottle :return: int - Minimum number of mixing operations required >>> min_mixing_operations(5, [4, 2, 1, 3, 6]) 4 >>> min_mixing_operations(1, [10]) 0 >>> min_mixing_operations(3, [5, 1, 7]) 2 >>> min_mixing_operations(4, [3, 3, 3, 3]) 3 >>> min_mixing_operations(6, [10, 50, 1, 1, 1, 1]) 5","solution":"def min_mixing_operations(n, concentrations): This function calculates the minimum number of mixing operations required to achieve a single bottle with the sum of concentrations. :param n: int - The number of bottles :param concentrations: List[int] - The concentration levels of each bottle :return: int - Minimum number of mixing operations required return n - 1"},{"question":"def can_replant_trees(n: int, apples: List[int]) -> Tuple[int, int]: Determine if it's possible to replant one tree to achieve the condition that one tree has the maximum apples and exactly one other tree has half or fewer apples. If possible, return 1 and the minimum number of apples for replanting, otherwise return 0. >>> can_replant_trees(5, [2, 1, 3, 2, 5]) (1, 1) >>> can_replant_trees(4, [4, 4, 4, 7]) (0,) >>> can_replant_trees(1, [7]) (0,) >>> can_replant_trees(5, [3, 3, 3, 3, 3]) (0,) >>> can_replant_trees(3, [6, 2, 3]) (1, 2) >>> can_replant_trees(6, [1, 9, 5, 2, 8, 3]) (1, 1) >>> can_replant_trees(7, [4, 12, 1, 3, 2, 7, 1]) (1, 1)","solution":"def can_replant_trees(n, apples): Determine if it's possible to replant one tree to achieve the condition that one tree has the maximum apples and exactly one other tree has half or fewer apples. If possible, return 1 and the minimum number of apples for replanting, otherwise return 0. max_apples = max(apples) half_apples_count = sum(1 for apple in apples if apple * 2 <= max_apples) if half_apples_count >= 1: return 1, min(apple for apple in apples if apple * 2 <= max_apples) return 0,"},{"question":"def has_pair_with_difference(arr, k): Determines if there exists a pair of indices in the array such that the absolute difference between the elements at these indices is equal to k. Parameters: arr (list): List of integers. k (int): The target absolute difference. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_difference([1, 7, 3], 4) 'YES' >>> has_pair_with_difference([1, 2, 2], 3) 'NO' >>> has_pair_with_difference([1, 4, 7], 3) 'YES'","solution":"def has_pair_with_difference(arr, k): Determines if there exists a pair of indices in the array such that the absolute difference between the elements at these indices is equal to k. Parameters: arr (list): List of integers. k (int): The target absolute difference. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen_elements = set() for num in arr: if (num + k) in seen_elements or (num - k) in seen_elements: return \\"YES\\" seen_elements.add(num) return \\"NO\\""},{"question":"def find_highest_peak(n: int, heights: List[int]) -> int: Find the height of the highest peak in the trail. :param n: Number of points in the trail :param heights: List of heights at each point :return: Height of the highest peak or -1 if no peaks >>> find_highest_peak(8, [1, 3, 2, 4, 5, 3, 2, 1]) == 5 >>> find_highest_peak(4, [1, 2, 3, 4]) == -1 >>> find_highest_peak(7, [10, 20, 15, 25, 30, 28, 26]) == 30 >>> find_highest_peak(6, [1, 2, 3, 2, 1, 0]) == 3 >>> find_highest_peak(5, [5, 5, 5, 5, 5]) == -1 >>> find_highest_peak(8, [1, 3, 2, 3, 1, 3, 2, 1]) == 3","solution":"def find_highest_peak(n, heights): Find the height of the highest peak in the trail. :param n: Number of points in the trail :param heights: List of heights at each point :return: Height of the highest peak or -1 if no peaks highest_peak = -1 for i in range(1, n - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: highest_peak = max(highest_peak, heights[i]) return highest_peak"},{"question":"def max_treasure(n, m, treasures, roads, start): In a fantasy land, there are n castles. Some of these castles are connected by bidirectional roads. Each castle has a certain amount of treasure. A hero wants to start from a given castle and collect treasures by visiting different castles. However, she can only visit each castle at most once due to the ancient curse that forbids revisiting any castle. Your task is to help the hero determine the maximum amount of treasure she can collect starting from the given castle until there are no more unvisited castles connected to her current location. Args: n (int): Number of castles. m (int): Number of roads. treasures (List[int]): Amount of treasure in each castle. roads (List[Tuple[int, int]]): Bidirectional roads between castles. start (int): Starting castle. Returns: int: Maximum amount of treasure the hero can collect. Examples: >>> max_treasure(6, 6, [5, 10, 20, 15, 10, 25], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (5, 6)], 1) 85 >>> max_treasure(1, 0, [100], [], 1) 100 >>> max_treasure(4, 2, [10, 20, 30, 40], [(1, 2), (3, 4)], 1) 30 >>> max_treasure(4, 2, [10, 20, 30, 40], [(1, 2), (3, 4)], 3) 70 >>> max_treasure(5, 4, [5, 10, 15, 20, 25], [(1, 2), (2, 3), (3, 4), (4, 5)], 1) 75 >>> max_treasure(4, 4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 1)], 2) 10","solution":"def max_treasure(n, m, treasures, roads, start): from collections import defaultdict, deque graph = defaultdict(list) for u, v in roads: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) visited = [False] * n queue = deque([start - 1]) total_treasure = 0 while queue: current = queue.popleft() if visited[current]: continue visited[current] = True total_treasure += treasures[current] for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) return total_treasure"},{"question":"def min_operations_to_make_beautiful(t: int, test_cases: List[str]) -> List[int]: Calculates the minimum number of operations to make each given binary string beautiful. Args: t (int): Number of test cases. test_cases (List[str]): List of binary strings. Returns: List[int]: List of minimum operations required for each test case. >>> min_operations_to_make_beautiful(3, [\\"011\\", \\"11111\\", \\"000\\"]) [1, 4, 2] >>> min_operations_to_make_beautiful(1, [\\"010\\"]) [0] >>> min_operations_to_make_beautiful(2, [\\"101\\", \\"1001\\"]) [0, 1] >>> min_operations_to_make_beautiful(3, [\\"0\\", \\"1\\", \\"01\\"]) [0, 0, 0] >>> min_operations_to_make_beautiful(1, [\\"111000\\"]) [4]","solution":"def min_operations_to_make_beautiful(t, test_cases): Calculates the minimum number of operations to make each given binary string beautiful. Args: t (int): Number of test cases. test_cases (List[str]): List of binary strings. Returns: List[int]: List of minimum operations required for each test case. results = [] for s in test_cases: operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 results.append(operations) return results"},{"question":"def find_largest_sum(n: int, m: int, elements: List[List[int]]) -> int: You are given a grid with n rows and m columns filled with integers. Your task is to find the largest sum of any rectangle subgrid. A rectangle subgrid is defined by choosing two rows and two columns. The sum of the rectangle subgrid is the sum of all integers inside the rectangle defined by these rows and columns. Args: n (int): the number of rows in the grid. m (int): the number of columns in the grid. elements (List[List[int]]): the elements of the grid. Returns: int: The largest sum of any rectangle subgrid. Examples: >>> find_largest_sum(4, 5, [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) 29 >>> find_largest_sum(1, 1, [[5]]) 5 >>> find_largest_sum(1, 1, [[-5]]) -5 >>> find_largest_sum(3, 3, [[-3, -1, -1], [-2, -5, -6], [-1, -3, -1]]) -1","solution":"def max_sum_subgrid(grid): Returns the largest sum of any rectangle subgrid in the given grid. n = len(grid) m = len(grid[0]) # Initialize max_sum to be the smallest possible value max_sum = float('-inf') # Temporary array used to store sums temp = [0] * n # Use the concept of Kadane's algorithm combined with column sums for left in range(m): # Initialize all elements of temp as 0 temp = [0] * n for right in range(left, m): # Calculate sum between current left and right for every row for i in range(n): temp[i] += grid[i][right] # Now we find the maximum sum subarray in temp array which is equivalent to using Kadane's algorithm current_max = temp[0] local_max = temp[0] for i in range(1, n): local_max = max(temp[i], local_max + temp[i]) current_max = max(current_max, local_max) # Update the max_sum if a new maximum is found max_sum = max(max_sum, current_max) return max_sum # Helper function to process input and generate the grid def find_largest_sum(n, m, elements): grid = [] for i in range(n): grid.append(elements[i]) return max_sum_subgrid(grid)"},{"question":"from typing import List def minimal_max_diff(n: int, m: int, grid: List[List[int]]) -> int: Return the minimal possible value for the maximum difference in height between any two consecutive cells along the optimal path from the top-left corner to the bottom-right corner. >>> minimal_max_diff(3, 3, [[1, 2, 2], [2, 3, 3], [3, 3, 4]]) 1 >>> minimal_max_diff(2, 2, [[1, 1], [1, 1]]) 0 >>> minimal_max_diff(2, 2, [[1, 1000000], [1000000, 1]]) 999999 >>> minimal_max_diff(3, 3, [[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 0 >>> minimal_max_diff(1, 1, [[0]]) 0","solution":"from heapq import heappop, heappush import sys def minimal_max_diff(n, m, grid): # Directions to move: right and down directions = [(0, 1), (1, 0)] # Priority queue to store (max_diff, x, y) pq = [(0, 0, 0)] # Track the minimum maximum difference to reach each cell dist = [[sys.maxsize] * m for _ in range(n)] dist[0][0] = 0 while pq: max_diff, x, y = heappop(pq) if x == n - 1 and y == m - 1: return max_diff for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: curr_diff = abs(grid[nx][ny] - grid[x][y]) new_max_diff = max(max_diff, curr_diff) if new_max_diff < dist[nx][ny]: dist[nx][ny] = new_max_diff heappush(pq, (new_max_diff, nx, ny)) return -1"},{"question":"def optimize_commands(n: int, commands: str) -> str: Takes the number of commands and the command string, and returns the optimized command string after removing redundant sequences. Parameters: n (int): The number of commands. commands (str): The command sequence string. Returns: str: The optimized command sequence. >>> optimize_commands(5, 'MMTMT') 'MTMT' >>> optimize_commands(8, 'TTMMTTMM') 'TMTM' >>> optimize_commands(2, 'MT') 'MT' >>> optimize_commands(1, 'M') 'M' >>> optimize_commands(1, 'T') 'T' >>> optimize_commands(6, 'MMMMMM') 'M' >>> optimize_commands(6, 'TTTTTT') 'T' >>> optimize_commands(6, 'MTMTMT') 'MTMTMT' >>> optimize_commands(0, '') '' >>> optimize_commands(4, 'MTMT') 'MTMT'","solution":"def optimize_commands(n, commands): Takes the number of commands and the command string, and returns the optimized command string after removing redundant sequences. Parameters: n (int): The number of commands. commands (str): The command sequence string. Returns: str: The optimized command sequence. if n <= 1: return commands result = [] for i in range(n): if i == 0 or commands[i] != commands[i - 1]: result.append(commands[i]) return ''.join(result) # Example usage: # n = 5 # commands = \\"MMTMT\\" # print(optimize_commands(n, commands)) # Output: \\"MTMT\\""},{"question":"def zig_zag(n: int, arr: List[int]) -> int: Determine the length of the longest Zigzag Subsequence of the given array. >>> zig_zag(6, [1, 7, 4, 9, 2, 5]) 6 >>> zig_zag(5, [1, 4, 7, 2, 5]) 4 >>> zig_zag(3, [1, 2, 3]) 2 from solution import zig_zag def test_example1(): assert zig_zag(6, [1, 7, 4, 9, 2, 5]) == 6 def test_example2(): assert zig_zag(5, [1, 4, 7, 2, 5]) == 4 def test_example3(): assert zig_zag(3, [1, 2, 3]) == 2 def test_all_increasing(): assert zig_zag(4, [1, 2, 3, 4]) == 2 def test_all_decreasing(): assert zig_zag(4, [4, 3, 2, 1]) == 2 def test_alternating_large_single_zigzag(): assert zig_zag(4, [1, 3, 2, 4]) == 4 def test_single_element(): assert zig_zag(1, [1]) == 1 def test_two_elements(): assert zig_zag(2, [3, 1]) == 2 assert zig_zag(2, [1, 3]) == 2","solution":"def longest_zigzag_sequence(arr): if not arr: return 0 n = len(arr) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): if arr[i] > arr[i - 1]: up[i] = down[i - 1] + 1 down[i] = down[i - 1] elif arr[i] < arr[i - 1]: down[i] = up[i - 1] + 1 up[i] = up[i - 1] else: up[i] = up[i - 1] down[i] = down[i - 1] return max(up[-1], down[-1]) def zig_zag(n, arr): return longest_zigzag_sequence(arr)"},{"question":"def find_min_edges_to_remove(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of edges to be removed such that in the resulting graph, every connected component is a tree. Parameters: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int]]): The edges of the graph as pairs of integers. Returns: int: The minimum number of edges that need to be removed. Example: >>> find_min_edges_to_remove(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) 1 >>> find_min_edges_to_remove(4, 0, []) 0 from typing import List, Tuple def test_example_case(): n, m = 5, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)] assert find_min_edges_to_remove(n, m, edges) == 1 def test_no_edges_case(): n, m = 4, 0 edges = [] assert find_min_edges_to_remove(n, m, edges) == 0 def test_no_cycle_case(): n, m = 4, 3 edges = [(1, 2), (2, 3), (3, 4)] assert find_min_edges_to_remove(n, m, edges) == 0 def test_multiple_components_case(): n, m = 6, 5 edges = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)] assert find_min_edges_to_remove(n, m, edges) == 1 def test_large_cycle_case(): n, m = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert find_min_edges_to_remove(n, m, edges) == 1 def test_disconnected_graph(): n, m = 6, 3 edges = [(1, 2), (3, 4), (5, 6)] assert find_min_edges_to_remove(n, m, edges) == 0","solution":"def find_min_edges_to_remove(n, m, edges): from collections import defaultdict, deque def bfs(start, adj_list, visited): queue = deque([start]) visited[start] = True component_edges = 0 component_vertices = 0 while queue: node = queue.popleft() component_vertices += 1 for neighbor in adj_list[node]: component_edges += 1 if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Each edge is counted twice (once for each vertex), so we divide by 2. component_edges //= 2 return component_edges, component_vertices adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) total_extra_edges = 0 for i in range(1, n + 1): if not visited[i]: component_edges, component_vertices = bfs(i, adj_list, visited) # In a tree, the number of edges is vertices - 1 total_extra_edges += component_edges - (component_vertices - 1) return total_extra_edges"},{"question":"def total_water_acummulation(n: int, m: int, grid: List[List[int]]) -> int: Compute the total water volume that accumulates in the entire grid after the rain stops. >>> total_water_acummulation(3, 3, [ ... [1, 2, 1], ... [2, 1, 2], ... [1, 2, 1] ... ]) 1 >>> total_water_acummulation(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> total_water_acummulation(4, 4, [ ... [1, 2, 2, 1], ... [2, 1, 1, 2], ... [2, 1, 1, 2], ... [1, 2, 2, 1] ... ]) 4 >>> total_water_acummulation(4, 4, [ ... [12, 13, 0, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12] ... ]) 14 >>> total_water_acummulation(3, 3, [ ... [1000, 1000, 1000], ... [1000, 1, 1000], ... [1000, 1000, 1000], ... ]) 999","solution":"import heapq def trapRainWater(elevation_map): if not elevation_map or not elevation_map[0]: return 0 n, m = len(elevation_map), len(elevation_map[0]) visited = [[False for _ in range(m)] for _ in range(n)] heap = [] for i in range(n): for j in range(m): if i == 0 or i == n - 1 or j == 0 or j == m - 1: heapq.heappush(heap, (elevation_map[i][j], i, j)) visited[i][j] = True water = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water += max(0, height - elevation_map[nx][ny]) new_height = max(height, elevation_map[nx][ny]) heapq.heappush(heap, (new_height, nx, ny)) return water def total_water_acummulation(n, m, grid): return trapRainWater(grid)"},{"question":"def arrange_rooks(n: int, k: int): Determines if it is possible to arrange k rooks on an n x n board such that no two rooks can attack each other. If possible, returns the board configuration. Otherwise, returns \\"NO\\". >>> arrange_rooks(3, 2) (\\"YES\\", [['R', '.', '.'], ['.', 'R', '.'], ['.', '.', '.']]) >>> arrange_rooks(4, 4) (\\"YES\\", [['R', '.', '.', '.'], ['.', 'R', '.', '.'], ['.', '.', 'R', '.'], ['.', '.', '.', 'R']]) >>> arrange_rooks(2, 3) \\"NO\\" >>> arrange_rooks(1, 2) \\"NO\\" pass def format_board(board: List[List[str]]) -> str: Converts the board configuration into a string for display. >>> format_board([['R', '.', '.'], ['.', 'R', '.'], ['.', '.', '.']]) \\"R..n.R.n...\\" >>> format_board([['.', '.', 'R'], ['.', 'R', '.'], ['R', '.', '.']]) \\"..Rn.R.nR..\\" pass","solution":"def arrange_rooks(n, k): Determines if it is possible to arrange k rooks on an n x n board such that no two rooks can attack each other. If possible, returns the board configuration. Otherwise, returns \\"NO\\". if k > n: return \\"NO\\" # Initialize the board with empty cells board = [['.' for _ in range(n)] for _ in range(n)] for i in range(k): board[i][i] = 'R' return \\"YES\\", board # Function to format the board into string output def format_board(board): return \\"n\\".join(\\"\\".join(row) for row in board)"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(n, nodes_info): nodes = [None] * (n + 1) for i in range(1, n + 1): if nodes[i] is None: nodes[i] = TreeNode(nodes_info[i - 1][0]) value, left_index, right_index = nodes_info[i - 1] if left_index != 0: nodes[left_index] = TreeNode(nodes_info[left_index - 1][0]) nodes[i].left = nodes[left_index] if right_index != 0: nodes[right_index] = TreeNode(nodes_info[right_index - 1][0]) nodes[i].right = nodes[right_index] return nodes[1] def sum_even_grandparent(root): Calculates the sum of all nodes with even-valued grandparents in a binary tree. >>> input_str = \\"5n2 2 3n6 4 5n8 0 0n1 0 0n7 0 0\\" >>> process_input(input_str) 8 >>> input_str = \\"1n1 0 0\\" >>> process_input(input_str) 0 >>> input_str = \\"4n7 2 3n5 4 0n6 0 0n9 0 0\\" >>> process_input(input_str) 0 >>> input_str = \\"5n4 2 3n6 4 5n8 0 0n12 0 0n14 0 0\\" >>> process_input(input_str) 26 >>> input_str = \\"3n0 2 3n0 0 0n0 0 0\\" >>> process_input(input_str) 0 def dfs(node, parent, grandparent): if node is None: return 0 sum_grandchildren = 0 if grandparent and grandparent.value % 2 == 0: sum_grandchildren += node.value sum_grandchildren += dfs(node.left, node, parent) sum_grandchildren += dfs(node.right, node, parent) return sum_grandchildren return dfs(root, None, None) # Process input and call the functions def process_input(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) nodes_info = [] for i in range(1, n + 1): ai, li, ri = map(int, input_lines[i].split()) nodes_info.append((ai, li, ri)) root = build_tree(n, nodes_info) return sum_even_grandparent(root)","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(n, nodes_info): nodes = [None] * (n + 1) for i in range(1, n + 1): if nodes[i] is None: nodes[i] = TreeNode(nodes_info[i - 1][0]) value, left_index, right_index = nodes_info[i - 1] if left_index != 0: nodes[left_index] = TreeNode(nodes_info[left_index - 1][0]) nodes[i].left = nodes[left_index] if right_index != 0: nodes[right_index] = TreeNode(nodes_info[right_index - 1][0]) nodes[i].right = nodes[right_index] return nodes[1] def sum_even_grandparent(root): def dfs(node, parent, grandparent): if node is None: return 0 sum_grandchildren = 0 if grandparent and grandparent.value % 2 == 0: sum_grandchildren += node.value sum_grandchildren += dfs(node.left, node, parent) sum_grandchildren += dfs(node.right, node, parent) return sum_grandchildren return dfs(root, None, None) # Process input and call the functions def process_input(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) nodes_info = [] for i in range(1, n + 1): ai, li, ri = map(int, input_lines[i].split()) nodes_info.append((ai, li, ri)) root = build_tree(n, nodes_info) return sum_even_grandparent(root)"},{"question":"def find_path(grid: List[str], n: int) -> str: Determines if there exists a path from the top-left to the bottom-right of the grid. Args: grid: List of strings representing the grid. n: Integer, size of the grid. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. >>> find_path([\\"..#.\\", \\"....\\", \\"#.\\", \\"....\\"], 4) \\"YES\\" >>> find_path([\\".#.\\", \\".\\", \\".#.\\"], 3) \\"NO\\" >>> find_path([\\".\\"], 1) \\"YES\\" >>> find_path([\\"#\\"], 1) \\"NO\\" >>> find_path([\\"....\\", \\"....\\", \\"....\\", \\"....\\"], 4) \\"YES\\" >>> find_path([\\"...\\", \\"...\\", \\"..#\\"], 3) \\"NO\\"","solution":"def find_path(grid, n): Determines if there exists a path from the top-left to the bottom-right of the grid. Args: grid: List of strings representing the grid. n: Integer, size of the grid. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. from collections import deque if grid[0][0] == '#' or grid[n-1][n-1] == '#': return \\"NO\\" directions = [(1, 0), (0, 1)] # Possible movements: right, down queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == n-1 and y == n-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) grid = [data[i + 1] for i in range(n)] print(find_path(grid, n))"},{"question":"from typing import List def max_books_on_shelf(n: int, H: int, heights: List[int]) -> int: Determines the maximum number of books that can be placed on the shelf without exceeding the given maximum height and ensuring the books are sorted in non-decreasing order of their heights. :param n: Number of books :param H: Maximum allowed total height of books on the shelf :param heights: List of book heights :return: Maximum number of books that can be placed on the shelf pass def test_max_books_on_shelf(): # Test case 1: Example given in the question assert max_books_on_shelf(5, 15, [2, 3, 5, 8, 1]) == 4 # Test case 2: All books can fit on the shelf assert max_books_on_shelf(3, 10, [2, 2, 2]) == 3 # Test case 3: No book can fit on the shelf assert max_books_on_shelf(3, 1, [2, 3, 4]) == 0 # Test case 4: Only some books can fit on the shelf assert max_books_on_shelf(4, 7, [8, 1, 2, 4]) == 3 # Test case 5: Books already sorted in non-decreasing order assert max_books_on_shelf(5, 10, [1, 2, 2, 2, 3]) == 5 # Test case 6: Heights in reverse order assert max_books_on_shelf(3, 5, [3, 2, 1]) == 2 # Test case 7: Single book can fit on the shelf assert max_books_on_shelf(1, 5, [4]) == 1 # Test case 8: Single book cannot fit on the shelf assert max_books_on_shelf(1, 1, [2]) == 0","solution":"def max_books_on_shelf(n, H, heights): Determines the maximum number of books that can be placed on the shelf without exceeding the given maximum height and ensuring the books are sorted in non-decreasing order of their heights. :param n: Number of books :param H: Maximum allowed total height of books on the shelf :param heights: List of book heights :return: Maximum number of books that can be placed on the shelf # Sort book heights heights.sort() # Initialize variables current_height = 0 max_books = 0 # Iterate through the sorted list and find the maximum number of books for height in heights: if current_height + height <= H: current_height += height max_books += 1 else: break return max_books"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def dijkstra(graph, start, n): Returns the shortest distance from start to all other nodes using Dijkstra's algorithm. distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def minimum_round_trip_time(n: int, m: int, edges: List[Tuple[int, int, int]], u: int, v: int) -> int: Returns the minimum round trip time from u to v and back to u. >>> n, m = 4, 5 >>> edges = [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3)] >>> u, v = 1, 4 >>> minimum_round_trip_time(n, m, edges, u, v) 10 >>> n, m = 3, 2 >>> edges = [(1, 2, 5), (2, 3, 7)] >>> u, v = 1, 3 >>> minimum_round_trip_time(n, m, edges, u, v) 24 >>> n, m = 5, 6 >>> edges = [(1, 2, 3), (1, 3, 2), (2, 3, 4), (2, 4, 7), (3, 5, 1), (4, 5, 3)] >>> u, v = 1, 5 >>> minimum_round_trip_time(n, m, edges, u, v) 6 >>> n, m = 4, 2 >>> edges = [(1, 2, 2), (3, 4, 2)] >>> u, v = 1, 3 >>> minimum_round_trip_time(n, m, edges, u, v) -1 pass","solution":"import heapq from collections import defaultdict def dijkstra(graph, start, n): Returns the shortest distance from start to all other nodes using Dijkstra's algorithm. distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def minimum_round_trip_time(n, m, edges, u, v): Returns the minimum round trip time from u to v and back to u. graph = defaultdict(list) for x, y, w in edges: graph[x].append((y, w)) graph[y].append((x, w)) distances_from_u = dijkstra(graph, u, n) distances_from_v = dijkstra(graph, v, n) if distances_from_u[v] == float('inf') or distances_from_v[u] == float('inf'): return -1 return distances_from_u[v] + distances_from_v[u]"},{"question":"def find_lca(n: int, parent_array: List[int], p: int, q: int) -> int: Finds the lowest common ancestor (LCA) of two nodes in a binary tree. Args: n: int : Number of nodes in the tree parent_array: List[int] : The parent array of the tree p: int : The first node for which to find the LCA q: int : The second node for which to find the LCA Returns: int : The lowest common ancestor of nodes p and q Test cases: >>> find_lca(5, [-1, 1, 1, 2, 2], 3, 4) 1 >>> find_lca(7, [-1, 1, 1, 2, 2, 3, 3], 4, 5) 2 >>> find_lca(5, [-1, 1, 1, 2, 2], 3, 3) 3 >>> find_lca(5, [-1, 1, 1, 2, 2], 2, 4) 2 >>> find_lca(5, [-1, 1, 1, 2, 2], 5, 4) 2 >>> find_lca(6, [-1, 1, 1, 2, 2, 3], 6, 4) 1","solution":"def find_lca(n, parent_array, p, q): Finds the lowest common ancestor (LCA) of two nodes in a binary tree. n: int : Number of nodes in the tree parent_array: List[int] : The parent array of the tree p: int : The first node for which to find the LCA q: int : The second node for which to find the LCA Returns: int : The lowest common ancestor of nodes p and q # Function to find the path from the root to a given node def find_path(node, parent_array): path = [] while node != -1: path.append(node) node = parent_array[node - 1] return path # Find paths from the root to p and q path_p = find_path(p, parent_array) path_q = find_path(q, parent_array) # The first common node in the paths from the end is the LCA lca = -1 i, j = len(path_p) - 1, len(path_q) - 1 while i >= 0 and j >= 0 and path_p[i] == path_q[j]: lca = path_p[i] i -= 1 j -= 1 return lca # Example usage N = 5 parent_array = [-1, 1, 1, 2, 2] p, q = 3, 4 print(find_lca(N, parent_array, p, q)) # Output: 1"},{"question":"def is_bipartite(n, m, edges): Determine if the given undirected graph is bipartite. Args: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges represented as tuples of two vertices. Returns: str: \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\"","solution":"def is_bipartite(n, m, edges): from collections import deque def bfs(start): queue = deque([start]) colors[start] = 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if colors[neighbor] == -1: colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True adj_list = [[] for _ in range(n + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) colors = [-1] * (n + 1) for i in range(1, n + 1): if colors[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"def max_subarray_product(nums): Takes an array of integers and returns the maximum possible product of any subarray within that array. >>> max_subarray_product([5]) 5 >>> max_subarray_product([2, 3, 4]) 24 >>> max_subarray_product([-5]) -5 >>> max_subarray_product([2, 3, -2, 4]) 6 >>> max_subarray_product([0, 2, 3, -2, 4, 0, -1]) 6 >>> max_subarray_product([-2, -3, -4, -1]) 24 >>> max_subarray_product([0, -3, 0, 4, 0, 2, 0]) 4 >>> max_subarray_product([2, 3, -2, 4, -1]) 48 >>> max_subarray_product([1] * 100) 1 >>> max_subarray_product([0] * 100) 0 >>> max_subarray_product([0] * 50 + [1, -1] * 50) 1","solution":"def max_subarray_product(nums): Takes an array of integers and returns the maximum possible product of any subarray within that array. if not nums: return 0 max_product = float('-inf') current_max, current_min = 1, 1 for num in nums: if num == 0: current_max, current_min = 1, 1 max_product = max(max_product, 0) continue temp_max = current_max * num current_max = max(num, temp_max, current_min * num) current_min = min(num, temp_max, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"def maximum_productivity_sum(n: int, m: int, productivity: List[List[int]]) -> int: Determine the maximum productivity sum of any subrectangle within the field. >>> maximum_productivity_sum(4, 5, [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) == 29 >>> maximum_productivity_sum(1, 1, [[0]]) == 0 >>> maximum_productivity_sum(2, 2, [[-1, -2], [-3, -4]]) == -1 >>> maximum_productivity_sum(1, 5, [[1, -2, 3, -1, 2]]) == 4 >>> maximum_productivity_sum(5, 1, [[1], [-2], [3], [-1], [2]]) == 4 >>> maximum_productivity_sum(3, 3, [[1, 2, 3], [4, 5, 6], [-1, -2, -3]]) == 21","solution":"def maximum_productivity_sum(n, m, productivity): def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += productivity[i][right] current_max = kadane(temp) max_sum = max(max_sum, current_max) return max_sum"},{"question":"def can_reorder_to_odd_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to reorder the sequence such that the sum of every two consecutive elements is odd. >>> can_reorder_to_odd_sum(1, [(4, [1, 2, 3, 4])]) [\\"YES\\"] >>> can_reorder_to_odd_sum(1, [(3, [2, 4, 6])]) [\\"NO\\"] >>> can_reorder_to_odd_sum(1, [(5, [1, 3, 5, 7, 9])]) [\\"NO\\"]","solution":"def can_reorder_to_odd_sum(t, test_cases): results = [] for case in test_cases: n, sequence = case odd_count = sum(1 for x in sequence if x % 2 != 0) even_count = n - odd_count # Check if it's possible to have alternating odd and even sequences if odd_count > 0 and even_count > 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_insertions_deletions_to_balance(s: str) -> int: Anjali loves balanced parentheses! A string is considered balanced if every opening parenthesis '(' has a corresponding closing parenthesis ')', and the parentheses are properly nested. You are given a string s consisting of only '(' and ')'. Anjali wants to balance the string by performing the minimum number of insertions or deletions of parentheses. Write a function that returns the minimum number of insertions or deletions required to balance the string. >>> min_insertions_deletions_to_balance(\\"(()\\") 1 >>> min_insertions_deletions_to_balance(\\"())(\\") 2 >>> min_insertions_deletions_to_balance(\\"(((\\") 3 >>> min_insertions_deletions_to_balance(\\")))\\") 3 >>> min_insertions_deletions_to_balance(\\"()()\\") 0 >>> min_insertions_deletions_to_balance(\\")(\\") 2 >>> min_insertions_deletions_to_balance(\\"(())\\") 0 >>> min_insertions_deletions_to_balance(\\"\\") 0","solution":"def min_insertions_deletions_to_balance(s): open_needed = 0 close_needed = 0 for char in s: if char == '(': # Increase the number of closing paren needed close_needed += 1 else: # If a closing paren is present but no open paren to match with, we need an open paren if close_needed == 0: open_needed += 1 else: # Match a closing paren with an open paren close_needed -= 1 # The total insertions/deletions needed will be the sum of remaining unmatched open and close parens return open_needed + close_needed"},{"question":"from typing import List def max_path_sum(matrix: List[List[int]]) -> int: Given a matrix of size n x n filled with non-negative integers, find the maximum possible sum of values traveling from the top-left to the bottom-right cell moving only to the right or downward. >>> max_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_path_sum([ ... [1, 2], ... [1, 1] ... ]) 4 # Write your code here # Unit Tests def test_max_path_sum(): matrix1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_path_sum(matrix1) == 12 matrix2 = [ [1, 2], [1, 1] ] assert max_path_sum(matrix2) == 4 matrix3 = [ [5] ] assert max_path_sum(matrix3) == 5 matrix4 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_path_sum(matrix4) == 29 matrix5 = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_path_sum(matrix5) == 5 matrix6 = [ [1, 10, 3], [1, 5, 1], [4, 2, 1] ] assert max_path_sum(matrix6) == 19 empty_matrix = [] assert max_path_sum(empty_matrix) == 0 matrix7 = [ [1000, 1000], [1000, 1000] ] assert max_path_sum(matrix7) == 3000 matrix8 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_path_sum(matrix8) == 0","solution":"def max_path_sum(matrix): n = len(matrix) if n == 0: return 0 # Create a DP table to store the maximum path sums up to each cell dp = [[0] * n for _ in range(n)] dp[0][0] = matrix[0][0] # Initialize the first row & column of the DP table for i in range(1, n): dp[0][i] = dp[0][i-1] + matrix[0][i] dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the DP table by choosing the max path sum for each cell for i in range(1, n): for j in range(1, n): dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[n-1][n-1] # Sample matrix for example example_matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] # Output the result for the sample matrix print(max_path_sum(example_matrix)) # Output should be 12"},{"question":"def can_rearrange_buildings(buildings, k): Determine if it is possible to rearrange the buildings in such a way that the difference in height between any two adjacent buildings does not exceed a given threshold value, \`k\`. If it is possible, return \\"Possible\\" followed by the arrangement; otherwise, return \\"Not Possible\\". >>> can_rearrange_buildings([3, 1, 4, 2], 2) ('Possible', [1, 2, 3, 4]) >>> can_rearrange_buildings([5, 7, 5], 1) 'Not Possible' # Your code here def process_test_cases(t, test_cases): Process the test cases and determine the possibility of rearranging buildings for each case. >>> process_test_cases(2, [(4, 2, [3, 1, 4, 2]), (3, 1, [5, 7, 5])]) [('Possible', [1, 2, 3, 4]), 'Not Possible'] # Your code here # Unit tests def test_rearrange_possible(): buildings = [3, 1, 4, 2] k = 2 assert can_rearrange_buildings(buildings, k) == ('Possible', [1, 2, 3, 4]) def test_rearrange_not_possible(): buildings = [5, 7, 5] k = 1 assert can_rearrange_buildings(buildings, k) == \\"Not Possible\\" def test_process_test_cases(): t = 2 test_cases = [ (4, 2, [3, 1, 4, 2]), (3, 1, [5, 7, 5]), ] results = process_test_cases(t, test_cases) assert results == [ ('Possible', [1, 2, 3, 4]), 'Not Possible' ] def test_rearrange_edge_cases(): buildings = [1, 2] k = 1 assert can_rearrange_buildings(buildings, k) == ('Possible', [1, 2]) buildings = [1000, 1] k = 999 assert can_rearrange_buildings(buildings, k) == ('Possible', [1, 1000]) def test_process_single_case(): t = 1 test_cases = [ (2, 3, [5, 8]), ] results = process_test_cases(t, test_cases) assert results == [ ('Possible', [5, 8]), ]","solution":"def can_rearrange_buildings(buildings, k): buildings.sort() # Check if rearranged buildings meet the criteria for i in range(1, len(buildings)): if abs(buildings[i] - buildings[i-1]) > k: return \\"Not Possible\\" return \\"Possible\\", buildings def process_test_cases(t, test_cases): results = [] for i in range(t): n, k, buildings = test_cases[i] result = can_rearrange_buildings(buildings, k) results.append(result) return results"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions required to convert a string into a palindrome. >>> min_insertions_to_palindrome(\\"abcd\\") 3 >>> min_insertions_to_palindrome(\\"racecar\\") 0 >>> min_insertions_to_palindrome(\\"abca\\") 1","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to convert a string into a palindrome using Dynamic Programming to find the Longest Palindromic Subsequence (LPS). n = len(s) # Create a table to store results of subproblems dp = [[0] * n for _ in range(n)] # Strings of length 1 are palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table. The lower diagonal values of the table are # not used and not filled in the process. for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of longest palindromic subsequence lps = dp[0][n - 1] # Minimum number of insertions to make the string a palindrome return n - lps"},{"question":"def can_sort_coins(n: int, coins: List[int], S: int) -> str: Determines if the coins can be sorted under the given swap constraint. Parameters: n (int): Number of coins. coins (list of int): Current order of coin values. S (int): Maximum allowable sum of values for a swap. Returns: str: \\"YES\\" if the coins can be sorted under the given constraint, \\"NO\\" otherwise. >>> can_sort_coins(5, [4, 2, 3, 5, 1], 6) \\"YES\\" >>> can_sort_coins(4, [1, 2, 3, 4], 5) \\"YES\\" >>> can_sort_coins(3, [3, 2, 1], 2) \\"NO\\" >>> can_sort_coins(1, [10], 10) \\"YES\\" >>> can_sort_coins(3, [2, 3, 1], 5) \\"YES\\" >>> can_sort_coins(5, [5, 3, 4, 1, 2], 10) \\"YES\\" >>> can_sort_coins(5, [5, 4, 3, 2, 1], 3) \\"NO\\" # Your code here","solution":"def can_sort_coins(n, coins, S): Determines if the coins can be sorted under the given swap constraint. Parameters: n (int): Number of coins. coins (list of int): Current order of coin values. S (int): Maximum allowable sum of values for a swap. Returns: str: \\"YES\\" if the coins can be sorted under the given constraint, \\"NO\\" otherwise. sorted_coins = sorted(coins) def bfs_can_sort(): from collections import deque visited = set() queue = deque([coins]) while queue: current_state = queue.popleft() if tuple(current_state) in visited: continue visited.add(tuple(current_state)) if current_state == sorted_coins: return True for i in range(n): for j in range(i + 1, n): if current_state[i] + current_state[j] <= S: new_state = current_state[:] new_state[i], new_state[j] = new_state[j], new_state[i] if tuple(new_state) not in visited: queue.append(new_state) return False return \\"YES\\" if bfs_can_sort() else \\"NO\\" # Example usage # n = 5 # coins = [4, 2, 3, 5, 1] # S = 6 # print(can_sort_coins(n, coins, S)) # Output: \\"YES\\""},{"question":"def min_total_charge(d: int, n: int, capacities: List[int], charges: List[int]) -> int: Determines the indices of the robots to be used, and the minimum total battery charge used to meet the delivery requirement. If it is not possible to meet the delivery requirement, returns -1. Parameters: d (int): Delivery requirement. n (int): Number of robots. capacities (list): List of integers representing each robot's maximum battery capacity. charges (list): List of integers representing each robot's current battery charge. Returns: int: Minimum total battery charge needed to meet the delivery requirement or -1 if it is not possible. pass from solution import min_total_charge def test_example_case(): d = 10 n = 5 capacities = [4, 3, 6, 7, 5] charges = [2, 1, 3, 2, 4] assert min_total_charge(d, n, capacities, charges) == 5 def test_insufficient_capacity(): d = 15 n = 3 capacities = [4, 5, 3] charges = [2, 3, 1] assert min_total_charge(d, n, capacities, charges) == -1 def test_exact_capacity(): d = 12 n = 4 capacities = [3, 4, 5, 6] charges = [3, 2, 1, 5] assert min_total_charge(d, n, capacities, charges) == 6 def test_multiple_min_capacities(): d = 8 n = 4 capacities = [2, 4, 3, 6] charges = [5, 1, 4, 3] assert min_total_charge(d, n, capacities, charges) == 4 def test_all_robots_needed(): d = 10 n = 3 capacities = [3, 3, 4] charges = [3, 3, 3] assert min_total_charge(d, n, capacities, charges) == 9","solution":"def min_total_charge(d, n, capacities, charges): Determines the indices of the robots to be used, and the minimum total battery charge used to meet the delivery requirement. If it is not possible to meet the delivery requirement, returns -1. Parameters: d (int): Delivery requirement. n (int): Number of robots. capacities (list): List of integers representing each robot's maximum battery capacity. charges (list): List of integers representing each robot's current battery charge. Returns: int: Minimum total battery charge needed to meet the delivery requirement or -1 if it is not possible. # Combine capacity and charge into a list of tuples and sort by charge robots = sorted(zip(capacities, charges), key=lambda x: x[1]) total_capacity = 0 total_charge = 0 for capacity, charge in robots: total_capacity += capacity total_charge += charge if total_capacity >= d: return total_charge return -1 # If cannot meet the delivery requirement"},{"question":"def minimum_task_time(n: int, tasks: List[int]) -> int: Assign tasks to workers A and B such that the tasks are completed in the minimum amount of time. The time taken to complete the tasks is the maximum of the total time taken by either of the workers. Args: n: An integer representing the number of tasks. tasks: A list of integers where each integer represents the time required to complete a task. Returns: An integer representing the minimum possible time required to complete all the tasks. >>> minimum_task_time(5, [2, 2, 3, 4, 5]) 8 >>> minimum_task_time(3, [1, 2, 3]) 3","solution":"def minimum_task_time(n, tasks): def helper(index, time_a, time_b): if index == n: return max(time_a, time_b) task_time = tasks[index] # Assign current task to worker A assign_to_a = helper(index + 1, time_a + task_time, time_b) # Assign current task to worker B assign_to_b = helper(index + 1, time_a, time_b + task_time) # Return the minimum time achievable return min(assign_to_a, assign_to_b) return helper(0, 0, 0)"},{"question":"def shortest_paths(n: int, m: int, grid: List[str]) -> int: Calculate the number of different shortest paths from the top-left cell (1,1) to the bottom-right cell (n,m) in a grid with obstacles. Args: n: The number of rows in the grid. m: The number of columns in the grid. grid: A list of strings representing the grid, where \\".\\" is an empty cell and \\"#\\" is an obstacle. Returns: The number of different shortest paths. If it's impossible to reach the target cell, returns 0. Example: >>> shortest_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> shortest_paths(3, 3, [\\"#.#\\", \\".#.\\", \\"...\\"]) 0","solution":"from collections import deque def shortest_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' queue = deque([(0, 0)]) visited = [[False for _ in range(m)] for _ in range(n)] visited[0][0] = True paths = [[0 for _ in range(m)] for _ in range(n)] paths[0][0] = 1 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): if not visited[nx][ny]: queue.append((nx, ny)) visited[nx][ny] = True if grid[nx][ny] == '.': paths[nx][ny] += paths[x][y] return paths[n-1][m-1] def parse_input(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) grid = [] index = 2 for i in range(n): grid.append(data[index + i]) return n, m, grid if __name__ == \\"__main__\\": n, m, grid = parse_input() print(shortest_paths(n, m, grid))"},{"question":"from typing import List def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determines if there are two distinct indices i and j such that nums[i] == nums[j] and the absolute difference between i and j is at most k. >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 3) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False >>> contains_nearby_duplicate([1], 1) False >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 3) False >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([99, 99], 2) True >>> contains_nearby_duplicate([1, 2, 3, 4, 5, 1], 5) True","solution":"def contains_nearby_duplicate(nums, k): Determines if there are two distinct indices i and j such that nums[i] == nums[j] and the absolute difference between i and j is at most k. index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def is_prime(number: int) -> bool: Returns True if the number is prime, otherwise False. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False def determine_winner(seq: List[int]) -> str: Determines the winner of the game given the initial sequence of numbers with optimal play. >>> determine_winner([3, 5, 7, 11]) 'Bob' >>> determine_winner([3, 5, 8, 9]) 'Alice' >>> determine_winner([4, 6, 8, 9]) 'Alice' >>> determine_winner([2, 3, 5, 7]) 'Bob'","solution":"def is_prime(number): Returns True if the number is prime, otherwise False if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def determine_winner(seq): Determines the winner of the game given the initial sequence of numbers with optimal play. # Counting how many non-prime numbers there are non_prime_count = sum(not is_prime(num) for num in seq) # If there are any non-prime numbers initially, Alice wins as she starts first if non_prime_count > 0: return \\"Alice\\" # Otherwise, if all numbers are prime, Bob wins because Alice has to make a non-prime move return \\"Bob\\""},{"question":"def max_book_values(n: int, m: int, bookshelf_values: List[List[int]]) -> int: Returns the maximum total book values Liam can remove by picking exactly one book from each shelf. Parameters: - n (int): Number of bookshelves - m (int): Number of books on each shelf - bookshelf_values (list of list of int): Values of books on each shelf Returns: - int: Maximum total value of books removed >>> max_book_values(3, 4, [[5, 3, 8, 4], [6, 1, 2, 7], [4, 9, 5, 1]]) == 24 >>> max_book_values(2, 3, [[1, 1, 1], [1, 1, 1]]) == 2 >>> max_book_values(2, 3, [[10, 20, 30], [40, 50, 60]]) == 90 >>> max_book_values(1, 4, [[1, 2, 3, 4]]) == 4 >>> max_book_values(2, 2, [[100, 200], [300, 500]]) == 700","solution":"def max_book_values(n, m, bookshelf_values): Returns the maximum total book values Liam can remove by picking exactly one book from each shelf. Parameters: n (int): Number of bookshelves m (int): Number of books on each shelf bookshelf_values (list of list of int): Values of books on each shelf Returns: int: Maximum total value of books removed total_value = 0 for shelf in bookshelf_values: total_value += max(shelf) return total_value"},{"question":"def max_matches(n: int, d: int, skills: List[int]) -> int: Returns the maximum number of matches that can be scheduled such that the difference in skill levels of the players in any match is not more than d. >>> max_matches(5, 3, [1, 6, 4, 3, 8]) 2 >>> max_matches(4, 1, [1, 3, 5, 7]) 0 from solution import max_matches def test_example_case(): assert max_matches(5, 3, [1, 6, 4, 3, 8]) == 2 def test_no_matches_possible(): assert max_matches(4, 1, [1, 3, 5, 7]) == 0 def test_all_players_can_be_paired(): assert max_matches(6, 5, [1, 2, 3, 6, 7, 8]) == 3 def test_single_player(): assert max_matches(1, 0, [10]) == 0 def test_players_with_same_skills(): assert max_matches(4, 0, [2, 2, 2, 2]) == 2 def test_edge_case_large_d(): assert max_matches(5, 100000, [1, 2, 3, 4, 5]) == 2 def test_players_with_gaps(): assert max_matches(5, 2, [1, 8, 5, 12, 3]) == 1","solution":"def max_matches(n, d, skills): Returns the maximum number of matches that can be scheduled such that the difference in skill levels of the players in any match is not more than d. skills.sort() matches = 0 i = 0 while i < n - 1: if skills[i + 1] - skills[i] <= d: matches += 1 i += 2 # Move to the next pair else: i += 1 # Check the next player for a possible match return matches"},{"question":"def determine_game_winner(n: int, k: int, sequence: List[int]) -> str: Determines the winner of the game between Alice and Bob based on the initial sequence and the number of moves k. Parameters: n (int): Number of integers in the sequence k (int): Number of moves sequence (list of int): The initial sequence of integers Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins, \\"Draw\\" if it is a draw Examples: >>> determine_game_winner(5, 1, [1, -1, 1, -1, 1]) \\"Alice\\" >>> determine_game_winner(4, 2, [1, -1, 1, -1]) \\"Draw\\" >>> determine_game_winner(3, 3, [1, 1, -1]) \\"Alice\\" >>> determine_game_winner(6, 3, [1, 1, 1, -1, -1, -1]) \\"Alice\\" >>> determine_game_winner(6, 4, [1, 1, 1, -1, -1, -1]) \\"Draw\\" >>> determine_game_winner(5, 2, [1, 1, 1, 1, 1]) \\"Alice\\" >>> determine_game_winner(5, 2, [-1, -1, -1, -1, -1]) \\"Bob\\" >>> determine_game_winner(3, 100000, [1, 1, 1]) \\"Alice\\" >>> determine_game_winner(3, 100000, [-1, -1, -1]) \\"Bob\\" >>> determine_game_winner(4, 3, [1, -1, 1, -1]) \\"Alice\\" >>> determine_game_winner(4, 4, [1, -1, 1, -1]) \\"Draw\\"","solution":"def determine_game_winner(n, k, sequence): Determines the winner of the game between Alice and Bob based on the initial sequence and the number of moves k. Parameters: n (int): Number of integers in the sequence k (int): Number of moves sequence (list of int): The initial sequence of integers Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins, \\"Draw\\" if it is a draw sequence_sum = sum(sequence) # As the moves are reversals of contiguous segments, their impact on the sequence sum alternates with parity of k. if k % 2 == 0: if sequence_sum == 0: return \\"Draw\\" else: return \\"Alice\\" if sequence_sum > 0 else \\"Bob\\" else: # when k is odd, Alice has final move, can make sum positive return \\"Alice\\" if sequence_sum >= 0 else \\"Bob\\" # Example usage print(determine_game_winner(5, 1, [1, -1, 1, -1, 1])) # Output: Alice print(determine_game_winner(4, 2, [1, -1, 1, -1])) # Output: Draw print(determine_game_winner(3, 3, [1, 1, -1])) # Output: Alice"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Finds the integer that occurs an odd number of times in the array. >>> find_odd_occurrence([1]) 1 >>> find_odd_occurrence([2, 2, 4, 4, 4, 4, 3]) 3 >>> find_odd_occurrence([10, 10, 20, 20, 30]) 30 >>> find_odd_occurrence([40, 50, 50, 60, 60]) 40 >>> find_odd_occurrence([5, 10, 5, 10, 100, 100, 200]) 200","solution":"def find_odd_occurrence(arr): Finds the integer that occurs an odd number of times in the array. result = 0 for number in arr: result ^= number return result"},{"question":"def minimize_max_subarray_sum(arr: List[int], k: int) -> int: You are given an array of positive integers of length \`n\`, and an integer \`k\`. Your task is to divide this array into exactly \`k\` non-overlapping contiguous subarrays such that the maximum sum of elements in any of the subarrays is minimized. >>> minimize_max_subarray_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_subarray_sum([10], 1) 10 >>> minimize_max_subarray_sum([5, 5, 5, 5, 5], 3) 10 >>> minimize_max_subarray_sum([1000000000, 1000000000, 1000000000, 1000000000], 2) 2000000000 >>> minimize_max_subarray_sum([1, 2, 3, 4, 5], 5) 5 >>> minimize_max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_subarray_sum([1, 1, 1, 1, 1], 1) 5 pass","solution":"def minimize_max_subarray_sum(arr, k): def can_split_with_max_sum(mid): current_sum = 0 subarrays = 1 for num in arr: current_sum += num if current_sum > mid: subarrays += 1 current_sum = num if subarrays > k: return False return True left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if can_split_with_max_sum(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def max_unique_trades(n: int, stickers: List[int]) -> int: Returns the maximum number of unique trades that can be made in a day. :param n: Number of children. :param stickers: List of stickers each child has. :return: Maximum number of unique trades. >>> max_unique_trades(4, [1, 2, 3, 4]) 6 >>> max_unique_trades(1, [5]) 0 >>> max_unique_trades(3, [2, 2, 2]) 0 >>> max_unique_trades(2, [3, 3]) 0 >>> max_unique_trades(5, [1, 100, 50, 75, 25]) 10 >>> max_unique_trades(4, [2, 1, 4, 3]) 6","solution":"def max_unique_trades(n, stickers): Returns the maximum number of unique trades that can be made in a day. :param n: Number of children. :param stickers: List of stickers each child has. :return: Maximum number of unique trades. stickers_sorted = sorted(stickers) trades = 0 for i in range(n): for j in range(i + 1, n): if stickers_sorted[j] > stickers_sorted[i]: trades += 1 return trades"},{"question":"from collections import deque def process_queue_operations(n, m, operations): Processes a series of queue operations and returns the results of DEQUEUE and PRINTFRONT operations. Args: n (int): The initial number of integers in the queue. m (int): The number of operations to perform. operations (List[List[int]]): A list of operations to be performed on the queue. Returns: List[int]: A list of results from DEQUEUE and PRINTFRONT operations. Example: >>> process_queue_operations(4, 6, [[3], [2], [1, 5], [3], [2], [3]]) [1, 1, 2, 5] >>> process_queue_operations(3, 4, [[3], [2], [2], [3]]) [1, 2, 3] queue = deque(range(1, n+1)) results = [] for operation in operations: if operation[0] == 1: # ENQUEUE x x = operation[1] queue.append(x) elif operation[0] == 2: # DEQUEUE if queue: results.append(queue.popleft()) elif operation[0] == 3: # PRINTFRONT if queue: results.append(queue[0]) return results","solution":"from collections import deque def process_queue_operations(n, m, operations): queue = deque(range(1, n+1)) results = [] for operation in operations: if operation[0] == 1: # ENQUEUE x x = operation[1] queue.append(x) elif operation[0] == 2: # DEQUEUE if queue: results.append(queue.popleft()) elif operation[0] == 3: # PRINTFRONT if queue: results.append(queue[0]) return results"},{"question":"from typing import List def combinationSum(arr: List[int], s: int) -> List[List[int]]: Find all unique combinations of elements in the array that sum up to a target number. The same combination of numbers is counted only once, and the combinations can be presented in any order. Each element in the array can be used multiple times. Args: arr (List[int]): List of positive integers. s (int): Target sum. Returns: List[List[int]]: List of all unique combinations that sum up to the target. >>> combinationSum([2, 3, 6, 7], 7) [[7], [2, 2, 3]] >>> combinationSum([3, 5, 7], 2) [] >>> combinationSum([1, 2], 4) [[1, 1, 1, 1], [1, 1, 2], [2, 2]] >>> combinationSum([5], 10) [[5, 5]] >>> combinationSum([1], 1) [[1]] >>> combinationSum([2, 4, 6, 8], 8) [[2, 2, 2, 2], [2, 2, 4], [2, 6], [4, 4], [8]]","solution":"from typing import List def combinationSum(arr: List[int], s: int) -> List[List[int]]: result = [] arr.sort() def backtrack(remaining_sum, current_combination, start): if remaining_sum == 0: result.append(list(current_combination)) return for i in range(start, len(arr)): if arr[i] > remaining_sum: break current_combination.append(arr[i]) backtrack(remaining_sum - arr[i], current_combination, i) current_combination.pop() backtrack(s, [], 0) return result"},{"question":"import heapq from typing import List, Tuple def shortest_path_from_source(n: int, m: int, edges: List[Tuple[int, int, int]], source: int) -> List[int]: Finds the shortest path distances from the source node to every other node. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples where each tuple represents (u, v, w), directed edge from u to v with weight w :param source: The source node :return: List of shortest path distances from the source node to every other node. If a node is unreachable, its distance is -1. Example: >>> shortest_path_from_source(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1) [0, 2, 3, 9, 6] >>> shortest_path_from_source(4, 2, [(1, 2, 1), (2, 3, 2)], 1) [0, 1, 3, -1] >>> shortest_path_from_source(1, 0, [], 1) [0] >>> shortest_path_from_source(6, 6, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (4, 5, 1), (5, 6, 2)], 1) [0, 1, 3, 6, 7, 9] >>> shortest_path_from_source(100000, 99999, [(i, i+1, 1) for i in range(1, 100000)], 1)[-1] 99999 >>> shortest_path_from_source(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], 1) [0, 1, 2, 3]","solution":"import heapq def shortest_path_from_source(n, m, edges, source): Finds the shortest path distances from the source node to every other node. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples where each tuple represents (u, v, w) directed edge from u to v with weight w :param source: The source node :return: List of shortest path distances from the source node to every other node. If a node is unreachable, its distance is -1. graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) distances = {i: float('inf') for i in range(1, n+1)} distances[source] = 0 min_heap = [(0, source)] # (distance, node) while min_heap: curr_dist, u = heapq.heappop(min_heap) if curr_dist > distances[u]: continue for v, weight in graph[u]: distance = curr_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) result = [] for i in range(1, n+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"import heapq from typing import List, Tuple def minimum_effort_path(m: int, n: int, grid: List[List[int]], start: Tuple[int, int], peak: Tuple[int, int]) -> int: Calculate the minimum effort path from the starting point to the peak in a mountain grid. Parameters: m (int): Number of rows in the grid n (int): Number of columns in the grid grid (List[List[int]]): The elevation grid start (Tuple[int, int]): Starting coordinate in the grid peak (Tuple[int, int]): Peak coordinate in the grid Returns: int: Minimum effort required to reach the peak Example: >>> m, n = 3, 3 >>> grid = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> start = (0, 0) >>> peak = (2, 2) >>> minimum_effort_path(m, n, grid, start, peak) 2 def test_sample_case(): m, n = 3, 3 grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] start = (0, 0) peak = (2, 2) assert minimum_effort_path(m, n, grid, start, peak) == 2 def test_single_cell(): m, n = 1, 1 grid = [ [0] ] start = (0, 0) peak = (0, 0) assert minimum_effort_path(m, n, grid, start, peak) == 0 def test_adjacent_cells(): m, n = 2, 2 grid = [ [1, 10], [10, 1] ] start = (0, 0) peak = (0, 1) assert minimum_effort_path(m, n, grid, start, peak) == 9 def test_large_grid(): m, n = 3, 3 grid = [ [1, 2, 3], [3, 4, 5], [5, 6, 7] ] start = (0, 0) peak = (2, 2) assert minimum_effort_path(m, n, grid, start, peak) == 2 def test_disjoint_path(): m, n = 2, 2 grid = [ [1, 1000], [1, 1000] ] start = (0, 0) peak = (1, 1) assert minimum_effort_path(m, n, grid, start, peak) == 999","solution":"import heapq def minimum_effort_path(m, n, grid, start, peak): def neighbors(x, y): for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 <= nx < m and 0 <= ny < n: yield nx, ny x1, y1 = start x2, y2 = peak efforts = [[float('inf')] * n for _ in range(m)] efforts[x1][y1] = 0 min_heap = [(0, x1, y1)] while min_heap: effort, x, y = heapq.heappop(min_heap) if (x, y) == (x2, y2): return effort for nx, ny in neighbors(x, y): current_effort = max(effort, abs(grid[x][y] - grid[nx][ny])) if current_effort < efforts[nx][ny]: efforts[nx][ny] = current_effort heapq.heappush(min_heap, (current_effort, nx, ny)) return efforts[x2][y2] # Example usage if __name__ == \\"__main__\\": m, n = 3, 3 grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] start = (0, 0) peak = (2, 2) result = minimum_effort_path(m, n, grid, start, peak) print(result) # Output: 2"},{"question":"def count_valid_pairs(n: int) -> int: Returns the number of pairs (a, b) such that: 1 <= a, b <= n gcd(a, b) + lcm(a, b) = a + b Args: n (int): A positive integer Returns: int: The number of valid pairs (a, b) >>> count_valid_pairs(1) 1 >>> count_valid_pairs(2) 2 >>> count_valid_pairs(5) 5 pass # Replace this with the code to solve the task","solution":"def count_valid_pairs(n): Returns the number of pairs (a, b) such that: 1 <= a, b <= n gcd(a, b) + lcm(a, b) = a + b # Since for (a, b) to satisfy the condition gcd(a, b) + lcm(a, b) = a + b, # a must equal to b. Therefore, the only valid pairs are (1,1), (2,2) ..., (n,n). return n"},{"question":"from typing import List, Tuple def maximum_wealth(n: int, m: int, wealth: List[int], edges: List[Tuple[int, int]]) -> int: Determine the maximum possible wealth you can accumulate starting from vertex 1 and reaching vertex n. >>> maximum_wealth(5, 5, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) 15 >>> maximum_wealth(4, 2, [1, 2, 3, 4], [(1, 2), (3, 4)]) -1 >>> maximum_wealth(3, 2, [3, 2, 5], [(1, 2), (2, 3)]) 10 >>> maximum_wealth(6, 7, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 6), (1, 4), (4, 5), (5, 6), (2, 5)]) 16 >>> maximum_wealth(4, 0, [1, 2, 3, 4], []) -1","solution":"def maximum_wealth(n, m, wealth, edges): from collections import defaultdict, deque graph = defaultdict(list) for a, b in edges: graph[a].append(b) # Initialize distance and wealth array max_wealth = [-1] * (n + 1) max_wealth[1] = wealth[0] queue = deque([1]) while queue: curr = queue.popleft() for neighbor in graph[curr]: if max_wealth[neighbor] < max_wealth[curr] + wealth[neighbor - 1]: max_wealth[neighbor] = max_wealth[curr] + wealth[neighbor - 1] queue.append(neighbor) return max_wealth[n] if max_wealth[n] != -1 else -1"},{"question":"def max_souvenirs(n: int, W: int, weights: List[int]) -> int: Determines the maximum number of souvenirs Peter can carry without exceeding the weight capacity of his rucksack. Parameters: n (int): Number of souvenirs W (int): Maximum weight capacity of the rucksack weights (list): List containing the weights of each souvenir Returns: int: Maximum number of souvenirs >>> max_souvenirs(5, 7, [1, 2, 3, 4, 5]) 3 >>> max_souvenirs(5, 5, [1, 1, 1, 1, 1]) 5","solution":"def max_souvenirs(n, W, weights): Determines the maximum number of souvenirs Peter can carry without exceeding the weight capacity of his rucksack. Parameters: n (int): Number of souvenirs W (int): Maximum weight capacity of the rucksack weights (list): List containing the weights of each souvenir Returns: int: Maximum number of souvenirs weights.sort() current_weight = 0 count = 0 for weight in weights: if current_weight + weight <= W: current_weight += weight count += 1 else: break return count # Sample input n = 5 W = 7 weights = [1, 2, 3, 4, 5] print(max_souvenirs(n, W, weights)) # Output: 3"},{"question":"def compress_logs(n, logs): Compress log entries using Run-Length Encoding (RLE). Parameters: n (int): Number of log entries logs (list): List of log entries as strings Returns: list: Compressed log entries >>> compress_logs(6, [\\"AAA\\", \\"AAA\\", \\"BBB\\", \\"BBB\\", \\"CCC\\", \\"AAA\\"]) [\\"AAA2\\", \\"BBB2\\", \\"CCC1\\", \\"AAA1\\"] >>> compress_logs(4, [\\"AAA\\", \\"BBB\\", \\"CCC\\", \\"DDD\\"]) [\\"AAA1\\", \\"BBB1\\", \\"CCC1\\", \\"DDD1\\"] from solution import compress_logs def test_compress_logs_single_entry(): logs = [\\"AAA\\"] assert compress_logs(1, logs) == [\\"AAA1\\"] def test_compress_logs_multiple_entries(): logs = [\\"AAA\\", \\"AAA\\", \\"BBB\\", \\"BBB\\", \\"CCC\\", \\"AAA\\"] assert compress_logs(6, logs) == [\\"AAA2\\", \\"BBB2\\", \\"CCC1\\", \\"AAA1\\"] def test_compress_logs_all_unique(): logs = [\\"AAA\\", \\"BBB\\", \\"CCC\\", \\"DDD\\"] assert compress_logs(4, logs) == [\\"AAA1\\", \\"BBB1\\", \\"CCC1\\", \\"DDD1\\"] def test_compress_logs_large_input(): logs = [\\"AAA\\"] * 100000 assert compress_logs(100000, logs) == [\\"AAA100000\\"] def test_compress_logs_empty_input(): logs = [] assert compress_logs(0, logs) == [] def test_compress_logs_varied_entries(): logs = [\\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\", \\"C\\", \\"C\\", \\"A\\"] assert compress_logs(8, logs) == [\\"A2\\", \\"B3\\", \\"C2\\", \\"A1\\"]","solution":"def compress_logs(n, logs): Compress log entries using Run-Length Encoding (RLE). Parameters: n (int): Number of log entries logs (list): List of log entries as strings Returns: list: Compressed log entries if n == 0: return [] compressed_logs = [] current_log = logs[0] count = 1 for i in range(1, n): if logs[i] == current_log: count += 1 else: compressed_logs.append(f\\"{current_log}{count}\\") current_log = logs[i] count = 1 compressed_logs.append(f\\"{current_log}{count}\\") return compressed_logs"},{"question":"from typing import List def shortest_path(m: int, n: int, grid: List[List[int]], start_x: int, start_y: int, delivery_x: int, delivery_y: int) -> int: Finds the shortest path in a grid from a start position to a delivery position using BFS. Args: m (int): number of rows n (int): number of columns grid (List[List[int]]): 2D list representing the grid start_x (int): starting row index start_y (int): starting column index delivery_x (int): delivery row index delivery_y (int): delivery column index Returns: int: length of the shortest path, -1 if no path exists. pass def test_shortest_path_simple(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert shortest_path(3, 3, grid, 0, 0, 2, 2) == 4 def test_shortest_path_no_path(): grid = [ [0, 1], [1, 0] ] assert shortest_path(2, 2, grid, 0, 0, 1, 1) == -1 def test_shortest_path_obstacle_at_start(): grid = [ [1, 0], [0, 0] ] assert shortest_path(2, 2, grid, 0, 0, 1, 1) == -1 def test_shortest_path_obstacle_at_end(): grid = [ [0, 0], [0, 1] ] assert shortest_path(2, 2, grid, 0, 0, 1, 1) == -1 def test_shortest_path_large_grid(): grid = [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_path(4, 5, grid, 0, 0, 3, 4) == 7","solution":"from collections import deque def shortest_path(m, n, grid, start_x, start_y, delivery_x, delivery_y): Finds the shortest path in a grid from a start position to a delivery position using BFS. Args: m (int): number of rows n (int): number of columns grid (List[List[int]]): 2D list representing the grid start_x (int): starting row index start_y (int): starting column index delivery_x (int): delivery row index delivery_y (int): delivery column index Returns: int: length of the shortest path, -1 if no path exists. if grid[start_x][start_y] == 1 or grid[delivery_x][delivery_y] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # directions for up, down, left, right queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) while queue: x, y, dist = queue.popleft() if x == delivery_x and y == delivery_y: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(13) True pass def filter_primes(arr: List[int]) -> List[int]: Filters the input array to include only prime numbers. Parameters: arr (List[int]): The array of integers to filter. Returns: List[int]: A new array containing only the prime numbers from the original array. >>> filter_primes([2, 4, 6, 7, 11, 15, 19]) [2, 7, 11, 19] >>> filter_primes([3, 5, 8, 14, 17, 21]) [3, 5, 17] pass def test_filter_primes(): assert filter_primes([2, 4, 6, 7, 11, 15, 19]) == [2, 7, 11, 19] assert filter_primes([3, 5, 8, 14, 17, 21]) == [3, 5, 17] assert filter_primes([1, 22, 25, 31, 37]) == [31, 37] assert filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] assert filter_primes([4, 6, 8, 10, 12]) == [] assert filter_primes([]) == [] assert filter_primes([1, 1, 1, 1]) == [] assert filter_primes([7919, 7873, 7877, 7883]) == [7919, 7873, 7877, 7883] def test_is_prime(): assert is_prime(2) assert is_prime(3) assert not is_prime(4) assert is_prime(5) assert not is_prime(1) assert not is_prime(10) assert is_prime(13) assert not is_prime(15) assert is_prime(101) assert not is_prime(100)","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(arr): Filters the input array to include only prime numbers. return [num for num in arr if is_prime(num)]"},{"question":"from typing import List, Tuple def can_reach_with_jumps(n: int, m: int, k: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> str: Determine if Alice can reach her target cell within the given constraints. Args: n : int : The number of rows in the grid. m : int : The number of columns in the grid. k : int : The maximum number of jumps allowed. grid : List[str] : The grid representing the maze where each cell is open (.) or blocked (#). start : Tuple[int, int] : The starting cell coordinates (sx, sy) (1-based indexing). target : Tuple[int, int] : The target cell coordinates (tx, ty) (1-based indexing). Returns: str : \\"YES\\" if it's possible for Alice to reach the target cell, otherwise \\"NO\\". >>> can_reach_with_jumps(5, 5, 3, [\\".....\\", \\"..#..\\", \\".#.#.\\", \\"..#..\\", \\".....\\"], (1, 1), (5, 5)) \\"YES\\" >>> can_reach_with_jumps(3, 3, 1, [\\".#.\\", \\"#\\", \\"..#\\"], (1, 1), (3, 3)) \\"NO\\"","solution":"from collections import deque def can_reach_with_jumps(n, m, k, grid, start, target): def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': yield nx, ny sx, sy, tx, ty = start[0] - 1, start[1] - 1, target[0] - 1, target[1] - 1 if grid[sx][sy] == '#' or grid[tx][ty] == '#': return \\"NO\\" queue = deque([(sx, sy, 0, k)]) visited = set() visited.add((sx, sy, 0)) while queue: x, y, jumps, remaining_jumps = queue.popleft() if (x, y) == (tx, ty): return \\"YES\\" for nx, ny in neighbors(x, y): if (nx, ny, jumps + 1) not in visited: visited.add((nx, ny, jumps + 1)) queue.append((nx, ny, jumps + 1, remaining_jumps - 1)) return \\"NO\\""},{"question":"def shortest_path_distance(n: int, m: int, q: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest path distance between pairs of towns in a kingdom with given roads. :param n: Number of towns :param m: Number of bidirectional roads :param q: Number of queries :param edges: List of edges where each edge is a tuple (u, v, w) :param queries: List of queries where each query is a tuple (a, b) :return: List of shortest distances for each query >>> n, m, q = 5, 6, 3 >>> edges = [(1, 2, 1), (1, 3, 5), (2, 3, 2), (3, 4, 1), (2, 5, 2), (5, 4, 3)] >>> queries = [(1, 4), (1, 5), (4, 5)] >>> shortest_path_distance(n, m, q, edges, queries) [4, 3, 3] >>> n, m, q = 4, 2, 2 >>> edges = [(1, 2, 4), (3, 4, 6)] >>> queries = [(1, 3), (2, 4)] >>> shortest_path_distance(n, m, q, edges, queries) [-1, -1] >>> n, m, q = 3, 3, 3 >>> edges = [(1, 2, 1), (2, 3, 1), (1, 3, 2)] >>> queries = [(1, 2), (2, 3), (1, 3)] >>> shortest_path_distance(n, m, q, edges, queries) [1, 1, 2] >>> n, m, q = 4, 5, 4 >>> edges = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 4, 7), (1, 3, 10)] >>> queries = [(1, 4), (1, 3), (2, 4), (3, 1)] >>> shortest_path_distance(n, m, q, edges, queries) [7, 7, 6, 7] >>> n, m, q = 1, 0, 1 >>> edges = [] >>> queries = [(1, 1)] >>> shortest_path_distance(n, m, q, edges, queries) [0]","solution":"import heapq def dijkstra(n, graph, start): Dijkstra's Algorithm to find the shortest path from start node to all nodes. :param n: Number of nodes :param graph: Adjacency list of the graph :param start: Start node :return: Dict with shortest distances from start to all nodes distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_path_distance(n, m, q, edges, queries): Process edges and queries to find shortest paths using Dijkstra's Algorithm. :param n: Number of towns :param m: Number of roads :param q: Number of queries :param edges: List of edges where each edge is (u, v, w) :param queries: List of queries where each query is (a, b) :return: List of shortest distances for each query graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for a, b in queries: distances = dijkstra(n, graph, a) result = distances[b] if distances[b] != float('inf') else -1 results.append(result) return results"},{"question":"def min_moves_to_equal_elements(n: int, arr: List[int]) -> int: Returns the minimum number of moves required to make all elements in the array equal. >>> min_moves_to_equal_elements(4, [1, 3, 2, 2]) 2 >>> min_moves_to_equal_elements(1, [5]) 0 >>> min_moves_to_equal_elements(3, [5, 5, 5]) 0 >>> min_moves_to_equal_elements(2, [1, 4]) 3 >>> min_moves_to_equal_elements(3, [1000000000, 999999999, 1000000000]) 1 >>> min_moves_to_equal_elements(6, [7, 1, 5, 4, 6, 2]) 11","solution":"def min_moves_to_equal_elements(n, arr): Returns the minimum number of moves required to make all elements in the array equal. # Finding the median of the array arr_sorted = sorted(arr) median = arr_sorted[n // 2] # Calculating the total number of moves required moves = sum(abs(x - median) for x in arr) return moves"},{"question":"def decode_message(n, k, A): Decodes an array that has been encoded by rotating every contiguous subarray of length \`k\` to the right by one position. :param int n: The length of the array. :param int k: The length of the subarrays that were rotated. :param list[int] A: The encoded array. :return: The original array. :rtype: list[int] pass # Test cases def test_example_case(): n = 8 k = 2 A = [3, 4, 1, 2, 6, 5, 8, 7] expected = [4, 3, 2, 1, 5, 6, 7, 8] assert decode_message(n, k, A) == expected def test_case_single_element_k(): n = 5 k = 1 A = [5, 4, 3, 2, 1] expected = [5, 4, 3, 2, 1] assert decode_message(n, k, A) == expected def test_case_entire_array_k(): n = 6 k = 6 A = [6, 1, 2, 3, 4, 5] expected = [1, 2, 3, 4, 5, 6] assert decode_message(n, k, A) == expected def test_case_middle_length_k(): n = 9 k = 3 A = [2, 3, 1, 5, 6, 4, 8, 9, 7] expected = [3, 1, 2, 6, 4, 5, 9, 7, 8] assert decode_message(n, k, A) == expected def test_case_large_numbers(): n = 4 k = 2 A = [1000000000, 999999999, 888888888, 777777777] expected = [999999999, 1000000000, 777777777, 888888888] assert decode_message(n, k, A) == expected","solution":"def decode_message(n, k, A): Decodes an array that has been encoded by rotating every contiguous subarray of length \`k\` to the right by one position. :param int n: The length of the array. :param int k: The length of the subarrays that were rotated. :param list[int] A: The encoded array. :return: The original array. :rtype: list[int] original = A[:] # Copying the list to maintain the same length for i in range(0, n, k): # Rotate subarray A[i:i+k] to the left by one (reverse the right rotation by one) subarray = A[i:i+k] subarray = subarray[1:] + subarray[:1] original[i:i+k] = subarray return original"},{"question":"def weighted_fibonacci(n: int) -> int: Computes the nth element of the Weighted Fibonacci sequence. The result is given modulo 10^9 + 7. >>> weighted_fibonacci(0) 0 >>> weighted_fibonacci(1) 1 >>> weighted_fibonacci(2) 2 >>> weighted_fibonacci(3) 6 >>> weighted_fibonacci(4) 12","solution":"MOD = 10**9 + 7 def weighted_fibonacci(n): Computes the nth element of the Weighted Fibonacci sequence. if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): next_fib = (a + b) % MOD a, b = b, next_fib return n * b % MOD"},{"question":"def can_make_equal(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Determines if it is possible to make all node values equal and returns the minimum number of operations if possible. Otherwise, returns -1. :param n: Number of nodes :param m: Number of edges :param values: List of initial values of the nodes :param edges: List of tuples representing the edges :return: Minimum number of operations or -1 if it's not possible pass # Unit Tests def test_can_make_equal_example1(): n = 3 m = 2 values = [1, 2, 3] edges = [(1, 2), (2, 3)] assert can_make_equal(n, m, values, edges) == 1 def test_can_make_equal_example2(): n = 3 m = 1 values = [1, 2, 3] edges = [(1, 2)] assert can_make_equal(n, m, values, edges) == -1 def test_can_make_equal_single_node(): n = 1 m = 0 values = [5] edges = [] assert can_make_equal(n, m, values, edges) == 0 def test_can_make_equal_disconnected_graph(): n = 4 m = 2 values = [1, 2, 3, 4] edges = [(1, 2), (3, 4)] assert can_make_equal(n, m, values, edges) == -1 def test_can_make_equal_equal_values(): n = 3 m = 2 values = [2, 2, 2] edges = [(1, 2), (2, 3)] assert can_make_equal(n, m, values, edges) == 0 def test_can_make_equal_zero_sum(): n = 4 m = 3 values = [1, -1, 1, -1] edges = [(1, 2), (2, 3), (3, 4)] assert can_make_equal(n, m, values, edges) == 2","solution":"def can_make_equal(n, m, values, edges): Determines if it is possible to make all node values equal and returns the minimum number of operations if possible. Otherwise, returns -1. :param n: Number of nodes :param m: Number of edges :param values: List of initial values of the nodes :param edges: List of tuples representing the edges :return: Minimum number of operations or -1 if it's not possible if sum(values) % n != 0: return -1 # Check if all nodes are in one connected component from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) queue = deque() queue.append(1) visited[1] = True count = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) count += 1 if count != n: return -1 avg = sum(values) // n operations = 0 for val in values: operations += abs(val - avg) return operations // 2"},{"question":"def min_delivery_rounds(n: int, k: int, weights: List[int]) -> int: Determines the minimum number of rounds required to deliver all packages using drones with a maximum carrying capacity. Parameters: n (int): The number of packages. k (int): The maximum capacity of each drone. weights (List[int]): The weights of the packages. Returns: int: The minimum number of rounds required to deliver all the packages. Example: >>> min_delivery_rounds(6, 10, [2, 3, 5, 6, 7, 8]) 4 >>> min_delivery_rounds(1, 5, [3]) 1 >>> min_delivery_rounds(5, 10, [5, 5, 5, 5, 5]) 3 >>> min_delivery_rounds(5, 15, [3, 5, 7, 9, 2]) 3 >>> min_delivery_rounds(4, 8, [9, 10, 8, 4, 3]) 4 >>> min_delivery_rounds(6, 10000, [1, 2, 3, 4, 5, 6]) 3","solution":"def min_delivery_rounds(n, k, weights): Determines the minimum number of rounds required to deliver all packages. weights.sort(reverse=True) rounds = 0 i = 0 j = n - 1 while i <= j: if weights[i] + weights[j] <= k: # If the lightest and the heaviest package can be delivered together in one drone j -= 1 # The heaviest package will always be delivered in the current round i += 1 rounds += 1 return rounds"},{"question":"from typing import List, Tuple def floyd_warshall(n: int, roads: List[Tuple[int, int, int]]) -> List[List[int]]: Compute the shortest travel time between every pair of cities. Args: n : int : number of cities roads : List[Tuple[int, int, int]] : list of roads characterized by tuples (u, v, t) Returns: List[List[int]] : a matrix where the element at (i, j) represents the minimum travel time from city i to city j Example: >>> floyd_warshall(4, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (3, 4, 1), (2, 4, 6), (1, 4, 7)]) [[0, 4, 2, 3], [4, 0, 3, 4], [2, 3, 0, 1], [3, 4, 1, 0]] >>> floyd_warshall(4, [(1, 2, 5)]) [[0, 5, -1, -1], [5, 0, -1, -1], [-1, -1, 0, -1], [-1, -1, -1, 0]]","solution":"def floyd_warshall(n, roads): # Initialize the distances with \\"infinity\\", and 0 for self loops dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Add each road to the distance table for u, v, t in roads: dist[u-1][v-1] = min(dist[u-1][v-1], t) dist[v-1][u-1] = min(dist[v-1][u-1], t) # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Convert 'inf' to -1 to signify no path exists for i in range(n): for j in range(n): if dist[i][j] == float('inf'): dist[i][j] = -1 return dist"},{"question":"def minimum_streetlights(n: int, k: int, obstacles: List[Tuple[int, int]]) -> int: Determine the minimum number of streetlights needed to ensure that every cell without an obstacle is illuminated. Args: n : int : the size of the grid (n x n) k : int : the number of cells that contain obstacles obstacles : List[Tuple[int, int]] : the coordinates of the cells that contain obstacles Returns: int : the minimum number of streetlights needed Example: >>> minimum_streetlights(4, 2, [(2, 2), (3, 3)]) 2 >>> minimum_streetlights(5, 3, [(1, 1), (5, 5), (3, 3)]) 3 >>> minimum_streetlights(4, 0, []) 0 >>> minimum_streetlights(6, 4, [(1, 2), (3, 4), (5, 6), (2, 2)]) 4 >>> minimum_streetlights(3, 1, [(2, 2)]) 1 # Write your code here","solution":"def minimum_streetlights(n, k, obstacles): rows_with_obstacles = set() cols_with_obstacles = set() for x, y in obstacles: rows_with_obstacles.add(x) cols_with_obstacles.add(y) # The number of streetlights needed is the maximum of the unique rows with obstacles and the unique columns with obstacles return max(len(rows_with_obstacles), len(cols_with_obstacles)) # Driver code to test solution # Test case n = 4 k = 2 obstacles = [(2, 2), (3, 3)] print(minimum_streetlights(n, k, obstacles)) # Expected Output: 2"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Given an array of integers, this function calculates the minimum number of operations required to make all elements equal. Incrementing or decrementing any element by 1 is considered a single operation. >>> min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) == 6 >>> min_operations_to_equal_elements(4, [2, 2, 2, 2]) == 0 >>> min_operations_to_equal_elements(2, [1, 10]) == 9 >>> min_operations_to_equal_elements(3, [-1000000000, 0, 1000000000]) == 2000000000 >>> min_operations_to_equal_elements(1, [42]) == 0 >>> min_operations_to_equal_elements(4, [-1, -2, -3, -4]) == 4 >>> min_operations_to_equal_elements(4, [-1, 2, -3, 4]) == 10","solution":"def min_operations_to_equal_elements(n, arr): Given an array of integers, this function calculates the minimum number of operations required to make all elements equal. Incrementing or decrementing any element by 1 is considered a single operation. # The median minimizes the sum of absolute deviations (L1 norm) arr.sort() median = arr[n // 2] # Compute the total number of operations needed operations = sum(abs(median - x) for x in arr) return operations"},{"question":"def is_path_possible(n: int, grid: List[List[int]]) -> str: Determines if it is possible to travel from the top-left cell (1, 1) to the bottom-right cell (n, n) only by moving along paths consisting of increasing consecutive integers. Parameters: n (int): The dimension of the grid. grid (list of lists of int): The n x n grid of integers. Returns: str: \\"YES\\" if the path exists, otherwise \\"NO\\". pass from solution import is_path_possible def test_sample1(): grid = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert is_path_possible(3, grid) == \\"YES\\" def test_sample2(): grid = [ [1, 2, 3], [4, 6, 5], [7, 8, 10] ] assert is_path_possible(3, grid) == \\"NO\\" def test_single_cell(): grid = [ [1] ] assert is_path_possible(1, grid) == \\"YES\\" def test_larger_grid_possible(): grid = [ [1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12], [16, 15, 14, 13] ] assert is_path_possible(4, grid) == \\"YES\\" def test_larger_grid_impossible(): grid = [ [1, 2, 4, 5], [3, 6, 8, 7], [9, 10, 12, 11], [16, 15, 14, 13] ] assert is_path_possible(4, grid) == \\"NO\\" def test_unreachable(): grid = [ [1, 3], [2, 4] ] assert is_path_possible(2, grid) == \\"NO\\" def test_non_consecutive_start(): grid = [ [2, 3], [4, 5] ] assert is_path_possible(2, grid) == \\"NO\\"","solution":"def is_path_possible(n, grid): Determines if it is possible to travel from the top-left cell (1, 1) to the bottom-right cell (n, n) only by moving along paths consisting of increasing consecutive integers. Parameters: n (int): The dimension of the grid. grid (list of lists of int): The n x n grid of integers. Returns: str: \\"YES\\" if the path exists, otherwise \\"NO\\". from collections import deque if grid[0][0] != 1: return \\"NO\\" destination = n * n moves = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < n queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if grid[x][y] == destination: return \\"YES\\" for dx, dy in moves: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] == grid[x][y] + 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"from typing import List, Tuple def categorize_properties(n: int, m: int, k: int, risk_scores: List[int], properties: List[Tuple[int, int]], categories: List[Tuple[str, int, int]]) -> List[str]: Categorize properties based on their risk scores and provided intervals. >>> n = 5 >>> m = 3 >>> k = 4 >>> risk_scores = [150, 300, 450, 600, 750] >>> properties = [(1001, 150), (1002, 300), (1003, 450), (1004, 600), (1005, 750)] >>> categories = [(\\"Low\\", 100, 299), (\\"Medium\\", 300, 599), (\\"High\\", 600, 899)] >>> categorize_properties(n, m, k, risk_scores, properties, categories) [\\"1001 Low\\", \\"1002 Medium\\", \\"1003 Medium\\", \\"1004 High\\", \\"1005 High\\"] >>> n = 2 >>> m = 2 >>> k = 2 >>> risk_scores = [50, 800] >>> properties = [(1001, 50), (1002, 800)] >>> categories = [(\\"Very Low\\", 0, 99), (\\"Very High\\", 700, 999)] >>> categorize_properties(n, m, k, risk_scores, properties, categories) [\\"1001 Very Low\\", \\"1002 Very High\\"] pass","solution":"def categorize_properties(n, m, k, risk_scores, properties, categories): # Create a dictionary to map property id to its risk score property_dict = {pid: score for pid, score in properties} # Initialize result list to store the final categories of properties result = [] # Iterate over each property to determine its category for pid, score in properties: for category in categories: category_name = category[0] lower_bound = category[1] upper_bound = category[2] if lower_bound <= score <= upper_bound: result.append(f\\"{pid} {category_name}\\") break # Return the result as a list of strings return result"},{"question":"from typing import List, Tuple, Union def reorder_list(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[Union[List[int], int]]: Reorder the lists so that the sum of every two adjacent numbers is not divisible by a given integer k. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list containing tuples with (n, k) and the list of integers for each test case. Returns: List[Union[List[int], int]]: A list of lists containing the reordered lists for each test case or -1 if not possible. pass # Example usage: # assert reorder_list(2, [(4, 3, [1, 2, 3, 4]), (3, 2, [2, 4, 6])]) == [[4, 1, 2, 3], -1]","solution":"def reorder_list(t, test_cases): Reorders the lists such that the sum of every two adjacent numbers is not divisible by k. Args: t (int): The number of test cases. test_cases (list): A list containing tuples with (n, k) and the list of integers for each test case. Returns: list: A list of lists containing the reordered lists for each test case or -1 if not possible. results = [] for n, k, arr in test_cases: arr.sort() i, j = 0, n - 1 reordered = [] while i <= j: if i == j: reordered.append(arr[i]) else: reordered.append(arr[j]) if i != j: reordered.append(arr[i]) i += 1 j -= 1 valid = True for i in range(1, n): if (reordered[i-1] + reordered[i]) % k == 0: valid = False break if valid: results.append(reordered) else: results.append(-1) return results"},{"question":"def count_beautiful_subarrays(arr, n, k): Returns the number of subarrays whose sum is equal to k. Parameters: arr (list of int): The list of integers to process. n (int): The length of the array. k (int): The target sum for a subarray to be considered \\"beautiful\\". Returns: int: The number of subarrays with sum equal to k. # Your code here # Unit tests def test_example1(): assert count_beautiful_subarrays([1, 2, 3, 4, 5], 5, 5) == 2 def test_example2(): assert count_beautiful_subarrays([1, -1, 1, -1], 4, 0) == 4 def test_single_element(): assert count_beautiful_subarrays([5], 1, 5) == 1 assert count_beautiful_subarrays([5], 1, 0) == 0 def test_all_zeroes(): assert count_beautiful_subarrays([0, 0, 0, 0], 4, 0) == 10 def test_no_beautiful_subarray(): assert count_beautiful_subarrays([1, 2, 3], 3, 7) == 0 def test_negative_numbers(): assert count_beautiful_subarrays([-1, -2, -3, -4, -5], 5, -5) == 2 assert count_beautiful_subarrays([-1, 2, -3, 4, -5], 5, -1) == 3 def test_mixed_positive_negative(): assert count_beautiful_subarrays([1, -1, 2, -2, 3, -3], 6, 0) == 6","solution":"def count_beautiful_subarrays(arr, n, k): Returns the number of subarrays whose sum is equal to k. Parameters: arr (list of int): The list of integers to process. n (int): The length of the array. k (int): The target sum for a subarray to be considered \\"beautiful\\". Returns: int: The number of subarrays with sum equal to k. from collections import defaultdict sum_count = defaultdict(int) current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == k: count += 1 if current_sum - k in sum_count: count += sum_count[current_sum - k] sum_count[current_sum] += 1 return count # Example usage # n, k = 5, 5 # arr = [1, 2, 3, 4, 5] # print(count_beautiful_subarrays(n, k, arr)) # Output should be 2"},{"question":"def is_isomorphic(s: str, t: str) -> str: Determines if two strings s and t are isomorphic. >>> is_isomorphic(\\"egg\\", \\"add\\") \\"yes\\" >>> is_isomorphic(\\"foo\\", \\"bar\\") \\"no\\" >>> is_isomorphic(\\"ab\\", \\"aa\\") \\"no\\" # Implement the logic to check if the strings s and t are isomorphic. def test_isomorphic_true_case(): assert is_isomorphic(\\"egg\\", \\"add\\") == \\"yes\\" def test_isomorphic_false_case(): assert is_isomorphic(\\"foo\\", \\"bar\\") == \\"no\\" def test_isomorphic_false_case_duplicate_characters(): assert is_isomorphic(\\"ab\\", \\"aa\\") == \\"no\\" def test_isomorphic_empty_strings(): assert is_isomorphic(\\"\\", \\"\\") == \\"yes\\" def test_isomorphic_single_character(): assert is_isomorphic(\\"a\\", \\"a\\") == \\"yes\\" assert is_isomorphic(\\"a\\", \\"b\\") == \\"yes\\" def test_isomorphic_different_lengths(): assert is_isomorphic(\\"abcd\\", \\"abc\\") == \\"no\\" def test_isomorphic_complex_case(): assert is_isomorphic(\\"paper\\", \\"title\\") == \\"yes\\" assert is_isomorphic(\\"aba\\", \\"baa\\") == \\"no\\" assert is_isomorphic(\\"ab\\", \\"ca\\") == \\"yes\\" assert is_isomorphic(\\"abc\\", \\"xyz\\") == \\"yes\\" assert is_isomorphic(\\"123\\", \\"456\\") == \\"yes\\"","solution":"def is_isomorphic(s, t): Determines if two strings s and t are isomorphic. Args: s (str): First string. t (str): Second string. Returns: str: \\"yes\\" if the strings are isomorphic, \\"no\\" otherwise. if len(s) != len(t): return \\"no\\" s_to_t = {} t_to_s = {} for c1, c2 in zip(s, t): if c1 in s_to_t and s_to_t[c1] != c2: return \\"no\\" if c2 in t_to_s and t_to_s[c2] != c1: return \\"no\\" s_to_t[c1] = c2 t_to_s[c2] = c1 return \\"yes\\""},{"question":"import heapq import sys from collections import defaultdict def shortest_paths_from_source(n, m, edges, s): Determine the shortest path from a source vertex to all other vertices in a directed graph. Args: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int, int]]): Edges given as tuples with two vertices and a weight (u, v, w). s (int): The source vertex. Returns: List[int]: A list of shortest paths from the source vertex to each vertex. If a vertex is unreachable, its distance is -1. >>> n = 5 >>> m = 6 >>> edges = [ ... (1, 2, 2), ... (1, 3, 4), ... (2, 3, 1), ... (2, 4, 7), ... (3, 5, 3), ... (4, 5, 1) ... ] >>> s = 1 >>> shortest_paths_from_source(n, m, edges, s) [0, 2, 3, 9, 6] >>> n = 4 >>> m = 2 >>> edges = [ ... (1, 2, 1), ... (3, 4, 1) ... ] >>> s = 1 >>> shortest_paths_from_source(n, m, edges, s) [0, 1, -1, -1] >>> n = 1 >>> m = 0 >>> edges = [] >>> s = 1 >>> shortest_paths_from_source(n, m, edges, s) [0] >>> n = 3 >>> m = 3 >>> edges = [ ... (1, 2, 1), ... (1, 3, 4), ... (2, 3, 2) ... ] >>> s = 1 >>> shortest_paths_from_source(n, m, edges, s) [0, 1, 3] >>> n = 2 >>> m = 1 >>> edges = [ ... (1, 2, 50) ... ] >>> s = 1 >>> shortest_paths_from_source(n, m, edges, s) [0, 50] >>> n = 6 >>> m = 5 >>> edges = [ ... (1, 2, 3), ... (2, 3, 4), ... (3, 4, 5), ... (4, 5, 6), ... (5, 6, 7) ... ] >>> s = 3 >>> shortest_paths_from_source(n, m, edges, s) [-1, -1, 0, 5, 11, 18]","solution":"import heapq import sys from collections import defaultdict, deque def shortest_paths_from_source(n, m, edges, s): graph = defaultdict(list) for u, v, w in edges: graph[u].append((w, v)) distances = {i: sys.maxsize for i in range(1, n + 1)} distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for weight, neighbor in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(1, n + 1): if distances[i] == sys.maxsize: result.append(-1) else: result.append(distances[i]) return result"},{"question":"def max_discount(n: int, k: int, m: int, discounts: List[int]) -> int: Returns the maximum discount a single customer can get while adhering to the constraints. Parameters: n (int): The total number of products. k (int): The maximum number of products allowed per transaction. m (int): The total number of customers. discounts (list of int): The discount values of the products. Returns: int: The maximum discount a single customer can get. >>> max_discount(5, 3, 4, [10, 20, 30, 40, 50]) 120 >>> max_discount(1, 1, 1, [50]) 50 >>> max_discount(5, 2, 3, [10, 10, 10, 10, 10]) 20 >>> max_discount(5, 2, 3, [10, 30, 20, 0, 10]) 50 >>> max_discount(5, 5, 3, [10, 20, 30, 40, 50]) 150 >>> max_discount(5, 3, 3, [10000, 20000, 30000, 40000, 50000]) 120000 >>> max_discount(5, 10, 1, [5, 5, 5, 5, 5]) 25 >>> max_discount(5, 1, 2, [1, 2, 3, 4, 5]) 5","solution":"def max_discount(n, k, m, discounts): Returns the maximum discount a single customer can get while adhering to the constraints. Parameters: n (int): The total number of products. k (int): The maximum number of products allowed per transaction. m (int): The total number of customers. discounts (list of int): The discount values of the products. Returns: int: The maximum discount a single customer can get. # Initialize the maximum discount value max_discount_value = 0 # Use a sliding window to calculate the sum of products within the allowed transaction limit 'k' current_window_sum = sum(discounts[:k]) max_discount_value = current_window_sum for i in range(1, n - k + 1): current_window_sum = current_window_sum - discounts[i - 1] + discounts[i + k - 1] if current_window_sum > max_discount_value: max_discount_value = current_window_sum return max_discount_value"},{"question":"def minimize_max_difference(n: int, k: int, arr: List[int]) -> List[int]: Rearranges the array to minimize the maximum difference between any adjacent elements, and returns the lexicographically smallest result. >>> minimize_max_difference(6, 2, [10, 1, 6, 8, 4, 2]) [1, 2, 4, 6, 8, 10] >>> minimize_max_difference(5, 3, [3, 9, 1, 4, 7]) [1, 3, 4, 7, 9] from minimize_max_difference import minimize_max_difference def test_example1(): n = 6 k = 2 arr = [10, 1, 6, 8, 4, 2] assert minimize_max_difference(n, k, arr) == [1, 2, 4, 6, 8, 10] def test_example2(): n = 5 k = 3 arr = [3, 9, 1, 4, 7] assert minimize_max_difference(n, k, arr) == [1, 3, 4, 7, 9] def test_single_element(): n = 1 k = 0 arr = [5] assert minimize_max_difference(n, k, arr) == [5] def test_already_sorted(): n = 4 k = 3 arr = [1, 2, 3, 4] assert minimize_max_difference(n, k, arr) == [1, 2, 3, 4] def test_reverse_sorted(): n = 4 k = 3 arr = [4, 3, 2, 1] assert minimize_max_difference(n, k, arr) == [1, 2, 3, 4] def test_large_values(): n = 3 k = 2 arr = [1000000000, 999999999, 999999998] assert minimize_max_difference(n, k, arr) == [999999998, 999999999, 1000000000]","solution":"def minimize_max_difference(n, k, arr): Rearranges the array to minimize the maximum difference between any adjacent elements, and returns the lexicographically smallest result. # Sort the array to get the lexicographically smallest order arr.sort() return arr"},{"question":"def maximize_sum_after_swaps(n: int, k: int, A: List[int], B: List[int]) -> int: Maximizes the sum of elements in array A after performing the swap operation up to k times. >>> maximize_sum_after_swaps(3, 2, [1, 2, 5], [8, 3, 1]) 16 >>> maximize_sum_after_swaps(3, 0, [1, 2, 5], [8, 3, 1]) 8 >>> maximize_sum_after_swaps(3, 3, [1, 2, 5], [8, 3, 1]) 16 >>> maximize_sum_after_swaps(3, 2, [8, 7, 6], [1, 2, 3]) 21 >>> maximize_sum_after_swaps(4, 2, [1, 4, 2, 3], [5, 6, 7, 1]) 20 >>> maximize_sum_after_swaps(3, 2, [1, 1, 1], [1, 1, 1]) 3 >>> maximize_sum_after_swaps(3, 5, [1, 2, 3], [9, 8, 7]) 24 # Your code here","solution":"def maximize_sum_after_swaps(n, k, A, B): Maximizes the sum of elements in array A after performing the swap operation up to k times. n: Length of the arrays A and B. k: Maximum number of swaps allowed. A: List of integers representing the array A. B: List of integers representing the array B. Returns the maximum possible sum of elements in array A after performing swaps. A = sorted(A) B = sorted(B, reverse=True) for i in range(min(k, n)): if A[i] < B[i]: A[i], B[i] = B[i], A[i] else: break return sum(A)"},{"question":"from typing import List, Tuple def minimal_maximum_travel_cost(n: int, m: int, k: int, roads: List[Tuple[int, int, int]], special_cities: List[int]) -> int: Determine the minimum possible maximum travel cost between any two special cities. Args: n : int : the number of cities m : int : the number of roads k : int : the number of special cities roads : List[Tuple[int, int, int]] : the list of roads with travel costs special_cities : List[int] : the list of special cities Returns: int : the minimum possible maximum travel cost between any two special cities. If it's impossible, return -1. Example: >>> n, m, k = 5, 6, 3 >>> roads = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 4, 6), (2, 5, 5), (3, 5, 1)] >>> special_cities = [2, 3, 5] >>> minimal_maximum_travel_cost(n, m, k, roads, special_cities) 4 pass def test_case_1(): n, m, k = 5, 6, 3 roads = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 4, 6), (2, 5, 5), (3, 5, 1)] special_cities = [2, 3, 5] result = minimal_maximum_travel_cost(n, m, k, roads, special_cities) assert result == 4 def test_case_2(): n, m, k = 4, 3, 2 roads = [(1, 2, 1), (2, 3, 1), (3, 4, 1)] special_cities = [1, 4] result = minimal_maximum_travel_cost(n, m, k, roads, special_cities) assert result == 3 def test_case_3(): n, m, k = 4, 3, 2 roads = [(1, 2, 1), (2, 3, 1), (3, 4, 1)] special_cities = [1, 3] result = minimal_maximum_travel_cost(n, m, k, roads, special_cities) assert result == 2 def test_case_4(): n, m, k = 5, 0, 3 roads = [] special_cities = [1, 2, 3] result = minimal_maximum_travel_cost(n, m, k, roads, special_cities) assert result == -1 def test_case_5(): n, m, k = 7, 9, 4 roads = [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (5, 6, 2), (6, 7, 2), (1, 3, 5), (5, 7, 4), (2, 6, 6)] special_cities = [1, 4, 5, 7] result = minimal_maximum_travel_cost(n, m, k, roads, special_cities) assert result == 6","solution":"import heapq def minimal_maximum_travel_cost(n, m, k, roads, special_cities): def dijkstra(start, graph): dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist graph = {i: [] for i in range(1, n+1)} for u, v, c in roads: graph[u].append((v, c)) graph[v].append((u, c)) min_max_cost = float('inf') for city in special_cities: dist = dijkstra(city, graph) max_cost = 0 for other_city in special_cities: if other_city != city: if dist[other_city] == float('inf'): return -1 max_cost = max(max_cost, dist[other_city]) min_max_cost = min(min_max_cost, max_cost) return min_max_cost"},{"question":"def minimum_transportation_cost(n: int, m: int, routes: List[Tuple[int, int, int]]) -> Union[int, str]: Determine the minimum transportation cost using a minimum spanning tree. The function should return the minimum cost to connect all distribution centers to the central warehouse. If it is not possible, return \\"IMPOSSIBLE\\". Args: n (int): Number of distribution centers. m (int): Number of delivery routes. routes (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, and w — the two distribution centers connected by a delivery route and the transportation cost of that route. Returns: Union[int, str]: The minimum transportation cost or \\"IMPOSSIBLE\\" if it's not possible. >>> minimum_transportation_cost(4, 5, [ (1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 5), (3, 4, 7), ]) 10 >>> minimum_transportation_cost(3, 1, [ (1, 2, 4) ]) \\"IMPOSSIBLE\\" >>> minimum_transportation_cost(1, 0, []) 0 >>> minimum_transportation_cost(2, 1, [ (1, 2, 3) ]) 3 >>> n = 100000 >>> m = 200000 >>> routes = [(i, i + 1, i) for i in range(1, 100001)] + [(1, 2, 3) for _ in range(99999)] >>> minimum_transportation_cost(n, m, routes) == sum(range(1, 100000)) True","solution":"import heapq def find(parent, i): A utility function to find set of an element i (uses path compression technique). if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): A function that does union of two sets of x and y (uses union by rank). root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(n, edges): Function to calculate the minimum transportation cost using Kruskal's algorithm. if n == 1: return 0 # Sort edges based on weight edges.sort(key=lambda x: x[2]) parent = [] rank = [] # Create \`n\` single item sets for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 mst_edges = 0 for edge in edges: u, v, w = edge root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w mst_edges += 1 # If we already have n-1 edges in MST, we can stop if mst_edges == n - 1: break if mst_edges == n - 1: return mst_weight else: return \\"IMPOSSIBLE\\" # Main function to read input and call the MST function def minimum_transportation_cost(n, m, routes): return minimum_spanning_tree(n, routes)"},{"question":"from typing import List def daily_temperatures(temps: List[int]) -> List[int]: Given an array of temperatures, find out how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 for that day instead. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([70, 70, 70, 70]) [0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 60, 70]) [1, 1, 1, 1, 0] >>> daily_temperatures([100, 90, 80, 70, 60]) [0, 0, 0, 0, 0] >>> daily_temperatures([50]) [0] >>> daily_temperatures([60, 70, 60, 70, 60, 70]) [1, 0, 1, 0, 1, 0]","solution":"from typing import List def daily_temperatures(temps: List[int]) -> List[int]: Given an array of temperatures, returns a list of integers representing the number of days to wait for a warmer temperature. If there is no future day for which this is possible, puts 0 for that day instead. n = len(temps) result = [0] * n stack = [] for i in range(n): while stack and temps[i] > temps[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"def is_prime(n): Check if a number is prime. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def nearest_prime(n): Find the nearest prime number greater than or equal to n. >>> nearest_prime(7) 7 >>> nearest_prime(10) 11 >>> nearest_prime(15) 17 >>> nearest_prime(20) 23 >>> nearest_prime(0) 2 >>> nearest_prime(1) 2 def nearest_primes_array(arr): Modify array so that each element is the nearest prime number greater than or equal to the element. >>> nearest_primes_array([10, 15, 20]) [11, 17, 23] >>> nearest_primes_array([2, 10, 14, 18]) [2, 11, 17, 19] >>> nearest_primes_array([0, 1]) [2, 2] >>> nearest_primes_array([29, 30, 31, 32]) [29, 31, 31, 37] >>> nearest_primes_array([5, 11, 17, 23]) [5, 11, 17, 23]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def nearest_prime(n): Find the nearest prime number greater than or equal to n. while not is_prime(n): n += 1 return n def nearest_primes_array(arr): Modify array so that each element is the nearest prime number greater than or equal to the element. return [nearest_prime(x) for x in arr]"},{"question":"from typing import List, Tuple, Union def find_nodes_with_distance(n: int, d: int, edges: List[Tuple[int, int, int]]) -> Union[Tuple[int, int], int]: Find two nodes in a tree such that the distance between them is exactly d. The distance between two nodes is defined as the sum of the edges' weights on the path between them. If multiple pairs of nodes satisfy the condition, any one of the pairs can be returned. If no pairs satisfy the condition, return -1. Args: n: int: The number of nodes in the tree. d: int: The desired distance between two nodes. edges: List[Tuple[int, int, int]]: List of edges where each edge is represented by a tuple (u, v, w) where u and v are the nodes connected by the edge, and w is the weight of the edge. Returns: Tuple[int, int]: A tuple of two nodes (u, v) such that the distance between them is exactly d. int: -1 if no such pair exists. Example: >>> n = 5 >>> d = 4 >>> edges = [(1, 2, 1), (1, 3, 2), (2, 4, 1), (3, 5, 2)] >>> find_nodes_with_distance(n, d, edges) (1, 5) # (2 -> 1 -> 3 -> 5) with weights 1+2+1 = 4","solution":"from collections import defaultdict, deque def find_nodes_with_distance(n, d, edges): def bfs(start): distance = [-1] * (n + 1) distance[start] = 0 q = deque([start]) while q: node = q.popleft() for neighbor, weight in graph[node]: if distance[neighbor] == -1: distance[neighbor] = distance[node] + weight q.append(neighbor) if distance[neighbor] == d: return neighbor return -1 # Construct the graph as an adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Perform BFS from node 1 to find a node at distance d result = bfs(1) if result == -1: return -1 else: return 1, result"},{"question":"def max_path_sum(tree: tuple) -> int: Given a binary tree, find the maximum path sum. The binary tree is represented using a tuple where the first element is the value of the node, the second element is the left subtree, and the third element is the right subtree. If a node does not have a left or right child, that subtree is represented as None. >>> max_path_sum((1, (2, (4, None, None), (5, None, None)), (3, None, None))) 11 >>> max_path_sum((-10, (9, None, None), (20, (15, None, None), (7, None, None)))) 42 pass def test_max_path_sum_single_node(): tree = (5, None, None) assert max_path_sum(tree) == 5 def test_max_path_sum_simple_tree(): tree = (1, (2, None, None), (3, None, None)) assert max_path_sum(tree) == 6 def test_max_path_sum_with_negatives(): tree = (1, (2, None, None), (-1, None, None)) assert max_path_sum(tree) == 3 def test_max_path_sum_complex_tree(): tree = (-10, (9, None, None), (20, (15, None, None), (7, None, None))) assert max_path_sum(tree) == 42 def test_max_path_sum_entirely_negative(): tree = (-10, (-20, None, None), (-30, (-40, None, None), (-50, None, None))) assert max_path_sum(tree) == -10 def test_max_path_sum_mixed_tree(): tree = (10, (2, (20, None, None), (1, None, None)), (10, None, (-25, (3, None, None), (4, None, None)))) assert max_path_sum(tree) == 42","solution":"def max_path_sum(tree): def helper(node): if not node: return (0, float('-inf')) val, left, right = node left_single, left_max = helper(left) right_single, right_max = helper(right) # Maximum path sum without splitting max_single_path = max(val, val + left_single, val + right_single) # Maximum splitting path max_topology = max(max_single_path, val + left_single + right_single) return (max_single_path, max(max_topology, left_max, right_max)) return helper(tree)[1]"},{"question":"from typing import List, Tuple from collections import defaultdict def find_max_cost_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given an undirected graph with n nodes and m edges. Each edge has a weight associated with it, representing the cost to traverse that edge. Your task is to find the maximum cost of any path between any two nodes in the graph. Args: n: int - Number of nodes in the graph. m: int - Number of edges in the graph. edges: List[Tuple[int, int, int]] - List of edges where each edge is represented by a tuple (u, v, c) with u and v being the nodes connected by the edge and c being the weight of the edge. Returns: int - The maximum cost of any path between any two nodes in the graph. Example: >>> find_max_cost_path(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 6)]) 12 >>> find_max_cost_path(2, 1, [(1, 2, 200)]) 200 pass # Unit Test import pytest def test_example1(): n = 4 m = 4 edges = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 6)] assert find_max_cost_path(n, m, edges) == 12 def test_single_edge(): n = 2 m = 1 edges = [(1, 2, 200)] assert find_max_cost_path(n, m, edges) == 200 def test_linear_graph(): n = 5 m = 4 edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1)] assert find_max_cost_path(n, m, edges) == 4 def test_star_graph(): n = 5 m = 4 edges = [(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4)] assert find_max_cost_path(n, m, edges) == 4 def test_disconnected_graph(): n = 6 m = 5 edges = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 6), (5, 6, 7)] assert find_max_cost_path(n, m, edges) == 12 if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import defaultdict import sys def dfs(node, graph, visited, dist): visited[node] = True max_cost = 0 for neighbor, weight in graph[node]: if not visited[neighbor]: dist[neighbor] = dist[node] + weight max_cost = max(max_cost, dist[neighbor]) max_cost = max(max_cost, dfs(neighbor, graph, visited, dist)) return max_cost def find_max_cost_path(n, m, edges): graph = defaultdict(list) for u, v, c in edges: graph[u].append((v, c)) graph[v].append((u, c)) visited = [False] * (n + 1) dist = [0] * (n + 1) max_cost = 0 for node in range(1, n + 1): if not visited[node]: max_cost = max(max_cost, dfs(node, graph, visited, dist)) return max_cost"},{"question":"def arrange_plants(n: int, plants: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Arrange the plants in one line in an alternating pattern starting with a rose. :param n: An integer representing the number of plants. :param plants: A list of tuples where each tuple contains a string (\\"rose\\" or \\"tulip\\") and an integer (height of the plant). :return: A list of tuples arranged in the desired pattern. >>> arrange_plants(6, [(\\"rose\\", 5), (\\"tulip\\", 3), (\\"rose\\", 2), (\\"tulip\\", 10), (\\"rose\\", 1), (\\"tulip\\", 4)]) [(\\"rose\\", 5), (\\"tulip\\", 3), (\\"rose\\", 2), (\\"tulip\\", 10), (\\"rose\\", 1), (\\"tulip\\", 4)] >>> arrange_plants(5, [(\\"tulip\\", 6), (\\"tulip\\", 5), (\\"rose\\", 8), (\\"tulip\\", 2), (\\"tulip\\", 9)]) [(\\"rose\\", 8), (\\"tulip\\", 6)] >>> arrange_plants(3, [(\\"rose\\", 1), (\\"rose\\", 2), (\\"rose\\", 3)]) [] >>> arrange_plants(3, [(\\"tulip\\", 1), (\\"tulip\\", 2), (\\"tulip\\", 3)]) [] >>> arrange_plants(2, [(\\"rose\\", 1), (\\"tulip\\", 2)]) [(\\"rose\\", 1), (\\"tulip\\", 2)] >>> arrange_plants(7, [(\\"rose\\", 4), (\\"tulip\\", 6), (\\"rose\\", 3), (\\"tulip\\", 2), (\\"rose\\", 5), (\\"rose\\", 1), (\\"tulip\\", 7)]) [(\\"rose\\", 4), (\\"tulip\\", 6), (\\"rose\\", 3), (\\"tulip\\", 2), (\\"rose\\", 5), (\\"tulip\\", 7)]","solution":"def arrange_plants(n, plants): Arrange the plants in one line in an alternating pattern starting with a rose. :param n: An integer representing the number of plants. :param plants: A list of tuples where each tuple contains a string (\\"rose\\" or \\"tulip\\") and an integer (height of the plant). :return: A list of tuples arranged in the desired pattern. roses = [plant for plant in plants if plant[0] == \\"rose\\"] tulips = [plant for plant in plants if plant[0] == \\"tulip\\"] if not roses or not tulips: return [] arranged = [] while roses and tulips: arranged.append(roses.pop(0)) arranged.append(tulips.pop(0)) return arranged"},{"question":"class KingdomHierarchy: def __init__(self, ruler): Initialize the KingdomHierarchy with the given ruler. Args: ruler (str): The name of the ruler of the kingdom. self.parent = {} self.ruler = ruler def add_citizen(self, child, parent): Add a citizen to the kingdom with their parent. Args: child (str): The name of the child citizen. parent (str): The name of the parent citizen. self.parent[child] = parent def find_path_to_ruler(self, citizen): Find the path from the given citizen to the ruler. Args: citizen (str): The name of the citizen. Returns: List[str]: The path from the citizen to the ruler. pass def closest_common_ancestor(self, citizen1, citizen2): Determine the closest common ancestor of two citizens. Args: citizen1 (str): The name of the first citizen. citizen2 (str): The name of the second citizen. Returns: str: The name of the closest common ancestor. pass def solve_kingdom_hierarchy(n, ruler, relations, q, queries): Solve the kingdom hierarchy problem. Args: n (int): The number of citizens. ruler (str): The name of the ruler. relations (List[Tuple[str, str]]): List of child-parent relations. q (int): The number of queries. queries (List[Tuple[str, str]]): List of citizen pairs for queries. Returns: List[str]: The closest common ancestors for each query. pass # Example test cases def test_find_path_to_ruler(): kingdom = KingdomHierarchy(\\"Henry\\") kingdom.add_citizen(\\"Alice\\", \\"Bob\\") kingdom.add_citizen(\\"Bob\\", \\"Henry\\") kingdom.add_citizen(\\"Charlie\\", \\"Henry\\") kingdom.add_citizen(\\"David\\", \\"Alice\\") kingdom.add_citizen(\\"Eve\\", \\"Charlie\\") kingdom.add_citizen(\\"Frank\\", \\"Charlie\\") assert kingdom.find_path_to_ruler(\\"David\\") == [\\"David\\", \\"Alice\\", \\"Bob\\", \\"Henry\\"] assert kingdom.find_path_to_ruler(\\"Eve\\") == [\\"Eve\\", \\"Charlie\\", \\"Henry\\"] assert kingdom.find_path_to_ruler(\\"Frank\\") == [\\"Frank\\", \\"Charlie\\", \\"Henry\\"] def test_closest_common_ancestor(): kingdom = KingdomHierarchy(\\"Henry\\") kingdom.add_citizen(\\"Alice\\", \\"Bob\\") kingdom.add_citizen(\\"Bob\\", \\"Henry\\") kingdom.add_citizen(\\"Charlie\\", \\"Henry\\") kingdom.add_citizen(\\"David\\", \\"Alice\\") kingdom.add_citizen(\\"Eve\\", \\"Charlie\\") kingdom.add_citizen(\\"Frank\\", \\"Charlie\\") assert kingdom.closest_common_ancestor(\\"David\\", \\"Eve\\") == \\"Henry\\" assert kingdom.closest_common_ancestor(\\"Eve\\", \\"Frank\\") == \\"Charlie\\" assert kingdom.closest_common_ancestor(\\"David\\", \\"Frank\\") == \\"Henry\\" def test_solve_kingdom_hierarchy(): n = 7 ruler = \\"Henry\\" relations = [(\\"Alice\\", \\"Bob\\"), (\\"Bob\\", \\"Henry\\"), (\\"Charlie\\", \\"Henry\\"), (\\"David\\", \\"Alice\\"), (\\"Eve\\", \\"Charlie\\"), (\\"Frank\\", \\"Charlie\\")] q = 3 queries = [(\\"David\\", \\"Eve\\"), (\\"Eve\\", \\"Frank\\"), (\\"David\\", \\"Frank\\")] expected_output = [\\"Henry\\", \\"Charlie\\", \\"Henry\\"] assert solve_kingdom_hierarchy(n, ruler, relations, q, queries) == expected_output","solution":"class KingdomHierarchy: def __init__(self, ruler): self.parent = {} self.ruler = ruler def add_citizen(self, child, parent): self.parent[child] = parent def find_path_to_ruler(self, citizen): path = [] while citizen != self.ruler: path.append(citizen) citizen = self.parent[citizen] path.append(self.ruler) return path def closest_common_ancestor(self, citizen1, citizen2): path1 = self.find_path_to_ruler(citizen1) path2 = self.find_path_to_ruler(citizen2) i = len(path1) - 1 j = len(path2) - 1 common_ancestor = None while i >= 0 and j >= 0 and path1[i] == path2[j]: common_ancestor = path1[i] i -= 1 j -= 1 return common_ancestor def solve_kingdom_hierarchy(n, ruler, relations, q, queries): kingdom = KingdomHierarchy(ruler) for u, v in relations: kingdom.add_citizen(u, v) results = [] for a, b in queries: results.append(kingdom.closest_common_ancestor(a, b)) return results"},{"question":"def count_buildings_receiving_sunlight(n: int, heights: List[int]) -> int: Returns the total number of buildings that receive sunlight. Parameters: n (int): The number of buildings. heights (List[int]): List of heights of the buildings. Returns: int: The total number of buildings that receive sunlight. Examples: >>> count_buildings_receiving_sunlight(5, [4, 3, 7, 1, 8]) 3 >>> count_buildings_receiving_sunlight(4, [1, 2, 3, 4]) 4 from solution import count_buildings_receiving_sunlight def test_example_1(): n = 5 heights = [4, 3, 7, 1, 8] assert count_buildings_receiving_sunlight(n, heights) == 3 def test_example_2(): n = 4 heights = [1, 2, 3, 4] assert count_buildings_receiving_sunlight(n, heights) == 4 def test_all_equal_heights(): n = 4 heights = [3, 3, 3, 3] assert count_buildings_receiving_sunlight(n, heights) == 1 def test_decreasing_heights(): n = 5 heights = [5, 4, 3, 2, 1] assert count_buildings_receiving_sunlight(n, heights) == 1 def test_random_heights(): n = 6 heights = [1, 3, 2, 5, 4, 6] assert count_buildings_receiving_sunlight(n, heights) == 4","solution":"def count_buildings_receiving_sunlight(n, heights): Returns the total number of buildings that receive sunlight. count = 0 max_height_so_far = 0 for height in heights: if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"def min_operations_to_combine_plates(k: int, weights: List[int]) -> int: Returns the minimum number of operations needed to combine all plates into one. Parameters: k (int): The number of plates in the stack. weights (List[int]): A list of integers representing the weights of the plates. Returns: int: The minimum number of operations to combine all plates into one. Examples: >>> min_operations_to_combine_plates(4, [2, 3, 5, 8]) 3 >>> min_operations_to_combine_plates(6, [1, 2, 3, 4, 5, 6]) 5 >>> min_operations_to_combine_plates(2, [10, 20]) 1 >>> min_operations_to_combine_plates(3, [1, 1, 1]) 2 >>> min_operations_to_combine_plates(5, [1, 2, 3, 4, 5]) 4 >>> min_operations_to_combine_plates(7, [5, 10, 15, 20, 25, 30, 35]) 6 # Write your code here","solution":"def min_operations_to_combine_plates(k, weights): Returns the minimum number of operations needed to combine all plates into one. # Since combining two plates into one reduces the total number of plates by 1, # it will always take (k - 1) operations to combine all plates into one. return k - 1 # Example usage print(min_operations_to_combine_plates(4, [2, 3, 5, 8])) # Should output 3"},{"question":"from collections import Counter def is_flexible_anagram(s1, s2): Check if s2 is a Flexible Anagram of s1. >>> is_flexible_anagram(\\"abc\\", \\"cab\\") True >>> is_flexible_anagram(\\"abc\\", \\"cad\\") True >>> is_flexible_anagram(\\"abc\\", \\"aaa\\") False pass def flexible_anagram_test_cases(test_cases): Determine Flexible Anagram status for multiple test cases. >>> flexible_anagram_test_cases([(\\"abc\\", \\"cab\\"), (\\"abc\\", \\"cad\\"), (\\"abc\\", \\"aaa\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> flexible_anagram_test_cases([(\\"abc\\", \\"abc\\"), (\\"abc\\", \\"bbc\\"), (\\"abc\\", \\"xyz\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass def test_is_flexible_anagram(): assert is_flexible_anagram(\\"abc\\", \\"cab\\") == True assert is_flexible_anagram(\\"abc\\", \\"cad\\") == True assert is_flexible_anagram(\\"abc\\", \\"aaa\\") == False assert is_flexible_anagram(\\"abc\\", \\"bbc\\") == True assert is_flexible_anagram(\\"abc\\", \\"xyz\\") == False assert is_flexible_anagram(\\"a\\", \\"b\\") == True assert is_flexible_anagram(\\"aa\\", \\"ab\\") == True assert is_flexible_anagram(\\"aa\\", \\"bb\\") == False def test_flexible_anagram_test_cases(): test_cases = [(\\"abc\\", \\"cab\\"), (\\"abc\\", \\"cad\\"), (\\"abc\\", \\"aaa\\")] assert flexible_anagram_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [(\\"abc\\", \\"abc\\"), (\\"abc\\", \\"bbc\\"), (\\"abc\\", \\"xyz\\")] assert flexible_anagram_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [(\\"a\\", \\"b\\"), (\\"aa\\", \\"ab\\"), (\\"aa\\", \\"bb\\")] assert flexible_anagram_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"from collections import Counter def is_flexible_anagram(s1, s2): if s1 == s2: return True # Check frequencies of characters count_s1 = Counter(s1) count_s2 = Counter(s2) # Check the differences in the two frequency counters diff_s1_to_s2 = count_s1 - count_s2 # Characters in s1 that are not in s2 diff_s2_to_s1 = count_s2 - count_s1 # Characters in s2 that are not in s1 # If there is more than one character in either diff, it's not a flexible anagram if len(diff_s1_to_s2) > 1 or len(diff_s2_to_s1) > 1: return False # Check if using one character from diff_s1_to_s2 resolves the one discrepancy in diff_s2_to_s1 return sum(diff_s1_to_s2.values()) <= 1 and sum(diff_s2_to_s1.values()) <= 1 def flexible_anagram_test_cases(test_cases): results = [] for s1, s2 in test_cases: if is_flexible_anagram(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def smallest_lexicographical_string(pattern: str) -> str: Given a string pattern that consists of characters 'a', 'b', and 'c', find the smallest lexicographical string containing at least as many 'a's, 'b's, and 'c's as the pattern. The lexicographical order for characters is defined as 'a' < 'b' < 'c'. >>> smallest_lexicographical_string(\\"aabbcc\\") 'aabbcc' >>> smallest_lexicographical_string(\\"abcabcabc\\") 'aaabbbccc' >>> smallest_lexicographical_string(\\"ccbbaa\\") 'aabbcc'","solution":"def smallest_lexicographical_string(pattern): Returns the smallest lexicographical string containing at least as many 'a's, 'b's, and 'c's as the pattern. count_a = pattern.count('a') count_b = pattern.count('b') count_c = pattern.count('c') return 'a' * count_a + 'b' * count_b + 'c' * count_c"},{"question":"from typing import List def min_elevation_diff(grid: List[List[int]]) -> int: You are given a 2D grid of size n x n consisting of non-negative integers. Each cell (i, j) contains an integer that represents a height. You start at the top-left corner of the grid (cell (1, 1)) and you want to reach the bottom-right corner (cell (n, n)). From any cell (i, j), you can only move in two directions: - Right to (i, j+1), as long as j+1 ≤ n. - Down to (i+1, j), as long as i+1 ≤ n. Your goal is to find the minimum elevation difference path from the top-left corner to the bottom-right corner. The elevation difference of the path is defined as the maximum absolute difference between the heights of two adjacent cells on the path. Args: grid (List[List[int]]): A 2D grid of heights. Returns: int: The minimum elevation difference of the optimal path from the top-left corner to the bottom-right corner. Example: >>> min_elevation_diff([ ... [1, 3, 5], ... [2, 8, 3], ... [4, 6, 2] ... ]) 2 Test Cases: >>> min_elevation_diff([ ... [1, 3, 5], ... [2, 8, 3], ... [4, 6, 2] ... ]) 2 >>> min_elevation_diff([ ... [0] ... ]) 0 >>> min_elevation_diff([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> min_elevation_diff([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) 1 >>> min_elevation_diff([ ... [9, 8, 7], ... [8, 7, 6], ... [7, 6, 5] ... ]) 1 >>> min_elevation_diff([ ... [1, 1000000000], ... [1000000000, 1] ... ]) 999999999 pass","solution":"from heapq import heappush, heappop def min_elevation_diff(grid): n = len(grid) directions = [(0, 1), (1, 0)] # Right and Down # Min-heap to store (max_diff, x, y) pq = [(0, 0, 0)] # Starting at (0, 0) with initial difference 0 visited = [[False] * n for _ in range(n)] visited[0][0] = True while pq: max_diff, x, y = heappop(pq) # If we've reached the bottom-right corner if x == n - 1 and y == n - 1: return max_diff for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True new_diff = max(max_diff, abs(grid[nx][ny] - grid[x][y])) heappush(pq, (new_diff, nx, ny)) return -1 # If there is no path (shouldn't happen with valid inputs) # Example usage example_grid = [ [1, 3, 5], [2, 8, 3], [4, 6, 2] ] print(min_elevation_diff(example_grid)) # Output: 2"},{"question":"def can_become_strictly_increasing(n, sequence): Determines if a sequence can become strictly increasing by removing at most one element. :param n: Number of elements in the sequence :param sequence: List of integers representing the sequence :return: \\"YES\\" if it can become strictly increasing by removing one element, else \\"NO\\" pass from typing import List def test_example_1(): assert can_become_strictly_increasing(5, [1, 2, 10, 5, 7]) == \\"YES\\" def test_example_2(): assert can_become_strictly_increasing(5, [1, 2, 2, 3, 4]) == \\"YES\\" def test_example_3(): assert can_become_strictly_increasing(3, [5, 4, 3]) == \\"NO\\" def test_already_increasing(): assert can_become_strictly_increasing(4, [1, 2, 3, 4]) == \\"YES\\" def test_one_removal_needed(): assert can_become_strictly_increasing(6, [1, 2, 6, 4, 5]) == \\"YES\\" def test_cannot_be_fixed(): assert can_become_strictly_increasing(4, [3, 3, 3, 3]) == \\"NO\\" def test_decreasing_with_one_removal(): assert can_become_strictly_increasing(4, [4, 1, 2, 3]) == \\"YES\\" def test_single_element(): assert can_become_strictly_increasing(2, [2, 1]) == \\"YES\\" def test_no_removal_needed(): assert can_become_strictly_increasing(2, [1, 2]) == \\"YES\\" def test_long_sequence(): assert can_become_strictly_increasing(6, [1, 2, 3, 5, 4, 6]) == \\"YES\\"","solution":"def can_become_strictly_increasing(n, sequence): Determines if a sequence can become strictly increasing by removing at most one element. :param n: Number of elements in the sequence :param sequence: List of integers representing the sequence :return: \\"YES\\" if it can become strictly increasing by removing one element, else \\"NO\\" def is_strictly_increasing(seq): for i in range(len(seq) - 1): if seq[i] >= seq[i + 1]: return False return True if is_strictly_increasing(sequence): return \\"YES\\" for i in range(n): if is_strictly_increasing(sequence[:i] + sequence[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"def check_event_compliance(n, rules, m, events): Determines compliance of each event in the sequence according to the rules. Args: n (int): Number of defined rules. rules (list of tuple): A list of tuples where each tuple contains an event type and its required status. m (int): Number of events in the sequence. events (list of tuple): A list of tuples where each tuple contains an event type and its current status. Returns: list: A list of string \\"Yes\\" or \\"No\\" indicating whether each event is compliant. # Your code here def test_check_event_compliance(): n = 3 rules = [(\\"login\\", \\"success\\"), (\\"logout\\", \\"success\\"), (\\"error\\", \\"fail\\")] m = 4 events = [(\\"login\\", \\"success\\"), (\\"logout\\", \\"fail\\"), (\\"error\\", \\"fail\\"), (\\"login\\", \\"fail\\")] result = check_event_compliance(n, rules, m, events) expected = [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"] assert result == expected def test_check_event_compliance_all_yes(): n = 2 rules = [(\\"start\\", \\"active\\"), (\\"stop\\", \\"inactive\\")] m = 2 events = [(\\"start\\", \\"active\\"), (\\"stop\\", \\"inactive\\")] result = check_event_compliance(n, rules, m, events) expected = [\\"Yes\\", \\"Yes\\"] assert result == expected def test_check_event_compliance_all_no(): n = 2 rules = [(\\"start\\", \\"active\\"), (\\"stop\\", \\"inactive\\")] m = 2 events = [(\\"start\\", \\"inactive\\"), (\\"stop\\", \\"active\\")] result = check_event_compliance(n, rules, m, events) expected = [\\"No\\", \\"No\\"] assert result == expected def test_check_event_compliance_mixed(): n = 4 rules = [(\\"start\\", \\"active\\"), (\\"stop\\", \\"inactive\\"), (\\"open\\", \\"on\\"), (\\"close\\", \\"off\\")] m = 4 events = [(\\"start\\", \\"active\\"), (\\"stop\\", \\"active\\"), (\\"open\\", \\"off\\"), (\\"close\\", \\"off\\")] result = check_event_compliance(n, rules, m, events) expected = [\\"Yes\\", \\"No\\", \\"No\\", \\"Yes\\"] assert result == expected def test_check_event_compliance_no_rules(): n = 0 rules = [] m = 2 events = [(\\"start\\", \\"active\\"), (\\"stop\\", \\"inactive\\")] result = check_event_compliance(n, rules, m, events) expected = [\\"No\\", \\"No\\"] assert result == expected","solution":"def check_event_compliance(n, rules, m, events): Determines compliance of each event in the sequence according to the rules. Args: n (int): Number of defined rules. rules (list of tuple): A list of tuples where each tuple contains an event type and its required status. m (int): Number of events in the sequence. events (list of tuple): A list of tuples where each tuple contains an event type and its current status. Returns: list: A list of string \\"Yes\\" or \\"No\\" indicating whether each event is compliant. rule_dict = dict(rules) result = [] for event_type, status in events: if event_type in rule_dict and rule_dict[event_type] == status: result.append(\\"Yes\\") else: result.append(\\"No\\") return result"},{"question":"def query_books_values(n, values, queries): This function processes the queries to find the max and min magical values in specific subsections of Timmy's collection of books. :param n: Number of books :param values: List of magical values of books :param queries: List of queries, where each query is a tuple (l, r) :return: List of results for each query, where each result is a tuple (max_value, min_value) >>> query_books_values(5, [4, 2, 7, 5, 9], [(1, 3), (2, 4), (1, 5)]) [(7, 2), (7, 2), (9, 2)] >>> query_books_values(6, [1, 3, 5, 7, 9, 2], [(1, 6), (3, 5), (2, 2)]) [(9, 1), (9, 5), (3, 3)] >>> query_books_values(4, [10, 20, 30, 40], [(1, 4), (1, 2), (3, 4)]) [(40, 10), (20, 10), (40, 30)] >>> query_books_values(3, [100, 200, 300], [(1, 2), (2, 3), (1, 3)]) [(200, 100), (300, 200), (300, 100)] >>> query_books_values(5, [5, 8, 2, 6, 4], [(1, 1), (3, 3), (5, 5)]) [(5, 5), (2, 2), (4, 4)] >>> query_books_values(7, [11, 13, 15, 9, 8, 17, 19], [(4, 5), (6, 7)]) [(9, 8), (19, 17)] >>> query_books_values(8, [3, 14, 7, 6, 2, 20, 18, 1], [(1, 8)]) [(20, 1)]","solution":"def query_books_values(n, values, queries): This function processes the queries to find the max and min magical values in specific subsections of Timmy's collection of books. :param n: Number of books :param values: List of magical values of books :param queries: List of queries, where each query is a tuple (l, r) :return: List of results for each query, where each result is a tuple (max_value, min_value) results = [] for query in queries: l, r = query subset = values[l-1:r] max_val = max(subset) min_val = min(subset) results.append((max_val, min_val)) return results"},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: Returns a list of integers where each element represents the number of days to wait for a warmer temperature. If no warmer temperature, returns 0 for that day. >>> daily_temperatures(4, [73, 74, 75, 71]) [1, 1, 0, 0] >>> daily_temperatures(5, [80, 70, 60, 50, 40]) [0, 0, 0, 0, 0] >>> daily_temperatures(5, [50, 60, 70, 80, 90]) [1, 1, 1, 1, 0] >>> daily_temperatures(7, [73, 74, 75, 71, 69, 72, 76]) [1, 1, 4, 2, 1, 1, 0] >>> daily_temperatures(9, [30, 40, 32, 33, 45, 38, 50, 41, 53]) [1, 3, 1, 1, 2, 1, 2, 1, 0] >>> daily_temperatures(0, []) []","solution":"def daily_temperatures(n, temperatures): Returns a list of integers where each element represents the number of days to wait for a warmer temperature. If no warmer temperature, returns 0 for that day. result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"def min_flips_to_symmetric(plants: str) -> int: Returns the minimum number of flips required to make the plant sequence symmetric. >>> min_flips_to_symmetric(\\"abca\\") 1 >>> min_flips_to_symmetric(\\"a\\") 0 >>> min_flips_to_symmetric(\\"abba\\") 0 >>> min_flips_to_symmetric(\\"abcba\\") 0 >>> min_flips_to_symmetric(\\"racecar\\") 0 >>> min_flips_to_symmetric(\\"abcfba\\") 1 >>> min_flips_to_symmetric(\\"abcbaeeabc\\") 2","solution":"def min_flips_to_symmetric(plants): Returns the minimum number of flips required to make the plant sequence symmetric. n = len(plants) # Initialize a 2D DP array where dp[i][j] holds the minimum flips required to make plants[i:j+1] symmetric. dp = [[0] * n for _ in range(n)] # Fill DP array for length in range(2, n + 1): # Length of the substring for i in range(n - length + 1): j = i + length - 1 if plants[i] == plants[j]: dp[i][j] = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0 else: dp[i][j] = 1 + min( dp[i + 1][j] if i + 1 <= j else float('inf'), dp[i][j - 1] if j - 1 >= i else float('inf') ) return dp[0][n - 1]"},{"question":"def unique_names(n: int, photos: List[str]) -> List[str]: Returns a list of unique people's names from a list of photos, sorted in alphabetical order. Parameters: n (int): Number of photos photos (list): List of strings, each string is space-separated names in a photo Returns: list: List of unique names sorted alphabetically from solution import unique_names def test_unique_names_basic(): n = 3 photos = [ \\"alice bob charlie\\", \\"bob david\\", \\"alice edward\\" ] result = unique_names(n, photos) expected = [\\"alice\\", \\"bob\\", \\"charlie\\", \\"david\\", \\"edward\\"] assert result == expected def test_unique_names_empty_photo(): n = 3 photos = [ \\"alice bob charlie\\", \\"\\", \\"alice edward\\" ] result = unique_names(n, photos) expected = [\\"alice\\", \\"bob\\", \\"charlie\\", \\"edward\\"] assert result == expected def test_unique_names_single_photo(): n = 1 photos = [\\"alice bob charlie\\"] result = unique_names(n, photos) expected = [\\"alice\\", \\"bob\\", \\"charlie\\"] assert result == expected def test_unique_names_no_repeats(): n = 3 photos = [ \\"alice\\", \\"bob\\", \\"charlie\\" ] result = unique_names(n, photos) expected = [\\"alice\\", \\"bob\\", \\"charlie\\"] assert result == expected def test_unique_names_all_repeats(): n = 3 photos = [ \\"alice bob charlie\\", \\"alice bob charlie\\", \\"alice bob charlie\\" ] result = unique_names(n, photos) expected = [\\"alice\\", \\"bob\\", \\"charlie\\"] assert result == expected def test_unique_names_mixed_case(): n = 3 photos = [ \\"alice bob charlie\\", \\"Alice Bob Charlie\\", \\"ALICE BOB CHARLIE\\" ] result = unique_names(n, photos) expected = [\\"ALICE\\", \\"Alice\\", \\"BOB\\", \\"Bob\\", \\"CHARLIE\\", \\"Charlie\\", \\"alice\\", \\"bob\\", \\"charlie\\"] assert result == expected","solution":"def unique_names(n, photos): Returns a list of unique people's names from a list of photos, sorted in alphabetical order. Parameters: n (int): Number of photos photos (list): List of strings, each string is space-separated names in a photo Returns: list: List of unique names sorted alphabetically unique_people = set() for photo in photos: names = photo.split() for name in names: unique_people.add(name) sorted_unique_people = sorted(unique_people) return sorted_unique_people"},{"question":"def find_hamiltonian_path(n: int, m: int, grid: List[str]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner of the grid that passes through each cell exactly once. Args: n (int): the number of rows in the grid. m (int): the number of columns in the grid. grid (List[str]): the grid description consisting of '.' and '#'. Returns: str: \\"Yes\\" if such a path exists, otherwise \\"No\\". Example: >>> find_hamiltonian_path(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"....\\"]) 'No' >>> find_hamiltonian_path(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 'Yes' # complete the function here # Unit Tests def test_find_hamiltonian_path(): assert find_hamiltonian_path(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"....\\"]) == \\"No\\" assert find_hamiltonian_path(1, 1, [\\".\\"]) == \\"Yes\\" assert find_hamiltonian_path(2, 2, [\\"..\\", \\"..\\"]) == \\"Yes\\" assert find_hamiltonian_path(2, 2, [\\".#\\", \\"#.\\"]) == \\"No\\" assert find_hamiltonian_path(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == \\"No\\" assert find_hamiltonian_path(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) == \\"No\\" assert find_hamiltonian_path(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == \\"Yes\\" if __name__ == \\"__main__\\": test_find_hamiltonian_path() print(\\"All tests passed!\\")","solution":"def is_valid(x, y, n, m, grid, visited): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y] def find_hamiltonian_path(n, m, grid): def dfs(x, y, step): if step == n * m: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, n, m, grid, visited): if dfs(nx, ny, step + 1): return True visited[x][y] = False return False if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"No\\" visited = [[False] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if dfs(0, 0, 1): return \\"Yes\\" else: return \\"No\\""},{"question":"def is_return_to_origin(transform_string: str) -> bool: Returns True if the movements described by transform_string return to the origin (0, 0), otherwise returns False. >>> is_return_to_origin(\\"LR\\") True >>> is_return_to_origin(\\"UDLR\\") True >>> is_return_to_origin(\\"UUDDL\\") False from solution import is_return_to_origin def test_case_1(): assert is_return_to_origin(\\"LR\\") == True def test_case_2(): assert is_return_to_origin(\\"UDLR\\") == True def test_case_3(): assert is_return_to_origin(\\"UUDDL\\") == False def test_case_4(): assert is_return_to_origin(\\"\\") == True # Edge case: empty string, no movement def test_case_5(): assert is_return_to_origin(\\"RLUDLRUD\\") == True def test_case_6(): assert is_return_to_origin(\\"LLRR\\") == True def test_case_7(): assert is_return_to_origin(\\"LDU\\") == False def test_case_8(): assert is_return_to_origin(\\"UUDDLLRR\\") == True def test_case_9(): assert is_return_to_origin(\\"UUUU\\") == False # Moves up only, will not return to origin def test_case_10(): assert is_return_to_origin(\\"DDLLRRUU\\") == True","solution":"def is_return_to_origin(transform_string: str) -> bool: Returns True if the movements described by transform_string return to the origin (0, 0), otherwise returns False. horizontal = 0 vertical = 0 for move in transform_string: if move == \\"L\\": horizontal -= 1 elif move == \\"R\\": horizontal += 1 elif move == \\"U\\": vertical += 1 elif move == \\"D\\": vertical -= 1 return horizontal == 0 and vertical == 0"},{"question":"def max_Z_diff(n: int, m: int, grid: List[List[int]]) -> int: Given the height at each cell in the grid, find the maximum possible difference in height the hero can achieve through a 'Z' shaped swing. The 'Z' shaped swing consists of the following cells in order: 1. Top left corner of the 'Z' (i, j) 2. Top right corner of the 'Z' (i, j+w) 3. Bottom left corner of the 'Z' (i+h, j) 4. Bottom right corner of the 'Z' (i+h, j+w) The function should return the maximum height difference for any valid 'Z' shaped swing. >>> n, m = 6, 5 >>> grid = [ ... [1, 2, 3, 4, 5], ... [5, 1, 1, 1, 5], ... [1, 1, 1, 1, 1], ... [1, 3, 2, 4, 4], ... [1, 1, 1, 2, 1], ... [1, 2, 3, 1, 1] ... ] >>> max_Z_diff(n, m, grid) 4 >>> n, m = 3, 3 >>> grid = [ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ] >>> max_Z_diff(n, m, grid) 0 >>> n, m = 1, 1 >>> grid = [ ... [1] ... ] >>> max_Z_diff(n, m, grid) 0 >>> n, m = 2, 2 >>> grid = [ ... [1, 3], ... [2, 4] ... ] >>> max_Z_diff(n, m, grid) 3 >>> n, m = 5, 4 >>> grid = [ ... [1, 1, 1, 2], ... [3, 3, 3, 4], ... [1, 5, 1, 1], ... [1, 1, 6, 1], ... [1, 1, 1, 1] ... ] >>> max_Z_diff(n, m, grid) 5","solution":"def max_Z_diff(n, m, grid): max_diff = 0 for i in range(n): for j in range(m): for h in range(n - i): for w in range(m - j): if h > 0 and w > 0: heights = [ grid[i][j], grid[i][j + w], grid[i + h][j], grid[i + h][j + w] ] max_height = max(heights) min_height = min(heights) diff = max_height - min_height if diff > max_diff: max_diff = diff return max_diff # Example usage: n, m = 6, 5 grid = [ [1, 2, 3, 4, 5], [5, 1, 1, 1, 5], [1, 1, 1, 1, 1], [1, 3, 2, 4, 4], [1, 1, 1, 2, 1], [1, 2, 3, 1, 1], ] print(max_Z_diff(n, m, grid)) # Output: 4"},{"question":"def minimum_swaps_to_next_permutation(N: int) -> int: Find the minimum number of swaps required to rearrange the digits of N such that it becomes the smallest possible number but still greater than N. If it is not possible to obtain such a number, return -1. >>> minimum_swaps_to_next_permutation(123) 1 >>> minimum_swaps_to_next_permutation(321) -1 >>> minimum_swaps_to_next_permutation(115) 1","solution":"from itertools import permutations def minimum_swaps_to_next_permutation(N): Find the minimum number of swaps required to rearrange the digits of N such that it becomes the smallest possible number but still greater than N. If it is not possible to obtain such a number, return -1. str_N = str(N) digits = list(str_N) length = len(digits) # Generate the next permutation next_perm = None for i in range(length-2, -1, -1): if digits[i] < digits[i+1]: break else: return -1 # if no such 'i' is found, it's not possible to get the next permutation for j in range(length-1, i, -1): if digits[j] > digits[i]: break digits[i], digits[j] = digits[j], digits[i] digits = digits[:i+1] + sorted(digits[i+1:]) next_perm = ''.join(digits) # Calculate the minimum number of swaps original = list(str_N) count = 0 for k in range(length): if original[k] != digits[k]: swap_idx = k + digits[k+1:].index(original[k]) + 1 digits[k], digits[swap_idx] = digits[swap_idx], digits[k] count += 1 return count"},{"question":"def plan_trip(n: int, a: int, alice_cities: List[int], b: int, bob_cities: List[int], c: int, charlie_cities: List[int]) -> List[Tuple[int, str]]: Determines the optimal visiting sequence for Alice, Bob, and Charlie with given priorities. Alice has the highest priority, followed by Bob, and then Charlie. >>> plan_trip(5, 3, [1, 2, 3], 2, [3, 4], 2, [4, 5]) [(1, 'A'), (2, 'A'), (3, 'A'), (4, 'B'), (5, 'C')] >>> plan_trip(3, 2, [3, 2], 1, [3], 1, [1]) [(1, 'C'), (2, 'A'), (3, 'A')] >>> plan_trip(4, 2, [1, 4], 3, [1, 2, 3], 2, [2, 3]) [(1, 'A'), (2, 'B'), (3, 'B'), (4, 'A')] >>> plan_trip(6, 3, [2, 3, 6], 3, [1, 3, 5], 3, [4, 5, 6]) [(1, 'B'), (2, 'A'), (3, 'A'), (4, 'C'), (5, 'B'), (6, 'A')] >>> plan_trip(7, 2, [7, 1], 2, [5, 1], 5, [2, 3, 4, 5, 6]) [(1, 'A'), (2, 'C'), (3, 'C'), (4, 'C'), (5, 'B'), (6, 'C'), (7, 'A')]","solution":"def plan_trip(n, a, alice_cities, b, bob_cities, c, charlie_cities): Determines the optimal visiting sequence for Alice, Bob, and Charlie with given priorities. # Create a city to visitor map city_to_visitor = {} # Alice's cities (highest priority) for city in alice_cities: city_to_visitor[city] = 'A' # Bob's cities (second highest priority) for city in bob_cities: if city not in city_to_visitor: city_to_visitor[city] = 'B' # Charlie's cities (lowest priority) for city in charlie_cities: if city not in city_to_visitor: city_to_visitor[city] = 'C' # Prepare the output in a sorted manner based on city numbers output = [(city, city_to_visitor[city]) for city in range(1, n+1)] return output"},{"question":"def min_path_sum(matrix: List[List[int]]) -> int: Compute the minimum path sum from the top-left to the bottom-right corner of a matrix. The path can only move either down or right at any point in time. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_path_sum([[0]]) 0 >>> min_path_sum([[-1, -3, -1], [-1, -5, -1], [-4, -2, -1]]) -12 pass","solution":"def min_path_sum(matrix): n = len(matrix) m = len(matrix[0]) # Initialize dp array with the same dimensions as the matrix dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first row (only right moves) for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (only down moves) for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner contains the minimum path sum return dp[n-1][m-1]"},{"question":"def determine_winner(s: str) -> str: Determine who will win the game if both players play optimally. Alice and Bob are playing a game with a string consisting of only characters 'a', 'b', and 'c'. The game works as follows: Alice and Bob take turns to make a move, with Alice going first. On each player's turn, they can choose any character in the string and replace it with another character ('a', 'b', or 'c'). The game ends when the string reads the same forward and backward, i.e., it becomes a palindrome. Both players always play optimally, trying to win. Alice's goal is to make the string a palindrome as quickly as possible, whereas Bob's goal is to prevent the string from becoming a palindrome for as long as possible. Given the initial string, determine who will win the game if both players play optimally. The input consists of a single line containing the initial string s (1 ≤ |s| ≤ 100, consisting only of characters 'a', 'b', and 'c'). Output \\"Alice\\" if Alice can guarantee a win, regardless of how Bob plays, or \\"Bob\\" if Bob can prevent the string from becoming a palindrome indefinitely if he plays optimally. Examples: >>> determine_winner(\\"abc\\") \\"Alice\\" >>> determine_winner(\\"abca\\") \\"Alice\\" >>> determine_winner(\\"aaa\\") \\"Alice\\" >>> determine_winner(\\"abcb\\") \\"Bob\\"","solution":"def determine_winner(s): n = len(s) mismatches = sum(s[i] != s[n - i - 1] for i in range(n // 2)) # Alice's win if the mismatches are odd or zero, else Bob's win. if mismatches % 2 == 1 or mismatches == 0: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def is_subsequence_sum_possible(n: int, k: int, sequence: List[int]) -> str: Determine if there is a subsequence of the given sequence whose sum is exactly equal to \`k\`. n: int - the number of integers in the sequence k: int - the target sum sequence: list of int - the list of integers in the sequence Returns \\"YES\\" if there is a subsequence whose sum equals \`k\`, otherwise \\"NO\\". >>> is_subsequence_sum_possible(5, 9, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_subsequence_sum_possible(5, 20, [1, 2, 3, 4, 5]) \\"NO\\" >>> is_subsequence_sum_possible(1, 5, [5]) \\"YES\\" >>> is_subsequence_sum_possible(1, 10, [5]) \\"NO\\" >>> is_subsequence_sum_possible(4, -10, [-3, -1, -4, -2]) \\"YES\\" >>> is_subsequence_sum_possible(4, -15, [-3, -1, -4, -2]) \\"NO\\" >>> is_subsequence_sum_possible(6, 8, [3, -2, 5, -1, 2, 4]) \\"YES\\" >>> is_subsequence_sum_possible(6, 20, [3, -2, 5, -1, 2, 4]) \\"NO\\"","solution":"def is_subsequence_sum_possible(n, k, sequence): Determine if there is a subsequence of the given sequence whose sum is exactly equal to \`k\`. n: int - the number of integers in the sequence k: int - the target sum sequence: list of int - the list of integers in the sequence Returns \\"YES\\" if there is a subsequence whose sum equals \`k\`, otherwise \\"NO\\". # Helper function to check all subsequences using recursion def is_sum_possible(index, current_sum): # Base case: If current_sum equals k if current_sum == k: return True # Base case: If we have exhausted all elements if index == n: return False # Check including current element if is_sum_possible(index + 1, current_sum + sequence[index]): return True # Check excluding current element if is_sum_possible(index + 1, current_sum): return True return False if is_sum_possible(0, 0): return \\"YES\\" return \\"NO\\""},{"question":"class RangeQueries: Class to handle range sum queries and point updates. Initialize with an array of integers. Can perform: - update(i, x): Update the element at index i in the array to x. - sum(l, r): Find the sum of the elements from index l to r inclusive. >>> rq = RangeQueries([1, 2, 3, 4, 5]) >>> rq.sum(0, 2) 6 >>> rq.update(1, 10) >>> rq.sum(0, 2) 14 >>> rq.sum(0, 4) 38 def __init__(self, array): self.tree = [] self.build(array) def build(self, array): pass def update(self, pos, value): pass def sum(self, l, r): pass","solution":"class RangeQueries: def __init__(self, array): self.array = array self.n = len(array) self.tree = [0] * (2 * self.n) self.build() def build(self): # Build the segment tree for i in range(self.n): self.tree[self.n + i] = self.array[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sum(self, l, r): l += self.n r += self.n + 1 # Make it inclusive s = 0 while l < r: if l % 2 == 1: s += self.tree[l] l += 1 if r % 2 == 1: r -= 1 s += self.tree[r] l //= 2 r //= 2 return s"},{"question":"import math from typing import List, Tuple def calculate_total_distance(n: int, operations: List[Tuple[str, int]]) -> float: Calculate the total Euclidean distance covered by a robotic arm. Each operation is defined by a specific direction (U, D, L, R) and a number of steps. Args: n: the number of operations operations: a list of tuples where each tuple contains a character (direction) and an integer (steps) Returns: The total Euclidean distance covered, rounded to two decimal places. >>> calculate_total_distance(4, [('U', 3), ('R', 4), ('D', 2), ('L', 1)]) 5.66 >>> calculate_total_distance(1, [('U', 5)]) 5.0 pass def test_example_case(): n = 4 operations = [('U', 3), ('R', 4), ('D', 2), ('L', 1)] assert math.isclose(calculate_total_distance(n, operations), 10.0, rel_tol=1e-2) def test_no_operations(): n = 0 operations = [] assert math.isclose(calculate_total_distance(n, operations), 0.0, rel_tol=1e-2) def test_single_up_operation(): n = 1 operations = [('U', 5)] assert math.isclose(calculate_total_distance(n, operations), 5.0, rel_tol=1e-2) def test_single_down_operation(): n = 1 operations = [('D', 3)] assert math.isclose(calculate_total_distance(n, operations), 3.0, rel_tol=1e-2) def test_mixed_operations(): n = 3 operations = [('U', 3), ('L', 4), ('R', 2)] assert math.isclose(calculate_total_distance(n, operations), 9.0, rel_tol=1e-2) def test_complex_operations(): n = 5 operations = [('U', 3), ('D', 2), ('L', 1), ('R', 6), ('U', 4)] assert math.isclose(calculate_total_distance(n, operations), 16.0, rel_tol=1e-2)","solution":"import math def calculate_total_distance(n, operations): x, y = 0, 0 total_distance = 0.0 for direction, steps in operations: if direction == 'U': new_y = y + steps total_distance += steps y = new_y elif direction == 'D': new_y = y - steps total_distance += steps y = new_y elif direction == 'L': new_x = x - steps total_distance += steps x = new_x elif direction == 'R': new_x = x + steps total_distance += steps x = new_x total_distance = round(total_distance, 2) return total_distance"},{"question":"def most_frequent_chars(s: str, k: int) -> str: Returns a string containing exactly k of the most frequent characters from the input string s. >>> most_frequent_chars(\\"aaabbc\\", 3) in [\\"aaabbc\\", \\"aaaabb\\", \\"aaabbbc\\", \\"bbbaaa\\", \\"bbaaac\\"] True >>> most_frequent_chars(\\"aaabbbccc\\", 3) in [\\"aaabbbccc\\", \\"bbbbcaaaa\\", \\"cccccaaaa\\"] True","solution":"from collections import Counter def most_frequent_chars(s, k): Returns a string containing exactly k of the most frequent characters from the input string s. # Count frequency of each character char_count = Counter(s) # Sort characters by frequency and then alphabetically sorted_chars = sorted(char_count.items(), key=lambda x: (-x[1], x[0])) # Form the result using the k most frequent characters result = ''.join([char * count for char, count in sorted_chars[:k]]) return result"},{"question":"def min_additional_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Calculates the minimum number of additional roads needed to make all cities fully connected. :param n: Number of cities :param m: Number of existing roads :param roads: List of tuples representing the roads :return: Minimum number of additional roads needed >>> min_additional_roads(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> min_additional_roads(4, 2, [(1, 2), (3, 4)]) 1 from typing import List, Tuple def test_example_1(): n = 5 m = 3 roads = [(1, 2), (2, 3), (4, 5)] assert min_additional_roads(n, m, roads) == 1 def test_example_2(): n = 4 m = 2 roads = [(1, 2), (3, 4)] assert min_additional_roads(n, m, roads) == 1 def test_example_3(): n = 6 m = 5 roads = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 1)] assert min_additional_roads(n, m, roads) == 0 def test_complete_graph(): n = 5 m = 10 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5), (2, 4), (3, 1), (4, 3), (5, 2), (1, 4)] assert min_additional_roads(n, m, roads) == 0 def test_no_existing_roads(): n = 3 m = 0 roads = [] assert min_additional_roads(n, m, roads) == 2 def test_single_city(): n = 1 m = 0 roads = [] assert min_additional_roads(n, m, roads) == 0 def test_two_disconnected_groups(): n = 6 m = 3 roads = [(1, 2), (2, 3), (4, 5)] assert min_additional_roads(n, m, roads) == 2","solution":"def min_additional_roads(n, m, roads): Calculates the minimum number of additional roads needed to make all cities fully connected. :param n: Number of cities :param m: Number of existing roads :param roads: List of tuples representing the roads :return: Minimum number of additional roads needed from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i, visited, graph) components += 1 # The number of additional roads required return components - 1"},{"question":"def string_match(s: str, t: str) -> str: Determines if two strings s and t match based on given rules. >>> string_match(\\"abc\\", \\"abc\\") == \\"YES\\" >>> string_match(\\"a*c\\", \\"abc\\") == \\"YES\\" >>> string_match(\\"a*cb\\", \\"axcy\\") == \\"NO\\" pass def process_test_cases(k: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if each pair of strings match. >>> k = 3 >>> test_cases = [(\\"abc\\", \\"a*c\\"), (\\"abc\\", \\"a*d\\"), (\\"abc\\", \\"abc\\")] >>> process_test_cases(k, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def string_match(s, t): Determines if two strings s and t match based on given rules. if len(s) != len(t): return \\"NO\\" for i in range(len(s)): if s[i] != t[i] and s[i] != '*' and t[i] != '*': return \\"NO\\" return \\"YES\\" def process_test_cases(k, test_cases): results = [] for s, t in test_cases: result = string_match(s, t) results.append(result) return results"},{"question":"def assign_participants(n, m, ranges): Determine if all checkpoints can be covered by participants and generate an assignment plan if possible. Parameters: n (int): The total number of checkpoints. m (int): The total number of participants. ranges (List[Tuple[int, int]]): A list of tuples, each containing the start and end checkpoints a participant can cover. Returns: str: \\"YES\\" if a valid assignment exists, otherwise \\"NO\\". List[int]: An assignment list if a valid assignment exists. pass import pytest def test_example_case(): n = 5 m = 3 ranges = [(1, 3), (2, 5), (4, 5)] result = assign_participants(n, m, ranges) assert result[0] == \\"YES\\" assert len(set(result[1])) <= m def test_insufficient_coverage(): n = 3 m = 2 ranges = [(1, 1), (3, 3)] assert assign_participants(n, m, ranges) == \\"NO\\" def test_exact_coverage(): n = 3 m = 1 ranges = [(1, 3)] result = assign_participants(n, m, ranges) assert result[0] == \\"YES\\" assert result[1] == [1, 1, 1] def test_multiple_participants(): n = 7 m = 3 ranges = [(1, 3), (4, 6), (7, 7)] result = assign_participants(n, m, ranges) assert result[0] == \\"YES\\" assert len(set(result[1])) == m def test_large_input(): n = 10**5 m = 1 ranges = [(1, 10**5)] result = assign_participants(n, m, ranges) assert result[0] == \\"YES\\" assert result[1] == [1] * 10**5","solution":"def assign_participants(n, m, ranges): Determine if all checkpoints can be covered by participants and generate an assignment plan if possible. Parameters: n (int): The total number of checkpoints. m (int): The total number of participants. ranges (List[Tuple[int, int]]): A list of tuples, each containing the start and end checkpoints a participant can cover. Returns: str: \\"YES\\" if a valid assignment exists, otherwise \\"NO\\". List[int]: An assignment list if a valid assignment exists. coverage = [0] * (n + 1) for li, ri in ranges: coverage[li - 1] += 1 if ri < n: coverage[ri] -= 1 for i in range(1, n): coverage[i] += coverage[i - 1] if any(c == 0 for c in coverage[:-1]): return \\"NO\\" assignment = [-1] * n for idx, (li, ri) in enumerate(ranges): for j in range(li - 1, ri): if assignment[j] == -1: assignment[j] = idx + 1 return \\"YES\\", assignment"},{"question":"def min_cost_path(n: int, grid: List[List[int]]) -> int: Finds the path that minimizes the total cost required to reach from (0, 0) to (n-1, n-1). Parameters: - n: integer, size of the grid (1 ≤ n ≤ 100) - grid: list of lists of integers representing the grid Returns: - Integer, the minimal cost required to reach from (0, 0) to (n-1, n-1). Example: >>> min_cost_path(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> min_cost_path(1, [ ... [5] ... ]) 5","solution":"def min_cost_path(n, grid): Finds the path that minimizes the total cost required to reach from (0, 0) to (n-1, n-1). Parameters: - n: integer, size of the grid (1 ≤ n ≤ 100) - grid: list of lists of integers representing the grid Returns: - Integer, the minimal cost required to reach from (0, 0) to (n-1, n-1). # Create a 2D dp array initialized with infinity dp = [[float('inf')] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[-1][-1]"},{"question":"class ParkingSystem: Parking system to manage parking spaces in a busy city. The system supports three operations: 1. ENTER car_id: Assigns a parking space to a car if available. 2. EXIT car_id: Frees up the parking space occupied by the car. 3. QUERY car_id: Returns the parking space number occupied by the car or -1 if the car is not parked. >>> ps = ParkingSystem(5) >>> ps.enter(100) >>> ps.enter(200) >>> ps.query(100) 0 >>> ps.query(300) -1 >>> ps.exit(100) >>> ps.query(100) -1 def __init__(self, n): pass def enter(self, car_id): pass def exit(self, car_id): pass def query(self, car_id): pass import pytest def test_enter(): ps = ParkingSystem(5) ps.enter(100) ps.enter(200) assert ps.query(100) == 0 assert ps.query(200) == 1 def test_exit(): ps = ParkingSystem(5) ps.enter(100) ps.enter(200) ps.exit(100) assert ps.query(100) == -1 assert 0 in ps.available_spaces ps.enter(300) assert ps.query(300) == 0 def test_query(): ps = ParkingSystem(5) ps.enter(100) ps.enter(200) assert ps.query(100) == 0 assert ps.query(200) == 1 assert ps.query(300) == -1 def test_turn_away(): ps = ParkingSystem(2) ps.enter(100) ps.enter(200) ps.enter(300) assert ps.query(100) == 0 assert ps.query(200) == 1 assert ps.query(300) == -1 def test_complex_scenario(): ps = ParkingSystem(3) ps.enter(100) ps.enter(200) assert ps.query(100) == 0 assert ps.query(200) == 1 ps.exit(100) assert ps.query(100) == -1 ps.enter(300) assert ps.query(300) == 0 ps.enter(400) assert ps.query(400) == 2 ps.exit(200) ps.enter(500) assert ps.query(500) == 1","solution":"class ParkingSystem: def __init__(self, n): self.parking_spaces = [None] * n self.available_spaces = set(range(n)) self.car_parking = {} def enter(self, car_id): if not self.available_spaces: return space = min(self.available_spaces) self.parking_spaces[space] = car_id self.available_spaces.remove(space) self.car_parking[car_id] = space def exit(self, car_id): if car_id in self.car_parking: space = self.car_parking[car_id] self.parking_spaces[space] = None self.available_spaces.add(space) del self.car_parking[car_id] def query(self, car_id): return self.car_parking.get(car_id, -1)"},{"question":"from typing import List def generate_user_reports(n: int, user_info: List[str], m: int, project_info: List[str]) -> List[str]: Generates a report for each user showing their ID, name, the projects they have worked on, and the total hours they have contributed. Parameters: n (int): Number of users user_info (List[str]): List of user information in the format 'user_id user_name' m (int): Number of project records project_info (List[str]): List of project information in the format 'user_id project_name hours' Returns: List[str]: Report for each user sorted by user ID Example: >>> n = 3 >>> user_info = [\\"1 Alice\\", \\"2 Bob\\", \\"3 Charlie\\"] >>> m = 4 >>> project_info = [\\"1 ProjectX 5\\", \\"2 ProjectY 3\\", \\"1 ProjectZ 2\\", \\"3 ProjectX 4\\"] >>> generate_user_reports(n, user_info, m, project_info) ['1 AlicenProjectX 5nProjectZ 2nTotal hours: 7', '2 BobnProjectY 3nTotal hours: 3', '3 CharlienProjectX 4nTotal hours: 4'] pass def test_generate_user_reports_basic(): n = 3 user_info = [\\"1 Alice\\", \\"2 Bob\\", \\"3 Charlie\\"] m = 4 project_info = [\\"1 ProjectX 5\\", \\"2 ProjectY 3\\", \\"1 ProjectZ 2\\", \\"3 ProjectX 4\\"] expected_output = [ \\"1 AlicenProjectX 5nProjectZ 2nTotal hours: 7\\", \\"2 BobnProjectY 3nTotal hours: 3\\", \\"3 CharlienProjectX 4nTotal hours: 4\\" ] actual_output = generate_user_reports(n, user_info, m, project_info) assert actual_output == expected_output def test_generate_user_reports_single_user(): n = 1 user_info = [\\"1 Alice\\"] m = 1 project_info = [\\"1 ProjectX 5\\"] expected_output = [ \\"1 AlicenProjectX 5nTotal hours: 5\\" ] actual_output = generate_user_reports(n, user_info, m, project_info) assert actual_output == expected_output def test_generate_user_reports_multiple_projects(): n = 2 user_info = [\\"1 Alice\\", \\"2 Bob\\"] m = 3 project_info = [\\"1 ProjectX 5\\", \\"1 ProjectY 2\\", \\"2 ProjectZ 3\\"] expected_output = [ \\"1 AlicenProjectX 5nProjectY 2nTotal hours: 7\\", \\"2 BobnProjectZ 3nTotal hours: 3\\" ] actual_output = generate_user_reports(n, user_info, m, project_info) assert actual_output == expected_output def test_generate_user_reports_no_projects(): n = 2 user_info = [\\"1 Alice\\", \\"2 Bob\\"] m = 0 project_info = [] expected_output = [ \\"1 AlicenTotal hours: 0\\", \\"2 BobnTotal hours: 0\\" ] actual_output = generate_user_reports(n, user_info, m, project_info) assert actual_output == expected_output","solution":"def generate_user_reports(n, user_info, m, project_info): from collections import defaultdict user_dict = {} project_dict = defaultdict(list) for user in user_info: user_id, user_name = user.split() user_dict[int(user_id)] = user_name for project in project_info: user_id, project_name, hours = project.split() user_id = int(user_id) hours = int(hours) project_dict[user_id].append((project_name, hours)) reports = [] for user_id in sorted(user_dict.keys()): user_name = user_dict[user_id] report = f\\"{user_id} {user_name}n\\" total_hours = 0 for project_name, hours in project_dict[user_id]: report += f\\"{project_name} {hours}n\\" total_hours += hours report += f\\"Total hours: {total_hours}\\" reports.append(report) return reports # Example usage: # n = 3 # user_info = [\\"1 Alice\\", \\"2 Bob\\", \\"3 Charlie\\"] # m = 4 # project_info = [\\"1 ProjectX 5\\", \\"2 ProjectY 3\\", \\"1 ProjectZ 2\\", \\"3 ProjectX 4\\"] # reports = generate_user_reports(n, user_info, m, project_info) # for report in reports: # print(report)"},{"question":"def calculate_reading_days(n: int, pages_per_book: List[int], pages_per_day: int) -> int: Calculate the number of days it will take Amy to finish all the books given the number of pages she reads each day. >>> calculate_reading_days(1, [100], 50) 2 >>> calculate_reading_days(1, [100], 100) 1 >>> calculate_reading_days(1, [100], 150) 1 >>> calculate_reading_days(3, [100, 200, 300], 150) 4 >>> calculate_reading_days(3, [100, 200, 300], 100) 6 >>> calculate_reading_days(3, [100, 200, 300], 1000) 1","solution":"def calculate_reading_days(n, pages_per_book, pages_per_day): total_pages = sum(pages_per_book) days_needed = total_pages // pages_per_day if total_pages % pages_per_day != 0: days_needed += 1 return days_needed # Example usage: # n = 3 # pages_per_book = [100, 200, 300] # pages_per_day = 150 # print(calculate_reading_days(n, pages_per_book, pages_per_day)) # Output: 4"},{"question":"def count_message_pairs(N: int, D: int) -> int: Returns the number of unique ways messages can be sent satisfying the condition |i - j| ≤ D. >>> count_message_pairs(5, 1) == 8 >>> count_message_pairs(1, 0) == 0 >>> count_message_pairs(1, 1) == 0 >>> count_message_pairs(4, 4) == 12 >>> count_message_pairs(3, 5) == 6 >>> count_message_pairs(100000, 1) == 199998","solution":"def count_message_pairs(N, D): Returns the number of unique ways messages can be sent satisfying the condition |i - j| ≤ D. if D == 0: return 0 total_pairs = 0 for i in range(1, N+1): total_pairs += min(D, N - i) total_pairs += min(D, i - 1) return total_pairs"},{"question":"from typing import List def generate_balanced_strings(n: int) -> List[str]: Generates all possible balanced strings of length 2n. >>> generate_balanced_strings(2) [\\"(())\\", \\"()()\\"] >>> generate_balanced_strings(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_balanced_strings(1) [\\"()\\"] >>> generate_balanced_strings(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()\\"] >>> generate_balanced_strings(0) [\\"\\"] def balanced_strings(t: int, cases: List[int]) -> List[List[str]]: For each test case given by the number of test cases t and a list of integers cases, generate balanced strings and return them grouped by test cases. >>> balanced_strings(2, [2, 3]) [[\\"(())\\", \\"()()\\"], [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]] >>> balanced_strings(1, [1]) [[\\"()\\"]] >>> balanced_strings(3, [1, 2, 3]) [[\\"()\\"], [\\"(())\\", \\"()()\\"], [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]]","solution":"def generate_balanced_strings(n): Generates all possible balanced strings of length 2n. result = [] def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) backtrack(\\"\\", 0, 0) return sorted(result) def balanced_strings(t, cases): For each test case, generate balanced strings and print them results = [] for n in cases: results.append(generate_balanced_strings(n)) return results"},{"question":"from typing import List, Tuple def form_teams(t: int, test_cases: List[Tuple[int, List[int], List[int], List[int]]]) -> List[List[Tuple[int, int, int]]]: A company is hosting a charity marathon event and needs to organize the teams. Each team must consist of runners with distinct skill levels. The skill level of each runner is a unique integer. The company is given three lists of distinct skill levels: experienced runners, intermediate runners, and beginner runners. The organizer needs to ensure that each team consists of exactly one experienced runner, one intermediate runner, and one beginner runner. The total skill level sum of each team (i.e., the sum of the skill levels of the three runners in the team) must be pairwise distinct from all other teams. For each test case, print \`n\` lines. Each line should contain three integers representing the skill levels of the runners in each team: one experienced, one intermediate, and one beginner. The total skill level sums should be pairwise distinct among all teams. The order of teams does not matter. It is guaranteed that a solution always exists. If there are multiple possible answers, you may print any of them. Args: t (int): Number of test cases. test_cases (List of Tuples[int, List[int], List[int], List[int]]): List of test cases containing the number of teams and three lists of runners' skill levels. Returns: List[List[Tuple[int, int, int]]]: List of lists of tuples, each representing a team with skill levels of one experienced, one intermediate, and one beginner runner. Example: >>> t = 2 >>> test_cases = [ ... (3, [1, 7, 5], [6, 1, 2], [3, 8, 4]), ... (2, [9, 4], [7, 3], [5, 6]) ... ] >>> result = form_teams(t, test_cases) >>> for teams in result: ... for team in teams: ... print(team) ... (1, 6, 3) (7, 1, 8) (5, 2, 4) (9, 7, 5) (4, 3, 6) pass def test_single_case(): t = 1 test_cases = [ ( 3, [1, 7, 5], [6, 1, 2], [3, 8, 4] ) ] result = form_teams(t, test_cases) assert len(result[0]) == 3 teams = result[0] sums = set() for team in teams: team_sum = sum(team) assert team_sum not in sums sums.add(team_sum) def test_multiple_cases(): t = 2 test_cases = [ ( 3, [1, 7, 5], [6, 1, 2], [3, 8, 4] ), ( 2, [9, 4], [7, 3], [5, 6] ) ] result = form_teams(t, test_cases) assert len(result) == 2 # Check first case teams_1 = result[0] sums_1 = set() for team in teams_1: team_sum = sum(team) assert team_sum not in sums_1 sums_1.add(team_sum) # Check second case teams_2 = result[1] sums_2 = set() for team in teams_2: team_sum = sum(team) assert team_sum not in sums_2 sums_2.add(team_sum) def test_distinct_teams(): t = 1 test_cases = [ ( 4, [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ) ] result = form_teams(t, test_cases) teams = result[0] sums = set() for team in teams: team_sum = sum(team) assert team_sum not in sums sums.add(team_sum)","solution":"def form_teams(t, test_cases): result = [] for i in range(t): n = test_cases[i][0] experienced = test_cases[i][1] intermediate = test_cases[i][2] beginners = test_cases[i][3] experienced.sort() intermediate.sort() beginners.sort() teams = [] used_sums = set() for j in range(n): for k in range(n): for l in range(n): team_sum = experienced[j] + intermediate[k] + beginners[l] if team_sum not in used_sums: used_sums.add(team_sum) teams.append((experienced[j], intermediate[k], beginners[l])) break if len(teams) == j + 1: break if len(teams) == j + 1: continue result.append(teams) return result"},{"question":"def make_strict_upper_triangular(matrix: List[List[int]]) -> Union[str, Tuple[str, List[List[int]]]]: Determine if the given matrix can be transformed into a strict upper triangular matrix. If it can be transformed, return \\"YES\\" and the transformed matrix. Otherwise, return \\"NO\\". Args: matrix (List[List[int]]): The input n x n matrix with non-negative integers. Returns: Union[str, Tuple[str, List[List[int]]]]: \\"NO\\" or a tuple with \\"YES\\" and the transformed matrix. Examples: >>> make_strict_upper_triangular([[0, 1, 2], [3, 0, 4], [5, 6, 0]]) (\\"YES\\", [[0, 1, 2], [0, 0, 4], [0, 0, 0]]) >>> make_strict_upper_triangular([[1, 0], [0, 1]]) \\"NO\\" pass def format_output(result: Union[str, Tuple[str, List[List[int]]]]) -> str: Format the output from the \`make_strict_upper_triangular\` function. Args: result (Union[str, Tuple[str, List[List[int]]]]): The result from the previous function. Returns: str: The formatted output string. Examples: >>> format_output((\\"YES\\", [[0, 1, 2], [0, 0, 4], [0, 0, 0]])) \\"YESn0 1 2n0 0 4n0 0 0\\" >>> format_output(\\"NO\\") \\"NO\\" pass from solution import make_strict_upper_triangular, format_output def test_example_1(): matrix = [ [0, 1, 2], [3, 0, 4], [5, 6, 0] ] expected_output = \\"YESn0 1 2n0 0 4n0 0 0\\" assert format_output(make_strict_upper_triangular(matrix)) == expected_output def test_example_2(): matrix = [ [1, 0], [0, 1] ] expected_output = \\"NO\\" assert format_output(make_strict_upper_triangular(matrix)) == expected_output def test_single_element_matrix(): matrix = [[0]] expected_output = \\"YESn0\\" assert format_output(make_strict_upper_triangular(matrix)) == expected_output def test_all_zeros_above_diagonal(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] expected_output = \\"NO\\" assert format_output(make_strict_upper_triangular(matrix)) == expected_output def test_mixed_numbers(): matrix = [ [0, 2, 3], [0, 0, 5], [0, 0, 0] ] expected_output = \\"YESn0 2 3n0 0 5n0 0 0\\" assert format_output(make_strict_upper_triangular(matrix)) == expected_output","solution":"def make_strict_upper_triangular(matrix): n = len(matrix) result = [[0]*n for _ in range(n)] for i in range(n): for j in range(i+1, n): if matrix[i][j] == 0: return \\"NO\\" result[i][j] = matrix[i][j] return \\"YES\\", result def format_output(result): if result == \\"NO\\": return \\"NO\\" else: status, b_matrix = result output = [status] for row in b_matrix: output.append(\\" \\".join(map(str, row))) return \\"n\\".join(output)"},{"question":"from typing import List, Tuple def min_coins_for_change(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determines the minimum number of coins needed to make the exact change for each test case, or returns -1 if it's not possible to make the change with the given denominations. Parameters: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list where each element is a tuple containing the change amount, the number of denominations, and the list of denominations. Returns: List[int]: A list of results where each element is the minimum number of coins needed for the corresponding test case, or -1 if it's impossible to make the change. Examples: >>> min_coins_for_change(3, [([7, 3], [1, 2, 3]), ([11, 4], [2, 5, 7, 10]), ([27, 4], [1, 5, 8, 12])]) [3, 3, 4] >>> min_coins_for_change(1, [([7, 2], [5, 3])]) [-1]","solution":"def min_coins_for_change(T, test_cases): results = [] for i in range(T): C, N = test_cases[i][0] denominations = test_cases[i][1] # Initialize DP array with a large number representing infinity dp = [float('inf')] * (C + 1) dp[0] = 0 # Base case: 0 coins are needed to make change for amount 0 for coin in denominations: for x in range(coin, C + 1): dp[x] = min(dp[x], dp[x - coin] + 1) result = dp[C] if dp[C] != float('inf') else -1 results.append(result) return results"},{"question":"def hiking_trip_time(n: int, readiness: List[int], weights: List[int], m: int, capacities: List[int]) -> int: Determine the minimum time to depart for the hiking trip. >>> hiking_trip_time(4, [10, 5, 8, 6], [200, 300, 150, 400], 3, [500, 200, 400]) 10 >>> hiking_trip_time(4, [10, 15, 8, 20], [500, 200, 300, 400], 4, [500, 500, 500, 500]) 20 >>> hiking_trip_time(4, [10, 5, 8, 6], [200, 300, 150, 400], 2, [200, 400]) -1 >>> hiking_trip_time(4, [10, 8, 6, 5], [100, 100, 100, 100], 4, [100, 100, 100, 100]) 10 >>> hiking_trip_time(4, [12, 8, 20, 10], [250, 250, 250, 250], 4, [250, 250, 250, 250]) 20","solution":"from itertools import permutations def can_distribute(weights, capacities): Check if weights can be distributed among given capacities. n = len(capacities) perm = permutations(weights) for comb in perm: caps_copy = sorted(capacities, reverse=True) possible = True for i in range(len(comb)): found = False for j in range(len(caps_copy)): if caps_copy[j] >= comb[i]: caps_copy[j] -= comb[i] found = True break if not found: possible = False break if possible: return True return False def hiking_trip_time(n, readiness, weights, m, capacities): Determine the minimum time to depart for the hiking trip. max_time = max(readiness) # Check if we can distribute weights in backpacks if can_distribute(weights, capacities): return max_time return -1"},{"question":"def custom_sort(m: int, order: List[int], n: int, arr: List[int]) -> List[int]: Sorts \`arr\` based on the \`order\` specified. Elements in \`arr\` that do not appear in \`order\` are appended at the end in their relative order. :param m: int, size of the order array :param order: list of int, array denoting the order of elements :param n: int, size of the arr array :param arr: list of int, array to be sorted :return: list of int, sorted array based on the custom order pass def test_custom_sort_example(): assert custom_sort(5, [2, 4, 3, 5, 1], 7, [1, 2, 3, 4, 5, 1, 2]) == [2, 2, 4, 3, 5, 1, 1] def test_custom_sort_no_order_elements(): assert custom_sort(3, [3, 2, 1], 4, [4, 4, 4, 4]) == [4, 4, 4, 4] def test_custom_sort_all_elements_same(): assert custom_sort(3, [1, 2, 3], 5, [2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] def test_custom_sort_mixed_elements_with_extras(): assert custom_sort(4, [2, 3, 4, 1], 6, [1, 2, 5, 3, 1, 6]) == [2, 3, 1, 1, 5, 6] def test_custom_sort_empty_arr(): assert custom_sort(3, [2, 1, 3], 0, []) == [] def test_custom_sort_element_not_in_order(): assert custom_sort(4, [4, 2, 3, 1], 5, [5, 4, 3, 2, 6]) == [4, 2, 3, 5, 6]","solution":"def custom_sort(m, order, n, arr): Sorts \`arr\` based on the \`order\` specified. Elements in \`arr\` that do not appear in \`order\` are appended at the end in their relative order. :param m: int, size of the order array :param order: list of int, array denoting the order of elements :param n: int, size of the arr array :param arr: list of int, array to be sorted :return: list of int, sorted array based on the custom order order_map = {val: idx for idx, val in enumerate(order)} # Separate elements that are and are not in the order array in_order = [] not_in_order = [] for num in arr: if num in order_map: in_order.append((order_map[num], num)) else: not_in_order.append(num) # Sort elements that are in the order based on their index in the order array in_order.sort() # Extract the sorted values and combine with the not_in_order list sorted_arr = [num for _, num in in_order] + not_in_order return sorted_arr"},{"question":"def can_fulfill_all_requests(n: int, weight_limits: List[int], m: int, capacities: List[int]) -> str: Determines if all delivery requests can be assigned to the available drones. Parameters: n (int): number of delivery requests weight_limits (list of int): weight limits of the delivery requests m (int): number of drones capacities (list of int): maximum weight capacities of each drone Returns: str: \\"YES\\" if all requests can be fulfilled, otherwise \\"NO\\" Example: >>> can_fulfill_all_requests(3, [200, 500, 1000], 3, [250, 600, 1500]) 'YES' >>> can_fulfill_all_requests(3, [200, 500, 1000], 3, [250, 600, 900]) 'NO' import unittest class TestCanFulfillAllRequests(unittest.TestCase): def test_can_fulfill_all_requests_yes(self): self.assertEqual(can_fulfill_all_requests(3, [200, 500, 1000], 3, [250, 600, 1500]), \\"YES\\") def test_can_fulfill_all_requests_no(self): self.assertEqual(can_fulfill_all_requests(3, [200, 500, 1000], 3, [250, 600, 900]), \\"NO\\") def test_can_fulfill_all_requests_exact_match(self): self.assertEqual(can_fulfill_all_requests(3, [200, 500, 1000], 3, [200, 500, 1000]), \\"YES\\") def test_can_fulfill_all_requests_extra_drones(self): self.assertEqual(can_fulfill_all_requests(3, [200, 500, 1000], 4, [250, 600, 1500, 2000]), \\"YES\\") def test_can_fulfill_all_requests_not_enough_drones(self): self.assertEqual(can_fulfill_all_requests(4, [200, 500, 600, 1000], 3, [250, 600, 1500]), \\"NO\\") def test_can_fulfill_all_requests_one_drone(self): self.assertEqual(can_fulfill_all_requests(1, [200], 1, [250]), \\"YES\\") self.assertEqual(can_fulfill_all_requests(1, [200], 1, [150]), \\"NO\\") def test_can_fulfill_all_requests_multiple_drones(self): self.assertEqual(can_fulfill_all_requests(2, [100, 200], 2, [100, 200]), \\"YES\\") self.assertEqual(can_fulfill_all_requests(2, [200, 300], 2, [100, 250]), \\"NO\\")","solution":"def can_fulfill_all_requests(n, weight_limits, m, capacities): Determines if all delivery requests can be assigned to the available drones. Parameters: n (int): number of delivery requests weight_limits (list of int): weight limits of the delivery requests m (int): number of drones capacities (list of int): maximum weight capacities of each drone Returns: str: \\"YES\\" if all requests can be fulfilled, otherwise \\"NO\\" # Sort the weight limits in ascending order weight_limits.sort() # Sort the drone capacities in ascending order capacities.sort() i = 0 # Index for weight_limits j = 0 # Index for capacities # Process each delivery request while i < n and j < m: if weight_limits[i] <= capacities[j]: i += 1 # Assign this delivery request to current drone j += 1 # Move to the next drone if i == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def matrix_beautiful(n: int, matrix: List[List[int]]) -> str: Determine whether the given square matrix is beautiful. A matrix is beautiful if all rows and all columns are palindromes. Args: n (int): The size of the matrix. matrix (List[List[int]]): A square matrix of integers. Returns: str: \\"YES\\" if the matrix is beautiful, \\"NO\\" otherwise. >>> matrix_beautiful(3, [[1, 2, 1], [2, 3, 2], [1, 2, 1]]) 'YES' >>> matrix_beautiful(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'NO'","solution":"def is_palindrome(seq): return seq == seq[::-1] def is_beautiful(m): n = len(m) for i in range(n): if not is_palindrome(m[i]): return \\"NO\\" for j in range(n): col = [m[i][j] for i in range(n)] if not is_palindrome(col): return \\"NO\\" return \\"YES\\" def matrix_beautiful(n, matrix): return is_beautiful(matrix)"},{"question":"def unique_paths_with_obstacles(grid: List[List[str]]) -> int: Returns the total number of unique paths from the top-left to the bottom-right corner of the grid. >>> unique_paths_with_obstacles([['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 6 >>> unique_paths_with_obstacles([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> unique_paths_with_obstacles([['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0 >>> unique_paths_with_obstacles([['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#']]) 0 >>> unique_paths_with_obstacles([['.']]) 1 >>> unique_paths_with_obstacles([['.', '#', '.'], ['#', '#', '.'], ['.', '#', '.']]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the total number of unique paths from the top-left to the bottom-right corner of the grid. n = len(grid) if grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] # Reading input def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) grid = [] for i in range(n): grid.append(list(data[i+1])) return grid if __name__ == \\"__main__\\": grid = read_input() print(unique_paths_with_obstacles(grid))"},{"question":"def max_flowers_in_k_pots(n: int, k: int, pots: List[int]) -> int: Given the number of pots (n), the number of consecutive pots to pick (k), and a list of integers representing the flowers in each pot, returns the maximum number of flowers in any k consecutive pots. >>> max_flowers_in_k_pots(5, 2, [1, 3, 1, 2, 5]) 7 >>> max_flowers_in_k_pots(7, 3, [2, 4, 1, 9, 3, 7, 6]) 19 >>> max_flowers_in_k_pots(1, 1, [10]) 10","solution":"def max_flowers_in_k_pots(n, k, pots): Given the number of pots (n), the number of consecutive pots to pick (k), and a list of integers representing the flowers in each pot, returns the maximum number of flowers in any k consecutive pots. # Initialize the maximum flowers to be the sum of the first k pots max_flowers = sum(pots[:k]) current_sum = max_flowers # Use sliding window approach to find the maximum sum of k consecutive pots for i in range(k, n): current_sum += pots[i] - pots[i - k] if current_sum > max_flowers: max_flowers = current_sum return max_flowers"},{"question":"def total_traffic_harmony(n: int, m: int, streets: List[Tuple[int, int, int]]) -> int: Computes the total Traffic Harmony for the entire city given the street information. :param n: Number of intersections. :param m: Number of streets. :param streets: List of (u, v, w) tuples where u and v are intersections and w is the traffic load. :return: Total traffic harmony for all intersections. >>> total_traffic_harmony(4, 5, [(1, 2, 10), (1, 3, 20), (1, 4, 30), (2, 3, 5), (3, 4, 15)]) 55 >>> total_traffic_harmony(4, 0, []) 0 >>> total_traffic_harmony(2, 1, [(1, 2, 10)]) 0 >>> total_traffic_harmony(3, 2, [(1, 2, 10), (2, 3, 15)]) 5 >>> total_traffic_harmony(5, 4, [(1, 2, 10), (1, 3, 20), (1, 4, 30), (1, 5, 40)]) 30 >>> total_traffic_harmony(3, 3, [(1, 2, 10), (2, 3, 10), (1, 3, 10)]) 0 >>> total_traffic_harmony(4, 2, [(1, 2, 5), (3, 4, 10)]) 0","solution":"def total_traffic_harmony(n, m, streets): Computes the total Traffic Harmony for the entire city given the street information. :param n: Number of intersections. :param m: Number of streets. :param streets: List of (u, v, w) tuples where u and v are intersections and w is the traffic load. :return: Total traffic harmony for all intersections. from collections import defaultdict # Initialize a dictionary to store traffic loads for each intersection intersection_loads = defaultdict(list) # Populate the intersection loads with the traffic data for u, v, w in streets: intersection_loads[u].append(w) intersection_loads[v].append(w) # Calculate total traffic harmony total_harmony = 0 for key, loads in intersection_loads.items(): if len(loads) > 1: # Only calculate if more than one street is connected max_load = max(loads) min_load = min(loads) harmony = max_load - min_load total_harmony += harmony return total_harmony"},{"question":"from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns the maximum values in each sliding window of size k in the given array. Args: nums: List of integers, the array of numbers. k: Integer, size of the sliding window. Returns: List of integers, maximum values in each sliding window. Examples: >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1, 3, 1, 2, 0, 5], 3) [3, 3, 2, 5] pass # Unit tests def test_max_sliding_window_basic(): assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] assert max_sliding_window([1, 3, 1, 2, 0, 5], 3) == [3, 3, 2, 5] def test_max_sliding_window_single_element_window(): assert max_sliding_window([1, 2, 3, 4, 5], 1) == [1, 2, 3, 4, 5] def test_max_sliding_window_whole_array_window(): assert max_sliding_window([1, 2, 3, 4, 5], 5) == [5] def test_max_sliding_window_single_element_array(): assert max_sliding_window([10], 1) == [10] def test_max_sliding_window_all_same_element(): assert max_sliding_window([5, 5, 5, 5, 5], 3) == [5, 5, 5] assert max_sliding_window([5, 5, 5], 1) == [5, 5, 5] assert max_sliding_window([5, 5, 5], 3) == [5] def test_max_sliding_window_negative_elements(): assert max_sliding_window([-1, -3, -5, -2, -1, -3], 2) == [-1, -3, -2, -1, -1] assert max_sliding_window([-1, -3, -5, -2, -1, -3], 3) == [-1, -2, -1, -1]","solution":"from collections import deque def max_sliding_window(nums, k): Returns the maximum values in each sliding window of size k in the given array. Args: nums: List of integers, the array of numbers. k: Integer, size of the sliding window. Returns: List of integers, maximum values in each sliding window. n = len(nums) if n == 0 or k == 0: return [] if k == 1: return nums q = deque() result = [] for i in range(n): # Remove indices that are out of the current window while q and q[0] < i - k + 1: q.popleft() # Remove indices whose corresponding values are less than nums[i] while q and nums[q[-1]] < nums[i]: q.pop() q.append(i) # Starting from i = k - 1, we can add to the result list if i >= k - 1: result.append(nums[q[0]]) return result # Example code to run the function n = 8 nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 print(max_sliding_window(nums, k)) # Output should be [3, 3, 5, 5, 6, 7]"},{"question":"def merge_inventory_data(n: int, system_data: List[str]) -> List[str]: Merge inventory data from multiple systems into a unified format. Args: n (int): Number of systems. system_data (List[str]): List of strings containing inventory data from each system. Returns: List[str]: Merged inventory data in the unified format sorted by Product IDs. Example: >>> merge_inventory_data(2, [\\"1nA1, Apple, 50, 1.20nA2, Banana, 30, 0.50\\", \\"2nA1, Apple, 30, 1.10nA3, Cherry, 20, 2.50\\"]) ['A1, Apple, 80, 1.20', 'A2, Banana, 30, 0.50', 'A3, Cherry, 20, 2.50'] def test_merge_simple_case(): n = 2 system_data = [ \\"1nA1, Apple, 50, 1.20nA2, Banana, 30, 0.50\\", \\"2nA1, Apple, 30, 1.10nA3, Cherry, 20, 2.50\\" ] expected_output = [ \\"A1, Apple, 80, 1.20\\", \\"A2, Banana, 30, 0.50\\", \\"A3, Cherry, 20, 2.50\\" ] assert merge_inventory_data(n, system_data) == expected_output def test_merge_single_system(): n = 1 system_data = [ \\"1nB1, Blueberry, 40, 1.00nB2, Blackberry, 15, 0.75\\" ] expected_output = [ \\"B1, Blueberry, 40, 1.00\\", \\"B2, Blackberry, 15, 0.75\\" ] assert merge_inventory_data(n, system_data) == expected_output def test_merge_with_different_quantities(): n = 2 system_data = [ \\"1nC1, Carrot, 75, 0.45\\", \\"2nC1, Carrot, 100, 0.50\\" ] expected_output = [ \\"C1, Carrot, 175, 0.50\\" ] assert merge_inventory_data(n, system_data) == expected_output def test_merge_with_same_highest_quantity(): n = 2 system_data = [ \\"1nD1, Date, 50, 1.80\\", \\"2nD1, Date, 50, 1.75\\" ] expected_output = [ \\"D1, Date, 100, 1.75\\" ] assert merge_inventory_data(n, system_data) == expected_output def test_merge_with_different_products(): n = 3 system_data = [ \\"1nE1, Eggplant, 20, 1.10\\", \\"2nE2, Endive, 15, 2.20\\", \\"3nE1, Eggplant, 30, 1.00\\" ] expected_output = [ \\"E1, Eggplant, 50, 1.00\\", \\"E2, Endive, 15, 2.20\\" ] assert merge_inventory_data(n, system_data) == expected_output","solution":"def merge_inventory_data(n, system_data): inventory = {} for sys_data in system_data: sys_lines = sys_data.split('n') system_id = sys_lines[0] # First line is the system ID, we can skip using it product_lines = sys_lines[1:] for line in product_lines: product_id, product_name, quantity, price = line.split(', ') quantity = int(quantity) price = float(price) if product_id not in inventory: inventory[product_id] = { 'product_name': product_name, 'total_quantity': quantity, 'price_per_unit': price } else: product_info = inventory[product_id] product_info['total_quantity'] += quantity # Update the price per unit based on the highest quantity if product_info['total_quantity'] == quantity: product_info['price_per_unit'] = price else: if quantity > (product_info['total_quantity'] - quantity) or ( quantity == (product_info['total_quantity'] - quantity) and price < product_info['price_per_unit'] ): product_info['price_per_unit'] = price # Sort the inventory by Product ID sorted_inventory = sorted(inventory.items(), key=lambda x: x[0]) result = [] for product_id, details in sorted_inventory: result.append(f\\"{product_id}, {details['product_name']}, {details['total_quantity']}, {details['price_per_unit']:.2f}\\") return result"},{"question":"from typing import List def maxTreesCut(n: int, heights: List[int]) -> int: Determines the maximum number of trees that can be cut down to make the remaining heights form a strictly increasing sequence. Parameters: n (int): The number of trees. heights (List[int]): The heights of the trees. Returns: int: The maximum number of trees that can be cut down. def test_single_tree(): assert maxTreesCut(1, [10]) == 0 def test_strictly_increasing(): assert maxTreesCut(5, [1, 2, 3, 4, 5]) == 0 def test_strictly_decreasing(): assert maxTreesCut(5, [5, 4, 3, 2, 1]) == 4 def test_mixed_heights(): assert maxTreesCut(5, [3, 2, 6, 4, 5]) == 2 def test_random_heights(): assert maxTreesCut(7, [5, 1, 6, 3, 7, 2, 4]) == 4 def test_large_input(): assert maxTreesCut(10, [10, 22, 9, 33, 21, 50, 41, 60, 80]) == 4","solution":"from typing import List import bisect def maxTreesCut(n: int, heights: List[int]) -> int: Determines the maximum number of trees that can be cut down to make the remaining heights form a strictly increasing sequence. Parameters: n (int): The number of trees. heights (List[int]): The heights of the trees. Returns: int: The maximum number of trees that can be cut down. # Array to store the longest increasing subsequence lis = [] for height in heights: pos = bisect.bisect_left(lis, height) if pos < len(lis): lis[pos] = height else: lis.append(height) # The maximum number of trees that can be cut down is \`n - len(lis)\` return n - len(lis)"},{"question":"def are_anagrams(s: str, t: str) -> bool: Determines if two strings s and t are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") == True >>> are_anagrams(\\"hello\\", \\"billion\\") == False","solution":"def are_anagrams(s: str, t: str) -> bool: Determines if two strings s and t are anagrams of each other. # Anagrams must be the same length if len(s) != len(t): return False # Count the occurrences of each character in s and t from collections import Counter return Counter(s) == Counter(t)"},{"question":"def findMaxGap(n, timestamps): Returns the maximum time difference between any two consecutive packets after sorting the timestamps. :param n: int - the number of timestamps :param timestamps: List[int] - a list of n non-negative integers representing the arrival times :return: int - the maximum time difference between two consecutive packets >>> findMaxGap(5, [2, 5, 1, 8, 3]) == 3 >>> findMaxGap(5, [1, 2, 3, 5, 8]) == 3 >>> findMaxGap(3, [2, 2, 2]) == 0 >>> findMaxGap(5, [100000, 100005, 100002, 100008, 100003]) == 3 >>> findMaxGap(2, [10, 20]) == 10 pass","solution":"def findMaxGap(n, timestamps): Returns the maximum time difference between any two consecutive packets after sorting the timestamps. :param n: int - the number of timestamps :param timestamps: List[int] - a list of n non-negative integers representing the arrival times :return: int - the maximum time difference between two consecutive packets if n < 2: return 0 timestamps.sort() max_gap = 0 for i in range(1, n): max_gap = max(max_gap, timestamps[i] - timestamps[i - 1]) return max_gap"},{"question":"def minimum_total_time(n: int, intervals: List[Tuple[int, int, int, int, int, int]]) -> int: Returns the minimum total time required to complete all operations with non-overlapping time intervals. Parameters: n (int): Number of cranes. intervals (list of tuples): Each tuple contains (xi1, yi1, xi2, yi2, ti1, ti2) which describe the working area and initial time interval of each crane. Returns: int: Minimum total time to complete all operations. Examples: >>> minimum_total_time(3, [(1, 1, 3, 3, 1, 4), (2, 2, 4, 4, 2, 5), (0, 0, 2, 2, 3, 6)]) 9 >>> minimum_total_time(1, [(0, 0, 1, 1, 1, 2)]) 1 >>> minimum_total_time(3, [(0, 0, 1, 1, 1, 2), (1, 1, 2, 2, 2, 4), (2, 2, 3, 3, 4, 6)]) 5 >>> minimum_total_time(3, [(0, 0, 1, 1, 1, 3), (1, 1, 2, 2, 1, 3), (2, 2, 3, 3, 1, 3)]) 6 >>> minimum_total_time(2, [(0, 0, 4, 4, 1, 100000), (4, 4, 8, 8, 100000, 200000)]) 199999","solution":"def minimum_total_time(n, intervals): Returns the minimum total time required to complete all operations with non-overlapping time intervals. Parameters: n (int): Number of cranes. intervals (list of tuples): Each tuple contains (xi1, yi1, xi2, yi2, ti1, ti2) which describe the working area and initial time interval of each crane. Returns: int: Minimum total time to complete all operations. intervals.sort(key=lambda x: x[4]) # Sort by start time ti1 current_end_time = 0 total_time = 0 for interval in intervals: _, _, _, _, start_time, end_time = interval duration = end_time - start_time total_time += duration current_end_time += duration return total_time"},{"question":"def longest_substring_with_k_distinct_characters(s: str, x: int) -> int: Returns the length of the longest substring with at most x distinct characters. >>> longest_substring_with_k_distinct_characters(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_characters(\\"abcabcbb\\", 2) 3 pass","solution":"def longest_substring_with_k_distinct_characters(s, x): Returns the length of the longest substring with at most x distinct characters. from collections import defaultdict n = len(s) if n == 0 or x == 0: return 0 left = 0 right = 0 char_count = defaultdict(int) max_length = 0 while right < n: char_count[s[right]] += 1 while len(char_count) > x: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def longest_ski_path(grid): Determine the length of the longest ski path that can be taken starting from any cell. >>> longest_ski_path([[9, 6, 3, 2], [5, 3, 2, 1], [8, 7, 4, 0], [6, 5, 2, 3]]) -> 6 >>> longest_ski_path([[1]]) -> 1 >>> longest_ski_path([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) -> 1 >>> longest_ski_path([[10, 9, 8, 7], [9, 8, 7, 6], [8, 7, 6, 5], [7, 6, 5, 4]]) -> 7 >>> longest_ski_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) -> 1 >>> longest_ski_path([[1, 2, 6, 3], [2, 3, 5, 4], [3, 4, 4, 5], [4, 5, 3, 6]]) -> 5","solution":"def longest_ski_path(grid): if not grid: return 0 M, N = len(grid), len(grid[0]) dp = [[-1 for _ in range(N)] for _ in range(M)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < M and 0 <= nc < N and grid[nr][nc] < grid[r][c]: max_length = max(max_length, 1 + dfs(nr, nc)) dp[r][c] = max_length return dp[r][c] longest_path = 0 for i in range(M): for j in range(N): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"def find_unsorted_subarray(arr): Finds the smallest subarray that needs to be sorted. Parameters: arr (List[int]): The input array of integers. Returns: tuple: A tuple containing the starting and ending indices (1-based) of the subarray, or -1 if the array is already sorted. >>> find_unsorted_subarray([1, 2, 3, 4, 5]) -1 >>> find_unsorted_subarray([5, 4, 3, 2, 1]) (1, 5) >>> find_unsorted_subarray([1, 2, 6, 5, 8]) (3, 4) >>> find_unsorted_subarray([1]) -1 >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) (2, 6) >>> find_unsorted_subarray([9, 7, 8, 10, 11]) (1, 3)","solution":"def find_unsorted_subarray(arr): Finds the smallest subarray that needs to be sorted. Parameters: arr (List[int]): The input array of integers. Returns: tuple: A tuple containing the starting and ending indices (1-based) of the subarray, or -1 if the array is already sorted. n = len(arr) start, end = 0, -1 max_seen, min_seen = -float('inf'), float('inf') for i in range(n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i if end == -1: return -1 else: return (start + 1, end + 1)"},{"question":"def minimum_commands(n: int, start: int, target: int) -> int: Returns the minimum number of commands required to move Mikey from the starting floor to the target floor in a building with n floors. Parameters: - n: Number of floors in the building. - start: Starting floor (0 ≤ start < n). - target: Target floor (0 ≤ target < n). Returns: - int: Minimum number of commands required. >>> minimum_commands(10, 3, 7) 4 >>> minimum_commands(10, 3, 3) 0 >>> minimum_commands(1000000, 0, 999999) 999999 >>> minimum_commands(10, 0, 1) 1 >>> minimum_commands(10, 1, 0) 1 >>> minimum_commands(1, 0, 0) 0 >>> minimum_commands(5, 4, 1) 3","solution":"def minimum_commands(n, start, target): Returns the minimum number of commands required to move Mikey from the starting floor to the target floor in a building with n floors. Parameters: - n: Number of floors in the building. - start: Starting floor (0 ≤ start < n). - target: Target floor (0 ≤ target < n). Returns: - int: Minimum number of commands required. return abs(target - start)"},{"question":"def lis_length(arr: List[int]) -> int: Given an array of integers, find the longest increasing subsequence (LIS). A subsequence is derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one where each element is larger than the previous one. >>> lis_length([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> lis_length([1, 2, 3, 4, 5]) 5 >>> lis_length([5, 4, 3, 2, 1]) 1 >>> lis_length([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> lis_length([10]) 1 >>> lis_length([]) 0 >>> lis_length([1, 2, 2, 3, 3, 4]) 4 pass","solution":"def lis_length(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def get_max_guests_seated(n: int, m: int, grid: List[str]) -> int: Returns the maximum number of guests that can be seated on chairs with access to a table. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): The seating arrangement. Returns: int: The maximum number of guests that can be seated. Example: >>> get_max_guests_seated(4, 4, [\\"ECTE\\", \\"EECE\\", \\"CTCE\\", \\"EETE\\"]) 4 >>> get_max_guests_seated(3, 3, [\\"EEE\\", \\"EEE\\", \\"EEE\\"]) 0 >>> get_max_guests_seated(3, 3, [\\"CCC\\", \\"CCC\\", \\"CCC\\"]) 0 >>> get_max_guests_seated(3, 3, [\\"CCC\\", \\"CTC\\", \\"CCC\\"]) 8 >>> get_max_guests_seated(5, 5, [\\"ECCCC\\", \\"ETTCB\\", \\"CTCET\\", \\"ECCCC\\", \\"EEEET\\"]) 10","solution":"def get_max_guests_seated(n, m, grid): Returns the maximum number of guests that can be seated on chairs with access to a table. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of str): The seating arrangement. Returns: int: The maximum number of guests that can be seated. def is_accessible_to_table(x, y): Checks if a chair at the position (x, y) is accessible to a table. directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'T': return True return False count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'C' and is_accessible_to_table(i, j): count += 1 return count"},{"question":"def reconstruct_stones(n: int, stones: List[int]) -> List[int]: Reconstructs the original sequence of stones by filling missing values with zeros. :param n: int, number of stones (including the missing ones) :param stones: List of int, shuffled stone values with missing values represented by -1 :return: List of int, reconstructed sequence of stones with missing values filled as zeros >>> reconstruct_stones(5, [4, -1, -1, 1, 3]) [1, 2, 3, 4, 0] >>> reconstruct_stones(7, [3, -1, 1, -1, -1, 2, 7]) [1, 2, 3, 4, 5, 6, 7]","solution":"def reconstruct_stones(n, stones): Reconstructs the original sequence of stones by filling missing values with zeros. :param n: int, number of stones (including the missing ones) :param stones: list of int, shuffled stone values with missing values represented by -1 :return: list of int, reconstructed sequence of stones with missing values filled as zeros stones = sorted([stone for stone in stones if stone != -1]) min_value = stones[0] max_value = stones[-1] complete_sequence = [0] * n for i in range(n): if min_value + i <= max_value: complete_sequence[i] = min_value + i return complete_sequence"},{"question":"class DocumentManager: def __init__(self, documents: List[str]): Initialize the Document Manager with a list of documents pass def add_document(self, document: str): Add a document to the collection pass def remove_document(self, document: str): Remove a document from the collection pass def check_document(self, document: str) -> bool: Check if a document is 'sorted text'. >>> DocumentManager([\\"abc\\"]).check_document(\\"abc\\") True >>> DocumentManager([\\"abc\\", \\"bcd\\"]).check_document(\\"bcd\\") True >>> DocumentManager([\\"abc\\", \\"bcd\\"]).check_document(\\"cba\\") False pass def process_commands(n: int, docs: List[str], commands: List[str]) -> List[str]: Process a list of commands for the Document Manager. >>> initial_docs = [\\"hello\\", \\"world\\", \\"abc\\"] >>> commands = [\\"ADD zzz\\", \\"CHECK zzz\\", \\"REMOVE world\\", \\"CHECK world\\", \\"CHECK abc\\", \\"ADD ddd\\", \\"CHECK ddd\\"] >>> process_commands(3, initial_docs, commands) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> initial_docs = [\\"abc\\", \\"bac\\"] >>> commands = [\\"CHECK bac\\"] >>> process_commands(2, initial_docs, commands) [\\"NO\\"] pass","solution":"class DocumentManager: def __init__(self, documents): self.documents = set(documents) def add_document(self, document): self.documents.add(document) def remove_document(self, document): if document in self.documents: self.documents.remove(document) def check_document(self, document): if document in self.documents: return all(document[i] <= document[i+1] for i in range(len(document)-1)) return False def process_commands(n, docs, commands): manager = DocumentManager(docs) results = [] for command in commands: cmd_type, *arg = command.split() if cmd_type == \\"ADD\\": manager.add_document(arg[0]) elif cmd_type == \\"REMOVE\\": manager.remove_document(arg[0]) elif cmd_type == \\"CHECK\\": is_sorted = manager.check_document(arg[0]) results.append(\\"YES\\" if is_sorted else \\"NO\\") return results"},{"question":"def find_min_energy(n, m, routes): Find the minimum total energy required to visit all the planets exactly once and return to the starting planet. >>> find_min_energy(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> find_min_energy(3, 3, [(1, 2, 10), (2, 3, 15), (1, 3, 20)]) 45 >>> find_min_energy(3, 2, [(1, 2, 10), (2, 3, 15)]) -1 >>> find_min_energy(4, 6, [(1, 2, 10), (1, 3, 10), (1, 4, 10), (2, 3, 10), (2, 4, 10), (3, 4, 10)]) 40 >>> find_min_energy(5, 10, [(1, 2, 10), (1, 3, 10), (1, 4, 10), (1, 5, 10), (2, 3, 10), (2, 4, 10), (2, 5, 10), (3, 4, 10), (3, 5, 10), (4, 5, 10)]) 50","solution":"import itertools def find_min_energy(n, m, routes): import sys from itertools import permutations def tsp(graph, s): vertex = [] for i in range(n): if i != s: vertex.append(i) min_path = sys.maxsize next_permutation=permutations(vertex) for i in next_permutation: current_pathweight = 0 k = s for j in i: current_pathweight += graph[k][j] k = j current_pathweight += graph[k][s] min_path = min(min_path, current_pathweight) return min_path adj_matrix = [[sys.maxsize] * n for _ in range(n)] for u, v, w in routes: adj_matrix[u-1][v-1] = w adj_matrix[v-1][u-1] = w min_energy = sys.maxsize for i in range(n): cycle_energy = tsp(adj_matrix, i) if cycle_energy < min_energy: min_energy = cycle_energy if min_energy >= sys.maxsize: return -1 else: return min_energy # Example usage n = 4 m = 6 routes = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] print(find_min_energy(n, m, routes)) # Should output the minimum energy required to visit all planets and return to the start"},{"question":"def subset_sum(nums: List[int], t: int) -> Union[List[int], str]: Determine if there exists a subset of nums such that the sum of the elements is equal to t. If such a subset exists, return the subset; otherwise, return \\"No solution\\". >>> subset_sum([2, 4, 6, 8, 10], 10) in [[2, 8], [4, 6], [10]] True >>> subset_sum([1, 2, 3, 4], 15) 'No solution' pass def parse_and_run(): Parse input from stdin and run subset_sum to produce output import sys input = sys.stdin.read data = input().split() n, t = int(data[0]), int(data[1]) nums = list(map(int, data[2:2+n])) solution = subset_sum(nums, t) if solution == \\"No solution\\": print(solution) else: print(\\" \\".join(map(str, solution)))","solution":"def subset_sum(nums, t): Determine if there exists a subset of nums that sums to t. If such a subset exists, return it as a list. Otherwise, return \\"No solution\\". n = len(nums) dp = {0: []} # Initial state with zero sum having an empty subset for num in nums: current_dp = list(dp.items()) for current_sum, subset in current_dp: new_sum = current_sum + num if new_sum == t: return subset + [num] if new_sum not in dp: dp[new_sum] = subset + [num] return \\"No solution\\" # Function to parse input received in the specified format def parse_and_run(): import sys input = sys.stdin.read data = input().split() n, t = int(data[0]), int(data[1]) nums = list(map(int, data[2:2+n])) solution = subset_sum(nums, t) if solution == \\"No solution\\": print(solution) else: print(\\" \\".join(map(str, solution)))"},{"question":"def max_donations(donors: List[Tuple[int, int, int]]) -> int: Determine the maximum total donation Gaurav can collect if he can't contact more than one donor at the same time. >>> max_donations([(1, 3, 50), (3, 5, 20), (2, 5, 100), (3, 4, 200), (1, 5, 50)]) 250 >>> max_donations([(1, 2, 50), (3, 4, 100), (5, 6, 200)]) 350 >>> max_donations([(1, 5, 50), (1, 5, 100), (1, 5, 200)]) 200 >>> max_donations([(1, 3, 50), (2, 5, 50), (4, 7, 100), (6, 8, 150)]) 200 >>> max_donations([(1, 2, 100)]) 100 # Your implementation here","solution":"def max_donations(donors): donors.sort(key=lambda x: x[1]) # Sort by end time # Initialize a dp array where each slot represents max donation up to this donor dp = [0] * len(donors) dp[0] = donors[0][2] # The donation amount for the first donor for i in range(1, len(donors)): include_donation = donors[i][2] # Donation including the current donor # Find the last non-conflicting donor for j in range(i - 1, -1, -1): if donors[j][1] <= donors[i][0]: include_donation += dp[j] break dp[i] = max(dp[i - 1], include_donation) return dp[-1]"},{"question":"from typing import List, Tuple def max_product_in_range(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, finds the maximum product of any two distinct elements within the specified range. Parameters: arr (List[int]): The array of integers. queries (List[Tuple[int, int]]): The list of queries where each query is a tuple (L, R). Returns: List[int]: The maximum product for each query. >>> max_product_in_range([3, 2, 1, 5, 4], [(1, 3), (2, 5), (1, 5)]) [6, 20, 20] >>> max_product_in_range([3, 2, 1, 5, 4], [(1, 1), (3, 3)]) [0, 0]","solution":"def max_product_in_range(arr, queries): For each query, finds the maximum product of any two distinct elements within the specified range. Parameters: arr (list of int): The array of integers. queries (list of tuple): The list of queries where each query is a tuple (L, R). Returns: list of int: The maximum product for each query. results = [] for L, R in queries: subrange = arr[L-1:R] if len(subrange) < 2: results.append(0) continue # Find the top two maximum numbers in the subrange first, second = 0, 0 for num in subrange: if num > first: second = first first = num elif num > second: second = num results.append(first * second) return results"},{"question":"def find_largest_square(n: int, m: int, grid: List[str]) -> int: Find the maximum size of a square sub-grid that contains only the same type of rune. >>> find_largest_square(5, 6, [ ... \\"AAAAAA\\", ... \\"ABBBAA\\", ... \\"ABBBBA\\", ... \\"ABBBBA\\", ... \\"AAAAAA\\" ... ]) 3 >>> find_largest_square(4, 4, [ ... \\"AAAA\\", ... \\"AAAA\\", ... \\"AAAA\\", ... \\"AAAA\\" ... ]) 4 >>> find_largest_square(4, 5, [ ... \\"ABCDE\\", ... \\"BCDEA\\", ... \\"CDEAB\\", ... \\"DEABC\\" ... ]) 1 >>> find_largest_square(4, 4, [ ... \\"AAAA\\", ... \\"ABAA\\", ... \\"ABAA\\", ... \\"AAAA\\" ... ]) 2 >>> find_largest_square(4, 1, [ ... \\"A\\", ... \\"A\\", ... \\"A\\", ... \\"A\\" ... ]) 1","solution":"def find_largest_square(n, m, grid): # Create a DP table to store the size of the largest square sub-grid ending at (i, j) dp = [[0] * m for _ in range(n)] max_square_size = 0 for i in range(n): for j in range(m): # For cells in the first row or first column if i == 0 or j == 0: dp[i][j] = 1 elif grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 # Update the maximum size found so far max_square_size = max(max_square_size, dp[i][j]) return max_square_size"},{"question":"def min_odd_subarrays(n: int, arr: List[int]) -> int: Returns the minimum number of contiguous subarrays needed such that the sum of elements in each subarray is odd. If it's not possible, returns -1. >>> min_odd_subarrays(6, [1, 2, 3, 4, 5, 6]) 3 >>> min_odd_subarrays(4, [2, 4, 6, 8]) -1","solution":"def min_odd_subarrays(n, arr): Returns the minimum number of contiguous subarrays needed such that the sum of elements in each subarray is odd. If it's not possible, returns -1. # Check if it's possible to obtain an odd sum subarray has_odd = any(x % 2 != 0 for x in arr) if not has_odd: return -1 subarrays = 0 current_sum = 0 for num in arr: current_sum += num if current_sum % 2 != 0: subarrays += 1 current_sum = 0 return subarrays"},{"question":"from typing import List, Tuple def tsp(n: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum cost to visit all vertices exactly once and return to the starting vertex in a complete graph with edges' weights either 1 or 2. :param n: Number of vertices in the graph :param edges: List of edges where each edge is represented as a tuple (u, v, w) with vertices u, v and weight w :return: Minimum cost to complete the tour, or -1 if it is not possible # Your implementation here def solve_tsp(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Solves the TSP for multiple test cases. :param test_cases: List of test cases, with each test case represented by a tuple (n, m, edges) :return: List of results, one for each test case # Your implementation here def test_example(): test_cases = [ (4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 2), (4, 1, 1), (1, 3, 2)]), (3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 1)]) ] expected_results = [6, 4] assert solve_tsp(test_cases) == expected_results def test_minimum_values(): test_cases = [ (2, 1, [(1, 2, 1)]), (2, 1, [(1, 2, 2)]), ] expected_results = [2, 4] assert solve_tsp(test_cases) == expected_results def test_disconnected_graph(): test_cases = [ (3, 2, [(1, 2, 1), (2, 3, 2)]), ] expected_results = [-1] assert solve_tsp(test_cases) == expected_results def test_larger_graph(): test_cases = [ (4, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (1, 3, 2), (2, 4, 2)]), ] expected_results = [4] assert solve_tsp(test_cases) == expected_results def test_all_edges_weight_2(): test_cases = [ (4, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 1, 2), (1, 3, 2), (2, 4, 2)]), ] expected_results = [8] assert solve_tsp(test_cases) == expected_results","solution":"import itertools def tsp(n, edges): # Initialize adjacency matrix with large values inf = float('inf') dist = [[inf] * n for _ in range(n)] # Fill the adjacency matrix with given edges for u, v, w in edges: dist[u-1][v-1] = w dist[v-1][u-1] = w # Use dynamic programming to find the shortest Hamiltonian cycle # dp[mask][i] will store the minimum cost to visit the subset represented by mask, ending at node i dp = [[inf] * n for _ in range(1 << n)] dp[1][0] = 0 # Starting point for mask in range(1 << n): for i in range(n): if mask & (1 << i): for j in range(n): if mask & (1 << j) == 0: new_mask = mask | (1 << j) dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + dist[i][j]) # The answer will be the minimum cost to visit all nodes, ending at the start node (0) result = inf for i in range(1, n): result = min(result, dp[(1 << n) - 1][i] + dist[i][0]) return result if result != inf else -1 def solve_tsp(test_cases): results = [] for n, m, edges in test_cases: result = tsp(n, edges) results.append(result) return results"},{"question":"def generate_binary_sequence(n: int) -> list: Construct a sequence of n binary strings that are strictly increasing and lexicographically larger than their preceding number. Returns the sequence if possible, otherwise returns -1 if it's not possible to construct such a sequence. >>> generate_binary_sequence(1) ['1'] >>> generate_binary_sequence(5) ['1', '10', '11', '100', '101'] >>> generate_binary_sequence(51) -1","solution":"def generate_binary_sequence(n): if n > 50: return -1 sequence = [] for i in range(n): sequence.append(bin(i + 1)[2:]) return sequence"},{"question":"def max_reward(n: int, rewards: List[int]) -> int: Determine the maximum reward Simon can collect sailing through checkpoints in sequential order. Due to the river's current, collecting a reward means skipping the next checkpoint's reward. Args: n (int): The number of checkpoints. rewards (List[int]): The rewards at each checkpoint. Returns: int: The maximum reward Simon can collect. Examples: >>> max_reward(4, [10, 15, 10, 20]) 35 >>> max_reward(5, [1, 2, 3, 1, 5]) 9","solution":"def max_reward(n, rewards): if n == 0: return 0 if n == 1: return rewards[0] if n == 2: return max(rewards[0], rewards[1]) dp = [0] * n dp[0] = rewards[0] dp[1] = max(rewards[0], rewards[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + rewards[i]) return dp[-1]"},{"question":"def min_operations_to_make_arrays_identical(n: int, a: List[int], b: List[int]) -> int: Returns the minimum number of operations required to make arrays a and b identical. Parameters: n (int): The length of the arrays. a (list of int): The first array. b (list of int): The second array. Returns: int: The minimum number of operations to make arrays a and b identical. >>> min_operations_to_make_arrays_identical(3, [1, 2, 3], [2, 3, 4]) 3 >>> min_operations_to_make_arrays_identical(3, [1, 1, 1], [1, 1, 1]) 0 >>> min_operations_to_make_arrays_identical(3, [1, 2, 3], [3, 4, 5]) 6 >>> min_operations_to_make_arrays_identical(3, [4, 5, 6], [1, 1, 1]) 0 >>> min_operations_to_make_arrays_identical(4, [1, 5, 2, 4], [2, 3, 5, 3]) 4 >>> min_operations_to_make_arrays_identical(100000, [1] * 100000, [100000] * 100000) 9999900000","solution":"def min_operations_to_make_arrays_identical(n, a, b): Returns the minimum number of operations required to make arrays a and b identical. Parameters: n (int): The length of the arrays. a (list of int): The first array. b (list of int): The second array. Returns: int: The minimum number of operations to make arrays a and b identical. operations = 0 for i in range(n): operations += max(0, b[i] - a[i]) return operations"},{"question":"from typing import List, Tuple def encode_tree(n: int, edges: List[Tuple[int, int]]) -> str: Encode a tree with n nodes and given edges into a unique string format. >>> encode_tree(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) \\"(1(2(4)(5))(3))\\" >>> encode_tree(4, [(1, 2), (2, 3), (3, 4)]) \\"(1(2(3(4))))\\" >>> encode_tree(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) \\"(1(2)(3)(4)(5))\\" >>> encode_tree(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) \\"(1(2(4)(5))(3(6)(7)))\\" >>> encode_tree(6, [(1, 2), (1, 3), (2, 4), (4, 5), (5, 6)]) \\"(1(2(4(5(6))))(3))\\"","solution":"def encode_tree(n, edges): from collections import defaultdict # Build the adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform DFS and build the encoded string def dfs(node, parent): children = sorted(child for child in tree[node] if child != parent) return f\\"({node}\\" + \\"\\".join(dfs(child, node) for child in children) + \\")\\" # Start DFS from root node 1 return dfs(1, None)"},{"question":"def longest_balanced_parentheses(s: str) -> int: Returns the length of the longest balanced substring of parentheses. >>> longest_balanced_parentheses(\\"(()())\\") == 6 >>> longest_balanced_parentheses(\\")()())\\") == 4 >>> longest_balanced_parentheses(\\"\\") == 0 >>> longest_balanced_parentheses(\\")(\\") == 0 >>> longest_balanced_parentheses(\\"()(()()))\\") == 8 >>> longest_balanced_parentheses(\\"(((())))\\") == 8 >>> longest_balanced_parentheses(\\"(()))(\\") == 4 >>> longest_balanced_parentheses(\\"()()()\\") == 6 >>> longest_balanced_parentheses(\\"(()\\") == 2 >>> longest_balanced_parentheses(\\"(((\\") == 0 >>> longest_balanced_parentheses(\\")))\\") == 0","solution":"def longest_balanced_parentheses(s): Returns the length of the longest balanced substring of parentheses. max_len = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) return max_len"},{"question":"def longest_distinct_segment(n: int, skill_levels: List[int]) -> int: Returns the length of the longest segment of distinct skill levels. Args: n (int): The number of challenges. skill_levels (List[int]): The list of skill levels required for each challenge. Returns: int: The length of the longest segment with distinct skill levels. Examples: >>> longest_distinct_segment(5, [1, 2, 3, 2, 1]) 3 >>> longest_distinct_segment(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_distinct_segment(6, [4, 5, 6, 6, 5, 4]) 3 from solution import longest_distinct_segment def test_example_cases(): assert longest_distinct_segment(5, [1, 2, 3, 2, 1]) == 3 assert longest_distinct_segment(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 assert longest_distinct_segment(6, [4, 5, 6, 6, 5, 4]) == 3 def test_single_element(): assert longest_distinct_segment(1, [5]) == 1 def test_all_elements_same(): assert longest_distinct_segment(5, [2, 2, 2, 2, 2]) == 1 def test_distinct_elements(): assert longest_distinct_segment(4, [1, 2, 3, 4]) == 4 def test_large_input(): assert longest_distinct_segment(100000, list(range(100000))) == 100000 def test_mixed_repeats(): assert longest_distinct_segment(8, [8, 6, 7, 8, 6, 7, 9, 10]) == 5","solution":"def longest_distinct_segment(n, skill_levels): Returns the length of the longest segment of distinct skill levels. max_length = 0 start = 0 seen = {} for end in range(n): if skill_levels[end] in seen: start = max(start, seen[skill_levels[end]] + 1) seen[skill_levels[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def largest_rectangle_area(grid: List[str]) -> int: Given a city map represented as an n × m grid, returns the area of the largest rectangle consisting entirely of road cells. Input: grid : List[str] - A list of strings representing the map, where each string corresponds to a row and can contain 'R', 'B', or 'P' Output: int - The area of the largest rectangular region composed of 'R' cells in the grid Examples: >>> largest_rectangle_area([ ... \\"RRBRP\\", ... \\"RRPBR\\", ... \\"RRRRR\\", ... \\"BBPRR\\" ... ]) 6 >>> largest_rectangle_area([ ... \\"B\\", ... \\"R\\" ... ]) 1 >>> largest_rectangle_area([ ... \\"PBR\\", ... \\"RRP\\", ... \\"BBB\\" ... ]) 2 >>> largest_rectangle_area([ ... \\"RRRR\\", ... \\"RRRR\\", ... \\"RRRR\\" ... ]) 12 >>> largest_rectangle_area([ ... \\"PBPB\\", ... \\"PRPR\\", ... \\"PBPB\\" ... ]) 1 >>> largest_rectangle_area([ ... \\"RRRRR\\", ... \\"RRRRR\\", ... \\"RRRRR\\", ... \\"RRRRR\\", ... \\"RRRRR\\" ... ]) 25 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([\\"R\\"]) 1 >>> largest_rectangle_area([\\"B\\"]) 0 >>> largest_rectangle_area([\\"P\\"]) 0 >>> largest_rectangle_area([ ... \\"PPPP\\", ... \\"BBBB\\", ... \\"PPPP\\", ... \\"BBBB\\" ... ]) 0 >>> largest_rectangle_area([ ... \\"RRR\\", ... \\"RRR\\", ... \\"RRR\\" ... ]) 9","solution":"def largest_rectangle_area(grid): def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not grid: return 0 n = len(grid) m = len(grid[0]) heights = [0] * m max_area = 0 for row in grid: for i in range(m): if row[i] == 'R': heights[i] += 1 else: heights[i] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"def process_operations(n, m, initial_values, operations): Process a list of operations on an array. - \`n\` (int): size of the list - \`m\` (int): number of operations - \`initial_values\` (List[int]): initial values of the list - \`operations\` (List[Tuple[int, ...]]): list of operations to perform on the list The function should return a list of results from the \\"find the maximum value\\" operations. >>> process_operations(5, 4, [1, 2, 3, 4, 5], [(1, 3, 10), (2, 1, 3), (1, 4, 5), (2, 2, 5)]) [13, 10]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self._build_tree(data) def _build_tree(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, idx, value): idx += self.n self.tree[idx] += value while idx > 1: idx >>= 1 self.tree[idx] = max(self.tree[idx << 1], self.tree[idx << 1 | 1]) def query(self, l, r): l += self.n r += self.n max_val = float('-inf') while l < r: if l & 1: max_val = max(max_val, self.tree[l]) l += 1 if r & 1: r -= 1 max_val = max(max_val, self.tree[r]) l >>= 1 r >>= 1 return max_val def process_operations(n, m, initial_values, operations): segment_tree = SegmentTree(initial_values) results = [] for operation in operations: if operation[0] == 1: _, x, v = operation segment_tree.update(x - 1, v) elif operation[0] == 2: _, l, r = operation result = segment_tree.query(l - 1, r) results.append(result) return results"},{"question":"def min_operations_to_equalize_array(t, test_cases): Returns the minimum number of operations to make all elements of the array equal. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains two elements - the length of array n and the array a. Returns: list: A list of integers representing the minimum number of operations for each test case. Example usage: >>> min_operations_to_equalize_array(2, [(3, [2, 2, 2]), (4, [4, 3, 2, 3])]) [0, 2] >>> min_operations_to_equalize_array(1, [(5, [1, 2, 3, 4, 5])]) [4]","solution":"def min_operations_to_equalize_array(t, test_cases): Returns the minimum number of operations to make all elements of the array equal. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains two elements - the length of array n and the array a. Returns: list: A list of integers representing the minimum number of operations for each test case. results = [] for n, a in test_cases: unique_elements = set(a) if len(unique_elements) == 1: results.append(0) else: results.append(len(unique_elements) - 1) return results"},{"question":"def vlad_and_lena_game(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Simulates the game where Vlad places coins on a grid and Lena verifies the placements. Args: t (int): Number of test cases. test_cases (List[Dict[str, Any]]): List of test cases. Each test case is a dictionary with keys: - 'm' (int): Number of rows in the grid. - 'n' (int): Number of columns in the grid. - 'N' (int): Number of coins to be placed. - 'placements' (List[Tuple[int, int]]): List of (x, y) tuples representing the placements. Returns: List[str]: List of results for each test case. \\"Valid\\" if all placements are valid, \\"Invalid\\" otherwise. Example: >>> vlad_and_lena_game(2, [{'m': 3, 'n': 3, 'N': 3, 'placements': [(1, 1), (2, 2), (3, 3)]}, {'m': 3, 'n': 3, 'N': 3, 'placements': [(1, 1), (2, 1), (3, 3)]}]) [\\"Valid\\", \\"Invalid\\"]","solution":"def vlad_and_lena_game(t, test_cases): results = [] for case in test_cases: m, n, N, placements = case['m'], case['n'], case['N'], case['placements'] rows = set() cols = set() valid = True for x, y in placements: if x in rows or y in cols: results.append(\\"Invalid\\") valid = False break rows.add(x) cols.add(y) if valid: results.append(\\"Valid\\") return results"},{"question":"def max_non_overlapping_tasks(test_cases: List[List[Tuple[int, int]]]) -> List[int]: Find the maximum number of non-overlapping tasks you can complete from given test cases. >>> max_non_overlapping_tasks([[(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)]]) [2, 4] pass def process_input(input_string: str) -> List[List[Tuple[int, int]]]: Process the input string to extract test cases. >>> process_input(\\"2n3n1 3n2 4n3 5n4n1 2n2 3n3 4n4 5\\") [[(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)]] pass def format_output(results: List[int]) -> str: Format the results into a string output. >>> format_output([2, 4]) \\"2n4\\" pass def test_process_input(): input_string = \\"2n3n1 3n2 4n3 5n4n1 2n2 3n3 4n4 5\\" expected_output = [ [(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)] ] assert process_input(input_string) == expected_output def test_format_output(): results = [2, 4] expected_output = \\"2n4\\" assert format_output(results) == expected_output def test_max_non_overlapping_tasks(): test_cases = [ [(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)] ] expected_output = [2, 4] assert max_non_overlapping_tasks(test_cases) == expected_output def test_end_to_end(): input_string = \\"2n3n1 3n2 4n3 5n4n1 2n2 3n3 4n4 5\\" expected_output = \\"2n4\\" # Process Input test_cases = process_input(input_string) # Get the results results = max_non_overlapping_tasks(test_cases) # Format outputs output = format_output(results) assert output == expected_output","solution":"def max_non_overlapping_tasks(test_cases): results = [] for tasks in test_cases: tasks.sort(key=lambda x: x[1]) # sort by end times max_tasks = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: max_tasks += 1 last_end_time = end results.append(max_tasks) return results def process_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(t): n = int(lines[index].strip()) tasks = [] for i in range(n): index += 1 start, end = map(int, lines[index].strip().split()) tasks.append((start, end)) test_cases.append(tasks) index += 1 return test_cases def format_output(results): return \\"n\\".join(map(str,results)) # Example usage: # input_string = \\"2n3n1 3n2 4n3 5n4n1 2n2 3n3 4n4 5\\" # test_cases = process_input(input_string) # max_tasks_per_case = max_non_overlapping_tasks(test_cases) # print(format_output(max_tasks_per_case))"},{"question":"import heapq from typing import List, Tuple def minimum_bike_path_length(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Compute the minimum length of bike paths needed to connect all intersections. :param n: Number of intersections :param m: Number of bidirectional roads :param roads: List of tuples (u, v, w) representing roads with their lengths :return: Minimum total length of the bike paths that connect all intersections >>> minimum_bike_path_length(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3)]) 6 >>> minimum_bike_path_length(3, 3, [(1, 2, 5), (2, 3, 4), (1, 3, 1)]) 5 pass def test_example_1(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3) ] assert minimum_bike_path_length(n, m, roads) == 6 def test_example_2(): n = 3 m = 3 roads = [ (1, 2, 5), (2, 3, 4), (1, 3, 1) ] assert minimum_bike_path_length(n, m, roads) == 5 def test_single_intersection(): n = 1 m = 0 roads = [] assert minimum_bike_path_length(n, m, roads) == 0 def test_disconnected_graph(): n = 4 m = 3 roads = [ (1, 2, 2), (2, 3, 2), (4, 1, 3) ] assert minimum_bike_path_length(n, m, roads) == 7 def test_large_graph(): n = 5 m = 7 roads = [ (1, 2, 2), (1, 3, 4), (1, 4, 3), (2, 3, 1), (3, 4, 5), (4, 5, 2), (2, 5, 7) ] assert minimum_bike_path_length(n, m, roads) == 8","solution":"import heapq def minimum_bike_path_length(n, m, roads): Compute the minimum length of bike paths needed to connect all intersections. :param n: Number of intersections :param m: Number of bidirectional roads :param roads: List of tuples (u, v, w) representing roads with their lengths :return: Minimum total length of the bike paths that connect all intersections # Initialize the graph graph = [[] for _ in range(n)] for u, v, w in roads: graph[u-1].append((w, v-1)) graph[v-1].append((w, u-1)) # Minimum spanning tree using Prim's algorithm min_length = 0 visited = [False] * n min_heap = [(0, 0)] # (cost, start_node) while min_heap: cost, node = heapq.heappop(min_heap) if visited[node]: continue min_length += cost visited[node] = True for edge_cost, neighbor in graph[node]: if not visited[neighbor]: heapq.heappush(min_heap, (edge_cost, neighbor)) return min_length # Example usage if __name__ == \\"__main__\\": n, m = 4, 5 roads = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3) ] print(minimum_bike_path_length(n, m, roads)) # Output: 6"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum possible profit from exactly one buy-sell transaction. Parameters: prices (list): A list of integers representing daily profits. Returns: int: The maximum possible profit. If no profit is possible, returns 0. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([5, 2, 6, 1, 4]) == 4","solution":"def max_profit(prices): Returns the maximum possible profit from exactly one buy-sell transaction. Parameters: prices (list): A list of integers representing daily profits. Returns: int: The maximum possible profit. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_doll_order(n: int, nesting_pairs: List[Tuple[int, int]]) -> Union[List[int], str]: Determine a valid ordering of dolls that respects the nesting relationships. >>> find_doll_order(3, [(3, 1), (4, 2), (2, 3)]) [4, 2, 3, 1] >>> find_doll_order(2, [(1, 2), (2, 1)]) 'IMPOSSIBLE'","solution":"def find_doll_order(n, nesting_pairs): from collections import defaultdict, deque # Create a graph and in-degree dictionary graph = defaultdict(list) in_degree = defaultdict(int) dolls = set() for a, b in nesting_pairs: graph[a].append(b) in_degree[b] += 1 dolls.add(a) dolls.add(b) # Find all nodes with zero in-degree queue = deque([doll for doll in dolls if in_degree[doll] == 0]) sorted_order = [] while queue: current = queue.popleft() sorted_order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(sorted_order) == len(dolls): return sorted_order else: return \\"IMPOSSIBLE\\" # Example Function Usage def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nesting_pairs = [] for i in range(n): a, b = int(data[2 * i + 1]), int(data[2 * i + 2]) nesting_pairs.append((a, b)) result = find_doll_order(n, nesting_pairs) if result == \\"IMPOSSIBLE\\": print(result) else: print(\\" \\".join(map(str, result)))"},{"question":"def can_water_plants(n: int, d: int, plants: List[int]) -> str: Determines if it's possible to water the plants for d days without causing any plant to wither. >>> can_water_plants(3, 5, [2, 3, 1]) \\"YES\\" >>> can_water_plants(3, 10, [1, 1, 1]) \\"NO\\" >>> can_water_plants(2, 2, [1, 1]) \\"YES\\" >>> can_water_plants(3, 4, [2, 2, 2]) \\"YES\\" >>> can_water_plants(1, 1, [1]) \\"YES\\" >>> can_water_plants(1, 2, [1]) \\"NO\\" >>> can_water_plants(4, 7, [1, 2, 3, 1]) \\"YES\\" >>> can_water_plants(4, 8, [1, 2, 3, 1]) \\"NO\\"","solution":"def can_water_plants(n, d, plants): Determines if it's possible to water the plants for d days without causing any plant to wither. Parameters: n (int): Number of plants. d (int): Number of days Fluttershy needs to water the plants. plants (list): Number of days each plant can survive without water after being watered. Returns: str: \\"YES\\" if it's possible to water the plants for d days without causing any plant to wither, otherwise \\"NO\\". # Ensure there is always a different plant available for each day if d <= sum(plants): return \\"YES\\" else: return \\"NO\\""},{"question":"def count_special_substrings(s: str) -> int: Given a string consisting solely of lowercase Latin letters, determine the number of special substrings. A substring is considered special if it starts and ends with the same character. >>> count_special_substrings(\\"ababa\\") == 9 >>> count_special_substrings(\\"aaa\\") == 6 >>> count_special_substrings(\\"a\\") == 1 >>> count_special_substrings(\\"ab\\") == 2 >>> count_special_substrings(\\"aa\\") == 3 >>> count_special_substrings(\\"racecar\\") == 10 >>> count_special_substrings(\\"abc\\") == 3 >>> count_special_substrings(\\"aaaaaa\\") == 21","solution":"def count_special_substrings(s): n = len(s) count = 0 for i in range(n): # Count single letter substrings count += 1 # Count substrings with the same start and end character for j in range(i + 1, n): if s[i] == s[j]: count += 1 return count"},{"question":"def assign_road_directions(n: int, roads: List[Tuple[int, int]]) -> str: Determine road directions such that all intersections remain reachable. Args: n (int): The number of intersections. roads (List[Tuple[int, int]]): List of roads represented by tuples of intersections (u, v). Returns: str: A string that begins with \\"YES\\" if it's possible to assign directions, followed by the directions, or \\"NO\\" if not possible. >>> assign_road_directions(4, [(1, 2), (1, 3), (2, 4)]) \\"YESn2n1n2\\" >>> assign_road_directions(3, [(1, 2), (2, 3)]) \\"YESn1n1\\" >>> assign_road_directions(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) \\"YESn1n1n1n1\\" >>> assign_road_directions(4, [(1, 2), (1, 3), (4, 2)]) \\"YESn1n1n1\\" >>> assign_road_directions(2, [(1, 2)]) \\"YESn1\\"","solution":"def assign_road_directions(n, roads): from collections import defaultdict, deque # Disjoint Set Union-Find with path compression parent = list(range(n + 1)) rank = [1] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Initialize adjacency list adj = defaultdict(list) for u, v in roads: adj[u].append(v) adj[v].append(u) union(u, v) # Check if all nodes belong to the same connected component root = find(1) for i in range(2, n + 1): if find(i) != root: return \\"NO\\" # BFS to assign directions directions = [] visited = [False] * (n + 1) queue = deque([1]) visited[1] = True parent = [-1] * (n + 1) while queue: node = queue.popleft() for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True parent[neighbor] = node queue.append(neighbor) directions.append((node, neighbor)) elif parent[node] != neighbor: directions.append((node, neighbor)) result = [\\"YES\\"] for u, v in directions: if parent[v] == u or parent[u] == v: result.append(\\"1\\") else: result.append(\\"2\\") return \\"n\\".join(result) # Example usage: n = 4 roads = [(1, 2), (1, 3), (2, 4)] print(assign_road_directions(n, roads))"},{"question":"def kruskal(n, edges): Calculate the minimum cost required to build the network such that all cities can communicate with each other using Kruskal's algorithm. Args: n (int): number of cities. edges (List[Tuple[int, int, int]]): list of roads described with tuples where each tuple contains two cities and a travel time. Returns: int: minimum cost to build the network. Example: >>> kruskal(4, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 3), (3, 4, 2)]) 6 >>> kruskal(4, [(1, 2, 1), (3, 4, 2)]) 3 >>> kruskal(2, [(1, 2, 5)]) 5 >>> kruskal(6, [(1, 2, 6), (1, 3, 1), (1, 4, 5), (2, 5, 3), (2, 3, 5), (3, 5, 6), (3, 6, 4), (4, 6, 2), (5, 6, 6)]) 15","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 for edge in edges: u, v, w = edge root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: mst_weight += w union(parent, rank, root_u, root_v) return mst_weight"},{"question":"from typing import List def max_average(n: int, productivity_scores: List[int]) -> float: Determine the maximum average productivity score of any team. >>> abs(max_average(6, [1, 12, -5, -6, 50, 3]) - 50.0) < 1e-6 True >>> abs(max_average(1, [10]) - 10.0) < 1e-6 True >>> abs(max_average(5, [1, 2, 3, 4, 5]) - 5.0) < 1e-6 True >>> abs(max_average(3, [-1, -2, -3]) - (-1.0)) < 1e-6 True >>> abs(max_average(5, [-1, 10, -5, 10, -1]) - 10.0) < 1e-6 True","solution":"def max_average_productivity(n, productivity_scores): max_sum = current_sum = productivity_scores[0] for i in range(1, n): current_sum = max(productivity_scores[i], current_sum + productivity_scores[i]) max_sum = max(max_sum, current_sum) return max_sum def max_average(n, a): max_avg = float('-inf') for k in range(1, n + 1): current_sum = sum(a[:k]) max_sum = current_sum for i in range(k, n): current_sum += a[i] - a[i - k] max_sum = max(max_sum, current_sum) max_avg = max(max_avg, max_sum / k) return max_avg"},{"question":"def is_valid_juggling_pattern(n: int, s: str) -> str: Determine if the given string represents a valid juggling pattern. A valid juggling pattern has matching \\"add\\" '(' and \\"remove\\" ')' actions such that at no point does the number of \\"remove\\" actions exceed the number of \\"add\\" actions. At the end, the number of \\"add\\" actions must equal the number of \\"remove\\" actions. Args: n (int): The length of the string. s (str): The string representing the juggling pattern. Returns: str: \\"YES\\" if the pattern is valid, \\"NO\\" otherwise. >>> is_valid_juggling_pattern(6, \\"((()))\\") \\"YES\\" >>> is_valid_juggling_pattern(4, \\"(()(\\") \\"NO\\" >>> is_valid_juggling_pattern(3, \\"())\\") \\"NO\\"","solution":"def is_valid_juggling_pattern(n, s): balance = 0 for char in s: if char == '(': balance += 1 else: balance -= 1 if balance < 0: return \\"NO\\" return \\"YES\\" if balance == 0 else \\"NO\\""},{"question":"from collections import Counter from typing import List def can_rearrange_no_consecutive_same(n: int, acts: List[int]) -> bool: Determines if it is possible to rearrange the list of acts such that no two consecutive acts have the same duration. Args: n: int, the number of acts. acts: List[int], list of integers where each integer represents the duration of an act. Returns: bool: True if it is possible to rearrange the list such that no two consecutive elements are the same. False otherwise. >>> can_rearrange_no_consecutive_same(5, [1, 2, 3, 2, 1]) True >>> can_rearrange_no_consecutive_same(3, [1, 1, 1]) False","solution":"from collections import Counter def can_rearrange_no_consecutive_same(n, acts): Determines if it is possible to rearrange the list of acts such that no two consecutive acts have the same duration. Args: n: int, the number of acts. acts: List[int], list of integers where each integer represents the duration of an act. Returns: bool: \\"Yes\\" if it is possible to rearrange the list such that no two consecutive elements are the same. \\"No\\" otherwise. if n == 1: return True freq = Counter(acts) most_common = freq.most_common(1)[0][1] # Check if the most common element can be placed without repetition possible = most_common <= (n + 1) // 2 return possible"},{"question":"def max_sum_subgrid(n, m, grid): Find the maximum possible sum of a rectangle subgrid within the given grid. >>> max_sum_subgrid(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> max_sum_subgrid(2, 2, [[1, 2], [3, 4]]) 10 def process_test_cases(input_data): Process multiple test cases and find the maximum sum of a rectangle subgrid for each. >>> input_data = \\"2n3 3n1 2 3n4 5 6n7 8 9n2 2n1 2n3 4n\\" >>> process_test_cases(input_data) [45, 10]","solution":"def max_sum_subgrid(n, m, grid): # Function to find the maximum sum subgrid in a given 2D grid max_sum = float('-inf') # Precompute prefix sums for the 2D grid prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = grid[i-1][j-1] if i > 1: prefix_sum[i][j] += prefix_sum[i-1][j] if j > 1: prefix_sum[i][j] += prefix_sum[i][j-1] if i > 1 and j > 1: prefix_sum[i][j] -= prefix_sum[i-1][j-1] # Compute the maximum sum subgrid for i1 in range(1, n + 1): for i2 in range(i1, n + 1): for j1 in range(1, m + 1): for j2 in range(j1, m + 1): total = prefix_sum[i2][j2] if i1 > 1: total -= prefix_sum[i1 - 1][j2] if j1 > 1: total -= prefix_sum[i2][j1 - 1] if i1 > 1 and j1 > 1: total += prefix_sum[i1 - 1][j1 - 1] max_sum = max(max_sum, total) return max_sum def process_test_cases(input_data): result = [] data = input_data.strip().split('n') T = int(data[0]) index = 1 for _ in range(T): n, m = map(int, data[index].split()) grid = [list(map(int, data[index + 1 + i].split())) for i in range(n)] result.append(max_sum_subgrid(n, m, grid)) index += n + 1 return result"},{"question":"def possible_new_roads(n: int, roads: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determine all pairs of gates between which a new road can be constructed such that the resulting network remains valid (no cycles). >>> possible_new_roads(4, [(1, 2), (2, 3), (3, 4)]) [(1, 3), (1, 4), (2, 4)] >>> possible_new_roads(3, [(1, 2), (1, 3)]) [(2, 3)] >>> possible_new_roads(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) [(1, 3), (1, 4), (1, 5), (2, 4), (2, 5), (3, 5)] >>> possible_new_roads(2, [(1, 2)]) []","solution":"def possible_new_roads(n, roads): from collections import defaultdict, deque graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) def bfs(start): visited = set() q = deque([start]) while q: node = q.popleft() if node in visited: continue visited.add(node) for neighbor in graph[node]: if neighbor not in visited: q.append(neighbor) return visited all_nodes = set(range(1, n + 1)) components = [] visited_nodes = set() for node in range(1, n + 1): if node not in visited_nodes: component = bfs(node) components.append(component) visited_nodes |= component possible_edges = [] for i in range(1, n): for j in range(i + 1, n + 1): if j not in graph[i]: possible_edges.append((i, j)) return possible_edges"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"abacdfg\\") 'aba' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ab\\") in [\\"a\\", \\"b\\"] True >>> longest_palindromic_substring(\\"aaaaa\\") 'aaaaa' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"noon\\") 'noon' >>> longest_palindromic_substring(\\"bananas\\") 'anana'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. n = len(s) if n <= 1: return s start = 0 max_length = 1 for i in range(n): # Odd length palindromes low, high = i, i while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: start = low max_length = current_length low -= 1 high += 1 # Even length palindromes low, high = i, i + 1 while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: start = low max_length = current_length low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def game_winner(n: int, m: int, matrix: List[List[int]]) -> str: Determines the winner of the game between Tom and Jerry. Parameters: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. matrix (list of list of int): The initial values in the matrix. Returns: str: \\"Tom\\" if Tom wins, otherwise \\"Jerry\\". >>> game_winner(2, 3, [[1, 2, 0], [0, 0, 3]]) == \\"Tom\\" >>> game_winner(2, 2, [[0, 1], [2, 0]]) == \\"Jerry\\" >>> game_winner(1, 1, [[1]]) == \\"Tom\\" >>> game_winner(1, 1, [[0]]) == \\"Jerry\\" >>> game_winner(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == \\"Tom\\" >>> game_winner(2, 2, [[1, 2], [3, 4]]) == \\"Jerry\\" >>> game_winner(2, 2, [[0, 0], [0, 0]]) == \\"Jerry\\"","solution":"def game_winner(n, m, matrix): Determines the winner of the game between Tom and Jerry. Parameters: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. matrix (list of list of int): The initial values in the matrix. Returns: str: \\"Tom\\" if Tom wins, otherwise \\"Jerry\\". total_non_zero_cells = sum(matrix[i][j] != 0 for i in range(n) for j in range(m)) # If the number of non-zero cells is odd, Tom wins, otherwise Jerry wins if total_non_zero_cells % 2 == 1: return \\"Tom\\" else: return \\"Jerry\\""},{"question":"def min_contiguous_blocks(n: int, k: int, blocks: str) -> int: Returns the minimum number of contiguous blocks after changing at most k blocks. >>> min_contiguous_blocks(7, 2, \\"rrbbrggg\\") 2 >>> min_contiguous_blocks(5, 0, \\"rrrbb\\") 2 >>> min_contiguous_blocks(5, 2, \\"rrrrr\\") 1 >>> min_contiguous_blocks(4, 4, \\"rgbg\\") 1 >>> min_contiguous_blocks(8, 3, \\"rgbrbgrb\\") 2 >>> min_contiguous_blocks(1, 0, \\"r\\") 1 >>> min_contiguous_blocks(0, 0, \\"\\") 0","solution":"def min_contiguous_blocks(n, k, blocks): Returns the minimum number of contiguous blocks after changing at most k blocks. if n == 0: return 0 def count_min_blocks(blocks): Helper function to count the number of contiguous blocks in a given string. count = 1 for i in range(1, len(blocks)): if blocks[i] != blocks[i - 1]: count += 1 return count # Initialize the minimum block count to the current block count min_blocks = count_min_blocks(blocks) # Iterate over each possible color to change contiguous blocks to for target_color in 'rbg': # Initialize sliding window pointers left, right = 0, 0 changes = 0 while right < n: if blocks[right] != target_color: changes += 1 while changes > k: if blocks[left] != target_color: changes -= 1 left += 1 # Calculate the number of blocks if we change [left:right] to target_color new_blocks = (left > 0) + (right < n - 1) + 1 min_blocks = min(min_blocks, new_blocks) right += 1 return min_blocks"},{"question":"def is_binary_palindrome(num: int) -> bool: Check if a number is a binary palindrome. >>> is_binary_palindrome(1) True >>> is_binary_palindrome(9) True >>> is_binary_palindrome(21) True >>> is_binary_palindrome(22) False >>> is_binary_palindrome(33) True def smallest_binary_palindrome(n: int) -> int: Find the smallest binary palindrome greater than or equal to n. >>> smallest_binary_palindrome(9) 9 >>> smallest_binary_palindrome(20) 21 >>> smallest_binary_palindrome(33) 33 >>> smallest_binary_palindrome(15) 15 >>> smallest_binary_palindrome(8) 9","solution":"def is_binary_palindrome(num): binary_rep = bin(num)[2:] return binary_rep == binary_rep[::-1] def smallest_binary_palindrome(n): while True: if is_binary_palindrome(n): return n n += 1"},{"question":"def process_queries(n: int, q: int, nums: List[int], queries: List[List[int]]) -> List[int]: You are given a long list of integer numbers where you need to process multiple queries. Each query can be of two types: 1. Update the value at a specific position in the list. 2. Retrieve the sum of all elements in a specified range within the list. You need to support these operations efficiently given the constraints. The first line contains two integers, \`n\` and \`q\` (1 le n, q le 10^5) — the size of the list and the number of queries. The second line contains \`n\` integers denoting the elements of the list. The next \`q\` lines contain queries, each in one of the following formats: - \`1 x y\` — Update the value at index \`x\` to \`y\` (1-based index). - \`2 l r\` — Retrieve the sum of elements from index \`l\` to index \`r\` (1-based index, inclusive). For each query of the second type, print the corresponding sum. >>> process_queries(5, 4, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 3, 10], [2, 1, 3], [2, 4, 5]]) [6, 13, 9] >>> process_queries(3, 1, [5, 6, 7], [[2, 1, 2]]) [11] >>> process_queries(3, 2, [100000, 200000, 300000], [[2, 1, 3], [1, 2, 500000]]) [600000] >>> process_queries(1, 1, [42], [[2, 1, 1]]) [42]","solution":"class NumList: def __init__(self, nums): self.nums = nums self.prefix_sums = self._compute_prefix_sums(nums) def _compute_prefix_sums(self, nums): prefix_sums = [0] * (len(nums) + 1) for i in range(1, len(nums) + 1): prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1] return prefix_sums def update(self, x, y): difference = y - self.nums[x - 1] self.nums[x - 1] = y for i in range(x, len(self.prefix_sums)): self.prefix_sums[i] += difference def range_sum(self, l, r): return self.prefix_sums[r] - self.prefix_sums[l - 1] def process_queries(n, q, nums, queries): num_list = NumList(nums) result = [] for query in queries: if query[0] == 1: num_list.update(query[1], query[2]) elif query[0] == 2: result.append(num_list.range_sum(query[1], query[2])) return result"},{"question":"def max_coins(n: int, grid: List[List[int]]) -> int: Computes the maximum number of coins that can be collected from the start to the finish point on an n x n grid by only moving right or down. Parameters: n (int): Size of the grid grid (list of list of int): 2D list representing the grid with coins in each cell Returns: int: The maximum number of coins that can be collected from typing import List def test_example_1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_coins(3, grid) == 29 def test_1x1_grid(): grid = [[5]] assert max_coins(1, grid) == 5 def test_2x2_grid(): grid = [ [1, 2], [3, 4] ] assert max_coins(2, grid) == 8 def test_3x3_all_zeros(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_coins(3, grid) == 0 def test_4x4_grid(): grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert max_coins(4, grid) == 7 def test_large_grid(): n = 1000 grid = [[1] * 1000 for _ in range(1000)] assert max_coins(1000, grid) == 1999","solution":"def max_coins(n, grid): Computes the maximum number of coins that can be collected from the start to the finish point on an n x n grid by only moving right or down. Parameters: n (int): Size of the grid grid (list of list of int): 2D list representing the grid with coins in each cell Returns: int: The maximum number of coins that can be collected # Create a 2D list to store the maximum coins collected up to each cell dp = [[0] * n for _ in range(n)] # Initialize the dp grid with the coins at the start position dp[0][0] = grid[0][0] # Fill the first row (can only come from left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp grid for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the maximum coins collected from (0,0) to (n-1,n-1) return dp[n-1][n-1]"},{"question":"def num_buildings_with_sunlight(n: int, heights: List[int]) -> int: Determine the total number of buildings that receive direct sunlight for a particular day. Parameters: n (int): number of buildings heights (list of int): list of building heights Returns: int: number of buildings that receive direct sunlight >>> num_buildings_with_sunlight(6, [3, 1, 4, 1, 5, 9]) # Output: 4 >>> num_buildings_with_sunlight(5, [5, 5, 5, 5, 5]) # Output: 1 >>> num_buildings_with_sunlight(5, [1, 2, 3, 4, 5]) # Output: 5 >>> num_buildings_with_sunlight(5, [5, 4, 3, 2, 1]) # Output: 1 >>> num_buildings_with_sunlight(7, [3, 3, 4, 3, 5, 7, 6]) # Output: 4 >>> num_buildings_with_sunlight(1, [10]) # Output: 1 >>> num_buildings_with_sunlight(100000, list(range(1, 100001))) # Output: 100000 >>> num_buildings_with_sunlight(100000, [100000] * 100000) # Output: 1 >>> num_buildings_with_sunlight(0, []) # Output: 0","solution":"def num_buildings_with_sunlight(n, heights): Returns the number of buildings that receive direct sunlight. Parameters: n (int): number of buildings heights (list of int): list of building heights Returns: int: number of buildings that receive direct sunlight if not heights: return 0 max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"def longest_palindromic_subsequence(n: int, sequence: List[int]) -> int: Given an integer sequence, find the length of the longest subsequence that is a palindrome. >>> longest_palindromic_subsequence(6, [1, 2, 3, 2, 1, 4]) 5 >>> longest_palindromic_subsequence(1, [1]) 1 >>> longest_palindromic_subsequence(5, [1, 2, 3, 2, 1]) 5 >>> longest_palindromic_subsequence(7, [1, 3, 7, 8, 7, 3, 1]) 7 >>> longest_palindromic_subsequence(6, [4, 1, 2, 3, 2, 1]) 5 >>> longest_palindromic_subsequence(4, [1, 2, 3, 4]) 1 >>> longest_palindromic_subsequence(8, [1, 4, 2, 3, 3, 2, 4, 1]) 8 >>> longest_palindromic_subsequence(5, [1, 1, 1, 1, 1]) 5","solution":"def longest_palindromic_subsequence(n, sequence): Given a sequence, returns the length of the longest subsequence that is a palindrome. dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Fill the dp array for length in range(2, n + 1): # Length of the substring for i in range(n - length + 1): j = i + length - 1 if sequence[i] == sequence[j] and length == 2: dp[i][j] = 2 elif sequence[i] == sequence[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def min_operations_to_equalize_grid(n, grid): Determines the minimum number of operations to make all integers in the grid equal. Each operation involves selecting a cell and adding 1 to all cells in its row and column. Parameters: n (int): Size of the grid (number of rows/columns). grid (List[List[int]]): The n x n grid of integers. Returns: int: Minimum number of operations required to make all integers in the grid equal. pass def test_case_1(): n = 2 grid = [[1, 2], [3, 4]] assert min_operations_to_equalize_grid(n, grid) == 3 def test_case_2(): n = 3 grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] assert min_operations_to_equalize_grid(n, grid) == 0 def test_case_3(): n = 2 grid = [[100, 200], [300, 400]] assert min_operations_to_equalize_grid(n, grid) == 300 def test_case_4(): n = 3 grid = [[5, 6, 5], [4, 5, 6], [7, 3, 5]] assert min_operations_to_equalize_grid(n, grid) == 4 def test_case_5(): n = 4 grid = [[10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 9]] assert min_operations_to_equalize_grid(n, grid) == 1","solution":"def min_operations_to_equalize_grid(n, grid): Determines the minimum number of operations to make all integers in the grid equal. Each operation involves selecting a cell and adding 1 to all cells in its row and column. Parameters: n (int): Size of the grid (number of rows/columns). grid (List[List[int]]): The n x n grid of integers. Returns: int: Minimum number of operations required to make all integers in the grid equal. max_value = max(max(row) for row in grid) min_value = min(min(row) for row in grid) # The minimum number of operations required would be the difference between # the maximum and minimum values in the grid. return max_value - min_value"},{"question":"def max_height_difference(n: int, q: int, heights: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the maximum difference in height between any two buildings within specified subarrays for each query. Parameters: n (int): Number of buildings. q (int): Number of queries. heights (list): Heights of the buildings. queries (list): Queries in the form of (li, ri) tuples where li and ri are the range Returns: list: List of maximum height differences for each query. >>> max_height_difference(8, 3, [1, 5, 3, 9, 8, 4, 6, 2], [(1, 4), (2, 6), (3, 8)]) [8, 6, 7] >>> max_height_difference(5, 2, [2, 4, 7, 1, 5], [(1, 1), (3, 3)]) [0, 0] >>> max_height_difference(5, 1, [2, 4, 7, 1, 5], [(1, 5)]) [6] >>> max_height_difference(6, 3, [3, 3, 3, 3, 3, 3], [(1, 6), (2, 5), (1, 1)]) [0, 0, 0] >>> max_height_difference(4, 2, [1000000, 999999, 1000000, 999999], [(1, 2), (2, 4)]) [1, 1]","solution":"def max_height_difference(n, q, heights, queries): This function computes the maximum height difference within specified subarrays for each query. Parameters: n (int): Number of buildings. q (int): Number of queries. heights (list): Heights of the buildings. queries (list): Queries in the form of (li, ri) tuples where li and ri are the range Returns: list: List of maximum height differences for each query. results = [] for li, ri in queries: sub_range = heights[li-1: ri] max_diff = max(sub_range) - min(sub_range) results.append(max_diff) return results"},{"question":"def make_palindrome(s: str) -> (int, str): Append the fewest number of characters to the end of a given string to make it a palindrome. Return the number of characters added and the resulting palindrome string. >>> make_palindrome(\\"abac\\") (3, \\"abacaba\\") >>> make_palindrome(\\"race\\") (3, \\"racecar\\") >>> make_palindrome(\\"a\\") (0, \\"a\\") >>> make_palindrome(\\"ababa\\") (0, \\"ababa\\") >>> make_palindrome(\\"x\\") (0, \\"x\\") >>> make_palindrome(\\"aabc\\") (3, \\"aabcbaa\\")","solution":"def make_palindrome(s): Append the minimum number of characters to the end of the string to make it a palindrome. Return the number of characters added and the resulting palindrome string. def is_palindrome(substring): return substring == substring[::-1] n = len(s) if is_palindrome(s): return 0, s for i in range(n): if is_palindrome(s[i:]): to_add = s[:i][::-1] return len(to_add), s + to_add return len(s), s[::-1]"},{"question":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming. :param n: The index of the Fibonacci sequence (0 ≤ n ≤ 1000) :return: The nth Fibonacci number >>> fibonacci(10) 55 >>> fibonacci(0) 0 >>> fibonacci(1) 1 def test_fibonacci_0(): assert fibonacci(0) == 0 def test_fibonacci_1(): assert fibonacci(1) == 1 def test_fibonacci_2(): assert fibonacci(2) == 1 def test_fibonacci_3(): assert fibonacci(3) == 2 def test_fibonacci_10(): assert fibonacci(10) == 55 def test_fibonacci_20(): assert fibonacci(20) == 6765 def test_fibonacci_50(): assert fibonacci(50) == 12586269025 def test_fibonacci_100(): assert fibonacci(100) == 354224848179261915075 def test_fibonacci_large(): assert fibonacci(1000) == 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming. :param n: The index of the Fibonacci sequence (0 ≤ n ≤ 1000) :return: The nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[0] = 0 fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def minimum_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum travel time to connect all towns with a high-speed railway system. >>> minimum_travel_time(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 6 >>> minimum_travel_time(4, 2, [(1, 2, 1), (3, 4, 1)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) # path compression return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_cost = 0 mst_edges = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w mst_edges += 1 if mst_edges == n - 1: break if mst_edges != n - 1: return -1 return mst_cost def minimum_travel_time(n, m, roads): if n == 1: return 0 if m == 0 else min([w for _, _, w in roads]) # single town edge case handling edges = [] for road in roads: u, v, w = map(int, road) edges.append((u, v, w)) return kruskal(n, edges)"},{"question":"def distinct_product_ids(test_cases): Calculate the number of distinct product IDs in the cart for each test case. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the number of items and a list of product IDs. Returns: List[int]: A list of integers representing the number of distinct product IDs for each test case. pass def format_input_output(input_str): Format the input string into a list of test cases. Parameters: input_str (str): Input string with multiple lines representing the test cases. Returns: List[Tuple[int, List[int]]]: A list of test cases, where each test case is a tuple containing the number of items and a list of product IDs. pass def format_output(results): Format the output list into a string. Parameters: results (List[int]): A list of integers representing the number of distinct product IDs for each test case. Returns: str: The results joined by newlines. pass # Unit tests def test_distinct_product_ids_case1(): input_data = \\"2n5n1 2 3 2 1n4n4 4 4 4\\" expected_output = \\"3n1\\" test_cases = format_input_output(input_data) results = distinct_product_ids(test_cases) output = format_output(results) assert output == expected_output def test_distinct_product_ids_case2(): input_data = \\"1n6n1 1 2 2 3 3\\" expected_output = \\"3\\" test_cases = format_input_output(input_data) results = distinct_product_ids(test_cases) output = format_output(results) assert output == expected_output def test_distinct_product_ids_case3(): input_data = \\"1n7n1 1 1 1 1 1 1\\" expected_output = \\"1\\" test_cases = format_input_output(input_data) results = distinct_product_ids(test_cases) output = format_output(results) assert output == expected_output def test_distinct_product_ids_case4(): input_data = \\"3n3n1 2 3n3n4 5 6n3n7 8 9\\" expected_output = \\"3n3n3\\" test_cases = format_input_output(input_data) results = distinct_product_ids(test_cases) output = format_output(results) assert output == expected_output def test_distinct_product_ids_case5(): input_data = \\"2n4n10 20 30 40n5n10 10 10 20 20\\" expected_output = \\"4n2\\" test_cases = format_input_output(input_data) results = distinct_product_ids(test_cases) output = format_output(results) assert output == expected_output","solution":"def distinct_product_ids(test_cases): results = [] for case in test_cases: t, items = case distinct_ids = len(set(items)) results.append(distinct_ids) return results def format_input_output(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) items = list(map(int, lines[index + 1].split())) test_cases.append((n, items)) index += 2 return test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def check_qualification(n: int, k: int, m: int, solved_problems: List[int]) -> str: Determines if the participant has qualified for the next round and calculates the number of problems solved. Parameters: n (int): Total problems available. k (int): Minimum problems required to qualify. m (int): Number of problems solved by the participant. solved_problems (list of int): List of solved problem identifiers. Returns: str: Total solved problems and qualification status (\\"Qualified\\" or \\"Not Qualified\\"). >>> check_qualification(10, 5, 6, [2, 5, 7, 3, 8, 9]) \\"6 Qualified\\" >>> check_qualification(8, 4, 3, [1, 4, 6]) \\"3 Not Qualified\\" >>> check_qualification(5, 2, 2, [2, 5]) \\"2 Qualified\\" pass # Test cases from solution import check_qualification def test_sample_input_1(): assert check_qualification(10, 5, 6, [2, 5, 7, 3, 8, 9]) == \\"6 Qualified\\" def test_sample_input_2(): assert check_qualification(8, 4, 3, [1, 4, 6]) == \\"3 Not Qualified\\" def test_sample_input_3(): assert check_qualification(5, 2, 2, [2, 5]) == \\"2 Qualified\\" def test_qualified_with_minimum_problems(): assert check_qualification(7, 3, 3, [1, 2, 3]) == \\"3 Qualified\\" def test_not_qualified_with_zero_solved(): assert check_qualification(10, 5, 0, []) == \\"0 Not Qualified\\" def test_qualified_with_all_problems_solved(): assert check_qualification(5, 3, 5, [1, 2, 3, 4, 5]) == \\"5 Qualified\\" def test_not_qualified_when_just_below_required(): assert check_qualification(6, 4, 3, [1, 2, 3]) == \\"3 Not Qualified\\"","solution":"def check_qualification(n, k, m, solved_problems): Determines if the participant has qualified for the next round and calculates the number of problems solved. Parameters: n (int): Total problems available. k (int): Minimum problems required to qualify. m (int): Number of problems solved by the participant. solved_problems (list of int): List of solved problem identifiers. Returns: str: Total solved problems and qualification status (\\"Qualified\\" or \\"Not Qualified\\"). total_solved = len(solved_problems) status = \\"Qualified\\" if total_solved >= k else \\"Not Qualified\\" return f\\"{total_solved} {status}\\""},{"question":"def minimize_max_weight_difference(n, weights): Arranges the boxes to minimize the maximum weight difference between any two consecutive boxes. Returns the minimized maximum weight difference and the arrangement. >>> minimize_max_weight_difference(5, [4, 8, 1, 7, 2]) (3, [1, 2, 4, 7, 8]) >>> minimize_max_weight_difference(2, [100, 1]) (99, [1, 100]) >>> minimize_max_weight_difference(4, [5, 5, 5, 5]) (0, [5, 5, 5, 5]) >>> minimize_max_weight_difference(4, [10, 9, 8, 7]) (1, [7, 8, 9, 10]) >>> minimize_max_weight_difference(6, [2, 4, 1, 3, 9, 5]) (4, [1, 2, 3, 4, 5, 9])","solution":"def minimize_max_weight_difference(n, weights): Arranges the boxes to minimize the maximum weight difference between any two consecutive boxes. Returns the minimized maximum weight difference and the arrangement. # Sort the weights weights.sort() # Calculate the maximum difference between consecutive weights in the sorted arrangement max_diff = max(weights[i] - weights[i - 1] for i in range(1, n)) return max_diff, weights"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sorted_array_to_bst(nums): Helper function to convert sorted array to balanced BST if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def inorder_traversal(root): Helper function to perform inorder traversal of the BST if not root: return [] return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) def construct_balanced_bst_and_inorder_traversal(nums): Constructs a balanced BST from the list of unique integers and returns its inorder traversal nums.sort() root = sorted_array_to_bst(nums) return inorder_traversal(root) def process_input(n, arr): Processes the input and returns the inorder traversal of the balanced binary tree return construct_balanced_bst_and_inorder_traversal(arr) # Unit tests def test_example_case(): assert process_input(7, [4, 2, 7, 1, 3, 6, 9]) == [1, 2, 3, 4, 6, 7, 9] def test_single_element(): assert process_input(1, [5]) == [5] def test_two_elements(): assert process_input(2, [5, 3]) == [3, 5] assert process_input(2, [3, 5]) == [3, 5] def test_large_range(): assert process_input(5, [10, 1, 100, 50, 20]) == [1, 10, 20, 50, 100] def test_zero_as_element(): assert process_input(3, [0, -1, 1]) == [-1, 0, 1] def test_all_positive(): assert process_input(4, [3, 1, 2, 5]) == [1, 2, 3, 5] def test_all_negative(): assert process_input(4, [-3, -1, -2, -5]) == [-5, -3, -2, -1] def test_already_balanced_input(): assert process_input(3, [2, 1, 3]) == [1, 2, 3]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sorted_array_to_bst(nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) def construct_balanced_bst_and_inorder_traversal(nums): nums.sort() root = sorted_array_to_bst(nums) return inorder_traversal(root) def process_input(n, arr): return construct_balanced_bst_and_inorder_traversal(arr)"},{"question":"import heapq from typing import List, Tuple def can_travel_within_time(n: int, m: int, x: int, roads: List[Tuple[int, int, int]], s: int, d: int) -> str: Determines if it's possible to travel from city \`s\` to city \`d\` within time \`x\`. Args: n (int): Number of cities. m (int): Number of roads. x (int): Maximum allowed travel time. roads (list of tuples): Each tuple contains (u, v, t) describing a road. s (int): Starting city. d (int): Destination city. Returns: str: \\"YES\\" if travel is possible within \`x\` time, \\"NO\\" otherwise. pass def test_case_1(): n = 5 m = 6 x = 20 roads = [ (1, 2, 5), (1, 3, 10), (2, 4, 3), (3, 4, 4), (4, 5, 2), (3, 5, 12) ] s = 1 d = 5 assert can_travel_within_time(n, m, x, roads, s, d) == \\"YES\\" def test_case_2(): n = 4 m = 4 x = 5 roads = [ (1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 6) ] s = 1 d = 4 assert can_travel_within_time(n, m, x, roads, s, d) == \\"NO\\" def test_case_3(): n = 3 m = 3 x = 10 roads = [ (1, 2, 3), (2, 3, 3), (1, 3, 8) ] s = 1 d = 3 assert can_travel_within_time(n, m, x, roads, s, d) == \\"YES\\" def test_case_4(): n = 2 m = 1 x = 1 roads = [ (1, 2, 1) ] s = 1 d = 2 assert can_travel_within_time(n, m, x, roads, s, d) == \\"YES\\" def test_case_5(): n = 2 m = 1 x = 1 roads = [ (1, 2, 2) ] s = 1 d = 2 assert can_travel_within_time(n, m, x, roads, s, d) == \\"NO\\"","solution":"import heapq def can_travel_within_time(n, m, x, roads, s, d): Determines if it's possible to travel from city \`s\` to city \`d\` within time \`x\`. Args: n (int): Number of cities. m (int): Number of roads. x (int): Maximum allowed travel time. roads (list of tuples): Each tuple contains (u, v, t) describing a road. s (int): Starting city. d (int): Destination city. Returns: str: \\"YES\\" if travel is possible within \`x\` time, \\"NO\\" otherwise. graph = {i: [] for i in range(1, n + 1)} # Build graph for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # Dijkstra's algorithm to find the shortest path from s to d def dijkstra(start, end): pq = [(0, start)] # (current_time, current_node) shortest_times = {i: float('inf') for i in range(1, n + 1)} shortest_times[start] = 0 while pq: current_time, current_node = heapq.heappop(pq) if current_node == end: return current_time if current_time > shortest_times[current_node]: continue for neighbor, travel_time in graph[current_node]: time = current_time + travel_time if time < shortest_times[neighbor]: shortest_times[neighbor] = time heapq.heappush(pq, (time, neighbor)) return float('inf') shortest_time = dijkstra(s, d) return \\"YES\\" if shortest_time <= x else \\"NO\\""},{"question":"def can_transform(s1: str, s2: str) -> str: Determines if s1 can be transformed into s2 by swapping characters any number of times. :param s1: Source string :param s2: Target string :return: \\"YES\\" if transformation is possible, otherwise \\"NO\\" >>> can_transform(\\"abcd\\", \\"dcba\\") == \\"YES\\" >>> can_transform(\\"abc\\", \\"def\\") == \\"NO\\"","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by swapping characters any number of times. :param s1: Source string :param s2: Target string :return: \\"YES\\" if transformation is possible, otherwise \\"NO\\" from collections import Counter return \\"YES\\" if Counter(s1) == Counter(s2) else \\"NO\\""},{"question":"def max_total_load(n: int, m: int, machine_capacities: List[int], task_loads: List[int]) -> int: Returns the maximum total load that can be processed by the machines. Parameters: n (int): Number of machines m (int): Number of tasks machine_capacities (list of int): Capacities of the machines task_loads (list of int): Load requirements of the tasks Returns: int: The maximum total load that can be processed by the machines >>> max_total_load(3, 4, [10, 15, 20], [5, 10, 15, 20]) 45 >>> max_total_load(3, 3, [5, 10, 15], [20, 25, 30]) 0 >>> max_total_load(3, 3, [25, 25, 25], [20, 20, 20]) 60 >>> max_total_load(2, 4, [15, 20], [10, 15, 20, 25]) 35 >>> max_total_load(4, 2, [5, 10, 15, 20], [10, 10]) 20 >>> max_total_load(3, 3, [10, 20, 30], [10, 20, 30]) 60 >>> max_total_load(1, 1, [50], [50]) 50","solution":"def max_total_load(n, m, machine_capacities, task_loads): Returns the maximum total load that can be processed by the machines. Parameters: n (int): Number of machines m (int): Number of tasks machine_capacities (list of int): Capacities of the machines task_loads (list of int): Load requirements of the tasks Returns: int: The maximum total load that can be processed by the machines machine_capacities.sort(reverse=True) task_loads.sort(reverse=True) i = 0 j = 0 total_load = 0 while i < n and j < m: if task_loads[j] <= machine_capacities[i]: total_load += task_loads[j] i += 1 j += 1 else: j += 1 return total_load"},{"question":"def longest_substring_without_char(s: str, c: str) -> int: Given a string \`s\` consisting of only lowercase alphabetical characters and a character \`c\`, find the length of the longest substring of \`s\` that contains no occurrences of the character \`c\`. >>> longest_substring_without_char(\\"abacabad\\", \\"c\\") 4 >>> longest_substring_without_char(\\"abcabcabc\\", \\"c\\") 2 >>> longest_substring_without_char(\\"abcdef\\", \\"z\\") 6 >>> longest_substring_without_char(\\"cccccc\\", \\"c\\") 0 >>> longest_substring_without_char(\\"a\\", \\"b\\") 1 >>> longest_substring_without_char(\\"a\\", \\"a\\") 0 >>> longest_substring_without_char(\\"\\", \\"a\\") 0","solution":"def longest_substring_without_char(s, c): Returns the length of the longest substring of \`s\` that contains no occurrences of the character \`c\`. max_length = 0 current_length = 0 for char in s: if char == c: max_length = max(max_length, current_length) current_length = 0 else: current_length += 1 # Check the last segment max_length = max(max_length, current_length) return max_length"},{"question":"def count_similar_positions(n: int, s: str) -> int: Counts the number of pairs of indices (i, j) (1 ≤ i < j ≤ n) that are similar. A pair of indices (i, j) is similar if the character at position i can replace the character at position j to make the string a palindrome. >>> count_similar_positions(5, \\"ababa\\") 4 >>> count_similar_positions(1, \\"a\\") 0 >>> count_similar_positions(3, \\"abc\\") 0 >>> count_similar_positions(4, \\"aaaa\\") 6 >>> count_similar_positions(5, \\"aabaa\\") 6","solution":"def count_similar_positions(n, s): Counts the number of pairs of indices (i, j) (1 ≤ i < j ≤ n) that are similar. A pair of indices (i, j) is similar if the character at position i can replace the character at position j to make the string a palindrome. :param n: Length of the string s :param s: The string of lowercase Latin letters :return: The number of similar pairs if n == 1: return 0 count = 0 counter = {} for char in s: if char in counter: counter[char] += 1 else: counter[char] = 1 for char, freq in counter.items(): if freq > 1: count += freq * (freq - 1) // 2 return count"},{"question":"def max_subset_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum sum of node values you can obtain by selecting a subset of nodes such that no two selected nodes are directly connected by an edge in a tree with n nodes. >>> max_subset_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 11 >>> max_subset_sum(1, [10], []) 10 >>> max_subset_sum(4, [1, 2, 3, 4], [(1, 2), (1, 3), (3, 4)]) 6 >>> max_subset_sum(3, [1000000000, 1000000000, 1000000000], [(1, 2), (1, 3)]) 2000000000 >>> max_subset_sum(3, [1, 2, 3], [(1, 2), (2, 3)]) 4 >>> max_subset_sum(4, [4, 1, 1, 1], [(1, 2), (1, 3), (1, 4)]) 4","solution":"def max_subset_sum(n, values, edges): from collections import defaultdict, deque # Construct the adjacency list for the tree adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Dynamic programming arrays include = [0] * (n + 1) exclude = [0] * (n + 1) # Depth-first search to populate include and exclude arrays def dfs(node, parent): include[node] = values[node - 1] # Node is 1-indexed in problem description for neighbor in adj_list[node]: if neighbor != parent: dfs(neighbor, node) include[node] += exclude[neighbor] exclude[node] += max(include[neighbor], exclude[neighbor]) # Start DFS from the root node (1) dfs(1, -1) # The result is the max value we can get whether we include or exclude the root node return max(include[1], exclude[1])"},{"question":"def find_articulation_points_and_check_connected(n, edges): Determine if a graph is fully connected and find articulation points that would disconnect the graph. Args: n (int): Number of nodes. edges (List[Tuple[int, int]]): List of undirected edges. Returns: Tuple[str, int, List[int]]: \\"Yes\\" or \\"No\\" if all sites are connected, number of articulation points, and a list of critical sites in increasing order. >>> find_articulation_points_and_check_connected(5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) ('Yes', 2, [3, 4]) >>> find_articulation_points_and_check_connected(4, [(1, 2), (3, 4)]) ('No', 0, [])","solution":"def find_articulation_points_and_check_connected(n, edges): from collections import defaultdict def dfs(v, discovery_time, low, visited, parent, articulation_points, adj, time): children = 0 visited[v] = True discovery_time[v] = low[v] = time[0] time[0] += 1 for to in adj[v]: if not visited[to]: parent[to] = v children += 1 dfs(to, discovery_time, low, visited, parent, articulation_points, adj, time) # Check if the subtree rooted at to has a connection back to one of ancestors of v low[v] = min(low[v], low[to]) # (1) v is an articulation point if it is root of DFS tree and has two or more children. if parent[v] is None and children > 1: articulation_points.add(v) # (2) v is an articulation point if it is not root and low value of one of its child is more # than discovery value of v. if parent[v] is not None and low[to] >= discovery_time[v]: articulation_points.add(v) elif to != parent[v]: low[v] = min(low[v], discovery_time[to]) # Construct adjacency list adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Checking connectivity visited = [False] * (n + 1) discovery_time = [float('inf')] * (n + 1) low = [float('inf')] * (n + 1) parent = [None] * (n + 1) articulation_points = set() time = [0] # Perform a DFS from node 1 (assuming nodes are 1-indexed) count = 0 for i in range(1, n + 1): if not visited[i]: dfs(i, discovery_time, low, visited, parent, articulation_points, adj, time) count += 1 connected = count == 1 return \\"Yes\\" if connected else \\"No\\", len(articulation_points), sorted(articulation_points) # The main function that reads input and calls the processing function def main(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) edges = [tuple(map(int, data[i:i+2])) for i in range(2, 2 * m + 2, 2)] is_connected, num_articulation_points, articulation_points = find_articulation_points_and_check_connected(n, edges) print(is_connected) print(num_articulation_points) if num_articulation_points > 0: print(\\" \\".join(map(str, articulation_points)))"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Returns the number of distinct palindromic substrings in the string s. >>> count_distinct_palindromic_substrings('a') 1 >>> count_distinct_palindromic_substrings('abc') 3 >>> count_distinct_palindromic_substrings('aaa') 3 >>> count_distinct_palindromic_substrings('ababa') 5 >>> count_distinct_palindromic_substrings('abcd') 4 >>> count_distinct_palindromic_substrings('racecar') 7 >>> count_distinct_palindromic_substrings('abacdfgdcaba') 7","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the string s. n = len(s) dp = [[False] * n for _ in range(n)] palindromic_substrings = set() for length in range(1, n + 1): # length of substring for start in range(n - length + 1): # starting index of substring end = start + length - 1 # ending index of substring if length == 1: dp[start][end] = True elif length == 2: dp[start][end] = (s[start] == s[end]) else: dp[start][end] = (s[start] == s[end]) and dp[start + 1][end - 1] if dp[start][end]: palindromic_substrings.add(s[start:end + 1]) return len(palindromic_substrings)"},{"question":"def min_removals_to_palindrome(s: str) -> int: Returns the minimum number of removals required to make the string a palindrome. >>> min_removals_to_palindrome('abcba') 0 >>> min_removals_to_palindrome('abcd') 3 >>> min_removals_to_palindrome('abbca') 1 >>> min_removals_to_palindrome('a') 0 >>> min_removals_to_palindrome('aa') 0 >>> min_removals_to_palindrome('ab') 1 >>> min_removals_to_palindrome('abcebba') 2 >>> min_removals_to_palindrome('abecdeca') 3","solution":"def min_removals_to_palindrome(s): Returns the minimum number of removals required to make the string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for _ in range(n)] for _ in range(n)] # Build the table. The bottom-up approach is used here. for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] else: dp[l][r] = 1 + min(dp[l + 1][r], dp[l][r - 1]) # The value at dp[0][n-1] will be our answer. return dp[0][n-1]"},{"question":"def min_operations_to_convert(s: str, t: str) -> int: Determine the minimum number of operations required to convert string s into string t. The allowed operations are: insert a character, delete a character, or replace a character. Args: s (str): the original string t (str): the target string Returns: int: the minimum number of operations required to convert s into t Examples: >>> min_operations_to_convert(\\"abcdef\\", \\"azced\\") 3 >>> min_operations_to_convert(\\"sunday\\", \\"saturday\\") 3","solution":"def min_operations_to_convert(s, t): Returns the minimum number of operations required to convert string s into string t. Operations allowed are insert, delete and replace a character. m, n = len(s), len(t) # Create a 2D array dp where dp[i][j] represents the minimum number of operations to convert # the first i characters of s to the first j characters of t. dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp for transformations from empty string for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, insert all characters from t elif j == 0: dp[i][j] = i # If t is empty, delete all characters from s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are the same, ignore last char else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def longest_path_in_grid(n: int, m: int, grid: List[str]) -> int: Find the length of the longest valid path from the top-left corner (1,1) to the bottom-right corner (n,m) only moving right or down and visiting each cell at most once. >>> longest_path_in_grid(5, 5, [\\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"]) 9 >>> longest_path_in_grid(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"]) -1 >>> longest_path_in_grid(1, 1, [\\".\\"]) 1 >>> longest_path_in_grid(2, 2, [\\"#.\\", \\"..\\"]) -1 >>> longest_path_in_grid(2, 2, [\\"..\\", \\".#\\"]) -1","solution":"def longest_path_in_grid(n, m, grid): Find the length of the longest valid path from the top-left corner (1,1) to the bottom-right corner (n,m) only moving right or down and visiting each cell at most once. # If the starting or ending cell is an obstacle, return -1 immediately. if grid[0][0] == '#' or grid[-1][-1] == '#': return -1 # Initialize a dp array with -1 dp = [[-1] * m for _ in range(n)] dp[0][0] = 1 # Starting cell # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == '#': continue if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + 1) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + 1) # Return the value at the bottom-right corner cell return dp[-1][-1]"},{"question":"def min_time_to_complete_forts(n: int, k: int, times: List[int]) -> int: Determines the minimum time required to complete at least k forts. :param n: Number of units :param k: Minimum number of forts required :param times: List of times to complete building forts in each zone :return: Minimum possible time to complete at least k forts, or -1 if not possible >>> min_time_to_complete_forts(3, 2, [2, 5, 7]) 5 >>> min_time_to_complete_forts(4, 3, [2, 3, 4, 7]) 4 >>> min_time_to_complete_forts(2, 3, [1, 2]) -1 >>> min_time_to_complete_forts(5, 5, [5, 10, 2, 8, 3]) 10 >>> min_time_to_complete_forts(1, 1, [10]) 10 >>> min_time_to_complete_forts(6, 4, [1, 3, 5, 7, 9, 11]) 7 pass","solution":"def min_time_to_complete_forts(n, k, times): Determines the minimum time required to complete at least k forts. :param n: Number of units :param k: Minimum number of forts required :param times: List of times to complete building forts in each zone :return: Minimum possible time to complete at least k forts, or -1 if not possible if k > n: return -1 times.sort() return times[k - 1]"},{"question":"def themed_photo_albums(t: int, testcases: List[Tuple[int, List[int]]]) -> List[List[int]]: This function processes multiple test cases and for each test case, returns the arrangement of photographs that minimizes the differences between the positions of consecutive photographs. Args: t: int - number of test cases testcases: list of tuples - each tuple contains the number of photographs 'n' and a list of photograph costs Returns: A list of lists of integers, where each list represents the arrangement of photographs for a test case. >>> themed_photo_albums(2, [(5, [4, 2, 1, 3, 5]), (4, [7, 3, 2, 8])]) [[1, 2, 3, 4, 5], [2, 3, 7, 8]]","solution":"def minimize_diff(arr): This function takes a list of integers arr and returns a new list where the differences between the positions of consecutive elements are minimized by sorting the array. return sorted(arr) def themed_photo_albums(t, testcases): This function processes multiple test cases and for each test case returns the arrangement of photographs that minimizes the differences between the positions of consecutive photographs. t: int - number of test cases testcases: list of tuples - each tuple contains the number of photographs 'n' and a list of photograph costs results = [] for n, photographs in testcases: result = minimize_diff(photographs) results.append(result) return results"},{"question":"from collections import deque def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determines the minimum number of moves required for Mina to reach the bottom-right corner from the top-left corner of the grid, or returns -1 if it is not possible. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): 2D grid represented as a list of strings where '.' denotes an empty cell and '#' denotes an obstacle. Returns: int: Minimum number of moves required or -1 if it is not possible. >>> min_moves_to_reach_end(5, 5, [ ... \\".....\\", ... \\"..#..\\", ... \\".....\\", ... \\".#...\\", ... \\"...#.\\" ... ]) == 8 >>> min_moves_to_reach_end(3, 3, [ ... \\"#\\", ... \\"#.#\\", ... \\"#\\" ... ]) == -1 >>> min_moves_to_reach_end(3, 3, [ ... \\"...\\", ... \\".#.\\", ... \\"...\\" ... ]) == 4 >>> min_moves_to_reach_end(3, 3, [ ... \\"..#\\", ... \\"#..\\", ... \\"..#\\" ... ]) == -1 >>> min_moves_to_reach_end(3, 3, [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ]) == 4 >>> min_moves_to_reach_end(1, 1, [ ... \\".\\" ... ]) == 0 >>> min_moves_to_reach_end(1, 1, [ ... \\"#\\" ... ]) == -1","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): Determines the minimum number of moves required for Mina to reach the bottom-right corner from the top-left corner of the grid, or returns -1 if it is not possible. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): 2D grid represented as a list of strings where '.' denotes an empty cell and '#' denotes an obstacle. Returns: int: Minimum number of moves required or -1 if it is not possible. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up start = (0, 0) end = (n-1, m-1) if grid[0][0] == '#' or grid[end[0]][end[1]] == '#': return -1 queue = deque([(start, 0)]) # (position, moves) visited = set([start]) while queue: (curr_x, curr_y), moves = queue.popleft() if (curr_x, curr_y) == end: return moves for dx, dy in directions: next_x, next_y = curr_x + dx, curr_y + dy if 0 <= next_x < n and 0 <= next_y < m and (next_x, next_y) not in visited and grid[next_x][next_y] == '.': visited.add((next_x, next_y)) queue.append(((next_x, next_y), moves + 1)) return -1"},{"question":"def max_batches(n: int, available: List[int], required: List[int]) -> int: Determine the maximum number of complete batches of cookies Maria can make with her available ingredients. :param n: number of different ingredients :param available: list containing the amount of each ingredient available :param required: list containing the amount of each ingredient required for one batch :return: maximum number of complete batches of cookies >>> max_batches(2, [5, 10], [2, 5]) 2 >>> max_batches(3, [6, 8, 10], [2, 4, 4]) 2 >>> max_batches(1, [10], [2]) 5 >>> max_batches(1, [1], [2]) 0 >>> max_batches(4, [10, 9, 8, 7], [1, 3, 2, 1]) 3 >>> max_batches(3, [100, 100, 100], [10, 20, 5]) 5","solution":"def max_batches(n, available, required): return min(available[i] // required[i] for i in range(n))"},{"question":"def largest_distance(nums: List[int], k: int) -> int: Returns the largest distance between any two distinct elements in the array that are at least k positions away. If no such pair exists, return -1. >>> largest_distance([1, 3, 1, 1, 8], 2) == 7 >>> largest_distance([1, 2], 2) == -1 >>> largest_distance([5, 5, 5, 5, 5], 1) == 0 >>> largest_distance([1, 2, 1, 3, 4, 5], 5) == 4 >>> largest_distance([1, 5, 1, 1, 10], 3) == 9 >>> largest_distance([-10, -5, 0, 5, 10], 1) == 20 >>> largest_distance([1, 0, 0, 0, 4], 4) == 3 >>> largest_distance([1, -1], 1) == 2","solution":"def largest_distance(nums, k): Returns the largest distance between any two distinct elements in the array that are at least k positions away. If no such pair exists, return -1. max_distance = -1 n = len(nums) for i in range(n): for j in range(i + k, n): max_distance = max(max_distance, abs(nums[i] - nums[j])) return max_distance"},{"question":"def calculate_teg(n, segment_lengths, elevation_changes): Calculate the Total Elevation Gain (TEG) for Alice's jogging route. Parameters: n (int): The number of segments in the route. segment_lengths (list of int): The lengths of the segments. elevation_changes (list of int): The elevation changes of the corresponding segments. Returns: int: The total elevation gain. pass # Example usage n = 5 segment_lengths = [3, 4, 2, 1, 5] elevation_changes = [-1, 2, 3, -2, 1] print(calculate_teg(n, segment_lengths, elevation_changes)) # Expected Output: 6","solution":"def calculate_teg(n, segment_lengths, elevation_changes): Calculate the Total Elevation Gain (TEG) for Alice's jogging route. Parameters: n (int): The number of segments in the route. segment_lengths (list of int): The lengths of the segments. elevation_changes (list of int): The elevation changes of the corresponding segments. Returns: int: The total elevation gain. teg = 0 for elevation_change in elevation_changes: if elevation_change > 0: teg += elevation_change return teg # Example usage n = 5 segment_lengths = [3, 4, 2, 1, 5] elevation_changes = [-1, 2, 3, -2, 1] print(calculate_teg(n, segment_lengths, elevation_changes)) # Output: 6"},{"question":"def longest_increasing_subsequence(arrays: List[List[int]]) -> List[int]: You are given an array of integers. Your task is to determine the longest increasing subsequence (LIS) that can be formed in the array. However, the twist is that the subsequence must be strictly increasing in terms of both value and index. Parameters: arrays (List[List[int]]): A list of lists where each inner list represents the array of integers for a test case. Returns: List[int]: A list of integers where each element represents the length of the longest increasing subsequence for the corresponding test case. Example: >>> longest_increasing_subsequence([[2, 3, 1, 7, 6], [4, 10, 4, 3]]) [3, 2] >>> longest_increasing_subsequence([[5], [10], [3]]) [1, 1, 1] >>> longest_increasing_subsequence([[5, 4, 3, 2, 1]]) [1] >>> longest_increasing_subsequence([[8, 8, 8, 8, 8]]) [1] >>> longest_increasing_subsequence([[8, 2, 3, 6, 1], [1, 2, 3, 4], [7, 1, 5, 3, 2, 6]]) [3, 4, 3] >>> longest_increasing_subsequence([list(range(1, 101))]) [100]","solution":"def longest_increasing_subsequence(arrays): def lis_length(arr): if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j] and i > j: dp[i] = max(dp[i], dp[j] + 1) return max(dp) results = [] for arr in arrays: results.append(lis_length(arr)) return results def parse_input(input_lines): input_iter = iter(input_lines) t = int(next(input_iter)) arrays = [] for _ in range(t): data = list(map(int, next(input_iter).split())) arrays.append(data[1:]) return arrays def main(input_lines): arrays = parse_input(input_lines) results = longest_increasing_subsequence(arrays) return results"},{"question":"from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Given a list of integers and a sliding window size k, this function returns an array of the maximum values for each sliding window. Args: nums: List[int] -> A list of integers. k: int -> The size of the sliding window. Returns: List[int] -> A list of integers representing the maximum values of each sliding window. Examples: >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([5], 1) [5] def test_max_sliding_window(): assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] assert max_sliding_window([5], 1) == [5] assert max_sliding_window([2, 2, 2, 2, 2], 3) == [2, 2, 2] assert max_sliding_window([5, 4, 3, 2, 1], 2) == [5, 4, 3, 2] assert max_sliding_window([1, 2, 3, 4, 5], 2) == [2, 3, 4, 5] assert max_sliding_window([-1, -3, -6, -2, -5], 3) == [-1, -2, -2] assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 8) == [7] assert max_sliding_window([4, 3, 2, 1, 5, 6, 7, 8], 1) == [4, 3, 2, 1, 5, 6, 7, 8]","solution":"from collections import deque def max_sliding_window(nums, k): Given a list of integers and a sliding window size k, this function returns an array of the maximum values for each sliding window. n = len(nums) if n * k == 0: return [] if k == 1: return nums def clean_deque(i): # Remove indexes that are out of bounds if deq and deq[0] == i - k: deq.popleft() # Remove indexes of elements which are not useful while deq and nums[i] > nums[deq[-1]]: deq.pop() # Initialize the deque and the output deq = deque() max_index = 0 for i in range(k): clean_deque(i) deq.append(i) # Compute max in nums[:k] if nums[i] > nums[max_index]: max_index = i output = [nums[max_index]] # Build output for i in range(k, n): clean_deque(i) deq.append(i) output.append(nums[deq[0]]) return output"},{"question":"def card_game_winner(t: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[str]: Determines the winner of a card game between Alice and Bob or if it is a tie. >>> card_game_winner(2, [(3, 3, [5, 3, 7], [6, 2, 4]), (4, 2, [9, 7, 6, 5], [8, 4])]) [\\"Alice\\", \\"Alice\\"] >>> card_game_winner(1, [(3, 3, [1, 2, 3], [3, 2, 1])]) [\\"Tie\\"] >>> card_game_winner(1, [(2, 2, [10, 5], [6, 4])]) [\\"Alice\\"] >>> card_game_winner(1, [(3, 3, [7, 8, 9], [10, 5, 2])]) [\\"Bob\\"] >>> card_game_winner(1, [(1, 1, [5], [5])]) [\\"Tie\\"]","solution":"def card_game_winner(t, test_cases): results = [] for case in test_cases: n, m, alice_cards, bob_cards = case while alice_cards and bob_cards: alice_card = alice_cards.pop(0) bob_card = bob_cards.pop(0) if alice_card > bob_card: alice_cards.append(alice_card) alice_cards.append(bob_card) elif bob_card > alice_card: bob_cards.append(bob_card) bob_cards.append(alice_card) if alice_cards and not bob_cards: results.append(\\"Alice\\") elif not alice_cards and bob_cards: results.append(\\"Bob\\") else: results.append(\\"Tie\\") return results"},{"question":"def largest_landmass(grid): Determines the size of the largest connected landmass in the city grid. Args: grid (List[List[str]]): A 2D grid representing land ('1') and water ('0'). Returns: int: The size of the largest connected landmass. >>> largest_landmass([['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]) 4 >>> largest_landmass([['1']]) 1 pass def parse_input_and_find_largest_landmass(input_str): Parses the input string and finds the size of the largest connected landmass. Args: input_str (str): The input string representing the grid dimensions and cells. Returns: int: The size of the largest connected landmass. >>> parse_input_and_find_largest_landmass(\\"4 5n11000n11000n00100n00011\\") 4 >>> parse_input_and_find_largest_landmass(\\"1 1n1\\") 1 pass","solution":"def largest_landmass(grid): n = len(grid) m = len(grid[0]) if n > 0 else 0 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '0': return 0 grid[x][y] = '0' # Mark the cell as visited size = 1 size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_landmass = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': max_landmass = max(max_landmass, dfs(i, j)) return max_landmass def parse_input_and_find_largest_landmass(input_str): lines = input_str.strip().split(\\"n\\") n, m = map(int, lines[0].split()) grid = [list(lines[i+1].strip()) for i in range(n)] return largest_landmass(grid)"},{"question":"def bfs(farthest_node, graph, n): Perform BFS and find the farthest node with its distance from a given node. ... def find_optimal_city(n, roads): Find the optimal city to be the capital by minimizing the maximum distance to any other city. ... def solve(test_cases): Solve multiple test cases. ... def main(): Main function to read input and provide output. ... # Unit tests def test_case_1(): assert solve([(4, [(1, 2), (1, 3), (3, 4)])]) == [3] def test_case_2(): assert solve([(4, [(1, 2), (1, 3), (2, 4)])]) == [2] def test_case_3(): assert solve([(1, [])]) == [1] # Single city case def test_case_4(): assert solve([(3, [(1, 2), (2, 3)])]) == [2] def test_case_5(): assert solve([(6, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)])]) == [2] def test_input_output(capsys): import sys from io import StringIO test_input = \\"2n4n1 2n1 3n3 4n4n1 2n1 3n2 4n\\" sys.stdin = StringIO(test_input) main() captured = capsys.readouterr() assert captured.out == \\"3n2n\\" if __name__ == \\"__main__\\": main()","solution":"from collections import deque def bfs(farthest_node, graph, n): Perform BFS and find the farthest node with its distance from a given node. dist = [-1] * (n + 1) queue = deque([farthest_node]) dist[farthest_node] = 0 max_dist = 0 node = farthest_node while queue: current = queue.popleft() for neighbor in graph[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + 1 queue.append(neighbor) if dist[neighbor] > max_dist: max_dist = dist[neighbor] node = neighbor return node, max_dist def find_optimal_city(n, roads): Find the optimal city to be the capital by minimizing the maximum distance to any other city. if n == 1: return 1 # Create graph from roads graph = [[] for _ in range(n + 1)] for u, v in roads: graph[u].append(v) graph[v].append(u) # Step 1: Find the farthest node from any starting node (node 1 in this case) farthest_node, _ = bfs(1, graph, n) # Step 2: Find the farthest node from the previously found farthest node opposite_node, max_dist = bfs(farthest_node, graph, n) # Step 3: Find the optimal city which will be the mid-point in the longest path found in the tree mid_dist = max_dist // 2 queue = deque([farthest_node]) dist = [-1] * (n + 1) dist[farthest_node] = 0 while queue: current = queue.popleft() for neighbor in graph[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + 1 queue.append(neighbor) if dist[neighbor] == mid_dist: return neighbor def solve(test_cases): Solve multiple test cases. results = [] for test_case in test_cases: n, roads = test_case results.append(find_optimal_city(n, roads)) return results # Helper function for input/output def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) index += 1 roads = [] for _ in range(n - 1): u = int(data[index]) v = int(data[index + 1]) roads.append((u, v)) index += 2 test_cases.append((n, roads)) results = solve(test_cases) for result in results: print(result)"},{"question":"def free_coffees(n: int, k: int, visits: List[int]) -> int: Given the number of visits and the threshold k, return the number of free coffees earned. >>> free_coffees(10, 3, [1, 3, 7, 8, 9, 13, 15, 16, 17, 18]) 3 >>> free_coffees(5, 10, [1, 2, 3, 4, 5]) 0 >>> free_coffees(10, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> free_coffees(13, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) 3 >>> free_coffees(9, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 3 >>> free_coffees(10, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1 >>> free_coffees(1, 1, [1000]) 1 >>> free_coffees(1, 2, [1000]) 0","solution":"def free_coffees(n, k, visits): Given the number of visits and the threshold k, return the number of free coffees earned. :param n: int, number of visits :param k: int, number of visits required for a free coffee :param visits: list of int, timestamps of the visits :return: int, number of free coffees earned # Total free coffees is the number of complete groups of k visits return n // k"},{"question":"def can_sum_to_target(nums: List[int], target: int) -> str: Determine if it is possible to find a subset of the list such that the sum of the subset equals the target number. >>> can_sum_to_target([1, 2, 3, 4, 5], 9) == \\"YES\\" >>> can_sum_to_target([1, 2, 5], 7) == \\"YES\\" >>> can_sum_to_target([-1, -2, 3, 1], 0) == \\"YES\\" >>> can_sum_to_target([1, 2, 3], 0) == \\"NO\\" pass def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Process multiple test cases to determine if a subset with the given target sum exists in each case. >>> test_cases = [(5, 9, [1, 2, 3, 4, 5]), (3, 7, [1, 2, 5]), (4, 0, [-1, -2, 3, 1])] >>> process_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_sum_to_target(nums, target): # Dynamic programming approach with memoization n = len(nums) dp = {0} for num in nums: new_dp = dp.copy() for x in dp: new_sum = x + num if new_sum == target: return \\"YES\\" new_dp.add(new_sum) dp = new_dp return \\"NO\\" def process_test_cases(test_cases): results = [] for n, k, nums in test_cases: results.append(can_sum_to_target(nums, k)) return results"},{"question":"def count_combinations(n: int, k: int) -> int: Returns the number of distinct combinations of wins, draws, and losses to achieve exactly k points in at most n games. >>> count_combinations(3, 3) 2 >>> count_combinations(5, 0) 1 >>> count_combinations(0, 0) 1 >>> count_combinations(4, 12) 1 >>> count_combinations(2, 5) 0 >>> count_combinations(4, 4) 2 >>> count_combinations(100, 300) 1 >>> count_combinations(10, 31) 0","solution":"def count_combinations(n, k): Returns the number of distinct combinations of wins, draws, and losses to achieve exactly k points in at most n games. count = 0 for wins in range(n + 1): for draws in range(n + 1 - wins): losses = n - wins - draws points = wins * 3 + draws * 1 if points == k: count += 1 return count"},{"question":"from typing import List, Tuple, Union def seating_arrangement(n: int, m: int, dislikes: List[Tuple[int, int]]) -> Union[List[int], str]: Determine if it is possible to arrange all the guests in a single line such that no two guests in a given pair are adjacent. If such an arrangement is possible, output any one valid arrangement. Otherwise, output \\"IMPOSSIBLE\\". >>> seating_arrangement(5, 3, [(1, 2), (2, 3), (4, 5)]) [1, 3, 2, 4, 5] >>> seating_arrangement(3, 3, [(1, 2), (2, 3), (1, 3)]) 'IMPOSSIBLE'","solution":"from collections import defaultdict, deque def seating_arrangement(n, m, dislikes): dislike_graph = defaultdict(list) for a, b in dislikes: dislike_graph[a].append(b) dislike_graph[b].append(a) color = {} # Try to color the graph using two colors (0 and 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: v = queue.popleft() for neighbor in dislike_graph[v]: if neighbor in color: if color[neighbor] == color[v]: return False else: color[neighbor] = 1 - color[v] queue.append(neighbor) return True for guest in range(1, n + 1): if guest not in color: if not bfs(guest): return \\"IMPOSSIBLE\\" # Separate guests into two groups based on their color group_0 = [guest for guest in range(1, n + 1) if color[guest] == 0] group_1 = [guest for guest in range(1, n + 1) if color[guest] == 1] # Return one of the valid arrangements by combining both groups return group_0 + group_1 # Example usage n = 5 m = 3 dislikes = [(1, 2), (2, 3), (4, 5)] print(seating_arrangement(n, m, dislikes)) # Output should be a valid arrangement or \\"IMPOSSIBLE\\""},{"question":"def communication_clusters(n: int) -> Tuple[int, int]: Given the number of computers n, this function returns the minimal number of communication clusters and the minimal number of direct communications required to ensure all computers in the network can communicate with each other. >>> communication_clusters(1) (1, 0) >>> communication_clusters(2) (1, 1) >>> communication_clusters(3) (1, 2) >>> communication_clusters(5) (1, 4) >>> communication_clusters(1000) (1, 999) >>> communication_clusters(4) (1, 3) >>> communication_clusters(10) (1, 9)","solution":"def communication_clusters(n): Given the number of computers n, this function returns the minimal number of communication clusters and the minimal number of direct communications required to ensure all computers in the network can communicate with each other. # The network forms a single communication cluster clusters = 1 # For n computers, we need n-1 connections to form a single fully connected cluster cables = n - 1 return clusters, cables"},{"question":"def max_distinct_problems(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of distinct problems Sancho can solve given the contest rules. >>> max_distinct_problems(3, [(5, [1, 2, 2, 3, 3]), (4, [4, 4, 4, 4]), (6, [5, 6, 7, 8, 8, 8])]) [3, 1, 4] >>> max_distinct_problems(1, [(5, [10, 10, 10, 10, 1])]) [2]","solution":"def max_distinct_problems(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] problems = test_cases[i][1] distinct_problems = len(set(problems)) results.append(distinct_problems) return results"},{"question":"def min_jumps(n: int, k: int, heights: List[int]) -> int: Given an array of integers, A, representing the heights of students, find the minimum number of jumps required to move from the first student to the last student in the array. Each student can jump to the right up to 'k' students ahead, but can only land on a student who is taller than the current student. If it is impossible for the student to reach the last student, return -1. :param n: int - The number of students :param k: int - The maximum number of students the current student can jump ahead :param heights: List[int] - List of heights of the students :return: int - Minimum number of jumps required to reach the last student, or -1 if impossible >>> min_jumps(5, 2, [1, 2, 3, 2, 4]) 2 >>> min_jumps(6, 2, [4, 3, 2, 5, 1, 2]) -1","solution":"def min_jumps(n, k, heights): Function to find the minimum number of jumps needed to go from the first student to the last student. :param n: int - The number of students :param k: int - The maximum number of students the current student can jump ahead :param heights: List[int] - List of heights of the students :return: int - Minimum number of jumps required to reach the last student, or -1 if impossible dp = [float('inf')] * n dp[0] = 0 for i in range(n): for j in range(1, k + 1): if i + j < n and heights[i + j] > heights[i]: dp[i + j] = min(dp[i + j], dp[i] + 1) return dp[-1] if dp[-1] != float('inf') else -1"},{"question":"def coding_contest(n: int, e: int, initial_scores: List[int], events: List[str]) -> List[List[int]]: Simulate a coding contest and respond to events affecting participants' scores. Parameters: n (int): The number of participants. e (int): The number of events. initial_scores (List[int]): The initial scores for each participant. events (List[str]): A list of events, where each event is either a score update or a query. Returns: List[List[int]]: For each query, the current top k participants' scores, sorted in descending order. >>> coding_contest(4, 3, [4, 2, 10, 8], [\\"1 3 5\\", \\"1 4 2\\", \\"2 2\\"]) [[15, 10]] >>> coding_contest(4, 5, [10, 20, 30, 15], [\\"1 2 10\\", \\"1 4 10\\", \\"2 3\\", \\"1 3 10\\", \\"2 2\\"]) [[30, 30, 25], [40, 30]]","solution":"def coding_contest(n, e, initial_scores, events): scores = initial_scores[:] outputs = [] for event in events: parts = event.split() if parts[0] == \\"1\\": p = int(parts[1]) - 1 x = int(parts[2]) scores[p] += x elif parts[0] == \\"2\\": k = int(parts[1]) top_k_scores = sorted( [(i + 1, scores[i]) for i in range(n)], key=lambda x: (-x[1], x[0]) )[:k] outputs.append([score for idx, score in top_k_scores]) return outputs"},{"question":"def minimum_changes_to_decorate(n: int, k: int, colors: List[int]) -> int: Determine the minimum number of changes needed to ensure no two adjacent segments have the same color, by changing at most one segment's color. Args: n : int : the number of segments k : int : the number of workers colors : List[int] : list of integers representing the colors of the segments Returns: int : the minimum number of changes needed, or -1 if it is impossible to meet the criteria by modifying at most one segment. >>> minimum_changes_to_decorate(5, 3, [1, 2, 2, 3, 4]) 1 >>> minimum_changes_to_decorate(3, 2, [1, 2, 3]) 0 >>> minimum_changes_to_decorate(4, 2, [1, 1, 1, 1]) -1 >>> minimum_changes_to_decorate(2, 2, [1, 1]) 1 >>> minimum_changes_to_decorate(2, 2, [1, 2]) 0 >>> minimum_changes_to_decorate(5, 2, [1, 1, 1, 1, 1]) -1 >>> minimum_changes_to_decorate(5, 2, [1, 2, 2, 2, 1]) -1","solution":"def minimum_changes_to_decorate(n, k, colors): adjacent_same_count = 0 for i in range(n - 1): if colors[i] == colors[i + 1]: adjacent_same_count += 1 if adjacent_same_count == 0: return 0 if adjacent_same_count == 1: return 1 return -1"},{"question":"import heapq from typing import List, Tuple, Union def find_shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> Union[int, str]: Determine the shortest travel time between two specified cities. Parameters: n (int): Number of cities. m (int): Number of roads. edges (List[Tuple[int, int, int]]): List of roads represented as tuples (u, v, t). start (int): Source city. end (int): Destination city. Returns: Union[int, str]: The shortest travel time or \\"NO PATH\\" if no path exists. >>> find_shortest_path(5, 7, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 2, 3), (2, 4, 1), (4, 5, 4), (3, 5, 7)], 1, 5) 12 >>> find_shortest_path(5, 3, [(1, 2, 10), (2, 3, 5), (4, 5, 7)], 1, 5) 'NO PATH' # Implementation here...","solution":"import heapq def find_shortest_path(n, m, edges, start, end): # Create the graph using adjacency list representation graph = {i: [] for i in range(1, n + 1)} for u, v, t in edges: graph[u].append((v, t)) # Use Dijkstra's algorithm to find the shortest path pq = [(0, start)] # (distance, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the end node, return the distance if current_node == end: return current_distance # If the current_distance is greater than recorded, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If the end node is still unreachable, return \\"NO PATH\\" return \\"NO PATH\\" if distances[end] == float('inf') else distances[end]"},{"question":"from typing import List def max_value_in_subgrid(grid: List[List[int]], queries: List[List[int]]) -> List[int]: Given a grid and a set of queries, each defined by two pairs of coordinates, return the largest value in each subgrid. Args: grid: A 2D list representing the grid of values. queries: A list of queries, where each query consists of four integers representing the top-left and bottom-right corners of the rectangle. Returns: A list of integers, each representing the maximum value found in the specified subgrid for each query. Examples: >>> grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] >>> queries = [ [1, 1, 3, 3], [2, 2, 5, 5] ] >>> max_value_in_subgrid(grid, queries) [13, 25] pass def process_input(n: int, m: int, q: int, grid_input: List[str], queries_input: List[str]) -> List[int]: Process input to extract the grid and queries, and then compute the maximum values using the max_value_in_subgrid function. Args: n: Number of rows in the grid. m: Number of columns in the grid. q: Number of queries. grid_input: List of strings representing the rows of the grid. queries_input: List of strings representing the queries. Returns: A list of integers representing the maximum value found in the specified subgrid for each query. Examples: >>> n, m, q = 5, 5, 2 >>> grid_input = [ \\"1 2 3 4 5\\", \\"6 7 8 9 10\\", \\"11 12 13 14 15\\", \\"16 17 18 19 20\\", \\"21 22 23 24 25\\" ] >>> queries_input = [ \\"1 1 3 3\\", \\"2 2 5 5\\" ] >>> process_input(n, m, q, grid_input, queries_input) [13, 25] pass # Test cases to validate the solution def test_max_value_in_subgrid_case_1(): grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] queries = [ [1, 1, 3, 3], [2, 2, 5, 5] ] result = max_value_in_subgrid(grid, queries) assert result == [13, 25] def test_max_value_in_subgrid_case_2(): grid = [ [1, 1, 1], [1, 2, 1], [1, 1, 1] ] queries = [ [1, 1, 2, 2], [2, 2, 3, 3] ] result = max_value_in_subgrid(grid, queries) assert result == [2, 2] def test_max_value_in_subgrid_case_3(): grid = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] queries = [ [1, 1, 3, 3], [1, 1, 2, 2], [2, 2, 3, 3] ] result = max_value_in_subgrid(grid, queries) assert result == [9, 9, 5] def test_process_input_general_case(): n, m, q = 5, 5, 2 grid_input = [ \\"1 2 3 4 5\\", \\"6 7 8 9 10\\", \\"11 12 13 14 15\\", \\"16 17 18 19 20\\", \\"21 22 23 24 25\\" ] queries_input = [ \\"1 1 3 3\\", \\"2 2 5 5\\" ] result = process_input(n, m, q, grid_input, queries_input) assert result == [13, 25]","solution":"def max_value_in_subgrid(grid, queries): results = [] for r1, c1, r2, c2 in queries: max_val = -1 for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): max_val = max(max_val, grid[i][j]) results.append(max_val) return results def process_input(n, m, q, grid_input, queries_input): grid = [list(map(int, grid_input[i].split())) for i in range(n)] queries = [list(map(int, queries_input[i].split())) for i in range(q)] return max_value_in_subgrid(grid, queries)"},{"question":"def max_package_value(n: int, W: int, packages: List[Tuple[int, int]]) -> int: Returns the maximum value of packages that can be delivered by the drone without exceeding the weight limit W. Parameters: n (int): Number of packages W (int): Maximum weight capacity of the drone packages (List[Tuple[int, int]]): List of tuples where each tuple contains two integers, weight and value of a package Returns: int: Maximum total value of packages the drone can deliver >>> max_package_value(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90 >>> max_package_value(1, 10, [(5, 10)]) 10 >>> max_package_value(1, 10, [(15, 10)]) 0 >>> max_package_value(4, 7, [(1, 1), (2, 2), (3, 3), (4, 4)]) 7 >>> max_package_value(3, 5, [(1, 10), (2, 10), (3, 10)]) 20 >>> max_package_value(3, 5, [(10, 20), (15, 30), (25, 40)]) 0 >>> max_package_value(2, 2000000, [(1000000, 1000000), (2000000, 2000000)]) 2000000 >>> max_package_value(3, 100, [(34, 25), (56, 34), (24, 45)]) 79","solution":"def max_package_value(n, W, packages): Returns the maximum value of packages that can be delivered by the drone without exceeding the weight limit W. Parameters: n (int): Number of packages W (int): Maximum weight capacity of the drone packages (List[Tuple[int, int]]): List of tuples where each tuple contains two integers, weight and value of a package Returns: int: Maximum total value of packages the drone can deliver # Initialize the array to store the maximum value for each weight capacity dp = [0] * (W + 1) for weight, value in packages: # We need to update the dp array in reverse order to avoid overwriting previous results needed for calculations for current_weight in range(W, weight - 1, -1): dp[current_weight] = max(dp[current_weight], dp[current_weight - weight] + value) return max(dp) # Example usage: # packages = [(5, 10), (4, 40), (6, 30), (3, 50)] # print(max_package_value(4, 10, packages)) # Output: 90"},{"question":"def find_symmetrical_pairs(x: int, y: int) -> List[Tuple[int, int]]: Given the coordinates of one flower (x, y), find the coordinates of the two possible symmetrical pairs. >>> find_symmetrical_pairs(3, 4) [(-3, 4), (3, -4)] >>> find_symmetrical_pairs(-3, 4) [(3, 4), (-3, -4)]","solution":"def find_symmetrical_pairs(x, y): Given the coordinates of one flower (x, y), find the coordinates of the two possible symmetrical pairs. return [(-x, y), (x, -y)]"},{"question":"def min_reversals_to_sort(n: int, arr: List[int]) -> int: Returns the minimum number of subarray reversals needed to sort the array in non-decreasing order. >>> min_reversals_to_sort(5, [1, 2, 3, 4, 5]) == 0 >>> min_reversals_to_sort(5, [5, 4, 3, 2, 1]) == 1 >>> min_reversals_to_sort(5, [1, 4, 3, 2, 5]) == 1 >>> min_reversals_to_sort(5, [3, 1, 4, 2, 5]) == 2 >>> min_reversals_to_sort(6, [1, 1, 2, 2, 3, 3]) == 0 >>> min_reversals_to_sort(6, [3, 3, 2, 2, 1, 1]) == 1 >>> min_reversals_to_sort(7, [4, 3, 1, 2, 7, 6, 5]) == 2","solution":"def min_reversals_to_sort(n, arr): Returns the minimum number of subarray reversals needed to sort the array in non-decreasing order. sorted_arr = sorted(arr) if arr == sorted_arr: return 0 left_mismatch = 0 while arr[left_mismatch] == sorted_arr[left_mismatch]: left_mismatch += 1 right_mismatch = n - 1 while arr[right_mismatch] == sorted_arr[right_mismatch]: right_mismatch -= 1 if arr[left_mismatch:right_mismatch + 1] == sorted_arr[left_mismatch:right_mismatch + 1][::-1]: return 1 return 2"},{"question":"def smallest_missing_integer(n, k, sequence): Determine the smallest non-negative integer that does not appear in any contiguous subarray of length k within the sequence. Args: n (int): The length of the sequence. k (int): The length of the subarrays. sequence (List[int]): The sequence of integers. Returns: int: The smallest non-negative integer not appearing in any subarray of length k. Example: >>> smallest_missing_integer(5, 3, [1, 2, 4, 1, 3]) 0 >>> smallest_missing_integer(5, 3, [0, 1, 2, 3, 4]) 5 from solution import smallest_missing_integer def test_example_case(): # Example case from the question assert smallest_missing_integer(5, 3, [1, 2, 4, 1, 3]) == 0 def test_all_elements_same(): # All elements are the same assert smallest_missing_integer(5, 3, [1, 1, 1, 1, 1]) == 0 def test_all_elements_in_range(): # All elements from 0 to n assert smallest_missing_integer(5, 3, [0, 1, 2, 3, 4]) == 5 def test_some_elements_missing(): # Some elements missing in sequence assert smallest_missing_integer(5, 3, [2, 3, 2, 5, 2]) == 0 def test_empty_subarray(): # Check where a non-zero value must be missing assert smallest_missing_integer(5, 3, [0, 1, 0, 1, 0]) == 2 def test_large_case(): # Large case assert smallest_missing_integer(200000, 1000, list(range(200000))) == 200000","solution":"def smallest_missing_integer(n, k, sequence): Returns the smallest non-negative integer that does not appear in any contiguous subarray of length k within the sequence. from collections import defaultdict # Initialize a set to keep track of existing numbers in the current window current_window_values = set() # Count the occurrences of each number in the current window num_count = defaultdict(int) # Initialize the current window with the first k elements for i in range(k): current_window_values.add(sequence[i]) num_count[sequence[i]] += 1 # Initialize the smallest missing integer missing_integer = 0 # Function to update the missing_integer def update_missing_integer(): nonlocal missing_integer # Loop until we find the smallest missing integer while missing_integer in current_window_values: missing_integer += 1 # Update for the first window update_missing_integer() # Slide the window over the rest of the sequence for i in range(k, n): if sequence[i - k] in num_count: num_count[sequence[i - k]] -= 1 if num_count[sequence[i - k]] == 0: current_window_values.remove(sequence[i - k]) current_window_values.add(sequence[i]) num_count[sequence[i]] += 1 update_missing_integer() return missing_integer"},{"question":"def is_circular_palindrome(s: str) -> str: Determines if the given string is a circular palindrome. >>> is_circular_palindrome(\\"abcba\\") == \\"YES\\" >>> is_circular_palindrome(\\"abcab\\") == \\"NO\\" >>> is_circular_palindrome(\\"a\\") == \\"YES\\" >>> is_circular_palindrome(\\"abccba\\") == \\"YES\\" >>> is_circular_palindrome(\\"aabcb\\") == \\"YES\\" >>> is_circular_palindrome(\\"abcdba\\") == \\"NO\\" >>> is_circular_palindrome(\\"bbabb\\") == \\"YES\\" >>> is_circular_palindrome(\\"ababab\\") == \\"NO\\" >>> is_circular_palindrome(\\"abcbaabcba\\") == \\"YES\\" >>> is_circular_palindrome(\\"abcbaabcbab\\") == \\"YES\\"","solution":"def is_circular_palindrome(s): Determines if the given string is a circular palindrome. s_length = len(s) for i in range(s_length): # Rotate the string by i and check if it is a palindrome rotated_s = s[i:] + s[:i] if rotated_s == rotated_s[::-1]: return \\"YES\\" return \\"NO\\""},{"question":"def is_nice_string(s: str) -> str: Determines if the binary string s can be rearranged to form a \\"nice\\" binary string. A \\"nice\\" binary string requires every substring of even length to have an equal number of 0s and 1s. This is only possible if the counts of '0' and '1' in the string are equal. Args: s (str): The input binary string Returns: str: \\"YES\\" if s can be rearranged to form a nice binary string, otherwise \\"NO\\" >>> is_nice_string(\\"1100\\") \\"YES\\" >>> is_nice_string(\\"101\\") \\"NO\\" def test_even_length_balanced_string(): assert is_nice_string('1100') == \\"YES\\" def test_odd_length_string(): assert is_nice_string('101') == \\"NO\\" def test_all_zeros(): assert is_nice_string('0000') == \\"NO\\" def test_all_ones(): assert is_nice_string('1111') == \\"NO\\" def test_already_balanced_string(): assert is_nice_string('1010') == \\"YES\\" def test_another_even_length_balanced_string(): assert is_nice_string('11001100') == \\"YES\\" def test_more_zeros_than_ones(): assert is_nice_string('00011') == \\"NO\\" def test_more_ones_than_zeros(): assert is_nice_string('11100') == \\"NO\\" def test_large_balanced_string(): assert is_nice_string('0' * 50000 + '1' * 50000) == \\"YES\\" def test_large_unbalanced_string(): assert is_nice_string('0' * 50001 + '1' * 49999) == \\"NO\\"","solution":"def is_nice_string(s): Determines if the binary string s can be rearranged to form a \\"nice\\" binary string. A \\"nice\\" binary string requires every substring of even length to have an equal number of 0s and 1s. This is only possible if the counts of '0' and '1' in the string are equal. Args: s (str): The input binary string Returns: str: \\"YES\\" if s can be rearranged to form a nice binary string, otherwise \\"NO\\" count_0 = s.count('0') count_1 = s.count('1') return \\"YES\\" if count_0 == count_1 else \\"NO\\""},{"question":"def count_unique_integers(s: int, m: int) -> int: Returns the number of unique integers that can be formed by appending and reordering digits from 1 to m exactly once in any order, starting with integer s. The result is given modulo 1000000007. Example: >>> count_unique_integers(4, 3) 24 >>> count_unique_integers(0, 1) 1 >>> count_unique_integers(99, 4) 24 >>> count_unique_integers(10, 5) 120 >>> count_unique_integers(0, 9) 362880","solution":"import math def count_unique_integers(s, m): Returns the number of unique integers that can be formed by appending and reordering digits from 1 to m exactly once in any order, starting with integer s. The result is given modulo 1000000007. MOD = 1000000007 return math.factorial(m) % MOD"},{"question":"class ArrayManipulator: def __init__(self, arr): self.arr = arr self.n = len(arr) self.segment_tree = [0] * (4 * self.n) self.build_segment_tree(0, 0, self.n - 1) def build_segment_tree(self, node, start, end): Build a segment tree for efficient range queries. pass def update(self, idx, value): Update the value at index idx to value. pass def _update(self, node, start, end, idx, value): pass def sum(self, L, R): Return the sum of the subarray from index L to index R (inclusive). pass def _sum(self, node, start, end, L, R): pass def process_queries(n, q, array, queries): Process an array of integers with a series of update and sum queries. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): The initial array of integers. queries (List[str]): The list of queries. Returns: List[int]: Results of the sum queries. Example: >>> process_queries(5, 5, [1, 2, 3, 4, 5], [\\"S 1 3\\", \\"U 3 10\\", \\"S 2 4\\", \\"U 5 -5\\", \\"S 1 5\\"]) [6, 16, 12] manipulator = ArrayManipulator(array) results = [] for query in queries: command = query.split() if command[0] == 'U': _, i, x = command manipulator.update(int(i) - 1, int(x)) elif command[0] == 'S': _, l, r = command result = manipulator.sum(int(l) - 1, int(r) - 1) results.append(result) return results","solution":"class ArrayManipulator: def __init__(self, arr): self.arr = arr self.n = len(arr) self.segment_tree = [0] * (4 * self.n) self.build_segment_tree(0, 0, self.n - 1) def build_segment_tree(self, node, start, end): if start == end: self.segment_tree[node] = self.arr[start] else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self.build_segment_tree(left_node, start, mid) self.build_segment_tree(right_node, mid + 1, end) self.segment_tree[node] = self.segment_tree[left_node] + self.segment_tree[right_node] def update(self, idx, value): self._update(0, 0, self.n - 1, idx, value) def _update(self, node, start, end, idx, value): if start == end: self.arr[idx] = value self.segment_tree[node] = value else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self._update(left_node, start, mid, idx, value) else: self._update(right_node, mid + 1, end, idx, value) self.segment_tree[node] = self.segment_tree[left_node] + self.segment_tree[right_node] def sum(self, L, R): return self._sum(0, 0, self.n - 1, L, R) def _sum(self, node, start, end, L, R): if R < start or end < L: return 0 if L <= start and end <= R: return self.segment_tree[node] mid = (start + end) // 2 left_sum = self._sum(2 * node + 1, start, mid, L, R) right_sum = self._sum(2 * node + 2, mid + 1, end, L, R) return left_sum + right_sum def process_queries(n, q, array, queries): manipulator = ArrayManipulator(array) results = [] for query in queries: command = query.split() if command[0] == 'U': _, i, x = command manipulator.update(int(i) - 1, int(x)) elif command[0] == 'S': _, l, r = command result = manipulator.sum(int(l) - 1, int(r) - 1) results.append(result) return results"},{"question":"def find_last_team(n: int, k: int, m: int, stages_info: List[List[int]]) -> int: Determine the team that finishes last based on the total time taken to complete the race. Parameters: n (int): Number of teams k (int): Number of runners per team m (int): Number of stages stages_info (list of list of ints): Information for each stage. Each element is a list containing the stage length followed by the speeds of runners for all teams. Returns: int: The team number that finishes last. pass if __name__ == \\"__main__\\": from typing import List import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) m = int(data[2]) stages_info = [] index = 3 for _ in range(m): stage_info = [int(data[index])] stage_info.extend(int(data[index+j]) for j in range(1, n + 1)) stages_info.append(stage_info) index += n + 1 print(find_last_team(n, k, m, stages_info)) def test_example(): n, k, m = 3, 2, 4 stages_info = [ [10, 5, 6, 7], [20, 8, 10, 9], [15, 5, 6, 7], [25, 8, 10, 9], ] assert find_last_team(n, k, m, stages_info) == 1 def test_all_same_speed(): n, k, m = 2, 3, 5 stages_info = [ [10, 5, 5], [20, 5, 5], [15, 5, 5], [25, 5, 5], [10, 5, 5] ] assert find_last_team(n, k, m, stages_info) == 1 def test_different_number_of_teams(): n, k, m = 4, 2, 2 stages_info = [ [10, 4, 3, 5, 6], [20, 6, 5, 9, 10], ] assert find_last_team(n, k, m, stages_info) == 2 def test_large_stage_lengths(): n, k, m = 2, 1, 3 stages_info = [ [1000, 10, 5], [2000, 10, 10], [1500, 8, 5] ] assert find_last_team(n, k, m, stages_info) == 2 def test_minimum_input(): n, k, m = 1, 1, 1 stages_info = [ [10, 1] ] assert find_last_team(n, k, m, stages_info) == 1","solution":"def find_last_team(n, k, m, stages_info): Determine the team that finishes last based on the total time taken to complete the race. Parameters: n (int): Number of teams k (int): Number of runners per team m (int): Number of stages stages_info (list of list of ints): Information for each stage. Each element is a list containing the stage length followed by the speeds of runners for all teams. Returns: int: The team number that finishes last. total_times = [0] * n for stage in range(m): length = stages_info[stage][0] for team in range(n): runner_index = stage % k speed = stages_info[stage][team + 1] total_times[team] += length / speed return total_times.index(max(total_times)) + 1"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge overlapping intervals and return a new list of non-overlapping intervals. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]]","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge overlapping intervals and return a new list of non-overlapping intervals. if not intervals: return intervals # Sort intervals by the starting value intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_interval = intervals[0] for i in range(1, len(intervals)): interval = intervals[i] # If the current interval overlaps with the next interval, merge them if current_interval[1] >= interval[0]: current_interval[1] = max(current_interval[1], interval[1]) else: merged_intervals.append(current_interval) current_interval = interval merged_intervals.append(current_interval) return merged_intervals"},{"question":"def minimum_battery_usage(n: int, dust: List[int]) -> int: Calculates the minimum battery usage required for the robotic vacuum cleaner to clean all the rooms and return to the start. Args: n (int): The number of rooms. dust (list): A list of integers representing the amount of dust in each room. Returns: int: The minimum battery usage required. Example: >>> minimum_battery_usage(3, [2, 4, 3]) 18 >>> minimum_battery_usage(1, [5]) 10 pass","solution":"def minimum_battery_usage(n, dust): Calculates the minimum battery usage required for the robotic vacuum cleaner to clean all the rooms and return to the start. Args: n (int): The number of rooms. dust (list): A list of integers representing the amount of dust in each room. Returns: int: The minimum battery usage required. total_dust = sum(dust) return total_dust * 2"},{"question":"def find_shortest_path(n: int, m: int, k: int, current_roads: List[Tuple[int, int, int]], new_roads: List[Tuple[int, int, int]]) -> int: Determine the length of the shortest path from intersection 1 to intersection n after adding the most optimal k new roads. If it is not possible to connect intersection 1 to intersection n, return -1. >>> find_shortest_path(2, 0, 0, [], []) -1 >>> find_shortest_path(2, 1, 0, [(1, 2, 5)], []) 5 >>> find_shortest_path(3, 2, 2, [(1, 2, 5), (2, 3, 5)], [(1, 3, 4), (1, 3, 7)]) 4 >>> find_shortest_path(3, 2, 2, [(1, 2, 3), (2, 3, 4)], [(1, 3, 10), (2, 3, 10)]) 7 >>> find_shortest_path(3, 0, 1, [], [(1, 2, 2)]) -1","solution":"import heapq from collections import defaultdict import sys def find_shortest_path(n, m, k, current_roads, new_roads): def dijkstra(graph, start, end): dist = [float('inf')] * (n+1) dist[start] = 0 pq = [] heapq.heappush(pq, (0, start)) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, length in graph[u]: distance = current_dist + length if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist[end] if dist[end] != float('inf') else -1 graph = defaultdict(list) for u, v, w in current_roads: graph[u].append((v, w)) graph[v].append((u, w)) base_dist = dijkstra(graph, 1, n) if k == 0: return base_dist min_dist = base_dist for u, v, w in new_roads: graph[u].append((v, w)) graph[v].append((u, w)) new_dist = dijkstra(graph, 1, n) min_dist = min(min_dist, new_dist) graph[u].remove((v, w)) graph[v].remove((u, w)) return min_dist"},{"question":"def max_cows_placement(n: int, m: int, barn: List[str]) -> int: Determine the maximum number of cows that can be placed in the barn such that no two cows can see each other. Args: n (int): The number of rows in the barn. m (int): The number of columns in the barn. barn (List[str]): The layout of the barn, where each element is a string representing a row. Returns: int: The maximum number of cows that can be placed in the barn. >>> max_cows_placement(5, 5, [\\".....\\", \\"..x..\\", \\".....\\", \\".x...\\", \\"....x\\"]) 5 >>> max_cows_placement(3, 3, [\\"...\\", \\".x.\\", \\"...\\"]) 3 >>> max_cows_placement(4, 4, [\\"....\\", \\".xx.\\", \\"....\\", \\"x..x\\"]) 4 >>> max_cows_placement(2, 2, [\\"..\\", \\"..\\"]) 2 >>> max_cows_placement(1, 1, [\\".\\"]) 1 pass from solution import max_cows_placement def test_case_1(): n = 5 m = 5 barn = [ \\".....\\", \\"..x..\\", \\".....\\", \\".x...\\", \\"....x\\" ] assert max_cows_placement(n, m, barn) == 5 def test_case_2(): n = 3 m = 3 barn = [ \\"...\\", \\".x.\\", \\"...\\", ] assert max_cows_placement(n, m, barn) == 3 def test_case_3(): n = 4 m = 4 barn = [ \\"....\\", \\".xx.\\", \\"....\\", \\"x..x\\", ] assert max_cows_placement(n, m, barn) == 4 def test_case_4(): n = 2 m = 2 barn = [ \\"..\\", \\"..\\", ] assert max_cows_placement(n, m, barn) == 2 def test_case_5(): n = 1 m = 1 barn = [ \\".\\", ] assert max_cows_placement(n, m, barn) == 1","solution":"def max_cows_placement(n, m, barn): from itertools import product def can_place(barn, placed, i, j): for k in range(i): if barn[k][j] == '.' and placed[k][j] == 'C': return False for l in range(j): if barn[i][l] == '.' and placed[i][l] == 'C': return False return True def place_cows(index, cnt, max_cows): if index >= len(empty_cells): return max(max_cows, cnt) i, j = empty_cells[index] if can_place(barn, placed, i, j): placed[i][j] = 'C' max_cows = place_cows(index + 1, cnt + 1, max_cows) placed[i][j] = '.' max_cows = place_cows(index + 1, cnt, max_cows) return max_cows empty_cells = [(i, j) for i, j in product(range(n), range(m)) if barn[i][j] == '.'] placed = [['.' for _ in range(m)] for _ in range(n)] return place_cows(0, 0, 0) # Function to handle input and output def solve(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) barn = [] index = 2 for i in range(n): barn.append(data[index + i]) print(max_cows_placement(n, m, barn))"},{"question":"from typing import List def game_grid(input_str: str) -> int: Determine the minimum number of cells needed to pass through to reach cell (n, m) while following the rules described. If it is impossible, return -1. Parameters: input_str (str): A string that contains the grid dimensions and layout Returns: int: Minimum number of cells needed to pass through to reach the target, or -1 if impossible Example: >>> game_grid(\\"4 4n....n.#..n..#.n....\\") 7 >>> game_grid(\\"2 2n.#n#.\\") -1 # Your implementation here def test_game_grid_possible_path(): input_str = \\"4 4n....n.#..n..#.n....\\" assert game_grid(input_str) == 7 def test_game_grid_no_path(): input_str = \\"2 2n.#n#.\\" assert game_grid(input_str) == -1 def test_game_grid_single_column(): input_str = \\"3 1n.n.n.\\" assert game_grid(input_str) == 3 def test_game_grid_single_row(): input_str = \\"1 3n...\\" assert game_grid(input_str) == 3 def test_game_grid_path_with_obstacles(): input_str = \\"3 3n...n.#.n...\\" assert game_grid(input_str) == 5","solution":"from queue import Queue def min_cells_to_collect_stars(grid, n, m): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Create a 3D visited array to mark cells as visited visited = [[[False, False] for _ in range(m)] for _ in range(n)] q = Queue() # Start from the top-left corner with step parity 0 (not expecting a star) q.put((0, 0, 0, 1)) # (current row, current column, current parity, steps count) visited[0][0][0] = True while not q.empty(): x, y, parity, steps = q.get() # If reached bottom-right corner if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': new_parity = (parity + 1) % 2 if not visited[nx][ny][new_parity]: visited[nx][ny][new_parity] = True q.put((nx, ny, new_parity, steps + 1)) return -1 # Function to read input, process the grid and return the result def game_grid(input_str): input_list = input_str.split(\\"n\\") n, m = map(int, input_list[0].split()) grid = [list(row) for row in input_list[1:n+1]] return min_cells_to_collect_stars(grid, n, m)"},{"question":"def num_symmetric_cells(n: int) -> int: Return the number of cells in an n x n chessboard that must be identical to its 180-degree rotated counterpart for the board to be symmetric. >>> num_symmetric_cells(1) == 1 >>> num_symmetric_cells(2) == 2 >>> num_symmetric_cells(3) == 5 >>> num_symmetric_cells(4) == 8 >>> num_symmetric_cells(5) == 13 >>> num_symmetric_cells(6) == 18 >>> num_symmetric_cells(7) == 25 >>> num_symmetric_cells(8) == 32 >>> num_symmetric_cells(10) == 50 >>> num_symmetric_cells(99) == 4901 >>> num_symmetric_cells(100) == 5000 >>> num_symmetric_cells(1000) == 500000","solution":"def num_symmetric_cells(n): Return the number of cells in an n x n chessboard that must be identical to its 180-degree rotated counterpart for the board to be symmetric. symmetric_cells = (n * n + 1) // 2 return symmetric_cells"},{"question":"def count_unique_stars(n: int, grid: List[str]) -> int: Returns the number of unique stars Alice can see in the grid. Parameters: n (int): The size of the grid. grid (list of str): The grid containing '0' and '1' characters, where '1' represents a star. Returns: int: The number of unique stars in the grid. Examples: >>> count_unique_stars(3, [\\"101\\", \\"010\\", \\"101\\"]) 5 >>> count_unique_stars(3, [\\"111\\", \\"111\\", \\"111\\"]) 9 >>> count_unique_stars(3, [\\"000\\", \\"000\\", \\"000\\"]) 0 >>> count_unique_stars(3, [\\"100\\", \\"010\\", \\"001\\"]) 3 >>> count_unique_stars(4, [\\"1010\\", \\"0101\\", \\"1010\\", \\"0101\\"]) 8 >>> count_unique_stars(1, [\\"1\\"]) 1 >>> count_unique_stars(1, [\\"0\\"]) 0 pass","solution":"def count_unique_stars(n, grid): Returns the number of unique stars Alice can see in the grid. Parameters: n (int): The size of the grid. grid (list of str): The grid containing '0' and '1' characters, where '1' represents a star. Returns: int: The number of unique stars in the grid. rows_with_stars = set() cols_with_stars = set() for i in range(n): for j in range(n): if grid[i][j] == '1': rows_with_stars.add(i) cols_with_stars.add(j) count = 0 for i in rows_with_stars: for j in cols_with_stars: if grid[i][j] == '1': count += 1 return count"},{"question":"def manage_operations(operations): Performs a sequence of operations on a list and returns the results of 'print' operations. :param operations: List of operation strings. :return: List of results of 'print' operations. pass import unittest class TestManageOperations(unittest.TestCase): def test_manage_operations_basic(self): operations = [ \\"1 97\\", \\"2\\", \\"1 20\\", \\"1 26\\", \\"3\\", \\"2\\", \\"3\\" ] expected = [26, 20] self.assertEqual(manage_operations(operations), expected) def test_manage_operations_empty_stack(self): operations = [ \\"3\\", \\"2\\", \\"3\\" ] expected = [\\"Empty\\", \\"Empty\\"] self.assertEqual(manage_operations(operations), expected) def test_manage_operations_single_insert(self): operations = [ \\"1 42\\", \\"3\\" ] expected = [42] self.assertEqual(manage_operations(operations), expected) def test_manage_operations_delete_all(self): operations = [ \\"1 15\\", \\"1 30\\", \\"2\\", \\"2\\", \\"3\\" ] expected = [\\"Empty\\"] self.assertEqual(manage_operations(operations), expected) def test_manage_operations_multiple(self): operations = [ \\"1 10\\", \\"1 20\\", \\"1 30\\", \\"3\\", \\"2\\", \\"3\\", \\"2\\", \\"3\\", \\"2\\", \\"3\\" ] expected = [30, 20, 10, \\"Empty\\"] self.assertEqual(manage_operations(operations), expected) if __name__ == '__main__': unittest.main()","solution":"def manage_operations(operations): Performs a sequence of operations on a list and returns the results of 'print' operations. :param operations: List of operation strings. :return: List of results of 'print' operations. stack = [] results = [] for operation in operations: if operation.startswith(\\"1\\"): _, k = operation.split() stack.append(int(k)) elif operation == \\"2\\": if stack: stack.pop() elif operation == \\"3\\": if stack: results.append(max(stack)) else: results.append(\\"Empty\\") return results"},{"question":"from typing import List def can_arrange_images(films: List[List[int]]) -> str: Determine if it is possible to arrange all the images from the given films in a single sequence while maintaining the order of images in each film. >>> can_arrange_images([[1, 3, 5, 7],[2, 3, 6],[1, 2, 3, 4, 5]]) == \\"YES\\" >>> can_arrange_images([[1, 2, 3],[3, 1, 2]]) == \\"NO\\" >>> can_arrange_images([[1, 2, 3]]) == \\"YES\\" >>> can_arrange_images([[1, 3, 5],[2, 4, 6]]) == \\"YES\\" >>> can_arrange_images([[i for i in range(1, 101)],[i + 100 for i in range(1, 101)]]) == \\"YES\\"","solution":"def can_arrange_images(films): from collections import defaultdict, deque # Graph and in-degrees dictionary graph = defaultdict(list) in_degrees = defaultdict(int) all_images = set() # Build the graph for film in films: for i in range(len(film) - 1): u, v = film[i], film[i + 1] graph[u].append(v) in_degrees[v] += 1 all_images.add(u) all_images.add(v) all_images.add(film[-1]) # Add the last image in the film # Initialize in-degrees for images that do not yet have entries for image in all_images: if image not in in_degrees: in_degrees[image] = 0 # Topological Sort Generation queue = deque([image for image in in_degrees if in_degrees[image] == 0]) sorted_order = [] while queue: node = queue.popleft() sorted_order.append(node) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) # If sorted_order has all the images, it means we can arrange them in a single sequence if len(sorted_order) == len(all_images): return \\"YES\\" else: return \\"NO\\" # Example usage: films = [ [1, 3, 5, 7], [2, 3, 6], [1, 2, 3, 4, 5] ] print(can_arrange_images(films)) # Output: YES films = [ [1, 2, 3], [3, 1, 2] ] print(can_arrange_images(films)) # Output: NO"},{"question":"def count_distinct_substrings(s: str) -> int: Calculate the number of distinct substrings in the given string. Args: s (str): Input string consisting of lowercase English letters only. Returns: int: The number of distinct substrings. >>> count_distinct_substrings(\\"ababa\\") 9 >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaaa\\") 4 >>> count_distinct_substrings(\\"abab\\") 7 >>> count_distinct_substrings(\\"\\") 0","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings in the string s. n = len(s) substrings = set() # Generate all possible substrings and add them to a set to ensure uniqueness for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"from typing import List, Tuple def minimum_tour_cost(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given an undirected graph representing cities and roads, find the minimum cost of visiting every city starting and ending at city 1. Args: n (int): Number of cities. m (int): Number of roads. edges (List[Tuple[int, int, int]]): List of tuples representing the roads with each tuple containing (u, v, w) where u and v are cities and w is the weight of the road between them. Returns: int: Minimum cost of the journey, or -1 if not possible. Examples: >>> minimum_tour_cost(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> minimum_tour_cost(2, 1, [(1, 2, 5)]) 10 >>> minimum_tour_cost(3, 2, [(1, 2, 5), (2, 3, 10)]) -1 >>> minimum_tour_cost(3, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 20)]) 35 >>> minimum_tour_cost(4, 2, [(1, 2, 10), (3, 4, 20)]) -1","solution":"import itertools def minimum_tour_cost(n, m, edges): inf = float('inf') distances = [[inf] * n for _ in range(n)] # Create adjacency matrix for u, v, w in edges: distances[u-1][v-1] = w distances[v-1][u-1] = w # Handle the simple case with only two nodes if n == 2: if m == 1: return distances[0][1] * 2 else: return -1 cities = list(range(1, n)) min_cost = inf # Try all permutations of cities, since 1 is always the starting city for perm in itertools.permutations(cities): cost = distances[0][perm[0]] if cost == inf: # Skip invalid permutations continue for i in range(len(perm) - 1): cost += distances[perm[i]][perm[i+1]] if cost == inf: # Skip invalid permutations break cost += distances[perm[-1]][0] if cost < min_cost: min_cost = cost return min_cost if min_cost < inf else -1"},{"question":"def max_aesthetic_value(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum aesthetic value possible by rearranging the flowers. >>> t = 2 >>> test_cases = [ ... (5, [3, 1, 4, 1, 5]), ... (4, [1, 2, 3, 4]) ... ] >>> max_aesthetic_value(t, test_cases) [3, 2]","solution":"def max_aesthetic_value(t, test_cases): results = [] for case in test_cases: n, heights = case heights.sort() # Building an optimal arrangement arrangement = [] left, right = 0, n - 1 switch = True while left <= right: if switch: arrangement.append(heights[left]) left += 1 else: arrangement.append(heights[right]) right -= 1 switch = not switch # Counting aesthetic pairs count = 0 for i in range(1, n - 1): if (arrangement[i-1] < arrangement[i] > arrangement[i+1]) or (arrangement[i-1] > arrangement[i] < arrangement[i+1]): count += 1 results.append(count) return results"},{"question":"def can_partition_array(arr): Determines if the array can be divided into two parts with equal sum. :param arr: List of integers :return: \\"YES\\" if it can be partitioned into two parts with equal sum, otherwise \\"NO\\" from solution import can_partition_array def test_can_partition_array_even_sum(): assert can_partition_array([1, 5, 11, 5]) == \\"YES\\" def test_can_partition_array_odd_sum(): assert can_partition_array([1, 2, 3, 5]) == \\"NO\\" def test_can_partition_array_single_element(): assert can_partition_array([1]) == \\"NO\\" assert can_partition_array([2]) == \\"NO\\" def test_can_partition_array_multiple_small_elements(): assert can_partition_array([1, 1, 1, 1]) == \\"YES\\" def test_can_partition_array_large_elements(): assert can_partition_array([100, 100, 100, 100, 100, 100, 100, 100]) == \\"YES\\" def test_can_partition_array_no_partition(): assert can_partition_array([3, 1, 1, 2, 2]) == \\"NO\\"","solution":"def can_partition_array(arr): Determines if the array can be divided into two parts with equal sum. :param arr: List of integers :return: \\"YES\\" if it can be partitioned into two parts with equal sum, otherwise \\"NO\\" total_sum = sum(arr) # If the total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(arr) # Use dynamic programming to find if a subset with the target sum exists dp = [False] * (target + 1) dp[0] = True # There's always a subset (empty set) that adds up to 0 for num in arr: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def detect_cycle_in_graph(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if a directed graph contains any cycles. >>> detect_cycle_in_graph(3, 3, [(1, 2), (2, 3), (3, 1)]) 'YES' >>> detect_cycle_in_graph(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> detect_cycle_in_graph(1, 0, []) 'NO' >>> detect_cycle_in_graph(2, 1, [(1, 2)]) 'NO' >>> detect_cycle_in_graph(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'NO' >>> detect_cycle_in_graph(5, 4, [(1, 2), (2, 3), (3, 1), (4, 5)]) 'YES' >>> detect_cycle_in_graph(5, 3, [(1, 2), (2, 3), (4, 5)]) 'NO'","solution":"def contains_cycle(n, m, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * (n + 1) rec_stack = [False] * (n + 1) def dfs(v): visited[v] = True rec_stack[v] = True for neighbour in graph[v]: if not visited[neighbour]: if dfs(neighbour): return True elif rec_stack[neighbour]: return True rec_stack[v] = False return False for node in range(1, n + 1): if not visited[node]: if dfs(node): return True return False def detect_cycle_in_graph(n, m, edges): if contains_cycle(n, m, edges): return \\"YES\\" else: return \\"NO\\""},{"question":"def min_total_dimness(N: int, dimness: List[Tuple[int, int]]) -> int: Calculate the minimum total dimness of a sequence of lights such that no two adjacent lights have the same color. >>> min_total_dimness(4, [(1, 2), (2, 3), (3, 1), (4, 3)]) 7 >>> min_total_dimness(1, [(5, 10)]) 5 >>> min_total_dimness(2, [(5, 10), (3, 1)]) 6 >>> min_total_dimness(3, [(1, 100), (100, 1), (50, 50)]) 52 >>> min_total_dimness(3, [(10, 10), (10, 10), (10, 10)]) 30 >>> min_total_dimness(3, [(1, 2), (3, 4), (5, 6)]) 9","solution":"def min_total_dimness(N, dimness): # Initialize dp arrays to store minimum dimness if ending with Red or Blue dp_red = [0] * N dp_blue = [0] * N # Base cases dp_red[0] = dimness[0][0] dp_blue[0] = dimness[0][1] # Fill the dp arrays for i in range(1, N): dp_red[i] = min(dp_red[i-1] + dimness[i][0], dp_blue[i-1] + dimness[i][0]) dp_blue[i] = min(dp_red[i-1] + dimness[i][1], dp_blue[i-1] + dimness[i][1]) # The result is the minimum of the two values at the last light return min(dp_red[N-1], dp_blue[N-1])"},{"question":"def compress_string(s: str) -> str: Compress a string such that consecutive identical characters are replaced by the character followed by the count of occurrences. Single occurrence does not show the count. Args: s (str): Input string consisting of lowercase Latin letters Returns: str: Compressed string Examples: >>> compress_string(\\"aaabbc\\") 'a3b2c' >>> compress_string(\\"abcd\\") 'abcd' def test_compress_string(): # Test with single consecutive characters assert compress_string(\\"aaabbc\\") == \\"a3b2c\\" assert compress_string(\\"abcd\\") == \\"abcd\\" # Test with all characters being the same assert compress_string(\\"aaaa\\") == \\"a4\\" # Test with empty string assert compress_string(\\"\\") == \\"\\" # Test with no repeating characters assert compress_string(\\"xyz\\") == \\"xyz\\" # Test with various patterns assert compress_string(\\"aabbcc\\") == \\"a2b2c2\\" assert compress_string(\\"aabbaa\\") == \\"a2b2a2\\" assert compress_string(\\"aaabbbccc\\") == \\"a3b3c3\\" # Test with single character assert compress_string(\\"a\\") == \\"a\\" # Test with mixed single and multiple characters assert compress_string(\\"aabbcca\\") == \\"a2b2c2a\\" def run_tests(): test_compress_string() print(\\"All tests passed.\\") run_tests()","solution":"def compress_string(s): Compresses a string such that consecutive identical characters are replaced by the character followed by the count of occurrences. Single occurrence does not show the count. Args: s (str): Input string consisting of lowercase Latin letters Returns: str: Compressed string if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: count += 1 else: if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) prev_char = s[i] count = 1 if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) return ''.join(compressed)"},{"question":"import math def count_unique_sequences(n: int) -> int: Returns the number of unique permutations of n words. >>> count_unique_sequences(3) 6 >>> count_unique_sequences(2) 2 >>> count_unique_sequences(4) 24 >>> count_unique_sequences(5) 120 >>> count_unique_sequences(12) 479001600","solution":"import math def count_unique_sequences(n): Returns the number of unique permutations of n words. return math.factorial(n)"},{"question":"def shortest_palindrome_length(s: str) -> int: This function returns the length of the shortest palindrome that can be formed by adding characters to the end of the given string \`s\`. >>> shortest_palindrome_length(\\"abcd\\") 7 >>> shortest_palindrome_length(\\"aba\\") 3 >>> shortest_palindrome_length(\\"aabb\\") 6 pass def batch_shortest_palindrome_length(t: int, test_cases: List[str]) -> List[int]: This function processes multiple test cases and returns the length of the shortest palindrome for each case. >>> batch_shortest_palindrome_length(3, [\\"abcd\\", \\"aba\\", \\"aabb\\"]) [7, 3, 6] >>> batch_shortest_palindrome_length(2, [\\"race\\", \\"a\\"]) [7, 1] pass","solution":"def shortest_palindrome_length(s): This function returns the length of the shortest palindrome that can be formed by adding characters to the end of the given string \`s\`. def is_palindrome(s): return s == s[::-1] n = len(s) for i in range(n): if is_palindrome(s[i:]): return n + i return 2 * n def batch_shortest_palindrome_length(t, test_cases): results = [] for s in test_cases: results.append(shortest_palindrome_length(s)) return results"},{"question":"from typing import List, Tuple def find_maximum_path_sum(n: int, edges: List[Tuple[int, int]]) -> int: Find the maximum path sum in a given binary tree. Arguments: n -- the number of nodes in the binary tree. edges -- a list of tuples where each tuple represents an edge between two nodes in the tree. Returns: The maximum path sum in the binary tree. >>> find_maximum_path_sum(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 15 >>> find_maximum_path_sum(6, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)]) 17 def test_single_node(): assert find_maximum_path_sum(1, []) == 1 def test_two_nodes_tree(): assert find_maximum_path_sum(2, [(1, 2)]) == 3 def test_simple_tree(): assert find_maximum_path_sum(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 15 def test_balanced_tree(): assert find_maximum_path_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 28 def test_unbalanced_tree(): assert find_maximum_path_sum(5, [(1, 2), (1, 3), (2, 4), (4, 5)]) == 13","solution":"from typing import List, Tuple def find_maximum_path_sum(n: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque if n == 1: return 1 # Create the adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Helper function to perform BFS and find the furthest node from the start node def bfs(start): visited = set() queue = deque([(start, 0)]) visited.add(start) furthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() if dist > max_distance: max_distance = dist furthest_node = node for neighbor in tree[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return furthest_node, max_distance # Find the furthest node from an arbitrary starting node (e.g., node 1) node_a, _ = bfs(1) # Use the furthest node found to find the longest path in the tree node_b, max_path_length = bfs(node_a) return max_path_length"},{"question":"def min_days_to_complete_sessions(n: int, m: int, s: List[int]) -> int: Calculates the minimum number of days required to complete all tutoring sessions. n: Number of students m: Number of tutors s: List of integers representing the number of sessions required by each student Returns: The minimum number of days required >>> min_days_to_complete_sessions(4, 3, [1, 2, 3, 4]) 4 >>> min_days_to_complete_sessions(1, 5, [10]) 2 >>> min_days_to_complete_sessions(3, 1, [3, 3, 3]) 9 >>> min_days_to_complete_sessions(5, 5, [2, 2, 2, 2, 2]) 2 >>> min_days_to_complete_sessions(2, 5, [1, 2]) 1 >>> min_days_to_complete_sessions(5, 3, [1, 1, 1, 1, 1]) 2","solution":"def min_days_to_complete_sessions(n, m, s): Calculates the minimum number of days required to complete all tutoring sessions. n: Number of students m: Number of tutors s: List of integers representing the number of sessions required by each student Return: The minimum number of days required # Calculate the total number of sessions required total_sessions = sum(s) # Calculate minimum number of days required days_needed = total_sessions // m if total_sessions % m != 0: days_needed += 1 return days_needed"},{"question":"def min_days_to_target(initial_population: int, target_population: int) -> int: Determine the minimum number of days required for the bacteria population to reach exactly the target population. >>> min_days_to_target(3, 12) 2 >>> min_days_to_target(3, 10) 3 >>> min_days_to_target(5, 15) 4 >>> min_days_to_target(1, 10) 4 >>> min_days_to_target(6, 20) 5","solution":"def min_days_to_target(initial_population, target_population): days = 0 while initial_population < target_population: if target_population % 2 == 0 and target_population // 2 >= initial_population: target_population //= 2 else: target_population -= 1 days += 1 return days"},{"question":"def plant_growth(g, h, d, init): Calculates the height of the plant after \`d\` days given daily growth \`g\`, maximum height threshold \`h\`, and initial height \`init\`. >>> plant_growth(10, 100, 5, 0) 50 >>> plant_growth(20, 50, 4, 10) 50 >>> plant_growth(5, 12, 4, 7) 12","solution":"def plant_growth(g, h, d, init): Calculates the height of the plant after \`d\` days given daily growth \`g\`, maximum height threshold \`h\`, and initial height \`init\`. height = init for _ in range(d): if height + g >= h: height = h else: height += g return height"},{"question":"def can_alice_always_move(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines whether Alice can always ensure she will make a move regardless of Bob's moves. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the number of integers in the array, followed by the array of integers. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case, indicating if Alice can always ensure she will make a move. >>> can_alice_always_move(2, [(3, [10, 5, 7]), (4, [4, 4, 4, 4])]) [\\"YES\\", \\"NO\\"] >>> can_alice_always_move(1, [(2, [1, 2])]) [\\"YES\\"] >>> can_alice_always_move(1, [(5, [7, 7, 7, 7, 7])]) [\\"NO\\"]","solution":"def can_alice_always_move(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] array = sorted(test_cases[i][1]) valid = any(array[j] - array[j - 1] > 0 for j in range(1, n)) if valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_potential_winners(test_cases): Given a list of test cases, count the number of participants whose speed is greater than the average speed of their race. >>> count_potential_winners([(5, [10, 20, 30, 40, 50]), (4, [60, 70, 80, 90])]) [2, 2] >>> count_potential_winners([(3, [15, 20, 25]), (2, [5, 10])]) [1, 1] >>> count_potential_winners([(6, [1, 2, 3, 4, 5, 6]), (3, [10, 20, 30])]) [3, 1] >>> count_potential_winners([(1, [100])]) [0] >>> count_potential_winners([(3, [7, 7, 7]), (4, [4, 6, 8, 10])]) [0, 2]","solution":"def count_potential_winners(test_cases): results = [] for participants in test_cases: n = participants[0] speeds = participants[1] average_speed = sum(speeds) / n potential_winners = sum(1 for speed in speeds if speed > average_speed) results.append(potential_winners) return results"},{"question":"def min_storage_units(volumes, capacity): Calculates the minimum number of storage units needed to store all items. Parameters: volumes (list of int): List of item volumes. capacity (int): Maximum capacity of a single storage unit. Returns: int: Minimum number of storage units required. from solution import min_storage_units def test_min_storage_units_example(): assert min_storage_units([2, 3, 8, 4, 5], 10) == 3 def test_min_storage_units_single_item(): assert min_storage_units([10], 10) == 1 assert min_storage_units([11], 10) == 1 def test_min_storage_units_all_items_fit_in_one_unit(): assert min_storage_units([2, 2, 2], 10) == 1 assert min_storage_units([1, 1, 1, 1, 1, 1, 1], 10) == 1 def test_min_storage_units_each_item_needs_separate_unit(): assert min_storage_units([10, 10, 10], 10) == 3 assert min_storage_units([9, 9, 9], 8) == 3 def test_min_storage_units_mixed_volumes(): assert min_storage_units([5, 5, 5, 5, 4, 4, 4], 10) == 4 assert min_storage_units([6, 8, 7, 3, 2], 10) == 3 def test_min_storage_units_large_numbers(): assert min_storage_units([10**9] * 10, 10**9) == 10 assert min_storage_units([10**9 - 1] * 15, 10**9) == 15","solution":"def min_storage_units(volumes, capacity): Calculates the minimum number of storage units needed to store all items. Parameters: volumes (list of int): List of item volumes. capacity (int): Maximum capacity of a single storage unit. Returns: int: Minimum number of storage units required. # Sort the items by volume in descending order volumes.sort(reverse=True) # Use a list to keep track of remaining capacities of storage units units = [] for volume in volumes: placed = False for i in range(len(units)): if units[i] >= volume: units[i] -= volume placed = True break if not placed: # If the item couldn't be placed in any existing unit, create a new unit units.append(capacity - volume) return len(units)"},{"question":"from typing import List def process_queries(n: int, q: int, arr: List[int], queries: List[List[int]]) -> List[int]: Processes an array and answers a list of queries. Each query is of two types: 1. Increment each element in the subarray by a given value. 2. Calculate the sum of elements in the subarray. Parameters: n (int): Length of the array. q (int): Number of queries. arr (list of int): The initial elements of the array. queries (list of list of int): The queries to be processed. Returns: list of int: Results of sum queries. >>> process_queries(5, 5, [1, 2, 3, 4, 5], [[1, 2, 4, 1], [2, 1, 3], [1, 1, 5, 2], [2, 2, 5], [2, 1, 5]]) [8, 25, 28] >>> process_queries(4, 2, [1, 3, 5, 7], [[2, 1, 4], [2, 2, 3]]) [16, 8] >>> process_queries(10, 3, [10**9]*10, [[1, 1, 10, 10], [2, 1, 5], [2, 6, 10]]) [50000000050, 50000000050]","solution":"def process_queries(n, q, arr, queries): Processes an array and answers a list of queries. Each query is of two types: 1. Increment each element in the subarray by a given value. 2. Calculate the sum of elements in the subarray. Parameters: n (int): Length of the array. q (int): Number of queries. arr (list of int): The initial elements of the array. queries (list of list of int): The queries to be processed. Returns: list of int: Results of sum queries. # Initialize the results list for type 2 queries. results = [] # Process each query. for query in queries: if query[0] == 1: # Increment operation _, l, r, k = query for i in range(l-1, r): arr[i] += k elif query[0] == 2: # Sum operation _, l, r = query results.append(sum(arr[l-1:r])) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string s, determine the longest palindromic substring in s. If there are multiple longest palindromic substrings, return the one that appears first. The input string s consists of lowercase English letters and has a length between 1 and 1000. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb'","solution":"def longest_palindromic_substring(s): # Helper function to expand around center def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if s is None or len(s) == 0: return \\"\\" longest = \\"\\" for i in range(len(s)): # Odd length palindrome odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindrome even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def longest_arithmetic_subsequence_length(arr): Returns the length of the longest subsequence that forms an arithmetic progression. >>> longest_arithmetic_subsequence_length([9, 4, 7, 2, 10, 3]) == 3 >>> longest_arithmetic_subsequence_length([3, 6, 9, 12]) == 4 >>> longest_arithmetic_subsequence_length([1, 3, 5, 7, 9, 11]) == 6 >>> longest_arithmetic_subsequence_length([1, 1, 1, 1, 1]) == 5 >>> longest_arithmetic_subsequence_length([10, 20, 30, 40, 50]) == 5 >>> longest_arithmetic_subsequence_length([20, 15, 10, 5, 0]) == 5 >>> longest_arithmetic_subsequence_length([2, 2, 2, 2]) == 4","solution":"def longest_arithmetic_subsequence_length(arr): Returns the length of the longest subsequence that forms an arithmetic progression. from collections import defaultdict if not arr: return 0 n = len(arr) longest = 0 # A dictionary to store the length of the longest AP that ends at index i with difference d. dp = [defaultdict(int) for _ in range(n)] for i in range(n): for j in range(i): diff = arr[i] - arr[j] dp[i][diff] = dp[j][diff] + 1 longest = max(longest, dp[i][diff]) return longest + 1 # plus one to include the initial element # Example usage print(longest_arithmetic_subsequence_length([9, 4, 7, 2, 10, 3])) # Output: 3"},{"question":"def can_reach_target(grid, n, m, tx, ty, sx, sy, d): Determines if a robot can reach the target position from its starting position within the given range. def num_robots_to_target(n, m, grid, tx, ty, robots): Determines the number of unique robots that can successfully navigate from their starting positions to a designated target position within the grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[str]): grid layout describing free spaces and obstacles tx (int): row index of the target position ty (int): column index of the target position robots (List[Tuple[int, int, int]]): list of starting positions and ranges for each robot Returns: int: number of robots that can reach the target position >>> grid = [ ... \\".....\\", ... \\".#...\\", ... \\".#...\\", ... \\".#...\\", ... \\".....\\" ... ] >>> num_robots_to_target(5, 5, grid, 5, 5, [(1, 1, 10), (2, 2, 3), (3, 5, 2)]) 2 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> num_robots_to_target(3, 3, grid, 3, 3, [(1, 1, 4)]) 1 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> num_robots_to_target(3, 3, grid, 3, 3, [(1, 1, 4), (2, 2, 1), (3, 1, 3)]) 2 >>> grid = [ ... \\".#.\\", ... \\"...\\", ... \\".#.\\" ... ] >>> num_robots_to_target(3, 3, grid, 2, 1, [(1, 3, 2), (3, 3, 1)]) 0 >>> grid = [ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ] >>> num_robots_to_target(5, 5, grid, 3, 3, [(1, 1, 5), (4, 4, 5), (1, 5, 5)]) 3 >>> grid = [ ... \\".\\" ... ] >>> num_robots_to_target(1, 1, grid, 1, 1, [(1, 1, 1)]) 1","solution":"def can_reach_target(grid, n, m, tx, ty, sx, sy, d): from collections import deque # Directions for 'U', 'D', 'L', 'R' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(sx, sy, 0)]) # (row, col, distance) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if dist > d: continue if (x, y) == (tx, ty): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return False def num_robots_to_target(n, m, grid, tx, ty, robots): tx -= 1 ty -= 1 count = 0 for sx, sy, d in robots: sx -= 1 sy -= 1 if can_reach_target(grid, n, m, tx, ty, sx, sy, d): count += 1 return count"},{"question":"def max_sum_in_matrix(matrix): Returns the maximum sum of elements in any row or column of the matrix. >>> max_sum_in_matrix([ ... [1, 2, -1], ... [-3, 4, 0], ... [2, -1, 5] ... ]) == 6 >>> max_sum_in_matrix([ ... [5] ... ]) == 5 >>> max_sum_in_matrix([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -6 >>> max_sum_in_matrix([ ... [1, 2, 3], ... [-1, -2, -3], ... [4, 5, 6] ... ]) == 15 >>> max_sum_in_matrix([ ... [1000, 1000, 1000], ... [1000, 1000, 1000], ... [1000, 1000, 1000] ... ]) == 3000","solution":"def max_sum_in_matrix(matrix): Returns the maximum sum of elements in any row or column of the matrix. n = len(matrix) max_sum = float('-inf') # Check row sums for row in matrix: row_sum = sum(row) if row_sum > max_sum: max_sum = row_sum # Check column sums for col in range(n): col_sum = sum(matrix[row][col] for row in range(n)) if col_sum > max_sum: max_sum = col_sum return max_sum"},{"question":"def most_influential_user(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Find the most influential user in the social network. Parameters: n (int): the number of users. m (int): the number of connections. connections (List[Tuple[int, int]]): list of directed connections (u, v) representing user u follows user v. Returns: int: the index of the most influential user. >>> most_influential_user(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5)]) 1 >>> most_influential_user(4, 0, []) 1 import pytest from your_module import most_influential_user def test_example_case(): n = 5 m = 5 connections = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5)] assert most_influential_user(n, m, connections) == 1 def test_no_connections(): n = 4 m = 0 connections = [] assert most_influential_user(n, m, connections) == 1 def test_all_connected(): n = 4 m = 6 connections = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert most_influential_user(n, m, connections) == 1 def test_circular_connections(): n = 3 m = 3 connections = [(1, 2), (2, 3), (3, 1)] assert most_influential_user(n, m, connections) == 1 def test_multiple_possible_influentials(): n = 3 m = 3 connections = [(1, 2), (2, 3), (1, 3)] assert most_influential_user(n, m, connections) == 1","solution":"from collections import defaultdict, deque def most_influential_user(n, m, connections): def bfs(start): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True reachable_count = 0 while queue: node = queue.popleft() reachable_count += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return reachable_count graph = defaultdict(list) for u, v in connections: graph[u].append(v) max_reach = 0 influential_user = 0 for user in range(1, n + 1): reach = bfs(user) if reach > max_reach or (reach == max_reach and user < influential_user): max_reach = reach influential_user = user return influential_user # Example input n = 5 m = 5 connections = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5)] print(most_influential_user(n, m, connections)) # Output should be 1"},{"question":"def min_insertions_to_make_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string s a palindrome. >>> min_insertions_to_make_palindrome(\\"aab\\") 1 >>> min_insertions_to_make_palindrome(\\"abcd\\") 3 >>> min_insertions_to_make_palindrome(\\"racecar\\") 0 >>> min_insertions_to_make_palindrome(\\"race\\") 3 >>> min_insertions_to_make_palindrome(\\"google\\") 2 >>> min_insertions_to_make_palindrome(\\"a\\") 0 >>> min_insertions_to_make_palindrome(\\"aa\\") 0 >>> min_insertions_to_make_palindrome(\\"ab\\") 1 pass","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of insertions needed to make the string s a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0] * n for _ in range(n)] # Fill the table for gap in range(1, n): for l in range(n-gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l+1][r-1] else: dp[l][r] = min(dp[l][r-1], dp[l+1][r]) + 1 # The minimum number of insertions needed to make the string a palindrome return dp[0][n-1]"},{"question":"class Inventory: def __init__(self): self.categories = {} def donate(self, category, count): Adds the specified count of items to the mentioned category in the inventory. Creates the category if it does not exist. if category in self.categories: self.categories[category] += count else: self.categories[category] = count def query(self, category): Returns the current count of items in the specified category. Returns 0 if the category does not exist. return self.categories.get(category, 0) def manage_inventory(n, operations): Manages the inventory based on the provided operations and returns the results of 'query' operations. Args: n (int): The number of operations. operations (List[str]): The list of operations as strings. Returns: List[int]: The results of the 'query' operations. Examples: >>> manage_inventory(7, [\\"donate books 10\\", \\"donate clothes 5\\", \\"query books\\", \\"donate toys 2\\", \\"query clothes\\", \\"donate clothes 3\\", \\"query clothes\\"]) [10, 5, 8] >>> manage_inventory(3, [\\"query gadgets\\", \\"donate gadgets 4\\", \\"query gadgets\\"]) [0, 4] inventory = Inventory() results = [] for op in operations: parts = op.split() if parts[0] == \\"donate\\": category = parts[1] count = int(parts[2]) inventory.donate(category, count) elif parts[0] == \\"query\\": category = parts[1] results.append(inventory.query(category)) return results def execute_inventory_operations(n, operations): return manage_inventory(n, operations)","solution":"class Inventory: def __init__(self): self.categories = {} def donate(self, category, count): if category in self.categories: self.categories[category] += count else: self.categories[category] = count def query(self, category): return self.categories.get(category, 0) def manage_inventory(n, operations): inventory = Inventory() results = [] for op in operations: parts = op.split() if parts[0] == \\"donate\\": category = parts[1] count = int(parts[2]) inventory.donate(category, count) elif parts[0] == \\"query\\": category = parts[1] results.append(inventory.query(category)) return results # Function to be directly called in test cases def execute_inventory_operations(n, operations): return manage_inventory(n, operations)"},{"question":"def max_total_energy(n: int, m: int, energy_values: List[int]) -> int: Returns the maximum total energy Santa can collect by choosing exactly m snowflakes. >>> max_total_energy(3, 5, [100, 200, 300]) 1500 >>> max_total_energy(1, 1, [500]) 500","solution":"def max_total_energy(n, m, energy_values): Returns the maximum total energy Santa can collect by choosing exactly m snowflakes. :param n: int: Number of snowbanks :param m: int: Total number of snowflakes to collect :param energy_values: List[int]: Energy values of snowflakes in each snowbank :return: int: Maximum total energy # Sort energy values in decreasing order to maximize total energy energy_values.sort(reverse=True) # The maximum energy will be the highest energy value multiplied by m max_energy = energy_values[0] * m return max_energy # Example usage: # n = 3, m = 5, energy_values = [100, 200, 300] # The maximum total energy should be 1500 n = 3 m = 5 energy_values = [100, 200, 300] print(max_total_energy(n, m, energy_values)) # Output: 1500"},{"question":"def is_fully_connected(n: int, m: int, routes: List[Tuple[int, int]]) -> str: Determines if it is possible to travel between any two islands using the given sea routes. Parameters: - n: number of islands (1 ≤ n ≤ 100,000) - m: number of sea routes (0 ≤ m ≤ 200,000) - routes: list of tuples representing the sea routes Returns: - \\"Yes\\" if the islands are fully connected, \\"No\\" otherwise pass from collections import defaultdict, deque # Example tests def test_single_island(): assert is_fully_connected(1, 0, []) == \\"Yes\\" def test_fully_connected_three_islands(): assert is_fully_connected(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"Yes\\" def test_disconnected_islands(): assert is_fully_connected(4, 2, [(1, 2), (3, 4)]) == \\"No\\" def test_single_route_no_connection(): assert is_fully_connected(2, 0, []) == \\"No\\" def test_two_connected_islands(): assert is_fully_connected(2, 1, [(1, 2)]) == \\"Yes\\" def test_large_connected_graph(): routes = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)] assert is_fully_connected(5, 5, routes) == \\"Yes\\" def test_large_disconnected_graph(): routes = [(1, 2), (2, 3), (3, 4), (5, 6)] assert is_fully_connected(6, 4, routes) == \\"No\\"","solution":"def is_fully_connected(n, m, routes): Determines if it is possible to travel between any two islands using the given sea routes. Parameters: - n: number of islands (1 ≤ n ≤ 100,000) - m: number of sea routes (0 ≤ m ≤ 200,000) - routes: list of tuples representing the sea routes Returns: - \\"Yes\\" if the islands are fully connected, \\"No\\" otherwise if n == 1: return \\"Yes\\" # Only one island is trivially connected from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) for u, v in routes: graph[u].append(v) graph[v].append(u) # Function to perform BFS def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Perform BFS from the first island (node 1) visited_islands = bfs(1) # Check if all islands are visited return \\"Yes\\" if len(visited_islands) == n else \\"No\\""},{"question":"def can_transform(s1: str, s2: str) -> bool: Check if it's possible to transform s1 into s2 by deleting some characters from s1 without rearranging the order. >>> can_transform(\\"abcde\\", \\"ace\\") True >>> can_transform(\\"abcde\\", \\"aed\\") False pass def transformation_possible(test_cases: List[Tuple[str, str]]) -> List[str]: Takes a list of tuples containing test cases and returns a list of \\"YES\\" or \\"NO\\" for each test case. >>> transformation_possible([(\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aed\\")]) [\\"YES\\", \\"NO\\"] pass from solution import can_transform, transformation_possible def test_can_transform_possible(): assert can_transform(\\"abcde\\", \\"ace\\") == True assert can_transform(\\"abcde\\", \\"abcde\\") == True assert can_transform(\\"abcde\\", \\"a\\") == True assert can_transform(\\"abcde\\", \\"e\\") == True assert can_transform(\\"abcde\\", \\"\\") == True def test_can_transform_not_possible(): assert can_transform(\\"abcde\\", \\"aed\\") == False assert can_transform(\\"abcde\\", \\"abcdef\\") == False assert can_transform(\\"abcde\\", \\"f\\") == False def test_transformation_possible(): test_cases = [(\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aed\\"), (\\"abcde\\", \\"abcde\\"), (\\"abcde\\", \\"abcdef\\"), (\\"abcde\\", \\"\\"), (\\"abcde\\", \\"a\\")] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert transformation_possible(test_cases) == expected_results","solution":"def can_transform(s1, s2): Check if it's possible to transform s1 into s2 by deleting some characters from s1 without rearranging the order. i, j = 0, 0 while i < len(s1) and j < len(s2): if s1[i] == s2[j]: j += 1 i += 1 return j == len(s2) def transformation_possible(test_cases): Takes a list of tuples containing test cases and returns a list of \\"YES\\" or \\"NO\\" for each test case. results = [] for s1, s2 in test_cases: if can_transform(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_unique_transformed_representations(n: int, variable_names: List[str]) -> int: Returns the number of unique transformed representations of variable names by permuting their characters. Parameters: n (int): The number of variable names. variable_names (List[str]): List of variable names. Returns: int: Number of unique transformed representations. >>> count_unique_transformed_representations(4, ['abc', 'bca', 'dac', 'cad']) == 2 >>> count_unique_transformed_representations(3, ['abcd', 'efgh', 'ijkl']) == 3 >>> count_unique_transformed_representations(3, ['abc', 'cab', 'bca']) == 1 >>> count_unique_transformed_representations(4, ['abcdefghij', 'jihgfedcba', 'abcdefghij', 'mnopqrstuv']) == 2 >>> count_unique_transformed_representations(1, ['a']) == 1 >>> count_unique_transformed_representations(3, ['a'*100000, 'a'*100000, 'a'*100000]) == 1 >>> count_unique_transformed_representations(0, []) == 0","solution":"def count_unique_transformed_representations(n, variable_names): Returns the number of unique transformed representations of variable names by permuting their characters. Parameters: n (int): The number of variable names. variable_names (List[str]): List of variable names. Returns: int: Number of unique transformed representations. unique_representations = set() for name in variable_names: sorted_name = ''.join(sorted(name)) unique_representations.add(sorted_name) return len(unique_representations)"},{"question":"from typing import List import math from collections import Counter def number_of_anagrams(n: int, book_titles: List[str]) -> List[int]: Determine the number of distinct anagrams a given book title can form. Parameters: n (int): The number of book titles. book_titles (List[str]): A list of strings representing book titles. Returns: List[int]: A list of integers where the i-th integer is the number of distinct anagrams of the i-th book title. >>> number_of_anagrams(2, ['aabb', 'abc']) [6, 6] >>> number_of_anagrams(3, ['a', 'b', 'c']) [1, 1, 1] Example of usage: number_of_anagrams(2, ['aabb', 'abc']) results = [] for title in book_titles: freq = Counter(title) denominator = 1 for count in freq.values(): denominator *= math.factorial(count) total_anagrams = math.factorial(len(title)) // denominator results.append(total_anagrams) return results","solution":"import math from collections import Counter def count_anagrams(book_titles): results = [] for title in book_titles: freq = Counter(title) denominator = 1 for count in freq.values(): denominator *= math.factorial(count) total_anagrams = math.factorial(len(title)) // denominator results.append(total_anagrams) return results def number_of_anagrams(n, book_titles): return count_anagrams(book_titles)"},{"question":"def find_subarray(n: int, k: int, pages: List[int]) -> Union[str, Tuple[str, int, int]]: Finds any consecutive subarray of books such that the sum of the pages in the subarray is divisible by k. Parameters: n (int): Number of books on the shelf. k (int): The divisor. pages (List[int]): List with the number of pages in each book. Returns: Union[str, Tuple[str, int, int]]: A tuple with a string \\"Yes\\" and two indices (1-based) if solution exists, otherwise a string \\"No Solution\\". >>> find_subarray(5, 5, [1, 2, 3, 4, 5]) (\\"Yes\\", 1, 3) >>> find_subarray(3, 7, [1, 2, 3]) \\"No Solution\\" >>> find_subarray(1, 3, [3]) (\\"Yes\\", 1, 1) >>> find_subarray(6, 5, [5, 5, 10, 15, 10, 5]) (\\"Yes\\", 1, 1) # among several possible answers >>> find_subarray(10, 20, [18, 1, 4, 7, 12, 5, 3, 20, 7, 9]) (\\"Yes\\", 1, 3) # among several possible answers","solution":"def find_subarray(n, k, pages): Finds any consecutive subarray of books such that the sum of the pages in the subarray is divisible by k. Parameters: n (int): Number of books on the shelf. k (int): The divisor. pages (list of int): List with the number of pages in each book. Returns: tuple: A tuple with a string \\"Yes\\" and two indices (1-based) if solution exists, otherwise a string \\"No Solution\\". remainder_map = {0: -1} current_sum = 0 # Iterate through the books and check for valid subarray for i in range(n): current_sum += pages[i] remainder = current_sum % k if remainder in remainder_map: start_index = remainder_map[remainder] + 1 end_index = i + 1 # 1-based indexing return \\"Yes\\", start_index + 1, end_index remainder_map[remainder] = i return \\"No Solution\\" # Example usage: # n = 5, k = 5 # pages = [1, 2, 3, 4, 5] # find_subarray(n, k, pages) should return (\\"Yes\\", 1, 3) or similar valid range"},{"question":"def canFormTargetWeight(weights, target): Determines if a subset of weights can sum up to the target weight. Args: weights: list of integers representing the weights. target: integer representing the target weight. Returns: string \\"YES\\" if it is possible to form the target weight, otherwise \\"NO\\". Example: >>> canFormTargetWeight([3, 34, 4, 12, 5], 9) \\"YES\\" >>> canFormTargetWeight([1, 2, 5], 4) \\"NO\\"","solution":"def canFormTargetWeight(weights, target): Determines if a subset of weights can sum up to the target weight. Args: weights: list of integers representing the weights. target: integer representing the target weight. Returns: string \\"YES\\" if it is possible to form the target weight, otherwise \\"NO\\". n = len(weights) # Create a 2D array to store the solutions to subproblems dp = [[False] * (target + 1) for _ in range(n + 1)] # If target is 0, then the answer is True (0 sum is possible with empty subset) for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, target + 1): if j < weights[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j - weights[i-1]] # The answer is in the bottom right corner of the dp array return \\"YES\\" if dp[n][target] else \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxDepth(root) 3 >>> root = None >>> maxDepth(root) 0 >>> root = TreeNode(1) >>> maxDepth(root) 1 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of a binary tree. if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def max_videos_watchable(n: int, videos: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping videos Alex can watch. Parameters: n (int): Number of videos. videos (list of tuples): List containing the start and end times of each video. Returns: int: Maximum number of videos that can be watched without overlaps. # Sort the videos by their end time. return from typing import List, Tuple def test_single_video(): assert max_videos_watchable(1, [(1, 2)]) == 1 def test_non_overlapping_videos(): assert max_videos_watchable(3, [(1, 2), (3, 4), (5, 6)]) == 3 def test_all_overlapping_videos(): assert max_videos_watchable(3, [(1, 5), (2, 6), (3, 7)]) == 1 def test_mixed_videos(): assert max_videos_watchable(5, [(1, 3), (2, 5), (4, 6), (6, 7), (5, 8)]) == 3 def test_videos_with_gaps(): assert max_videos_watchable(4, [(1, 2), (4, 5), (6, 7), (9, 10)]) == 4 def test_large_dataset(): # Create test case with n = 100000 and slightly staggered times n = 100000 videos = [(i, i + 2) for i in range(1, 200001, 2)] assert max_videos_watchable(n, videos) == 100000","solution":"def max_videos_watchable(n, videos): Determines the maximum number of non-overlapping videos Alex can watch. Parameters: n (int): Number of videos. videos (list of tuples): List containing the start and end times of each video. Returns: int: Maximum number of videos that can be watched without overlaps. # Sort the videos by their end time videos.sort(key=lambda x: x[1]) max_videos = 0 last_end_time = -1 for start, end in videos: if start >= last_end_time: max_videos += 1 last_end_time = end return max_videos"},{"question":"def group_and_sort_characters(input_str: str) -> str: This function takes a string containing lowercase alphabetical characters and digits, separates them into alphabetical and numerical groups, sorts each group, and then concatenates the sorted groups in order with alphabetical characters first. >>> group_and_sort_characters('bd3a2c1') == 'abcd123' >>> group_and_sort_characters('a1b2c3') == 'abc123' >>> group_and_sort_characters('z9y8x7w6') == 'wxyz6789' >>> group_and_sort_characters('a') == 'a' >>> group_and_sort_characters('1') == '1' >>> group_and_sort_characters('') == '' >>> group_and_sort_characters('a1z9b8y7c6') == 'abcyz16789' >>> group_and_sort_characters('123xyz') == 'xyz123' >>> group_and_sort_characters('x7y6') == 'xy67' >>> group_and_sort_characters('7y9x') == 'xy79'","solution":"def group_and_sort_characters(input_str): This function takes a string containing lowercase alphabetical characters and digits, separates them into alphabetical and numerical groups, sorts each group, and then concatenates the sorted groups in order with alphabetical characters first. alphabetical_chars = [] numerical_chars = [] for char in input_str: if char.isalpha(): alphabetical_chars.append(char) elif char.isdigit(): numerical_chars.append(char) sorted_alphabetical = ''.join(sorted(alphabetical_chars)) sorted_numerical = ''.join(sorted(numerical_chars)) return sorted_alphabetical + sorted_numerical"},{"question":"def unique_operations_to_empty_string(s: str) -> int: Determine the number of unique operations needed to make the string empty by removing all occurrences of specific characters. >>> unique_operations_to_empty_string(\\"abacbc\\") 3 >>> unique_operations_to_empty_string(\\"aabbcc\\") 3","solution":"def unique_operations_to_empty_string(s): Returns the number of unique operations needed to make the string s empty. # Using a set to find unique characters unique_chars = set(s) # The number of unique operations is the number of unique characters return len(unique_chars)"},{"question":"def generate_fence_posts(x1: int, y1: int, x2: int, y2: int) -> List[Tuple[int, int]]: Generate all unique integer-coordinate fence post locations around the rectangle boundary formed by (x1, y1) and (x2, y2) in a clockwise order starting from (x1, y1). >>> generate_fence_posts(1, 1, 4, 3) [(1, 1), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3), (3, 3), (2, 3), (1, 3), (1, 2)] >>> generate_fence_posts(4, 3, 1, 1) [(1, 1), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3), (3, 3), (2, 3), (1, 3), (1, 2)] >>> generate_fence_posts(-2, -3, 2, 1) [(-2, -3), (-1, -3), (0, -3), (1, -3), (2, -3), (2, -2), (2, -1), (2, 0), (2, 1), (1, 1), (0, 1), (-1, 1), (-2, 1), (-2, 0), (-2, -1), (-2, -2)] >>> generate_fence_posts(0, 0, 3, 5) [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (2, 5), (1, 5), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1)] >>> generate_fence_posts(9998, -9998, 10000, -9995) [(9998, -9998), (9999, -9998), (10000, -9998), (10000, -9997), (10000, -9996), (10000, -9995), (9999, -9995), (9998, -9995), (9998, -9996), (9998, -9997)]","solution":"def generate_fence_posts(x1, y1, x2, y2): Generate all unique integer-coordinate fence post locations around the rectangle boundary formed by (x1, y1) and (x2, y2) in a clockwise order starting from (x1, y1). if x1 > x2: x1, x2 = x2, x1 if y1 > y2: y1, y2 = y2, y1 perimeter_posts = [] # Bottom edge (y1) for x in range(x1, x2 + 1): perimeter_posts.append((x, y1)) # Right edge (x2) for y in range(y1 + 1, y2 + 1): perimeter_posts.append((x2, y)) # Top edge (y2) for x in range(x2 - 1, x1 - 1, -1): perimeter_posts.append((x, y2)) # Left edge (x1) for y in range(y2 - 1, y1, -1): perimeter_posts.append((x1, y)) return perimeter_posts"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def solve(test_cases): Determine the size of the maximum independent set (MIS) for given binary trees. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test case inputs, where each test case is a tuple containing an integer n representing the number of nodes and a list of tuples representing the edges. Returns: List[int]: List of integers indicating the size of the maximum independent set for each binary tree. Example: >>> solve([(5, [(1, 2), (1, 3), (2, 4), (2, 5)])]) [3] >>> solve([(6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)])]) [3] def test_case_1(): test_cases = [(5, [(1, 2), (1, 3), (2, 4), (2, 5)])] assert solve(test_cases) == [3] def test_case_2(): test_cases = [(6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)])] assert solve(test_cases) == [3] def test_case_3(): test_cases = [(7, [(1, 2), (2, 3), (2, 4), (3, 5), (3, 6), (4, 7)])] assert solve(test_cases) == [4] def test_case_4(): test_cases = [(3, [(1, 2), (1, 3)])] assert solve(test_cases) == [2] def test_case_5(): test_cases = [(1, [])] assert solve(test_cases) == [1] def test_case_6(): test_cases = [ (5, [(1, 2), (1, 3), (2, 4), (2, 5)]), (6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)]) ] assert solve(test_cases) == [3, 3]","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(edges, n): nodes = {i: TreeNode(i) for i in range(1, n + 1)} for u, v in edges: nodes[u].children.append(nodes[v]) nodes[v].children.append(nodes[u]) return nodes[1] def mis(node, parent): if not node: return 0 inclusive = 1 for child in node.children: if child != parent: for grandchild in child.children: if grandchild != node: inclusive += mis(grandchild, child) exclusive = 0 for child in node.children: if child != parent: exclusive += mis(child, node) return max(inclusive, exclusive) def find_mis(tree, n): return mis(tree, None) def solve(test_cases): results = [] for n, edges in test_cases: if n == 0: results.append(0) continue tree = build_tree(edges, n) results.append(find_mis(tree, n)) return results"},{"question":"def can_rearrange_no_adjacent(s: str) -> str: Determines if the string can be rearranged such that no two adjacent characters are the same. Parameters: s (str): The input string consisting of lowercase letters. Returns: str: \\"YES\\" if the string can be rearranged accordingly, otherwise \\"NO\\". >>> can_rearrange_no_adjacent(\\"aab\\") \\"YES\\" >>> can_rearrange_no_adjacent(\\"aaab\\") \\"NO\\"","solution":"from collections import Counter def can_rearrange_no_adjacent(s): Determines if the string can be rearranged such that no two adjacent characters are the same. Parameters: s (str): The input string consisting of lowercase letters. Returns: str: \\"YES\\" if the string can be rearranged accordingly, otherwise \\"NO\\". # Count the frequency of each character freq = Counter(s) # Find the maximum frequency of any character max_freq = max(freq.values()) # Check if any character frequency is greater than half the length of the string plus one if max_freq > (len(s) + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def determine_winner(n: int, ratings: List[int]) -> int: This function takes in the number of players \`n\` and a list of their ratings \`ratings\`, and returns the expected winner of the tournament based on their ratings. >>> determine_winner(4, [100, 200, 300, 400]) 400 >>> determine_winner(1, [500]) 500 >>> determine_winner(5, [100, 200, 300, 400, 500]) 500 >>> determine_winner(3, [123, 456, 789]) 789 >>> determine_winner(6, [10, 20, 30, 40, 50, 60]) 60","solution":"def determine_winner(n, ratings): This function takes in the number of players \`n\` and a list of their ratings \`ratings\`, and returns the expected winner of the tournament based on their ratings. # The player with the highest rating will always win return ratings[-1]"},{"question":"def longest_palindromic_substring(s: str) -> str: This function returns the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring(\\"babad\\") == \\"bab\\" or longest_palindromic_substring(\\"babad\\") == \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"abcde\\") == \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"racecarxyz\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" or longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"cdc\\" >>> longest_palindromic_substring(\\"\\") == \\"\\"","solution":"def longest_palindromic_substring(s): This function returns the longest palindromic substring in the given string \`s\`. if len(s) == 0: return \\"\\" n = len(s) start, maxlen = 0, 1 # starting index and length of longest palindrome for i in range(n): for j in range(i, n): substr = s[i:j+1] if substr == substr[::-1]: # check if the substring is a palindrome if len(substr) > maxlen: start, maxlen = i, len(substr) return s[start:start + maxlen]"},{"question":"def get_min_max_subsequences(n: int, k: int, sequence: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples where each tuple contains the minimum and maximum value of each subsequence of length k. n: int - the length of the sequence k: int - the length of the subsequences sequence: list of int - the sequence of performance values >>> get_min_max_subsequences(8, 3, [5, 1, 3, 8, 6, 4, 7, 2]) [(1, 5), (1, 8), (3, 8), (4, 8), (4, 7), (2, 7)] >>> get_min_max_subsequences(5, 2, [2, 2, 2, 2, 2]) [(2, 2), (2, 2), (2, 2), (2, 2)] >>> get_min_max_subsequences(4, 2, [10, 9, 8, 7]) [(9, 10), (8, 9), (7, 8)] >>> get_min_max_subsequences(5, 3, [1, 2, 3, 4, 5]) [(1, 3), (2, 4), (3, 5)] >>> get_min_max_subsequences(6, 6, [3, 1, 4, 1, 5, 9]) [(1, 9)] ... def format_output(result: List[Tuple[int, int]]) -> List[str]: Formats the output as specified. result: list of tuples (min_val, max_val) - the list of min and max values for each subsequence >>> format_output([(1, 5), (1, 8), (3, 8), (4, 8), (4, 7), (2, 7)]) ['1 5', '1 8', '3 8', '4 8', '4 7', '2 7'] >>> format_output([(2, 2), (2, 2), (2, 2), (2, 2)]) ['2 2', '2 2', '2 2', '2 2'] >>> format_output([(9, 10), (8, 9), (7, 8)]) ['9 10', '8 9', '7 8'] >>> format_output([(1, 3), (2, 4), (3, 5)]) ['1 3', '2 4', '3 5'] >>> format_output([(1, 9)]) ['1 9'] ... from solution import get_min_max_subsequences, format_output def test_basic_case(): n, k = 8, 3 sequence = [5, 1, 3, 8, 6, 4, 7, 2] expected = [\\"1 5\\", \\"1 8\\", \\"3 8\\", \\"4 8\\", \\"4 7\\", \\"2 7\\"] result = get_min_max_subsequences(n, k, sequence) assert format_output(result) == expected def test_all_same_values(): n, k = 5, 2 sequence = [2, 2, 2, 2, 2] expected = [\\"2 2\\", \\"2 2\\", \\"2 2\\", \\"2 2\\"] result = get_min_max_subsequences(n, k, sequence) assert format_output(result) == expected def test_decreasing_sequence(): n, k = 4, 2 sequence = [10, 9, 8, 7] expected = [\\"9 10\\", \\"8 9\\", \\"7 8\\"] result = get_min_max_subsequences(n, k, sequence) assert format_output(result) == expected def test_increasing_sequence(): n, k = 5, 3 sequence = [1, 2, 3, 4, 5] expected = [\\"1 3\\", \\"2 4\\", \\"3 5\\"] result = get_min_max_subsequences(n, k, sequence) assert format_output(result) == expected def test_large_k_equals_n(): n, k = 6, 6 sequence = [3, 1, 4, 1, 5, 9] expected = [\\"1 9\\"] result = get_min_max_subsequences(n, k, sequence) assert format_output(result) == expected","solution":"def get_min_max_subsequences(n, k, sequence): Returns a list of tuples where each tuple contains the minimum and maximum value of each subsequence of length k. n: int - the length of the sequence k: int - the length of the subsequences sequence: list of int - the sequence of performance values result = [] for i in range(n - k + 1): subsequence = sequence[i:i + k] result.append((min(subsequence), max(subsequence))) return result # Function to format the output as specified def format_output(result): formatted_result = [] for min_val, max_val in result: formatted_result.append(f\\"{min_val} {max_val}\\") return formatted_result"},{"question":"def min_removal_cost(n: int, a: List[int]) -> int: Returns the minimum cost to remove all elements from the array. n: int - The number of elements in the array. a: List[int] - The list of integers. >>> min_removal_cost(3, [3, 2, 4]) 1 >>> min_removal_cost(4, [1, 3, 2, 4]) 1 >>> min_removal_cost(1, [5]) 0 >>> min_removal_cost(5, [10, 11, 10, 9, 8]) 1 >>> min_removal_cost(3, [10, 10, 10]) 0","solution":"def min_removal_cost(n, a): Returns the minimum cost to remove all elements from the array. n: int - The number of elements in the array. a: List[int] - The list of integers. if n == 1: return 0 min_cost = float('inf') for i in range(n-1): min_cost = min(min_cost, abs(a[i] - a[i+1])) return min_cost"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: You are given an array of integers where each element represents the price of a stock on a given day. Your task is to determine the days on which you should buy and sell the stock to maximize your profit. However, you can make at most two transactions throughout the entire period. A transaction consists of buying on one day and selling on another later day. Args: prices (List[int]): A list of integer prices. Returns: int: The maximum profit with at most two transactions. Examples: >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: if not prices: return 0 n = len(prices) # Initialize arrays for the profit left_profits = [0] * n right_profits = [0] * n # Fill the left_profits array left_min_price = prices[0] for i in range(1, n): left_profits[i] = max(left_profits[i-1], prices[i] - left_min_price) left_min_price = min(left_min_price, prices[i]) # Fill the right_profits array right_max_price = prices[-1] for i in range(n-2, -1, -1): right_profits[i] = max(right_profits[i+1], right_max_price - prices[i]) right_max_price = max(right_max_price, prices[i]) # Calculate the maximum possible profit max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"from typing import List, Tuple def find_LIS_length_and_sequence(arr: List[int]) -> Tuple[int, List[int]]: Determine the length of the longest increasing subsequence (LIS) in an array and reconstruct one such subsequence. >>> find_LIS_length_and_sequence([5, 2, 8, 6, 3, 6]) (3, [2, 6, 8]) >>> find_LIS_length_and_sequence([1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> find_LIS_length_and_sequence([5, 4, 3, 2, 1]) (1, [5]) >>> find_LIS_length_and_sequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) (6, [10, 22, 33, 50, 60, 80]) >>> find_LIS_length_and_sequence([10]) (1, [10]) >>> find_LIS_length_and_sequence([]) (0, [])","solution":"from typing import List, Tuple def find_LIS_length_and_sequence(arr: List[int]) -> Tuple[int, List[int]]: n = len(arr) if n == 0: return (0, []) # Create an array to store the length of LIS at each index lis_lengths = [1] * n prev_index = [-1] * n # Array to reconstruct the path # Populate the lis_lengths array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis_lengths[i] < lis_lengths[j] + 1: lis_lengths[i] = lis_lengths[j] + 1 prev_index[i] = j # Find the maximum length of LIS and its last index max_length = max(lis_lengths) max_index = lis_lengths.index(max_length) # Reconstruct the LIS sequence lis_sequence = [] while max_index != -1: lis_sequence.append(arr[max_index]) max_index = prev_index[max_index] lis_sequence.reverse() # The sequence was built backwards, so reverse it return (max_length, lis_sequence)"},{"question":"def is_valid_string(s: str) -> str: Determine if the given string is valid according to Alice's criteria. A string is considered valid if it does not contain any substring that is repeated consecutively. Output 'YES' if the string is valid, and 'NO' otherwise. >>> is_valid_string(\\"a\\") \\"YES\\" >>> is_valid_string(\\"abcde\\") \\"YES\\" >>> is_valid_string(\\"abab\\") \\"NO\\" >>> is_valid_string(\\"abcabc\\") \\"NO\\" >>> is_valid_string(\\"aabbaabb\\") \\"NO\\" >>> is_valid_string(\\"abacabad\\") \\"YES\\" >>> is_valid_string(\\"xyxy\\") \\"NO\\"","solution":"def is_valid_string(s): Returns 'YES' if the string is valid, 'NO' otherwise. A string is considered valid if it does not contain any substring that is repeated consecutively. length = len(s) for i in range(1, length // 2 + 1): for j in range(length - i * 2 + 1): if s[j:j + i] == s[j + i:j + i * 2]: return \\"NO\\" return \\"YES\\""},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Finds an integer that appears an odd number of times in the array. Parameters: arr (list): List of integers. Returns: int: An integer that appears an odd number of times, or -1 if there is none. Example: >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 1]) 1 >>> find_odd_occurrence([2, 2, 3, 3]) -1 >>> find_odd_occurrence([5]) 5 >>> find_odd_occurrence([4, 4, 7, 7, 9]) 9 pass def find_odd_occurrence_from_input(n: int, elements: List[int]) -> int: Wrapper to facilitate input processing as per the given problem statement Parameters: n (int): Number of elements in the array. elements (list): The array of integers. Returns: int: An integer that appears an odd number of times, or -1 if there is none. pass","solution":"def find_odd_occurrence(arr): Finds an integer that appears an odd number of times in the array. Parameters: arr (list): List of integers. Returns: int: An integer that appears an odd number of times, or -1 if there is none. count_map = {} # Count the occurrences of each element for num in arr: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 # Find an element that appears an odd number of times for num, count in count_map.items(): if count % 2 != 0: return num return -1 def find_odd_occurrence_from_input(n, elements): Wrapper to facilitate input processing as per the given problem statement Parameters: n (int): Number of elements in the array. elements (list): The array of integers. Returns: int: An integer that appears an odd number of times, or -1 if there is none. return find_odd_occurrence(elements)"},{"question":"def has_same_color_edge(n: int, m: int, k: int, colors: List[int], edges: List[Tuple[int, int]]) -> str: Checks if there exists any edge in the graph where both endpoints have the same color. Parameters: n (int): Number of nodes m (int): Number of edges k (int): Number of colors colors (List[int]): List of node colors edges (List[Tuple[int, int]]): List of edges Returns: str: \\"YES\\" if an edge with both endpoints having the same color exists, otherwise \\"NO\\" pass # Example Test Cases def test_edge_with_same_colors_exists(): n = 5 m = 5 k = 2 colors = [1, 2, 1, 2, 1] edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert has_same_color_edge(n, m, k, colors, edges) == \\"YES\\" def test_no_edge_with_same_colors(): n = 5 m = 4 k = 3 colors = [1, 2, 3, 1, 2] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert has_same_color_edge(n, m, k, colors, edges) == \\"NO\\" def test_single_edge_same_colors(): n = 2 m = 1 k = 1 colors = [1, 1] edges = [(1, 2)] assert has_same_color_edge(n, m, k, colors, edges) == \\"YES\\" def test_single_edge_different_colors(): n = 2 m = 1 k = 2 colors = [1, 2] edges = [(1, 2)] assert has_same_color_edge(n, m, k, colors, edges) == \\"NO\\" def test_large_graph_no_same_color_edges(): n = 5 m = 4 k = 5 colors = [1, 2, 3, 4, 5] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert has_same_color_edge(n, m, k, colors, edges) == \\"NO\\"","solution":"def has_same_color_edge(n, m, k, colors, edges): Checks if there exists any edge in the graph where both endpoints have the same color. Parameters: n (int): Number of nodes m (int): Number of edges k (int): Number of colors colors (List[int]): List of node colors edges (List[Tuple[int, int]]): List of edges Returns: str: \\"YES\\" if an edge with both endpoints having the same color exists, otherwise \\"NO\\" for u, v in edges: if colors[u-1] == colors[v-1]: return \\"YES\\" return \\"NO\\""},{"question":"def max_coins(n: int, coins: List[int]) -> int: Determines the maximum number of coins Mario can collect by stepping into the next room or by skipping exactly one room. >>> max_coins(1, [7]) 7 >>> max_coins(2, [1, 2]) 2 >>> max_coins(5, [1, 2, 9, 4, 5]) 15 >>> max_coins(4, [0, 0, 0, 0]) 0 >>> max_coins(6, [1, 2, 3, 4, 5, 6]) 12 >>> max_coins(10, [1, 100, 1, 100, 1, 100, 1, 100, 1, 100]) 500","solution":"def max_coins(n, coins): if n == 0: return 0 if n == 1: return coins[0] # dp array where dp[i] will store the maximum coins that can be collected up to room i dp = [0] * n # Start by setting up the base cases dp[0] = coins[0] if n > 1: dp[1] = max(coins[0], coins[1]) # Fill in the dp array for the rest of the rooms for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + coins[i]) return dp[n-1]"},{"question":"def replace_words_with_emojis(n: int, replacements: List[Tuple[str, str]], message: str) -> str: Replaces specified words in a message with their corresponding emojis. :param n: Number of replacement pairs. :param replacements: List of tuples containing a word and its corresponding emoji. :param message: The message in which words need to be replaced with emojis. :return: Processed message with words replaced by emojis. return message # Example Usage: # replacements = [(\\"hello\\", \\"😊\\"), (\\"world\\", \\"🌍\\"), (\\"python\\", \\"🐍\\")] # message = \\"hello world, welcome to the python world!\\" # print(replace_words_with_emojis(3, replacements, message)) # Should output: \\"😊 🌍, welcome to the 🐍 🌍!\\" from typing import List, Tuple def test_replace_single_word(): assert replace_words_with_emojis(1, [(\\"hello\\", \\"😊\\")], \\"hello there\\") == \\"😊 there\\" def test_replace_multiple_words(): assert replace_words_with_emojis(2, [(\\"hello\\", \\"😊\\"), (\\"there\\", \\"🌍\\")], \\"hello there\\") == \\"😊 🌍\\" def test_no_replacements(): assert replace_words_with_emojis(1, [(\\"goodbye\\", \\"😊\\")], \\"hello there\\") == \\"hello there\\" def test_replace_with_punctuation(): assert replace_words_with_emojis(1, [(\\"hello\\", \\"😊\\")], \\"hello, how are you?\\") == \\"😊, how are you?\\" def test_multiple_occurrences(): assert replace_words_with_emojis(1, [(\\"world\\", \\"🌍\\")], \\"world hello world\\") == \\"🌍 hello 🌍\\" def test_case_sensitive(): assert replace_words_with_emojis(1, [(\\"hello\\", \\"😊\\")], \\"Hello there\\") == \\"Hello there\\" def test_example_case(): replacements = [(\\"hello\\", \\"😊\\"), (\\"world\\", \\"🌍\\"), (\\"python\\", \\"🐍\\")] message = \\"hello world, welcome to the python world!\\" assert replace_words_with_emojis(3, replacements, message) == \\"😊 🌍, welcome to the 🐍 🌍!\\"","solution":"def replace_words_with_emojis(n, replacements, message): Replaces specified words in a message with their corresponding emojis. :param n: Number of replacement pairs. :param replacements: List of tuples containing a word and its corresponding emoji. :param message: The message in which words need to be replaced with emojis. :return: Processed message with words replaced by emojis. for word, emoji in replacements: message = message.replace(word, emoji) return message # Example Usage: # replacements = [(\\"hello\\", \\"😊\\"), (\\"world\\", \\"🌍\\"), (\\"python\\", \\"🐍\\")] # message = \\"hello world, welcome to the python world!\\" # print(replace_words_with_emojis(3, replacements, message)) # Should output: \\"😊 🌍, welcome to the 🐍 🌍!\\""},{"question":"from collections import defaultdict, deque class BinaryTree: def __init__(self, n, values, edges): self.n = n self.values = values self.adj = defaultdict(list) for u, v in edges: self.adj[u].append(v) self.adj[v].append(u) def update_value(self, x, value): self.values[x-1] = value def query_max_value(self, x, k): queue = deque([(x, 0)]) visited = set([x]) max_value = self.values[x-1] while queue: node, distance = queue.popleft() if distance > k: continue max_value = max(max_value, self.values[node-1]) for neighbor in self.adj[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return max_value def process_queries(n, values, edges, queries): Process a list of queries on a tree with n nodes. Args: n (int): The number of nodes in the tree. values (List[int]): Initial values of the nodes. edges (List[Tuple[int, int]]): The tree edges. queries (List[str]): List of queries to process. Returns: List[int]: The results of all QUERY type queries. >>> n = 5 >>> values = [3, 4, 5, 1, 2] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [\\"QUERY 2 1\\", \\"UPDATE 4 6\\", \\"QUERY 1 2\\"] >>> process_queries(n, values, edges, queries) [4, 6]","solution":"from collections import defaultdict, deque class BinaryTree: def __init__(self, n, values, edges): self.n = n self.values = values self.adj = defaultdict(list) for u, v in edges: self.adj[u].append(v) self.adj[v].append(u) def update_value(self, x, value): self.values[x-1] = value def query_max_value(self, x, k): queue = deque([(x, 0)]) visited = set([x]) max_value = self.values[x-1] while queue: node, distance = queue.popleft() if distance > k: continue max_value = max(max_value, self.values[node-1]) for neighbor in self.adj[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return max_value def process_queries(n, values, edges, queries): tree = BinaryTree(n, values, edges) result = [] for query in queries: parts = query.split() if parts[0] == 'UPDATE': x, value = int(parts[1]), int(parts[2]) tree.update_value(x, value) elif parts[0] == 'QUERY': x, k = int(parts[1]), int(parts[2]) result.append(tree.query_max_value(x, k)) return result # Example usage n = 5 values = [3, 4, 5, 1, 2] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [\\"QUERY 2 1\\", \\"UPDATE 4 6\\", \\"QUERY 1 2\\"] results = process_queries(n, values, edges, queries) print(\\"n\\".join(map(str, results))) # Example will print: 4, 6"},{"question":"from typing import List, Tuple def shortest_travel_time(n: int, roads: List[Tuple[int, int, int]], u: int, v: int) -> int: Calculate the minimum travel time required to travel from castle u to castle v. Args: n : int : the number of castles roads : List[Tuple[int, int, int]] : list of tuples representing roads where each tuple contains two castles and the length of the road between them u : int : the starting castle v : int : the destination castle Returns: int : the minimum travel time required to travel from castle u to castle v Example: >>> shortest_travel_time(5, [(1, 2, 3), (1, 3, 1), (2, 4, 4), (2, 5, 2)], 4, 5) 6 >>> shortest_travel_time(2, [(1, 2, 5)], 1, 2) 5 >>> shortest_travel_time(4, [(1, 2, 2), (1, 3, 4), (3, 4, 1), (2, 4, 7)], 1, 4) 5 >>> shortest_travel_time(3, [(1, 2, 4), (2, 3, 6)], 1, 3) 10 >>> shortest_travel_time(3, [(1, 2, 4), (2, 3, 6)], 1, 1) 0","solution":"import sys import heapq from collections import defaultdict def dijkstra(graph, start, end): # Min-heap priority queue for Dijkstra's algorithm heap = [(0, start)] # Dictionary to store the shortest distance to each node distances = {i: float('inf') for i in graph} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_distance > distances[current_node]: continue if current_node == end: return current_distance for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances[end] def shortest_travel_time(n, roads, u, v): graph = defaultdict(list) for road in roads: start, end, weight = road graph[start].append((end, weight)) graph[end].append((start, weight)) return dijkstra(graph, u, v)"},{"question":"def count_nice_segments(n: int, arr: List[int]) -> int: Returns the number of nice segments in the array where the sum is divisible by 5. >>> count_nice_segments(5, [1, 2, 3, 4, 5]) 4 >>> count_nice_segments(1, [5]) 1 >>> count_nice_segments(1, [3]) 0 >>> count_nice_segments(3, [1, 1, 1]) 0 >>> count_nice_segments(3, [5, 5, 5]) 6 >>> count_nice_segments(5, [2, 3, 1, 6, -1]) 3","solution":"def count_nice_segments(n, arr): Returns the number of nice segments in the array where the sum is divisible by 5. count = 0 prefix_sums = {0: 1} current_sum = 0 for num in arr: current_sum += num remainder = current_sum % 5 if remainder in prefix_sums: count += prefix_sums[remainder] prefix_sums[remainder] = prefix_sums.get(remainder, 0) + 1 return count"},{"question":"def is_subsequence(S: str, T: str) -> str: Determines if T is a subsequence of S. Args: S: string (1 ≤ |S| ≤ 10^4) T: string (1 ≤ |T| ≤ 10^4) Returns: \\"Yes\\" if T is a subsequence of S, otherwise \\"No\\". >>> is_subsequence(\\"abcde\\", \\"ace\\") 'Yes' >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"No\\"","solution":"def is_subsequence(S, T): Determines if T is a subsequence of S. Args: S: string T: string Returns: \\"Yes\\" if T is a subsequence of S, otherwise \\"No\\". iter_s = iter(S) return \\"Yes\\" if all(char in iter_s for char in T) else \\"No\\""},{"question":"def does_robot_return(commands: str) -> str: Determines if the robot returns to the starting cell after executing all commands. :param commands: str - A string containing the sequence of commands. :return: str - \\"YES\\" if the robot returns to (0, 0), otherwise \\"NO\\". >>> does_robot_return(\\"UD\\") \\"YES\\" >>> does_robot_return(\\"LL\\") \\"NO\\"","solution":"def does_robot_return(commands): Determines if the robot returns to the starting cell after executing all commands. :param commands: str - A string containing the sequence of commands. :return: str - \\"YES\\" if the robot returns to (0, 0), otherwise \\"NO\\". x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def max_coins(matrix): Xander is trying to traverse a grid to collect as many coins as possible. The grid is represented as an m x n matrix where each element of the matrix represents the number of coins at that cell. Xander starts at the top-left corner of the matrix, and he can only move either to the right or down at each step. He wants to collect the maximum number of coins by the time he reaches the bottom-right corner of the matrix. Args: matrix (List[List[int]]): The grid represented as a list of lists of integers. Returns: int: The maximum number of coins Xander can collect. >>> max_coins([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_coins([ ... [5] ... ]) 5 >>> max_coins([ ... [1, 2, 3, 4] ... ]) 10 >>> max_coins([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_coins([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_coins([ ... [100, 100, 100], ... [100, 100, 100], ... [100, 100, 100] ... ]) 500","solution":"def max_coins(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"from collections import deque from typing import List def min_moves(n: int, m: int, grid: List[List[str]]) -> int: Determine the minimum distance required to travel from the top-left corner to the bottom-right corner of the grid. >>> min_moves(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 4 >>> min_moves(3, 3, [['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.']]) -1 >>> min_moves(1, 1, [['.']]) 0 >>> min_moves(4, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.']]) 5 >>> min_moves(5, 5, [['.', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '.', '.', '.', '.'], ['#', '#', '#', '#', '.'], ['.', '.', '.', '.', '.']]) 8","solution":"from collections import deque def min_moves(n, m, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def can_transform(s, t): Determines if string s can be transformed into string t using the allowed operations. >>> can_transform(\\"abc\\", \\"cba\\") 'YES' >>> can_transform(\\"a\\", \\"ab\\") 'YES' >>> can_transform(\\"abc\\", \\"def\\") 'NO' >>> can_transform(\\"same\\", \\"same\\") 'YES' >>> can_transform(\\"xyz\\", \\"abc\\") 'NO' >>> can_transform(\\"a\\", \\"b\\") 'NO' pass def process_queries(queries): Process a list of queries and return the results. Each query is a tuple (s, t). pass # Unit Test def test_can_transform_example1(): assert can_transform(\\"abc\\", \\"cba\\") == \\"YES\\" def test_can_transform_example2(): assert can_transform(\\"a\\", \\"ab\\") == \\"YES\\" def test_can_transform_example3(): assert can_transform(\\"abc\\", \\"def\\") == \\"NO\\" def test_can_transform_identical_strings(): assert can_transform(\\"same\\", \\"same\\") == \\"YES\\" def test_can_transform_no_common_chars(): assert can_transform(\\"xyz\\", \\"abc\\") == \\"NO\\" def test_can_transform_all_chars_different(): assert can_transform(\\"a\\", \\"b\\") == \\"NO\\" def test_process_queries_multiple(): queries = [(\\"abc\\", \\"cba\\"), (\\"a\\", \\"ab\\"), (\\"abc\\", \\"def\\"), (\\"xyz\\", \\"yzx\\")] expected_results = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert process_queries(queries) == expected_results","solution":"def can_transform(s, t): Determines if string s can be transformed into string t using the allowed operations. set_s = set(s) set_t = set(t) # Check if there is at least one common character between s and t if set_s.intersection(set_t): return \\"YES\\" return \\"NO\\" def process_queries(queries): Process a list of queries and return the results. Each query is a tuple (s, t). results = [] for s, t in queries: results.append(can_transform(s, t)) return results"},{"question":"def p_sequence_sum(p: int, m: int) -> int: Calculate the sum of the first m elements of a p-sequence modulo 1000000007. Parameters: p (int): The fixed integer multiplier of the p-sequence. m (int): The number of elements in the p-sequence. Returns: int: The sum of the first m elements of the p-sequence modulo 1000000007. >>> p_sequence_sum(2, 4) 15 >>> p_sequence_sum(1, 100000) 100000 >>> p_sequence_sum(3, 5) 121 >>> p_sequence_sum(10, 3) 111 pass","solution":"def p_sequence_sum(p, m): Calculate the sum of the first m elements of a p-sequence modulo 1000000007. Parameters: p (int): The fixed integer multiplier of the p-sequence. m (int): The number of elements in the p-sequence. Returns: int: The sum of the first m elements of the p-sequence modulo 1000000007. MOD = 1000000007 if p == 1: return m % MOD sum_p_seq = (pow(p, m, MOD * (p - 1)) - 1) // (p - 1) return sum_p_seq % MOD"},{"question":"def validate_routine(n: int, k: int, routine: List[int]) -> str: This function checks if a citizen's morning routine is valid. Parameters: n (int): The number of stones in the cave. k (int): The number of stones the citizen is interested in touching. routine (list of int): The sequence of stone indices the citizen plans to touch. Returns: str: 'VALID' if the routine is valid, 'INVALID' otherwise. >>> validate_routine(5, 4, [1, 3, 2, 4]) 'VALID' >>> validate_routine(5, 6, [1, 2, 3, 4, 5, 6]) 'INVALID' >>> validate_routine(5, 3, [1, 1, 2]) 'INVALID' >>> validate_routine(5, 3, [1, 6, 2]) 'INVALID' >>> validate_routine(5, 5, [1, 2, 3, 4, 5]) 'VALID' >>> validate_routine(1, 1, [1]) 'VALID' >>> validate_routine(1, 1, [2]) 'INVALID' >>> validate_routine(5, 2, [1, 3]) 'VALID' >>> validate_routine(5, 2, [0, 3]) 'INVALID' >>> validate_routine(5, 2, [1, 6]) 'INVALID'","solution":"def validate_routine(n, k, routine): This function checks if a citizen's morning routine is valid. Parameters: n (int): The number of stones in the cave. k (int): The number of stones the citizen is interested in touching. routine (list of int): The sequence of stone indices the citizen plans to touch. Returns: str: 'VALID' if the routine is valid, 'INVALID' otherwise. # Check if the length of the routine exceeds the number of stones in the cave if k > n: return \\"INVALID\\" # Check if the routine contains unique indices if len(set(routine)) != len(routine): return \\"INVALID\\" # Check if all indices in the routine are within the valid range for stone in routine: if not 1 <= stone <= n: return \\"INVALID\\" return \\"VALID\\""},{"question":"def find_swapped_positions(n: int, card_values: List[int]) -> str: Identifies the positions to swap to restore sorted order or returns \\"YES\\" if the sequence is already sorted. :param n: An integer representing the number of cards. :param card_values: A list of integers representing the values of the cards. :return: \\"YES\\" if the sequence is already sorted, else two space-separated integers indicating the positions of the two cards to be swapped. >>> find_swapped_positions(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> find_swapped_positions(5, [1, 3, 5, 4, 6]) \\"3 4\\" >>> find_swapped_positions(5, [4, 2, 3, 1, 5]) \\"1 4\\" >>> find_swapped_positions(5, [1, 2, 3, 5, 4]) \\"4 5\\" >>> find_swapped_positions(5, [3, 2, 1, 4, 5]) \\"1 3\\" or \\"2 3\\" >>> find_swapped_positions(2, [2, 1]) \\"1 2\\" >>> find_swapped_positions(7, [1, 2, 6, 4, 5, 3, 7]) \\"3 6\\"","solution":"def find_swapped_positions(n, card_values): Identifies the positions to swap to restore sorted order or returns \\"YES\\" if the sequence is already sorted. :param n: An integer representing the number of cards. :param card_values: A list of integers representing the values of the cards. :return: \\"YES\\" if the sequence is already sorted, else two space-separated integers indicating the positions of the two cards to be swapped. sorted_cards = sorted(card_values) # Check if the sequence is already sorted if card_values == sorted_cards: return \\"YES\\" # Identify the two positions to be swapped pos1, pos2 = -1, -1 for i in range(n): if card_values[i] != sorted_cards[i]: if pos1 == -1: pos1 = i else: pos2 = i # Return the positions in 1-based index return f\\"{pos1 + 1} {pos2 + 1}\\""},{"question":"def min_subarrays(n, m, arr): Returns the minimal number of non-empty contiguous subarrays where the sum of elements in each subarray is strictly less than the integer m. If it's impossible to do so, returns -1. >>> min_subarrays(4, 5, [1, 2, 1, 2]) 2 >>> min_subarrays(5, 6, [1, 2, 3, 1, 2]) 3 >>> min_subarrays(3, 4, [5, 1, 1]) -1 >>> min_subarrays(10, 15, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) 3 >>> min_subarrays(1, 5, [5]) -1 >>> min_subarrays(1, 5, [3]) 1 >>> min_subarrays(3, 10, [2, 3, 4]) 1 >>> min_subarrays(6, 10, [1, 2, 3, 4, 5, 6]) 3 >>> min_subarrays(4, 3, [1, 1, 1, 1]) 2 >>> min_subarrays(5, 10**9, [10**8, 10**8, 10**8, 10**8, 10**8]) 1","solution":"def min_subarrays(n, m, arr): Returns the minimal number of non-empty contiguous subarrays where the sum of elements in each subarray is strictly less than the integer m. If it's impossible to do so, returns -1. if any(x >= m for x in arr): return -1 current_sum = 0 subarray_count = 1 for value in arr: if current_sum + value < m: current_sum += value else: subarray_count += 1 current_sum = value return subarray_count"},{"question":"def generate_oscillating_sequence(n: int) -> List[int]: Generate an Oscillating Sequence of length n. The sequence elements alternate between increasing and decreasing, while maintaining the absolute difference rule. The sequence starts with 1. :param n: The length of the sequence (1 ≤ n ≤ 200000) :return: A list representing the Oscillating Sequence of length n >>> generate_oscillating_sequence(5) [1, 0, 1, 0, 1] >>> generate_oscillating_sequence(6) [1, 0, 1, 0, 1, 0]","solution":"def generate_oscillating_sequence(n): Generate an Oscillating Sequence of length n. sequence = [1] for i in range(1, n): if i % 2 == 0: sequence.append(sequence[-1] + 1) else: sequence.append(sequence[-1] - 1) return sequence"},{"question":"def inventory_system(n, operations): Manage inventory system based on given operations. Args: n : int : Number of operations. operations : list : List of operation strings. Returns: list : List of results of \\"GET\\" operations. >>> inventory_system(8, [\\"SET 1 10\\", \\"SET 2 20\\", \\"GET 1\\", \\"REMOVE 1\\", \\"GET 1\\", \\"GET 2\\", \\"REMOVE 2\\", \\"GET 2\\"]) [10, 0, 20, 0] >>> inventory_system(2, [\\"SET 1 15\\", \\"GET 1\\"]) [15] >>> inventory_system(4, [\\"GET 3\\", \\"SET 3 30\\", \\"REMOVE 3\\", \\"GET 3\\"]) [0, 0] >>> inventory_system(4, [\\"SET 1 100\\", \\"SET 1 200\\", \\"SET 1 300\\", \\"GET 1\\"]) [300] >>> inventory_system(0, []) [] >>> inventory_system(2, [\\"REMOVE 1\\", \\"GET 1\\"]) [0]","solution":"def inventory_system(n, operations): Manage inventory system based on given operations. Args: n : int : Number of operations. operations : list : List of operation strings. Returns: list : List of results of \\"GET\\" operations. inventory = {} results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"SET\\": product_id = int(parts[1]) quantity = int(parts[2]) inventory[product_id] = quantity elif command == \\"GET\\": product_id = int(parts[1]) results.append(inventory.get(product_id, 0)) elif command == \\"REMOVE\\": product_id = int(parts[1]) if product_id in inventory: del inventory[product_id] return results"},{"question":"def max_complete_tiers(n: int) -> int: Given the number of blocks n, return the maximum number of complete tiers that can be formed. >>> max_complete_tiers(10) 4 >>> max_complete_tiers(1) 1 >>> max_complete_tiers(2) 1 >>> max_complete_tiers(3) 2 >>> max_complete_tiers(4) 2 >>> max_complete_tiers(1000000000) 44720 >>> max_complete_tiers(0) 0 >>> max_complete_tiers(-5) 0","solution":"def max_complete_tiers(n): Given the number of blocks n, return the maximum number of complete tiers that can be formed. if n <= 0: return 0 tiers = 0 used_blocks = 0 while True: # The next tier will need (tiers + 1) blocks needed = tiers + 1 if used_blocks + needed <= n: used_blocks += needed tiers += 1 else: break return tiers"},{"question":"from typing import List, Tuple def can_distribute_invitations(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if it is possible to distribute invitations according to the guests' requirements. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): The list of test cases, where each test case is a tuple containing: - n (int): The number of guests. - a (List[int]): The list of integers representing the number of invitations each guest should receive. - b (List[int]): The list of integers representing the maximum number of invitations each guest can receive at a time. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. >>> can_distribute_invitations(2, [(3, [5, 10, 15], [5, 5, 5]), (2, [7, 9], [3, 5])]) [\\"YES\\", \\"NO\\"] def test_example_case_1(): t = 2 test_cases = [ (3, [5, 10, 15], [5, 5, 5]), (2, [7, 9], [3, 5]) ] expected = [\\"YES\\", \\"NO\\"] assert can_distribute_invitations(t, test_cases) == expected def test_all_guests_possible(): t = 1 test_cases = [ (4, [12, 8, 25, 50], [6, 4, 5, 25]) ] expected = [\\"YES\\"] assert can_distribute_invitations(t, test_cases) == expected def test_all_guests_impossible(): t = 1 test_cases = [ (3, [10, 22, 30], [5, 12, 15]) ] expected = [\\"NO\\"] assert can_distribute_invitations(t, test_cases) == expected def test_mixed_possibility(): t = 3 test_cases = [ (3, [10, 20, 30], [10, 10, 10]), (3, [14, 21, 22], [7, 7, 9]), (2, [15, 30], [3, 30]) ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert can_distribute_invitations(t, test_cases) == expected def test_min_edge_case(): t = 1 test_cases = [ (1, [2], [1]) ] expected = [\\"YES\\"] assert can_distribute_invitations(t, test_cases) == expected def test_max_but_possible(): t = 1 test_cases = [ (3, [99999999, 10000000, 150000000], [1, 10000000, 5]) ] expected = [\\"YES\\"] assert can_distribute_invitations(t, test_cases) == expected","solution":"def can_distribute_invitations(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] b = test_cases[i][2] possible = True for j in range(n): if a[j] % b[j] != 0: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_sum_submatrices_from_input(input_str: str) -> List[int]: Given an input containing multiple test cases of matrices, find the maximum sum of any submatrix for each test case. Input: - The first line contains an integer t (1 <= t <= 50) - the number of test cases. - For each test case: - The first line contains two integers n and m (1 <= n, m <= 300) - the number of rows and columns in the matrix. - The next n lines each contain m integers representing the elements of the matrix. Each element of the matrix a[ij] is bounded by -10^9 and 10^9. Output: - For each test case, output a single integer - the maximum sum of any submatrix. >>> input_str = \\"2n3 3n1 2 -1n-3 -4 5n2 3 -8n2 2n-1 -2n-3 -4\\" >>> max_sum_submatrices_from_input(input_str) [5, -1]","solution":"def max_sum_submatrix(matrix, n, m): def max_subarray(arr): max_sum = float('-inf') current_sum = 0 for x in arr: current_sum = max(x, current_sum + x) max_sum = max(max_sum, current_sum) return max_sum max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, max_subarray(temp)) return max_sum def get_max_sum_all_matrices(test_cases): results = [] for case in test_cases: n, m, matrix = case results.append(max_sum_submatrix(matrix, n, m)) return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) matrix = [list(map(int, lines[index + i + 1].split())) for i in range(n)] test_cases.append((n, m, matrix)) index += n + 1 return test_cases def max_sum_submatrices_from_input(input_str): test_cases = parse_input(input_str) return get_max_sum_all_matrices(test_cases) # Sample usage for testing input_str = 2 3 3 1 2 -1 -3 -4 5 2 3 -8 2 2 -1 -2 -3 -4 print(max_sum_submatrices_from_input(input_str))"},{"question":"def longest_subarray_with_difference(arr, k): Function to find the length of the longest subarray where the difference between any two elements is at most k. pass def process_test_cases(test_cases): This function accepts a list of test cases, where each test case is represented as a tuple (n, k, arr), and returns a list of results, one for each test case, representing the length of the longest subarray where the difference between any two elements is at most k. >>> process_test_cases([(5, 3, [1, 5, 3, 4, 2]), (6, 2, [4, 3, 1, 1, 5, 6])]) [4, 3] pass from longest_subarray_with_difference import process_test_cases def test_example_cases(): test_cases = [ (5, 3, [1, 5, 3, 4, 2]), (6, 2, [4, 3, 1, 1, 5, 6]) ] expected = [4, 3] assert process_test_cases(test_cases) == expected def test_single_element(): test_cases = [ (1, 5, [1]), (1, 0, [10]) ] expected = [1, 1] assert process_test_cases(test_cases) == expected def test_all_same_elements(): test_cases = [ (5, 0, [3, 3, 3, 3, 3]), (4, 1, [7, 7, 7, 7]) ] expected = [5, 4] assert process_test_cases(test_cases) == expected def test_large_difference(): test_cases = [ (6, 100, [1, 2, 3, 4, 5, 6]), (5, 4, [10, 20, 30, 10, 40]) ] expected = [6, 2] assert process_test_cases(test_cases) == expected def test_no_valid_subarray(): test_cases = [ (5, 1, [1, 3, 5, 7, 9]), (4, 0, [8, 10, 12, 14]) ] expected = [1, 1] assert process_test_cases(test_cases) == expected","solution":"def longest_subarray_with_difference(arr, k): Function to find the length of the longest subarray where the difference between any two elements is at most k. arr.sort() left, right = 0, 0 max_len = 0 while right < len(arr): if arr[right] - arr[left] <= k: max_len = max(max_len, right - left + 1) right += 1 else: left += 1 return max_len def process_test_cases(test_cases): results = [] for (n, k, arr) in test_cases: results.append(longest_subarray_with_difference(arr, k)) return results"},{"question":"import heapq from typing import List def merge_sorted_lists(test_cases: List[List[List[int]]]) -> List[List[int]]: Merges k sorted lists for each test case into a single sorted list. :param test_cases: List of test cases, where each test case is a list of k sorted lists. :return: List of merged sorted lists for each test case. >>> input_str = \\"2n2n3 1 4 5n5 2 3 6 7 8n3n4 1 3 5 7n3 2 4 6n2 8 9\\" >>> test_cases = process_input(input_str) >>> merge_sorted_lists(test_cases) [[1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9]] >>> input_str = \\"1n1n3 10 20 30\\" >>> test_cases = process_input(input_str) >>> merge_sorted_lists(test_cases) [[10, 20, 30]] >>> input_str = \\"1n4n1 5n1 1n1 3n1 2\\" >>> test_cases = process_input(input_str) >>> merge_sorted_lists(test_cases) [[1, 2, 3, 5]] >>> input_str = \\"1n3n0n0n0\\" >>> test_cases = process_input(input_str) >>> merge_sorted_lists(test_cases) [[]] >>> input_str = \\"1n3n5 1 2 3 4 5n0n3 6 7 8\\" >>> test_cases = process_input(input_str) >>> merge_sorted_lists(test_cases) [[1, 2, 3, 4, 5, 6, 7, 8]] def process_input(input_str: str) -> List[List[List[int]]]: Processes the input string as per the given format in the question and returns structured test cases. :param input_str: Input string containing the test cases. :return: Structured test cases for processing. input_lines = input_str.strip().split('n') t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): k = int(input_lines[index]) index += 1 current_case = [] for _ in range(k): current_case.append(list(map(int, input_lines[index].split()[1:]))) index += 1 test_cases.append(current_case) return test_cases","solution":"import heapq def merge_sorted_lists(test_cases): Merges k sorted lists for each test case into a single sorted list. :param test_cases: List of test cases, where each test case is a list of k sorted lists. :return: List of merged sorted lists for each test case. result = [] for lists in test_cases: merged_list = list(heapq.merge(*lists)) result.append(merged_list) return result def process_input(input_str): Processes the input string as per the given format in the question and returns structured test cases. :param input_str: Input string containing the test cases. :return: Structured test cases for processing. input_lines = input_str.strip().split('n') t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): k = int(input_lines[index]) index += 1 current_case = [] for _ in range(k): current_case.append(list(map(int, input_lines[index].split()[1:]))) index += 1 test_cases.append(current_case) return test_cases"},{"question":"def min_operations_to_one(n: int) -> int: Returns the minimum number of operations to transform the number n to 1. Operations allowed: 1. If n is even, divide it by 2. 2. If n is odd and greater than 1, subtract 1 from it. >>> min_operations_to_one(10) 4 >>> min_operations_to_one(8) 3 >>> min_operations_to_one(15) 6 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(2) 1 >>> min_operations_to_one(3) 2","solution":"def min_operations_to_one(n): Returns the minimum number of operations to transform the number n to 1. Operations allowed: 1. If n is even, divide it by 2. 2. If n is odd and greater than 1, subtract 1 from it. count = 0 while n > 1: if n % 2 == 0: n //= 2 else: n -= 1 count += 1 return count"},{"question":"def sum_sub_matrix(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Calculate the total sum of the elements present in the given sub-matrix for a number of queries. Args: matrix (List[List[int]]): A 2D list of ints representing the matrix. queries (List[Tuple[int, int, int, int]]): A list of tuples, each containing four ints representing the top-left and bottom-right corners of the sub-matrix. Returns: List[int]: The sum of integers for each query. >>> matrix = [ >>> [1, -2, 3], >>> [-4, 5, 6], >>> [7, -8, 9] >>> ] >>> queries = [ >>> (1, 1, 2, 2), >>> (2, 2, 3, 3) >>> ] >>> sum_sub_matrix(matrix, queries) [0, 12]","solution":"def sum_sub_matrix(matrix, queries): n = len(matrix) m = len(matrix[0]) # Calculate prefix sums prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i + 1][j + 1] = (matrix[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j]) results = [] for x1, y1, x2, y2 in queries: # Convert 1-based indices to 0-based indices sum_value = (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]) results.append(sum_value) return results"},{"question":"from typing import List def max_files_to_store(max_size: int, file_sizes: List[int]) -> int: Determine the maximum number of files that can be stored without exceeding the size limit. >>> max_files_to_store(10, [2, 3, 5, 2, 1]) 4 >>> max_files_to_store(5, [4]) 1 >>> max_files_to_store(1, [5, 10, 3]) 0 >>> max_files_to_store(15, [5, 5, 5]) 3 >>> max_files_to_store(7, [2, 1, 1, 1, 1]) 5 >>> max_files_to_store(8, [3, 2, 5, 1, 2, 1]) 4 >>> max_files_to_store(10**9, [10**9 for _ in range(100000)]) 1 >>> max_files_to_store(10, [10, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 9","solution":"def max_files_to_store(max_size, file_sizes): file_sizes.sort() # Sort the file sizes to attempt to store smaller files first total_size = 0 count = 0 for size in file_sizes: if total_size + size <= max_size: total_size += size count += 1 else: break return count"},{"question":"def find_peak(n: int, heights: List[int], d: int) -> int: Find the index of the first occurring peak in the elevation map that satisfies the given conditions. A peak is defined as a point that is higher than its neighbors and has a height difference of at least \`d\` with them. >>> find_peak(8, [2, 3, 1, 5, 3, 6, 2, 4], 2) 3 >>> find_peak(5, [5, 3, 6, 2, 8], 1) 2 >>> find_peak(5, [1, 2, 3, 4, 5], 1) -1 >>> find_peak(3, [1, 3, 2], 1) 1 >>> find_peak(6, [1, 4, 2, 5, 3, 7], 2) 1 >>> find_peak(5, [10, 15, 20, 25, 30], 15) -1","solution":"def find_peak(n, heights, d): for i in range(1, n-1): if (heights[i] > heights[i-1] and heights[i] > heights[i+1] and heights[i] - heights[i-1] >= d and heights[i] - heights[i+1] >= d): return i return -1"},{"question":"import math from typing import List def min_gcd_groups(arr: List[int]) -> int: Function to determine the minimum number of groups such that each group contains two or more contiguous elements with each pair of elements having the same greatest common divisor (GCD). >>> min_gcd_groups([4, 8, 6, 3, 9]) == 2 >>> min_gcd_groups([2, 4, 8, 16]) == 1 >>> min_gcd_groups([2, 4, 6, 8, 3, 9]) == 2 >>> min_gcd_groups([3, 5, 7, 11, 13]) == 0 >>> min_gcd_groups([6, 6, 6, 6]) == 1 >>> min_gcd_groups([21, 7, 14, 2, 4, 8, 16]) == 2","solution":"import math from typing import List def min_gcd_groups(arr: List[int]) -> int: Function to determine the minimum number of groups such that each group contains two or more contiguous elements with each pair of elements having the same greatest common divisor (GCD). n = len(arr) group_count = 0 i = 0 while i < n: j = i current_gcd = arr[i] while j < n and math.gcd(current_gcd, arr[j]) == current_gcd: current_gcd = math.gcd(current_gcd, arr[j]) j += 1 if j - i > 1: group_count += 1 i = j else: i += 1 return group_count def min_gcd_groups_from_input(n: int, arr: List[int]) -> int: return min_gcd_groups(arr)"},{"question":"def min_sum_absolute_diff(n: int, m: int, beauty_values: List[int]) -> int: Given the beauty values of the bouquets, find the minimum possible sum of the absolute differences of beauty values between adjacent bouquets after arranging n bouquets on the shelves. Args: n: Number of shelves m: Number of available bouquets beauty_values: List of beauty values of the bouquets Returns: The minimum sum of the absolute differences of beauty values between adjacent bouquets. >>> min_sum_absolute_diff(3, 5, [2, 4, 5, 1, 3]) 2 >>> min_sum_absolute_diff(2, 4, [1, 2, 5, 6]) 1","solution":"def min_sum_absolute_diff(n, m, beauty_values): beauty_values.sort() min_diff = float('inf') for i in range(m - n + 1): current_diff = beauty_values[i + n - 1] - beauty_values[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def find_subarray_with_sum(n, M, arr): Determines if there exists a contiguous subarray whose sum is exactly M. Parameters: - n: Length of the array - M: Target sum - arr: List of integers representing the array Returns: - \\"YES\\" if such a subarray exists, otherwise \\"NO\\" Example Usage: >>> find_subarray_with_sum(5, 12, [1, 2, 3, 7, 5]) \\"YES\\" >>> find_subarray_with_sum(4, 15, [1, 2, 3, 4]) \\"NO\\" # Implementation","solution":"def find_subarray_with_sum(n, M, arr): Determines if there exists a contiguous subarray whose sum is exactly M. Parameters: - n: Length of the array - M: Target sum - arr: List of integers representing the array Returns: - \\"YES\\" if such a subarray exists, otherwise \\"NO\\" current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > M and start <= end: current_sum -= arr[start] start += 1 if current_sum == M: return \\"YES\\" return \\"NO\\""},{"question":"def min_trees_to_cut(n: int, k: int, heights: List[int]) -> int: Returns the minimum number of trees that need to be cut down to form a non-decreasing sequence after optionally increasing the height of one tree by k units. >>> min_trees_to_cut(5, 3, [3, 1, 2, 6, 4]) 1 >>> min_trees_to_cut(4, 2, [1, 2, 3, 4]) 0 >>> min_trees_to_cut(4, 1, [4, 3, 2, 1]) 2 >>> min_trees_to_cut(1, 5, [10]) 0 >>> min_trees_to_cut(5, 3, [3, 3, 3, 3, 3]) 0 >>> min_trees_to_cut(5, 1000000, [1, 1, 1, 1, 1]) 0 >>> min_trees_to_cut(6, 2, [1, 3, 3, 5, 4, 4]) 1","solution":"def min_trees_to_cut(n, k, heights): Returns the minimum number of trees that need to be cut down to form a non-decreasing sequence after optionally increasing the height of one tree by k units. def longest_non_decreasing_subsequence(seq): from bisect import bisect_right lis = [] for h in seq: pos = bisect_right(lis, h) if pos < len(lis): lis[pos] = h else: lis.append(h) return len(lis) best_result = float('inf') for i in range(n + 1): if i < n: modified_heights = heights[:i] + [heights[i] + k] + heights[i+1:] else: modified_heights = heights lis_length = longest_non_decreasing_subsequence(modified_heights) cuts_required = n - lis_length best_result = min(best_result, cuts_required) return best_result # Example usage n = 5 k = 3 heights = [3, 1, 2, 6, 4] print(min_trees_to_cut(n, k, heights)) # Outputs: 1"},{"question":"def can_form_alternating_sequence(arr): Determine whether it is possible to rearrange the array to form a strictly alternating sequence of even and odd numbers. >>> can_form_alternating_sequence([1, 2, 3, 4, 5]) (True, [5, 4, 3, 2, 1]) >>> can_form_alternating_sequence([2, 4, 6, 8]) (False, []) >>> can_form_alternating_sequence([1, 3, 2]) (True, [3, 2, 1]) def rearrange_arrays(t, cases): For each test case, determine whether a valid rearrangement is possible, and if so, print \\"YES\\" along with the rearranged sequence. >>> rearrange_arrays(3, [(5, [1, 2, 3, 4, 5]), (4, [2, 4, 6, 8]), (3, [1, 3, 2])]) ['YESn5 4 3 2 1', 'NO', 'YESn3 2 1'] >>> rearrange_arrays(3, [(4, [1, 3, 5, 7]), (5, [2, 4, 6, 8, 10]), (6, [1, 2, 3, 4, 5, 6])]) ['NO', 'NO', 'YESn5 6 3 4 1 2']","solution":"def can_form_alternating_sequence(arr): evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] if abs(len(evens) - len(odds)) > 1: return False, [] result = [] if len(evens) > len(odds): while evens or odds: if evens: result.append(evens.pop()) if odds: result.append(odds.pop()) else: while odds or evens: if odds: result.append(odds.pop()) if evens: result.append(evens.pop()) return True, result def rearrange_arrays(t, cases): results = [] for i in range(t): n, arr = cases[i] possible, sequence = can_form_alternating_sequence(arr) if possible: results.append(f\\"YESn{' '.join(map(str, sequence))}\\") else: results.append(\\"NO\\") return results"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from the given stock prices. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def test_example_case_1(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_example_case_2(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_all_same_prices(): assert max_profit([5, 5, 5, 5, 5]) == 0 def test_strictly_increasing_prices(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_strictly_decreasing_prices(): assert max_profit([5, 4, 3, 2, 1]) == 0 def test_single_day(): assert max_profit([5]) == 0 def test_large_input(): import random random.seed(0) large_input = [random.randint(1, 10**9) for _ in range(10**5)] # We cannot predict a specific profit value here, so we just test that the function runs without error. max_profit(large_input) def test_empty_input(): assert max_profit([]) == 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from the given stock prices. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def rearrange_string(s: str) -> str: Polycarpus loves arranging his collection of strings. You are given a string consisting of lowercase Latin letters and Polycarpus wants to reorder the characters in such a way that the string contains as few distinct characters as possible for the maximum possible number of positions. The reordering should follow these rules: 1. The reordered string should be a permutation of the input string. 2. The maximum possible number of successive positions should contain the same character. Determine and print any such reordered string. Args: s (str): The input string consisting of lowercase Latin letters. Returns: str: The reordered string. Examples: >>> rearrange_string(\\"aabbcc\\") 'ababcc' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"aaabbb\\") 'ababab' >>> rearrange_string(\\"abcabcabc\\") 'abcabcabc' from solution import rearrange_string def test_rearrange_string_example1(): assert rearrange_string(\\"aabbcc\\") == \\"ababcc\\" or rearrange_string(\\"aabbcc\\") == \\"abcabc\\" def test_rearrange_string_single_character(): assert rearrange_string(\\"a\\") == \\"a\\" def test_rearrange_string_repeated_characters(): assert rearrange_string(\\"aaabbb\\") == \\"ababab\\" def test_rearrange_string_mixed_characters(): assert rearrange_string(\\"abcabcabc\\") == \\"abcabcabc\\" or rearrange_string(\\"abcabcabc\\") == \\"abccbaabc\\" def test_rearrange_string_large_input(): input_string = \\"a\\" * 100000 + \\"b\\" * 100000 reordered = rearrange_string(input_string) assert len(reordered) == 200000 assert reordered.count(\\"a\\") == 100000 assert reordered.count(\\"b\\") == 100000","solution":"def rearrange_string(s: str) -> str: from collections import Counter import heapq # Count the frequency of each character freq = Counter(s) # Create a max heap based on the frequency of each character max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) if prev_char: heapq.heappush(max_heap, (prev_freq, prev_char)) result.append(char) prev_char = char prev_freq = freq + 1 # Increase frequency since it's negative in heap (max-heap simulation) if prev_freq == 0: prev_char = None return ''.join(result)"},{"question":"from typing import List def min_max_difference(nums: List[int], k: int) -> int: Given an integer array \`nums\` and an integer \`k\`, rearrange the array such that the maximum difference between any two adjacent elements is minimized. Args: nums: List[int] - the integer array. k: int - the number of subarrays to split into. Returns: int - the minimized maximum difference. >>> min_max_difference([1, 3, 6, 4, 1, 2], 3) 2 >>> min_max_difference([1], 1) 0 >>> min_max_difference([2, 2, 2, 2], 2) 0 >>> min_max_difference([1, 1000000], 2) 0 >>> min_max_difference([7, 2, 5, 10, 8], 2) 5 >>> min_max_difference([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 2 >>> min_max_difference([9, 8, 7, 6, 5, 4, 3, 2, 1], 3) 2","solution":"def min_max_difference(nums, k): def can_partition(nums, k, max_diff): partitions = 1 current_min = current_max = nums[0] for num in nums[1:]: current_min = min(current_min, num) current_max = max(current_max, num) if current_max - current_min > max_diff: partitions += 1 current_min = current_max = num if partitions > k: return False return True left, right = 0, max(nums) - min(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, k, mid): right = mid else: left = mid + 1 return left # Example usage n = 6 nums = [1, 3, 6, 4, 1, 2] k = 3 print(min_max_difference(nums, k)) # Output: 2"},{"question":"def min_operations(source: str, target: str) -> int: Calculates the minimum number of operations required to transform the source string into the target string. Allowed operations are insert, delete, and replace a character. >>> min_operations(\\"horse\\", \\"ros\\") # returns 3 >>> min_operations(\\"intention\\", \\"execution\\") # returns 5","solution":"def min_operations(source, target): Calculates the minimum number of operations required to transform the source string into the target string. Allowed operations are insert, delete, and replace a character. m, n = len(source), len(target) # Initialize a (m+1) x (n+1) DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(m + 1): dp[i][0] = i # Fill first column for j in range(n + 1): dp[0][j] = j # Fill first row # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match else: insert_op = dp[i][j - 1] + 1 delete_op = dp[i - 1][j] + 1 replace_op = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert_op, delete_op, replace_op) return dp[m][n]"},{"question":"from typing import List def longest_zigzag_sequence(trees: List[int]) -> int: Determine the maximum possible length of the zigzag sequence that can be made from a given list of tree heights. >>> longest_zigzag_sequence([1, 7, 4, 9, 2, 5]) == 6 >>> longest_zigzag_sequence([10, 8, 6, 4, 2]) == 2 def test_single_tree(): assert longest_zigzag_sequence([5]) == 1 def test_all_equal_trees(): assert longest_zigzag_sequence([3, 3, 3]) == 1 def test_zigzag_sequence(): assert longest_zigzag_sequence([1, 7, 4, 9, 2, 5]) == 6 def test_simple_zigzag(): assert longest_zigzag_sequence([1, 3, 2, 4]) == 4 def test_decreasing_sequence(): assert longest_zigzag_sequence([10, 8, 6, 4, 2]) == 2 def test_increasing_sequence(): assert longest_zigzag_sequence([2, 4, 6, 8, 10]) == 2 def test_alternating_sequence(): assert longest_zigzag_sequence([5, 1, 5, 1, 5, 1, 5]) == 7 def test_large_input(): assert longest_zigzag_sequence([i for i in range(1000)]) == 2","solution":"def longest_zigzag_sequence(trees): n = len(trees) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): for j in range(i): if trees[i] > trees[j]: up[i] = max(up[i], down[j] + 1) elif trees[i] < trees[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"def water_rain_simulation(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Perform a water rain simulation on the grid for one time-step. Each cell in the grid will receive 1 unit of water. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the height of each cell in the grid. Returns: List[List[int]]: The grid after water has been distributed. >>> n = 3 >>> m = 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> water_rain_simulation(n, m, grid) [ [2, 3, 4], [5, 6, 7], [8, 9, 10] ]","solution":"def water_rain_simulation(n, m, grid): new_grid = [[grid[i][j] + 1 for j in range(m)] for i in range(n)] return new_grid def print_grid(grid): for row in grid: print(\\" \\".join(map(str, row))) # Example usage: if __name__ == \\"__main__\\": n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] new_grid = water_rain_simulation(n, m, grid) print_grid(new_grid)"},{"question":"def min_total_distance_to_last_stone(n, heights): Calculate the minimum total distance the frog needs to jump to reach the last stone. >>> min_total_distance_to_last_stone(5, [1, 3, 2, 4, 5]) 4 >>> min_total_distance_to_last_stone(7, [1, 2, 3, 4, 5, 6, 7]) 6 >>> min_total_distance_to_last_stone(1, [1]) 0 >>> min_total_distance_to_last_stone(3, [3, 2, 1]) -1 >>> min_total_distance_to_last_stone(6, [10, 30, 20, 50, 40, 60]) 50 >>> min_total_distance_to_last_stone(4, [4, 3, 2, 1]) -1 >>> min_total_distance_to_last_stone(4, [1, 10, 20, 30]) 29","solution":"def min_total_distance_to_last_stone(n, heights): Calculate the minimum total distance the frog needs to jump to reach the last stone. if n == 1: return 0 min_distance = float('inf') dp = [float('inf')] * n dp[0] = 0 for i in range(1, n): for j in range(0, i): if heights[j] < heights[i]: dp[i] = min(dp[i], dp[j] + (heights[i] - heights[j])) return dp[-1] if dp[-1] != float('inf') else -1"},{"question":"def min_partition_difference(n: int, arr: List[int]) -> int: Returns the minimum possible absolute difference between the sums of the elements in the two subsets. Parameters: n (int): Number of elements in the set. arr (list of int): List of integers in the set. Returns: int: Minimum possible absolute difference. >>> min_partition_difference(4, [1, 6, 11, 5]) 1 >>> min_partition_difference(1, [10]) 10 >>> min_partition_difference(2, [5, 5]) 0 >>> min_partition_difference(2, [1, 4]) 3 >>> min_partition_difference(3, [3, 9, 7]) 1 >>> min_partition_difference(5, [3, 1, 4, 2, 2]) 0","solution":"def min_partition_difference(n, arr): Returns the minimum possible absolute difference between the sums of the elements in the two subsets. Parameters: n (int): Number of elements in the set. arr (list of int): List of integers in the set. Returns: int: Minimum possible absolute difference. total_sum = sum(arr) dp = [0] * (total_sum // 2 + 1) for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return total_sum - 2 * dp[total_sum // 2]"},{"question":"from typing import List def transform_grid(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Transforms the grid to minimize all values in the grid by performing the operations described. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: The initial values of the cells in the grid :return: The final grid after performing the operations to minimize the values >>> transform_grid(3, 4, [[5, 9, 3, 6], [8, 7, 4, 2], [3, 6, 9, 5]]) [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]] >>> transform_grid(1, 1, [[5]]) [[5]] >>> transform_grid(2, 2, [[3, 3], [3, 3]]) [[3, 3], [3, 3]] pass","solution":"def transform_grid(n, m, grid): Transforms the grid to minimize all values in the grid by performing the operations described. min_value = min(map(min, grid)) return [[min_value] * m for _ in range(n)]"},{"question":"def max_sum_of_k_consecutive_elements(n: int, k: int, array: List[int]) -> int: Given an array \`a\` consisting of \`n\` integers, and an integer \`k\`, find the maximum sum of \`k\` consecutive elements in the array. :param n: int: Size of the array :param k: int: Number of consecutive elements to sum :param array: list[int]: The array of integers :return: int: The maximum sum of \`k\` consecutive elements >>> max_sum_of_k_consecutive_elements(5, 2, [1, 3, -2, 5, -1]) == 8 >>> max_sum_of_k_consecutive_elements(1, 1, [-100000]) == -100000 >>> max_sum_of_k_consecutive_elements(5, 3, [1, 2, 3, 4, 5]) == 12 >>> max_sum_of_k_consecutive_elements(5, 3, [-1, -2, -3, -4, -5]) == -6 >>> max_sum_of_k_consecutive_elements(7, 3, [1, -2, 3, 10, -4, 7, 2]) == 13 pass","solution":"def max_sum_of_k_consecutive_elements(n, k, array): Returns the maximum sum of k consecutive elements in the array. :param n: int: Size of the array :param k: int: Number of consecutive elements to sum :param array: list[int]: The array of integers :return: int: The maximum sum of k consecutive elements # Calculate the initial sum of the first k elements current_sum = sum(array[:k]) max_sum = current_sum # Slide the window across the array and update the sums for i in range(k, n): current_sum = current_sum + array[i] - array[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def top_k_frequent_videos(watch_history: List[int], k: int) -> List[int]: Finds the top k most frequently watched videos in the user's watch history. If ties in frequency occur, videos with lower id are prioritized. >>> top_k_frequent_videos([1, 2, 1, 2, 1, 3, 3, 3, 4, 5], 2) [1, 3] >>> top_k_frequent_videos([1, 1, 2, 2, 3, 3, 4, 4], 3) [1, 2, 3]","solution":"from typing import List from collections import Counter def top_k_frequent_videos(watch_history: List[int], k: int) -> List[int]: Finds the top k most frequently watched videos in the user's watch history. If ties in frequency occur, videos with lower id are prioritized. # Count the frequency of each video in the watch history freq_counter = Counter(watch_history) # Sort the videos based on frequency, and then by video id sorted_videos = sorted(freq_counter.keys(), key=lambda vid: (-freq_counter[vid], vid)) # Return the top k videos return sorted_videos[:k]"},{"question":"def num_islands(grid: List[str]) -> int: Find the number of distinct islands in the grid. A cell containing 1 is considered a land cell, while a cell containing 0 is considered a water cell. An island is a group of land cells connected vertically or horizontally (not diagonally) and surrounded by water. Args: - grid (List[str]): a list of strings representing the grid Returns: - int: the number of distinct islands in the grid >>> num_islands([\\"11000\\",\\"11000\\",\\"00100\\",\\"00011\\"]) 3 >>> num_islands([\\"101\\",\\"010\\",\\"101\\"]) 5 >>> num_islands([\\"00\\",\\"00\\"]) 0 pass def parse_input_and_calculate_islands(input_data: str) -> int: Parse input data and calculate the number of islands. Args: - input_data (str): input string containing size of the grid followed by grid representation Returns: - int: the number of distinct islands in the grid >>> parse_input_and_calculate_islands(\\"4 5n11000n11000n00100n00011\\") 3 >>> parse_input_and_calculate_islands(\\"1 1n1\\") 1 >>> parse_input_and_calculate_islands(\\"1 1n0\\") 0 pass","solution":"def num_islands(grid): if not grid: return 0 n = len(grid) m = len(grid[0]) visited = [[False] * m for _ in range(n)] def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == '0' or visited[i][j]: return visited[i][j] = True dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count def parse_input_and_calculate_islands(input_data): lines = input_data.strip().split() n = int(lines[0]) m = int(lines[1]) grid = lines[2:n+2] return num_islands(grid) # Example input for demonstration input_data = \\"4 5n11000n11000n00100n00011\\" print(parse_input_and_calculate_islands(input_data)) # Output should be 3"},{"question":"def are_sequences_equal(t: int, test_cases: list) -> list: Determine if it's possible to rearrange the first sequence to match the second sequence exactly, considering frequencies of each integer must be the same in both sequences. Parameters: t (int): Number of test cases. test_cases (list): List of tuples (n, m, sequence_a, sequence_b) where: - n (int): Length of the first sequence. - m (int): Length of the second sequence. - sequence_a (list of int): The first sequence. - sequence_b (list of int): The second sequence. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. Examples: >>> are_sequences_equal(3, [ ... (3, 3, [1, 2, 3], [3, 2, 1]), ... (4, 4, [1, 1, 1, 1], [1, 1, 2, 1]), ... (5, 5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) ... ]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> are_sequences_equal(2, [ ... (2, 2, [4, 5], [5, 4]), ... (3, 2, [1, 2, 3], [2, 3]) ... ]) == [\\"YES\\", \\"NO\\"]","solution":"def are_sequences_equal(t, test_cases): Determine if it's possible to rearrange the first sequence to match the second sequence exactly, considering frequencies of each integer must be the same in both. Parameters: t (int): Number of test cases. test_cases (list): List where each element is a tuple of the format: (n, m, a, b) where n is the length of first sequence, m is the length of the second sequence, a is the first sequence and b is the second sequence. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case index. results = [] for n, m, sequence_a, sequence_b in test_cases: if sorted(sequence_a) == sorted(sequence_b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def count_communication_hubs(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Function to count the minimum number of communication hubs required. Parameters: n (int): Number of castles. m (int): Number of roads. roads (list of tuples): Each tuple represents a road connecting two castles. Returns: int: Minimum number of communication hubs required. >>> count_communication_hubs(5, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) 1 >>> count_communication_hubs(4, 0, []) 4 >>> count_communication_hubs(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> count_communication_hubs(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 2 >>> count_communication_hubs(6, 3, [(1, 2), (3, 4), (5, 6)]) 3 >>> count_communication_hubs(1, 0, []) 1","solution":"def count_communication_hubs(n, m, roads): Function to count the minimum number of communication hubs required. Parameters: n (int): Number of castles. m (int): Number of roads. roads (list of tuples): Each tuple represents a road connecting two castles. Returns: int: Minimum number of communication hubs required. from collections import defaultdict # Build the adjacency list graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) visited = [False] * (n + 1) def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) components = 0 # Find all connected components using DFS for castle in range(1, n + 1): if not visited[castle]: components += 1 visited[castle] = True dfs(castle) return components"},{"question":"from typing import List, Tuple def min_completion_time(n: int, jobs: List[Tuple[int, int, int]], R: int) -> int: Determine the minimum amount of time required to complete all jobs while respecting resource constraints and priority levels. Parameters: n (int): The number of jobs. jobs (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, bi (time required to complete the job in normal mode), ci (resource consumption in normal mode), and di (priority level). R (int): The maximum resources available per unit time. Returns: int: The minimum amount of time required to complete all jobs. Examples: >>> min_completion_time(3, [(10, 5, 2), (20, 3, 1), (15, 4, 3)], 10) 35 >>> min_completion_time(2, [(10, 5, 1), (10, 5, 1)], 10) 20 >>> min_completion_time(1, [(10, 5, 2)], 10) 10 >>> min_completion_time(3, [(10, 5, 2), (20, 3, 1), (15, 6, 3)], 10) 35 >>> min_completion_time(2, [(10, 5, 2), (20, 5, 3)], 50) 15","solution":"def min_completion_time(n, jobs, R): # Sort jobs based on priority level (higher priority first) jobs.sort(key=lambda x: x[2], reverse=True) total_time = 0 for job in jobs: bi, ci = job[0], job[1] # Determine the number of time units required to complete the job in normal mode normal_time = bi high_priority_time = bi // 2 remaining_time = bi if bi <= (R // ci) else (R // ci) * (bi // ci) if remaining_time < high_priority_time: total_time += normal_time else: total_time += high_priority_time return total_time"},{"question":"def min_append_to_palindrome(word): Returns the minimum number of characters that need to be appended to the end of the word to make it a palindrome. >>> min_append_to_palindrome(\\"abc\\") 2 >>> min_append_to_palindrome(\\"race\\") 3 >>> min_append_to_palindrome(\\"madam\\") 0 def process_words(n, words): Takes an integer n and a list of n words, returns a list of integers where each integer represents the minimum number of characters that need to be appended to the end of the corresponding word to make it a palindrome. >>> process_words(3, [\\"abc\\", \\"race\\", \\"madam\\"]) [2, 3, 0] >>> process_words(4, [\\"a\\", \\"ba\\", \\"abc\\", \\"abcd\\"]) [0, 1, 2, 3] >>> process_words(3, [\\"noon\\", \\"level\\", \\"rotor\\"]) [0, 0, 0]","solution":"def min_append_to_palindrome(word): Returns the minimum number of characters that need to be appended to the end of the word to make it a palindrome. for i in range(len(word)): if word[i:] == word[i:][::-1]: return i return len(word) def process_words(n, words): Takes an integer n and a list of n words, returns a list of integers where each integer represents the minimum number of characters that need to be appended to the end of the corresponding word to make it a palindrome. return [min_append_to_palindrome(word) for word in words]"},{"question":"def max_crops(n: int, m: int): Returns the maximum number of different crops that can be planted in the field, and an arrangement of crops in the field. Args: n (int): Number of rows in the field. m (int): Number of columns in the field. Returns: tuple: A tuple containing the maximum number of crop types (int) and the arrangement of crops (list of str). Examples: >>> max_crops(2, 3) (2, ['ABC', 'CAB']) >>> max_crops(3, 3) (3, ['ABC', 'BCA', 'CAB']) pass","solution":"def max_crops(n, m): Returns the maximum number of different crops that can be planted in the field, and an arrangement of crops in the field. crops = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" crop_arrangement = [] for i in range(n): row = [] for j in range(m): # The position in the crop string is decided to ensure adjacent cell rules row.append(crops[(i + j) % len(crops)]) crop_arrangement.append(''.join(row)) return min(n, m), crop_arrangement # Function to generate output and print results def print_max_crops(n, m): max_crop_count, arrangement = max_crops(n, m) print(max_crop_count) for row in arrangement: print(row)"},{"question":"def max_circular_subarray_sum(arr): Returns the maximum sum of a contiguous subarray in a circular manner. >>> max_circular_subarray_sum([5, -3, 5]) 10 >>> max_circular_subarray_sum([1, 2, 3, 4]) 10 >>> max_circular_subarray_sum([-2, 3, -1, 2]) 4 >>> max_circular_subarray_sum([-3, -2, -1]) -1 >>> max_circular_subarray_sum([1000] * 100000) 100000000 # Implement your function here pass","solution":"def max_circular_subarray_sum(arr): Returns the maximum sum of a contiguous subarray in a circular manner. def kadane(nums): Standard Kadane's algorithm to find the maximum sum subarray. max_sum = cur_sum = nums[0] for num in nums[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum max_kadane = kadane(arr) # Max sum subarray in non-circular array max_wrap = sum(arr) # Total sum of the array for i in range(len(arr)): arr[i] = -arr[i] # Invert the array elements # max sum subarray of inverted array max_wrap += kadane(arr) if max_wrap > 0: return max(max_kadane, max_wrap) else: return max_kadane"},{"question":"import heapq import sys from typing import List, Tuple def minimal_max_communication_time(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Returns the minimal maximum communication time required to send a message between the most distant pair of computers in a network. :param n: Number of computers :param m: Number of communication links :param edges: List of edges, each defined as (u, v, w) :return: Minimal maximum communication time >>> minimal_max_communication_time(4, 4, [(1, 2, 4), (1, 3, 2), (2, 4, 6), (3, 4, 8)]) 10 >>> minimal_max_communication_time(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 5)]) 5 >>> minimal_max_communication_time(3, 2, [(1, 2, 10), (2, 3, 20)]) 30 >>> minimal_max_communication_time(4, 2, [(1, 2, 5), (3, 4, 10)]) sys.maxsize >>> minimal_max_communication_time(1, 0, []) 0","solution":"import heapq import sys def minimal_max_communication_time(n, m, edges): Returns the minimal maximum communication time required to send a message between the most distant pair of computers in a network. :param n: Number of computers :param m: Number of communication links :param edges: List of edges, each defined as (u, v, w) :return: Minimal maximum communication time def dijkstra(start, n, graph): distances = [sys.maxsize] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) all_distances = [] for i in range(1, n + 1): distances = dijkstra(i, n, graph) max_distance = max(distances[1:]) # Ignore the 0th index which is dummy. all_distances.append(max_distance) return max(all_distances)"},{"question":"def largest_rectangle_area(histogram: List[int]) -> int: Function to calculate the largest rectangle area in a histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([2, 1, 4, 5, 1, 3, 3]) == 8 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 >>> largest_rectangle_area([1, 1, 1, 1, 1]) == 5 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to process multiple test cases. >>> process_test_cases([(6, [2, 1, 5, 6, 2, 3]), (5, [1, 2, 3, 4, 5]), (7, [2, 1, 4, 5, 1, 3, 3])]) == [10, 9, 8] pass","solution":"def largest_rectangle_area(histogram): Function to calculate the largest rectangle area in a histogram. stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_test_cases(test_cases): Function to process multiple test cases. results = [] for case in test_cases: n, heights = case result = largest_rectangle_area(heights) results.append(result) return results"},{"question":"from typing import List from math import gcd from functools import reduce def smallest_possible_max(a: List[int]) -> int: Given a list of integers, returns the smallest possible maximum element after any number of GCD operations. >>> smallest_possible_max([6, 8, 12, 15]) 1 >>> smallest_possible_max([5]) 5 >>> smallest_possible_max([4, 4, 4]) 4 >>> smallest_possible_max([4, 9, 25, 49]) 1 >>> smallest_possible_max([100, 200, 300]) 100 >>> smallest_possible_max([12, 15, 18, 21]) 3 >>> smallest_possible_max([3, 5, 7]) 1","solution":"from math import gcd from functools import reduce def smallest_possible_max(a): Given a list of integers, returns the smallest possible maximum element after any number of GCD operations. return reduce(gcd, a)"},{"question":"def max_subarray_sum(crystals: List[int]) -> int: Returns the maximum sum of a contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-2, 3, 2, -1]) 5","solution":"def max_subarray_sum(crystals): Returns the maximum sum of a contiguous subarray. max_current = max_global = crystals[0] for num in crystals[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_repairs_from_input(input_string: str) -> int: Given the network topology as a list of direct connections, determine the minimum number of connections that need to be repaired to ensure that a virus can spread throughout the entire network. Args: input_string (str): The network topology as a string containing the number of computers, the number of direct connections, and the direct connections themselves. Returns: int: The minimum number of connections that need to be repaired. Example: >>> min_repairs_from_input(\\"4 2n1 2n3 4n\\") 1 >>> min_repairs_from_input(\\"1 0n\\") 0 >>> min_repairs_from_input(\\"3 3n1 2n2 3n1 3n\\") 0 >>> min_repairs_from_input(\\"6 3n1 2n2 3n4 5n\\") 2 >>> min_repairs_from_input(\\"5 0n\\") 4","solution":"def find_min_repairs(n, m, connections): parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for u, v in connections: union(u, v) root_set = set(find(i) for i in range(1, n + 1)) return len(root_set) - 1 # Parse input def min_repairs_from_input(input_string): input_lines = input_string.strip().split('n') n, m = map(int, input_lines[0].split()) connections = [tuple(map(int, line.split())) for line in input_lines[1:]] return find_min_repairs(n, m, connections)"},{"question":"def largest_uniform_subgrid_area(n: int, m: int, grid: List[str]) -> int: You are given a rectangular grid of size n x m filled with lowercase Latin letters. You need to find the largest rectangular sub-grid where every cell in the sub-grid is filled with the same character. Note that the sub-grid itself must also be a rectangular structure. >>> largest_uniform_subgrid_area(4, 5, [\\"abbaa\\", \\"aabbb\\", \\"aabba\\", \\"aaaab\\"]) 6 >>> largest_uniform_subgrid_area(3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 9 pass from typing import List def test_largest_uniform_subgrid_area_example1(): n = 4 m = 5 grid = [ \\"abbaa\\", \\"aabbb\\", \\"aabba\\", \\"aaaab\\" ] assert largest_uniform_subgrid_area(n, m, grid) == 6 def test_largest_uniform_subgrid_area_example2(): n = 3 m = 3 grid = [ \\"aaa\\", \\"aaa\\", \\"aaa\\" ] assert largest_uniform_subgrid_area(n, m, grid) == 9 def test_largest_uniform_subgrid_area_single_character(): n = 1 m = 1 grid = [ \\"a\\" ] assert largest_uniform_subgrid_area(n, m, grid) == 1 def test_largest_uniform_subgrid_area_different_characters(): n = 2 m = 2 grid = [ \\"ab\\", \\"cd\\" ] assert largest_uniform_subgrid_area(n, m, grid) == 1 def test_largest_uniform_subgrid_area_single_row(): n = 1 m = 5 grid = [ \\"aaaaa\\" ] assert largest_uniform_subgrid_area(n, m, grid) == 5 def test_largest_uniform_subgrid_area_single_column(): n = 5 m = 1 grid = [ \\"a\\", \\"a\\", \\"a\\", \\"b\\", \\"a\\" ] assert largest_uniform_subgrid_area(n, m, grid) == 3","solution":"def largest_uniform_subgrid_area(n, m, grid): max_area = 0 for i in range(n): for j in range(m): current_char = grid[i][j] for k in range(i, n): for l in range(j, m): if all(grid[x][y] == current_char for x in range(i, k + 1) for y in range(j, l + 1)): max_area = max(max_area, (k - i + 1) * (l - j + 1)) return max_area"},{"question":"from typing import List def coinChange(coins: List[int], amount: int) -> int: Determine the minimum number of coins needed to make up the given amount. Parameters: coins (List[int]): A list of distinct integers representing the coin denominations. amount (int): The total amount of money. Returns: int: The fewest number of coins needed to make up the given amount, or -1 if it's not possible. Examples: >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2, 4, 6], 3) -1","solution":"from typing import List def coinChange(coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List, Tuple def average_aqi(n: int, m: int, records: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Given the AQI data from multiple sensors, calculate the average AQI for each interval ID that appears in the data. If data from any sensor is missing for a particular interval, that sensor is ignored for that interval's calculation. If all sensors miss for a particular interval, the average AQI for that interval should be reported as -1. >>> average_aqi(7, 3, [(1, 1, 100), (2, 1, 50), (3, 1, 75), (1, 2, 200), (2, 3, 120), (1, 3, 80), (3, 3, 90)]) [(1, 75), (2, 200), (3, 96)] >>> average_aqi(0, 3, []) [] >>> average_aqi(2, 2, [(1, 1, 100), (2, 1, 100)]) [(1, 100)] >>> average_aqi(3, 2, [(1, 1, 100), (1, 2, 200), (2, 2, 300)]) [(1, 100), (2, 250)] >>> average_aqi(2, 3, [(1, 1, 100), (3, 1, 200)]) [(1, 150)] >>> average_aqi(4, 3, [(1, 1, 100), (3, 1, 50), (1, 2, 200), (2, 2, 300)]) [(1, 75), (2, 250)]","solution":"def average_aqi(n, m, records): from collections import defaultdict interval_aqi = defaultdict(list) # Collect AQI records for each interval for sensor_id, interval_id, aqi in records: interval_aqi[interval_id].append(aqi) # Calculate the average AQI for each interval result = [] for interval_id in sorted(interval_aqi): aqi_values = interval_aqi[interval_id] if aqi_values: average_aqi = sum(aqi_values) // len(aqi_values) else: average_aqi = -1 result.append((interval_id, average_aqi)) return result"},{"question":"from typing import List, Tuple def process_operations(n: int, m: int, k: int, special_nodes: List[int], operations: List[List[int]]) -> List[int]: Process a series of operations on a directed graph with special nodes. Args: n (int): The number of nodes in the graph. m (int): The number of operations to perform. k (int): The number of special nodes. special_nodes (List[int]): List of special nodes. operations (List[List[int]]): List of operations where each operation can be: - [1, u, v, w]: Add an edge with weight 'w' from node 'u' to node 'v'. - [2, a, b]: Query the shortest path from the special node corresponding to index 'a' to the node corresponding to index 'b'. Returns: List[int]: Results of the path queries, with each entry being the shortest path length or -1 if no path exists. Example: >>> n, m, k = 5, 5, 3 >>> special_nodes = [1, 3, 5] >>> operations = [ ... [1, 1, 2, 4], ... [1, 2, 3, 1], ... [1, 3, 4, 6], ... [2, 1, 2], ... [1, 4, 5, 2], ... [2, 2, 3] ... ] >>> process_operations(n, m, k, special_nodes, operations) [5, 8] pass from solution import process_operations def test_process_operations_case1(): n, m, k = 5, 5, 3 special_nodes = [1, 3, 5] operations = [ [1, 1, 2, 4], [1, 2, 3, 1], [1, 3, 4, 6], [2, 1, 2], [1, 4, 5, 2], [2, 2, 3] ] assert process_operations(n, m, k, special_nodes, operations) == [5, 8] def test_process_operations_case2(): n, m, k = 4, 3, 2 special_nodes = [2, 4] operations = [ [1, 2, 3, 5], [1, 3, 4, 2], [2, 1, 2] ] assert process_operations(n, m, k, special_nodes, operations) == [7] def test_process_operations_case3(): n, m, k= 3, 2, 2 special_nodes = [1, 3] operations = [ [1, 1, 2, 5], [2, 1, 2] ] assert process_operations(n, m, k, special_nodes, operations) == [-1] def test_path_not_exist(): n, m, k = 2, 3, 2 special_nodes = [1, 2] operations = [ [1, 1, 2, 5], [1, 2, 1, 2], [2, 1, 2] ] assert process_operations(n, m, k, special_nodes, operations) == [5] def test_single_node(): n, m, k = 1, 1, 1 special_nodes = [1] operations = [ [2, 1, 1] ] assert process_operations(n, m, k, special_nodes, operations) == [0]","solution":"import heapq from collections import defaultdict, deque def process_operations(n, m, k, special_nodes, operations): # Build the graph graph = defaultdict(list) # A function to run Dijkstra's algorithm from a start node def dijkstra(start, end): dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 pq = [(0, start)] visited = set() while pq: curr_dist, node = heapq.heappop(pq) if node in visited: continue visited.add(node) if node == end: return curr_dist for neighbor, weight in graph[node]: if neighbor not in visited and curr_dist + weight < dist[neighbor]: dist[neighbor] = curr_dist + weight heapq.heappush(pq, (dist[neighbor], neighbor)) return -1 results = [] special_index = {i + 1: special_nodes[i] for i in range(k)} for operation in operations: if operation[0] == 1: _, u, v, w = operation graph[u].append((v, w)) elif operation[0] == 2: _, a, b = operation node_a = special_index[a] node_b = special_index[b] shortest_path = dijkstra(node_a, node_b) results.append(shortest_path) return results"},{"question":"def find_smallest_index(n: int) -> int: Finds the smallest index k such that a(k) is greater than or equal to n. Given a sequence a(i) as: - a(1) = 1 - a(2) = 2 - a(i) = a(i-1) + a(i-2) for i > 2 Args: n: A positive integer (1 ≤ n ≤ 10^18) Returns: The smallest index k such that a(k) >= n. Examples: >>> find_smallest_index(10) 6 >>> find_smallest_index(1) 1 >>> find_smallest_index(2) 2","solution":"def find_smallest_index(n): Finds the smallest index k such that a(k) is greater than or equal to n where a(i) is defined as: - a(1) = 1 - a(2) = 2 - a(i) = a(i-1) + a(i-2) for i > 2 if n == 1: return 1 if n == 2: return 2 a1, a2 = 1, 2 k = 2 while a2 < n: a1, a2 = a2, a1 + a2 k += 1 return k"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Given a string s, returns the minimum number of characters that need to be inserted to make it a palindrome. >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"google\\") 2 pass def min_insertions_for_multiple_cases(test_cases: List[str]) -> List[int]: Given a list of strings, returns a list with the minimum number of characters needed for each string to be a palindrome. >>> min_insertions_for_multiple_cases([\\"race\\", \\"google\\"]) [3, 2] >>> min_insertions_for_multiple_cases([\\"a\\", \\"ab\\", \\"aba\\"]) [0, 1, 0] pass from min_insertions import min_insertions_to_palindrome, min_insertions_for_multiple_cases def test_single_case(): assert min_insertions_to_palindrome(\\"race\\") == 3 assert min_insertions_to_palindrome(\\"google\\") == 2 assert min_insertions_to_palindrome(\\"a\\") == 0 assert min_insertions_to_palindrome(\\"ab\\") == 1 assert min_insertions_to_palindrome(\\"aba\\") == 0 def test_multiple_cases(): test_cases = [\\"race\\", \\"google\\"] assert min_insertions_for_multiple_cases(test_cases) == [3, 2] test_cases = [\\"a\\", \\"ab\\", \\"aba\\"] assert min_insertions_for_multiple_cases(test_cases) == [0, 1, 0]","solution":"def min_insertions_to_palindrome(s): Given a string s, returns the minimum number of characters that need to be inserted to make it a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for gap in range(1, n): i = 0 for j in range(gap, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i][j-1], dp[i+1][j]) + 1 i += 1 return dp[0][-1] def min_insertions_for_multiple_cases(test_cases): return [min_insertions_to_palindrome(s) for s in test_cases]"},{"question":"def additional_tickets(n: int, k: int) -> int: Calculate the total number of additional tickets Arkady needs to prepare to ensure every subset size of employees from 1 to k can receive distinct consecutive numbers. :param n: Total number of employees :param k: Maximum subset size :return: Number of additional tickets required >>> additional_tickets(5, 3) 3 >>> additional_tickets(1, 1) 1 >>> additional_tickets(50, 50) 50 >>> additional_tickets(30, 20) 20 >>> additional_tickets(40, 15) 15 >>> additional_tickets(25, 10) 10","solution":"def additional_tickets(n, k): Returns the number of additional tickets required to ensure every subset size of employees from 1 to k can receive distinct consecutive numbers. :param n: Total number of employees :param k: Maximum subset size :return: Number of additional tickets required return k"},{"question":"def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves to reach the bottom-right cell from the top-left cell in a grid with obstacles. Args: n: int : number of rows in the grid m: int : number of columns in the grid grid: List[str] : grid representation with '.' for empty cell and '#' for obstacle Returns: int: minimum number of moves or -1 if no path exists >>> min_moves_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_reach_end(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) -1 from typing import List def test_min_moves_no_obstacles(): grid = [ \\"...\\" ] assert min_moves_to_reach_end(3, 3, grid) == 4 def test_min_moves_with_obstacle(): grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert min_moves_to_reach_end(3, 3, grid) == 4 def test_no_path(): grid = [ \\"...\\", \\"#\\", \\"...\\" ] assert min_moves_to_reach_end(3, 3, grid) == -1 def test_no_path_start_blocked(): grid = [ \\"#..\\", \\"...\\", \\"...\\" ] assert min_moves_to_reach_end(3, 3, grid) == -1 def test_no_path_end_blocked(): grid = [ \\"...\\", \\"...\\", \\"..#\\" ] assert min_moves_to_reach_end(3, 3, grid) == -1 def test_larger_grid_no_obstacles(): grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert min_moves_to_reach_end(4, 4, grid) == 6 def test_larger_grid_with_obstacles(): grid = [ \\"....\\", \\"..#.\\", \\"....\\", \\".#..\\" ] assert min_moves_to_reach_end(4, 4, grid) == 6","solution":"def min_moves_to_reach_end(n, m, grid): from collections import deque # Directions array for moving right and down directions = [(0, 1), (1, 0)] # Check if the starting or ending positions are blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # BFS queue and visited set queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n-1 and col == m-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited: if grid[new_row][new_col] == '.': queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def find_max_square_subgrid(n: int, m: int, grid: List[str]) -> int: Given a rectangular grid with dimensions n x m, where each cell has a value of either 0 or 1, returns the size of the largest square sub-grid containing only 1's. >>> find_max_square_subgrid(4, 5, [\\"10111\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 3 >>> find_max_square_subgrid(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 3 >>> find_max_square_subgrid(1, 1, [\\"0\\"]) 0 >>> find_max_square_subgrid(1, 1, [\\"1\\"]) 1 >>> find_max_square_subgrid(2, 2, [\\"01\\", \\"11\\"]) 1 >>> find_max_square_subgrid(3, 4, [\\"1101\\", \\"1101\\", \\"1111\\"]) 2 >>> find_max_square_subgrid(6, 6, [\\"100001\\", \\"111111\\", \\"111111\\", \\"111111\\", \\"111111\\", \\"111111\\"]) 5","solution":"def find_max_square_subgrid(n, m, grid): # Create a 2D list to store the size of the largest square ending at each point dp = [[0] * m for _ in range(n)] max_size = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"from typing import List def is_path_exists(n: int, m: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> str: Determines if there is a path from (sx, sy) to (dx, dy) in the grid. Moves can be made in the four cardinal directions: left, right, up, and down without passing through obstacles. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): Representation of the grid. sx (int): Starting row (1-based index). sy (int): Starting column (1-based index). dx (int): Destination row (1-based index). dy (int): Destination column (1-based index). Returns: str: 'YES' if a path exists, 'NO' otherwise. >>> is_path_exists(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"....\\"], 1, 1, 4, 4) \\"YES\\" >>> is_path_exists(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"\\"], 1, 1, 4, 4) \\"NO\\" def test_is_path_exists(): assert is_path_exists(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"....\\"], 1, 1, 4, 4) == \\"YES\\" assert is_path_exists(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"\\"], 1, 1, 4, 4) == \\"NO\\" assert is_path_exists(3, 3, [\\"...\\", \\"...\\", \\"...\\"], 1, 1, 3, 3) == \\"YES\\" assert is_path_exists(3, 3, [\\"#\\", \\"#..\\", \\"#\\"], 2, 2, 2, 3) == \\"YES\\" assert is_path_exists(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"], 2, 2, 2, 3) == \\"NO\\" assert is_path_exists(5, 5, [ \\".....\\", \\"...#.\\", \\".#...\\", \\"..#..\\", \\".....\\"], 1, 1, 5, 5) == \\"YES\\" test_is_path_exists()","solution":"from collections import deque def is_path_exists(n, m, grid, sx, sy, dx, dy): Determines if there is a path from (sx, sy) to (dx, dy) in the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): Representation of the grid. sx (int): Starting row (1-based index). sy (int): Starting column (1-based index). dx (int): Destination row (1-based index). dy (int): Destination column (1-based index). Returns: str: 'YES' if a path exists, 'NO' otherwise. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] sx, sy, dx, dy = sx-1, sy-1, dx-1, dy-1 queue = deque([(sx, sy)]) visited = set((sx, sy)) while queue: x, y = queue.popleft() if (x, y) == (dx, dy): return \\"YES\\" for dxn, dyn in directions: nx, ny = x + dxn, y + dyn if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def count_paths_with_one(n: int, m: int, grid: List[List[int]]) -> int: Calculate the number of distinct paths in a grid that start from the top-left cell and reach the bottom-right cell, passing through at least one cell with a value 1. >>> count_paths_with_one(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) # 2 >>> count_paths_with_one(2, 2, [ ... [0, 0], ... [0, 0], ... ]) # 0","solution":"def count_paths_with_one(n, m, grid): def dfs(x, y, contains_one): if x == n - 1 and y == m - 1: return 1 if contains_one or grid[x][y] == 1 else 0 if (x, y) in memo: if contains_one: return memo[(x, y)][1] return memo[(x, y)][0] paths = 0 if x + 1 < n: paths += dfs(x + 1, y, contains_one or grid[x + 1][y] == 1) if y + 1 < m: paths += dfs(x, y + 1, contains_one or grid[x][y + 1] == 1) memo[(x, y)] = (memo.get((x, y), (0, 0))[0], memo.get((x, y), (0, 0))[1]) if contains_one: memo[(x, y)] = (memo[(x, y)][0], paths) else: memo[(x, y)] = (paths, memo[(x, y)][1]) return paths memo = {} return dfs(0, 0, grid[0][0] == 1)"},{"question":"def perform_operations(n: int, m: int, a: List[int], operations: List[str]) -> List[int]: Perform a sequence of update and query operations on a list of integers. Parameters: n (int): Number of elements in the list. m (int): Number of operations to perform. a (List[int]): Initial list of integers. operations (List[str]): List of operations to perform on the list. Returns: List[int]: Results of the query operations. Example: >>> perform_operations(5, 4, [3, 1, 4, 1, 5], [\\"2 1 3\\", \\"1 2 2\\", \\"2 1 3\\", \\"2 3 5\\"]) [8, 9, 10] >>> perform_operations(5, 0, [3, 1, 4, 1, 5], []) [] result = [] # Your code starts here # Your code ends here return result # Unit tests def test_example_case(): n = 5 m = 4 a = [3, 1, 4, 1, 5] operations = [\\"2 1 3\\", \\"1 2 2\\", \\"2 1 3\\", \\"2 3 5\\"] assert perform_operations(n, m, a, operations) == [8, 9, 10] def test_no_operations(): n = 5 m = 0 a = [3, 1, 4, 1, 5] operations = [] assert perform_operations(n, m, a, operations) == [] def test_all_updates(): n = 4 m = 3 a = [7, 8, 9, 10] operations = [\\"1 1 3\\", \\"1 4 2\\", \\"1 2 1\\"] assert perform_operations(n, m, a, operations) == [] def test_all_queries(): n = 6 m = 3 a = [1, 2, 3, 4, 5, 6] operations = [\\"2 1 6\\", \\"2 1 3\\", \\"2 4 6\\"] assert perform_operations(n, m, a, operations) == [21, 6, 15] def test_mix_operations(): n = 5 m = 4 a = [10, 20, 30, 40, 50] operations = [\\"2 2 4\\", \\"1 3 25\\", \\"2 2 4\\", \\"2 1 5\\"] assert perform_operations(n, m, a, operations) == [90, 85, 145]","solution":"def perform_operations(n, m, a, operations): result = [] for operation in operations: op = operation.split() if op[0] == \\"1\\": index = int(op[1]) - 1 value = int(op[2]) a[index] = value elif op[0] == \\"2\\": l = int(op[1]) - 1 r = int(op[2]) result.append(sum(a[l:r])) return result"},{"question":"def max_sum_subarray_with_length_not_exceeding_k(arr, K): Find the maximum sum of a contiguous subarray with length not exceeding K. Args: arr: List[int]: A list of integers representing the sequence of operations. K: int: The maximum length of the contiguous subarray. Returns: int: The maximum sum of a contiguous subarray with length not exceeding K. Examples: >>> max_sum_subarray_with_length_not_exceeding_k([-1, 2, 3, -4, 5, 6, -7, 8], 3) 11 >>> max_sum_subarray_with_length_not_exceeding_k([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray_with_length_not_exceeding_k([-1, -2, -3, -4, -5], 2) -1 >>> max_sum_subarray_with_length_not_exceeding_k([1, -2, 3, 10, -4, 7, 2, -5], 4) 16 >>> max_sum_subarray_with_length_not_exceeding_k([5], 1) 5 >>> max_sum_subarray_with_length_not_exceeding_k([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray_with_length_not_exceeding_k([10, -25, 3, 2, 1], 1) 10 >>> max_sum_subarray_with_length_not_exceeding_k([-10, 20, 15], 2) 35 >>> max_sum_subarray_with_length_not_exceeding_k([0, 0, 0, 0], 2) 0","solution":"def max_sum_subarray_with_length_not_exceeding_k(arr, K): n = len(arr) max_sum = float('-inf') for curr_length in range(1, K+1): current_sum = sum(arr[:curr_length]) max_sum = max(max_sum, current_sum) for i in range(curr_length, n): current_sum += arr[i] - arr[i - curr_length] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import defaultdict def longest_route(m, edges): Finds the length of the longest route in a directed graph. Args: m (int): Number of directed paths. edges (list of tuples): Each tuple contains two integers (u, v) representing the directed path from u to v. Returns: int: Length of the longest route. def test_simple_case(): assert longest_route(3, [(1, 2), (2, 3), (3, 4)]) == 3 def test_single_path(): assert longest_route(1, [(1, 2)]) == 1 def test_cyclic_path(): assert longest_route(3, [(1, 2), (2, 3), (3, 1)]) == 2 def test_multiple_paths(): assert longest_route(5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) == 3 def test_no_path(): assert longest_route(0, []) == 0 def test_disconnected_graph(): assert longest_route(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) == 1 def test_large_number_of_paths(): edges = [(i, i + 1) for i in range(1, 100)] assert longest_route(99, edges) == 99","solution":"from collections import defaultdict def longest_route(m, edges): Finds the length of the longest route in a directed graph. Args: m (int): Number of directed paths. edges (list of tuples): Each tuple contains two integers (u, v) representing the directed path from u to v. Returns: int: Length of the longest route. graph = defaultdict(list) for u, v in edges: graph[u].append(v) def dfs(vertex, visited, memo): if vertex in memo: return memo[vertex] max_length = 0 visited.add(vertex) for neighbor in graph[vertex]: if neighbor not in visited: route_length = 1 + dfs(neighbor, visited, memo) max_length = max(max_length, route_length) visited.remove(vertex) memo[vertex] = max_length return max_length memo = {} max_route_length = 0 for landmark in range(1, 101): visited = set() max_route_length = max(max_route_length, dfs(landmark, visited, memo)) return max_route_length"},{"question":"def process_operations(n: int, operations: List[str]) -> List[int]: Process a sequence of operations on an initially zeroed sequence of length n and return the results of the \\"sum\\" operations. >>> process_operations(5, [\\"add 2 3\\", \\"add 4 5\\", \\"sum 1 5\\", \\"sum 2 4\\"]) [8, 8] >>> process_operations(1, [\\"add 1 10\\", \\"sum 1 1\\"]) [10] >>> process_operations(3, [\\"add 2 4\\", \\"sum 1 3\\", \\"sum 2 2\\", \\"sum 1 2\\"]) [4, 4, 4] >>> process_operations(4, [\\"add 1 0\\", \\"add 2 10\\", \\"add 3 0\\", \\"sum 1 4\\", \\"sum 1 2\\", \\"sum 2 2\\"]) [10, 10, 10] >>> process_operations(5, [\\"add 5 15\\", \\"add 4 10\\", \\"sum 1 5\\", \\"sum 4 5\\"]) [25, 25]","solution":"def process_operations(n, operations): sequence = [0] * n results = [] for op in operations: split = op.split() if split[0] == \\"add\\": i = int(split[1]) x = int(split[2]) sequence[i-1] += x elif split[0] == \\"sum\\": l = int(split[1]) r = int(split[2]) results.append(sum(sequence[l-1:r])) return results"},{"question":"def diagonal_sum(matrix: list[list[int]]) -> int: Returns the sum of the elements on the main diagonal and anti-diagonal of a square matrix, counting the middle element only once if it is common to both diagonals. Args: matrix (list of list of int): 2D list representing the square matrix Returns: int: The sum of the diagonal elements >>> diagonal_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 25 >>> diagonal_sum([ [1, 2], [3, 4]]) == 10 >>> diagonal_sum([ [5]]) == 5 >>> diagonal_sum([ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == 117 >>> diagonal_sum([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 68","solution":"def diagonal_sum(matrix): Returns the sum of the elements on the main diagonal and anti-diagonal of a square matrix, counting the middle element only once if it is common to both diagonals. Args: matrix (list of list of int): 2D list representing the square matrix Returns: int: The sum of the diagonal elements n = len(matrix) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) anti_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) if n % 2 == 1: middle_element = matrix[n // 2][n // 2] total_sum = main_diagonal_sum + anti_diagonal_sum - middle_element else: total_sum = main_diagonal_sum + anti_diagonal_sum return total_sum"},{"question":"def max_subarray_sum(a): Returns the maximum sum of any continuous subarray within the array a. Args: a (List[int]): The list of integers. Returns: int: The maximum sum of any continuous subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> large_array = [1000] * 100000 >>> max_subarray_sum(large_array) 100000000 >>> large_array = [-1000] * 100000 >>> max_subarray_sum(large_array) -1000","solution":"def max_subarray_sum(a): Returns the maximum sum of any continuous subarray within the array a. Uses Kadane's Algorithm. max_current = max_global = a[0] for num in a[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global # Example Usage: # n = 5 # a = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # print(max_subarray_sum(a)) # Output: 6"},{"question":"from typing import List, Tuple def max_points(n: int, m: int, start: Tuple[int, int], checkpoints: List[Tuple[int, int, int]]) -> int: Determine the maximum points you can collect if you start at the starting point and visit the checkpoints. Parameters: - n (int): The size of the grid. - m (int): The number of checkpoints. - start (Tuple[int, int]): The starting point coordinates. - checkpoints (List[Tuple[int, int, int]]): A list of tuples representing the coordinates of each checkpoint and the points you earn for visiting it. Returns: - int: The maximum number of points you can collect. Example: >>> max_points(4, 3, (1, 1), [(2, 2, 10), (3, 3, 20), (4, 4, 30)]) 60 pass def test_example_case(): n, m = 4, 3 start = (1, 1) checkpoints = [(2, 2, 10), (3, 3, 20), (4, 4, 30)] assert max_points(n, m, start, checkpoints) == 60 def test_single_checkpoint(): n, m = 3, 1 start = (1, 1) checkpoints = [(3, 3, 50)] assert max_points(n, m, start, checkpoints) == 50 def test_two_checkpoints(): n, m = 3, 2 start = (1, 1) checkpoints = [(3, 3, 50), (2, 2, 30)] assert max_points(n, m, start, checkpoints) == 80 def test_same_points_different_paths(): n, m = 4, 3 start = (1, 1) checkpoints = [(3, 3, 20), (4, 1, 30), (2, 2, 10)] assert max_points(n, m, start, checkpoints) == 60 def test_larger_grid(): n, m = 5, 4 start = (1, 1) checkpoints = [(3, 3, 20), (5, 5, 40), (2, 4, 30), (4, 2, 10)] assert max_points(n, m, start, checkpoints) == 100","solution":"from itertools import permutations def max_points(n, m, start, checkpoints): def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) max_points_collected = 0 for perm in permutations(checkpoints): points_collected = 0 current_position = start for checkpoint in perm: points_collected += checkpoint[2] current_position = (checkpoint[0], checkpoint[1]) max_points_collected = max(max_points_collected, points_collected) return max_points_collected # Example usage: n, m = 4, 3 start = (1, 1) checkpoints = [(2, 2, 10), (3, 3, 20), (4, 4, 30)] print(max_points(n, m, start, checkpoints)) # Output should be 60"},{"question":"def can_form_equal_stacks(n: int, books: List[Tuple[int, int]]) -> str: Determine if it is possible to form two stacks of books of equal height containing only books of one color each (blue or red). Args: n (int): the number of books books (List[Tuple[int, int]]): a list of tuples, where each tuple contains the height of the book and its color (0 represents blue, 1 represents red) Returns: str: \\"YES\\" if it is possible to form equal stacks, otherwise \\"NO\\" >>> can_form_equal_stacks(4, [(3, 0), (2, 0), (4, 1), (1, 1)]) \\"YES\\" >>> can_form_equal_stacks(2, [(5, 0), (7, 1)]) \\"NO\\"","solution":"def can_form_equal_stacks(n, books): blue_books = [] red_books = [] # Separate the books into blue and red stacks for height, color in books: if color == 0: blue_books.append(height) else: red_books.append(height) sum_blue = sum(blue_books) sum_red = sum(red_books) # If the total heights of blue and red stacks are already equal if sum_blue == sum_red: return \\"YES\\" # Determine all possible sums from the blue books def possible_sums(books): possible = {0} for book in books: new_possible = set() for ps in possible: new_possible.add(ps + book) possible.update(new_possible) return possible possible_blue_sums = possible_sums(blue_books) possible_red_sums = possible_sums(red_books) # Check if there is a possible sum in blue stack and red stack that is the same for blue_sum in possible_blue_sums: if (sum_blue - blue_sum) == (sum_red + blue_sum): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def post_visibility(n: int, friendships: List[Tuple[int, int]], user_id: int) -> int: Returns the number of unique friends who can see the post made by the user with ID user_id. :param n: An integer, the number of users. :param friendships: A list of tuples where each tuple (a, b) represents a bidirectional friendship connection. :param user_id: An integer, the ID of the user who made the post. :return: The number of unique friends who can see the post. # Your code here def test_post_visibility_one_user(): assert post_visibility(1, [], 1) == 0 def test_post_visibility_no_friends(): assert post_visibility(5, [], 3) == 0 def test_post_visibility_single_friendship(): assert post_visibility(3, [(1, 2)], 1) == 1 assert post_visibility(3, [(1, 2)], 2) == 1 def test_post_visibility_multiple_friends(): assert post_visibility(5, [(1, 2), (1, 3), (1, 4)], 1) == 3 def test_post_visibility_large_network(): assert post_visibility(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], 2) == 3 assert post_visibility(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], 1) == 2 def test_post_visibility_example_cases(): assert post_visibility(5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 1) == 2 assert post_visibility(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], 2) == 3","solution":"from typing import List, Tuple def post_visibility(n: int, friendships: List[Tuple[int, int]], user_id: int) -> int: Returns the number of unique friends who can see the post made by the user with ID user_id. :param n: An integer, the number of users. :param friendships: A list of tuples where each tuple (a, b) represents a bidirectional friendship connection. :param user_id: An integer, the ID of the user who made the post. :return: The number of unique friends who can see the post. # Create an adjacency list to represent the graph friends = {i: set() for i in range(1, n + 1)} for a, b in friendships: friends[a].add(b) friends[b].add(a) # The number of unique friends is the size of the set for user_id return len(friends[user_id])"},{"question":"def count_unique_ingredients(n: int, ingredients: List[str]) -> int: Returns the number of unique ingredients. Parameters: n (int): The number of ingredients. ingredients (list of str): The list of ingredients represented as strings. Returns: int: The number of unique ingredient types. # Example usage: # >>> count_unique_ingredients(7, [\\"flour\\", \\"sugar\\", \\"eggs\\", \\"milk\\", \\"butter\\", \\"sugar\\", \\"flour\\"]) # 5 # >>> count_unique_ingredients(5, [\\"flour\\", \\"flour\\", \\"flour\\", \\"flour\\", \\"flour\\"]) # 1 from typing import List def test_single_ingredient(): assert count_unique_ingredients(1, [\\"flour\\"]) == 1 def test_all_unique_ingredients(): assert count_unique_ingredients(4, [\\"flour\\", \\"sugar\\", \\"eggs\\", \\"milk\\"]) == 4 def test_all_duplicate_ingredients(): assert count_unique_ingredients(5, [\\"flour\\", \\"flour\\", \\"flour\\", \\"flour\\", \\"flour\\"]) == 1 def test_mixed_ingredients(): assert count_unique_ingredients(7, [\\"flour\\", \\"sugar\\", \\"eggs\\", \\"milk\\", \\"butter\\", \\"sugar\\", \\"flour\\"]) == 5 def test_edge_case_no_ingredients(): assert count_unique_ingredients(0, []) == 0","solution":"def count_unique_ingredients(n, ingredients): Returns the number of unique ingredients. Parameters: n (int): The number of ingredients. ingredients (list of str): The list of ingredients represented as strings. Returns: int: The number of unique ingredient types. return len(set(ingredients))"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root: TreeNode, v1: int, v2: int) -> int: Finds the lowest common ancestor of nodes with values v1 and v2 in a BST. >>> root = build_bst() >>> find_lca(root, 2, 8) == 6 >>> find_lca(root, 2, 4) == 2 >>> find_lca(root, 3, 5) == 4 >>> find_lca(root, 0, 6) == 6 >>> find_lca(root, 7, 9) == 8 def build_bst(): root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) return root def test_find_lca_case1(): root = build_bst() assert find_lca(root, 2, 8) == 6 def test_find_lca_case2(): root = build_bst() assert find_lca(root, 2, 4) == 2 def test_find_lca_case3(): root = build_bst() assert find_lca(root, 3, 5) == 4 def test_find_lca_case4(): root = build_bst() assert find_lca(root, 0, 6) == 6 def test_find_lca_case5(): root = build_bst() assert find_lca(root, 7, 9) == 8","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root: TreeNode, v1: int, v2: int) -> int: Finds the lowest common ancestor of nodes with values v1 and v2 in a BST. current = root while current: # If both v1 and v2 are smaller than current node's value, LCA is in left subtree if v1 < current.val and v2 < current.val: current = current.left # If both v1 and v2 are greater than current node's value, LCA is in right subtree elif v1 > current.val and v2 > current.val: current = current.right else: # We have found the split point, i.e., the LCA node return current.val return None"},{"question":"def can_be_made_increasing(arr): Determine if the array can be made strictly increasing by performing at most one increment or decrement operation. >>> can_be_made_increasing([1, 2, 3, 4, 5]) \\"YES\\" >>> can_be_made_increasing([1, 1, 2, 3]) \\"YES\\" >>> can_be_made_increasing([3, 3, 3]) \\"NO\\" def judge_test_cases(t, test_cases): Determine if each of the given test cases can be made strictly increasing by performing at most one increment or decrement operation. >>> judge_test_cases(3, [(5, [1, 2, 3, 4, 5]), (4, [1, 1, 2, 3]), (3, [3, 3, 3])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> judge_test_cases(2, [(4, [1, 2, 2, 4]), (6, [1, 3, 5, 7, 8, 9])]) [\\"YES\\", \\"YES\\"]","solution":"def can_be_made_increasing(arr): n = len(arr) violation_indices = [] for i in range(1, n): if arr[i] <= arr[i - 1]: violation_indices.append(i) if len(violation_indices) == 0: return \\"YES\\" if len(violation_indices) > 1: return \\"NO\\" v = violation_indices[0] # Try incrementing arr[v-1] or decrementing arr[v] if (v == n-1 or arr[v-1] < arr[v+1]) or (v == 1 or arr[v-2] < arr[v]): return \\"YES\\" return \\"NO\\" def judge_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(can_be_made_increasing(arr)) return results"},{"question":"def min_water_supply_cost(n, m, house_req, well_capacity, cost): Determine the minimum total cost to supply water to all the houses while satisfying the constraints. If it is not possible to satisfy the conditions, return -1. Args: n (int): Number of houses m (int): Number of wells house_req (List[int]): List of water requirements for each house well_capacity (List[int]): List of maximum capacity for each well cost (List[List[int]]): Matrix representing cost of supplying water from wells to houses Returns: int: Minimum total cost or -1 if not possible Examples: >>> n = 3 >>> m = 3 >>> house_req = [5, 10, 7] >>> well_capacity = [10, 15, 10] >>> cost = [ ... [2, 4, 6], ... [5, 7, 3], ... [8, 6, 4] ... ] >>> min_water_supply_cost(n, m, house_req, well_capacity, cost) 11 >>> n = 2 >>> m = 2 >>> house_req = [10, 10] >>> well_capacity = [5, 5] >>> cost = [ ... [1, 1], ... [1, 1] ... ] >>> min_water_supply_cost(n, m, house_req, well_capacity, cost) -1","solution":"def min_water_supply_cost(n, m, house_req, well_capacity, cost): from itertools import permutations def calculate_total_cost(order, house_req, cost): total_cost = 0 well_usage = [0] * m for i in range(n): min_cost = float('inf') chosen_well = -1 for j in range(m): if well_usage[j] + house_req[i] <= well_capacity[j]: if cost[i][j] < min_cost: min_cost = cost[i][j] chosen_well = j if chosen_well == -1: return float('inf') well_usage[chosen_well] += house_req[i] total_cost += min_cost return total_cost best_cost = float('inf') for perm in permutations(range(n)): perm_house_req = [house_req[i] for i in perm] current_cost = calculate_total_cost(perm, perm_house_req, cost) best_cost = min(best_cost, current_cost) return best_cost if best_cost != float('inf') else -1"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the characters of the given string such that no two adjacent characters are the same. If such a rearrangement is not possible, returns \\"NOT POSSIBLE\\". >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") 'NOT POSSIBLE' pass # Unit tests def test_example_1(): assert rearrange_string(\\"aabb\\") == \\"abab\\" def test_example_2(): assert rearrange_string(\\"aaab\\") == \\"NOT POSSIBLE\\" def test_single_character(): assert rearrange_string(\\"a\\") == \\"a\\" def test_two_different_characters(): assert rearrange_string(\\"ab\\") == \\"ab\\" def test_large_unrearrangeable_string(): assert rearrange_string(\\"aaaaaab\\") == \\"NOT POSSIBLE\\" def test_large_rearrangeable_string(): rearranged_string = rearrange_string(\\"aabbcc\\") assert sorted(rearranged_string) == sorted(\\"aabbcc\\") for i in range(1, len(rearranged_string)): assert rearranged_string[i] != rearranged_string[i - 1] def test_repeated_characters(): rearranged_string = rearrange_string(\\"aaabbbccc\\") assert sorted(rearranged_string) == sorted(\\"aaabbbccc\\") for i in range(1, len(rearranged_string)): assert rearranged_string[i] != rearranged_string[i - 1] def test_all_same_characters(): assert rearrange_string(\\"aaa\\") == \\"NOT POSSIBLE\\"","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Rearranges the characters of the given string such that no two adjacent characters are the same. If such a rearrangement is not possible, returns \\"NOT POSSIBLE\\". counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 return ''.join(result) if len(result) == len(s) else \\"NOT POSSIBLE\\""},{"question":"def minimize_waiting_time(n: int, times: List[int]) -> int: Returns the minimum sum of waiting times for reading all emails. :param n: The number of emails. :param times: A list of integers where each integer represents the time it takes to read an email. :return: The minimum sum of waiting times. >>> minimize_waiting_time(4, [2, 3, 1, 4]) 10 >>> minimize_waiting_time(1, [5]) 0 >>> minimize_waiting_time(5, [5, 2, 1, 3, 4]) 20 >>> minimize_waiting_time(3, [10, 1, 2]) 13 >>> minimize_waiting_time(6, [3, 3, 3, 3, 3, 3]) 45 >>> minimize_waiting_time(0, []) 0","solution":"def minimize_waiting_time(n, times): Returns the minimum sum of waiting times for reading all emails. :param n: The number of emails. :param times: A list of integers where each integer represents the time it takes to read an email. :return: The minimum sum of waiting times. # Sort the reading times in ascending order times.sort() total_waiting_time = 0 current_waiting_time = 0 for time in times: # Add the current waiting time to the total waiting time total_waiting_time += current_waiting_time # Update the current waiting time by adding the current reading time current_waiting_time += time return total_waiting_time"},{"question":"def most_frequent_char(t: int, strings: List[str]) -> List[str]: Given a number of test cases and a list of strings, return the most frequently occurring character in each string. If there is a tie, the lexicographically smallest character among the most frequently occurring characters is returned. Parameters: t (int): Number of test cases. strings (list of str): List of strings with only lowercase English letters. Returns: list of str: List of most frequently occurring characters for each string. >>> most_frequent_char(3, [\\"aabbbcc\\", \\"xyzxyz\\", \\"apple\\"]) [\\"b\\", \\"x\\", \\"p\\"] >>> most_frequent_char(1, [\\"abcdefgh\\"]) [\\"a\\"] >>> most_frequent_char(1, [\\"aabbcc\\"]) [\\"a\\"]","solution":"def most_frequent_char(t, strings): Given a number of test cases and a list of strings, this function returns the most frequently occurring character in each string. If there is a tie, the lexicographically smallest character among the most frequently occurring characters is returned. Parameters: t (int): Number of test cases. strings (list of str): List of strings with only lowercase English letters. Returns: list of str: List of most frequently occurring characters for each string. results = [] for s in strings: freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # Finding character with the maximum frequency max_freq = max(freq.values()) # Collecting all characters with the maximum frequency candidates = [char for char, count in freq.items() if count == max_freq] # Returning the lexicographically smallest character among the candidates results.append(min(candidates)) return results"},{"question":"def max_sum_path(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum sum Ingo can achieve by reaching the bottom-right corner of the grid. >>> max_sum_path(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_sum_path(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_sum_path(5, 1, [[1], [2], [3], [4], [5]]) 15 >>> max_sum_path(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_sum_path(2, 2, [[1000, 1000], [1000, 1000]]) 3000 >>> max_sum_path(4, 4, [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]) 10","solution":"def max_sum_path(n, m, grid): # Initialize a DP table to store the maximum sum till each cell dp = [[0] * m for _ in range(n)] # Base case: the value of the top-left cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The result is in the bottom-right cell return dp[n-1][m-1]"},{"question":"def smallest_integer_after_transformations(n: int, k: int, s: str) -> str: Returns the smallest possible integer after k transformations. Parameters: n (int): length of the integer string k (int): number of transformations s (str): the integer in string format Returns: str: the smallest possible integer after k transformations >>> smallest_integer_after_transformations(5, 1, \\"54321\\") '14325' >>> smallest_integer_after_transformations(5, 2, \\"43215\\") '12345' >>> smallest_integer_after_transformations(2, 0, \\"21\\") '21'","solution":"def smallest_integer_after_transformations(n, k, s): Returns the smallest possible integer after k transformations. Parameters: n (int): length of the integer string k (int): number of transformations s (str): the integer in string format Returns: str: the smallest possible integer after k transformations s = list(s) for i in range(n): if k == 0: break min_digit = s[i] min_index = i # Find the smallest digit in the remaining array for j in range(i + 1, n): if s[j] < min_digit: min_digit = s[j] min_index = j # If the smallest digit is not in the current position if min_index != i: s[i], s[min_index] = s[min_index], s[i] k -= 1 return ''.join(s)"},{"question":"def connect_buildings(n: int, m: int, k: int, buildings: [(int, int)]) -> str: Determines if it's possible to connect all important buildings with non-overlapping horizontal and vertical rail tracks. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of important buildings. buildings (list of tuples): List of coordinates (x, y) of important buildings. Returns: str: \\"Possible\\" + grid configuration or \\"Impossible\\". >>> connect_buildings(5, 5, 1, [(3, 3)]) 'Possiblen n n o n n ' >>> connect_buildings(5, 5, 2, [(1, 1), (5, 1)]) 'Possibleno n| n| n| no ' >>> connect_buildings(5, 5, 2, [(1, 1), (1, 5)]) 'Possibleno---on n n n ' >>> connect_buildings(5, 5, 4, [(1, 1), (1, 5), (5, 1), (5, 5)]) 'Possibleno---on| |n| |n| |no---o' >>> connect_buildings(10, 10, 4, [(1, 1), (1, 10), (10, 1), (10, 10)]).startswith('Possible') True","solution":"def connect_buildings(n, m, k, buildings): Determines if it's possible to connect all important buildings with non-overlapping horizontal and vertical rail tracks. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of important buildings. buildings (list of tuples): List of coordinates (x, y) of important buildings. Returns: str: \\"Possible\\" + grid configuration or \\"Impossible\\". # Can only connect up to 100 buildings from itertools import product if k == 1: # If there's only one building, it's trivially possible grid = [[' ' for _ in range(m)] for _ in range(n)] x, y = buildings[0] grid[x-1][y-1] = 'o' return \\"Possiblen\\" + 'n'.join(''.join(row) for row in grid) # Ensure all buildings are connectable by placing tracks grid = [[' ' for _ in range(m)] for _ in range(n)] for x, y in buildings: grid[x-1][y-1] = 'o' for x, y in buildings: # Connect vertically if another building shares the same column for bx, by in buildings: if (bx, by) != (x, y) and by == y: for i in range(min(x, bx), max(x, bx)): if grid[i-1][y-1] == 'o': continue grid[i-1][y-1] = '|' # Connect horizontally if another building shares the same row for bx, by in buildings: if (bx, by) != (x, y) and bx == x: for j in range(min(y, by), max(y, by)): if grid[x-1][j-1] == 'o': continue grid[x-1][j-1] = '-' return \\"Possiblen\\" + 'n'.join(''.join(row) for row in grid) # Sample data for manual testing n, m, k = 5, 5, 4 buildings = [(1, 1), (1, 4), (4, 1), (4, 4)] print(connect_buildings(n, m, k, buildings))"},{"question":"from typing import List, Tuple class TreeNode: def __init__(self, val): self.val = val self.children = [] def build_tree(n: int, edges: List[Tuple[int, int]]) -> TreeNode: Build an adjacency list representation of the tree. nodes = {i: TreeNode(i) for i in range(1, n + 1)} for u, v in edges: nodes[u].children.append(nodes[v]) nodes[v].children.append(nodes[u]) return nodes[1] # Return the root node def longest_path(root: TreeNode) -> int: Find the longest path from the root to a leaf node. def dfs(node, parent): max_depth = 0 for child in node.children: if child != parent: max_depth = max(max_depth, dfs(child, node)) return max_depth + 1 return dfs(root, None) - 1 def find_longest_path(n: int, edges: List[Tuple[int, int]]) -> int: Given a binary tree, find the longest path from the root node to a leaf node. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): The edges connecting the nodes. Returns: int: The length of the longest path from the root node to a leaf node. Examples: >>> find_longest_path(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> find_longest_path(1, []) 0","solution":"class TreeNode: def __init__(self, val): self.val = val self.children = [] def build_tree(n, edges): Build an adjacency list representation of the tree. nodes = {i: TreeNode(i) for i in range(1, n + 1)} for u, v in edges: nodes[u].children.append(nodes[v]) nodes[v].children.append(nodes[u]) return nodes[1] # Return the root node def longest_path(root): Find the longest path from the root to a leaf node. def dfs(node, parent): max_depth = 0 for child in node.children: if child != parent: max_depth = max(max_depth, dfs(child, node)) return max_depth + 1 return dfs(root, None) - 1 def find_longest_path(n, edges): root = build_tree(n, edges) return longest_path(root)"},{"question":"def decay_cycles(n: int, energy_levels: List[int], d: int) -> int: Returns the number of complete decay cycles required for all atoms to decay completely. :param n: number of atoms :param energy_levels: list of initial energy levels of the atoms :param d: decay factor :return: number of complete decay cycles required for all atoms to decay completely >>> decay_cycles(3, [10, 15, 8], 3) == 5 >>> decay_cycles(4, [100, 200, 300, 400], 50) == 8 >>> decay_cycles(5, [20, 20, 20, 20, 20], 4) == 5 >>> decay_cycles(1, [30], 10) == 3 >>> decay_cycles(3, [25, 50, 75], 25) == 3 >>> decay_cycles(50, [i for i in range(1, 51)], 1) == 50","solution":"def decay_cycles(n, energy_levels, d): Returns the number of complete decay cycles required for all atoms to decay completely. :param n: number of atoms :param energy_levels: list of initial energy levels of the atoms :param d: decay factor :return: number of complete decay cycles required for all atoms to decay completely max_energy = max(energy_levels) cycles = (max_energy + d - 1) // d # Ceiling of max_energy / d return cycles"},{"question":"def min_execution_time(m: int, participants_data: List[Tuple[int, List[int], List[int]]]) -> List[int]: Compute the minimal total execution times efficiently for each participant. >>> min_execution_time(2, [(3, [5, 2, 8], [1, 2, 1]), (4, [7, 5, 3, 4], [2, 2, 3, 1])]) [8, 7] >>> min_execution_time(1, [(3, [1, 2, 3], [1, 2, 3])]) [3] >>> min_execution_time(1, [(3, [3, 3, 3], [1, 1, 1])]) [3] >>> min_execution_time(1, [(5, [5, 3, 4, 2, 1], [1, 1, 2, 2, 3])]) [5] >>> min_execution_time(3, [(4, [8, 7, 6, 5], [1, 1, 2, 2]), (4, [5, 7, 4, 3], [3, 3, 3, 2]), (2, [1, 2], [1, 2])]) [8, 7, 2]","solution":"def min_execution_time(m, participants_data): results = [] for pdata in participants_data: n, times, slots = pdata slot_dict = {} for time, slot in zip(times, slots): if slot not in slot_dict: slot_dict[slot] = [] slot_dict[slot].append(time) min_total_time = 0 for slot_times in slot_dict.values(): min_total_time = max(min_total_time, max(slot_times)) results.append(min_total_time) return results"},{"question":"def most_popular_products(sales): Returns the most popular product in each category based on the number of units sold. If there is a tie, the product with the smallest product ID is chosen. Args: - sales (list): List of tuples with (product_id, category, units_sold) Returns: - dict: Dictionary where keys are categories and values are the most popular product IDs Example: >>> sales = [ (101, 'electronics', 150), (102, 'electronics', 120), (103, 'electronics', 150), (201, 'books', 210), (202, 'books', 230), (203, 'books', 230), (301, 'clothing', 310) ] >>> most_popular_products(sales) { 'electronics': 101, 'books': 202, 'clothing': 301 } # Your code here # Test cases def test_most_popular_products(): sales = [ (101, 'electronics', 150), (102, 'electronics', 120), (103, 'electronics', 150), (201, 'books', 210), (202, 'books', 230), (203, 'books', 230), (301, 'clothing', 310) ] assert most_popular_products(sales) == { 'electronics': 101, 'books': 202, 'clothing': 301 } def test_most_popular_products_tie(): sales = [ (101, 'electronics', 150), (103, 'electronics', 150), (102, 'electronics', 150), (202, 'books', 230), (201, 'books', 210), (203, 'books', 200), (301, 'clothing', 310) ] assert most_popular_products(sales) == { 'electronics': 101, 'books': 202, 'clothing': 301 } def test_most_popular_products_single_sales(): sales = [ (101, 'electronics', 250) ] assert most_popular_products(sales) == { 'electronics': 101 } def test_most_popular_products_multiple_categories(): sales = [ (301, 'clothing', 300), (401, 'furniture', 500), (501, 'toys', 250), (701, 'groceries', 400), (801, 'beauty', 450) ] assert most_popular_products(sales) == { 'clothing': 301, 'furniture': 401, 'toys': 501, 'groceries': 701, 'beauty': 801 } def test_most_popular_products_empty(): sales = [] assert most_popular_products(sales) == {}","solution":"def most_popular_products(sales): Returns the most popular product in each category based on the number of units sold. If there is a tie, the product with the smallest product ID is chosen. category_popularity = {} for product_id, category, units_sold in sales: if category not in category_popularity: category_popularity[category] = (product_id, units_sold) else: current_most_popular = category_popularity[category] if units_sold > current_most_popular[1] or (units_sold == current_most_popular[1] and product_id < current_most_popular[0]): category_popularity[category] = (product_id, units_sold) return {category: product_id for category, (product_id, units_sold) in category_popularity.items()}"},{"question":"from typing import List def min_swaps_to_make_equal(n: int, a: str, b: str) -> int: Determine the minimum number of swaps to make two strings equal. Args: n (int): The length of the strings. a (str): The first string. b (str): The second string. Returns: int: The minimum number of swaps needed to make the strings equal, or -1 if it's impossible. >>> min_swaps_to_make_equal(4, 'abac', 'baca') 2 >>> min_swaps_to_make_equal(4, 'abcd', 'abcd') 0 >>> min_swaps_to_make_equal(5, 'abcde', 'abccd') -1 >>> min_swaps_to_make_equal(4, 'abcd', 'dcba') 2 >>> min_swaps_to_make_equal(6, 'aabccb', 'bbcaac') 3 pass def test_min_swaps_to_make_equal_basic(): assert min_swaps_to_make_equal(4, 'abac', 'baca') == 2 def test_min_swaps_to_make_equal_simple_no_swap_needed(): assert min_swaps_to_make_equal(4, 'abcd', 'abcd') == 0 def test_min_swaps_to_make_equal_impossible_case(): assert min_swaps_to_make_equal(5, 'abcde', 'abccd') == -1 def test_min_swaps_to_make_equal_mismatched_length_strings(): # This test should consider the lengths directly, assuming the function handles that assert min_swaps_to_make_equal(5, 'abcde', 'abcd') == -1 def test_min_swaps_to_make_equal_all_different(): assert min_swaps_to_make_equal(4, 'abcd', 'dcba') == 2 def test_min_swaps_to_make_equal_mixed_characters(): assert min_swaps_to_make_equal(6, 'aabccb', 'bbcaac') == 3","solution":"def min_swaps_to_make_equal(n, a, b): from collections import Counter # Count the characters in both strings count_a = Counter(a) count_b = Counter(b) # Each character must be present in both strings the same number of times if count_a != count_b: return -1 # Determine the positions of mismatching characters mismatch_a = [] mismatch_b = [] for i in range(n): if a[i] != b[i]: mismatch_a.append(a[i]) mismatch_b.append(b[i]) # Find any optimal pairing for swaps swaps = 0 i = 0 while i < len(mismatch_a): j = i + 1 while j < len(mismatch_b): if mismatch_a[i] == mismatch_b[j] and mismatch_a[j] == mismatch_b[i]: swaps += 1 mismatch_a.pop(j) mismatch_b.pop(j) mismatch_a.pop(i) mismatch_b.pop(i) break j += 1 else: i += 1 return swaps + len(mismatch_a) // 2"},{"question":"from typing import List, Tuple def count_divisibles_by_six(a: int, b: int) -> int: Returns the count of numbers divisible by 6 between a and b inclusive. >>> count_divisibles_by_six(1, 10) 1 >>> count_divisibles_by_six(15, 30) 3 >>> count_divisibles_by_six(10, 61) 9 def treasure_hunt_divisibles(t: int, ranges: List[Tuple[int, int]]) -> List[int]: For each pair (a, b) in ranges, returns the number of integers divisible by 6 between a and b inclusive. >>> treasure_hunt_divisibles(3, [(1, 10), (15, 30), (10, 61)]) [1, 3, 9] >>> treasure_hunt_divisibles(3, [(5, 20), (30, 60), (1, 6)]) [3, 6, 1]","solution":"def count_divisibles_by_six(a, b): Returns the count of numbers divisible by 6 between a and b inclusive. def count_up_to(n): return n // 6 return count_up_to(b) - count_up_to(a - 1) def treasure_hunt_divisibles(t, ranges): For each pair (a, b) in ranges, returns the number of integers divisible by 6 between a and b inclusive. results = [] for a, b in ranges: results.append(count_divisibles_by_six(a, b)) return results"},{"question":"def min_trees_to_cut(n: int, heights: List[int]) -> int: Returns the minimum number of trees that need to be cut down so that no two adjacent trees have the same height. Parameters: n (int): The number of trees. heights (List[int]): A list of integers representing the heights of the trees. Returns: int: The minimum number of trees to cut down. >>> min_trees_to_cut(6, [4, 7, 4, 4, 6, 4]) 1 >>> min_trees_to_cut(5, [1, 2, 3, 4, 5]) 0 >>> min_trees_to_cut(4, [6, 6, 6, 6]) 3 >>> min_trees_to_cut(5, [1, 1, 1, 1, 1]) 4 >>> min_trees_to_cut(6, [2, 2, 2, 2, 2, 2]) 5 >>> min_trees_to_cut(7, [4, 4, 5, 5, 4, 4, 6]) 3 >>> min_trees_to_cut(1, [1]) 0","solution":"def min_trees_to_cut(n, heights): Returns the minimum number of trees that need to be cut down so that no two adjacent trees have the same height. Parameters: n (int): The number of trees. heights (List[int]): A list of integers representing the heights of the trees. Returns: int: The minimum number of trees to cut down. last = None cut_count = 0 for i in range(n): if i > 0 and heights[i] == last: cut_count += 1 else: last = heights[i] return cut_count"},{"question":"def find_shortest_special_substrings(t: int, test_cases: List[Tuple[str, str]]) -> List[int]: Find the length of the shortest \\"special\\" substring for multiple test cases. A \\"special\\" substring contains all characters from the set \`chars\` at least once. Args: t: An integer representing the number of test cases. test_cases: A list of tuples where each tuple contains a string \`s\` and a string \`chars\`. Returns: A list of integers where each integer represents the length of the shortest \\"special\\" substring for each test case, or -1 if no such substring exists. Examples: >>> find_shortest_special_substrings(2, [(\\"abacabadabacaba\\", \\"abc\\"), (\\"aaaaaaa\\", \\"bc\\")]) [3, -1] >>> find_shortest_special_substrings(1, [(\\"abcabcabc\\", \\"acb\\")]) [3] >>> find_shortest_special_substrings(1, [(\\"abcd\\", \\"abcd\\")]) [4] >>> find_shortest_special_substrings(1, [(\\"abcdef\\", \\"gh\\")]) [-1] >>> find_shortest_special_substrings(1, [(\\"zzzzzzzzzzz\\", \\"z\\")]) [1] pass","solution":"def shortest_special_substring(s, chars): Finds the length of the shortest substring of s which contains all characters in chars at least once. import sys from collections import Counter, defaultdict n = len(s) chars_set = set(chars) chars_count = Counter(chars) left = 0 formed = 0 window_counts = defaultdict(int) answer = float('inf') for right in range(n): char = s[right] if char in chars_set: window_counts[char] += 1 if window_counts[char] == chars_count[char]: formed += 1 while left <= right and formed == len(chars_set): answer = min(answer, right - left + 1) char = s[left] if char in chars_set: if window_counts[char] == chars_count[char]: formed -= 1 window_counts[char] -= 1 left += 1 return answer if answer != float('inf') else -1 def find_shortest_special_substrings(t, test_cases): results = [] for s, chars in test_cases: result = shortest_special_substring(s, chars) results.append(result) return results"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, s: int, d: int, edges: List[Tuple[int, int, int]]) -> List[int]: Given a weighted, undirected graph where each edge has a cost associated with it, find the shortest path from a starting node to a destination node. If multiple paths have the same shortest distance, find any one of those paths. >>> shortest_path(5, 6, 1, 5, [(1, 2, 3), (1, 3, 1), (2, 3, 1), (3, 4, 6), (2, 5, 5), (4, 5, 2)]) [1, 3, 2, 5] >>> shortest_path(4, 4, 1, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 10)]) [1, 2, 3, 4] def test_shortest_path_simple_case(): n = 5 m = 6 s = 1 d = 5 edges = [ (1, 2, 3), (1, 3, 1), (2, 3, 1), (3, 4, 6), (2, 5, 5), (4, 5, 2) ] result = shortest_path(n, m, s, d, edges) assert result == [1, 3, 2, 5] or result == [1, 2, 5] def test_shortest_path_another_case(): n = 4 m = 4 s = 1 d = 4 edges = [ (1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 10) ] result = shortest_path(n, m, s, d, edges) assert result == [1, 2, 3, 4] def test_shortest_path_single_edge(): n = 2 m = 1 s = 1 d = 2 edges = [ (1, 2, 5) ] result = shortest_path(n, m, s, d, edges) assert result == [1, 2] def test_shortest_path_more_complex_case(): n = 6 m = 9 s = 1 d = 6 edges = [ (1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (4, 5, 6), (5, 6, 9) ] result = shortest_path(n, m, s, d, edges) assert result == [1, 3, 6]","solution":"import heapq def shortest_path(n, m, s, d, edges): # Construct the graph in adjacency list representation graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Initialize Dijkstra's algorithm distances = {i: float('inf') for i in range(1, n+1)} previous_nodes = {i: None for i in range(1, n+1)} distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the path from s to d path = [] current_node = d while previous_nodes[current_node] is not None: path.append(current_node) current_node = previous_nodes[current_node] path.append(s) path.reverse() return path"},{"question":"def max_increase_in_range(bloom_times: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a list of bloom times for flower beds and a list of queries as ranges, returns the maximum increase in blooming times between consecutive flower beds within each range. >>> max_increase_in_range([1, 3, 5, 4, 2], [(1, 3), (2, 5), (1, 5)]) [2, 2, 2] >>> max_increase_in_range([10, 20, 15, 22, 18], [(1, 5)]) [10] >>> max_increase_in_range([50, 55, 53, 52, 51], [(1, 2), (2, 3), (3, 4), (4, 5)]) [5, -2, -1, -1] >>> max_increase_in_range([5, 5, 5, 5, 5], [(1, 3), (2, 4), (1, 5)]) [0, 0, 0] >>> max_increase_in_range([100, 90, 80, 70, 60], [(1, 5), (1, 3), (3, 5)]) [-10, -10, -10] pass","solution":"def max_increase_in_range(bloom_times, queries): Given a list of bloom times for flower beds and a list of queries as ranges, returns the maximum increase in blooming times between consecutive flower beds within each range. results = [] for l, r in queries: max_increase = float('-inf') for i in range(l - 1, r - 1): increase = bloom_times[i+1] - bloom_times[i] if increase > max_increase: max_increase = increase results.append(max_increase) return results"},{"question":"def max_resources(n: int, a: List[int]) -> int: This function returns the maximum resources a player can collect in a single continuous run on a circular map. Parameters: n (int): number of regions a (list of int): resources in each region Output: int: maximum resources collectable pass # Unit tests def test_single_region(): assert max_resources(1, [10]) == 10 def test_multiple_regions(): assert max_resources(5, [2, 3, 1, 5, 4]) == 15 assert max_resources(4, [1, 2, 3, 4]) == 10 assert max_resources(3, [3, 1, 2]) == 6 def test_high_values(): assert max_resources(3, [1000000, 1000000, 1000000]) == 3000000 assert max_resources(2, [1, 1000000]) == 1000001 def test_boundary_conditions(): assert max_resources(100000, [1] * 100000) == 100000 a = [i for i in range(100000, 0, -1)] assert max_resources(100000, a) == 5000050000","solution":"def max_resources(n, a): This function returns the maximum resources a player can collect in a single continuous run on a circular map. Parameters: n (int): number of regions a (list of int): resources in each region Output: int: maximum resources collectable # Edge case, if there's just one region, that's the maximum sum if n == 1: return a[0] # Calculate total sum of array elements total_sum = sum(a) # To handle the circular nature, we consider the array two times consecutively a = a + a max_sum = float('-inf') current_sum = 0 start = 0 # Slide window of size n across the extended array for i in range(2 * n): current_sum += a[i] if (i - start + 1) == n: max_sum = max(max_sum, current_sum) current_sum -= a[start] start += 1 return max_sum"},{"question":"def decompress(s: str) -> str: Decompresses a run-length encoded string into its original form. Parameters: s (str): The compressed string in the format where each letter is followed by the number of times it appears consecutively. Returns: str: The decompressed string. >>> decompress(\\"a3b3c2\\") 'aaabbbcc' >>> decompress(\\"a10b1\\") 'aaaaaaaaaab' >>> decompress(\\"x2y3\\") 'xxyyy' pass # Example usage: compressed = \\"a3b3c2\\" print(decompress(compressed)) # Output: aaabbbcc","solution":"def decompress(s): Decompresses a run-length encoded string into its original form. Parameters: s (str): The compressed string in the format where each letter is followed by the number of times it appears consecutively. Returns: str: The decompressed string. decompressed_str = [] i = 0 while i < len(s): char = s[i] # Get the character # Find the full number which may have multiple digits num_str = '' i += 1 while i < len(s) and s[i].isdigit(): num_str += s[i] i += 1 count = int(num_str) # Convert the num_str to an integer count decompressed_str.append(char * count) # Append the character count times to the list return ''.join(decompressed_str)"},{"question":"def generate_prime_sequence(n: int) -> List[int]: Generate a sequence of length n such that: - Each number in the sequence is a prime number. - The sequence contains the smallest possible prime numbers that sum up to n. Args: n (int): Length of the sequence to generate. Returns: List[int]: A sequence of prime numbers that sum up to n. >>> generate_prime_sequence(5) [2, 3] >>> generate_prime_sequence(8) [2, 2, 2, 2]","solution":"def generate_prime_sequence(n): if n < 2: return [] if n % 2 == 1: return [2] * (n // 2 - 1) + [3] else: return [2] * (n // 2) # Example usage: # generate_prime_sequence(5) -> [2, 3] # generate_prime_sequence(8) -> [2, 2, 2, 2]"},{"question":"def min_delivery_route_time(dist): Find the minimum time needed to complete the delivery route while visiting each location exactly once and returning to the starting location. >>> min_delivery_route_time([ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> min_delivery_route_time([ ... [0, 10], ... [10, 0] ... ]) 20 >>> min_delivery_route_time([ ... [0, 10, 15], ... [10, 0, 20], ... [15, 20, 0] ... ]) 45 >>> min_delivery_route_time([ ... [0, 1, 1, 1], ... [1, 0, 1, 1], ... [1, 1, 0, 1], ... [1, 1, 1, 0] ... ]) 4 >>> min_delivery_route_time([[0]]) 0","solution":"def min_delivery_route_time(dist): from functools import lru_cache n = len(dist) @lru_cache(None) def dp(mask, i): if mask == (1 << n) - 1: return dist[i][0] ans = float('inf') for j in range(n): if (mask & (1 << j)) == 0: ans = min(ans, dist[i][j] + dp(mask | (1 << j), j)) return ans return dp(1, 0) # Example usage dist_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] print(min_delivery_route_time(dist_matrix)) # Output should be 80"},{"question":"def charity_auction(n: int, T: int, items: List[Tuple[int, int]]) -> int: Determine the minimum cost of achieving the target fund in a charity auction. Args: n (int): The number of items available for auction. T (int): The target fund to achieve. items (List[Tuple[int, int]]): A list of tuples where each tuple contains the price and value of an item. Returns: int: The minimum total price required to achieve at least the target fund. If it is not possible, return -1. >>> charity_auction(4, 10, [(4, 6), (2, 4), (7, 8), (5, 3)]) 6 >>> charity_auction(1, 11, [(10, 10)]) -1","solution":"def minimum_cost_achieving_target(n, T, items): # Create a dp array where dp[i] represents the minimum cost to achieve at least value i dp = [float('inf')] * (T + 1) dp[0] = 0 for price, value in items: for i in range(T, value - 1, -1): dp[i] = min(dp[i], dp[i - value] + price) result = min(dp[T:]) return result if result != float('inf') else -1 def charity_auction(n, T, items): min_cost = minimum_cost_achieving_target(n, T, items) return min_cost"},{"question":"from typing import List, Tuple def max_2x2_subgrid_sum(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum sum of all elements in any subgrid of size 2x2. >>> max_2x2_subgrid_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 28 >>> max_2x2_subgrid_sum(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 54 pass def process_test_cases(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Process multiple test cases for the max_2x2_subgrid_sum function. >>> process_test_cases([(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])]) [28, 54] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_2x2_subgrid_sum(n, m, grid): max_sum = 0 for i in range(n - 1): for j in range(m - 1): current_sum = ( grid[i][j] + grid[i][j + 1] + grid[i + 1][j] + grid[i + 1][j + 1] ) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for n, m, grid in test_cases: results.append(max_2x2_subgrid_sum(n, m, grid)) return results"},{"question":"def is_palindrome(n: int) -> bool: Check if the given number n is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(1) == True >>> is_palindrome(0) == True >>> is_palindrome(12321) == True def count_palindromes(L: int, R: int) -> int: Count the number of palindrome numbers between L and R, inclusive. >>> count_palindromes(10, 20) == 1 # Only 11 is a palindrome >>> count_palindromes(1, 9) == 9 # All single digit numbers are palindromes >>> count_palindromes(100, 200) == 10 # Palindromes: 101, 111, 121, 131, 141, 151, 161, 171, 181, 191 >>> count_palindromes(110, 121) == 2 # Palindromes: 111, 121 >>> count_palindromes(998999, 999999) == 1 # Palindrome: 999999","solution":"def is_palindrome(n): Check if the given number n is a palindrome. return str(n) == str(n)[::-1] def count_palindromes(L, R): Count the number of palindrome numbers between L and R, inclusive. count = 0 for i in range(L, R + 1): if is_palindrome(i): count += 1 return count"},{"question":"from typing import List, Tuple def min_max_danger_path(n: int, m: int, s: int, t: int, edges: List[Tuple[int, int, int]]) -> int: Given a directed graph with \`n\` nodes and \`m\` edges, determines the shortest path from a source node \`s\` to a target node \`t\` such that the maximum danger level encountered along the path is minimized. Args: n (int): Number of nodes. m (int): Number of edges. s (int): Source node. t (int): Target node. edges (List[Tuple[int, int, int]]): List of tuples representing edges where each tuple (u, v, d) represents an edge from node \`u\` to node \`v\` with danger level \`d\`. Returns: int: The minimum possible value of the maximum danger level encountered along the path from \`s\` to \`t\`. If there is no such path, returns \`-1\`. Examples: >>> min_max_danger_path(4, 5, 1, 4, [(1, 2, 3), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 2)]) 3 >>> min_max_danger_path(3, 2, 1, 3, [(1, 2, 5), (2, 1, 5)]) -1 pass","solution":"import heapq def min_max_danger_path(n, m, s, t, edges): Finds the path from s to t that minimizes the maximum danger level on the path. Returns the minimum possible value of the maximum danger level encountered along the path. If there is no such path, returns -1. # Graph representation graph = [[] for _ in range(n + 1)] for u, v, d in edges: graph[u].append((v, d)) # Binary search over the answer left, right = 1, 1000 result = -1 def can_reach_with_max_danger(max_danger): visited = [False] * (n + 1) pq = [(0, s)] # (current max danger on the path, current node) heapq.heapify(pq) while pq: current_danger, node = heapq.heappop(pq) if node == t: return True if visited[node]: continue visited[node] = True for neighbor, danger in graph[node]: if not visited[neighbor] and danger <= max_danger: heapq.heappush(pq, (max(danger, current_danger), neighbor)) return False while left <= right: mid = (left + right) // 2 if can_reach_with_max_danger(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def process_transactions(n: int, m: int, transactions: List[str]) -> List[int]: Process a sequence of transactions for warehouse inventory management. Parameters: - n (int): The number of distinct items in the warehouse. - m (int): The number of transactions to process. - transactions (List[str]): A list of transaction strings. Returns: - List[int]: A list of results for the query transactions. >>> process_transactions(5, 10, [\\"+ 1 10\\", \\"+ 2 5\\", \\"- 1 3\\", \\"? 1\\", \\"? 2\\", \\"- 2 10\\", \\"? 2\\", \\"+ 3 20\\", \\"+ 3 10\\", \\"? 3\\"]) [7, 5, 0, 30] >>> process_transactions(1, 5, [\\"+ 1 1000000000\\", \\"- 1 999999999\\", \\"? 1\\", \\"- 1 2\\", \\"? 1\\"]) [1, 0] >>> process_transactions(3, 7, [\\"+ 1 5\\", \\"+ 2 3\\", \\"+ 3 8\\", \\"- 1 2\\", \\"? 1\\", \\"? 2\\", \\"? 3\\"]) [3, 3, 8] >>> process_transactions(3, 8, [\\"+ 1 10\\", \\"+ 2 20\\", \\"+ 2 10\\", \\"+ 3 5\\", \\"? 2\\", \\"? 3\\", \\"- 2 5\\", \\"? 2\\"]) [30, 5, 25] >>> process_transactions(1, 3, [\\"+ 1 10\\", \\"- 1 15\\", \\"? 1\\"]) [0] >>> process_transactions(1, 1, [\\"? 1\\"]) [0] >>> process_transactions(1, 4, [\\"+ 1 10\\", \\"+ 1 20\\", \\"+ 1 30\\", \\"? 1\\"]) [60]","solution":"def process_transactions(n, m, transactions): inventory = [0] * (n + 1) results = [] for transaction in transactions: parts = transaction.split() op = parts[0] i = int(parts[1]) if op == '+': k = int(parts[2]) inventory[i] += k elif op == '-': k = int(parts[2]) inventory[i] = max(inventory[i] - k, 0) elif op == '?': results.append(inventory[i]) return results"},{"question":"def max_non_overlapping_sessions(n: int, intervals: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping intervals. :param n: Number of students (intervals) :param intervals: List of tuples where each tuple contains two integers representing the start and end time of intervals :return: Maximum number of non-overlapping intervals Example: >>> max_non_overlapping_sessions(5, [(1, 3), (2, 4), (3, 5), (7, 8), (5, 6)]) 3 >>> max_non_overlapping_sessions(0, []) 0 >>> max_non_overlapping_sessions(4, [(1, 10), (2, 9), (3, 8), (4, 7)]) 1 >>> max_non_overlapping_sessions(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_sessions(4, [(1, 5), (2, 3), (4, 6), (7, 8)]) 3 >>> max_non_overlapping_sessions(1, [(1, 2)]) 1","solution":"def max_non_overlapping_sessions(n, intervals): Finds the maximum number of non-overlapping intervals. :param n: Number of students (intervals) :param intervals: List of tuples where each tuple contains two integers representing the start and end time of intervals :return: Maximum number of non-overlapping intervals # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) # Initializing the end time of last added interval to negative infinity last_end_time = -1 count = 0 for start, end in intervals: if start > last_end_time: count += 1 last_end_time = end return count"},{"question":"def count_mountains_and_valleys(n: int, heights: List[int]) -> Tuple[int, int]: Given an array of heights, find the number of mountains and valleys. A mountain is a sequence that first strictly increases and then strictly decreases. A valley is a sequence that first strictly decreases and then strictly increases. >>> count_mountains_and_valleys(8, [1, 2, 3, 5, 4, 3, 1, 2]) (1, 1) >>> count_mountains_and_valleys(7, [4, 3, 2, 1, 2, 3, 4]) (0, 1) >>> count_mountains_and_valleys(5, [1, 2, 3, 4, 5]) (0, 0) >>> count_mountains_and_valleys(5, [5, 4, 3, 2, 1]) (0, 0) >>> count_mountains_and_valleys(6, [1, 2, 3, 4, 3, 2]) (1, 0) >>> count_mountains_and_valleys(6, [4, 3, 2, 3, 4, 5]) (0, 1) >>> count_mountains_and_valleys(10, [1, 2, 3, 2, 1, 3, 4, 3, 2, 1]) (2, 1) >>> count_mountains_and_valleys(4, [1, 1, 1, 1]) (0, 0)","solution":"def count_mountains_and_valleys(n, heights): mountains = 0 valleys = 0 for i in range(1, n - 1): if heights[i - 1] < heights[i] > heights[i + 1]: mountains += 1 elif heights[i - 1] > heights[i] < heights[i + 1]: valleys += 1 return mountains, valleys"},{"question":"def is_rotated_version(s1: str, s2: str) -> str: Determines if s1 is a rotated version of s2. >>> is_rotated_version(\\"abcde\\", \\"cdeab\\") \\"YES\\" >>> is_rotated_version(\\"abc\\", \\"def\\") \\"NO\\"","solution":"def is_rotated_version(s1, s2): Determines if s1 is a rotated version of s2. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s1 is a rotated version of s2, otherwise \\"NO\\". if len(s1) != len(s2): return \\"NO\\" combined = s2 + s2 if s1 in combined: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def game_night(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if there exists a combination of four sticks that can form a quadrilateral with a given perimeter for each test case. Args: t (int): Number of test cases test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing: - n (int): Number of sticks - target (int): Target perimeter - sticks (List[int]): Lengths of the sticks Returns: List[str]: List of results (\\"YES\\" or \\"NO\\") for each test case >>> game_night(3, [ ... (5, 10, [1, 2, 3, 4, 5]), ... (4, 4, [1, 1, 1, 1]), ... (6, 15, [3, 4, 5, 6, 7, 8]) ... ]) ['YES', 'YES', 'NO'] >>> game_night(1, [ ... (5, 12, [2, 2, 3, 4, 5]) ... ]) ['YES'] pass","solution":"from itertools import combinations def can_form_quadrilateral(sticks, target): Determine if there exist any four sticks that can form a quadrilateral with a given perimeter. for comb in combinations(sticks, 4): if sum(comb) == target: a, b, c, d = sorted(comb) if a + b + c > d: return \\"YES\\" return \\"NO\\" def game_night(t, test_cases): results = [] for i in range(t): n, target, sticks = test_cases[i] result = can_form_quadrilateral(sticks, target) results.append(result) return results"},{"question":"def max_activities_attended_by_employees(n: int, m: int, capacities: List[int], preferences: List[List[int]]) -> int: Determine the maximum number of different activities that can be attended by employees. :param n: Number of employees :param m: Number of activities :param capacities: List of capacities of the activities :param preferences: List of preference lists for each employee :return: Maximum number of different activities that can be attended >>> max_activities_attended_by_employees(4, 3, [1, 2, 2], [[1, 2, 3], [], [1, 3], [2]]) 3 >>> max_activities_attended_by_employees(5, 5, [1, 1, 1, 1, 1], [[1, 2], [1, 2], [3], [4, 5], [5]]) 5 >>> max_activities_attended_by_employees(3, 3, [1, 1, 1], [[1], [1], [1]]) 1 >>> max_activities_attended_by_employees(4, 2, [2, 2], [[1, 2], [1], [2], [1, 2]]) 2 >>> max_activities_attended_by_employees(4, 2, [1, 1], [[1], [1, 2], [2], []]) 2","solution":"def max_activities_attended_by_employees(n, m, capacities, preferences): activity_count = [0] * (m + 1) assignments = [-1] * n for i in range(n): for preference in preferences[i]: if activity_count[preference] < capacities[preference - 1]: activity_count[preference] += 1 assignments[i] = preference break unique_activities = set(assignments) - {-1} return len(unique_activities)"},{"question":"def calculate_final_scores(n: int, m: int, submissions: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determine the final scores of participants in a competition. Args: n (int): Number of participants. m (int): Number of submissions. submissions (List[Tuple[int, int]]): Each tuple contains participant's ID and their score for a submission. Returns: List[Tuple[int, int]]: Final scoreboard in descending order of scores. If scores are the same, sorted by participant IDs. >>> calculate_final_scores(4, 6, [(1, 50), (2, 30), (3, 30), (2, 40), (3, 50), (4, 60)]) [(4, 60), (1, 50), (3, 50), (2, 40)] >>> calculate_final_scores(1, 3, [(1, 50), (1, 20), (1, 70)]) [(1, 70)] >>> calculate_final_scores(2, 0, []) [] >>> calculate_final_scores(3, 6, [(1, 30), (2, 30), (3, 30), (1, 30), (2, 30), (3, 30)]) [(1, 30), (2, 30), (3, 30)] >>> calculate_final_scores(5, 7, [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (1, 15), (1, 5)]) [(5, 50), (4, 40), (3, 30), (2, 20), (1, 15)]","solution":"def calculate_final_scores(n, m, submissions): from collections import defaultdict participants_scores = defaultdict(int) for p, s in submissions: if s > participants_scores[p]: participants_scores[p] = s sorted_scores = sorted(participants_scores.items(), key=lambda x: (-x[1], x[0])) return sorted_scores"},{"question":"def min_operations(n: int, k: int, binary_str: str) -> int: Returns the minimum number of operations needed to make all characters in the binary string the same. >>> min_operations(5, 1, \\"11001\\") 1 >>> min_operations(4, 2, \\"1111\\") 0 >>> min_operations(5, 5, \\"11100\\") 2 >>> min_operations(5, 0, \\"11100\\") 0 >>> min_operations(4, 2, \\"0000\\") 0 >>> min_operations(7, 3, \\"1001101\\") 3 >>> min_operations(1, 0, \\"0\\") 0 >>> min_operations(1, 1, \\"1\\") 0","solution":"def min_operations(n, k, binary_str): Returns the minimum number of operations needed to make all characters in the binary string the same. # Count the number of '0's and '1's in the string count_0s = binary_str.count('0') count_1s = binary_str.count('1') # The minimum number of operations needed is the smaller of the two counts min_operations_needed = min(count_0s, count_1s) # Return the minimum of the calculated operations needed and the allowed maximum k return min(min_operations_needed, k)"},{"question":"from typing import List, Tuple def count_removals(flower_heights: List[int], queries: List[int]) -> List[Tuple[int, int]]: Determine the minimum number of flowers to be removed for each query. Args: flower_heights (List[int]): A list of integers representing flower heights in each flower bed. queries (List[int]): A list of integers representing the value used to determine the weeding strategy. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers: - The minimum number of flowers to be removed by the first strategy. - The minimum number of flowers to be removed by the second strategy. >>> count_removals([5, 10, 15, 20, 25], [10, 15, 25]) [(4, 2), (3, 3), (1, 5)] >>> count_removals([1, 2, 3, 4, 5], [6]) [(0, 5)] >>> count_removals([6, 7, 8, 9, 10], [5]) [(5, 0)] >>> count_removals([1000000000], [1000000000]) [(1, 1)] >>> count_removals(list(range(1, 100001)), [50000, 100000, 1]) [(50001, 50000), (1, 100000), (100000, 1)]","solution":"def count_removals(flower_heights, queries): flower_heights.sort() n = len(flower_heights) results = [] for h in queries: idx_ge = next((i for i, height in enumerate(flower_heights) if height >= h), n) idx_le = next((i for i, height in enumerate(flower_heights) if height > h), n) remove_ge = n - idx_ge # number of elements >= h remove_le = idx_le # number of elements <= h results.append((remove_ge, remove_le)) return results"},{"question":"def max_sum_contiguous_subarray(n: int, excitement_levels: List[int]) -> int: Finds the sum of the maximum sum contiguous subarray with non-negative sum. If all excitement levels are negative, returns 0. >>> max_sum_contiguous_subarray(6, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_sum_contiguous_subarray(5, [-2, -3, -4, -1, -5]) 0 pass def test_example_case(): assert max_sum_contiguous_subarray(6, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_all_negative(): assert max_sum_contiguous_subarray(5, [-2, -3, -4, -1, -5]) == 0 assert max_sum_contiguous_subarray(3, [-1, -1, -1]) == 0 def test_all_positive(): assert max_sum_contiguous_subarray(5, [1, 2, 3, 4, 5]) == 15 assert max_sum_contiguous_subarray(3, [10, 20, 30]) == 60 def test_mix_of_positive_and_negative(): assert max_sum_contiguous_subarray(5, [-1, 2, 3, -4, 5]) == 6 assert max_sum_contiguous_subarray(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_sum_contiguous_subarray(7, [5, -2, -1, 2, 3, -4, 4]) == 7 def test_single_element(): assert max_sum_contiguous_subarray(1, [-1]) == 0 assert max_sum_contiguous_subarray(1, [10]) == 10","solution":"def max_sum_contiguous_subarray(n, excitement_levels): Finds the sum of the maximum sum contiguous subarray with non-negative sum. If all excitement levels are negative, returns 0. max_sum = 0 current_sum = 0 for excitement in excitement_levels: current_sum += excitement if current_sum < 0: current_sum = 0 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def preprocess_prefix_sums(arr: List[int]) -> List[int]: Preprocess the array into a prefix sum array. >>> preprocess_prefix_sums([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] def sum_subarray(prefix_sums: List[int], l: int, r: int) -> int: Calculate the sum of the subarray using the prefix sums array. The indices l and r are 1-based and inclusive. >>> sum_subarray([0, 1, 3, 6, 10, 15], 1, 3) == 6 >>> sum_subarray([0, 1, 3, 6, 10, 15], 2, 4) == 9 >>> sum_subarray([0, 1, 3, 6, 10, 15], 1, 5) == 15 def process_queries(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process the queries to calculate the sum of the elements in the specified subarrays. >>> process_queries(5, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) == [6, 9, 15]","solution":"def preprocess_prefix_sums(arr): Preprocess the array into a prefix sum array. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] return prefix_sums def sum_subarray(prefix_sums, l, r): Calculate the sum of the subarray using the prefix sums array. The indices l and r are 1-based and inclusive. return prefix_sums[r] - prefix_sums[l - 1] def process_queries(n, arr, queries): prefix_sums = preprocess_prefix_sums(arr) results = [] for l, r in queries: results.append(sum_subarray(prefix_sums, l, r)) return results"},{"question":"from typing import List def day_with_largest_temp_difference(temperatures: List[List[int]]) -> int: Returns the index of the day with the largest temperature difference. >>> temperatures = [ ... [10, 20, 13, 15, 16, 17, 18, 11, 12, 22, 23, 11, 15, 13, 14, 18, 17, 20, 19, 16, 15, 14, 15, 16], ... [12, 14, 16, 17, 19, 13, 15, 14, 20, 22, 24, 25, 14, 13, 12, 19, 18, 17, 16, 20, 21, 22, 23, 24], ... [13, 15, 14, 18, 16, 19, 17, 15, 23, 24, 22, 21, 19, 18, 20, 19, 17, 18, 17, 21, 20, 19, 18, 22], ... [15, 18, 19, 20, 21, 22, 23, 17, 18, 20, 21, 23, 22, 21, 20, 19, 18, 15, 14, 13, 12, 11, 10, 12], ... [11, 13, 15, 17, 19, 21, 12, 14, 16, 18, 20, 22, 14, 16, 17, 19, 21, 15, 18, 20, 22, 24, 23, 21], ... [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10], ... [10, 15, 20, 25, 30, 35, 40, 45, 16, 15, 20, 25, 20, 15, 18, 19, 23, 21, 20, 18, 17, 16, 19, 20] ... ] >>> day_with_largest_temp_difference(temperatures) 6","solution":"def day_with_largest_temp_difference(temperatures): Returns the index of the day with the largest temperature difference. largest_difference = float('-inf') index_of_day_with_largest_diff = 0 for i, day_temps in enumerate(temperatures): max_temp = max(day_temps) min_temp = min(day_temps) temp_difference = max_temp - min_temp if temp_difference > largest_difference: largest_difference = temp_difference index_of_day_with_largest_diff = i return index_of_day_with_largest_diff"},{"question":"from typing import List, Tuple from collections import defaultdict def special_paths_sum(n: int, node_values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the minimum sum of node values on the special path between given pairs of nodes in a tree. Args: - n: the number of nodes in the tree - node_values: values of the nodes - edges: list of edges representing the tree - queries: list of queries where each query is a tuple of two nodes Returns: List of integers representing the minimum sum of node values for each query Examples: >>> special_paths_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)], [(1, 4), (1, 5), (3, 4)]) [7, 8, 9]","solution":"from collections import defaultdict, deque def build_tree(edges, n): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def calc_subtree_sums(tree, node_values, root): n = len(node_values) subtree_sums = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): visited[node] = True subtree_sum = node_values[node - 1] for neighbor in tree[node]: if not visited[neighbor]: subtree_sum += dfs(neighbor) subtree_sums[node] = subtree_sum return subtree_sum dfs(root) return subtree_sums def find_special_path_sum(tree, u, v, node_values, subtree_sums): if u == v: return node_values[u - 1] n = len(node_values) parent = [None] * (n + 1) level = [0] * (n + 1) def bfs(node): q = deque([node]) parent[node] = -1 visited = [False] * (n + 1) visited[node] = True while q: current = q.popleft() for neighbor in tree[current]: if not visited[neighbor]: parent[neighbor] = current level[neighbor] = level[current] + 1 visited[neighbor] = True q.append(neighbor) bfs(u) path_sum = 0 while level[u] > level[v]: path_sum += node_values[u - 1] u = parent[u] while level[v] > level[u]: path_sum += node_values[v - 1] v = parent[v] while u != v: path_sum += node_values[u - 1] + node_values[v - 1] u = parent[u] v = parent[v] path_sum += node_values[u - 1] return path_sum def special_paths_sum(n, node_values, edges, queries): tree = build_tree(edges, n) subtree_sums = calc_subtree_sums(tree, node_values, 1) results = [] for u, v in queries: results.append(find_special_path_sum(tree, u, v, node_values, subtree_sums)) return results"},{"question":"from typing import List def maximum_team_size(n: int, m: int, developers_languages: List[List[int]]) -> int: Given the number of developers and a list of known languages by each developer, determines the maximum team size where each member can communicate with at least one common language. Parameters: - n (int): Number of developers - m (int): Total number of different programming languages - developers_languages (List[List[int]]): List of languages known by each developer Returns: - int: The maximum team size or 0 if no valid team can be formed >>> maximum_team_size(4, 5, [[1, 2], [2, 3, 4], [1, 5], [2, 5]]) 3 >>> maximum_team_size(3, 3, [[1], [2], [3]]) 0 >>> maximum_team_size(3, 1, [[1], [1], [1]]) 3 >>> maximum_team_size(5, 3, [[1, 3], [2, 3], [2, 1], [2, 3], [3]]) 4 >>> maximum_team_size(5, 5, [[1], [2], [3], [4], [5]]) 0","solution":"def maximum_team_size(n, m, developers_languages): from collections import defaultdict # Create a dictionary to map each language to the set of developers that know it language_to_developers = defaultdict(set) for developer_id, languages in enumerate(developers_languages, start=1): for language in languages: language_to_developers[language].add(developer_id) max_team_size = 0 # Check the size of the team for each language and update the maximum size found for developers in language_to_developers.values(): max_team_size = max(max_team_size, len(developers)) return max_team_size if max_team_size >= 2 else 0"},{"question":"def can_collect_waste(grid): Determine if the waste collection truck can reach the bottom-right corner of the grid starting from the top-left corner following the movement restrictions. The truck can only move right or down, and can only move into a cell if the amount of waste in the current cell is greater than or equal to the waste in the next cell. >>> can_collect_waste([ ... [8, 5, 3], ... [4, 3, 2], ... [2, 1, 0] ... ]) 'YES' >>> can_collect_waste([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) 'NO'","solution":"def can_collect_waste(grid): n = len(grid) def is_valid(x, y, prev_waste): return (0 <= x < n and 0 <= y < n and grid[x][y] <= prev_waste) def dfs(x, y, prev_waste): if x == n-1 and y == n-1: return True if not is_valid(x, y, prev_waste): return False # Move right if y+1 < n and is_valid(x, y+1, grid[x][y]): if dfs(x, y+1, grid[x][y]): return True # Move down if x+1 < n and is_valid(x+1, y, grid[x][y]): if dfs(x+1, y, grid[x][y]): return True return False return \\"YES\\" if dfs(0, 0, grid[0][0]) else \\"NO\\" # Example usage: input_grid = [ [8, 5, 3], [4, 3, 2], [2, 1, 0] ] print(can_collect_waste(input_grid)) # Output: YES"},{"question":"def find_minimum_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determines the minimized total travel time required to connect all the monuments. Args: n : int : number of monuments m : int : number of roads roads : List[Tuple[int, int, int]] : list of roads where each road is represented as a tuple (u, v, w) Returns: int : the minimized total travel time to connect all monuments or -1 if not all monuments can be connected Example: >>> find_minimum_travel_time(4, 5, [(1, 2, 1), (1, 3, 2), (2, 3, 3), (2, 4, 6), (3, 4, 4)]) 7 >>> find_minimum_travel_time(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 pass def test_example_case(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 3), (2, 4, 6), (3, 4, 4), ] assert find_minimum_travel_time(n, m, roads) == 7 def test_no_roads(): n = 1 m = 0 roads = [] assert find_minimum_travel_time(n, m, roads) == 0 def test_not_all_connected(): n = 4 m = 2 roads = [ (1, 2, 1), (3, 4, 2), ] assert find_minimum_travel_time(n, m, roads) == -1 def test_single_road(): n = 2 m = 1 roads = [ (1, 2, 5), ] assert find_minimum_travel_time(n, m, roads) == 5 def test_large_case(): n = 3 m = 3 roads = [ (1, 2, 10), (2, 3, 15), (1, 3, 7), ] assert find_minimum_travel_time(n, m, roads) == 17 def test_disconnected_graph(): n = 6 m = 5 roads = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (1, 6, 8) ] assert find_minimum_travel_time(n, m, roads) == 25 if __name__ == \\"__main__\\": test_example_case() test_no_roads() test_not_all_connected() test_single_road() test_large_case() test_disconnected_graph() print(\\"All tests passed.\\")","solution":"def find_minimum_travel_time(n, m, roads): Finds the minimum total travel time required to connect all the monuments using the Kruskal's algorithm for Minimum Spanning Tree. parent = list(range(n+1)) def find(x): if x != parent[x]: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY # Sort roads based on their weights roads.sort(key=lambda x: x[2]) mst_weight = 0 edges_used = 0 for u, v, w in roads: if find(u) != find(v): union(u, v) mst_weight += w edges_used += 1 if edges_used == n - 1: break # Check if all nodes are connected root = find(1) for i in range(1, n+1): if find(i) != root: return -1 return mst_weight # Sample usage if __name__ == \\"__main__\\": n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 3), (2, 4, 6), (3, 4, 4), ] print(find_minimum_travel_time(n, m, roads)) # Output should be 7"},{"question":"def longest_word_occurrences(k: int, text: str) -> str: Identifies the longest word that appears at least k times, or the lexicographically smallest one if there are ties in length. Parameters: k (int): Minimum number of appearances a word must have. text (str): The input text as a string. Returns: str: The longest word appearing at least k times, or the lexicographically smallest in case of ties. pass # Unit tests def test_no_word(): assert longest_word_occurrences(2, \\"a quick brown fox jumps over the lazy dog\\") == \\"No word\\" def test_single_word(): assert longest_word_occurrences(1, \\"hello world\\") == \\"hello\\" def test_example_1(): text = \\"this is a test this is only a test this is a test for finding the longest test\\" assert longest_word_occurrences(3, text) == \\"test\\" def test_example_2(): text = \\"the quick brown fox jumps over the lazy dog and the dog was not lazy at all\\" assert longest_word_occurrences(2, text) == \\"lazy\\" def test_ties_in_length(): text = \\"a a b b c c d d e e\\" assert longest_word_occurrences(2, text) == \\"a\\" def test_mixed_lengths(): text = \\"aa aa bb bb cc cc\\" assert longest_word_occurrences(2, text) == \\"aa\\" def test_larger_input(): text = \\"word \\" * 1000 + \\"another \\" * 999 assert longest_word_occurrences(1000, text) == \\"word\\"","solution":"def longest_word_occurrences(k, text): Identifies the longest word that appears at least k times, or the lexicographically smallest one if there are ties in length. Parameters: k (int): Minimum number of appearances a word must have. text (str): The input text as a string. Returns: str: The longest word appearing at least k times, or the lexicographically smallest in case of ties. from collections import Counter words = text.split() count = Counter(words) candidates = [word for word, freq in count.items() if freq >= k] if not candidates: return \\"No word\\" candidates.sort(key=lambda x: (-len(x), x)) return candidates[0]"},{"question":"from typing import List def is_possible_lights(n: int, m: int, k: int, initial_states: List[int], buttons: List[List[int]]) -> str: Determines if it is possible to have exactly k bulbs turned ON. Args: n : int : the number of rooms m : int : the number of buttons k : int : the required number of bulbs to be ON initial_states : List[int] : the initial state of each bulb (0 for OFF, 1 for ON) buttons : List[List[int]] : the indices of the bulbs that each button controls Returns: str : \\"YES\\" if it's possible to achieve exactly k bulbs turned ON, otherwise \\"NO\\" Example: >>> n = 5 >>> m = 3 >>> k = 3 >>> initial_states = [0, 1, 0, 1, 0] >>> buttons = [ ... [1, 2, 3], ... [4, 5], ... [2, 3, 4] ... ] >>> is_possible_lights(n, m, k, initial_states, buttons) \\"YES\\" >>> n = 4 >>> m = 0 >>> k = 3 >>> initial_states = [0, 1, 0, 1, 0] >>> buttons = [] >>> is_possible_lights(n, m, k, initial_states, buttons) \\"NO\\" >>> n = 4 >>> m = 1 >>> k = 2 >>> initial_states = [1, 1, 0, 0] >>> buttons = [ ... [1, 2, 3] ... ] >>> is_possible_lights(n, m, k, initial_states, buttons) \\"YES\\" >>> n = 4 >>> m = 2 >>> k = 3 >>> initial_states = [0, 0, 0, 0] >>> buttons = [ ... [1, 2], ... [3, 4] ... ] >>> is_possible_lights(n, m, k, initial_states, buttons) \\"NO\\" >>> n = 3 >>> m = 1 >>> k = 0 >>> initial_states = [0, 0, 0] >>> buttons = [ ... [1, 2, 3] ... ] >>> is_possible_lights(n, m, k, initial_states, buttons) \\"YES\\"","solution":"def is_possible_lights(n, m, k, initial_states, buttons): Determines if it is possible to have exactly k bulbs turned ON. from itertools import combinations # Count the initial number of bulbs that are ON initial_on_count = sum(initial_states) # Calculate the impact of each button (number of bulbs it affects) button_impacts = [] for button in buttons: impact = 0 for bulb in button: if initial_states[bulb - 1] == 1: impact -= 1 else: impact += 1 button_impacts.append(impact) # Check if it is possible to reach exactly k ON bulbs impacts = button_impacts[:] for i in range(1, m + 1): for combination in combinations(button_impacts, i): current_sum = initial_on_count + sum(combination) if current_sum == k: return \\"YES\\" if initial_on_count == k: return \\"YES\\" return \\"NO\\" # Example usage: n = 5 m = 3 k = 3 initial_states = [0, 1, 0, 1, 0] buttons = [ [1, 2, 3], [4, 5], [2, 3, 4] ] print(is_possible_lights(n, m, k, initial_states, buttons)) # Output should be \\"YES\\""},{"question":"from typing import List def min_operations_to_transform(s: str, t: str) -> int: Determine the minimum number of operations required to transform string s into string t. This problem is a classic example of the edit distance problem. def process_input(q: int, cases: List[str]) -> List[int]: Processes the input and returns a list of results for the given test cases. >>> process_input(2, [\\"abcdef\\", \\"azced\\", \\"cat\\", \\"cut\\"]) == [3, 1] >>> process_input(1, [\\"kitten\\", \\"sitting\\"]) == [3] >>> process_input(3, [\\"\\", \\"a\\", \\"a\\", \\"\\", \\"abc\\", \\"abc\\"]) == [1, 1, 0] results = [] for i in range(q): s = cases[2 * i] t = cases[2 * i + 1] results.append(min_operations_to_transform(s, t)) return results","solution":"def min_operations_to_transform(s, t): Determine the minimum number of operations required to transform string s into string t. This problem is a classic example of the edit distance problem. m, n = len(s), len(t) # Create a dp table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of t elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of s elif s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are same, ignore last char else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n] def process_input(q, cases): results = [] for i in range(q): s = cases[2 * i] t = cases[2 * i + 1] results.append(min_operations_to_transform(s, t)) return results"},{"question":"from typing import List def assign_food(friends_food: List[str]) -> List[str]: Determine if it is possible to assign unique food items to friends. Each friend is willing to bring a list of food items. Return \\"YES\\" followed by each friend's name and their assigned food if possible, otherwise return \\"NO\\". >>> assign_food([\\"apple,banana,grape\\", \\"banana,orange\\", \\"apple,orange,grape\\"]) [\\"YES\\", \\"1 grape\\", \\"2 banana\\", \\"3 apple\\"] >>> assign_food([\\"apple,banana\\", \\"banana\\", \\"apple\\"]) [\\"NO\\"] >>> assign_food([\\"apple\\"]) [\\"YES\\", \\"1 apple\\"] >>> assign_food([\\"food1\\", \\"food2\\", \\"food3\\"]) [\\"YES\\", \\"1 food1\\", \\"2 food2\\", \\"3 food3\\"] >>> assign_food([\\"pizza\\", \\"pizza\\", \\"pizza\\"]) [\\"NO\\"]","solution":"def assign_food(friends_food): from collections import defaultdict n = len(friends_food) food_to_friend = {} # To store the food items that each friend can bring in an associative list friend_possible_food = defaultdict(list) for friend_index, food_list in enumerate(friends_food): for food_item in food_list.split(','): friend_possible_food[friend_index].append(food_item) assigned_food = set() # Using a recursive function to try to assign food items def assign(index): if index == n: return True for food in friend_possible_food[index]: if food not in assigned_food: assigned_food.add(food) food_to_friend[index] = food if assign(index + 1): return True assigned_food.remove(food) return False if assign(0): result = [\\"YES\\"] for i in range(n): result.append(f\\"{i+1} {food_to_friend[i]}\\") return result else: return [\\"NO\\"]"},{"question":"def largest_number_of_groups_with_equal_weight(n: int, weights: List[int]) -> int: Given a collection of n stones with distinct weights, find the largest number of groups that can have the same total weight if the stones are divided optimally. >>> largest_number_of_groups_with_equal_weight(1, [1]) 1 >>> largest_number_of_groups_with_equal_weight(4, [1, 2, 3, 4]) 2 >>> largest_number_of_groups_with_equal_weight(5, [1, 2, 3, 4, 5]) 3 >>> largest_number_of_groups_with_equal_weight(3, [3, 3, 3]) 3 >>> largest_number_of_groups_with_equal_weight(2, [1, 2]) 1","solution":"from itertools import combinations def largest_number_of_groups_with_equal_weight(n, weights): weights_sum = sum(weights) max_groups = 1 # Try every possible number of groups from n down to 1 for i in range(n, 0, -1): # If weights_sum is divisible by the number of groups if weights_sum % i == 0: target_group_weight = weights_sum // i group_sums = [0] * i weights_sorted = sorted(weights, reverse=True) def can_form_groups(index): if index == n: return all(group_sum == target_group_weight for group_sum in group_sums) for j in range(i): if group_sums[j] + weights_sorted[index] <= target_group_weight: group_sums[j] += weights_sorted[index] if can_form_groups(index + 1): return True group_sums[j] -= weights_sorted[index] if group_sums[j] == 0: break return False if can_form_groups(0): max_groups = i break return max_groups"},{"question":"def is_prime(num: int) -> bool: Checks if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(29) True >>> is_prime(25) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-1) False pass def next_prime(N: int) -> int: Returns the smallest prime number greater than N. >>> next_prime(1) 2 >>> next_prime(2) 3 >>> next_prime(3) 5 >>> next_prime(14) 17 >>> next_prime(100) 101 >>> next_prime(997) 1009 >>> next_prime(1000000) 1000003 pass","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(N): Returns the smallest prime number greater than N. candidate = N + 1 while True: if is_prime(candidate): return candidate candidate += 1"},{"question":"def longest_contiguous_ones(n: int, binary_string: str) -> int: Returns the length of the longest contiguous subsequence of '1's that can be obtained by replacing at most one '0' with a '1'. >>> longest_contiguous_ones(5, \\"11010\\") 4 >>> longest_contiguous_ones(6, \\"111101\\") 6 >>> longest_contiguous_ones(1, \\"0\\") 1 >>> longest_contiguous_ones(10, \\"0000000000\\") 1 >>> longest_contiguous_ones(7, \\"1000001\\") 2 >>> longest_contiguous_ones(8, \\"11101111\\") 8 >>> longest_contiguous_ones(5, \\"11111\\") 5","solution":"def longest_contiguous_ones(n, binary_string): Returns the length of the longest contiguous subsequence of '1's that can be obtained by replacing at most one '0' with a '1'. max_one_side = 0 left = right = 0 zero_count = 0 while right < n: if binary_string[right] == '0': zero_count += 1 while zero_count > 1: if binary_string[left] == '0': zero_count -= 1 left += 1 max_one_side = max(max_one_side, right - left + 1) right += 1 return max_one_side"},{"question":"def smallest_integer_greater_than_x(n: int, x: int, array: List[int]) -> int: Finds the smallest integer in the array that is greater than a given integer x. If no such integer exists, returns -1. :param n: int - size of the array :param x: int - the integer to compare against :param array: list[int] - the list of integers :return: int - smallest integer in array greater than x or -1 if no such integer exists >>> smallest_integer_greater_than_x(6, 7, [1, 3, 5, 8, 12, 14]) 8 >>> smallest_integer_greater_than_x(5, 15, [2, 4, 6, 8, 10]) -1","solution":"def smallest_integer_greater_than_x(n, x, array): Finds the smallest integer in the array that is greater than a given integer x. If no such integer exists, returns -1. :param n: int - size of the array :param x: int - the integer to compare against :param array: list[int] - the list of integers :return: int - smallest integer in array greater than x or -1 if no such integer exists min_greater = float('inf') for num in array: if num > x and num < min_greater: min_greater = num return min_greater if min_greater != float('inf') else -1"},{"question":"def adjust_temperatures(n: int, m: int, k: int, grid: List[List[int]], adjustments: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: Applies a series of temperature adjustments to a grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of adjustments. grid (List[List[int]]): The initial temperature grid. adjustments (List[Tuple[int, int, int, int, int]]): A list of adjustments specifying rows, columns and value to add. >>> adjust_temperatures(3, 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1, 2, 2, 1), (2, 2, 3, 3, 2)]) [[2, 3, 3], [5, 8, 8], [7, 10, 11]] >>> adjust_temperatures(2, 2, 1, [[0, 0], [0, 0]], [(1, 1, 1, 1, 5)]) [[5, 0], [0, 0]] >>> adjust_temperatures(3, 3, 1, [[1, 1, 1], [1, 1, 1], [1, 1, 1]], [(1, 1, 3, 3, 2)]) [[3, 3, 3], [3, 3, 3], [3, 3, 3]] >>> adjust_temperatures(4, 4, 2, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], [(1, 1, 2, 2, 1), (2, 2, 4, 4, 3)]) [[2, 3, 3, 4], [6, 10, 10, 11], [9, 13, 14, 15], [13, 17, 18, 19]] >>> adjust_temperatures(2, 2, 0, [[8, 7], [6, 5]], []) [[8, 7], [6, 5]] pass","solution":"def adjust_temperatures(n, m, k, grid, adjustments): for adjustment in adjustments: r1, c1, r2, c2, t = adjustment for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): grid[i][j] += t return grid # Example usage: n = 3 m = 3 k = 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] adjustments = [ (1, 1, 2, 2, 1), (2, 2, 3, 3, 2) ] adjusted_grid = adjust_temperatures(n, m, k, grid, adjustments) for row in adjusted_grid: print(' '.join(map(str, row)))"},{"question":"def find_threshold(n: int, k: int, scores: List[int]) -> int: Returns the score threshold for prize eligibility. Parameters: n (int): Number of participants. k (int): Number of prizes. scores (list): List of scores. Returns: int: The score threshold. # Test cases def test_given_example(): assert find_threshold(7, 3, [10, 20, 20, 30, 30, 40, 50]) == 30 def test_all_same_scores(): assert find_threshold(5, 2, [50, 50, 50, 50, 50]) == 50 def test_all_unique_scores(): assert find_threshold(6, 3, [1, 2, 3, 4, 5, 6]) == 4 def test_edge_case_minimum_n_and_k(): assert find_threshold(1, 1, [1000]) == 1000 def test_large_input(): n = 100000 k = 50000 scores = list(range(1000000, 900000, -1)) assert find_threshold(n, k, scores) == 950001","solution":"def find_threshold(n, k, scores): Returns the score threshold for prize eligibility. Parameters: n (int): Number of participants. k (int): Number of prizes. scores (list): List of scores. Returns: int: The score threshold. scores.sort(reverse=True) return scores[k-1]"},{"question":"def player_effectiveness(n: int, points: List[int], m: int, player_teams: List[int]) -> List[int]: Determine the total effectiveness for each player based on the points of the teams they belong to. :param n: Number of teams :param points: List of points earned by each team :param m: Number of players :param player_teams: List of team numbers each player belongs to :return: List of effectiveness values for each player Example: >>> player_effectiveness(4, [10, 20, 30, 40], 5, [1, 2, 3, 4, 2]) [10, 20, 30, 40, 20] >>> player_effectiveness(1, [50], 3, [1, 1, 1]) [50, 50, 50] >>> player_effectiveness(3, [15, 25, 35], 3, [1, 2, 3]) [15, 25, 35] >>> player_effectiveness(2, [100, 200], 4, [1, 2, 1, 2]) [100, 200, 100, 200]","solution":"def player_effectiveness(n, points, m, player_teams): This function computes the effectiveness of players based on the points of the teams they belong to. team_points = [0] * n for i in range(n): team_points[i] = points[i] effectiveness = [0] * m for i in range(m): team_idx = player_teams[i] - 1 effectiveness[i] = team_points[team_idx] return effectiveness"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"aaab\\") \\"NO\\" >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"civil\\") \\"NO\\" >>> can_form_palindrome(\\"livci\\") \\"NO\\" def palindrome_rearrangement_test_cases(k: int, strings: List[str]) -> List[str]: Determines if each string in a list of strings can be rearranged to form a palindrome. Returns a list of \\"YES\\"/\\"NO\\" for each string. >>> palindrome_rearrangement_test_cases(3, [\\"aabb\\", \\"aaab\\", \\"civic\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> palindrome_rearrangement_test_cases(2, [\\"ivicc\\", \\"civil\\"]) [\\"YES\\", \\"NO\\"] >>> palindrome_rearrangement_test_cases(1, [\\"livci\\"]) [\\"NO\\"]","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def palindrome_rearrangement_test_cases(k, strings): Takes the number of test cases and a list of strings, returns a list of results for each string. return [can_form_palindrome(s) for s in strings]"},{"question":"def min_operations_to_transform_string(s: str, k: int) -> int: Returns the minimum number of insertions or deletions required to transform the string s into a string of length k. >>> min_operations_to_transform_string('abc', 5) 2 >>> min_operations_to_transform_string('abcde', 3) 2 >>> min_operations_to_transform_string('abcd', 4) 0 def min_operations(t: int, test_cases: List[Tuple[str, int]]) -> List[int]: Returns the minimum number of insertions or deletions for multiple test cases. >>> min_operations(3, [('abc', 5), ('abcde', 3), ('abcd', 4)]) [2, 2, 0]","solution":"def min_operations_to_transform_string(s, k): Returns the minimum number of insertions or deletions required to transform the string s into a string of length k. n = len(s) if n == k: return 0 elif n < k: return k - n else: return n - k def min_operations(t, test_cases): results = [] for s, k in test_cases: results.append(min_operations_to_transform_string(s, k)) return results"},{"question":"def count_unlockable_doors(n: int, m: int, magic_codes: List[str], keys: List[str]) -> int: Given the number of doors, number of keys, the magic codes for each door, and the keys Leo possesses, returns the number of doors Leo can unlock. Parameters: n (int): Number of doors. m (int): Number of keys. magic_codes (list of str): Magic codes for each door. keys (list of str): Keys Leo possesses. Returns: int: Number of doors Leo can unlock. pass def test_count_unlockable_doors_basic(): n, m = 3, 3 magic_codes = [\\"abc\\", \\"def\\", \\"ghi\\"] keys = [\\"abcxyz\\", \\"zabcdefgh\\", \\"ghijkl\\"] assert count_unlockable_doors(n, m, magic_codes, keys) == 3 def test_count_unlockable_doors_no_unlock(): n, m = 3, 3 magic_codes = [\\"abc\\", \\"def\\", \\"ghi\\"] keys = [\\"mnopqr\\", \\"stuv\\", \\"wxyz\\"] assert count_unlockable_doors(n, m, magic_codes, keys) == 0 def test_count_unlockable_doors_some_unlock(): n, m = 4, 4 magic_codes = [\\"one\\", \\"two\\", \\"three\\", \\"four\\"] keys = [\\"onetwo\\", \\"threefour\\", \\"five\\", \\"six\\"] assert count_unlockable_doors(n, m, magic_codes, keys) == 4 def test_count_unlockable_doors_repeated_keys(): n, m = 3, 5 magic_codes = [\\"abc\\", \\"def\\", \\"ghi\\"] keys = [\\"abcabc\\", \\"defdef\\", \\"ghighijk\\", \\"abc\\", \\"def\\"] assert count_unlockable_doors(n, m, magic_codes, keys) == 3 def test_count_unlockable_doors_edge_case(): n, m = 1, 1 magic_codes = [\\"a\\"] keys = [\\"a\\"] assert count_unlockable_doors(n, m, magic_codes, keys) == 1 def test_count_unlockable_doors_none_matching(): n, m = 2, 3 magic_codes = [\\"xyz\\", \\"uvw\\"] keys = [\\"ab\\", \\"cd\\", \\"efg\\"] assert count_unlockable_doors(n, m, magic_codes, keys) == 0 def test_count_unlockable_doors_large_case(): n, m = 100, 100 magic_codes = [\\"a\\" * (i % 50 + 1) for i in range(n)] keys = [(\\"a\\" * (i % 50 + 1) + \\"b\\") for i in range(m)] assert count_unlockable_doors(n, m, magic_codes, keys) == 100","solution":"def count_unlockable_doors(n, m, magic_codes, keys): Given the number of doors, number of keys, the magic codes for each door, and the keys Leo possesses, returns the number of doors Leo can unlock. Parameters: n (int): Number of doors. m (int): Number of keys. magic_codes (list of str): Magic codes for each door. keys (list of str): Keys Leo possesses. Returns: int: Number of doors Leo can unlock. unlock_count = 0 for code in magic_codes: for key in keys: if code in key: unlock_count += 1 break return unlock_count"},{"question":"def smallest_substring_with_nucleotides(s: str, required_counts: str) -> int: Determine the length of the smallest contiguous substring that contains at least the required number of each nucleotide 'A', 'C', 'G', and 'T'. >>> smallest_substring_with_nucleotides(\\"ACGTACGTA\\", \\"1 1 1 1\\") 4 >>> smallest_substring_with_nucleotides(\\"AAGTCG\\", \\"2 1 1 1\\") 5 >>> smallest_substring_with_nucleotides(\\"CGTAG\\", \\"1 2 1 1\\") -1 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases to find the smallest substring length for each. >>> process_test_cases(3, [\\"ACGTACGTA\\", \\"1 1 1 1\\", \\"AAGTCG\\", \\"2 1 1 1\\", \\"CGTAG\\", \\"1 2 1 1\\"]) [4, 5, -1] >>> process_test_cases(2, [\\"GATTACA\\", \\"1 1 1 1\\", \\"AAAA\\", \\"1 0 0 0\\"]) [6, 1] pass def test_smallest_substring_with_nucleotides(): assert smallest_substring_with_nucleotides(\\"ACGTACGTA\\", \\"1 1 1 1\\") == 4 assert smallest_substring_with_nucleotides(\\"AAGTCG\\", \\"2 1 1 1\\") == 5 assert smallest_substring_with_nucleotides(\\"CGTAG\\", \\"1 2 1 1\\") == -1 assert smallest_substring_with_nucleotides(\\"GATTACA\\", \\"1 1 1 1\\") == 6 assert smallest_substring_with_nucleotides(\\"AAAA\\", \\"1 0 0 0\\") == 1 def test_process_test_cases(): test_cases = [ \\"ACGTACGTA\\", \\"1 1 1 1\\", \\"AAGTCG\\", \\"2 1 1 1\\", \\"CGTAG\\", \\"1 2 1 1\\" ] assert process_test_cases(3, test_cases) == [4, 5, -1] test_cases = [ \\"GATTACA\\", \\"1 1 1 1\\", \\"AAAA\\", \\"1 0 0 0\\" ] assert process_test_cases(2, test_cases) == [6, 1]","solution":"def smallest_substring_with_nucleotides(s, required_counts): n = len(s) min_length = float('inf') required_a, required_c, required_g, required_t = map(int, required_counts.split()) if required_a == 0 and required_c == 0 and required_g == 0 and required_t == 0: return 0 count_a = count_c = count_g = count_t = 0 l = 0 for r in range(n): if s[r] == 'A': count_a += 1 elif s[r] == 'C': count_c += 1 elif s[r] == 'G': count_g += 1 elif s[r] == 'T': count_t += 1 while (count_a >= required_a and count_c >= required_c and count_g >= required_g and count_t >= required_t): min_length = min(min_length, r - l + 1) if s[l] == 'A': count_a -= 1 elif s[l] == 'C': count_c -= 1 elif s[l] == 'G': count_g -= 1 elif s[l] == 'T': count_t -= 1 l += 1 return min_length if min_length != float('inf') else -1 def process_test_cases(t, test_cases): results = [] for i in range(t): s = test_cases[2 * i].strip() required_counts = test_cases[2 * i + 1].strip() result = smallest_substring_with_nucleotides(s, required_counts) results.append(result) return results"},{"question":"def can_make_grid_uniform(n: int, m: int, grid: List[List[int]]) -> str: Determine if it's possible to make all elements in the grid the same by performing the subgrid rotation operation any number of times. >>> can_make_grid_uniform(3, 3, [[1, 2, 1], [2, 1, 2], [1, 2, 1]]) 'YES' >>> can_make_grid_uniform(2, 2, [[1, 2], [3, 4]]) 'NO' pass def test_example_case_1(): n = 3 m = 3 grid = [ [1, 2, 1], [2, 1, 2], [1, 2, 1] ] assert can_make_grid_uniform(n, m, grid) == \\"YES\\" def test_example_case_2(): n = 2 m = 2 grid = [ [1, 2], [3, 4] ] assert can_make_grid_uniform(n, m, grid) == \\"NO\\" def test_uniform_grid(): n = 4 m = 4 grid = [ [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5] ] assert can_make_grid_uniform(n, m, grid) == \\"YES\\" def test_one_element_grid(): n = 1 m = 1 grid = [ [1] ] assert can_make_grid_uniform(n, m, grid) == \\"YES\\" def test_all_unique_elements(): n = 3 m = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert can_make_grid_uniform(n, m, grid) == \\"NO\\" def test_large_grid_with_possible_uniformity(): n = 4 m = 4 grid = [ [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1] ] assert can_make_grid_uniform(n, m, grid) == \\"YES\\"","solution":"def can_make_grid_uniform(n, m, grid): Determine if it's possible to make all elements in the grid the same by performing the subgrid rotation operation any number of times. from collections import Counter total_elements = n * m flat_grid = [grid[i][j] for i in range(n) for j in range(m)] freq = Counter(flat_grid) max_freq = max(freq.values()) # If the most frequent element appears more than or equal to half of the # total elements in the grid, it is possible to make all elements the same if max_freq >= total_elements / 2: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def longest_alternating_subsequence(arr: List[int]) -> int: Find the length of the longest subsequence such that the difference between any two consecutive elements is either 1 or -1. >>> longest_alternating_subsequence([1, 2, 3, 4, 3, 2, 1, 2, 3]) 9 >>> longest_alternating_subsequence([1, 3, 5, 2, 1, 4, 6]) 3 >>> longest_alternating_subsequence([]) 0 >>> longest_alternating_subsequence([1]) 1 >>> longest_alternating_subsequence([1, 2]) 2 >>> longest_alternating_subsequence([1, 1]) 1 >>> longest_alternating_subsequence([3, 3, 3, 3, 3]) 1 >>> longest_alternating_subsequence(list(range(-500, 501))) 1001 >>> longest_alternating_subsequence([1, 5, 9, 13]) 1","solution":"def longest_alternating_subsequence(arr): if not arr: return 0 # Initialize lengths list with 1 n = len(arr) lengths = [1] * n for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) == 1: lengths[i] = max(lengths[i], lengths[j] + 1) return max(lengths)"},{"question":"class ArrayManipulator: def __init__(self, array): self.array = array def reverse_subarray(self, l, r): Reverse the subarray from index l to r (1-based inclusive). pass def find_max_subarray(self, l, r): Find the maximum element in the subarray from index l to r (1-based inclusive). pass def process_queries(n, queries, array): Given an array of length \`n\`, process a list of queries where each query is either: 1. Reverse the subarray from index \`l\` to \`r\` (1-based inclusive). 2. Find the maximum element in the subarray from index \`l\` to \`r\` (1-based inclusive). For each query of the second type, return the result. pass def test_reverse_and_find_max(): # Test data based on the given example n = 6 q = 5 array = [1, 3, 5, 2, 4, 6] queries = [ [1, 2, 4], [2, 1, 5], [1, 1, 6], [2, 3, 6], [2, 1, 6], ] expected_output = [5, 5, 2] output = process_queries(n, queries, array) assert output == expected_output def test_multiple_reverses(): n = 5 array = [1, 2, 3, 4, 5] queries = [ [1, 1, 3], # Reverses subarray [1, 2, 3], result: [3, 2, 1, 4, 5] [1, 2, 4], # Reverses subarray [2, 1, 4], result: [3, 4, 1, 2, 5] [2, 1, 5], # Finds max in the entire array, result: 5 ] expected_output = [5] output = process_queries(n, queries, array) assert output == expected_output def test_no_reverse(): n = 4 array = [9, 7, 5, 3] queries = [ [2, 1, 2], # Finds max in subarray [9, 7], result: 9 [2, 2, 3], # Finds max in subarray [7, 5], result: 7 [2, 3, 4], # Finds max in subarray [5, 3], result: 5 ] expected_output = [9, 7, 5] output = process_queries(n, queries, array) assert output == expected_output","solution":"class ArrayManipulator: def __init__(self, array): self.array = array def reverse_subarray(self, l, r): self.array[l-1:r] = self.array[l-1:r][::-1] def find_max_subarray(self, l, r): return max(self.array[l-1:r]) def process_queries(n, queries, array): manipulator = ArrayManipulator(array) result = [] for query in queries: if query[0] == 1: manipulator.reverse_subarray(query[1], query[2]) elif query[0] == 2: result.append(manipulator.find_max_subarray(query[1], query[2])) return result"},{"question":"def simon_wins_game(n: int, m: int, k: int, rolls: List[int]) -> str: Determine if Simon wins the game by finding a sequence of k consecutive integers in the dice rolls. :param n: Number of faces of the dice (integer) :param m: Number of times the dice is rolled (integer) :param k: Length of the consecutive sequence to find (integer) :param rolls: List of integers representing the results of the dice rolls :return: \\"YES\\" if a consecutive sequence of length k is found, \\"NO\\" otherwise >>> simon_wins_game(6, 10, 3, [4, 5, 2, 1, 2, 3, 4, 5, 6, 2]) \\"YES\\" >>> simon_wins_game(4, 7, 4, [1, 2, 3, 1, 2, 4, 1]) \\"NO\\" >>> simon_wins_game(1, 1, 1, [1]) \\"YES\\" >>> simon_wins_game(6, 6, 3, [6, 5, 4, 3, 2, 1]) \\"NO\\" >>> simon_wins_game(1000000, 1000000, 2, [i % 1000000 + 1 for i in range(1000000)]) \\"YES\\" >>> simon_wins_game(10, 10, 3, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) \\"NO\\" >>> simon_wins_game(10, 10, 3, [1, 2, 3, 1, 2, 3, 1, 2, 3, 4]) \\"YES\\" >>> simon_wins_game(10, 15, 5, [1, 2, 3, 5, 6, 7, 8, 2, 3, 4, 5, 6, 1, 4, 5]) \\"YES\\" >>> simon_wins_game(10, 15, 6, [1, 2, 3, 5, 6, 7, 8, 2, 3, 4, 5, 6, 1, 4, 5]) \\"NO\\"","solution":"def simon_wins_game(n, m, k, rolls): Determine if Simon wins the game by finding a sequence of k consecutive integers in the dice rolls. :param n: Number of faces of the dice (integer) :param m: Number of times the dice is rolled (integer) :param k: Length of the consecutive sequence to find (integer) :param rolls: List of integers representing the results of the dice rolls :return: \\"YES\\" if a consecutive sequence of length k is found, \\"NO\\" otherwise for i in range(m - k + 1): consecutive = True for j in range(1, k): if rolls[i + j] != rolls[i + j - 1] + 1: consecutive = False break if consecutive: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Union def rearrange_array(n: int, arr: List[int]) -> Union[List[int], str]: Rearranges the array so that no two adjacent elements are the same. If impossible, returns \\"IMPOSSIBLE\\". >>> rearrange_array(6, [1, 1, 1, 2, 2, 3]) [1, 2, 1, 3, 1, 2] >>> rearrange_array(3, [3, 3, 3]) \\"IMPOSSIBLE\\" pass if __name__ == \\"__main__\\": import doctest doctest.testmod() # Unit tests def test_rearrange_array(): assert rearrange_array(1, [1]) == [1] assert rearrange_array(2, [1, 2]) in ([1, 2], [2, 1]) result = rearrange_array(6, [1, 1, 1, 2, 2, 3]) for i in range(len(result) - 1): assert result[i] != result[i+1] assert rearrange_array(3, [3, 3, 3]) == \\"IMPOSSIBLE\\" result = rearrange_array(7, [1, 1, 2, 2, 3, 3, 3]) for i in range(len(result) - 1): assert result[i] != result[i+1] assert rearrange_array(5, [1, 1, 1, 1, 2]) == \\"IMPOSSIBLE\\" result = rearrange_array(5, [1, 1, 2, 2, 2]) for i in range(len(result) - 1): assert result[i] != result[i+1]","solution":"from collections import Counter import heapq def rearrange_array(n, arr): Rearranges the array so that no two adjacent elements are the same. If impossible, returns \\"IMPOSSIBLE\\". if n == 1: return arr # Count the frequency of each element freq = Counter(arr) max_freq = max(freq.values()) if max_freq > (n + 1) // 2: return \\"IMPOSSIBLE\\" # Max heap to get the most frequent elements first max_heap = [(-count, num) for num, count in freq.items()] heapq.heapify(max_heap) result = [] prev_count, prev_num = 0, None while max_heap: count, num = heapq.heappop(max_heap) result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) prev_count, prev_num = count + 1, num return result"},{"question":"def next_palindrome(N: int) -> int: Find the next palindrome number larger than N. >>> next_palindrome(123) 131 >>> next_palindrome(999) 1001 >>> next_palindrome(1234) 1331 >>> next_palindrome(1) 2 >>> next_palindrome(11) 22 >>> next_palindrome(10**6 - 1) 1000001 >>> next_palindrome(10**6) 1000001 >>> next_palindrome(999999) 1000001","solution":"def is_palindrome(num): return str(num) == str(num)[::-1] def next_palindrome(N): N += 1 while not is_palindrome(N): N += 1 return N"},{"question":"def shortest_paths(n, m, edges, q, queries): Finds the shortest path between any two cities given the roads connecting them. :param n: Number of cities :param m: Number of roads :param edges: List of tuples where each tuple is (u, v, w) representing a road between city u and v with distance w :param q: Number of queries :param queries: List of tuples where each tuple is (s, t) representing a query for the shortest path from city s to city t :return: List of shortest path lengths for each query. If no path exists, return -1 for that query. >>> n = 5 >>> m = 6 >>> edges = [(1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 1), (4, 5, 3), (1, 5, 10)] >>> q = 2 >>> queries = [(1, 3), (4, 1)] >>> shortest_paths(n, m, edges, q, queries) [3, 4] >>> n = 4 >>> m = 3 >>> edges = [(1, 2, 1), (2, 3, 2), (3, 4, 3)] >>> q = 2 >>> queries = [(1, 4), (4, 1)] >>> shortest_paths(n, m, edges, q, queries) [6, 6] >>> n = 4 >>> m = 2 >>> edges = [(1, 2, 1), (3, 4, 2)] >>> q = 2 >>> queries = [(1, 3), (2, 4)] >>> shortest_paths(n, m, edges, q, queries) [-1, -1] >>> n = 3 >>> m = 3 >>> edges = [(1, 2, 10), (2, 3, 5), (1, 3, 100)] >>> q = 2 >>> queries = [(1, 3), (2, 1)] >>> shortest_paths(n, m, edges, q, queries) [15, 10]","solution":"import heapq def dijkstra(graph, start): Uses Dijkstra's algorithm to find the shortest paths from the start node to all other nodes in the graph. Returns a dictionary with the shortest distance to each node. distance = {node: float('inf') for node in graph} distance[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distance[current_node]: continue for neighbor, weight in graph[current_node]: distance_via_current = current_distance + weight if distance_via_current < distance[neighbor]: distance[neighbor] = distance_via_current heapq.heappush(priority_queue, (distance_via_current, neighbor)) return distance def shortest_paths(n, m, edges, q, queries): Finds the shortest path between any two cities given the roads connecting them. :param n: Number of cities :param m: Number of roads :param edges: List of tuples where each tuple is (u, v, w) representing a road between city u and v with distance w :param q: Number of queries :param queries: List of tuples where each tuple is (s, t) representing a query for the shortest path from city s to city t :return: List of shortest path lengths for each query. If no path exists, return -1 for that query. # Create a graph representation using an adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for s, t in queries: distances = dijkstra(graph, s) result = distances[t] if distances[t] != float('inf') else -1 results.append(result) return results"},{"question":"def can_make_all_bits_equal(n: int, k: int, s: str) -> str: Determine if it's possible to make all bits in the string equal using the mentioned operation any number of times. Args: n : int : length of the binary string. k : int : length of the substring to be flipped. s : str : binary string. Returns: str : \\"YES\\" or \\"NO\\" depending on whether it's possible to make all bits in the string equal. >>> can_make_all_bits_equal(6, 2, \\"110011\\") \\"YES\\" >>> can_make_all_bits_equal(5, 3, \\"10101\\") \\"NO\\"","solution":"def can_make_all_bits_equal(n, k, s): Determine if it's possible to make all bits in the string equal using the mentioned operation any number of times. Args: n : int : length of the binary string. k : int : length of the substring to be flipped. s : str : binary string. Returns: str : \\"YES\\" or \\"NO\\" depending on whether it's possible to make all bits in the string equal. count_0 = s.count('0') count_1 = s.count('1') # If counts of either '0's or '1's already make the length of binary string, return YES if count_0 == n or count_1 == n: return \\"YES\\" if k % 2 == 1: return \\"YES\\" # If flip length k is odd, any configuration is possible # If flip length k is even, check if frequencies of '0's and '1's are even if count_0 % 2 == count_1 % 2: return \\"YES\\" return \\"NO\\""},{"question":"def longest_climbing_sequence_length(stickers: List[int]) -> int: Given a list of stickers, returns the length of the longest climbing sequence. A climbing sequence is defined such that for each sticker value in the sequence, it is greater than the previous one. Parameters: stickers (list of integers): List of sticker values. Returns: int: Length of the longest climbing sequence. pass # Test cases def test_example_case(): stickers = [10, 9, 2, 5, 3, 7] assert longest_climbing_sequence_length(stickers) == 2 def test_single_element(): stickers = [5] assert longest_climbing_sequence_length(stickers) == 1 def test_all_increasing(): stickers = [1, 2, 3, 4, 5, 6] assert longest_climbing_sequence_length(stickers) == 6 def test_all_decreasing(): stickers = [6, 5, 4, 3, 2, 1] assert longest_climbing_sequence_length(stickers) == 1 def test_mixed_elements(): stickers = [1, 3, 5, 4, 7] assert longest_climbing_sequence_length(stickers) == 3 def test_repeated_elements(): stickers = [2, 2, 2, 2, 2] assert longest_climbing_sequence_length(stickers) == 1 def test_large_input(): n = 10**5 stickers = list(range(n)) assert longest_climbing_sequence_length(stickers) == n","solution":"def longest_climbing_sequence_length(stickers): Given a list of stickers, returns the length of the longest climbing sequence. A climbing sequence is defined such that for each sticker value in the sequence, it is greater than the previous one. Parameters: stickers (list of integers): List of sticker values. Returns: int: Length of the longest climbing sequence. if not stickers: return 0 longest_length = 1 current_length = 1 for i in range(1, len(stickers)): if stickers[i] > stickers[i - 1]: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"def max_new_stamps(n: int, k: int, l: int, collections: List[Tuple[int, List[int], List[int]]]) -> int: Determine the maximum number of new stamps Alice can place in her collections given the available slots. >>> max_new_stamps(2, 5, 4, [(2, [5, 6], [3, 6]), (3, [4, 8, 6], [2, 4, 6])]) 5 >>> max_new_stamps(1, 3, 3, [(2, [5, 5], [1, 1])]) 0","solution":"def max_new_stamps(n, k, l, collections): total_free_slots = 0 for collection in collections: mi, slots, frees = collection for free in frees: total_free_slots += free max_new_stamps = total_free_slots // l return min(k, max_new_stamps)"},{"question":"def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of two integers a and b. >>> lcm(3, 5) 15 >>> lcm(4, 6) 12 def gcd(x: int, y: int) -> int: while y: x, y = y, x % y return x return abs(a * b) // gcd(a, b) def min_tshirts_order(S: int, L: int) -> int: Returns the minimum number of T-shirts that is divisible by both integers S and L. >>> min_tshirts_order(3, 5) 15 >>> min_tshirts_order(4, 6) 12 return lcm(S, L) def test_min_tshirts_order(): assert min_tshirts_order(3, 5) == 15, \\"Test case 1 failed\\" assert min_tshirts_order(4, 6) == 12, \\"Test case 2 failed\\" assert min_tshirts_order(1, 1) == 1, \\"Test case 3 failed\\" assert min_tshirts_order(6, 8) == 24, \\"Test case 4 failed\\" assert min_tshirts_order(7, 7) == 7, \\"Test case 5 failed\\" assert min_tshirts_order(9, 10) == 90, \\"Test case 6 failed\\" assert min_tshirts_order(15, 20) == 60, \\"Test case 7 failed\\" assert min_tshirts_order(25, 35) == 175, \\"Test case 8 failed\\" def test_lcm(): assert lcm(3, 5) == 15, \\"LCM test case 1 failed\\" assert lcm(4, 6) == 12, \\"LCM test case 2 failed\\" assert lcm(1, 1) == 1, \\"LCM test case 3 failed\\" assert lcm(6, 8) == 24, \\"LCM test case 4 failed\\" assert lcm(7, 7) == 7, \\"LCM test case 5 failed\\" assert lcm(9, 10) == 90, \\"LCM test case 6 failed\\" assert lcm(15, 20) == 60, \\"LCM test case 7 failed\\" assert lcm(25, 35) == 175, \\"LCM test case 8 failed\\"","solution":"def lcm(a, b): Returns the least common multiple (LCM) of two numbers a and b. def gcd(x, y): while y: x, y = y, x % y return x return abs(a * b) // gcd(a, b) def min_tshirts_order(S, L): Returns the minimum number of T-shirts that is divisible by both S and L. return lcm(S, L)"},{"question":"def largest_subarray_with_threshold(n: int, k: int, elevations: List[int]) -> int: Identify the largest contiguous segment of the elevation array where the difference between the maximum and minimum elevations within that segment is at most the given threshold k. >>> largest_subarray_with_threshold(7, 4, [1, 3, 2, 6, 4, 8, 5]) 4 >>> largest_subarray_with_threshold(5, 0, [2, 2, 2, 2, 2]) 5 >>> largest_subarray_with_threshold(1, 0, [8]) 1 >>> largest_subarray_with_threshold(3, 2, [5, 5, 5]) 3 >>> largest_subarray_with_threshold(6, 100, [1, 10, 20, 30, 40, 50]) 6 >>> largest_subarray_with_threshold(5, 1, [1, 10, 100, 1000, 10000]) 1 >>> largest_subarray_with_threshold(6, 4, [1, 3, 5, 7, 3, 1]) 4 >>> largest_subarray_with_threshold(7, 0, [1, 2, 3, 2, 1, 2, 3]) 1","solution":"def largest_subarray_with_threshold(n, k, elevations): from collections import deque min_deque = deque() # stores the indices of the min elements in the current window max_deque = deque() # stores the indices of the max elements in the current window max_length = 0 left = 0 for right in range(n): # maintain the max_deque while max_deque and elevations[max_deque[-1]] <= elevations[right]: max_deque.pop() max_deque.append(right) # maintain the min_deque while min_deque and elevations[min_deque[-1]] >= elevations[right]: min_deque.pop() min_deque.append(right) while elevations[max_deque[0]] - elevations[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minimum_moves_to_meet(n, mystical_string, a, b): Returns the minimum moves required for Alfie (starting at position a) and Bella (starting at position b) to meet, or -1 if they cannot meet. >>> minimum_moves_to_meet(5, \\"abcde\\", 2, 5) 3 >>> minimum_moves_to_meet(10, \\"abcdefghij\\", 1, 10) 9 >>> minimum_moves_to_meet(5, \\"abcde\\", 1, 2) 1 >>> minimum_moves_to_meet(5, \\"abcde\\", 4, 5) 1 >>> minimum_moves_to_meet(6, \\"abcdef\\", 4, 3) -1 >>> minimum_moves_to_meet(100, \\"a\\" * 50 + \\"b\\" * 50, 1, 100) 99 >>> minimum_moves_to_meet(3, \\"abc\\", 2, 3) 1 >>> minimum_moves_to_meet(2, \\"ab\\", 1, 2) 1","solution":"def minimum_moves_to_meet(n, mystical_string, a, b): Returns the minimum moves required for Alfie (starting at position a) and Bella (starting at position b) to meet, or -1 if they cannot meet. a -= 1 # Convert to 0-based index b -= 1 # Convert to 0-based index if a > b: # If Alfie is already to the right of Bella, they can't meet return -1 return b - a # They meet at b and the number of moves is b - a"},{"question":"def count_paths(n: int, grid: List[List[str]]) -> int: Determine the number of distinct paths from the top-left corner to the bottom-right corner of an n x n grid. >>> count_paths(3, [['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0']]) 2 >>> count_paths(3, [['1', '0', '0'], ['0', '1', '0'], ['0', '0', '0']]) 0","solution":"def count_paths(n, grid): MOD = 10**9+7 if grid[0][0] == '1' or grid[n-1][n-1] == '1': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][n-1]"},{"question":"from typing import List, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(tree: List[int], index: int) -> TreeNode: Construct the binary tree from the given list representation. pass def check_balance_and_height(node: TreeNode) -> Tuple[bool, int]: Check if the tree is balanced and return the height of the tree. pass def is_balanced_tree(tree: List[int]) -> bool: Determine if the tree represented by the given list is height-balanced. >>> is_balanced_tree([1, 2, 3, 4, 5, -1, -1, 6, -1, -1, -1]) False >>> is_balanced_tree([1, 2, 3, 4, 5, 6, 7]) True >>> is_balanced_tree([1, 2, 3, -1, -1, 4, 5]) True >>> is_balanced_tree() True pass def test_balanced_tree(): # Balanced tree example tree = [1, 2, 3, 4, 5, 6, 7] assert is_balanced_tree(tree) == True def test_unbalanced_tree(): # Unbalanced tree example tree = [1, 2, 3, 4, 5, -1, -1, 6, -1, -1] assert is_balanced_tree(tree) == False def test_single_element(): # Single element tree tree = [1] assert is_balanced_tree(tree) == True def test_empty_tree(): # Empty tree tree = [] assert is_balanced_tree(tree) == True def test_tree_with_missing_nodes(): # Tree with missing nodes tree = [1, 2, 3, -1, -1, 4, 5] assert is_balanced_tree(tree) == True def test_complex_unbalanced_tree(): # More complex unbalanced tree not balanced tree = [1, 2, 3, 4, -1, -1, 7, 8, -1, -1, 11, 12, -1, -1, -1] assert is_balanced_tree(tree) == False","solution":"from typing import List, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(tree: List[int], index: int) -> TreeNode: if index >= len(tree) or tree[index] == -1: return None root = TreeNode(tree[index]) root.left = build_tree_from_list(tree, 2 * index + 1) root.right = build_tree_from_list(tree, 2 * index + 2) return root def check_balance_and_height(node: TreeNode) -> Tuple[bool, int]: if not node: return True, 0 left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 current_height = 1 + max(left_height, right_height) return current_balanced, current_height def is_balanced_tree(tree: List[int]) -> bool: root = build_tree_from_list(tree, 0) balanced, _ = check_balance_and_height(root) return balanced"},{"question":"def number_of_matches(n: int) -> int: Calculate the number of matches that will be played in the tournament. Parameters: n (int): The number of participants. Returns: int: The total number of matches played in the tournament. >>> number_of_matches(1) 0 >>> number_of_matches(2) 1 >>> number_of_matches(3) 2 >>> number_of_matches(4) 3 >>> number_of_matches(7) 6 >>> number_of_matches(8) 7 >>> number_of_matches(16) 15 >>> number_of_matches(1000000) 999999","solution":"def number_of_matches(n): Calculate the number of matches that will be played in the tournament. Parameters: n (int): The number of participants. Returns: int: The total number of matches played in the tournament. total_matches = 0 while n > 1: if n % 2 == 0: matches = n // 2 n = n // 2 else: matches = (n - 1) // 2 n = (n - 1) // 2 + 1 total_matches += matches return total_matches"},{"question":"import math from typing import List, Tuple def preprocess(arr: List[int], n: int) -> List[List[int]]: Preprocess the array to create the sparse table for range minimum query pass def query(sparse_table: List[List[int]], l: int, r: int) -> int: Query the sparse table to find the minimum in the range l to r pass def solve(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Answer queries about the smallest value in a subarray of arr. >>> solve(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [1, 2, 1] >>> solve(1, 1, [42], [(1, 1)]) [42] >>> solve(5, 2, [5, 5, 5, 5, 5], [(1, 3), (2, 5)]) [5, 5] >>> solve(7, 3, [4, 8, 6, 1, 7, 3, 2], [(1, 3), (4, 7), (2, 4)]) [4, 1, 1] >>> solve(5, 1, [4, 2, 9, 11, 5], [(1, 5)]) [2] pass","solution":"import sys import math def preprocess(arr, n): # Initialize sparse table for range minimum query log = math.ceil(math.log2(n)) sparse_table = [[0] * (log + 1) for _ in range(n)] # Initialize all minimum values for the intervals of length 1 for i in range(n): sparse_table[i][0] = arr[i] # Compute values from smaller to bigger intervals j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: if sparse_table[i][j - 1] < sparse_table[i + (1 << (j - 1))][j - 1]: sparse_table[i][j] = sparse_table[i][j - 1] else: sparse_table[i][j] = sparse_table[i + (1 << (j - 1))][j - 1] i += 1 j += 1 return sparse_table def query(sparse_table, l, r): j = int(math.log2(r - l + 1)) if sparse_table[l][j] <= sparse_table[r - (1 << j) + 1][j]: return sparse_table[l][j] else: return sparse_table[r - (1 << j) + 1][j] def solve(n, q, arr, queries): sparse_table = preprocess(arr, n) results = [] for query_pair in queries: l, r = query_pair results.append(query(sparse_table, l - 1, r - 1)) return results"},{"question":"def sum_of_subarray_sums(n: int, arr: List[int]) -> int: Returns the sum of all subarray sums of the given array. >>> sum_of_subarray_sums(1, [5]) == 5 >>> sum_of_subarray_sums(2, [1, 2]) == 6 >>> sum_of_subarray_sums(3, [3, -1, 4]) == 17","solution":"def sum_of_subarray_sums(n, arr): Returns the sum of all subarray sums of the given array. total_sum = 0 for i in range(n): subarray_sum = 0 for j in range(i, n): subarray_sum += arr[j] total_sum += subarray_sum return total_sum # Example usage: # n = 3 # arr = [1, 2, 3] # print(sum_of_subarray_sums(n, arr)) # Output should be 20"},{"question":"def minimum_scenic_value(n: int, m: int, heights: List[int], bridges: List[Tuple[int, int]]) -> int: Determine the minimum possible scenic value of any path from the 1st waterfall to the n-th waterfall. >>> minimum_scenic_value(5, 6, [1, 2, 4, 5, 3], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)]) 4 >>> minimum_scenic_value(5, 3, [1, 3, 4, 5, 2], [(1, 2), (2, 3), (3, 4)]) -1 >>> minimum_scenic_value(3, 2, [3, 4, 2], [(1, 2), (2, 3)]) 4 >>> minimum_scenic_value(4, 4, [10, 1, 1, 1], [(1, 2), (2, 3), (3, 4), (1, 4)]) 10 >>> minimum_scenic_value(1000, 10000, [i % 100 + 1 for i in range(1000)], [(i, i + 1) for i in range(1, 1000)] + [(i, (i + 250) % 1000 + 1) for i in range(1, 1000)]) 100","solution":"import heapq def minimum_scenic_value(n, m, heights, bridges): def dijkstra(): pq = [(heights[0], 0)] min_scenic = [float('inf')] * n min_scenic[0] = heights[0] while pq: current_max_height, u = heapq.heappop(pq) if u == n - 1: return current_max_height for v in graph[u]: max_height = max(current_max_height, heights[v]) if max_height < min_scenic[v]: min_scenic[v] = max_height heapq.heappush(pq, (max_height, v)) return -1 graph = [[] for _ in range(n)] for u, v in bridges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) return dijkstra()"},{"question":"def minimize_absolute_differences(n: int, a: List[int]) -> List[int]: Given a list of integers \`a\` of length \`n\`, returns a new list \`b\` such that each element in \`b\` is distinct, within the range [1, 200000], and minimizes the sum of absolute differences with the corresponding elements in \`a\`. >>> minimize_absolute_differences(3, [3, 7, 9]) != [3, 7, 9] >>> minimize_absolute_differences(1, [100]) == [1] >>> result = minimize_absolute_differences(5, [10, 10, 10, 10, 10]) >>> len(result) == 5 >>> all(result[i] != result[j] for i in range(len(result)) for j in range(i + 1, len(result))) >>> result = minimize_absolute_differences(4, [4, 6, 8, 2]) >>> len(result) == 4 >>> all(result[i] != result[j] for i in range(len(result)) for j in range(i + 1, len(result))) >>> result = minimize_absolute_differences(3, [199998, 199999, 200000]) >>> len(result) == 3 >>> all(result[i] != result[j] for i in range(len(result)) for j in range(i + 1, len(result))) >>> all(1 <= x <= 200000 for x in result)","solution":"def minimize_absolute_differences(n, a): Given a list of integers \`a\` of length \`n\`, returns a new list \`b\` such that each element in \`b\` is distinct, within the range [1, 200000], and minimizes the sum of absolute differences with the corresponding elements in \`a\`. unique_values = set() b = [] a_sorted_indices = sorted(range(n), key=lambda x: a[x]) current_value = 1 for i in a_sorted_indices: while current_value in unique_values: current_value += 1 b.append(current_value) unique_values.add(current_value) result_b = [0] * n for index, value in zip(a_sorted_indices, b): result_b[index] = value return result_b # Example usage: n = 3 a = [3, 7, 9] print(minimize_absolute_differences(n, a)) # Output may vary as multiple valid outputs are possible"},{"question":"def min_rooms(n, k, skill_levels): Determines the minimum number of rooms required to accommodate all the participants under the condition that no two participants in the same room have skill levels that differ by more than k. Args: n (int): The number of participants. k (int): The maximum allowed difference in skill levels within the same room. skill_levels (List[int]): Skill levels of the participants. Returns: int: The minimum number of rooms needed. Examples: >>> min_rooms(5, 2, [3, 5, 4, 9, 10]) 2 >>> min_rooms(5, 0, [1, 1, 1, 1, 1]) 1 >>> min_rooms(5, 4, [1, 2, 3, 4, 5]) 1 >>> min_rooms(5, 0, [1, 2, 3, 4, 5]) 5 >>> min_rooms(6, 1, [1, 2, 4, 5, 7, 8]) 3 >>> min_rooms(1, 0, [999]) 1 >>> min_rooms(3, 1000, [500, 1000, 1500]) 1","solution":"def min_rooms(n, k, skill_levels): Returns the minimum number of rooms required where no two participant's skill level in the same room differs by more than k. # Sort the skill levels to facilitate grouping skill_levels.sort() # Initialize the number of rooms needed rooms = 0 i = 0 while i < n: # Start a new room with the current participant rooms += 1 current_skill = skill_levels[i] # Continue to add participants to the room as long as the skill difference is within k while i < n and skill_levels[i] - current_skill <= k: i += 1 return rooms"},{"question":"def schedule_bands(m: int, n: int, popularity_scores: list, preferences: list) -> int: Schedule the bands to time slots to maximize the total popularity score. Parameters: m (int): Number of bands. n (int): Number of time slots. popularity_scores (list): List of popularity scores for each time slot. preferences (list of lists): List containing preferred time slots for each band. Returns: int: Maximal total popularity score or -1 if it's impossible to schedule all bands. from schedule_bands import schedule_bands def test_example_1(): m = 4 n = 5 popularity_scores = [4, 10, 6, 5, 8] preferences = [ [3, 1, 2, 3], [2, 2, 5], [2, 2, 3], [1, 5] ] assert schedule_bands(m, n, popularity_scores, preferences) == 28 def test_example_2(): m = 4 n = 3 popularity_scores = [5, 6, 8] preferences = [ [2, 1, 2], [1, 3], [0], [0] ] assert schedule_bands(m, n, popularity_scores, preferences) == -1 def test_single_band_single_time_slot(): m = 1 n = 1 popularity_scores = [10] preferences = [ [1, 1] ] assert schedule_bands(m, n, popularity_scores, preferences) == 10 def test_multiple_bands_no_valid_slots(): m = 2 n = 2 popularity_scores = [5, 10] preferences = [ [1, 1], [1, 2] ] preferences[1] = [0] # No valid slots for second band assert schedule_bands(m, n, popularity_scores, preferences) == -1 def test_all_bands_same_slot(): m = 2 n = 2 popularity_scores = [8, 6] preferences = [ [1, 1], [1, 1] ] assert schedule_bands(m, n, popularity_scores, preferences) == -1 def test_general_case(): m = 3 n = 4 popularity_scores = [7, 8, 10, 5] preferences = [ [2, 1, 3], [2, 2, 4], [1, 1] ] assert schedule_bands(m, n, popularity_scores, preferences) == 25 def test_no_preferences_one_slot_per_band(): m = 3 n = 3 popularity_scores = [5, 6, 7] preferences = [ [1, 1], [1, 2], [1, 3] ] assert schedule_bands(m, n, popularity_scores, preferences) == 18","solution":"import heapq def schedule_bands(m, n, popularity_scores, preferences): Schedule the bands to time slots to maximize the total popularity score. Parameters: m (int): Number of bands. n (int): Number of time slots. popularity_scores (list): List of popularity scores for each time slot. preferences (list of lists): List containing preferred time slots for each band. Returns: int: Maximal total popularity score or -1 if it's impossible to schedule all bands. # Create a list of tuples (popularity_score, time_slot_index). popularity_heap = [(-score, i) for i, score in enumerate(popularity_scores)] heapq.heapify(popularity_heap) # Convert preferences to a set of preferred time slots for each band for easy lookup. preferred_slots = [set(p[1:]) for p in preferences] # Result tally total_popularity = 0 assigned_slots = set() for _ in range(m): while popularity_heap: score, slot = heapq.heappop(popularity_heap) slot += 1 # to adjust index as the time slots have indices from 1 to n for band_slots in preferred_slots: if slot in band_slots and slot not in assigned_slots: total_popularity -= score assigned_slots.add(slot) break else: continue break else: return -1 # If there's no valid slot to assign return total_popularity"},{"question":"def findUniqueElement(arr: [int]) -> int: Finds the element that appears exactly once in the array. >>> findUniqueElement([2, 2, 1]) == 1 >>> findUniqueElement([4, 1, 2, 1, 2]) == 4","solution":"def findUniqueElement(arr): Finds the element that appears exactly once in the array. Args: arr (list): List of integers where every element appears twice except for one element. Returns: int: The element that appears exactly once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"import random from typing import List def shuffle_array(arr: List[int]) -> List[int]: Shuffles the elements of the array randomly in place. Parameters: arr (List[int]): The array to be shuffled. Returns: List[int]: The shuffled array. # Implement your solution here # Example usage: # arr = [1, 2, 3, 4, 5] # print(shuffle_array(arr)) # Unit Test: def test_shuffle_array_length(): arr = [1, 2, 3, 4, 5] shuffled = shuffle_array(arr[:]) assert len(shuffled) == len(arr), \\"The length of the shuffled array should be the same as the original array.\\" def test_shuffle_array_contents(): arr = [1, 2, 3, 4, 5] shuffled = shuffle_array(arr[:]) assert sorted(shuffled) == sorted(arr), \\"The shuffled array should contain the same elements as the original array.\\" def test_shuffle_array_randomness(): arr = [1, 2, 3, 4, 5] first_shuffle = shuffle_array(arr[:]) second_shuffle = shuffle_array(arr[:]) # It's very unlikely (but possible) the arrays will be identical. assert first_shuffle != second_shuffle, \\"Two consecutive shuffles should not produce the same result.\\" def test_shuffle_empty_array(): arr = [] shuffled = shuffle_array(arr[:]) assert shuffled == arr, \\"Shuffling an empty array should return an empty array.\\" def test_shuffle_array_with_one_element(): arr = [42] shuffled = shuffle_array(arr[:]) assert shuffled == arr, \\"Shuffling a single-element array should return the same array.\\"","solution":"import random from typing import List def shuffle_array(arr: List[int]) -> List[int]: Shuffles the elements of the array randomly in place. Parameters: arr (List[int]): The array to be shuffled. Returns: List[int]: The shuffled array. random.shuffle(arr) return arr"},{"question":"def max_min_distance(n: int, k: int, positions: List[int]) -> int: Determine the largest minimum distance possible between any two flowers if k flowers are planted at given positions in the garden. Args: n (int): The length of the array of positions. k (int): The number of flowers to be planted. positions (List[int]): The possible positions where flowers can be planted. Returns: int: The maximum possible minimum distance between any two flowers. Examples: >>> max_min_distance(5, 3, [1, 2, 8, 4, 9]) == 3 >>> max_min_distance(2, 2, [1, 10]) == 9 import pytest from solution import max_min_distance def test_example_case(): assert max_min_distance(5, 3, [1, 2, 8, 4, 9]) == 3 def test_small_case(): assert max_min_distance(2, 2, [1, 10]) == 9 def test_consecutive_positions(): assert max_min_distance(5, 3, [1, 2, 3, 4, 5]) == 2 def test_large_gap(): assert max_min_distance(4, 2, [1, 2, 3, 1000000000]) == 999999999 def test_max_positions(): assert max_min_distance(5, 4, [1, 1000000000, 500000000, 250000000, 750000000]) == 250000000","solution":"def can_place_flowers(positions, k, min_distance): count = 1 # Place the first flower at the first position last_position = positions[0] for position in positions[1:]: if position - last_position >= min_distance: count += 1 last_position = position if count >= k: return True return False def max_min_distance(n, k, positions): positions.sort() left = 1 right = positions[-1] - positions[0] best = 0 while left <= right: mid = (left + right) // 2 if can_place_flowers(positions, k, mid): best = mid left = mid + 1 else: right = mid - 1 return best"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: This function takes a list of integers and returns the length of the longest consecutive subsequence. >>> longest_consecutive_subsequence([1, 2, 3, 4]) == 4 >>> longest_consecutive_subsequence([1, 2, 9, 4, 3]) == 4 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([10, 5, 15, 20]) == 1 >>> longest_consecutive_subsequence([1, 2, 2, 3, 4]) == 4 >>> longest_consecutive_subsequence([1000000000, 1000000001, 1000000002]) == 3 >>> longest_consecutive_subsequence([3]) == 1","solution":"def longest_consecutive_subsequence(arr): This function takes a list of integers and returns the length of the longest consecutive subsequence. num_set = set(arr) # Convert the list to a set to remove duplicates and allow O(1) lookups longest_streak = 0 for num in num_set: # Check if it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # Count the length of the sequence while current_num + 1 in num_set: current_num += 1 current_streak += 1 # Update the longest streak found longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def max_points_on_a_line(n: int, points: List[Tuple[int, int]]) -> int: Given n points on a 2D cartesian plane, determine the maximum number of points that lie on the same straight line. Args: n: An integer representing the number of points. points: A list of tuples where each tuple contains two integers representing the coordinates of each point. Returns: An integer representing the maximum number of points that lie on the same straight line. Examples: >>> max_points_on_a_line(6, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (1, 2)]) 5 >>> max_points_on_a_line(4, [(-1, -1), (-2, -2), (1, 1), (2, 2)]) 4 >>> max_points_on_a_line(3, [(0, 0), (1, 1), (1, 0)]) 2 pass","solution":"def max_points_on_a_line(n, points): from collections import defaultdict from math import gcd if n <= 1: return n def slope(dx, dy): if dx == 0: # vertical line return (0, 1) elif dy == 0: # horizontal line return (1, 0) else: g = gcd(dx, dy) return (dx // g, dy // g) max_points = 1 for i in range(n): slopes = defaultdict(int) same_point_count = 1 vertical_points = 0 horizontal_points = 0 for j in range(n): if i != j: dx = points[j][0] - points[i][0] dy = points[j][1] - points[i][1] if dx == 0 and dy == 0: same_point_count += 1 elif dx == 0: vertical_points += 1 elif dy == 0: horizontal_points += 1 else: sl = slope(dx, dy) slopes[sl] += 1 current_max = max(slopes.values(), default=0) + same_point_count current_max = max(current_max, vertical_points + same_point_count) current_max = max(current_max, horizontal_points + same_point_count) max_points = max(max_points, current_max) return max_points # Example usage: # n = 6 # points = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (1, 2)] # print(max_points_on_a_line(n, points)) # Output: 5"},{"question":"def longest_dense_consecutive_subarray(arr: List[int]) -> int: Determine the length of the longest \\"dense\\" and \\"consecutive\\" subarray within the array. >>> longest_dense_consecutive_subarray([1, 2, 0, 4, 3, 5]) 6 >>> longest_dense_consecutive_subarray([1, 3, 5, 7, 9]) 1 >>> longest_dense_consecutive_subarray([4, 3, 2, 1, 0]) 5 >>> longest_dense_consecutive_subarray([5, 5, 5, 5]) 1","solution":"def longest_dense_consecutive_subarray(arr): if not arr: return 0 # Sort the array and remove duplicates sorted_arr = sorted(set(arr)) longest_length = 1 current_length = 1 for i in range(1, len(sorted_arr)): if sorted_arr[i] - sorted_arr[i-1] == 1: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"from typing import List, Tuple def apply_operations(n: int, m: int, k: int, operations: List[Tuple[int, int, int, int]]) -> List[List[str]]: Apply a series of operations to a board and fill cells with '#' as specified by the operations. pass def board_to_string(board: List[List[str]]) -> str: Convert a board represented as a list of lists into a string where each row is joined by new lines. pass # Unit tests def test_apply_operations(): n, m, k = 5, 5, 3 operations = [ (1, 1, 2, 2), (3, 3, 4, 4), (4, 2, 5, 5) ] expected_output = [ ['#', '#', '.', '.', '.'], ['#', '#', '.', '.', '.'], ['.', '.', '#', '#', '.'], ['.', '#', '#', '#', '#'], ['.', '#', '#', '#', '#'] ] assert apply_operations(n, m, k, operations) == expected_output def test_board_to_string(): board = [ ['#', '#', '.', '.', '.'], ['#', '#', '.', '.', '.'], ['.', '.', '#', '#', '.'], ['.', '#', '#', '#', '#'], ['.', '#', '#', '#', '#'] ] expected_output = '...n...n...n.n.' assert board_to_string(board) == expected_output def test_apply_operations_single_cell(): n, m, k = 3, 3, 1 operations = [(1, 1, 1, 1)] expected_output = [ ['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert apply_operations(n, m, k, operations) == expected_output def test_apply_operations_full_board(): n, m, k = 2, 2, 1 operations = [(1, 1, 2, 2)] expected_output = [ ['#', '#'], ['#', '#'] ] assert apply_operations(n, m, k, operations) == expected_output","solution":"def apply_operations(n, m, k, operations): board = [['.' for _ in range(m)] for _ in range(n)] for op in operations: r1, c1, r2, c2 = op for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): board[i][j] = '#' return board def board_to_string(board): return 'n'.join(''.join(row) for row in board) def main(): n, m, k = map(int, input().split()) operations = [tuple(map(int, input().split())) for _ in range(k)] result_board = apply_operations(n, m, k, operations) print(board_to_string(result_board)) if __name__ == \\"__main__\\": main()"},{"question":"def count_clusters(t: int, test_cases: List[Dict[str, Union[int, List[str]]]]) -> List[int]: Counts the number of distinct clusters in the petri dishes described by test cases. Parameters: t (int): The number of test cases. test_cases (List[Dict[str, Union[int, List[str]]]]): A list of test cases, each containing: - 'n': Number of rows in the grid. - 'm': Number of columns in the grid. - 'grid': List of strings representing the grid. Returns: List[int]: A list containing the number of distinct clusters for each test case. Examples: >>> count_clusters(2, [{'n': 3, 'm': 3, 'grid': [\\"#.#\\", \\".#.\\", \\"#.#\\"]}, {'n': 4, 'm': 5, 'grid': [\\"..#\\", \\".#..#\\", \\"...\\", \\"...\\"]}]) [5, 4] >>> count_clusters(1, [{'n': 2, 'm': 2, 'grid': [\\"..\\", \\"..\\"] }]) [0]","solution":"def count_clusters(t, test_cases): Counts the number of distinct clusters in the petri dishes described by test_cases. def dfs(grid, visited, x, y, n, m): stack = [(x, y)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '#': visited[nx][ny] = True stack.append((nx, ny)) results = [] for case in test_cases: n, m, grid = case['n'], case['m'], case['grid'] visited = [[False] * m for _ in range(n)] clusters = 0 for i in range(n): for j in range(m): if not visited[i][j] and grid[i][j] == '#': visited[i][j] = True dfs(grid, visited, i, j, n, m) clusters += 1 results.append(clusters) return results"},{"question":"def is_stable_matrix(matrix: List[List[int]]) -> str: Determine if a matrix is stable. A matrix is stable if the difference between the sum of elements in any row and the sum of elements in any column is the same across all rows and columns. :param matrix: List of Lists of integers representing the matrix :return: \\"YES\\" if the matrix is stable, \\"NO\\" otherwise >>> is_stable_matrix([[2, 1, 3], [1, 2, 2], [2, 3, 1]]) \\"NO\\" >>> is_stable_matrix([[1, 2], [3, 4]]) \\"NO\\" >>> is_stable_matrix([[1]]) \\"YES\\" >>> is_stable_matrix([[1, 1], [1, 1]]) \\"YES\\" >>> is_stable_matrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) \\"YES\\" >>> is_stable_matrix([[10, 10, 10], [10, 10, 10], [10, 10, 10]]) \\"YES\\"","solution":"def is_stable_matrix(matrix): Determine if a matrix is stable. A matrix is stable if the difference between the sum of elements in any row and the sum of elements in any column is the same across all rows and columns. :param matrix: List of Lists of integers representing the matrix :return: \\"YES\\" if the matrix is stable, \\"NO\\" otherwise n = len(matrix) # Calculate sum of each row and store in row_sums row_sums = [sum(row) for row in matrix] # Calculate sum of each column and store in col_sums col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(n)] # Calculate the first difference between the sum of first row and the first column difference = row_sums[0] - col_sums[0] # Check if the difference is same for all rows and columns for i in range(1, n): if row_sums[i] - col_sums[i] != difference: return \\"NO\\" return \\"YES\\""},{"question":"def max_path_sum(grid): Hiroshi, an avid coder, has devised a game involving an NxM grid filled with numbers. Each cell of the grid contains a positive integer. The objective is to find a path from the top-left corner (cell (1,1)) to the bottom-right corner (cell (N,M)) such that the sum of the values on the path is maximized. Hiroshi can only move right or down from a given cell. Parameters: grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: The maximum sum of values on a path from the top-left corner to the bottom-right corner. Example: >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 # Your code here def solve_max_path_sum(N, M, grid): Wrapper function to read the input and call the max_path_sum function. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: The maximum sum of values on a path from the top-left corner to the bottom-right corner. Example: >>> solve_max_path_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 # Your code here from solution import max_path_sum, solve_max_path_sum def test_max_path_sum(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_path_sum(grid) == 29 def test_solve_max_path_sum_example(): N = 3 M = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert solve_max_path_sum(N, M, grid) == 29 def test_grid_with_min_size(): N = 1 M = 1 grid = [ [1] ] assert solve_max_path_sum(N, M, grid) == 1 def test_uniform_grid(): N = 2 M = 2 grid = [ [1, 1], [1, 1] ] assert solve_max_path_sum(N, M, grid) == 3 def test_single_column_grid(): N = 3 M = 1 grid = [ [1], [2], [3] ] assert solve_max_path_sum(N, M, grid) == 6 def test_single_row_grid(): N = 1 M = 3 grid = [ [4, 5, 6] ] assert solve_max_path_sum(N, M, grid) == 15 def test_larger_grid(): N = 4 M = 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert solve_max_path_sum(N, M, grid) == 73","solution":"def max_path_sum(grid): N = len(grid) M = len(grid[0]) # Create a 2D dp array to store the maximum sum up to each position dp = [[0]*M for _ in range(N)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell will have the result return dp[N-1][M-1] # Wrapper function to read the input and call the max_path_sum function def solve_max_path_sum(N, M, grid): return max_path_sum(grid)"},{"question":"def can_be_palindrome(s: str) -> str: Determines if it is possible to transform the string into a palindrome by swapping all occurrences of any two distinct characters. >>> can_be_palindrome(\\"aabb\\") == \\"YES\\" >>> can_be_palindrome(\\"abc\\") == \\"NO\\"","solution":"def can_be_palindrome(s): Determines if the string s can be transformed into a palindrome by swapping all occurrences of any two distinct characters. from collections import Counter count = Counter(s) odd_count = sum(1 for cnt in count.values() if cnt % 2 != 0) # A string can be rearranged into a palindrome if there's at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def longest_unique_subarray(n: int, a: List[int]) -> int: Returns the length of the longest subarray where all elements are distinct. >>> longest_unique_subarray(5, [1, 2, 1, 3, 4]) 4 >>> longest_unique_subarray(3, [1, 1, 1]) 1 >>> longest_unique_subarray(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_unique_subarray(4, [2, 2, 2, 2]) 1 >>> longest_unique_subarray(7, [1, 2, 3, 1, 2, 3, 4]) 4 >>> longest_unique_subarray(10, [5, 5, 7, 8, 5, 6, 7, 8, 9, 10]) 6 >>> longest_unique_subarray(1, [42]) 1 >>> longest_unique_subarray(0, []) 0","solution":"def longest_unique_subarray(n, a): Returns the length of the longest subarray where all elements are distinct. max_length = 0 start = 0 seen = {} for end in range(n): if a[end] in seen: start = max(start, seen[a[end]] + 1) seen[a[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def max_donations(donations: List[int]) -> int: Determines the maximum sum of money obtained by accepting donations such that no two accepted donations come from adjacent donors. Parameters: donations (list of int): List of donations from n donors Returns: int: Maximum sum of non-adjacent donations >>> max_donations([10]) 10 >>> max_donations([]) 0 >>> max_donations([2, 4]) 4 >>> max_donations([5, 1, 2, 10, 6, 2]) 17 >>> max_donations([1, 1000, 1, 1000, 1, 1000]) 3000 >>> max_donations([3, 2, 5, 10, 7]) 15 >>> max_donations([4, 4, 4, 4, 4, 4]) 12","solution":"def max_donations(donations): Determines the maximum sum of money obtained by accepting donations such that no two accepted donations come from adjacent donors. Parameters: donations (list of int): List of donations from n donors Returns: int: Maximum sum of non-adjacent donations if not donations: return 0 n = len(donations) if n == 1: return donations[0] # dp[i] will store the max donation sum we can get by considering first i donations dp = [0] * n dp[0] = donations[0] dp[1] = max(donations[0], donations[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + donations[i]) return dp[-1]"},{"question":"def min_palindromic_parts(n: int, sequence: List[int]) -> int: Determine the minimum number of palindromic parts the sequence can be split into. :param n: An integer, the number of cards. :param sequence: A list of integers representing card values. :return: An integer, the minimum number of palindromic parts. >>> min_palindromic_parts(7, [1, 2, 3, 2, 1, 4, 4]) 2 >>> min_palindromic_parts(3, [1, 2, 1]) 1 >>> min_palindromic_parts(3, [1, 2, 3]) 3 >>> min_palindromic_parts(1, [1]) 1 >>> min_palindromic_parts(8, [1, 2, 3, 4, 5, 6, 7, 8]) 8 >>> min_palindromic_parts(5, [1, 3, 3, 3, 1]) 1 >>> min_palindromic_parts(6, [1, 2, 2, 1, 3, 3]) 2","solution":"def min_palindromic_parts(n, sequence): Returns the minimum number of palindromic subsequences the given sequence can be split into. dp = [0] * n for i in range(n): min_parts = i + 1 for j in range(i + 1): if sequence[j:i + 1] == sequence[j:i + 1][::-1]: min_parts = min(min_parts, (dp[j - 1] if j > 0 else 0) + 1) dp[i] = min_parts return dp[-1]"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Returns the maximum sum of any continuous subarray of length k. Parameters: arr (list): List of integers. k (int): Length of subarray. Returns: int: Maximum sum of any continuous subarray of length k. >>> max_sum_subarray([1, 2, 3, 4, 5], 3) 12 >>> max_sum_subarray([5], 1) 5 >>> max_sum_subarray([1000000000, 1000000000, 1000000000], 2) 2000000000 >>> max_sum_subarray([1, 2, 3, 4], 4) 10 >>> max_sum_subarray([1, 2, 3, 4, 5, 6], 3) 15 >>> max_sum_subarray([4, 4, 4, 4, 4], 2) 8","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any continuous subarray of length k. Parameters: arr (list): List of integers. k (int): Length of subarray. Returns: int: Maximum sum of any continuous subarray of length k. n = len(arr) # Compute the sum of the first subarray of length k max_sum = current_sum = sum(arr[:k]) # Use a sliding window to compute the sums of the remaining subarrays for i in range(k, n): current_sum = current_sum + arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def coin_change(coins: List[int], amount: int) -> int: Returns the fewest number of coins needed to make up the amount. If it is not possible to make up the amount with the given coins, return -1. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1], 10) 10 >>> coin_change([1, 2, 5], 100) 20 >>> coin_change([3, 4, 5], 7) 2 >>> coin_change([100], 10000) 100 >>> coin_change([], 1000) -1 >>> coin_change([1, 2, 5], 0) 0","solution":"def coin_change(coins, amount): Returns the fewest number of coins needed to make up the amount. If it is not possible to make up the amount with the given coins, return -1. # Initialize a list for storing the minimum coins needed for each amount up to \`amount\` dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make 0 amount # Update the dp list for each coin for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still inf, it means amount cannot be made up by any combination of the coins return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List def shortest_path_in_grid(grid: List[str], N: int, M: int) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner, avoiding obstacles, or -1 if no such path exists. Args: grid: List of strings representing the grid. N: Number of rows in the grid. M: Number of columns in the grid. >>> grid = [ ... \\"......\\", ... \\".XX...\\", ... \\"....X.\\", ... \\"X....X\\", ... \\"...X..\\" ... ] >>> shortest_path_in_grid(grid, 5, 6) 9 >>> grid = [ ... \\"XX\\", ... \\"XX\\" ... ] >>> shortest_path_in_grid(grid, 2, 2) -1 # Unit tests def test_example(): grid = [ \\"......\\", \\".XX...\\", \\"....X.\\", \\"X....X\\", \\"...X..\\" ] assert shortest_path_in_grid(grid, 5, 6) == 9 def test_no_path(): grid = [ \\"XX\\", \\"XX\\" ] assert shortest_path_in_grid(grid, 2, 2) == -1 def test_path_with_obstacles(): grid = [ \\"...\\", \\".X.\\", \\"...\\" ] assert shortest_path_in_grid(grid, 3, 3) == 4 def test_large_empty_grid(): grid = [\\".\\" * 1000 for _ in range(1000)] assert shortest_path_in_grid(grid, 1000, 1000) == 1998 def test_start_or_end_blocked(): grid = [ \\"X.\\", \\".X\\" ] assert shortest_path_in_grid(grid, 2, 2) == -1 grid = [ \\".X\\", \\"X.\\" ] assert shortest_path_in_grid(grid, 2, 2) == -1 def test_already_at_destination(): grid = [ \\".\\" ] assert shortest_path_in_grid(grid, 1, 1) == 0","solution":"from collections import deque def shortest_path_in_grid(grid, N, M): Returns the length of the shortest path from the top-left to the bottom-right corner, avoiding obstacles, or -1 if no such path exists. if grid[0][0] == 'X' or grid[N-1][M-1] == 'X': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = [[False for _ in range(M)] for _ in range(N)] visited[0][0] = True steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == N-1 and y == M-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) steps += 1 return -1"},{"question":"def is_valley(heights: List[int]) -> str: Determine if the given list of building heights forms a valley pattern. >>> is_valley([2, 3, 5, 4, 1]) == \\"YES\\" >>> is_valley([7, 5, 3, 1]) == \\"NO\\" >>> is_valley([1, 1, 1]) == \\"NO\\" >>> is_valley([1, 2, 3, 4]) == \\"NO\\" >>> is_valley([]) == \\"NO\\" >>> is_valley([1, 2, 1]) == \\"YES\\" >>> is_valley([1, 2, 2, 1]) == \\"NO\\" >>> is_valley([1, 3, 5, 7, 6, 4, 2]) == \\"YES\\" >>> is_valley([3, 2, 1]) == \\"NO\\" >>> is_valley([1, 2, 3]) == \\"NO\\"","solution":"def is_valley(heights): n = len(heights) if n < 3: return \\"NO\\" i = 1 # find the increasing part while i < n and heights[i] > heights[i - 1]: i += 1 if i == 1 or i == n: return \\"NO\\" # find the decreasing part while i < n and heights[i] < heights[i - 1]: i += 1 if i == n: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is a prime. >>> is_prime(2) True >>> is_prime(4) False if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def can_partition_into_prime_sums(n: int, k: int, arr: List[int]) -> str: Determine if array can be partitioned into \`k\` non-empty subsets such that each subset sum is a prime number. >>> can_partition_into_prime_sums(5, 3, [6, 5, 8, 12, 1]) 'NO' >>> can_partition_into_prime_sums(3, 2, [5, 7, 6]) 'YES' >>> can_partition_into_prime_sums(4, 2, [3, 11, 7, 2]) 'YES' >>> can_partition_into_prime_sums(4, 2, [4, 6, 8, 9]) 'NO' >>> can_partition_into_prime_sums(5, 5, [2, 3, 5, 7, 11]) 'YES' >>> can_partition_into_prime_sums(1, 1, [2]) 'YES' >>> can_partition_into_prime_sums(1, 1, [4]) 'NO' >>> can_partition_into_prime_sums(3, 2, [997, 991, 4]) 'YES' >>> can_partition_into_prime_sums(3, 2, [997, 990, 4]) 'NO'","solution":"from itertools import combinations def is_prime(num): Check if a number is a prime. if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def can_partition_into_prime_sums(n, k, arr): Determine if array can be partitioned into \`k\` non-empty subsets such that each subset sum is a prime number. def can_partition(start, k, subset_sums): if k == 0: return all(is_prime(s) for s in subset_sums) if start >= n: return False for comb in combinations(range(start, n), 1): new_subset_sum = sum(arr[i] for i in comb) if can_partition(comb[0] + 1, k - 1, subset_sums + [new_subset_sum]): return True return False return \\"YES\\" if can_partition(0, k, []) else \\"NO\\""},{"question":"def find_isomer_pairs(molecules: List[str]) -> Union[List[Tuple[int, int]], int]: Finds and returns pairs of isomer molecules by their 1-based indices. >>> find_isomer_pairs([\\"CCHH\\", \\"HCCO\\", \\"OCHH\\", \\"HCC\\", \\"CCHH\\"]) [(1, 5)] >>> find_isomer_pairs([\\"ABC\\", \\"DEF\\", \\"GHI\\"]) -1 >>> find_isomer_pairs([\\"AABB\\", \\"BBAA\\", \\"ABAB\\", \\"CCDD\\", \\"DDCC\\", \\"CCDD\\"]) [(1, 2), (1, 3), (2, 3), (4, 5), (4, 6), (5, 6)] >>> find_isomer_pairs([\\"A\\", \\"B\\", \\"A\\"]) [(1, 3)] >>> find_isomer_pairs([\\"ABC\\", \\"ABC\\", \\"ABC\\"]) [(1, 2), (1, 3), (2, 3)] >>> find_isomer_pairs([\\"AB\\", \\"BC\\", \\"CD\\", \\"DE\\"]) -1 >>> find_isomer_pairs([\\"AABBCC\\", \\"CCBBAA\\", \\"BBCCAADD\\"]) [(1, 2)] >>> find_isomer_pairs([]) -1","solution":"from collections import defaultdict def find_isomer_pairs(molecules): Finds and returns pairs of isomer molecules by their 1-based indices. Parameters: molecules (list of str): List of molecules represented as strings. Returns: list of tuple: List of tuples where each tuple contains two 1-based indices of isomer molecules. # Dictionary to map sorted molecular formula to its original indices isomer_map = defaultdict(list) # Populate the map with sorted molecules and their indices for idx, molecule in enumerate(molecules): sorted_molecule = ''.join(sorted(molecule)) isomer_map[sorted_molecule].append(idx + 1) # Store 1-based index isomer_pairs = [] # Find all pairs of indices which are isomers for indices in isomer_map.values(): if len(indices) > 1: for i in range(len(indices)): for j in range(i + 1, len(indices)): isomer_pairs.append((indices[i], indices[j])) if not isomer_pairs: return -1 return isomer_pairs"},{"question":"def min_gadgets_required(n: int, meetings: list) -> int: Returns the minimum number of gadgets required to cover all meetings. >>> min_gadgets_required(4, [{1, 2, 3}, {2, 4}, {1, 4, 5}, {6}]) 6 >>> min_gadgets_required(1, [{1, 2, 3}]) 3 >>> min_gadgets_required(3, [{1, 2}, {3, 4}, {5, 6}]) 6 >>> min_gadgets_required(3, [{1, 2, 3}, {1, 2, 3}, {1, 2, 3}]) 3 >>> min_gadgets_required(3, [{1, 2}, {2, 3}, {3, 4}]) 4","solution":"def min_gadgets_required(n, meetings): Returns the minimum number of gadgets required to cover all meetings. attendees = set() for meeting in meetings: attendees.update(meeting) return len(attendees)"},{"question":"def tsp(n: int, t: List[List[int]]) -> int: Solve the Traveling Salesman Problem for a given number of cities and travel time matrix. Parameters: n (int): number of cities t (list of list of int): travel time matrix Returns: int: minimum travel time to visit all cities and return to the start Example: >>> tsp(4, [[0, 20, 42, 35], [20, 0, 30, 34], [42, 30, 0, 12], [35, 34, 12, 0]]) 97 >>> tsp(3, [[0, 1, 15], [1, 0, 10], [15, 10, 0]]) 26","solution":"from itertools import permutations def tsp(n, t): Solve the Traveling Salesman Problem for a given number of cities and travel time matrix. Parameters: n (int): number of cities t (list of list of int): travel time matrix Returns: int: minimum travel time to visit all cities and return to the start # Generate all permutations of cities except the starting city (city 0) cities = range(1, n) min_travel_time = float('inf') for perm in permutations(cities): # Calculate the total travel time for the current permutation travel_time = t[0][perm[0]] # start from city 0 to the first city in the permutation for i in range(len(perm) - 1): travel_time += t[perm[i]][perm[i + 1]] travel_time += t[perm[-1]][0] # return to the start city # Update the minimum travel time if the current one is less min_travel_time = min(min_travel_time, travel_time) return min_travel_time"},{"question":"from typing import List, Tuple def process_queries(n: int, s: str, queries: List[Tuple[int, int]]) -> List[str]: Given a string s and a list of queries defined by two integers l and r, determines if substrings can be rearranged to form a palindrome. Parameters: n (int): The length of the string s. s (str): The input string consisting of lowercase English letters. queries (List[Tuple[int, int]]): List of queries where each query is defined by two integers l and r. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each query. Examples: >>> process_queries(6, \\"aabbcc\\", [(1, 4)]) [\\"YES\\"] >>> process_queries(6, \\"aabbcc\\", [(2, 5)]) [\\"NO\\"]","solution":"from collections import Counter def can_form_palindrome(l, r, s): Checks if the substring s[l-1:r] can be rearranged to form a palindrome. l and r are 1-based indices. substr = s[l-1:r] count = Counter(substr) odd_count = sum(1 for v in count.values() if v % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_queries(n, s, queries): Processes multiple queries to check if substrings can be rearranged to form a palindrome. return [can_form_palindrome(l, r, s) for l, r in queries]"},{"question":"def min_operations_to_open_all_gates(n: int, house_string: str) -> int: Determine the minimum number of operations required to open all the gates in the houses. >>> min_operations_to_open_all_gates(6, \\"101010\\") 3 >>> min_operations_to_open_all_gates(1, \\"1\\") 0 >>> min_operations_to_open_all_gates(1, \\"0\\") 1 >>> min_operations_to_open_all_gates(5, \\"11111\\") 0 >>> min_operations_to_open_all_gates(4, \\"0000\\") 1 >>> min_operations_to_open_all_gates(7, \\"1001001\\") 2 >>> min_operations_to_open_all_gates(5, \\"00111\\") 1 >>> min_operations_to_open_all_gates(5, \\"11100\\") 1 >>> min_operations_to_open_all_gates(6, \\"110011\\") 1","solution":"def min_operations_to_open_all_gates(n, house_string): Determine the minimum number of operations required to open all the gates in the houses. :param n: Integer, the number of houses :param house_string: String of length n containing '0' and '1' :return: Integer, the minimum number of operations operations = 0 i = 0 while i < n: if house_string[i] == '0': operations += 1 while i < n and house_string[i] == '0': i += 1 else: i += 1 return operations"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: You are given \`n\` weighted items and a knapsack that can carry up to a certain weight \`W\`. Your task is to find the maximum value of items that can be carried in the knapsack without exceeding the weight limit. Each item has a weight \`w_i\` and a value \`v_i\`. The function will receive: n (int): The number of items. W (int): The maximum weight the knapsack can carry. items (list of tuples of int, int): A list where each tuple contains two integers representing the weight and value of an item. Returns: int: The maximum value that can be achieved within the given weight limit of the knapsack. Example: >>> knapsack(4, 7, [(2, 10), (3, 40), (4, 50), (5, 70)]) 90 pass from typing import List, Tuple def test_knapsack_example(): n = 4 W = 7 items = [(2, 10), (3, 40), (4, 50), (5, 70)] assert knapsack(n, W, items) == 90 def test_knapsack_small_input(): n = 1 W = 1000 items = [(100, 1000)] assert knapsack(n, W, items) == 1000 def test_knapsack_no_items(): n = 0 W = 1000 items = [] assert knapsack(n, W, items) == 0 def test_knapsack_weight_limit_exceeded(): n = 1 W = 50 items = [(100, 1000)] assert knapsack(n, W, items) == 0 def test_knapsack_multiple_items(): n = 4 W = 10 items = [(5, 10), (4, 40), (6, 30), (3, 50)] assert knapsack(n, W, items) == 90 def test_knapsack_weights_equal(): n = 3 W = 5 items = [(5, 10), (5, 20), (5, 30)] assert knapsack(n, W, items) == 30 def test_knapsack_values_equal(): n = 3 W = 6 items = [(2, 10), (3, 10), (4, 10)] assert knapsack(n, W, items) == 20","solution":"def knapsack(n, W, items): dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): weight, value = items[i-1] for w in range(W + 1): if weight > w: dp[i][w] = dp[i-1][w] else: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) return dp[n][W]"},{"question":"def count_unique_subarrays_with_sum_T(n: int, T: int, arr: List[int]) -> int: Returns the count of unique subarrays where the sum of the elements is exactly T. :param n: The number of elements in the array (1 ≤ n ≤ 10^5). :param T: The target sum (-10^9 ≤ T ≤ 10^9). :param arr: The list of integers (-10^9 ≤ a_i ≤ 10^9). :return: The total number of unique subarrays where the sum of the elements is exactly T. >>> count_unique_subarrays_with_sum_T(5, 5, [1, 2, 3, 4, 5]) 2 >>> count_unique_subarrays_with_sum_T(1, 5, [5]) 1 >>> count_unique_subarrays_with_sum_T(5, 10, [1, 1, 1, 1, 1]) 0 >>> count_unique_subarrays_with_sum_T(6, 5, [3, 2, 1, 2, 3, 1]) 3 >>> count_unique_subarrays_with_sum_T(5, 0, [1, -1, 2, -2, 3]) 3 >>> count_unique_subarrays_with_sum_T(100000, 100000, [1] * 100000) 1 pass","solution":"def count_unique_subarrays_with_sum_T(n, T, arr): Returns the count of unique subarrays where the sum of the elements is exactly T. prefix_sum_count = {} prefix_sum = 0 count = 0 for num in arr: prefix_sum += num if prefix_sum == T: count += 1 if (prefix_sum - T) in prefix_sum_count: count += prefix_sum_count[prefix_sum - T] if prefix_sum in prefix_sum_count: prefix_sum_count[prefix_sum] += 1 else: prefix_sum_count[prefix_sum] = 1 return count"},{"question":"def max_sum_after_k_swaps(nums, k): Returns the maximum possible sum of the first k elements of the array after performing at most k swaps. >>> max_sum_after_k_swaps([3, 1, 2, 5, 4], 3) 12 >>> max_sum_after_k_swaps([1, 2, 3], 3) 6 >>> max_sum_after_k_swaps([-1, -2, -3], 2) -3 >>> max_sum_after_k_swaps([1, -1, 3, 2, -2], 2) 5 >>> max_sum_after_k_swaps([4, 3, 2, 1], 2) 7","solution":"def max_sum_after_k_swaps(nums, k): Returns the maximum possible sum of the first k elements of the array after performing at most k swaps. nums.sort(reverse=True) return sum(nums[:k])"},{"question":"def game_winner(s: str) -> str: Determines the winner of the game based on the string s. Alice wins if she can make all characters of the string the same by performing exactly one operation. Bob wins if Alice cannot achieve this. :param s: str - input string :return: str - the winner (\\"Alice\\" or \\"Bob\\") >>> game_winner(\\"aaaab\\") == \\"Alice\\" >>> game_winner(\\"abcdef\\") == \\"Bob\\" >>> game_winner(\\"a\\") == \\"Alice\\" >>> game_winner(\\"aaaaa\\") == \\"Alice\\" >>> game_winner(\\"aaab\\") == \\"Alice\\" >>> game_winner(\\"abcd\\") == \\"Bob\\" >>> game_winner(\\"aab\\") == \\"Alice\\" >>> game_winner(\\"aaa\\") == \\"Alice\\" >>> game_winner(\\"aabb\\") == \\"Bob\\"","solution":"def game_winner(s): Determines the winner of the game based on the string s. Alice wins if she can make all characters of the string the same by performing exactly one operation. Bob wins if Alice cannot achieve this. :param s: str - input string :return: str - the winner (\\"Alice\\" or \\"Bob\\") from collections import Counter freq = Counter(s) if len(freq) == 1: return \\"Alice\\" max_freq = max(freq.values()) if max_freq == len(s) - 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def maximum_length_to_sort(arr): Determine the maximum possible length of a contiguous subarray such that if you sort this subarray, the entire array becomes sorted in non-decreasing order. >>> maximum_length_to_sort([1, 2, 3, 4, 5]) 0 >>> maximum_length_to_sort([1, 5, 4, 3, 2, 6, 7]) 4 >>> maximum_length_to_sort([5, 1, 2, 3, 4]) 5 >>> maximum_length_to_sort([1, 2, 3, 4, 6, 5, 7]) 2 >>> maximum_length_to_sort([1]) 0 >>> maximum_length_to_sort([1, 3, 2, 4]) 2","solution":"def maximum_length_to_sort(arr): n = len(arr) if n == 1: return 0 left = 0 while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 if left == n - 1: return 0 right = n - 1 while right > 0 and arr[right] >= arr[right - 1]: right -= 1 if right == 0: return n - 1 min_val = min(arr[left:right + 1]) max_val = max(arr[left:right + 1]) while left > 0 and arr[left - 1] > min_val: left -= 1 while right < n - 1 and arr[right + 1] < max_val: right += 1 return right - left + 1"},{"question":"def spiral_rotate(matrix: List[List[int]]) -> List[List[int]]: Rotates the elements of a matrix in a spiral manner and returns the new matrix. >>> spiral_rotate([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) [[5,1,2,3], [9,10,6,4], [13,11,7,8], [14,15,16,12]] >>> spiral_rotate([[1,2,3],[4,5,6],[7,8,9]]) [[4,1,2],[7,5,3],[8,9,6]] >>> spiral_rotate([[1,2],[3,4]]) [[3,1],[4,2]] >>> spiral_rotate([[1]]) [[1]] >>> spiral_rotate([]) []","solution":"def spiral_rotate(matrix): if not matrix: return [] m, n = len(matrix), len(matrix[0]) layers = [] # Collect the layers of the matrix for layer in range((min(m, n) + 1) // 2): toplayer = (layer, layer) bottomlayer = (m - 1 - layer, n - 1 - layer) current_layer = [] # Top edge (left to right) for j in range(toplayer[1], bottomlayer[1] + 1): current_layer.append(matrix[toplayer[0]][j]) # Right edge (top to bottom) for i in range(toplayer[0] + 1, bottomlayer[0] + 1): current_layer.append(matrix[i][bottomlayer[1]]) # Bottom edge (right to left) if bottomlayer[0] > toplayer[0]: for j in range(bottomlayer[1] - 1, toplayer[1] - 1, -1): current_layer.append(matrix[bottomlayer[0]][j]) # Left edge (bottom to top) if bottomlayer[1] > toplayer[1]: for i in range(bottomlayer[0] - 1, toplayer[0], -1): current_layer.append(matrix[i][toplayer[1]]) layers.append(current_layer) # Rotate each layer for l in range(len(layers)): if layers[l]: last = layers[l].pop() layers[l].insert(0, last) # Put the layers back into the matrix for layer in range(len(layers)): toplayer = (layer, layer) bottomlayer = (m - 1 - layer, n - 1 - layer) current_layer = layers[layer] idx = 0 # Top edge (left to right) for j in range(toplayer[1], bottomlayer[1] + 1): matrix[toplayer[0]][j] = current_layer[idx] idx += 1 # Right edge (top to bottom) for i in range(toplayer[0] + 1, bottomlayer[0] + 1): matrix[i][bottomlayer[1]] = current_layer[idx] idx += 1 # Bottom edge (right to left) if bottomlayer[0] > toplayer[0]: for j in range(bottomlayer[1] - 1, toplayer[1] - 1, -1): matrix[bottomlayer[0]][j] = current_layer[idx] idx += 1 # Left edge (bottom to top) if bottomlayer[1] > toplayer[1]: for i in range(bottomlayer[0] - 1, toplayer[0], -1): matrix[i][toplayer[1]] = current_layer[idx] idx += 1 return matrix"},{"question":"from collections import deque def shortest_path(n: int, b: int, barriers: List[Tuple[int, int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determine the shortest number of steps required to move from the starting cell (sx, sy) to the ending cell (ex, ey) in an n x n grid with some barriers. Args: n (int): The size of the grid. b (int): The number of barriers in the grid. barriers (List[Tuple[int, int]]): The coordinates of the barriers. start (Tuple[int, int]): The starting point coordinates. end (Tuple[int, int]): The ending point coordinates. Returns: int: The shortest number of steps required to reach the destination, or -1 if it is impossible. >>> shortest_path(5, 4, [(1, 2), (3, 3), (4, 4), (2, 5)], (1, 1), (5, 5)) 8 >>> shortest_path(3, 1, [(2, 2)], (1, 1), (3, 3)) 4 >>> shortest_path(3, 3, [(1, 2), (2, 1), (2, 2)], (1, 1), (3, 3)) -1 >>> shortest_path(1, 0, [], (1, 1), (1, 1)) 0 >>> shortest_path(5, 0, [], (1, 1), (5, 5)) 8","solution":"from collections import deque def shortest_path(n, b, barriers, start, end): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] sx, sy = start ex, ey = end grid = [[0] * n for _ in range(n)] for x, y in barriers: grid[x - 1][y - 1] = 1 queue = deque([(sx - 1, sy - 1, 0)]) # (x, y, steps) visited = set() visited.add((sx - 1, sy - 1)) while queue: x, y, steps = queue.popleft() if (x, y) == (ex - 1, ey - 1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def smallest_subarray_sum(n: int, arr: List[int]) -> int: Finds the smallest sum of any contiguous subarray in the array. :param n: Number of elements in the array :param arr: List of integers :return: Smallest sum of any contiguous subarray >>> smallest_subarray_sum(5, [3, -4, 2, -3, -1]) -6 >>> smallest_subarray_sum(4, [1, 2, 3, 4]) 1","solution":"def smallest_subarray_sum(n, arr): Finds the smallest sum of any contiguous subarray in the array. :param n: Number of elements in the array :param arr: List of integers :return: Smallest sum of any contiguous subarray min_current = arr[0] min_global = arr[0] for i in range(1, n): min_current = min(arr[i], min_current + arr[i]) if min_current < min_global: min_global = min_current return min_global # Example usage: # n = 5 # arr = [3, -4, 2, -3, -1] # print(smallest_subarray_sum(n, arr)) # Output: -6"},{"question":"import math def calculate_total_time(num_competitors, swimming_time, cycling_time, running_time, strengths): Calculates the total time for each competitor to finish the triathlon. Parameters: num_competitors (int): The number of competitors. swimming_time (int): The duration of the swimming discipline. cycling_time (int): The duration of the cycling discipline. running_time (int): The duration of the running discipline. strengths (list of tuples): A list where each tuple contains three integers si, ci, ri representing the strengths of the i-th competitor in swimming, cycling, and running. Returns: list: Total times for each competitor.","solution":"import math def calculate_total_time(num_competitors, swimming_time, cycling_time, running_time, strengths): Calculates the total time for each competitor to finish the triathlon. Parameters: num_competitors (int): The number of competitors. swimming_time (int): The duration of the swimming discipline. cycling_time (int): The duration of the cycling discipline. running_time (int): The duration of the running discipline. strengths (list of tuples): A list where each tuple contains three integers si, ci, ri representing the strengths of the i-th competitor in swimming, cycling, and running. Returns: list: Total times for each competitor. total_times = [] for si, ci, ri in strengths: effective_swimming_time = math.ceil(swimming_time / si) effective_cycling_time = math.ceil(cycling_time / ci) effective_running_time = math.ceil(running_time / ri) total_time = effective_swimming_time + effective_cycling_time + effective_running_time total_times.append(total_time) return total_times"},{"question":"from typing import List def length_of_lis(nums: List[int]) -> int: Determine the length of the longest increasing subsequence (LIS) in a given array of integers. >>> length_of_lis([5, 2, 8, 6, 3, 6]) 3 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([7]) 1 >>> length_of_lis([1, 3, 5, 4, 7]) 4 >>> length_of_lis([2, 2, 2, 2, 2]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> length_of_lis([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1","solution":"def length_of_lis(nums): if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] will be the length of LIS ending at index i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_absolute_difference(n: int, arr: List[int]) -> int: Given an array of integers, find the maximum absolute difference between any two elements such that the larger element appears after the smaller element in the array. >>> max_absolute_difference(6, [2, 3, 10, 6, 4, 8]) == 8 >>> max_absolute_difference(5, [-10, -5, 0, 5, 10]) == 20 >>> max_absolute_difference(4, [5, 5, 5, 5]) == 0 >>> max_absolute_difference(1, [1]) == 0 >>> max_absolute_difference(2, [5, 1]) == 0 >>> max_absolute_difference(5, [1, -2, 3, -4, 5]) == 9 >>> max_absolute_difference(5, [1, 2, 3, 4, 5]) == 4","solution":"def max_absolute_difference(n, arr): if n < 2: return 0 max_diff = 0 min_value = arr[0] for i in range(1, n): max_diff = max(max_diff, arr[i] - min_value) min_value = min(min_value, arr[i]) return max_diff"},{"question":"def max_total_score(n: int, M: int, problems: List[Tuple[int, int]]) -> int: Calculate the maximum total score that can be obtained by selecting a subset of problems without exceeding the available time M. >>> max_total_score(3, 50, [(20, 10), (30, 20), (50, 30)]) 80 >>> max_total_score(1, 10, [(100, 10)]) 100 >>> max_total_score(1, 10, [(100, 20)]) 0 >>> max_total_score(3, 5, [(20, 10), (30, 20), (50, 30)]) 0 >>> max_total_score(4, 10, [(10, 1), (20, 2), (30, 3), (40, 8)]) 60 >>> max_total_score(100, 100, [(i + 1, i + 1) for i in range(100)]) 100","solution":"def max_total_score(n, M, problems): # Initialize the DP table dp = [0] * (M + 1) # Iterate over each problem for score, time in problems: # Update the DP table in reverse to avoid overwriting for m in range(M, time - 1, -1): dp[m] = max(dp[m], dp[m - time] + score) return dp[M]"},{"question":"import heapq from typing import List, Tuple def median_game(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Simulate the game and determine the median after each round for each test case. >>> median_game([(5, [1, 5, 3, 4, 2]), (3, [6, 8, 7])]) ['1 3 3 3 3', '6 7 7'] def parse_input(input_str: str) -> List[Tuple[int, List[int]]]: Parse the input string to extract test cases details. >>> parse_input(\\"2n5n1 5 3 4 2n3n6 8 7\\") [(5, [1, 5, 3, 4, 2]), (3, [6, 8, 7])] # Unit Tests def test_median_game_case1(): input_str = \\"2n5n1 5 3 4 2n3n6 8 7\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['1 3 3 3 3', '6 7 7'] def test_median_game_single_element(): input_str = \\"1n1n10\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['10'] def test_median_game_two_elements(): input_str = \\"1n2n10 20\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['10 15'] def test_median_game_three_elements(): input_str = \\"1n3n10 20 30\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['10 15 20'] def test_median_game_even_elements(): input_str = \\"1n4n10 20 30 40\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['10 15 20 25'] def test_median_game_large_numbers(): input_str = \\"1n5n1000000000 999999999 999999998 999999997 999999996\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['1000000000 999999999 999999999 999999998 999999998'] def test_median_game_repeated_elements(): input_str = \\"1n5n5 5 5 5 5\\" test_cases = parse_input(input_str) result = median_game(test_cases) assert result == ['5 5 5 5 5']","solution":"import heapq def median_game(test_cases): results = [] for n, numbers in test_cases: min_heap = [] # This heap keeps the larger half max_heap = [] # This heap keeps the smaller half (as negative numbers to use min-heap properties) medians = [] for number in numbers: if len(max_heap) == 0 or number <= -max_heap[0]: heapq.heappush(max_heap, -number) else: heapq.heappush(min_heap, number) # Balance the heaps if necessary if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) # Append current median to results if len(max_heap) == len(min_heap): median = (-max_heap[0] + min_heap[0]) // 2 else: median = -max_heap[0] medians.append(median) results.append(' '.join(map(str, medians))) return results # Reading input data and preparing the test cases def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) numbers = list(map(int, lines[index + 1].split())) test_cases.append((n, numbers)) index += 2 return test_cases # Example usage input_str = 2 5 1 5 3 4 2 3 6 8 7 test_cases = parse_input(input_str) print(median_game(test_cases))"},{"question":"def count_distinct_prefix_sums(n: int, arr: List[int]) -> int: Determine how many distinct prefix sums can be formed from the array's prefixes. >>> count_distinct_prefix_sums(4, [1, 2, 2, 1]) 4 >>> count_distinct_prefix_sums(1, [10]) 1 >>> count_distinct_prefix_sums(5, [2, 2, 2, 2, 2]) 5 >>> count_distinct_prefix_sums(4, [1, 2, 3, 4]) 4 >>> count_distinct_prefix_sums(4, [4, 3, 2, 1]) 4 >>> count_distinct_prefix_sums(6, [1, 3, 2, 5, 2, 1]) 6 >>> count_distinct_prefix_sums(3, [10000, 10000, 10000]) 3 >>> count_distinct_prefix_sums(100000, [1] * 100000) 100000","solution":"def count_distinct_prefix_sums(n, arr): prefix_sums = set() current_sum = 0 for num in arr: current_sum += num prefix_sums.add(current_sum) return len(prefix_sums)"},{"question":"def longest_uniform_substring(t: int, strings: List[str]) -> List[int]: Determines the length of the longest substring that contains no more than one unique character. Parameters: t (int): The number of test cases. strings (list of str): List of strings consisting of characters 'a' and 'b'. Returns: list of int: List of the lengths of the longest substrings for each input string. >>> longest_uniform_substring(3, [\\"ababab\\", \\"aaaa\\", \\"bbaabb\\"]) == [1, 4, 2] >>> longest_uniform_substring(2, [\\"a\\", \\"b\\"]) == [1, 1] >>> longest_uniform_substring(2, [\\"aaabbb\\", \\"bbbaaa\\"]) == [3, 3] >>> longest_uniform_substring(1, [\\"abababab\\"]) == [1] >>> longest_uniform_substring(1, [\\"a\\" * 100]) == [100] >>> longest_uniform_substring(1, [\\"b\\" * 100]) == [100] >>> longest_uniform_substring(1, [\\"a\\" * 50 + \\"b\\" * 50]) == [50] >>> longest_uniform_substring(1, [\\"\\"]) == [0]","solution":"def longest_uniform_substring(t, strings): Determines the length of the longest substring that contains no more than one unique character. Parameters: t (int): The number of test cases. strings (list of str): List of strings consisting of characters 'a' and 'b'. Returns: list of int: List of the lengths of the longest substrings for each input string. results = [] for s in strings: max_length = 0 current_char = '' current_length = 0 for char in s: if char == current_char: current_length += 1 else: max_length = max(max_length, current_length) current_char = char current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results"},{"question":"def count_different_pairs(lst: List[int]) -> int: Given a list of integers, return the count of pairs (i, j) where 0 ≤ i < j < length of the list and the elements at these indices are different. >>> count_different_pairs([1, 2, 3, 4, 5]) 10 >>> count_different_pairs([1, 1, 1, 1]) 0 >>> count_different_pairs([1, 1, 2, 2]) 4 >>> count_different_pairs([1]) 0 >>> count_different_pairs([i for i in range(1000)]) 499500","solution":"def count_different_pairs(lst): Given a list of integers, return the count of pairs (i, j) where 0 ≤ i < j < length of the list and the elements at these indices are different. n = len(lst) counter = 0 for i in range(n): for j in range(i + 1, n): if lst[i] != lst[j]: counter += 1 return counter"},{"question":"def coin_game(n: int) -> Tuple[str, int]: Determine the winner and the maximum number of coins they collect when Alice and Bob play optimally. >>> coin_game(10) ('Alice', 6) >>> coin_game(15) ('Bob', 8)","solution":"def coin_game(n): if n % 2 == 1: return (\\"Alice\\", (n // 2) + 1) else: return (\\"Bob\\", (n // 2))"},{"question":"from typing import List, Tuple def rearrange_sequence(n: int, nums: List[int]) -> str: # To be implemented pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: For each test case, check if it is possible to rearrange the sequence such that no two adjacent integers are the same. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer 'n' and a list of 'n' integers. Returns: List[str]: Output string for each test case, \\"YES <rearranged sequence>\\" or \\"NO\\" if not possible. >>> process_test_cases(3, [(4, [1, 2, 2, 3]), (5, [2, 3, 3, 3, 3]), (3, [1, 1, 2])]) [\\"YES 1 2 3 2\\", \\"NO\\", \\"YES 1 2 1\\"] pass from solution import process_test_cases def test_single_test_case(): T = 1 test_cases = [ (4, [1, 2, 2, 3]) ] assert process_test_cases(T, test_cases) == [\\"YES 1 2 3 2\\"] def test_multiple_test_cases(): T = 3 test_cases = [ (4, [1, 2, 2, 3]), (5, [2, 3, 3, 3, 3]), (3, [1, 1, 2]) ] results = process_test_cases(T, test_cases) assert results[0] == \\"YES 1 2 3 2\\" assert results[1] == \\"NO\\" assert results[2] == \\"YES 1 2 1\\" def test_impossible_cases(): T = 2 test_cases = [ (5, [1, 1, 1, 1, 2]), (3, [1, 1, 1]) ] assert process_test_cases(T, test_cases) == [\\"NO\\", \\"NO\\"] def test_all_same_elements(): T = 1 test_cases = [ (4, [1, 1, 1, 1]) ] assert process_test_cases(T, test_cases) == [\\"NO\\"] def test_rearrange_possible(): T = 2 test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [4, 4, 3, 5]) ] results = process_test_cases(T, test_cases) assert results[0] == \\"YES 1 2 3 4 5\\" assert results[1] == \\"YES 4 3 4 5\\"","solution":"from collections import Counter import heapq def rearrange_sequence(n, nums): count = Counter(nums) max_count = max(count.values()) if max_count > (n + 1) // 2: return \\"NO\\" max_heap = [(-freq, num) for num, freq in count.items()] heapq.heapify(max_heap) result = [] prev_freq, prev_num = 0, None while max_heap: freq, num = heapq.heappop(max_heap) result.append(num) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_num)) prev_freq, prev_num = freq + 1, num return \\"YES {}\\".format(\\" \\".join(map(str, result))) def process_test_cases(T, test_cases): results = [] for t in range(T): n, nums = test_cases[t] result = rearrange_sequence(n, nums) results.append(result) return results"},{"question":"def final_coordinates(n: int, moves: str) -> tuple: Returns the final coordinates of the robot after a given sequence of moves. Parameters: n (int): The number of moves moves (str): The sequence of moves Returns: tuple: Final coordinates (x, y) >>> final_coordinates(5, \\"RRDLL\\") (0, -1) >>> final_coordinates(3, \\"UUU\\") (0, 3) >>> final_coordinates(4, \\"DDDD\\") (0, -4) >>> final_coordinates(6, \\"LLRRLL\\") (-2, 0) >>> final_coordinates(8, \\"ULDRULDR\\") (0, 0) >>> final_coordinates(5, \\"RRLDU\\") (1, 0)","solution":"def final_coordinates(n, moves): Returns the final coordinates of the robot after a given sequence of moves. Parameters: n (int): The number of moves moves (str): The sequence of moves Returns: tuple: Final coordinates (x, y) x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return (x, y)"},{"question":"def min_palindromic_substrings(s: str) -> int: Returns the minimum number of palindromic substrings into which the given binary string should be divided. >>> min_palindromic_substrings('0') == 1 >>> min_palindromic_substrings('1') == 1 >>> min_palindromic_substrings('00') == 2 >>> min_palindromic_substrings('11') == 2 >>> min_palindromic_substrings('01') == 2 >>> min_palindromic_substrings('10') == 2 >>> min_palindromic_substrings('10101') == 5 >>> min_palindromic_substrings('11111') == 5 >>> min_palindromic_substrings('00000') == 5 >>> min_palindromic_substrings('110110') == 6 >>> min_palindromic_substrings('1001') == 4 >>> min_palindromic_substrings('10111101') == 8 >>> min_palindromic_substrings('1' * 100000) == 100000 >>> min_palindromic_substrings('0' * 100000) == 100000 >>> min_palindromic_substrings('01' * 50000) == 100000","solution":"def min_palindromic_substrings(s): Returns the minimum number of palindromic substrings into which the given binary string should be divided. # Rational (since each character itself is a palindrome) return len(s)"},{"question":"def leaderboard_operations(n: int, q: int, operations: List[str]) -> List[str]: Function to process leaderboard operations. Args: n : int : number of players q : int : number of queries operations : list : list of strings representing the operations Returns: list : the results of the 'top k' operations pass # Unit Tests def test_leaderboard_operations_case_1(): n = 5 q = 6 operations = [ \\"add 1 50\\", \\"add 2 100\\", \\"add 1 20\\", \\"top 2\\", \\"add 3 25\\", \\"top 2\\" ] expected = [ \\"2 1\\", \\"2 1\\" ] assert leaderboard_operations(n, q, operations) == expected def test_leaderboard_operations_case_2(): n = 3 q = 4 operations = [ \\"add 1 10\\", \\"add 2 20\\", \\"top 1\\", \\"add 1 15\\" ] expected = [ \\"2\\" ] assert leaderboard_operations(n, q, operations) == expected def test_leaderboard_operations_case_3(): n = 4 q = 5 operations = [ \\"add 1 10\\", \\"add 2 5\\", \\"add 3 20\\", \\"top 2\\", \\"add 4 30\\" ] expected = [ \\"3 1\\" ] assert leaderboard_operations(n, q, operations) == expected def test_leaderboard_operations_case_4(): n = 2 q = 3 operations = [ \\"add 1 10\\", \\"top 1\\", \\"add 2 15\\" ] expected = [ \\"1\\" ] assert leaderboard_operations(n, q, operations) == expected def test_leaderboard_operations_case_5(): n = 1 q = 2 operations = [ \\"add 1 50\\", \\"top 1\\" ] expected = [ \\"1\\" ] assert leaderboard_operations(n, q, operations) == expected","solution":"def leaderboard_operations(n, q, operations): Function to process leaderboard operations. Args: n : int : number of players. q : int : number of queries. operations : list : list of strings representing the operations. Returns: list : the results of the 'top k' operations. from collections import defaultdict, deque # Initialize player scores and operation order scores = defaultdict(int) order = deque() # To keep track of the order of scores added result = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": player = int(parts[1]) score = int(parts[2]) if player not in scores: order.append(player) scores[player] += score elif parts[0] == \\"top\\": k = int(parts[1]) # Get top k players top_players = sorted(scores.items(), key=lambda x: (-x[1], order.index(x[0])))[:k] top_players_ids = [str(player) for player, _ in top_players] result.append(\\" \\".join(top_players_ids)) return result"},{"question":"def total_occupied_time(n: int, intervals: List[Tuple[int, int]]) -> int: Given an ordered list of time intervals representing user sessions on a website, compute the total duration for which the website was user-occupied. The intervals might overlap, and in such cases, the time should be counted only once. Args: n: an integer representing the number of user sessions. intervals: a list of tuples, where each tuple contains two space-separated integers representing the start and end time of a user session. Returns: an integer representing the total duration in seconds for which the website was occupied by at least one user session. Examples: >>> total_occupied_time(5, [(1, 3), (2, 5), (6, 8), (8, 10), (3, 6)]) 9 >>> total_occupied_time(3, [(1, 4), (2, 6), (3, 5)]) 5 >>> total_occupied_time(3, [(1, 3), (4, 6), (7, 9)]) 6","solution":"def total_occupied_time(n, intervals): if n == 0: return 0 # Sort the intervals by start time intervals.sort() # Initialize merged intervals with the first interval merged_intervals = [intervals[0]] for i in range(1, n): current_start, current_end = intervals[i] last_start, last_end = merged_intervals[-1] if current_start <= last_end: # Merge intervals if they overlap merged_intervals[-1] = (last_start, max(last_end, current_end)) else: # Otherwise, add the current interval as a new one merged_intervals.append((current_start, current_end)) # Calculate the total duration of merged intervals total_duration = sum(end - start for start, end in merged_intervals) return total_duration"},{"question":"def max_non_overlapping_activities(activities): Returns the maximum number of non-overlapping activities that can be completed in a single day. >>> max_non_overlapping_activities([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9)]) 4 >>> max_non_overlapping_activities([(1, 5), (2, 6), (6, 8), (8, 10)]) 3 >>> max_non_overlapping_activities([(0, 1)]) 1 >>> max_non_overlapping_activities([]) 0 >>> max_non_overlapping_activities([(1, 3), (2, 3), (3, 5)]) 2 >>> max_non_overlapping_activities([(i, i+1) for i in range(0, 24, 1)]) 24","solution":"def max_non_overlapping_activities(activities): Returns the maximum number of non-overlapping activities that can be completed in a single day. # Sort activities primarily by end time, and then by start time if end time is the same. activities.sort(key=lambda x: (x[1], x[0])) count = 0 last_end_time = 0 for start, end in activities: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def find_max_safety_score(n: int, m: int, grid: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Returns the maximum safety score within the specified rectangular areas for each query. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list[list[int]]): 2D list representing the grid of safety scores. queries (list[tuple[int, int, int, int]]): List of queries, each represented as a tuple (r1, c1, r2, c2). Returns: list[int]: List of maximum safety scores for each query. >>> n, m = 4, 5 >>> grid = [ ... [9, 2, 4, 6, 1], ... [3, 7, 8, 5, 0], ... [2, 3, 6, 4, 8], ... [5, 1, 0, 2, 3] ... ] >>> queries = [(1, 1, 2, 3), (2, 2, 4, 4), (1, 3, 3, 5)] >>> find_max_safety_score(n, m, grid, queries) [9, 8, 8] >>> n, m = 3, 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [(1, 1, 3, 3), (2, 2, 3, 3)] >>> find_max_safety_score(n, m, grid, queries) [9, 9] >>> n, m = 2, 2 >>> grid = [ ... [0, -1], ... [-2, -3] ... ] >>> queries = [(1, 1, 2, 2), (1, 1, 1, 2), (2, 1, 2, 2)] >>> find_max_safety_score(n, m, grid, queries) [0, 0, -2] >>> n, m = 1, 1 >>> grid = [ ... [42] ... ] >>> queries = [(1, 1, 1, 1)] >>> find_max_safety_score(n, m, grid, queries) [42] >>> n, m = 3, 3 >>> grid = [ ... [3, 3, 3], ... [3, 3, 3], ... [3, 3, 3] ... ] >>> queries = [(1, 1, 1, 1), (1, 1, 2, 2)] >>> find_max_safety_score(n, m, grid, queries) [3, 3]","solution":"def find_max_safety_score(n, m, grid, queries): Returns the maximum safety score within the specified rectangular areas for each query. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list[list[int]]): 2D list representing the grid of safety scores. queries (list[tuple[int, int, int, int]]): List of queries, each represented as a tuple (r1, c1, r2, c2). Returns: list[int]: List of maximum safety scores for each query. results = [] for r1, c1, r2, c2 in queries: max_safety = -float('inf') for i in range(r1-1, r2): for j in range(c1-1, c2): if grid[i][j] > max_safety: max_safety = grid[i][j] results.append(max_safety) return results"},{"question":"from typing import List, Tuple def maximum_flow(n: int, m: int, s: int, t: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum flow from source \`s\` to sink \`t\` in a directed graph. Args: n (int): The number of nodes. m (int): The number of edges. s (int): The source node. t (int): The sink node. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, capacity). Returns: int: The maximum flow from the source node to the sink node. Example: >>> maximum_flow(4, 5, 1, 4, [(1, 2, 100), (1, 3, 100), (2, 3, 1), (2, 4, 100), (3, 4, 100)]) 200 >>> maximum_flow(4, 2, 1, 4, [(1, 2, 100), (3, 4, 100)]) 0","solution":"from collections import deque, defaultdict class MaxFlow: def __init__(self, n): self.n = n self.adjacency_list = defaultdict(list) self.capacity = defaultdict(lambda: defaultdict(int)) def add_edge(self, u, v, c): self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) # Add a reverse edge self.capacity[u][v] += c # Handle multiple edges by summing up capacities def bfs(self, s, t, parent): visited = [False] * (self.n + 1) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for v in self.adjacency_list[u]: if not visited[v] and self.capacity[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == t: return True return False def edmonds_karp(self, s, t): parent = [-1] * (self.n + 1) max_flow = 0 while self.bfs(s, t, parent): path_flow = float('Inf') v = t while v != s: u = parent[v] path_flow = min(path_flow, self.capacity[u][v]) v = u v = t while v != s: u = parent[v] self.capacity[u][v] -= path_flow self.capacity[v][u] += path_flow v = u max_flow += path_flow return max_flow def maximum_flow(n, m, s, t, edges): max_flow_solver = MaxFlow(n) for u, v, c in edges: max_flow_solver.add_edge(u, v, c) return max_flow_solver.edmonds_karp(s, t)"},{"question":"def best_selling_product(n: int, d: int, sales_records: List[List[int]]) -> int: Identifies the best-selling product based on the sales records. Parameters: n (int): Number of products. d (int): Number of days in the sales records. sales_records (List[List[int]]): A list of lists where each inner list contains the daily sales of a product. Returns: int: The product ID (1-based index) of the best-selling product. pass # Test cases def test_best_selling_product(): assert best_selling_product(3, 5, [ [10, 20, 30, 40, 50], [5, 10, 15, 20, 25], [15, 15, 15, 15, 15] ]) == 1 assert best_selling_product(2, 3, [ [7, 8, 9], [10, 10, 10] ]) == 2 assert best_selling_product(4, 4, [ [5, 5, 5, 5], [2, 2, 2, 2], [5, 5, 5, 5], [1, 1, 1, 1] ]) == 1 assert best_selling_product(1, 1, [ [100] ]) == 1 assert best_selling_product(3, 2, [ [0, 1], [1, 0], [0, 0] ]) == 1 assert best_selling_product(2, 3, [ [1, 1, 1], [1, 1, 1] ]) == 1","solution":"def best_selling_product(n, d, sales_records): Identifies the best-selling product based on the sales records. Parameters: n (int): Number of products. d (int): Number of days in the sales records. sales_records (List[List[int]]): A list of lists where each inner list contains the daily sales of a product. Returns: int: The product ID (1-based index) of the best-selling product. max_sales = -1 best_product_id = -1 for i in range(n): total_sales = sum(sales_records[i]) if total_sales > max_sales: max_sales = total_sales best_product_id = i + 1 elif total_sales == max_sales and i + 1 < best_product_id: best_product_id = i + 1 return best_product_id # Helper function for handling input and output def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) d = int(data[1]) sales_records = [] index = 2 for i in range(n): sales_records.append(list(map(int, data[index:index + d]))) index += d print(best_selling_product(n, d, sales_records))"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring within a given string. A palindromic string is a string that reads the same backwards as forwards. Args: s (str): The input string with a length between 1 and 1000. Returns: str: The longest palindromic substring of s. Example: >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" # or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of s. n = len(s) if n == 0: return \\"\\" longest = s[0] for i in range(n): # Check for odd-length palindromes for j in range(min(i + 1, n - i)): if s[i - j] != s[i + j]: break if 2 * j + 1 > len(longest): longest = s[i - j:i + j + 1] # Check for even-length palindromes for j in range(min(i + 1, n - i - 1)): if s[i - j] != s[i + j + 1]: break if 2 * j + 2 > len(longest): longest = s[i - j:i + j + 2] return longest"},{"question":"from typing import List def can_satisfy_all_friends(dishes: List[str], friends: List[str]) -> str: Returns \\"YES\\" if the dishes can satisfy all friends' flavor preferences, otherwise returns \\"NO\\". >>> can_satisfy_all_friends([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], [\\"ab\\", \\"cd\\", \\"ef\\", \\"gh\\"]) 'YES' >>> can_satisfy_all_friends([\\"abc\\", \\"def\\"], [\\"ab\\", \\"fg\\", \\"xyz\\"]) 'NO'","solution":"def can_satisfy_all_friends(dishes, friends): Returns \\"YES\\" if the dishes can satisfy all friends' flavor preferences, otherwise returns \\"NO\\". # Create a set to keep all available ingredients in the dishes available_ingredients = set() # Add all ingredients from the dishes to the set for dish in dishes: available_ingredients.update(dish) # Check if each friend's favorite ingredients are met for friend in friends: satisfied = False for ingredient in friend: if ingredient in available_ingredients: satisfied = True break if not satisfied: return \\"NO\\" return \\"YES\\""},{"question":"def team_skill_levels(m: int, skills: List[int]) -> List[int]: Return the skill levels of teams of three consecutive students. >>> team_skill_levels(5, [1, 2, 3, 4, 5]) [6, 9, 12] >>> team_skill_levels(3, [1, 1, 1]) [3] >>> team_skill_levels(4, [1, 2, 3, 10]) [6, 15] >>> team_skill_levels(6, [4, 4, 4, 4, 4, 4]) [12, 12, 12, 12] >>> team_skill_levels(6, [1000, 999, 998, 997, 996, 995]) [2997, 2994, 2991, 2988] >>> team_skill_levels(7, [10, 20, 30, 40, 50, 60, 70]) [60, 90, 120, 150, 180]","solution":"def team_skill_levels(m, skills): Return the skill levels of teams of three consecutive students. Parameters: m (int): The number of students skills (list of int): The skill levels of the students Returns: list of int: The skill levels of each consecutive team of three students return [skills[i] + skills[i+1] + skills[i+2] for i in range(m - 2)]"},{"question":"def max_sum_of_candies(n: int, q: int, candies: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Return the maximum sum of candies you can collect from the specified subarray by selecting at most k consecutive boxes. Args: n (int): The number of boxes. q (int): The number of queries. candies (List[int]): A list where the ith element represents the number of candies in the ith box. queries (List[Tuple[int, int, int]]): A list of tuples where each tuple contains the parameters (l, r, k) of the query. Returns: List[int]: A list of integers where the ith integer is the maximum sum of candies for the ith query from the specified subarray by selecting at most k consecutive boxes. >>> max_sum_of_candies(7, 3, [3, 1, 4, 1, 5, 9, 2], [(1, 5, 3), (2, 7, 2), (3, 6, 1)]) [10, 14, 9] >>> max_sum_of_candies(5, 2, [5, 8, 3, 6, 7], [(1, 1, 1), (3, 3, 1)]) [5, 3]","solution":"def max_sum_of_candies(n, q, candies, queries): def max_sum_subarray(array, k): max_sum = curr_sum = sum(array[:k]) for i in range(len(array) - k): curr_sum += array[i + k] - array[i] max_sum = max(max_sum, curr_sum) return max_sum results = [] for query in queries: l, r, k = query subarray = candies[l - 1 : r] # Convert to 0-based index results.append(max_sum_subarray(subarray, k)) return results"},{"question":"def can_form_string(s: str, t: str) -> str: Determines if it is possible to obtain the string t by performing some number of removal operations on the string s. Args: s (str): Input string s. t (str): Target string t. Returns: str: 'YES' if t can be obtained from s, otherwise 'NO'. Examples: >>> can_form_string(\\"aebdc\\", \\"abc\\") 'YES' >>> can_form_string(\\"abc\\", \\"axc\\") 'NO'","solution":"def can_form_string(s, t): Determines if it is possible to obtain the string t by performing some number of removal operations on the string s. Args: s (str): Input string s. t (str): Target string t. Returns: str: 'YES' if t can be obtained from s, otherwise 'NO'. m, n = len(t), len(s) i = j = 0 while i < m and j < n: if t[i] == s[j]: i += 1 j += 1 return \\"YES\\" if i == m else \\"NO\\""},{"question":"def max_profit(prices): Calculates the maximum profit that can be achieved from a list of stock prices. If no profit can be achieved, returns \\"NO PROFIT\\". :param prices: List of integers representing stock prices. :return: Maximum possible profit or \\"NO PROFIT\\" >>> max_profit([3, 1, 4, 1, 5, 9]) == 8 >>> max_profit([7, 6, 4, 3]) == \\"NO PROFIT\\" def test_max_profit_standard_case(): assert max_profit([3, 1, 4, 1, 5, 9]) == 8 def test_max_profit_no_profit_case(): assert max_profit([7, 6, 4, 3]) == \\"NO PROFIT\\" def test_max_profit_single_increase(): assert max_profit([1, 2]) == 1 def test_max_profit_alternating_prices(): assert max_profit([3, 1, 3, 1, 3, 1, 3]) == 2 def test_max_profit_increasing_prices(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_decreasing_prices(): assert max_profit([5, 4, 3, 2, 1]) == \\"NO PROFIT\\" def test_max_profit_large_range(): assert max_profit([1000000, 999999, 999998, 1, 1000000]) == 999999 def test_max_profit_all_same_prices(): assert max_profit([3, 3, 3, 3, 3]) == \\"NO PROFIT\\" def test_max_profit_min_max_prices(): assert max_profit([1, 1000000]) == 999999 def test_max_profit_edge_case(): assert max_profit([1, 1, 1, 1, 1, 5]) == 4 def test_max_profit_leading_ones_case(): assert max_profit([1, 1, 1, 1, 1]) == \\"NO PROFIT\\"","solution":"def max_profit(prices): Calculates the maximum profit that can be achieved from a list of stock prices. If no profit can be achieved, returns \\"NO PROFIT\\". :param prices: List of integers representing stock prices. :return: Maximum possible profit or \\"NO PROFIT\\" n = len(prices) # Initialize variables min_price = prices[0] max_profit = 0 # Traverse through the stock prices for price in prices[1:]: # Update max profit if current price minus min_price is greater max_profit = max(max_profit, price - min_price) # Update min price min_price = min(min_price, price) # Check if a profit was possible if max_profit > 0: return max_profit else: return \\"NO PROFIT\\""},{"question":"from typing import List, Tuple def find_safest_paths(n: int, m: int, k: int, restricted: List[int], wormholes: List[Tuple[int, int, int]]) -> List[int]: Determine the safest paths from one sector to all other sectors in the galaxy, avoiding restricted sectors. Args: n (int): The number of sectors. m (int): The number of wormholes. k (int): The number of restricted sectors. restricted (List[int]): List of restricted sector indices. wormholes (List[Tuple[int, int, int]]): List of wormholes represented as (ui, vi, wi) Returns: List[int]: The minimum risk level to travel from sector 1 to sector i for i in 1 to n. If a sector is unreachable, return -1. Example: >>> find_safest_paths(5, 6, 2, [3, 5], [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 2)]) [0, 2, -1, 9, -1] >>> find_safest_paths(3, 3, 1, [3], [(1, 2, 4), (2, 3, 6), (1, 3, 2)]) [0, 4, -1] >>> find_safest_paths(3, 3, 0, [], [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) [0, 1, 2] >>> find_safest_paths(4, 4, 2, [2, 4], [(1, 2, 3), (1, 3, 5), (2, 4, 4), (3, 4, 2)]) [0, -1, 5, -1] >>> find_safest_paths(3, 0, 0, [], []) [0, -1, -1] >>> find_safest_paths(4, 4, 0, [], [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 5)]) [0, 1, 2, 3] pass def test_find_safest_paths(): n = 5 m = 6 k = 2 restricted = [3, 5] wormholes = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 2) ] assert find_safest_paths(n, m, k, restricted, wormholes) == [0, 2, -1, 9, -1] # Additional test cases n = 3 m = 3 k = 1 restricted = [3] wormholes = [ (1, 2, 4), (2, 3, 6), (1, 3, 2) ] assert find_safest_paths(n, m, k, restricted, wormholes) == [0, 4, -1] n = 3 m = 3 k = 0 restricted = [] wormholes = [ (1, 2, 1), (2, 3, 1), (1, 3, 2) ] assert find_safest_paths(n, m, k, restricted, wormholes) == [0, 1, 2] n = 4 m = 4 k = 2 restricted = [2, 4] wormholes = [ (1, 2, 3), (1, 3, 5), (2, 4, 4), (3, 4, 2) ] assert find_safest_paths(n, m, k, restricted, wormholes) == [0, -1, 5, -1] def test_find_safest_paths_no_wormholes(): n = 3 m = 0 k = 0 restricted = [] wormholes = [] assert find_safest_paths(n, m, k, restricted, wormholes) == [0, -1, -1] def test_find_safest_paths_no_restrictions(): n = 4 m = 4 k = 0 restricted = [] wormholes = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 5) ] assert find_safest_paths(n, m, k, restricted, wormholes) == [0, 1, 2, 3]","solution":"import heapq def find_safest_paths(n, m, k, restricted, wormholes): # Create a graph graph = {i: [] for i in range(1, n + 1)} for ui, vi, wi in wormholes: if vi not in restricted: graph[ui].append((vi, wi)) # Dijkstra's algorithm using a priority queue. def dijkstra(start_node): min_heap = [(0, start_node)] # (risk, sector) risks = {i: float('inf') for i in range(1, n + 1)} risks[start_node] = 0 visited = set() while min_heap: current_risk, current_sector = heapq.heappop(min_heap) if current_sector in visited: continue visited.add(current_sector) for neighbor, risk in graph[current_sector]: if neighbor not in visited: new_risk = current_risk + risk if new_risk < risks[neighbor]: risks[neighbor] = new_risk heapq.heappush(min_heap, (new_risk, neighbor)) return risks risks = dijkstra(1) result = [] for i in range(1, n + 1): if risks[i] == float('inf'): result.append(-1) else: result.append(risks[i]) return result"},{"question":"def max_score(n: int, E: int, sequence: List[int]) -> int: Returns the maximum score Sereja can achieve given the sequence and initial energy. Args: n (int): The length of the sequence. E (int): The initial amount of energy. sequence (list): List of integers representing the sequence. Returns: int: The maximum score Sereja can achieve. Example: >>> max_score(5, 10, [1, 3, 2, 4, 5]) 15 >>> max_score(1, 0, [10]) 10","solution":"def max_score(n, E, sequence): Returns the maximum score Sereja can achieve given the sequence and initial energy. Args: n (int): The length of the sequence. E (int): The initial amount of energy. sequence (list): List of integers representing the sequence. Returns: int: The maximum score Sereja can achieve. # The optimal strategy in this problem context: just take the sum of the whole sequence # There's no need to use energy since adding all elements to score maximizes it. return sum(sequence)"},{"question":"def min_abs_difference(nums: List[int]) -> int: Given a list of N distinct positive integers, find the pair of integers (a, b) such that the absolute difference |a - b| is minimized. Return that minimum absolute difference. Args: nums (List[int]): List of N distinct positive integers. Returns: int: The minimum absolute difference. Examples: >>> min_abs_difference([1, 5, 9, 12, 13]) 1 >>> min_abs_difference([1, 2]) 1 >>> min_abs_difference([1000000000, 999999999, 999999998]) 1 >>> min_abs_difference([5, 2, 7, 3]) 1 >>> min_abs_difference(list(range(1, 100001))) 1","solution":"def min_abs_difference(nums): Returns the minimum absolute difference between any two integers in the list. # Sort the list nums.sort() # Initialize the minimum difference to a large number min_diff = float('inf') # Compare adjacent elements in the sorted list to find the minimum difference for i in range(len(nums) - 1): min_diff = min(min_diff, nums[i+1] - nums[i]) return min_diff"},{"question":"def sum_of_unique_prime_factors(n: int, arr: List[int]) -> List[int]: Given an array of \`n\` non-negative integers, modify it such that each element in the array is equal to the sum of its unique prime factors. If an element is zero or one, it should remain unchanged in the array. The unique prime factors of 6 (which are 2 and 3) sum to 5. For 10, the unique prime factors (2 and 5) sum to 7. 1 remains 1 as it has no prime factors. Args: n (int): the number of elements in the array arr (List[int]): list of n non-negative integers Returns: List[int]: the modified array where each element is replaced by the sum of its unique prime factors >>> sum_of_unique_prime_factors(5, [6, 10, 15, 1, 0]) [5, 7, 8, 1, 0] >>> sum_of_unique_prime_factors(1, [6]) [5] >>> sum_of_unique_prime_factors(1, [1]) [1] >>> sum_of_unique_prime_factors(1, [0]) [0] >>> sum_of_unique_prime_factors(3, [2, 3, 5]) [2, 3, 5] >>> sum_of_unique_prime_factors(4, [7, 11, 13, 17]) [7, 11, 13, 17] >>> sum_of_unique_prime_factors(6, [2, 4, 5, 8, 16, 20]) [2, 2, 5, 2, 2, 7]","solution":"def sum_of_unique_prime_factors(n, arr): Returns a new array where each element is replaced by the sum of its unique prime factors. Parameters: n : int : the number of elements in the array arr : list : the list of n non-negative integers Returns: list : the modified array where each element is replaced by the sum of its unique prime factors # Helper function to get prime factors using Sieve of Eratosthenes def sieve_prime_factors(max_num): sieve = [[] for _ in range(max_num + 1)] for i in range(2, max_num + 1): if not sieve[i]: for j in range(i, max_num + 1, i): sieve[j].append(i) return sieve max_element = max(arr) prime_factors = sieve_prime_factors(max_element) result = [] for number in arr: if number == 0 or number == 1: result.append(number) else: result.append(sum(prime_factors[number])) return result"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to make the string a palindrome. >>> min_replacements_to_palindrome(\\"abcca\\") == 1 >>> min_replacements_to_palindrome(\\"racecar\\") == 0 pass def test_example_cases(): assert min_replacements_to_palindrome(\\"abcca\\") == 1 assert min_replacements_to_palindrome(\\"racecar\\") == 0 def test_single_character(): assert min_replacements_to_palindrome(\\"a\\") == 0 def test_all_characters_same(): assert min_replacements_to_palindrome(\\"aaaaa\\") == 0 assert min_replacements_to_palindrome(\\"bbbbbb\\") == 0 def test_palindrome(): assert min_replacements_to_palindrome(\\"abcba\\") == 0 assert min_replacements_to_palindrome(\\"abba\\") == 0 def test_non_palindrome(): assert min_replacements_to_palindrome(\\"abcd\\") == 2 assert min_replacements_to_palindrome(\\"abcde\\") == 2 def test_even_length(): assert min_replacements_to_palindrome(\\"ab\\") == 1 assert min_replacements_to_palindrome(\\"aabb\\") == 2 def test_complex_cases(): assert min_replacements_to_palindrome(\\"abcdefg\\") == 3 assert min_replacements_to_palindrome(\\"abcdefedcba\\") == 0","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of character replacements required to make the string a palindrome. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"def max_energy_boost(N: int, L: int, energy_boosts: List[int]) -> int: Calculates the maximum energy boost a runner can accumulate after completing all the laps. Args: N : int : number of checkpoints L : int : number of laps energy_boosts : list : energy boost values at each checkpoint Returns: int : maximum energy boost >>> max_energy_boost(4, 3, [1, 2, 3, 4]) 30 >>> max_energy_boost(1, 1000000000, [5]) 5000000000 >>> max_energy_boost(2, 5, [1, 2]) 15 >>> max_energy_boost(3, 2, [1, 3, 5]) 18 >>> max_energy_boost(3, 1000000000, [1, 1, 1]) 3000000000","solution":"def max_energy_boost(N, L, energy_boosts): Calculates the maximum energy boost a runner can accumulate after completing all the laps. Args: N : int : number of checkpoints L : int : number of laps energy_boosts : list : energy boost values at each checkpoint Returns: int : maximum energy boost sum_energy_boosts = sum(energy_boosts) return sum_energy_boosts * L"},{"question":"def max_gem_value(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum possible sum of gem values Thalor can collect by moving from top-left to bottom-right corner. >>> max_gem_value(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_gem_value(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_gem_value(5, 1, [[1], [2], [3], [4], [5]]) 15 >>> max_gem_value(3, 3, [[4, 1, 5], [2, 7, 1], [3, 6, 8]]) 27 >>> max_gem_value(1, 1, [[100000]]) 100000","solution":"def max_gem_value(n, m, grid): Returns the maximum possible sum of gem values Thalor can collect by moving from top-left to bottom-right corner. dp = [[0] * m for _ in range(n)] # Initialize the top-left corner of the dp table dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def max_coins_per_case(n: int) -> int: Returns the maximum number of boxes that can contain a coin when there are n boxes and no two consecutive boxes can contain coins. >>> max_coins_per_case(1) 1 >>> max_coins_per_case(2) 1 >>> max_coins_per_case(5) 3 pass def solve(t: int, cases: List[int]) -> List[int]: Given t test cases and a list of n values, returns a list with the result for each test case. >>> solve(3, [1, 2, 5]) [1, 1, 3] >>> solve(1, [3]) [2] >>> solve(2, [4, 7]) [2, 4] pass","solution":"def max_coins_per_case(n): Returns the maximum number of boxes that can contain a coin when there are n boxes and no two consecutive boxes can contain coins. return (n + 1) // 2 def solve(t, cases): Given t test cases and a list of n values, returns a list with the result for each test case. return [max_coins_per_case(n) for n in cases]"},{"question":"def polygon_area(vertices): Returns the area of a polygon given its vertices using the Shoelace formula. Args: vertices (list of tuples): A list of tuples where each tuple (x, y) represents the coordinates of a vertex. Returns: float: The area of the polygon. >>> abs(polygon_area([(0, 0), (4, 0), (4, 3), (0, 3)]) - 12.0) < 1e-9 True >>> abs(polygon_area([(0, 0), (2, 0), (1, 1)]) - 1.0) < 1e-9 True >>> abs(polygon_area([(0, 0), (4, 0), (4, 3)]) - 6.0) < 1e-9 True >>> abs(polygon_area([(1, 1), (3, 1), (2, 3)]) - 2.0) < 1e-9 True >>> abs(polygon_area([(0, 0), (1, 0), (1, 1), (0, 1)]) - 1.0) < 1e-9 True >>> abs(polygon_area([(0, 0), (10, 0), (0, 10)]) - 50.0) < 1e-9 True >>> abs(polygon_area([(0, 0), (1, 0), (0, 1)]) - 0.5) < 1e-9 True pass","solution":"def polygon_area(vertices): Returns the area of a polygon given its vertices using the Shoelace formula. Args: vertices (list of tuples): A list of tuples where each tuple (x, y) represents the coordinates of a vertex. Returns: float: The area of the polygon. n = len(vertices) if n < 3: return 0.0 # A polygon can't have less than 3 vertices area = 0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 - x2 * y1 return abs(area) / 2.0 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) vertices = [] index = 1 for _ in range(n): x = int(data[index]) y = int(data[index + 1]) vertices.append((x, y)) index += 2 result = polygon_area(vertices) print(f\\"{result:.6f}\\")"},{"question":"def max_subarray_sum(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum sum of a subarray that contains at least one positive number or the largest element if all elements are non-positive. Args: t (int): Number of test cases. cases (List[Tuple[int, List[int]]]): List containing tuples with the number of elements and the array elements for each test case. Returns: List[int]: List of maximum sums for each test case. >>> max_subarray_sum(1, [(5, [-1, -2, -3, -4, -5])]) [-1] >>> max_subarray_sum(1, [(4, [1, 2, 3, 4])]) [10] >>> max_subarray_sum(1, [(5, [-1, 2, -3, 4, -5])]) [4]","solution":"def max_subarray_sum(t, cases): def max_subarray(arr): if all(x <= 0 for x in arr): return max(arr) current_max = global_max = float('-inf') for number in arr: if current_max < 0: current_max = 0 current_max += number if current_max > global_max: global_max = current_max return global_max results = [] for case in cases: n, arr = case results.append(max_subarray(arr)) return results"},{"question":"def max_energy_harness(n: int, crystals: List[int]) -> int: Determine the maximum total energy Elara can harness without selecting adjacent Mana Crystals. >>> max_energy_harness(5, [3, 2, 7, 10, 12]) 22","solution":"def max_energy_harness(n, crystals): if n == 0: return 0 elif n == 1: return crystals[0] # Initialize DP array dp = [0] * n dp[0] = crystals[0] dp[1] = max(crystals[0], crystals[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + crystals[i]) return dp[-1]"},{"question":"from typing import List def entangle_qubits(n: int) -> List[str]: Returns a list of strings where each string represents the final state of a pair of qubits after entanglement. Parameters: n (int): The number of qubits, guaranteed to be even (1 <= n <= 8). Returns: List[str]: The list of strings representing each Bell pair formed. pass def test_entangle_qubits_2(): assert entangle_qubits(2) == ['Bell Pair (0, 1)'] def test_entangle_qubits_4(): assert entangle_qubits(4) == ['Bell Pair (0, 1)', 'Bell Pair (2, 3)'] def test_entangle_qubits_6(): assert entangle_qubits(6) == ['Bell Pair (0, 1)', 'Bell Pair (2, 3)', 'Bell Pair (4, 5)'] def test_entangle_qubits_8(): assert entangle_qubits(8) == ['Bell Pair (0, 1)', 'Bell Pair (2, 3)', 'Bell Pair (4, 5)', 'Bell Pair (6, 7)']","solution":"from typing import List def entangle_qubits(n: int) -> List[str]: Returns a list of strings where each string represents the final state of a pair of qubits after entanglement. Parameters: n (int): The number of qubits, guaranteed to be even (1 <= n <= 8). Returns: List[str]: The list of strings representing each Bell pair formed. bell_pairs = [] for i in range(0, n, 2): bell_pairs.append(f'Bell Pair ({i}, {i+1})') return bell_pairs"},{"question":"def isWeightPossible(W: int, weights: List[int]) -> bool: Checks if there is a subarray in the given weights array that sums up to the target weight W. :param W: int, target weight :param weights: List[int], list of weights of packages :return: bool, True if there exists a subarray with sum W, otherwise False >>> isWeightPossible(7, [2, 4, 3, 7, 1]) True >>> isWeightPossible(5, [1, 2, 3]) True >>> isWeightPossible(11, [1, 2, 3, 4, 5]) False from typing import List","solution":"def isWeightPossible(W, weights): Checks if there is a subarray in the given weights array that sums up to the target weight W. :param W: int, target weight :param weights: List[int], list of weights of packages :return: bool, True if there exists a subarray with sum W, otherwise False current_sum = 0 start = 0 sum_dict = {} for i in range(len(weights)): current_sum += weights[i] # Check if current prefix sum is exactly W if current_sum == W: return True # Check if there is any subarray sum equal to W if (current_sum - W) in sum_dict: return True # Store the current prefix sum in sum dictionary sum_dict[current_sum] = i return False"},{"question":"from typing import List, Tuple def min_initial_updates(n: int, m: int, dependencies: List[Tuple[int, int]]) -> int: Given the number of files \`n\`, the number of dependencies \`m\` and the list of \`dependencies\`, find the minimum number of files that need to be initially updated to ensure that all files in the system will eventually be updated. Args: n (int): The number of files. m (int): The number of dependencies. dependencies (List[Tuple[int, int]]): A list of tuples representing dependencies. Returns: int: The minimum number of files that need to be initially updated. Example: >>> min_initial_updates(5, 4, [(1, 2), (2, 3), (4, 5), (5, 3)]) 2 def test_example_case(): n = 5 m = 4 dependencies = [(1, 2), (2, 3), (4, 5), (5, 3)] assert min_initial_updates(n, m, dependencies) == 2 def test_no_dependencies(): n = 3 m = 0 dependencies = [] assert min_initial_updates(n, m, dependencies) == 3 def test_single_chain_dependency(): n = 4 m = 3 dependencies = [(1, 2), (2, 3), (3, 4)] assert min_initial_updates(n, m, dependencies) == 1 def test_all_files_dependent_on_one(): n = 4 m = 3 dependencies = [(1, 2), (1, 3), (1, 4)] assert min_initial_updates(n, m, dependencies) == 1 def test_multiple_independent_components(): n = 6 m = 2 dependencies = [(1, 2), (3, 4)] assert min_initial_updates(n, m, dependencies) == 4","solution":"def min_initial_updates(n, m, dependencies): from collections import defaultdict, deque # Building the graph representation and in-degree count graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Find all nodes with 0 in-degree zero_in_degree = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) # The number of initially updated files is the count of nodes with 0 in-degree return len(zero_in_degree)"},{"question":"def max_min_difference(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given an integer array of size n, reorder the elements to maximize the minimum difference between adjacent elements and return the maximum possible value for each test case. >>> max_min_difference(3, [(4, [1, 2, 3, 4]), (5, [10, 20, 30, 40, 50]), (3, [5, 10, 5])]) [1, 10, 5] >>> max_min_difference(2, [(3, [1, 1, 1]), (4, [8, 10, 12, 14])]) [0, 2]","solution":"def max_min_difference(t, cases): results = [] for case in cases: _, array = case array.sort() reordered = [] left = 0 right = len(array) - 1 while left <= right: if left == right: reordered.append(array[left]) else: reordered.append(array[left]) reordered.append(array[right]) left += 1 right -= 1 min_diff = float('inf') for i in range(1, len(reordered)): min_diff = min(min_diff, abs(reordered[i] - reordered[i - 1])) results.append(min_diff) return results # Interpreter function to parse input and generate the required output def solve(): import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) index = 1 cases = [] for _ in range(t): n = int(data[index]) index += 1 array = list(map(int, data[index:index + n])) index += n cases.append((n, array)) results = max_min_difference(t, cases) for result in results: print(result)"},{"question":"from typing import List, Tuple, Optional def two_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Find two distinct indices i and j in the array such that nums[i] + nums[j] equals target and return them as a tuple. >>> two_sum([2, 7, 11, 15, 1], 9) (0, 1) >>> two_sum([2, 7, 11, 15, 8, 1], 9) in [(0, 1), (4, 5)] True >>> two_sum([1, 2], 5) None >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([100000000, 999999999], 1099999999) (0, 1)","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return num_to_index[complement], i num_to_index[num] = i return None"},{"question":"def arrange_marbles(r, c, k, quantities): Determine if Polycarp can arrange the marbles in a grid such that no two marbles of the same color are in the same row or column. Each row and column must contain unique colors. Args: r (int): Number of rows in the grid. c (int): Number of columns in the grid. k (int): Number of different colors of marbles. quantities (List[int]): List containing the quantities of marbles of each color. Returns: str: \\"YES\\" if it is possible to arrange the marbles, otherwise \\"NO\\". If \\"YES\\", then also print the arrangement of the grid. Example: >>> arrange_marbles(3, 3, 3, [3, 3, 3]) YES 1 2 3 3 1 2 2 3 1 >>> arrange_marbles(2, 3, 2, [4, 2]) NO","solution":"def arrange_marbles(r, c, k, quantities): import numpy as np total_marbles = sum(quantities) if total_marbles != r * c: return \\"NO\\" if max(quantities) > r or max(quantities) > c: return \\"NO\\" quantities_sorted_indices = sorted(range(k), key=lambda i: quantities[i]) result = np.zeros((r, c), dtype=int) row_pattern = [] color_index = 0 for i in range(k): color = quantities_sorted_indices[i] + 1 quantity = quantities[i] row_pattern.extend([color] * quantity) for i in range(r): result[i] = row_pattern[i*c:(i+1)*c] if len(set(quantities)) == 1: if quantities[0] == 1: result = [[(i+j) % r + 1 for j in range(c)] for i in range(r)] else: for i in range(r): result[i] = list(range(i+1, c + i + 1)) result[i] = list(map(lambda x: x if x <= c else x - c, result[i])) print(\\"YES\\") for row in result: print(' '.join(map(str, row))) return \\"YES\\""},{"question":"def min_length_substring_with_k_distinct(n: int, k: int, s: str) -> int: Find the minimal length of the substring of s which contains exactly k distinct letters. >>> min_length_substring_with_k_distinct(10, 2, 'abacabadab') 2 >>> min_length_substring_with_k_distinct(5, 1, 'aaaaa') 1 >>> min_length_substring_with_k_distinct(6, 3, 'abcdef') 3 >>> min_length_substring_with_k_distinct(8, 2, 'aabbccaa') 2 >>> min_length_substring_with_k_distinct(7, 2, 'aaabbbc') 2 >>> min_length_substring_with_k_distinct(5, 3, 'abcde') 3","solution":"def min_length_substring_with_k_distinct(n, k, s): from collections import defaultdict min_len = float('inf') left = 0 char_count = defaultdict(int) distinct_count = 0 for right in range(n): if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 while distinct_count == k: min_len = min(min_len, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 return min_len"},{"question":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): parent = [i for i in range(n)] rank = [0] * n mst = [] for edge in sorted(edges, key=lambda item: item[2]): u, v, w = edge u_root = find(parent, u) v_root = find(parent, v) if u_root != v_root: mst.append(edge) union(parent, rank, u_root, v_root) return mst def maximum_possible_minimal_road_toll(n, m, edges): Find the maximum possible minimal road toll within a group while maximizing the number of cities in that group. :param n: The number of cities (vertices) :param m: The number of roads (edges) :param edges: A list of tuples where each tuple represents a road with (u, v, w) -> cities u, v and road toll w :return: An integer representing the maximum possible minimal road toll within a group. >>> maximum_possible_minimal_road_toll(4, 5, [(0, 1, 4), (0, 2, 2), (1, 2, 1), (1, 3, 6), (2, 3, 3)]) == 3 >>> maximum_possible_minimal_road_toll(3, 3, [(0, 1, 1), (1, 2, 2), (0, 2, 3)]) == 2 >>> maximum_possible_minimal_road_toll(5, 7, [(0, 1, 10), (0, 2, 1), (1, 2, 8), (1, 3, 7), (2, 3, 3), (2, 4, 10), (3, 4, 2)]) == 7 pass","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): parent = [i for i in range(n)] rank = [0] * n mst = [] for edge in sorted(edges, key=lambda item: item[2]): u, v, w = edge u_root = find(parent, u) v_root = find(parent, v) if u_root != v_root: mst.append(edge) union(parent, rank, u_root, v_root) return mst def maximum_possible_minimal_road_toll(n, m, edges): mst = kruskal(n, edges) max_edge_weight_in_mst = max(edge[2] for edge in mst) return max_edge_weight_in_mst # Reading input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] for i in range(m): u = int(data[2 + 3 * i]) - 1 # to convert 1-based index to 0-based index v = int(data[3 + 3 * i]) - 1 w = int(data[4 + 3 * i]) edges.append((u, v, w)) result = maximum_possible_minimal_road_toll(n, m, edges) print(result) # If needed, uncomment the following line to read from standard input # if __name__ == \\"__main__\\": # main()"},{"question":"from typing import List def shortest_path_in_forest(grid: List[str]) -> int: Finds the shortest path in a forest grid from the top-left to the bottom-right corner avoiding swamps. Args: grid (List[str]): The forest grid represented as a list of strings with '.' as clear path and '#' as swamp. Returns: int: The length of the shortest path, or -1 if no such path exists. Example: >>> shortest_path_in_forest([ ... \\"....\\", ... \\"..\\", ... \\".#..\\", ... \\"....\\" ...]) 6 >>> shortest_path_in_forest([ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ...]) -1 from collections import deque def test_shortest_path_in_forest(): grid1 = [ \\"....\\", \\"..\\", \\".#..\\", \\"....\\" ] assert shortest_path_in_forest(grid1) == 6 grid2 = [ \\".#.\\", \\"#\\", \\".#.\\", ] assert shortest_path_in_forest(grid2) == -1 grid3 = [ \\".\\" ] assert shortest_path_in_forest(grid3) == 0 grid4 = [ \\"#..\\", \\"...\\", \\"...\\" ] assert shortest_path_in_forest(grid4) == -1 grid5 = [ \\"...\\", \\"...\\", \\"..#\\" ] assert shortest_path_in_forest(grid5) == -1 grid6 = [\\".\\" * 100 for _ in range(100)] assert shortest_path_in_forest(grid6) == 198","solution":"from collections import deque def shortest_path_in_forest(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (n-1, m-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) steps += 1 return -1 # Example Usage if __name__ == \\"__main__\\": grid1 = [ \\"....\\", \\"..\\", \\".#..\\", \\"....\\" ] result1 = shortest_path_in_forest(grid1) print(result1) # Output: 6 grid2 = [ \\".#.\\", \\"#\\", \\".#.\\", ] result2 = shortest_path_in_forest(grid2) print(result2) # Output: -1"},{"question":"def make_stones_even(n: int, stones: List[int]) -> str: Determines if it is possible to make the number of stones in each bag even. n : int - The number of bags stones : list of int - The initial number of stones in each bag Returns \\"YES\\" if it's possible to make all numbers of stones in the bags even, otherwise \\"NO\\". >>> make_stones_even(3, [5, 3, 2]) \\"YES\\" >>> make_stones_even(4, [1, 3, 5, 7]) \\"YES\\" >>> make_stones_even(3, [5, 3, 3]) \\"NO\\" >>> make_stones_even(4, [2, 4, 6, 1]) \\"NO\\" >>> make_stones_even(3, [4, 6, 8]) \\"YES\\" >>> make_stones_even(2, [0, 2]) \\"YES\\" >>> make_stones_even(2, [0, 0]) \\"YES\\" >>> make_stones_even(1, [0]) \\"YES\\" >>> make_stones_even(1, [1]) \\"NO\\" >>> make_stones_even(1, [10**9]) \\"YES\\"","solution":"def make_stones_even(n, stones): Determines if it is possible to make the number of stones in each bag even. n: int - The number of bags stones: list of int - The initial number of stones in each bag Returns \\"YES\\" if it's possible to make all numbers of stones in the bags even, otherwise \\"NO\\". odd_count = sum(1 for stone in stones if stone % 2 != 0) # If the number of bags with odd stones is even, we can pair them up and balance them, resulting in all bags having even stones if odd_count % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_complete_sessions(n: int, s: int, sessions: List[Tuple[int, int]]) -> str: Determine if Polycarp can complete all training sessions without his stamina falling below zero. >>> can_complete_sessions(3, 10, [(7, 5), (8, -2), (5, 3)]) \\"YES\\" >>> can_complete_sessions(3, 15, [(10, -5), (12, 4), (11, -6)]) \\"NO\\" Args: n (int): The number of training sessions. s (int): Initial stamina. sessions (List[Tuple[int, int]]): List of sessions, where each session is represented as a tuple of required stamina and stamina change. Returns: str: \\"YES\\" if it is possible to complete all the training sessions, \\"NO\\" otherwise.","solution":"def can_complete_sessions(n, s, sessions): # Sort sessions primarily by required stamina, then by change in stamina sessions.sort(key=lambda x: (x[0], -x[1])) for min_stamina, stamina_change in sessions: if s < min_stamina: return \\"NO\\" s += stamina_change if s < 0: return \\"NO\\" return \\"YES\\""},{"question":"def create_star_grid(n, m): Generates an n x m grid where the number of stars in each cell (i, j) is determined by specific rules. Args: n (int): the number of rows in the grid. m (int): the number of columns in the grid. Returns: list of list of int: A 2D list representing the grid with the number of stars as specified by the rules. Examples: >>> create_star_grid(3, 4) [[1, 1, 3, 3], [1, 4, 1, 6], [3, 1, 9, 1]] >>> create_star_grid(2, 2) [[1, 1], [1, 4]] grid = [] for i in range(1, n + 1): row = [] for j in range(1, m + 1): if i % 2 == 0 and j % 2 == 0: stars = i + j elif i % 2 == 1 and j % 2 == 1: stars = i * j else: stars = abs(i - j) row.append(stars) grid.append(row) return grid # Unit tests def test_3_4_grid(): result = create_star_grid(3, 4) expected = [ [1, 1, 3, 3], [1, 4, 1, 6], [3, 1, 9, 1] ] assert result == expected def test_2_2_grid(): result = create_star_grid(2, 2) expected = [ [1, 1], [1, 4] ] assert result == expected def test_1_1_grid(): result = create_star_grid(1, 1) expected = [ [1] ] assert result == expected def test_2_3_grid(): result = create_star_grid(2, 3) expected = [ [1, 1, 3], [1, 4, 1] ] assert result == expected def test_4_4_grid(): result = create_star_grid(4, 4) expected = [ [1, 1, 3, 3], [1, 4, 1, 6], [3, 1, 9, 1], [3, 6, 1, 8] ] assert result == expected","solution":"def create_star_grid(n, m): Generates an n x m grid where the number of stars in each cell (i, j) is determined by specific rules. Args: n (int): the number of rows in the grid. m (int): the number of columns in the grid. Returns: list of list of int: A 2D list representing the grid with the number of stars as specified by the rules. grid = [] for i in range(1, n + 1): row = [] for j in range(1, m + 1): if i % 2 == 0 and j % 2 == 0: stars = i + j elif i % 2 == 1 and j % 2 == 1: stars = i * j else: stars = abs(i - j) row.append(stars) grid.append(row) return grid"},{"question":"def minimum_total_reading_time(n: int, word_counts: List[int]) -> int: Returns the minimum total reading time for the given documents. Args: n : int The number of documents. word_counts : list of int A list of integers representing the word count in each document. Returns: int The minimum total reading time. >>> minimum_total_reading_time(5, [4, 5, 1, 2, 3]) 35 >>> minimum_total_reading_time(1, [7]) 7 >>> minimum_total_reading_time(2, [2, 1]) 4 >>> minimum_total_reading_time(4, [1, 2, 3, 4]) 20 >>> minimum_total_reading_time(4, [4, 3, 2, 1]) 20 >>> minimum_total_reading_time(3, [5, 5, 5]) 30","solution":"def minimum_total_reading_time(n, word_counts): Returns the minimum total reading time for the given documents. Args: n : int The number of documents. word_counts : list of int A list of integers representing the word count in each document. Returns: int The minimum total reading time. sorted_word_counts = sorted(word_counts) total_reading_time = 0 current_time = 0 for word_count in sorted_word_counts: current_time += word_count total_reading_time += current_time return total_reading_time"},{"question":"def can_be_equal_by_swapping(s: str, t: str) -> bool: Determine if two strings s and t of equal length can be made equal by swapping adjacent characters any number of times in s. Example: >>> can_be_equal_by_swapping(\\"converse\\", \\"conserve\\") True >>> can_be_equal_by_swapping(\\"abc\\", \\"cba\\") True","solution":"def can_be_equal_by_swapping(s, t): Determine if two strings s and t of equal length can be made equal by swapping adjacent characters any number of times in s. return sorted(s) == sorted(t)"},{"question":"def max_high_fences(n, grid): Determines the maximum number of high-fences that can be placed on the given grid. A high-fence can only be placed on an entirely empty row. :param n: The size of the grid (number of rows/columns). :type n: int :param grid: A list of strings representing the nxn grid. :type grid: list of str :return: The maximum number of high-fences that can be placed. :rtype: int >>> max_high_fences(4, [ >>> \\"....\\", >>> \\".#..\\", >>> \\"....\\", >>> \\"\\"]) 2 >>> max_high_fences(4, [ >>> \\"....\\", >>> \\"....\\", >>> \\"....\\", >>> \\"....\\"]) 4 >>> max_high_fences(4, [ >>> \\"\\", >>> \\"#..#\\", >>> \\"#..#\\", >>> \\"\\"]) 0","solution":"def max_high_fences(n, grid): Determines the maximum number of high-fences that can be placed on the given grid. A high-fence can only be placed on an entirely empty row. :param n: The size of the grid (number of rows/columns). :type n: int :param grid: A list of strings representing the nxn grid. :type grid: list of str :return: The maximum number of high-fences that can be placed. :rtype: int max_fences = 0 for row in grid: if all(cell == '.' for cell in row): max_fences += 1 return max_fences"},{"question":"def subset_sum_exists(n: int, x: int, numbers: List[int]) -> str: Determine if there is a subset of the given list of distinct integers that sums to x. >>> subset_sum_exists(5, 10, [1, 2, 3, 4, 5]) 'YES' >>> subset_sum_exists(3, 15, [3, 9, 8]) 'NO' from typing import List def test_subset_sum_exists_example1(): assert subset_sum_exists(5, 10, [1, 2, 3, 4, 5]) == \\"YES\\" def test_subset_sum_exists_example2(): assert subset_sum_exists(3, 15, [3, 9, 8]) == \\"NO\\" def test_subset_sum_exists_single_element_match(): assert subset_sum_exists(1, 5, [5]) == \\"YES\\" def test_subset_sum_exists_single_element_no_match(): assert subset_sum_exists(1, 10, [5]) == \\"NO\\" def test_subset_sum_exists_no_subset(): assert subset_sum_exists(4, 100, [1, 2, 3, 4]) == \\"NO\\" def test_subset_sum_exists_negative_numbers(): assert subset_sum_exists(5, 0, [-1, -2, -3, 4, 6]) == \\"YES\\" def test_subset_sum_exists_large_target(): assert subset_sum_exists(5, 1000000, [999999, 1, -1, 0, -999999]) == \\"YES\\" def test_subset_sum_exists_mixed_numbers(): assert subset_sum_exists(6, -3, [-10, -5, 2, 3, 5, 6]) == \\"YES\\"","solution":"def subset_sum_exists(n, x, numbers): from itertools import combinations # Check all possible subsets for i in range(1, n + 1): for subset in combinations(numbers, i): if sum(subset) == x: return \\"YES\\" return \\"NO\\" # Example usage: # Input: 5 10 # 1 2 3 4 5 # Output: YES n = 5 x = 10 numbers = [1, 2, 3, 4, 5] print(subset_sum_exists(n, x, numbers)) # Output: YES"},{"question":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of a subsequence where no two elements chosen are adjacent in the original sequence. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-1, -2, -3, -4]) 0 >>> max_non_adjacent_sum([-5]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([3, 5, -7, 8, 10]) 15 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> max_non_adjacent_sum([]) 0 >>> seq = [10000] * 100 >>> max_non_adjacent_sum(seq) 500000","solution":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of a subsequence where no two elements chosen are adjacent in the original sequence. n = len(arr) if n == 0: return 0 elif n == 1: return max(0, arr[0]) # dp[i] will store the maximum sum of subsequences for the subarray arr[0...i] dp = [0] * n dp[0] = max(0, arr[0]) if n > 1: dp[1] = max(dp[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"class Cinema: def __init__(self, n): Initialize the cinema with n seats, all initially available. self.seats = [False] * n def book(self, x): Book the seat at position x (1-indexed). If already booked, do nothing. self.seats[x - 1] = True def check(self, x): Check if the seat at position x (1-indexed) is available or booked. Returns \\"BOOKED\\" if the seat is booked, otherwise \\"AVAILABLE\\". return \\"BOOKED\\" if self.seats[x - 1] else \\"AVAILABLE\\" def handle_queries(n, queries): Handle multiple seat booking and checking queries. Args: n (int): The number of seats in the cinema. queries (List[str]): List of queries where each query is a string of the format \\"BOOK x\\" or \\"CHECK x\\". Returns: List[str]: List of results for each \\"CHECK x\\" query. Example: >>> handle_queries(5, [\\"BOOK 3\\", \\"CHECK 3\\", \\"BOOK 3\\", \\"CHECK 4\\", \\"CHECK 3\\"]) ['BOOKED', 'AVAILABLE', 'BOOKED'] cinema = Cinema(n) results = [] for query in queries: if query.startswith(\\"BOOK\\"): _, x = query.split() x = int(x) cinema.book(x) elif query.startswith(\\"CHECK\\"): _, x = query.split() x = int(x) results.append(cinema.check(x)) return results","solution":"class Cinema: def __init__(self, n): self.seats = [False] * n def book(self, x): self.seats[x - 1] = True def check(self, x): return \\"BOOKED\\" if self.seats[x - 1] else \\"AVAILABLE\\" def handle_queries(n, queries): cinema = Cinema(n) results = [] for query in queries: if query.startswith(\\"BOOK\\"): _, x = query.split() x = int(x) cinema.book(x) elif query.startswith(\\"CHECK\\"): _, x = query.split() x = int(x) results.append(cinema.check(x)) return results"},{"question":"def max_stones(n: int, grid: List[List[int]]) -> int: Harry is on a quest to collect magical stones placed on an n x n grid. Each cell on the grid contains a non-negative integer that denotes the number of stones at that cell. Harry starts his journey from the top-left corner of the grid (cell (1, 1)) and can only move right or down at each step until he reaches the bottom-right corner of the grid (cell (n, n)). Harry can collect stones from the cell he is currently on. Args: n: the size of the grid grid: a 2D list of integers representing the grid Returns: An integer representing the maximum number of stones Harry can collect from (1, 1) to (n, n). >>> max_stones(4, [[1, 3, 1, 4], [2, 2, 2, 2], [3, 1, 1, 1], [4, 2, 1, 0]]) 13 >>> max_stones(1, [[5]]) 5 >>> max_stones(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_stones(2, [[1000, 1000], [1000, 1000]]) 3000 >>> max_stones(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29","solution":"def max_stones(n, grid): Returns the maximum number of stones Harry can collect from (1, 1) to (n, n). # Create a dp table of the same size as the grid dp = [[0]*n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The value at dp[n-1][n-1] will be the maximum stones collected return dp[n-1][n-1]"},{"question":"from typing import List, Tuple def solve(t: int, cases: List[Tuple[int, int, List[str]]]) -> List[Union[int, str]]: Determine the path for Alice and Bob to reach the treasure. Args: t (int): Number of test cases. cases (List[Tuple[int, int, List[str]]]): List of cases; each case is represented by a tuple containing R (rows), C (columns), and the cave grid. Returns: List[Union[int, str]]: List of results for each test case. If a path is found, the number of cells visited (excluding the starting cell) is returned. Otherwise, \\"NO PATH\\" is returned. Examples: >>> solve(2, [(3, 4, [\\"....\\", \\".#..\\", \\"....\\"]), (3, 3, [\\"..#\\", \\".#.\\", \\"..#\\"])]) [5, \\"NO PATH\\"] >>> solve(1, [(1, 1, [\\".\\"])]) [0] >>> solve(1, [(2, 2, [\\".#\\", \\"#.\\"])]) [\\"NO PATH\\"] >>> solve(1, [(2, 2, [\\"..\\", \\"..\\"])]) [2] >>> solve(1, [(5, 5, [\\"..#..\\", \\".#.#.\\", \\".....\\", \\".#.#.\\", \\"..#..\\"])]) [8]","solution":"from collections import deque def find_path(R, C, grid): directions = [(0,1), (1,0), (0,-1), (-1,0)] def is_valid(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == '.' queue = deque([(0, 0, 1)]) visited = set([(0, 0)]) while queue: x, y, steps = queue.popleft() if (x, y) == (R-1, C-1): return steps - 1 for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return \\"NO PATH\\" def solve(t, cases): results = [] for case in cases: R, C, grid = case results.append(find_path(R, C, grid)) return results"},{"question":"def find_radius_of_tree(n: int, edges: List[Tuple[int, int]]) -> int: Find the radius of a tree with n nodes and n-1 edges. >>> find_radius_of_tree(6, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)]) 2 >>> find_radius_of_tree(2, [(1, 2)]) 1 >>> find_radius_of_tree(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 1 >>> find_radius_of_tree(4, [(1, 2), (2, 3), (3, 4)]) 2 >>> find_radius_of_tree(7, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (5, 7)]) 2","solution":"from collections import deque def find_radius_of_tree(n, edges): # Helper function to perform BFS and return the farthest node and its distance def bfs(start_node): distances = [-1] * n distances[start_node] = 0 queue = deque([start_node]) max_distance = 0 farthest_node = start_node while queue: node = queue.popleft() current_distance = distances[node] for neighbor in tree[node]: if distances[neighbor] == -1: queue.append(neighbor) distances[neighbor] = current_distance + 1 if distances[neighbor] > max_distance: max_distance = distances[neighbor] farthest_node = neighbor return farthest_node, max_distance # Transform input edges into an adjacency list representation of the tree tree = [[] for _ in range(n)] for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) # Step 1: Find the farthest node from an arbitrary node (let's choose node 0) farthest_node, _ = bfs(0) # Step 2: Find the farthest node from the first farthest node found in step 1 other_farthest_node, distance = bfs(farthest_node) # The radius of the tree is the ceiling of half the diameter of the tree radius = (distance + 1) // 2 return radius"},{"question":"def is_path_exists(n: int, m: int, grid: List[str]) -> str: Determine whether there exists a path from the top-left corner to the bottom-right corner of the grid that does not pass through any buildings. >>> is_path_exists(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) \\"YES\\" >>> is_path_exists(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) \\"NO\\" >>> is_path_exists(2, 2, [\\".#\\", \\"..\\"]) \\"YES\\" >>> is_path_exists(2, 2, [\\"..\\", \\"\\"]) \\"NO\\" >>> is_path_exists(5, 5, [\\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\"]) \\"YES\\" >>> is_path_exists(5, 5, [\\".....\\", \\"#\\", \\".....\\", \\"#\\", \\".....\\"]) \\"NO\\" >>> is_path_exists(1, 1, [\\".\\"]) \\"YES\\" >>> is_path_exists(1, 1, [\\"#\\"]) \\"NO\\" >>> is_path_exists(3, 3, [\\"..#\\", \\"#.#\\", \\"#..\\"]) \\"YES\\"","solution":"from typing import List def is_path_exists(n: int, m: int, grid: List[str]) -> str: if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '#' or visited[x][y]: return False if x == n - 1 and y == m - 1: return True visited[x][y] = True # Visit neighbors (up, down, left, right) if (dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1)): return True return False visited = [[False for _ in range(m)] for _ in range(n)] return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def minimum_edges_to_remove_to_make_acyclic(n, m, edges): Returns the minimum number of edges that must be removed to make the given graph acyclic. :param n: int - number of nodes :param m: int - number of edges :param edges: List of tuples - each tuple represents an edge in the form (u, v) :return: int - minimum number of edges to remove from solution import minimum_edges_to_remove_to_make_acyclic def test_example_case(): n = 6 m = 7 edges = [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6), (4, 6)] assert minimum_edges_to_remove_to_make_acyclic(n, m, edges) == 2 def test_case_no_edges(): n = 3 m = 0 edges = [] assert minimum_edges_to_remove_to_make_acyclic(n, m, edges) == 0 def test_case_no_cycles(): n = 3 m = 2 edges = [(1, 2), (2, 3)] assert minimum_edges_to_remove_to_make_acyclic(n, m, edges) == 0 def test_case_all_nodes_connected(): n = 4 m = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)] assert minimum_edges_to_remove_to_make_acyclic(n, m, edges) == 3 def test_case_single_node(): n = 1 m = 0 edges = [] assert minimum_edges_to_remove_to_make_acyclic(n, m, edges) == 0","solution":"def minimum_edges_to_remove_to_make_acyclic(n, m, edges): Returns the minimum number of edges that must be removed to make the given graph acyclic. :param n: int - number of nodes :param m: int - number of edges :param edges: List of tuples - each tuple represents an edge in the form (u, v) :return: int - minimum number of edges to remove from collections import defaultdict parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False redundant_edges = 0 for u, v in edges: if not union(u, v): redundant_edges += 1 return redundant_edges"},{"question":"from typing import List def min_moves_in_maze(n: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Given a grid, initial position and target position, determines the minimum number of moves required to reach the target. Returns -1 if target is not reachable. :param n: Integer representing the size of the grid (n x n) :param grid: List of strings representing the grid :param sx: Starting x coordinate (1-based) :param sy: Starting y coordinate (1-based) :param tx: Target x coordinate (1-based) :param ty: Target y coordinate (1-based) :return: Integer representing minimum number of moves or -1 if not reachable >>> min_moves_in_maze(5, [\\".....\\", \\".#.\\", \\"..#..\\", \\".\\", \\".....\\"], 1, 1, 5, 5) 8 >>> min_moves_in_maze(5, [\\".....\\", \\"#\\", \\".....\\", \\"#\\", \\".....\\"], 1, 1, 5, 5) -1 >>> min_moves_in_maze(3, [\\".#.\\", \\"...\\", \\"...\\"], 1, 1, 3, 3) 4","solution":"from collections import deque def min_moves_in_maze(n, grid, sx, sy, tx, ty): Given a grid, initial position and target position, determines the minimum number of moves required to reach the target. Returns -1 if target is not reachable. :param n: Integer representing the size of the grid (n x n) :param grid: List of strings representing the grid :param sx: Starting x coordinate (1-based) :param sy: Starting y coordinate (1-based) :param tx: Target x coordinate (1-based) :param ty: Target y coordinate (1-based) :return: Integer representing minimum number of moves or -1 if not reachable # Convert coordinates from 1-based to 0-based for easier indexing sx, sy, tx, ty = sx - 1, sy - 1, tx - 1, ty - 1 # Directions for movement (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Initialize queue for BFS and set for visited nodes queue = deque([(sx, sy, 0)]) # (x, y, move_count) visited = set((sx, sy)) # Perform BFS while queue: x, y, move_count = queue.popleft() # If we reach the target if (x, y) == (tx, ty): return move_count # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, move_count + 1)) # If target is not reachable return -1"},{"question":"def max_non_overlapping_appointments(n: int, appointments: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping appointments Leo can attend. >>> max_non_overlapping_appointments(5, [(1, 3), (2, 5), (4, 6), (6, 8), (5, 7)]) == 3 >>> max_non_overlapping_appointments(1, [(1, 2)]) == 1 >>> max_non_overlapping_appointments(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_appointments(3, [(1, 4), (2, 5), (3, 6)]) == 1 >>> max_non_overlapping_appointments(6, [(1, 2), (2, 3), (3, 4), (1, 4), (5, 6), (6, 7)]) == 5","solution":"def max_non_overlapping_appointments(n, appointments): Returns the maximum number of non-overlapping appointments Leo can attend. Parameters: n (int): Number of appointments. appointments (list of tuples): List containing tuples of (start, end) times. Returns: int: Maximum number of non-overlapping appointments. # Sort appointments by their end time appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_end_time = -1 # Iterate through sorted appointments for start, end in appointments: if start >= last_end_time: max_appointments += 1 last_end_time = end # Update last end time to current appointment's end time return max_appointments"},{"question":"from typing import List, Tuple def calculate_highest_score(n: int, m: int, scores: List[List[int]]) -> Tuple[float, List[int]]: Calculate the highest overall score of dance pairs and their indices. Args: n (int): Number of dance pairs. m (int): Number of judges. scores (list of list of int): Scores given to each pair by each judge. Returns: tuple: Highest overall score and a list of indices of pairs with the highest score. pass def find_winners(input_data: str) -> str: Process the input data to find winners. Args: input_data (str): Raw input data string. Returns: str: Formatted result string containing the highest score and pairs with that score. pass def test_single_pair(): n = 1 m = 5 scores = [ [78, 82, 85, 88, 90] ] assert calculate_highest_score(n, m, scores) == (85.0, [1]) def test_multiple_pairs(): n = 3 m = 5 scores = [ [78, 82, 85, 88, 90], [80, 87, 84, 91, 76], [75, 89, 84, 83, 80] ] assert calculate_highest_score(n, m, scores) == (85.0, [1]) def test_tied_pairs(): n = 3 m = 5 scores = [ [78, 82, 85, 88, 90], [78, 82, 85, 88, 90], [75, 89, 84, 83, 80] ] assert calculate_highest_score(n, m, scores) == (85.0, [1, 2]) def test_find_winners_example(): input_data = \\"3 5n78 82 85 88 90n80 87 84 91 76n75 89 84 83 80\\" assert find_winners(input_data) == \\"85.00 1\\" def test_find_winners_tied(): input_data = \\"3 5n78 82 85 88 90n78 82 85 88 90n75 89 84 83 80\\" assert find_winners(input_data) == \\"85.00 1 2\\"","solution":"def calculate_highest_score(n, m, scores): Calculate the highest overall score of dance pairs and their indices. Args: n (int): Number of dance pairs. m (int): Number of judges. scores (list of list of int): Scores given to each pair by each judge. Returns: tuple: Highest overall score and a list of indices of pairs with the highest score. highest_score = float('-inf') highest_pairs = [] for i in range(n): pair_scores = scores[i] sorted_scores = sorted(pair_scores) truncated_scores = sorted_scores[1:-1] # Remove the lowest and highest scores overall_score = sum(truncated_scores) / (m - 2) if overall_score > highest_score: highest_score = overall_score highest_pairs = [i + 1] # Store the 1-based index elif overall_score == highest_score: highest_pairs.append(i + 1) # Format the highest score to two decimal places highest_score = round(highest_score, 2) return highest_score, highest_pairs def find_winners(input_data): Process the input data to find winners. Args: input_data (str): Raw input data string. Returns: str: Formatted result string containing the highest score and pairs with that score. lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) scores = [list(map(int, line.split())) for line in lines[1:]] highest_score, highest_pairs = calculate_highest_score(n, m, scores) result_str = f\\"{highest_score:.2f} {' '.join(map(str, highest_pairs))}\\" return result_str"},{"question":"from typing import List from collections import deque def min_steps_to_artifact(n: int, m: int, maze: List[str]) -> int: Returns the minimum number of steps required to reach the artifact 'X' starting from (1, 1). If the artifact is not reachable, return -1. >>> min_steps_to_artifact(4, 4, [\\"....\\", \\".#..\\", \\".#X.\\", \\"....\\"]) 4 >>> min_steps_to_artifact(4, 4, [\\"....\\", \\"\\", \\"\\", \\"..X.\\"]) -1 >>> min_steps_to_artifact(1, 5, [\\"....X\\"]) 4 >>> min_steps_to_artifact(1, 1, [\\"X\\"]) 0 >>> min_steps_to_artifact(3, 3, [\\".#.\\", \\"#X#\\", \\".#.\\"]) -1 >>> min_steps_to_artifact(1, 2, [\\"X.\\"]) 0","solution":"from collections import deque def min_steps_to_artifact(n, m, maze): Returns the minimum number of steps required to reach the artifact 'X' starting from (1, 1). If the artifact is not reachable, return -1. def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] != '#' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (current row, current column, steps so far) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.popleft() if maze[x][y] == 'X': return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def find_duplicates(n: int, paper_ids: List[int]) -> Tuple[int, List[int]]: Finds and returns duplicate paper ids in sorted order. Parameters: n (int): The number of papers. paper_ids (List[int]): List of paper ids. Returns: Tuple[int, List[int]]: Number of duplicates and list of duplicate ids sorted. pass # Example usage: # n = 5 # paper_ids = [1, 2, 3, 2, 1] # print(find_duplicates(n, paper_ids)) # Output: (2, [1, 2]) from solution import find_duplicates def test_find_duplicates_example1(): n = 5 paper_ids = [1, 2, 3, 2, 1] assert find_duplicates(n, paper_ids) == (2, [1, 2]) def test_find_duplicates_example2(): n = 7 paper_ids = [4, 3, 2, 7, 8, 2, 3] assert find_duplicates(n, paper_ids) == (2, [2, 3]) def test_find_duplicates_example3(): n = 4 paper_ids = [1, 2, 3, 4] assert find_duplicates(n, paper_ids) == (0, []) def test_find_duplicates_no_duplicates(): n = 3 paper_ids = [5, 6, 7] assert find_duplicates(n, paper_ids) == (0, []) def test_find_duplicates_all_same(): n = 4 paper_ids = [2, 2, 2, 2] assert find_duplicates(n, paper_ids) == (1, [2]) def test_find_duplicates_randomized(): import random paper_ids = [1, 2, 2, 3, 4, 4] n = len(paper_ids) assert find_duplicates(n, paper_ids) == (2, [2, 4])","solution":"def find_duplicates(n, paper_ids): Finds and returns duplicate paper ids in sorted order. Parameters: n (int): The number of papers. paper_ids (list): List of paper ids. Returns: tuple: Number of duplicates and list of duplicate ids sorted. from collections import Counter count = Counter(paper_ids) duplicates = [paper_id for paper_id, cnt in count.items() if cnt > 1] return (len(duplicates), sorted(duplicates)) # Example usage: # n = 5 # paper_ids = [1, 2, 3, 2, 1] # print(find_duplicates(n, paper_ids)) # Output: (2, [1, 2])"},{"question":"class ArrayProcessor: def __init__(self, arr): Initialize the ArrayProcessor with the given array. def build_segment_tree(self, node, start, end): Build the segment tree. This function is used internally def update(self, idx, value): Update the element at the specified index with the given value. def _update(self, node, start, end, idx, value): Internal function for updating the segment tree. def query(self, L, R): Compute the sum of the elements in the subarray from index L to R. def _query(self, node, start, end, L, R): Internal function for querying the segment tree. def test_query(): processor = ArrayProcessor([1, 2, 3, 4, 5]) Test the query function def test_update_and_query(): processor = ArrayProcessor([1, 2, 3, 4, 5]) Test the update and query functions def test_edge_cases(): processor = ArrayProcessor([1000000000]) Test edge cases for the ArrayProcessor class","solution":"class ArrayProcessor: def __init__(self, arr): self.arr = arr self.n = len(arr) self.segment_tree = [0] * (4 * self.n) self.build_segment_tree(0, 0, self.n - 1) def build_segment_tree(self, node, start, end): if start == end: self.segment_tree[node] = self.arr[start] else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self.build_segment_tree(left_node, start, mid) self.build_segment_tree(right_node, mid + 1, end) self.segment_tree[node] = self.segment_tree[left_node] + self.segment_tree[right_node] def update(self, idx, value): self._update(0, 0, self.n - 1, idx, value) def _update(self, node, start, end, idx, value): if start == end: self.arr[idx] = value self.segment_tree[node] = value else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self._update(left_node, start, mid, idx, value) else: self._update(right_node, mid + 1, end, idx, value) self.segment_tree[node] = self.segment_tree[left_node] + self.segment_tree[right_node] def query(self, L, R): return self._query(0, 0, self.n - 1, L, R) def _query(self, node, start, end, L, R): if R < start or end < L: return 0 if L <= start and end <= R: return self.segment_tree[node] mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 left_sum = self._query(left_node, start, mid, L, R) right_sum = self._query(right_node, mid + 1, end, L, R) return left_sum + right_sum"},{"question":"def maximum_planks(n: int, m: int, k: int) -> int: Returns the maximum number of planks in one continuous section John can achieve under the given constraints. Args: n (int): The total number of planks. m (int): The number of required sections. k (int): The maximum number of cuts allowed. Returns: int: The maximum number of planks in one section. Examples: >>> maximum_planks(5, 3, 2) 2 >>> maximum_planks(7, 4, 3) 2","solution":"def maximum_planks(n, m, k): Returns the maximum number of planks in one continuous section John can achieve under the given constraints. # The maximum number of cuts needed to create m sections is m - 1 # But we can make no more than k cuts cuts = min(m - 1, k) # To distribute n planks into m sections with the allowed cuts # 1. Calculate the base size of each section when the planks are evenly distributed base_size = n // m # 2. Calculate the remainder planks (these are the extra planks that can't be evenly distributed) remainder = n % m # The maximum possible planks in one section would be base_size + 1 if we place all remainders in one section, # but since we can make no more cuts than k, we need to check based on the cuts distribution # 3. Calculate the number of larger sections possible larger_sections = min(remainder, cuts + 1) max_planks = base_size if larger_sections > 0: max_planks += 1 return max_planks # Testing the function print(maximum_planks(5, 3, 2)) # Output: 2 print(maximum_planks(7, 4, 3)) # Output: 2"},{"question":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed in a histogram. :param heights: List of integers representing heights of bars in the histogram :return: Integer representing the area of the largest rectangle >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 1, 2]) 3 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([1]) 1","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed in a histogram. :param heights: List of integers representing heights of bars in the histogram :return: Integer representing the area of the largest rectangle n = len(heights) stack = [] max_area = 0 for i in range(n + 1): while stack and (i == n or heights[stack[-1]] >= heights[i]): h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def maximize_sum(n: int, a: List[int]) -> int: Perform operations to maximize the sum of the elements in the array. >>> maximize_sum(5, [2, 4, 6, 7, 9]) 28 >>> maximize_sum(1, [7]) 7 >>> maximize_sum(4, [1, 3, 5, 7]) 16 >>> maximize_sum(4, [2, 4, 6, 8]) 20 >>> maximize_sum(6, [1, 2, 3, 4, 5, 6]) 21","solution":"def maximize_sum(n, a): odd_sum = sum(filter(lambda x: x % 2 != 0, a)) even_sum = sum(filter(lambda x: x % 2 == 0, a)) return odd_sum + even_sum"},{"question":"def check_pairs(t: int, cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine whether there exists a pair of distinct indices where the absolute difference between the elements is equal to the target value. Args: t (int): The number of test cases. cases (List[Tuple[int, int, List[int]]]): A list of tuples, each containing the number of elements, the target value, and the array of integers. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. >>> check_pairs(3, [(5, 7, [10, 1, 3, 16, 8]), (4, 2, [4, 1, 7, 10]), (6, 5, [2, 4, 5, 7, 9, 3])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_pairs(1, [(4, 10, [3, 1, 4, 6])]) [\\"NO\\"] >>> check_pairs(1, [(2, 3, [1, 4])]) [\\"YES\\"] >>> check_pairs(1, [(6, 2, [1, 3, 5, 7, 9, 11])]) [\\"YES\\"] >>> check_pairs(1, [(2, 1000000, [1, 1000001])]) [\\"YES\\"] >>> check_pairs(1, [(1000, 1, list(range(1, 1001)))]) [\\"YES\\"] def process_input(data: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Process the input data to extract the number of test cases and the details for each case. Args: data (str): The input data as a single string. Returns: Tuple[int, List[Tuple[int, int, List[int]]]]: The number of test cases and a list of tuples, each containing the number of elements, the target value, and the array of integers. >>> data = \\"3n5 7n10 1 3 16 8n4 2n4 1 7 10n6 5n2 4 5 7 9 3\\" >>> process_input(data) (3, [(5, 7, [10, 1, 3, 16, 8]), (4, 2, [4, 1, 7, 10]), (6, 5, [2, 4, 5, 7, 9, 3])]) from typing import List, Tuple def test_example_1(): data = \\"3n5 7n10 1 3 16 8n4 2n4 1 7 10n6 5n2 4 5 7 9 3\\" t, cases = process_input(data) result = check_pairs(t, cases) assert result == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_no_pair(): data = \\"1n4 10n3 1 4 6\\" t, cases = process_input(data) result = check_pairs(t, cases) assert result == [\\"NO\\"] def test_single_pair(): data = \\"1n2 3n1 4\\" t, cases = process_input(data) result = check_pairs(t, cases) assert result == [\\"YES\\"] def test_multiple_pairs(): data = \\"1n6 2n1 3 5 7 9 11\\" t, cases = process_input(data) result = check_pairs(t, cases) assert result == [\\"YES\\"] def test_large_k(): data = \\"1n2 1000000n1 1000001\\" t, cases = process_input(data) result = check_pairs(t, cases) assert result == [\\"YES\\"] def test_large_n(): data = \\"1n1000 1n\\" + \\" \\".join(map(str, range(1, 1001))) t, cases = process_input(data) result = check_pairs(t, cases) assert result == [\\"YES\\"]","solution":"def check_pairs(t, cases): results = [] for case in cases: n, k, array = case found = False elements_set = set(array) for num in array: if (num + k in elements_set) or (num - k in elements_set): found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(data): lines = data.strip().split('n') t = int(lines[0]) cases = [] current_line = 1 for _ in range(t): n, k = map(int, lines[current_line].split()) array = list(map(int, lines[current_line + 1].split())) cases.append((n, k, array)) current_line += 2 return t, cases"},{"question":"def num_decodings(s: str) -> int: Determine the number of ways to decode an encoded message given as a string of digits, where each digit or pair of digits is translated to a letter (1-26 -> A-Z). >>> num_decodings(\\"123\\") 3 >>> num_decodings(\\"10\\") 1 Args: s (str): The input string representing the encoded message. Returns: int: The number of ways to decode the string, modulo 10^9 + 7.","solution":"MOD = 10**9 + 7 def num_decodings(s: str) -> int: n = len(s) if n == 0 or s[0] == '0': return 0 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if s[i - 1] != '0': dp[i] = dp[i - 1] % MOD two_digit = int(s[i - 2:i]) if 10 <= two_digit <= 26: dp[i] = (dp[i] + dp[i - 2]) % MOD return dp[n]"},{"question":"def can_schedule_party(n: int, k: int, intervals: List[Tuple[int, int]]) -> Tuple[str, Optional[int]]: Determines if there is a time at which at least k friends can attend the party. Parameters: n (int): The number of friends. k (int): The minimum number of friends that should be able to attend the party. intervals (list of tuples): Each tuple contains two integers li and ri representing the start and end time of the available interval for each friend. Returns: tuple: A tuple containing \\"YES\\" and a possible time if it's possible to schedule the party, otherwise \\"NO\\". pass # Unit Tests def test_possible_schedule(): n = 5 k = 3 intervals = [(1, 5), (2, 6), (4, 8), (5, 9), (7, 10)] result = can_schedule_party(n, k, intervals) assert result[0] == \\"YES\\" def test_possible_schedule_exact(): n = 3 k = 3 intervals = [(1, 4), (2, 5), (3, 6)] result = can_schedule_party(n, k, intervals) assert result[0] == \\"YES\\" def test_impossible_schedule(): n = 3 k = 4 intervals = [(1, 4), (2, 5), (3, 6)] result = can_schedule_party(n, k, intervals) assert result[0] == \\"NO\\" def test_exact_k(): n = 3 k = 2 intervals = [(1, 4), (2, 5), (5, 6)] result = can_schedule_party(n, k, intervals) assert result[0] == \\"YES\\" def test_single_friend(): n = 1 k = 1 intervals = [(1, 10)] result = can_schedule_party(n, k, intervals) assert result[0] == \\"YES\\" and result[1] == 1 def test_large_intervals(): n = 5 k = 3 intervals = [(0, 1000000000), (250000000, 750000000), (500000000, 1000000000), (0, 500000000), (750000000, 1000000000)] result = can_schedule_party(n, k, intervals) assert result[0] == \\"YES\\"","solution":"def can_schedule_party(n, k, intervals): Determines if there is a time at which at least k friends can attend the party. Parameters: n (int): The number of friends. k (int): The minimum number of friends that should be able to attend the party. intervals (list of tuples): Each tuple contains two integers li and ri representing the start and end time of the available interval for each friend. Returns: tuple: A tuple containing \\"YES\\" and a possible time if it's possible to schedule the party, otherwise \\"NO\\". events = [] # Create events for all interval boundaries for li, ri in intervals: events.append((li, 1)) # 1 for starting of interval events.append((ri + 1, -1)) # -1 for ending of interval # Sort events by time, and in case of tie, end before start events.sort() current_friends = 0 for time, delta in events: current_friends += delta if current_friends >= k: return \\"YES\\", time return \\"NO\\","},{"question":"def min_removals_to_make_palindrome(s: str) -> int: Remove the smallest possible number of characters from a given string to make it a palindrome. >>> min_removals_to_make_palindrome(\\"abca\\") 1 >>> min_removals_to_make_palindrome(\\"racecar\\") 0 >>> min_removals_to_make_palindrome(\\"abcdefg\\") 6 >>> min_removals_to_make_palindrome(\\"abba\\") 0 >>> min_removals_to_make_palindrome(\\"abcde\\") 4 >>> min_removals_to_make_palindrome(\\"a\\") 0 >>> min_removals_to_make_palindrome(\\"ab\\") 1 >>> min_removals_to_make_palindrome(\\"aaabbb\\") 3 >>> min_removals_to_make_palindrome(\\"abcba\\") 0 >>> min_removals_to_make_palindrome(\\"aabb\\") 2","solution":"def min_removals_to_make_palindrome(s): n = len(s) # Function to find the minimum number of edits required to convert s[i...j] into a palindrome def minEditPalindromic(s, i, j, memo): # Base case: If the current substring is of length 1 or less, it is already a palindrome if i >= j: return 0 # Check if the result for this substring has already been computed if (i, j) in memo: return memo[(i, j)] # If the characters at the current positions are the same, move inward if s[i] == s[j]: memo[(i, j)] = minEditPalindromic(s, i+1, j-1, memo) else: # If they are different, consider both possibilities: remove s[i] or remove s[j] remove_i = minEditPalindromic(s, i+1, j, memo) remove_j = minEditPalindromic(s, i, j-1, memo) memo[(i, j)] = 1 + min(remove_i, remove_j) return memo[(i, j)] # Memoization table memo = {} # Calculate the minimum number of removals needed for the entire string return minEditPalindromic(s, 0, n-1, memo)"},{"question":"def max_treasure(grid: List[List[int]]) -> int: Returns the maximum amount of treasure Alyona can collect while moving from top-left to bottom-right of the grid. :param grid: List of lists of integers representing the treasure grid. :return: Integer representing the maximum amount of treasure. pass # Unit tests def test_max_treasure_simple(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_treasure(grid) == 29 # Example case def test_max_treasure_single_cell(): grid = [ [5] ] assert max_treasure(grid) == 5 # Single cell case def test_max_treasure_row(): grid = [ [1, 2, 3, 4, 5] ] assert max_treasure(grid) == 15 # Single row case def test_max_treasure_column(): grid = [ [1], [2], [3], [4], [5] ] assert max_treasure(grid) == 15 # Single column case def test_max_treasure_large(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] assert max_treasure(grid) == 45 # Larger grid case","solution":"def max_treasure(grid): Returns the maximum amount of treasure Alyona can collect while moving from top-left to bottom-right of the grid. :param grid: List of lists of integers representing the treasure grid. :return: Integer representing the maximum amount of treasure. n = len(grid) m = len(grid[0]) # Initialize a dp table with the same dimensions dp = [[0] * m for _ in range(n)] # Base case dp[0][0] = grid[0][0] # Fill the dp table for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[n-1][m-1]"},{"question":"def min_operations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations needed to make all elements in the array equal. >>> min_operations(1, [(4, [1, 2, 2, 3])]) [2] >>> min_operations(1, [(5, [4, 4, 4, 4, 4])]) [0] >>> min_operations(1, [(6, [6, 1, 6, 1, 6, 1])]) [3]","solution":"def min_operations(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] nums = test_cases[i][1] from collections import Counter # Count frequency of each element freq = Counter(nums) # Find the most common element max_freq = max(freq.values()) # Minimum operations needed to make all elements the same min_operations_needed = n - max_freq results.append(min_operations_needed) return results"},{"question":"import heapq import sys def find_max_travel_time(n, m, c, roads): Returns the maximum travel time between any pair of cities in Arrayland after constructing the high-speed railway that directly connects the central city to every other city. :param n: Number of cities :param m: Number of roads :param c: Central city index :param roads: List of tuples representing the roads (u, v, w) :return: Maximum travel time def test_single_road(): assert find_max_travel_time(2, 1, 1, [(1, 2, 5)]) == 5 def test_multiple_roads(): assert find_max_travel_time(4, 5, 1, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10), (2, 4, 7)]) == 6 def test_disconnected_graph(): assert find_max_travel_time(3, 1, 1, [(2, 3, 1)]) == sys.maxsize def test_long_travel_times(): assert find_max_travel_time(3, 3, 1, [(1, 2, 1000000), (1, 3, 999999), (2, 3, 1)]) == 1000000 def test_small_graph(): assert find_max_travel_time(3, 2, 1, [(1, 2, 1), (2, 3, 1)]) == 2","solution":"import heapq import sys def find_max_travel_time(n, m, c, roads): Returns the maximum travel time between any pair of cities in Arrayland after constructing the high-speed railway that directly connects the central city to every other city. :param n: Number of cities :param m: Number of roads :param c: Central city index :param roads: List of tuples representing the roads (u, v, w) :return: Maximum travel time def dijkstra(start, adj_list, n): distances = [sys.maxsize] * (n + 1) distances[start] = 0 min_heap = [(0, start)] while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > distances[u]: continue for v, weight in adj_list[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances adj_list = [[] for _ in range(n + 1)] for u, v, w in roads: adj_list[u].append((v, w)) adj_list[v].append((u, w)) distances_from_central = dijkstra(c, adj_list, n) return max(distances_from_central[1:])"},{"question":"from typing import List, Tuple def simulate_game(n: int, checkpoints: List[int], queries: List[Tuple[str, int]]) -> List[int]: Create a game simulation to test algorithm design skills. The game involves moving around a circular track represented by an array of integers and responding to queries. Args: n (int): The number of checkpoints on the track. checkpoints (List[int]): The values at each checkpoint. queries (List[Tuple[str, int]]): List of queries where each query can either be a movement query (\\"M x\\") or a report query (\\"R\\"). Returns: List[int]: The results of report queries. Example: >>> simulate_game(5, [1, 2, 3, 4, 5], [(\\"M\\", 2), (\\"R\\",), (\\"M\\", -1), (\\"R\\",)]) [3, 2] >>> simulate_game(5, [1, 2, 3, 4, 5], [(\\"M\\", 5), (\\"R\\",), (\\"M\\", -5), (\\"R\\",)]) [1, 1]","solution":"def simulate_game(n, checkpoints, queries): result = [] current_position = 0 for query in queries: if query[0] == \\"M\\": steps = int(query[1]) current_position = (current_position + steps) % n elif query[0] == \\"R\\": result.append(checkpoints[current_position]) return result"},{"question":"def max_fire_spread(grid): Returns the maximum number of connected empty cells ('.') that can catch fire starting from a single empty cell. >>> max_fire_spread([ ... ['.', '.', '.', '.', '.'], ... ['.', 'T', '.', '.', '.'], ... ['T', 'T', 'T', 'T', 'T'], ... ['.', '.', '.', '.', '.'], ... ['.', 'T', '.', '.', '.'], ... ['.', '.', '.', '.', '.'] ... ]) == 14 >>> max_fire_spread([ ... ['.', 'T', 'T'], ... ['T', 'T', 'T'], ... ['T', 'T', 'T'] ... ]) == 1 >>> max_fire_spread([ ... ['T', 'T', 'T'], ... ['T', 'T', 'T'], ... ['T', 'T', 'T'] ... ]) == 0 >>> max_fire_spread([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) == 9 >>> max_fire_spread([ ... ['.', 'T', '.'], ... ['T', '.', 'T'], ... ['.', 'T', '.'] ... ]) == 1","solution":"def max_fire_spread(grid): Returns the maximum number of connected empty cells ('.') that can catch fire starting from a single empty cell. if not grid: return 0 n = len(grid) m = len(grid[0]) def in_bounds(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y): if not in_bounds(x, y) or grid[x][y] != '.': return 0 grid[x][y] = '#' # mark as visited size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + dx, y + dy) return size max_size = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': max_size = max(max_size, dfs(i, j)) return max_size # Example usage n, m = 4, 5 grid = [ ['.', '.', '.', '.', '.'], ['.', 'T', '.', '.', '.'], ['T', 'T', 'T', 'T', 'T'], ['.', '.', '.', '.', '.'], ['.', 'T', '.', '.', '.'], ['.', '.', '.', '.', '.'] ] print(max_fire_spread(grid)) # Output: 14"},{"question":"from typing import List def smallest_positive_integer_not_sum_of_subset(n: int, arr: List[int]) -> int: Given an array of integers of size n, find the smallest positive integer k that is not the sum of any subset of the array elements. A subset can be empty, but the sum of an empty subset is considered to be 0. >>> smallest_positive_integer_not_sum_of_subset(5, [1, 2, 3, 8, 7]) 22 >>> smallest_positive_integer_not_sum_of_subset(3, [1, 2, 5]) 4 >>> smallest_positive_integer_not_sum_of_subset(1, [1]) 2 >>> smallest_positive_integer_not_sum_of_subset(5, [1, 1, 1, 1, 1]) 6 >>> smallest_positive_integer_not_sum_of_subset(6, [1, 2, 2, 2, 2, 3]) 13 >>> smallest_positive_integer_not_sum_of_subset(4, [3, 6, 9, 15]) 1 >>> smallest_positive_integer_not_sum_of_subset(5, [1, 3, 6, 10, 15]) 2","solution":"def smallest_positive_integer_not_sum_of_subset(n, arr): arr.sort() result = 1 # Initialize the smallest integer that cannot be represented by any subset sum for i in range(n): if arr[i] <= result: result += arr[i] else: break return result"},{"question":"def minimum_hours_to_set_temperature(f: int, r: int, temperature_preferences: List[List[int]]) -> int: Determines the minimum number of hours required to set the system for all the floors so that every room on each floor achieves its desired temperature at least once during the day. Parameters: f (int): Number of floors r (int): Number of rooms per floor temperature_preferences (list of list of int): Required temperatures for each room on each floor Returns: int: Minimum number of hours required >>> minimum_hours_to_set_temperature(3, 4, [ ... [21, 21, 23, 22], ... [23, 21, 22, 21], ... [22, 22, 22, 22] ... ]) == 3 >>> minimum_hours_to_set_temperature(1, 1, [[22]]) == 1 >>> minimum_hours_to_set_temperature(1, 5, [[20, 20, 20, 20, 20]]) == 1 >>> minimum_hours_to_set_temperature(1, 5, [[18, 20, 22, 24, 26]]) == 5 >>> minimum_hours_to_set_temperature(2, 3, [[21, 21, 23], [21, 23, 21]]) == 2 >>> minimum_hours_to_set_temperature(3, 3, [[21, 22, 23], [21, 23, 24], [24, 25, 26]]) == 3 >>> minimum_hours_to_set_temperature(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 3","solution":"def minimum_hours_to_set_temperature(f, r, temperature_preferences): Determines the minimum number of hours required to set the system for all the floors so that every room on each floor achieves its desired temperature at least once during the day. Parameters: f (int): Number of floors r (int): Number of rooms per floor temperature_preferences (list of list of int): Required temperatures for each room on each floor Returns: int: Minimum number of hours required max_unique_temps = 0 for floor in temperature_preferences: unique_temps = len(set(floor)) if unique_temps > max_unique_temps: max_unique_temps = unique_temps return max_unique_temps"},{"question":"def find_largest_N(prime_product: List[int]) -> List[int]: Given a list of clue numbers representing \\"prime products\\", return the largest possible integer 'N' for each clue such that the product of all prime numbers from 1 to N is equal to or just below the given number 'X'. >>> find_largest_N([2]) [2] >>> find_largest_N([6]) [3] >>> find_largest_N([30]) [5]","solution":"def find_largest_N(prime_product): def sieve(n): is_prime = [True] * (n+1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n+1, p): is_prime[i] = False p += 1 return [p for p in range(2, n+1) if is_prime[p]] def calculate_largest_N(X): primes = sieve(100) # primes up to 100 product, N = 1, 0 for prime in primes: if product * prime > X: break product *= prime N = prime return N results = [] for X in prime_product: results.append(calculate_largest_N(X)) return results"},{"question":"import math from typing import List, Tuple def can_measure_exactly(t: int, cases: List[Tuple[int, int, int]]) -> List[str]: Determine if it is possible to measure exactly z milliliters using any combination of the two types of vessels. Args: t (int): The number of test cases. cases (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers x, y, z, the capacities of the two types of vessels and the required amount of liquid. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_measure_exactly(3, [(3, 5, 7), (4, 6, 8), (1, 2, 3)]) ['YES', 'NO', 'YES'] results = [] for i in range(t): x, y, z = cases[i] if z % math.gcd(x, y) == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def test_can_measure_exactly(): # First test case: 3 5 7 -> GCD(3, 5) = 1, 7 is divisible by 1 -> YES assert can_measure_exactly(1, [(3, 5, 7)]) == [\\"YES\\"] # Second test case: 4 6 8 -> GCD(4, 6) = 2, 8 is divisible by 2 -> YES assert can_measure_exactly(1, [(4, 6, 8)]) == [\\"YES\\"] # Third test case: 1 2 3 -> GCD(1, 2) = 1, 3 is divisible by 1 -> YES assert can_measure_exactly(1, [(1, 2, 3)]) == [\\"YES\\"] # Fourth test case: 4 6 10 -> GCD(4, 6) = 2, 10 is divisible by 2 -> YES assert can_measure_exactly(1, [(4, 6, 10)]) == [\\"YES\\"] # Fifth test case: 4 6 7 -> GCD(4, 6) = 2, 7 is not divisible by 2 -> NO assert can_measure_exactly(1, [(4, 6, 7)]) == [\\"NO\\"] # Testing multiple cases test_cases = [ (3, 5, 7), # YES (4, 6, 8), # YES (1, 2, 3), # YES (4, 6, 10), # YES (4, 6, 7) # NO ] result = can_measure_exactly(5, test_cases) assert result == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"import math def can_measure_exactly(t, cases): results = [] for i in range(t): x, y, z = cases[i] if z % math.gcd(x, y) == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_generators_to_light_houses(n: int, houses: str, k: int) -> int: Returns the minimum number of generators needed to light up all houses with citizens ('C'). >>> min_generators_to_light_houses(5, \\"CECCE\\", 1) 2 >>> min_generators_to_light_houses(8, \\"ECCCECEE\\", 2) 2 >>> min_generators_to_light_houses(1, \\"C\\", 1) 1 >>> min_generators_to_light_houses(5, \\"EEEEE\\", 1) 0 >>> min_generators_to_light_houses(5, \\"CCCCC\\", 1) 2 >>> min_generators_to_light_houses(10, \\"CCECCECECE\\", 2) 3 >>> min_generators_to_light_houses(5, \\"CECCE\\", 3) 1 >>> min_generators_to_light_houses(6, \\"EEEEEE\\", 2) 0","solution":"def min_generators_to_light_houses(n, houses, k): Returns the minimum number of generators needed to light up all houses with citizens ('C'). i = 0 generators = 0 while i < n: # Find the rightmost house within the reach of the current 'C' that can place a generator j = min(i + k, n - 1) while j >= i - k and houses[j] == 'E': j -= 1 if j < i - k: # No house in the range i - k to i + k has a 'C' to place a generator break # Place the generator and light up houses from j - k to j + k generators += 1 i = j + k + 1 return generators"},{"question":"def sum_of_multiples(n: int) -> int: Returns the sum of all numbers from 1 to n that are divisible by 3 or 5. >>> sum_of_multiples(10) 33 >>> sum_of_multiples(15) 60 # Implementation here def sum_of_multiples_for_test_cases(t: int, test_cases: List[int]) -> List[int]: Returns a list of results for each of the test cases. >>> sum_of_multiples_for_test_cases(6, [10, 15, 20, 1, 3, 5]) [33, 60, 98, 0, 3, 8] # Implementation here def test_sum_of_multiples_single_case(): assert sum_of_multiples(10) == 33 assert sum_of_multiples(15) == 60 assert sum_of_multiples(20) == 98 assert sum_of_multiples(1) == 0 assert sum_of_multiples(3) == 3 assert sum_of_multiples(5) == 8 def test_sum_of_multiples_multiple_cases(): test_cases = [10, 15, 20, 1, 3, 5] expected_results = [33, 60, 98, 0, 3, 8] assert sum_of_multiples_for_test_cases(6, test_cases) == expected_results","solution":"def sum_of_multiples(n): Returns the sum of all numbers from 1 to n that are divisible by 3 or 5. def sum_divisible_by(k): p = n // k return k * p * (p + 1) // 2 return sum_divisible_by(3) + sum_divisible_by(5) - sum_divisible_by(15) def sum_of_multiples_for_test_cases(t, test_cases): Returns a list of results for each of the test cases. results = [] for n in test_cases: results.append(sum_of_multiples(n)) return results"},{"question":"import heapq from typing import List def merge_movie_lists(movie_lists: List[List[int]]) -> List[int]: Merges multiple sorted lists preserving the relative order and returns a single sorted list. Arguments: movie_lists -- List of sorted lists of movie IDs Returns: A single merged and sorted list of movie IDs. Examples: >>> merge_movie_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_movie_lists([[1, 2, 3, 4, 5]]) [1, 2, 3, 4, 5] >>> merge_movie_lists([[], [], []]) [] >>> merge_movie_lists([[], [1, 3, 5], []]) [1, 3, 5] >>> merge_movie_lists([[1000000, 1000001], [999999, 1000000], [1000002]]) [999999, 1000000, 1000000, 1000001, 1000002] >>> merge_movie_lists([[i for i in range(1, 10001)]] * 10) sorted([i for i in range(1, 10001) for _ in range(10)])","solution":"import heapq def merge_movie_lists(movie_lists): Merges multiple sorted lists preserving the relative order and returns a single sorted list. Arguments: movie_lists -- List of sorted lists of movie IDs Returns: A single merged and sorted list of movie IDs. merged_list = [] min_heap = [] # Initialize a heap with the first element from each list for i, movie_list in enumerate(movie_lists): if movie_list: heapq.heappush(min_heap, (movie_list[0], i, 0)) # Extract the smallest element and push the next element from the same list into the heap while min_heap: val, list_index, element_index = heapq.heappop(min_heap) merged_list.append(val) if element_index + 1 < len(movie_lists[list_index]): next_tuple = (movie_lists[list_index][element_index + 1], list_index, element_index + 1) heapq.heappush(min_heap, next_tuple) return merged_list"},{"question":"from typing import List, Tuple def max_profit(n: int, projects: List[Tuple[int, int, int]]) -> int: Calculate the maximum profit by selecting non-overlapping projects. >>> max_profit(5, [(1, 3, 50), (4, 6, 60), (7, 8, 70), (2, 5, 20), (5, 7, 100)]) 180 >>> max_profit(4, [(1, 2, 30), (3, 5, 50), (6, 7, 60), (8, 10, 40)]) 180 >>> max_profit(5, [(1, 10, 70), (2, 9, 90), (3, 8, 80), (4, 7, 60), (5, 6, 100)]) 100 >>> max_profit(4, [(1, 3, 20), (3, 5, 70), (2, 6, 60), (7, 8, 50)]) 120 >>> max_profit(1, [(1, 10, 100)]) 100 >>> max_profit(3, [(1, 2, 50), (1, 2, 20), (1, 2, 30)]) 50","solution":"from bisect import bisect_right def max_profit(n, projects): # Sort the projects based on end time projects.sort(key=lambda x: x[1]) dp = [0] * (n + 1) end_times = [projects[i][1] for i in range(n)] for i in range(1, n + 1): s, e, p = projects[i - 1] # Find the rightmost project that ends before current project starts index = bisect_right(end_times, s - 1) # Update dp[i] as the maximum profit by either including or excluding the current project dp[i] = max(dp[i - 1], dp[index] + p) return dp[n]"},{"question":"def max_winners(n: int, m: int, prize_counts: List[int]) -> int: Determine the maximum number of winners who can receive one of each type of prize. Args: n (int): The number of winners m (int): The number of different types of prizes prize_counts (list): List of integers where each integer represents the number of units available for each prize type Returns: int: Maximum number of winners who can get one of each type of prize >>> max_winners(2, 3, [2, 2, 2]) 2 >>> max_winners(5, 2, [4, 4]) 4 >>> max_winners(10, 5, [3, 4, 5, 6, 7]) 3 >>> max_winners(5, 3, [1, 2, 2]) 1 >>> max_winners(100, 4, [10, 20, 30, 40]) 10 >>> max_winners(3, 5, [3, 3, 3, 3, 3]) 3 >>> max_winners(3, 1, [2]) 2 pass","solution":"def max_winners(n, m, prize_counts): Determine the maximum number of winners who can receive one of each type of prize. Args: n (int): The number of winners m (int): The number of different types of prizes prize_counts (list): List of integers where each integer represents the number of units available for each prize type Returns: int: Maximum number of winners who can get one of each type of prize return min(min(prize_counts), n) # Test cases for the function assert max_winners(2, 3, [2, 2, 2]) == 2 assert max_winners(5, 2, [4, 4]) == 4 assert max_winners(10, 5, [3, 4, 5, 6, 7]) == 3"},{"question":"from typing import List, Tuple, Union def shortest_path_in_graph(n: int, m: int, edges: List[Tuple[int, int]], u: int, v: int) -> Union[str, Tuple[str, int]]: Determine if there exists a path between a given pair of vertices u and v in an undirected graph, and if it exists, return the length of the shortest path. Parameters: n (int): The number of vertices in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): A list of tuples representing the edges of the graph. u (int): The start vertex. v (int): The end vertex. Returns: Union[str, Tuple[str, int]]: \\"NO\\" if no path exists, otherwise a tuple with \\"YES\\" and the length of the shortest path. >>> shortest_path_in_graph(3, 0, [], 1, 2) 'NO' >>> shortest_path_in_graph(2, 1, [(1, 2)], 1, 2) ('YES', 1) >>> shortest_path_in_graph(4, 3, [(1, 2), (2, 3), (3, 4)], 1, 4) ('YES', 3)","solution":"from collections import deque def shortest_path_in_graph(n, m, edges, u, v): # Create adjacency list for the graph graph = [[] for _ in range(n + 1)] for a, b in edges: graph[a].append(b) graph[b].append(a) # Perform Breadth-First Search (BFS) to find the shortest path def bfs(start, end): visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start]) visited[start] = True while queue: current = queue.popleft() if current == end: return distance[end] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[current] + 1 queue.append(neighbor) return None shortest_distance = bfs(u, v) if shortest_distance is not None: return (\\"YES\\", shortest_distance) else: return \\"NO\\""},{"question":"def max_train_station(n: int, trains: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the station with the highest number of trains passing through in a given range of stations. Parameters: n (int): Number of stations. trains (list of int): List containing number of trains for each station. queries (list of tuples): Each tuple containing two integers L and R representing the range of stations. Returns: list of int: List containing the station indexes with the highest number of trains passing through for each query. >>> max_train_station(7, [10, 20, 30, 10, 20, 30, 40], [(1, 3)]) [3] >>> max_train_station(7, [10, 20, 30, 10, 20, 30, 40], [(1, 3), (4, 6), (1, 7)]) [3, 6, 7] >>> max_train_station(5, [50, 50, 20, 50, 50], [(1, 5)]) [1] >>> max_train_station(5, [10, 20, 30, 40, 50], [(3, 3)]) [3] >>> max_train_station(5, [5, 10, 15, 20, 25], [(1, 5)]) [5]","solution":"def max_train_station(n, trains, queries): Returns the stations with the highest number of trains passing through within the given range of stations. Parameters: n (int): Number of stations. trains (list of int): List containing number of trains for each station. queries (list of tuples): Each tuple containing two integers L and R representing the range of stations. Returns: list of int: List containing the station indexes with the highest number of trains passing through for each query. result = [] for L, R in queries: max_trains = -1 max_station = -1 for i in range(L - 1, R): if trains[i] > max_trains or (trains[i] == max_trains and (max_station == -1 or i + 1 < max_station)): max_trains = trains[i] max_station = i + 1 result.append(max_station) return result"},{"question":"import math def count_perfect_squares_between(n: int, m: int) -> int: Returns the count of perfect squares between n and m, inclusive. >>> count_perfect_squares_between(10, 20) == 1 >>> count_perfect_squares_between(1, 100) == 10 >>> count_perfect_squares_between(2, 3) == 0 >>> count_perfect_squares_between(16, 16) == 1 >>> count_perfect_squares_between(1, 1000000) == 1000 >>> count_perfect_squares_between(4, 9) == 2 >>> count_perfect_squares_between(17, 24) == 0","solution":"import math def count_perfect_squares_between(n, m): Returns the count of perfect squares between n and m, inclusive. start = math.ceil(math.sqrt(n)) end = math.floor(math.sqrt(m)) return max(0, end - start + 1)"},{"question":"def min_operations_to_sort_subtrees(n: int, parents: List[int]) -> int: Calculate the minimum number of operations required to ensure each node's subtree has nodes with values in strictly increasing order. >>> min_operations_to_sort_subtrees(5, [0, 1, 1, 2, 2]) 0 >>> min_operations_to_sort_subtrees(1, [0]) 0 >>> min_operations_to_sort_subtrees(2, [0, 1]) 0 >>> min_operations_to_sort_subtrees(3, [0, 1, 2]) 0 >>> min_operations_to_sort_subtrees(7, [0, 1, 1, 2, 2, 3, 3]) 0 >>> min_operations_to_sort_subtrees(10, [0, 1, 1, 2, 2, 3, 3, 4, 4, 5]) 0","solution":"def min_operations_to_sort_subtrees(n, parents): Calculate the minimum number of operations required to ensure each node's subtree has nodes with values in strictly increasing order. # Based on the problem requirements, as long as the tree structure remains intact # (i.e., no changes in parent-child relationships), the nodes' values are already # guaranteed to be in the required order since all nodes have unique values # from 1 to n and thus will always form a strictly increasing sequence within # each subtree rooted at any node given the unique values constraint. # Therefore, no operations are needed. return 0"},{"question":"def maxProfit(M, prices): Function to maximize the profit by the end of \`n\` days. Parameters: M (int): Initial amount of money. prices (list): List of stock prices over \`n\` days. Returns: int: The maximum amount of money that can be achieved at the end of day \`n\`. pass # Unit Tests def test_no_price_change(): assert maxProfit(100, [5, 5, 5, 5, 5]) == 100 def test_increasing_prices(): assert maxProfit(100, [1, 2, 3, 4, 5]) == 104 def test_decreasing_prices(): assert maxProfit(100, [5, 4, 3, 2, 1]) == 100 def test_fluctuating_prices(): assert maxProfit(100, [1, 3, 2, 8, 4, 9]) == 108 def test_single_day(): assert maxProfit(100, [5]) == 100 def test_empty_prices(): assert maxProfit(100, []) == 100 def test_random_case(): assert maxProfit(1000, [5, 3, 6, 1, 8, 4]) == 1007","solution":"def maxProfit(M, prices): Function to maximize the profit by the end of \`n\` days. Parameters: M (int): Initial amount of money. prices (list): List of stock prices over \`n\` days. Returns: int: The maximum amount of money that can be achieved at the end of day \`n\`. n = len(prices) if n == 0: return M max_money = M min_price = prices[0] for i in range(1, n): # If we buy at the minimum price observed so far and sell at today's price max_money = max(max_money, M + (prices[i] - min_price)) # Update the minimum price observed so far to include today's price min_price = min(min_price, prices[i]) return max_money"},{"question":"def min_operations_to_one(n: int) -> int: Returns the minimum number of operations to reduce the number n to 1. >>> min_operations_to_one(25) 6 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(2) 1 >>> min_operations_to_one(3) 2 >>> min_operations_to_one(4) 2 >>> min_operations_to_one(15) 5 >>> min_operations_to_one(1024) 10","solution":"def min_operations_to_one(n): Returns the minimum number of operations to reduce the number n to 1. operations = 0 while n > 1: if n % 2 == 0: n //= 2 else: # Prefer subtraction when n is 3 or n - 1 has fewer 1's in binary representation if n == 3 or ((n - 1) & (n - 2)) <= ((n + 1) & n): n -= 1 else: n += 1 operations += 1 return operations"},{"question":"def longest_increasing_subsequence(sequence: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given sequence. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([5, 8, 3, 7, 9, 1]) 3 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([2, 7, 4, 3, 8]) 3 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given sequence. if not sequence: return 0 n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"import sys from typing import List, Tuple def minimize_differences(t: int, cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given an array of integers, rearrange it so that the difference between any two adjacent integers is minimized. Example: >>> t = 2 >>> cases = [(5, [4, 1, 3, 8, 5]), (4, [7, 3, 2, 1])] >>> minimize_differences(t, cases) [[1, 3, 4, 5, 8], [1, 2, 3, 7]] results = [] for case in cases: n, arr = case arr.sort() results.append(arr) return results # Example usage # t = 2 # cases = [ # (5, [4, 1, 3, 8, 5]), # (4, [7, 3, 2, 1]) #] # minimize_differences(t, cases) # Output: [[1, 3, 4, 5, 8], [1, 2, 3, 7]]","solution":"def minimize_differences(t, cases): results = [] for case in cases: n, arr = case arr.sort() results.append(arr) return results # Example usage # t = 2 # cases = [ # (5, [4, 1, 3, 8, 5]), # (4, [7, 3, 2, 1]) #] # minimize_differences(t, cases) # Output: [[1, 3, 4, 5, 8], [1, 2, 3, 7]]"},{"question":"def evaluate_expression(n: int, expression: str) -> int: Evaluates a mathematical expression with addition, multiplication, and parentheses. Args: n (int): The length of the expression string. expression (str): The mathematical expression to evaluate. Returns: int: The result of evaluating the expression. Examples: >>> evaluate_expression(7, \\"(2+3)*4\\") 20 >>> evaluate_expression(5, \\"2+3*4\\") 14","solution":"def evaluate_expression(n, expression): Evaluates a mathematical expression with addition, multiplication, and parentheses. Args: n (int): The length of the expression string. expression (str): The mathematical expression to evaluate. Returns: int: The result of evaluating the expression. return eval(expression) # Example usage: # n = 7 # expression = \\"(2+3)*4\\" # print(evaluate_expression(n, expression)) # Output: 20"},{"question":"def count_clusters(n: int, m: int, grid: List[List[str]]) -> int: A security system designed for a fictional company's headquarters consists of a grid of n * m cells, where some cells are locked and others are not. Each locked cell is denoted by 'L', and each unlocked cell is denoted by 'U'. The goal is to determine the number of clusters of connected unlocked cells in the system. Args: n: an integer, number of rows in the grid. m: an integer, number of columns in the grid. grid: a list of lists of strings representing the grid. Returns: The number of clusters of connected unlocked cells. Example: >>> count_clusters(4, 5, [['U', 'U', 'L', 'L', 'U'], ['U', 'L', 'U', 'L', 'U'], ['L', 'U', 'U', 'L', 'L'], ['U', 'U', 'L', 'U', 'U']]) 4 pass if __name__ == \\"__main__\\": import pytest def test_example_case(): n = 4 m = 5 grid = [ ['U', 'U', 'L', 'L', 'U'], ['U', 'L', 'U', 'L', 'U'], ['L', 'U', 'U', 'L', 'L'], ['U', 'U', 'L', 'U', 'U'] ] assert count_clusters(n, m, grid) == 4 def test_all_locked(): n = 2 m = 2 grid = [ ['L', 'L'], ['L', 'L'] ] assert count_clusters(n, m, grid) == 0 def test_single_unlocked_cell(): n = 3 m = 3 grid = [ ['L', 'L', 'L'], ['L', 'U', 'L'], ['L', 'L', 'L'] ] assert count_clusters(n, m, grid) == 1 def test_all_unlocked(): n = 2 m = 2 grid = [ ['U', 'U'], ['U', 'U'] ] assert count_clusters(n, m, grid) == 1 def test_grid_with_multiple_clusters(): n = 5 m = 5 grid = [ ['U', 'L', 'U', 'L', 'U'], ['L', 'U', 'L', 'U', 'L'], ['U', 'L', 'U', 'L', 'U'], ['L', 'U', 'L', 'U', 'L'], ['U', 'L', 'U', 'L', 'U'] ] assert count_clusters(n, m, grid) == 13 pytest.main([__file__])","solution":"def count_clusters(n, m, grid): Returns the number of clusters of connected unlocked cells in the grid. def dfs(grid, visited, i, j): # Directions for the adjacent cells (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] stack = [(i, j)] while stack: x, y = stack.pop() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 'U': visited[nx][ny] = True stack.append((nx, ny)) visited = [[False] * m for _ in range(n)] clusters = 0 for i in range(n): for j in range(m): if grid[i][j] == 'U' and not visited[i][j]: clusters += 1 visited[i][j] = True dfs(grid, visited, i, j) return clusters"},{"question":"def max_possible_sum(N: int, K: int, X: int, A: List[int]) -> int: Calculate the maximum possible sum of elements you can achieve by selecting some contiguous subarray of length exactly K and then performing at most one replacement operation where you replace one element of the subarray with the given integer X. >>> max_possible_sum(5, 3, 4, [1, 3, 2, 1, -1]) 9 >>> max_possible_sum(5, 2, 10**9, [1, 1, 1, 1, 1]) 1000000001 >>> max_possible_sum(5, 3, 10**9, [1, 2, 3, 4, 5]) 1000000009 >>> max_possible_sum(4, 2, 1, [4, 5, 6, 7]) 13 >>> max_possible_sum(6, 4, 1, [1, 2, 3, 4, 5, 6]) 18 >>> max_possible_sum(6, 3, -1, [5, 3, 2, 1, -7, -8]) 10 >>> max_possible_sum(5, 1, 10, [1, 2, 3, 4, 5]) 10 pass","solution":"def max_possible_sum(N, K, X, A): # Calculate the initial sum of the first window of size K current_sum = sum(A[:K]) max_sum = current_sum # Calculate max sum of all windows of size K for i in range(1, N - K+ 1): current_sum = current_sum - A[i - 1] + A[i + K - 1] max_sum = max(max_sum, current_sum) # Calculate the sum of each window after replacement replacement_sum = max_sum for i in range(N - K + 1): for j in range(K): current_window = A[i:i + K] replaced_sum = sum(current_window) - current_window[j] + X replacement_sum = max(replacement_sum, replaced_sum) return replacement_sum"},{"question":"from typing import List def count_valid_subsets(n: int, L: int, R: int, marbles: List[int]) -> int: Counts the number of non-empty subsets of marbles whose power sum is within the range [L, R]. :param n: Number of marbles :param L: Lower bound of the sum range :param R: Upper bound of the sum range :param marbles: List of integers representing the powers of the marbles :return: Number of valid subsets >>> count_valid_subsets(3, 5, 8, [2, 3, 5]) 4 >>> count_valid_subsets(1, 1, 100, [50]) 1 >>> count_valid_subsets(1, 51, 100, [50]) 0 >>> count_valid_subsets(3, 0, 100, [1, 2, 3]) 7 >>> count_valid_subsets(3, 10, 20, [1, 2, 3]) 0 >>> count_valid_subsets(4, 1, 1000, [10, 20, 30, 40]) 15 >>> count_valid_subsets(0, 1, 100, []) 0","solution":"from itertools import combinations def count_valid_subsets(n, L, R, marbles): Counts the number of non-empty subsets of marbles whose power sum is within the range [L, R]. :param n: Number of marbles :param L: Lower bound of the sum range :param R: Upper bound of the sum range :param marbles: List of integers representing the powers of the marbles :return: Number of valid subsets count = 0 for i in range(1, n + 1): for subset in combinations(marbles, i): if L <= sum(subset) <= R: count += 1 return count"},{"question":"def longest_common_subsequence(strings: List[str]) -> int: Amanda has a list of strings consisting of lowercase English letters. She wants to find the length of the longest subsequence which is common across all strings in the list. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Write a function that takes a list of strings and returns the length of the longest common subsequence. >>> longest_common_subsequence([\\"abcde\\", \\"abfce\\", \\"abgde\\"]) 3 >>> longest_common_subsequence([\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> longest_common_subsequence([\\"aab\\", \\"azb\\", \\"ayb\\"]) 2","solution":"from functools import lru_cache def longest_common_subsequence(strings): def lcs(X, Y): m = len(X) n = len(Y) L = [[None] * (n + 1) for i in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0 : L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) return L[m][n] def find_lcs_for_all_strings(strings): result_subseq = strings[0] for i in range(1, len(strings)): result_subseq_length = lcs(result_subseq, strings[i]) temp_lcs = \\"\\" m, n = len(result_subseq), len(strings[i]) L = [[0] * (n + 1) for _ in range(m + 1)] for x in range(m + 1): for y in range(n + 1): if x == 0 or y == 0: L[x][y] = 0 elif result_subseq[x-1] == strings[i][y-1]: L[x][y] = L[x-1][y-1] + 1 else: L[x][y] = max(L[x-1][y], L[x][y-1]) x, y = m, n while x > 0 and y > 0: if result_subseq[x-1] == strings[i][y-1]: temp_lcs = result_subseq[x-1] + temp_lcs x -= 1 y -= 1 elif L[x-1][y] > L[x][y-1]: x -= 1 else: y -= 1 result_subseq = temp_lcs return len(result_subseq) return find_lcs_for_all_strings(strings)"},{"question":"def generate_distinct_sum_sequence(n: int) -> List[int]: Generates a sequence of length n where the sum of any two consecutive elements is distinct. >>> generate_distinct_sum_sequence(1) [1] >>> generate_distinct_sum_sequence(2) [1, 2] >>> generate_distinct_sum_sequence(3) [1, 2, 4] >>> generate_distinct_sum_sequence(5) [1, 2, 4, 7, 11]","solution":"def generate_distinct_sum_sequence(n): Generates a sequence of length n where the sum of any two consecutive elements is distinct. sequence = [] current = 1 for i in range(n): sequence.append(current) current += i + 1 return sequence"},{"question":"def min_swaps_to_palindrome(t, test_cases): Calculate the minimum number of swaps required to rearrange the cards into a palindrome, or return -1 if it is impossible. :param t: The number of test cases :param test_cases: A list of tuples, where each tuple contains an integer n and a list of n integers representing the initial order of the cards :return: A list of integers representing the minimum number of swaps required for each test case, or -1 if it is impossible >>> t = 3 >>> test_cases = [(4, [1, 2, 3, 4]), (5, [1, 2, 3, 2, 1]), (6, [1, 4, 5, 5, 4, 1])] >>> min_swaps_to_palindrome(t, test_cases) [-1, 0, 0] >>> t = 1 >>> test_cases = [(4, [1, 2, 3, 5])] >>> min_swaps_to_palindrome(t, test_cases) [-1] >>> t = 1 >>> test_cases = [(1, [1])] >>> min_swaps_to_palindrome(t, test_cases) [0] >>> t = 1 >>> test_cases = [(4, [1, 2, 2, 1])] >>> min_swaps_to_palindrome(t, test_cases) [0] >>> t = 1 >>> test_cases = [(5, [1, 2, 3, 2, 1])] >>> min_swaps_to_palindrome(t, test_cases) [0]","solution":"def min_swaps_to_palindrome(t, test_cases): def is_palindrome_possible(seq): from collections import Counter counts = Counter(seq) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 results = [] for i in range(t): n = test_cases[i][0] seq = test_cases[i][1] if not is_palindrome_possible(seq): results.append(-1) continue def count_swaps_to_palindrome(seq): seq = list(seq) swaps = 0 left = 0 right = len(seq) - 1 while left < right: if seq[left] != seq[right]: l = left r = right while l < r and seq[l] != seq[right]: l += 1 while r > l and seq[r] != seq[left]: r -= 1 if l == r: seq[l], seq[l+1] = seq[l+1], seq[l] swaps += 1 else: seq[left], seq[r] = seq[r], seq[left] swaps += 1 left += 1 right -= 1 return swaps results.append(count_swaps_to_palindrome(seq)) return results # Example of usage t = 3 test_cases = [(4, [1, 2, 3, 4]), (5, [1, 2, 3, 2, 1]), (6, [1, 4, 5, 5, 4, 1])] print(min_swaps_to_palindrome(t, test_cases))"},{"question":"def process_queries(n, m, q, queries): This function processes the queries that modify a binary string and prints the maximum length of the binary string after each modification to ensure that the length of consecutive '1's does not exceed a given length m. :param n: Initial length of the binary string (always starts at 0) :param m: The upper limit for the length of consecutive '1's :param q: Number of queries :param queries: List of queries, each containing [p_i, v_i] :return: None # Your code here # Example usage: # n = 0 # m = 3 # q = 5 # queries = [(1, 1), (2, 1), (3, 1), (4, 0), (5, 1)] # process_queries(n, m, q, queries) # Unit tests import pytest def capture_output(func, *args, **kwargs): from io import StringIO import sys old_stdout = sys.stdout sys.stdout = StringIO() func(*args, **kwargs) output = sys.stdout.getvalue().split('n') sys.stdout = old_stdout return [line for line in output if line] def test_example(): n = 0 m = 3 q = 5 queries = [(1, 1), (2, 1), (3, 1), (4, 0), (5, 1)] expected_output = [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"] output = capture_output(process_queries, n, m, q, queries) assert output == expected_output def test_consecutive_ones_exceeding_limit(): n = 0 m = 2 q = 5 queries = [(1, 1), (2, 1), (3, 1), (4, 0), (5, 1)] expected_output = [\\"1\\", \\"2\\", \\"2\\", \\"3\\", \\"4\\"] output = capture_output(process_queries, n, m, q, queries) assert output == expected_output def test_alternating_values(): n = 0 m = 2 q = 6 queries = [(1, 1), (2, 0), (3, 1), (4, 0), (5, 1), (6, 0)] expected_output = [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"6\\"] output = capture_output(process_queries, n, m, q, queries) assert output == expected_output def test_all_zeros(): n = 0 m = 2 q = 5 queries = [(1, 0), (2, 0), (3, 0), (4, 0), (5, 0)] expected_output = [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"] output = capture_output(process_queries, n, m, q, queries) assert output == expected_output","solution":"def process_queries(n, m, q, queries): This function processes the queries that modify a binary string and prints the maximum length of the binary string after each modification to ensure that the length of consecutive '1's does not exceed a given length m. :param n: Initial length of the binary string (always starts at 0) :param m: The upper limit for the length of consecutive '1's :param q: Number of queries :param queries: List of queries, each containing [p_i, v_i] :return: None binary_string = [] max_length = 0 def count_consecutive_ones(): max_1s = 0 current_1s = 0 for char in binary_string: if char == '1': current_1s += 1 if current_1s > max_1s: max_1s = current_1s else: current_1s = 0 return max_1s for p, v in queries: if p > len(binary_string): # Extend the binary_string to fit the new position binary_string.extend(['0'] * (p - len(binary_string))) binary_string[p - 1] = str(v) if count_consecutive_ones() <= m: max_length += 1 else: binary_string[p - 1] = '0' print(max_length) # Note: In actual usage, you would read input from the user and call # process_queries(n, m, q, queries) with the correct parameters from the input."},{"question":"def find_stations(w: int, h: int) -> ((int, int), (int, int)): Finds the coordinates of two stations such that the Manhattan distance between them is minimized. Given the dimensions of the city square grid (w and h), this function places two stations in such a way that the travel chaos, defined as the maximum Manhattan distance between any two stations placed on the grid, is minimized. The Manhattan distance between two cells (x1, y1) and (x2, y2) in a grid is defined as |x1 - x2| + |y1 - y2|. Args: w (int): width of the grid h (int): height of the grid Returns: tuple of tuple: coordinates of the two stations Example: >>> find_stations(4, 5) ((2, 2), (3, 2)) >>> find_stations(3, 3) ((1, 1), (1, 2)) # Your code here","solution":"def find_stations(w, h): Finds the coordinates of two stations such that the Manhattan distance between them is minimized. Args: w (int): width of the grid h (int): height of the grid Returns: tuple of tuple: coordinates of the two stations if w > h: return (1, 1), (1, 2) else: return (1, 1), (2, 1)"},{"question":"def smallest_subsequence(s: str) -> str: Returns the lexicographically smallest subsequence of the string s. >>> smallest_subsequence('bcabc') == 'abc' >>> smallest_subsequence('cbacdcbc') == 'acdb'","solution":"def smallest_subsequence(s): Returns the lexicographically smallest subsequence of the string s. stack = [] seen = set() last_occurrence = {c: i for i, c in enumerate(s)} for i, c in enumerate(s): if c not in seen: while stack and c < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(c) seen.add(c) return ''.join(stack)"},{"question":"def min_trips(capacity: int, weights: List[int]) -> int: Returns the minimum number of trips required to ship all the containers with the given capacity. >>> min_trips(10, [2, 3, 5, 8, 3]) 3 >>> min_trips(15, [10, 5, 5, 7]) 2 def solve(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solves multiple test cases and returns a list of minimum trips required for each test case. >>> solve([(5, 10, [2, 3, 5, 8, 3]), (4, 15, [10, 5, 5, 7])]) [3, 2] def test_min_trips(): assert min_trips(10, [2, 3, 5, 8, 3]) == 3 assert min_trips(15, [10, 5, 5, 7]) == 2 assert min_trips(7, [1, 2, 3, 4, 5, 6]) == 3 assert min_trips(10, [10, 10, 10]) == 3 assert min_trips(50, [25, 25, 25, 25, 10, 40]) == 3 def test_solve(): test_cases = [ (5, 10, [2, 3, 5, 8, 3]), (4, 15, [10, 5, 5, 7]) ] expected_results = [3, 2] assert solve(test_cases) == expected_results","solution":"def min_trips(capacity, weights): Returns the minimum number of trips required to ship all the containers with the given capacity. weights.sort() left = 0 right = len(weights) - 1 trips = 0 while left <= right: if weights[left] + weights[right] <= capacity: left += 1 right -= 1 trips += 1 return trips def solve(test_cases): results = [] for test in test_cases: n = test[0] capacity = test[1] weights = test[2] results.append(min_trips(capacity, weights)) return results"},{"question":"def find_optimal_village(n: int, roads: List[Tuple[int, int, int]]) -> int: Determine the optimal village to build the central warehouse such that the sum of distances from this warehouse to all other villages is minimized. Parameters: n (int): The number of villages. roads (List[Tuple[int, int, int]]): List of tuples representing roads where each tuple (u, v, w) means there is a road of length w connecting village u and village v. Returns: int: The number of the village where the warehouse should be built. Example: >>> find_optimal_village(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (3, 5, 1)]) 3 >>> find_optimal_village(2, [(1, 2, 1)]) 1 >>> find_optimal_village(4, [(1, 2, 1), (2, 3, 2), (2, 4, 3)]) 2 from solution import find_optimal_village def test_example(): roads = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (3, 5, 1)] assert find_optimal_village(5, roads) == 3 def test_single_edge(): roads = [(1, 2, 1)] assert find_optimal_village(2, roads) in [1, 2] def test_balanced_tree(): roads = [(1, 2, 1), (2, 3, 2), (2, 4, 3)] assert find_optimal_village(4, roads) == 2 def test_large_tree(): roads = [(1, 2, 1), (1, 3, 1), (2, 4, 1), (2, 5, 1), (3, 6, 1), (3, 7, 1)] assert find_optimal_village(7, roads) in [1, 2, 3]","solution":"from collections import defaultdict import sys def find_centroid(n, edges): def dfs(node, parent): subtree_size[node] = 1 is_centroid = True for neighbor, weight in graph[node]: if neighbor != parent: dfs(neighbor, node) subtree_size[node] += subtree_size[neighbor] if subtree_size[neighbor] > n // 2: is_centroid = False if n - subtree_size[node] > n // 2: is_centroid = False if is_centroid: centroids.append(node) graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) subtree_size = [0] * (n + 1) centroids = [] dfs(1, -1) return centroids[0] def find_optimal_village(n, road_list): return find_centroid(n, road_list)"},{"question":"def maxSubarraySum(arr, k): Returns the maximum possible sum of any subarray of length k, or -1 if k is greater than the length of the array. >>> maxSubarraySum([1, 2, 3, 4, 5], 3) 12 >>> maxSubarraySum([5, 4, -1, 7, 8], 2) 15 >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 3) 9 >>> maxSubarraySum([1, 2, 3], 5) -1","solution":"def maxSubarraySum(arr, k): Returns the maximum possible sum of any subarray of length k, or -1 if k is greater than the length of the array. n = len(arr) if k > n: return -1 # Calculate the sum of the first window of size k current_sum = sum(arr[:k]) max_sum = current_sum # Use sliding window technique to find the maximum sum of any subarray of length k for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def top_k_road_segments(n: int, k: int, traffic_loads: List[int]) -> Tuple[int, List[int]]: Identify the top-k road segments with the highest traffic load. >>> top_k_road_segments(5, 2, [10, 20, 30, 40, 50]) (90, [4, 5]) >>> top_k_road_segments(4, 2, [10, 10, 10, 10]) (20, [1, 2]) >>> top_k_road_segments(2, 1, [100]) (100, [1]) >>> top_k_road_segments(5, 2, [1000000000, 2000000000, 3000000000, 4000000000, 5000000000]) (9000000000, [4, 5]) >>> top_k_road_segments(6, 3, [10, 20, 30, 40, 50, 60]) (150, [4, 5, 6]) >>> top_k_road_segments(6, 3, [60, 50, 40, 30, 20, 10]) (150, [1, 2, 3])","solution":"def top_k_road_segments(n, k, traffic_loads): Identify the top-k road segments with the highest traffic load. Parameters: n (int): Number of cities k (int): Number of road segments to identify traffic_loads (list of int): Traffic loads on each road segment Returns: tuple: total traffic load of the top-k road segments and list of 1-based indices # Pair each traffic load with its index, then sort by traffic load in descending order indexed_loads = sorted(enumerate(traffic_loads, start=1), key=lambda x: -x[1]) # Select the top-k road segments top_k_segments = indexed_loads[:k] # Calculate the total traffic load total_load = sum(load for idx, load in top_k_segments) # Extract the indices and sort them in ascending order indices = sorted(idx for idx, load in top_k_segments) return total_load, indices"},{"question":"def can_rearrange(n, current, target, R, C): Determine if it is possible to rearrange the values in the grid such that the grid matches a target configuration. >>> can_rearrange(3, ... [[1, 2, 3], [4, 5, 6], [7, 8, 9]], ... [[9, 2, 3], [4, 5, 1], [7, 8, 6]], ... [[1, 1, 1], [1, 1, 1], [1, 1, 1]], ... [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) \\"YES\\" >>> can_rearrange(2, ... [[1, 2], [3, 4]], ... [[4, 3], [2, 1]], ... [[0, 0], [0, 0]], ... [[0, 0], [0, 0]]) \\"NO\\"","solution":"def can_rearrange(n, current, target, R, C): # Initialize a graph to represent the cells and their connections from collections import defaultdict, deque # A function to add edges to the graph based on the rules def add_edges(i, j, graph): if R[i][j] == 1: if j > 0: graph[(i, j)].add((i, j - 1)) graph[(i, j - 1)].add((i, j)) if j < n - 1: graph[(i, j)].add((i, j + 1)) graph[(i, j + 1)].add((i, j)) if C[i][j] == 1: if i > 0: graph[(i, j)].add((i - 1, j)) graph[(i - 1, j)].add((i, j)) if i < n - 1: graph[(i, j)].add((i + 1, j)) graph[(i + 1, j)].add((i, j)) # Build the graph from the given rotation rules graph = defaultdict(set) for i in range(n): for j in range(n): add_edges(i, j, graph) # A function to perform BFS and find all connected components def bfs(start, visited): queue = deque([start]) component = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return component # Discover all connected components visited = set() components = [] for i in range(n): for j in range(n): if (i, j) not in visited: component = bfs((i, j), visited) components.append(component) # For each component, check if the values can be rearranged to match the target configuration for component in components: current_values = [current[i][j] for i, j in component] target_values = [target[i][j] for i, j in component] if sorted(current_values) != sorted(target_values): return \\"NO\\" return \\"YES\\""},{"question":"def minimal_moves_to_palindrome(t: int, test_cases: List[str]) -> List[int]: Determine the minimal number of moves needed to make each string a palindrome. >>> minimal_moves_to_palindrome(1, [\\"abc\\"]) [1] >>> minimal_moves_to_palindrome(3, [\\"abc\\", \\"aabb\\", \\"abccba\\"]) [1, 2, 0] >>> minimal_moves_to_palindrome(1, [\\"racecar\\"]) == [0] >>> minimal_moves_to_palindrome(1, [\\"abca\\"]) == [1] >>> minimal_moves_to_palindrome(2, [\\"aaa\\", \\"aba\\"]) == [0, 0] >>> minimal_moves_to_palindrome(1, [\\"abcdefghihgfedcba\\"]) == [0] >>> minimal_moves_to_palindrome(1, [\\"a\\"]) == [0] >>> minimal_moves_to_palindrome(1, [\\"ab\\"]) == [1]","solution":"def minimal_moves_to_palindrome(t, test_cases): Returns the minimal number of moves to make the string a palindrome. results = [] for s in test_cases: left = 0 right = len(s) - 1 moves = 0 while left < right: if s[left] != s[right]: moves += 1 left += 1 right -= 1 results.append(moves) return results"},{"question":"def min_days_to_zero_heights(n: int, heights: List[int]) -> int: Given the number of buildings and their heights, return the minimum number of days required to reduce all buildings to zero heights. >>> min_days_to_zero_heights(5, [3, 3, 1, 2, 3]) 3 >>> min_days_to_zero_heights(4, [1, 2, 3, 4]) 4","solution":"def min_days_to_zero_heights(n, heights): Given the number of buildings and their heights, return the minimum number of days required to reduce all buildings to zero heights. if n == 0: return 0 days = 0 while max(heights) > 0: # Continue until all heights are reduced to zero min_height_non_zero = min([h for h in heights if h > 0]) for i in range(n): if heights[i] > 0: heights[i] -= min_height_non_zero days += min_height_non_zero return days"},{"question":"from typing import List, Tuple def min_operations_to_zero_array(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array \`arr\` of length \`n\` consisting of positive integers, determine the minimum number of operations needed to make all elements in the array zero. The operation consists of picking any subarray and setting all its elements to zero. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list containing tuples where each tuple contains an integer \`n\` and a list of \`n\` positive integers. Returns: List[int]: A list containing the minimum number of operations needed for each test case to make all elements zero. Example: >>> t = 4 >>> test_cases = [(5, [1, 2, 3, 4, 5]), (4, [0, 0, 0, 0]), (6, [1, 1, 0, 1, 1, 1]), (3, [1, 0, 1])] >>> min_operations_to_zero_array(t, test_cases) [1, 0, 2, 2] >>> t = 2 >>> test_cases = [(3, [0, 0, 0]), (5, [0, 0, 0, 0, 0])] >>> min_operations_to_zero_array(t, test_cases) [0, 0]","solution":"def min_operations_to_zero_array(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] if all(x == 0 for x in arr): results.append(0) continue # We count the number of subarrays of non-zero elements. seen_non_zero = False count = 0 for num in arr: if num != 0: if not seen_non_zero: count += 1 seen_non_zero = True else: seen_non_zero = False results.append(count) return results"},{"question":"def min_moves_to_reach_end(n, m, grid): Returns the minimum number of moves to reach the bottom-right cell from the top-left cell in a grid. Returns -1 if it is not possible. pass # Unit tests def test_example1(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert min_moves_to_reach_end(5, 5, grid) == 8 def test_example2(): grid = [ [0, 1, 1], [1, 1, 0], [1, 1, 0] ] assert min_moves_to_reach_end(3, 3, grid) == -1 def test_single_cell_path(): assert min_moves_to_reach_end(1, 1, [[0]]) == 0 def test_single_cell_blocked(): assert min_moves_to_reach_end(1, 1, [[1]]) == -1 def test_all_open(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_moves_to_reach_end(3, 3, grid) == 4 def test_no_possible_path(): grid = [ [0, 1], [1, 0] ] assert min_moves_to_reach_end(2, 2, grid) == -1","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): Returns the minimum number of moves to reach the bottom-right cell from the top-left cell in a grid. Returns -1 if it is not possible. if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 # Directions for moving in the grid (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the bottom-right cell if x == n-1 and y == m-1: return dist # Explore all possible movements for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def longest_ap_length(n: int, artifacts: List[int]) -> int: Returns the length of the longest subsequence that forms an arithmetic progression. >>> longest_ap_length(1, [5]) 1 >>> longest_ap_length(6, [3, 8, 5, 10, 15, 20]) 4 >>> longest_ap_length(5, [-5, -10, 0, -15, 5]) 5 >>> longest_ap_length(4, [7, 7, 7, 7]) 4 >>> longest_ap_length(5, [1, 4, 7, 10, 13]) 5 >>> longest_ap_length(7, [9, 4, 5, 1, 19, 13, 7]) 4","solution":"def longest_ap_length(n, artifacts): Returns the length of the longest subsequence that forms an arithmetic progression. if n == 1: return 1 artifacts.sort() dp = [{} for _ in range(n)] max_length = 1 for i in range(n): for j in range(i): diff = artifacts[i] - artifacts[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"from typing import List, Tuple def largest_scc(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Find the size and nodes of the largest Strongly Connected Component (SCC) in the network. :param n: number of servers :param m: number of communication channels :param edges: list of communication channels represented as tuples (u, v) :return: tuple containing size of the largest SCC and a list of servers in that SCC >>> largest_scc(6, 7, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5), (5, 6), (6, 4)]) (3, [1, 2, 3]) or (3, [4, 5, 6]) >>> largest_scc(5, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]) (3, [1, 2, 3]) or (2, [4, 5]) pass def test_case_1(): n = 6 m = 7 edges = [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5), (5, 6), (6, 4)] size, scc = largest_scc(n, m, edges) assert size == 3 assert sorted(scc) in [sorted([1, 2, 3]), sorted([4, 5, 6])] def test_case_2(): n = 5 m = 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)] size, scc = largest_scc(n, m, edges) assert size == 3 or size == 2 if size == 3: assert sorted(scc) == sorted([1, 2, 3]) else: assert sorted(scc) == sorted([4, 5]) def test_case_3(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 2)] size, scc = largest_scc(n, m, edges) assert size == 3 assert sorted(scc) == sorted([2, 3, 4]) def test_case_4(): n = 3 m = 2 edges = [(1, 2), (2, 3)] size, scc = largest_scc(n, m, edges) assert size == 1 assert scc in [[3], [1]] or [2] def test_case_5(): n = 1 m = 0 edges = [] size, scc = largest_scc(n, m, edges) assert size == 1 assert scc == [1]","solution":"from collections import defaultdict, deque def kosaraju_scc(n, edges): def dfs(v): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: dfs(neighbour) order.append(v) def reverse_dfs(v, component): visited[v] = True component.append(v) for neighbour in rev_graph[v]: if not visited[neighbour]: reverse_dfs(neighbour, component) graph = defaultdict(list) rev_graph = defaultdict(list) for u, v in edges: graph[u].append(v) rev_graph[v].append(u) visited = [False] * (n + 1) order = [] for i in range(1, n + 1): if not visited[i]: dfs(i) visited = [False] * (n + 1) components = [] while order: v = order.pop() if not visited[v]: component = [] reverse_dfs(v, component) components.append(component) largest_scc = max(components, key=len) return len(largest_scc), sorted(largest_scc) def largest_scc(n, m, edges): return kosaraju_scc(n, edges)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): A string of lowercase English letters. Returns: int: The length of the longest substring with at most two distinct characters. Examples: >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aaa\\") 3","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n # Sliding window left and right pointers left, right = 0, 0 # Hashmap character -> its rightmost position in the sliding window hashmap = {} max_len = 2 while right < n: # Add character to hashmap and move right pointer hashmap[s[right]] = right right += 1 # If there are more than 2 distinct characters if len(hashmap) == 3: # Delete the leftmost character to make room for the new character del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def find_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Given an undirected graph with n vertices and m edges, find the number of connected components in the graph, and for each connected component, print its size. >>> find_connected_components(1, 0, []) (1, [1]) >>> find_connected_components(5, 0, []) (5, [1, 1, 1, 1, 1]) >>> find_connected_components(6, 5, [(1, 2), (2, 3), (3, 4), (5, 6), (3, 4)]) (2, [2, 4]) >>> find_connected_components(4, 2, [(1, 2), (3, 4)]) (2, [2, 2]) >>> find_connected_components(4, 3, [(1, 2), (2, 3), (3, 4)]) (1, [4])","solution":"def find_connected_components(n, m, edges): from collections import defaultdict, deque # Create the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Helper function to perform BFS def bfs(start, visited): queue = deque([start]) visited[start] = True component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_size visited = [False] * (n + 1) component_sizes = [] for i in range(1, n + 1): if not visited[i]: size = bfs(i, visited) component_sizes.append(size) component_sizes.sort() return len(component_sizes), component_sizes"},{"question":"from typing import List def ladder_length(start: str, end: str, wordList: List[str]) -> int: Returns the length of the shortest transformation sequence from start to end. >>> ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0","solution":"from collections import deque def ladder_length(start, end, wordList): Returns the length of the shortest transformation sequence from start to end. if end not in wordList: return 0 wordSet = set(wordList) queue = deque([(start, 1)]) # Queue holds tuples of the word and the current length of the sequence while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordSet: wordSet.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"def max_difficulty_subset(k: int, L: int, difficulties: List[int]) -> int: Determine the maximum sum of difficulty levels of the problems that can be selected without exceeding L. >>> max_difficulty_subset(5, 10, [1, 2, 4, 5, 6]) 10 >>> max_difficulty_subset(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_difficulty_subset(4, 7, [7, 7, 7, 7]) 7 >>> max_difficulty_subset(3, 10, [10, 1, 2]) 10 >>> max_difficulty_subset(3, 15, [1, 2, 10]) 13 >>> max_difficulty_subset(5, 10, [6, 3, 2, 5, 1]) 10 >>> max_difficulty_subset(3, 100, [45, 60, 30]) 90","solution":"def max_difficulty_subset(k, L, difficulties): Returns the maximum sum of difficulty levels of the problems that can be selected without exceeding L. # Using 0/1 Knapsack Dynamic Programming approach dp = [0] * (L + 1) for difficulty in difficulties: for j in range(L, difficulty - 1, -1): dp[j] = max(dp[j], dp[j - difficulty] + difficulty) return dp[L] # Example usage k = 5 L = 10 difficulties = [1, 2, 4, 5, 6] print(max_difficulty_subset(k, L, difficulties)) # Output: 10"},{"question":"def max_simultaneous_users(logs: List[str]) -> int: Returns the maximum number of simultaneous users logged in at any given point in time. >>> logs = [ ... \\"6\\", ... \\"2023-01-01 08:00:00 1 login User1 logged in from IP 192.168.1.2\\", ... \\"2023-01-01 08:10:00 2 login User2 logged in from IP 192.168.1.3\\", ... \\"2023-01-01 08:30:00 1 logout User1 logged out\\", ... \\"2023-01-01 09:00:00 1 login User1 logged in from IP 192.168.1.2\\", ... \\"2023-01-01 09:15:00 2 logout User2 logged out\\", ... \\"2023-01-01 09:30:00 1 logout User1 logged out\\" ... ] >>> max_simultaneous_users(logs) 2 >>> logs = [ ... \\"1\\", ... \\"2023-01-01 08:00:00 1 login User1 logged in from IP 192.168.1.2\\" ... ] >>> max_simultaneous_users(logs) 1 >>> logs = [ ... \\"2\\", ... \\"2023-01-01 08:00:00 1 login User1 logged in from IP 192.168.1.2\\", ... \\"2023-01-01 08:10:00 1 logout User1 logged out\\" ... ] >>> max_simultaneous_users(logs) 1 >>> logs = [ ... \\"4\\", ... \\"2023-01-01 08:00:00 1 login User1 logged in from IP 192.168.1.2\\", ... \\"2023-01-01 08:05:00 1 logout User1 logged out\\", ... \\"2023-01-01 08:10:00 2 login User2 logged in from IP 192.168.1.3\\", ... \\"2023-01-01 08:15:00 2 logout User2 logged out\\" ... ] >>> max_simultaneous_users(logs) 1 >>> logs = [ ... \\"5\\", ... \\"2023-01-01 08:00:00 1 login User1 logged in from IP 192.168.1.2\\", ... \\"2023-01-01 08:05:00 2 login User2 logged in from IP 192.168.1.3\\", ... \\"2023-01-01 08:10:00 3 login User3 logged in from IP 192.168.1.4\\", ... \\"2023-01-01 08:15:00 1 logout User1 logged out\\", ... \\"2023-01-01 08:20:00 2 logout User2 logged out\\" ... ] >>> max_simultaneous_users(logs) 3","solution":"def max_simultaneous_users(logs): Returns the maximum number of simultaneous users logged in at any given point in time. import heapq from collections import defaultdict n = int(logs[0]) events = [] # Parse logs for i in range(1, n + 1): parts = logs[i].split() timestamp = parts[0] + ' ' + parts[1] user_id = int(parts[2]) event_type = parts[3] if event_type == 'login': events.append((timestamp, 1)) elif event_type == 'logout': events.append((timestamp, -1)) # Sort events by timestamp events.sort() max_users = 0 current_users = 0 # Traverse events and find the maximum number of simultaneous users for event in events: current_users += event[1] max_users = max(max_users, current_users) return max_users"},{"question":"def count_patterns_occurrences(dna: str, patterns: List[str]) -> List[int]: Counts the occurrences of each pattern in the DNA sequence. Args: dna (str): DNA sequence. patterns (list of str): List of patterns to be searched in the DNA sequence. Returns: list of int: List with the count of occurrences of each pattern. >>> count_patterns_occurrences(\\"ACGTACGTACGT\\", [\\"AC\\", \\"CGT\\", \\"G\\"]) [3, 3, 3] >>> count_patterns_occurrences(\\"ACGTACGTACGT\\", [\\"AAA\\", \\"CCC\\", \\"GGG\\"]) [0, 0, 0] >>> count_patterns_occurrences(\\"ACGTACGTACGT\\", [\\"A\\", \\"C\\", \\"G\\", \\"T\\"]) [3, 3, 3, 3] >>> count_patterns_occurrences(\\"\\", [\\"A\\", \\"C\\", \\"G\\", \\"T\\"]) [0, 0, 0, 0] >>> count_patterns_occurrences(\\"ACG\\", [\\"ACGT\\", \\"CGTA\\", \\"GTAC\\"]) [0, 0, 0]","solution":"def count_patterns_occurrences(dna, patterns): Counts the occurrences of each pattern in the DNA sequence. Args: dna (str): DNA sequence. patterns (list of str): List of patterns to be searched in the DNA sequence. Returns: list of int: List with the count of occurrences of each pattern. counts = [] for pattern in patterns: # Count the occurrences of \`pattern\` in \`dna\` count = dna.count(pattern) counts.append(count) return counts"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the shortest travel cost from city 1 to city n. :param n: Number of nodes (cities) :param m: Number of edges (one-way roads) :param edges: List of tuples containing edges in format (u, v, w) :return: The minimum cost to travel from city 1 to city n, or -1 if no such path exists Example usage: >>> shortest_path(5, 6, [(1, 2, 5), (2, 3, 10), (3, 4, 2), (4, 5, 1), (1, 3, 2), (3, 5, 3)]) 5 >>> shortest_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 4)]) 4 >>> shortest_path(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 4)]) 3 >>> shortest_path(4, 3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 12 >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 1)]) -1","solution":"import heapq def shortest_path(n, m, edges): def dijkstra(graph, start, end): distances = {node: float('inf') for node in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) return dijkstra(graph, 1, n)"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes sum queries on the array. Args: n : int : Number of elements in the array q : int : Number of queries array : list of int : The array elements queries : list of tuple : List of queries where each query is a tuple (l, r) Returns: list of int : List of results for each query return [] from solution import process_queries def test_example_case(): n = 5 q = 3 array = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected_output = [6, 9, 15] assert process_queries(n, q, array, queries) == expected_output def test_single_element_case(): n = 1 q = 1 array = [10] queries = [(1, 1)] expected_output = [10] assert process_queries(n, q, array, queries) == expected_output def test_entire_array_case(): n = 4 q = 1 array = [3, 1, 4, 1] queries = [(1, 4)] expected_output = [9] assert process_queries(n, q, array, queries) == expected_output def test_multiple_queries(): n = 6 q = 3 array = [1, 3, 5, 7, 9, 11] queries = [(1, 2), (2, 5), (3, 6)] expected_output = [4, 24, 32] assert process_queries(n, q, array, queries) == expected_output def test_repeated_elements(): n = 5 q = 2 array = [2, 2, 2, 2, 2] queries = [(1, 3), (2, 5)] expected_output = [6, 8] assert process_queries(n, q, array, queries) == expected_output def test_large_numbers(): n = 3 q = 2 array = [1000000000, 1000000000, 1000000000] queries = [(1, 2), (1, 3)] expected_output = [2000000000, 3000000000] assert process_queries(n, q, array, queries) == expected_output","solution":"def process_queries(n, q, array, queries): Processes sum queries on the array. Args: n : int : Number of elements in the array q : int : Number of queries array : list of int : The array elements queries : list of tuple : List of queries where each query is a tuple (l, r) Returns: list of int : List of results for each query # Compute the prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i-1] + array[i-1] # Process each query results = [] for l, r in queries: result = prefix_sums[r] - prefix_sums[l-1] results.append(result) return results"},{"question":"def can_reach_last_platform(n: int, d: int, heights: List[int]) -> str: Determines if the player can reach the last platform given the maximum allowed height difference. Parameters: n (int): The number of platforms. d (int): The maximum allowed height difference. heights (list): The heights of the platforms. Returns: str: \\"YES\\" if the player can reach the last platform, otherwise \\"NO\\". >>> can_reach_last_platform(5, 3, [1, 4, 2, 3, 5]) \\"YES\\" >>> can_reach_last_platform(5, 1, [1, 4, 2, 3, 5]) \\"NO\\" >>> can_reach_last_platform(4, 0, [3, 3, 3, 3]) \\"YES\\" >>> can_reach_last_platform(6, 10, [0, 10, 0, 10, 0, 10]) \\"YES\\" >>> can_reach_last_platform(1, 0, [5]) \\"YES\\"","solution":"def can_reach_last_platform(n, d, heights): Determines if the player can reach the last platform given the maximum allowed height difference. Parameters: n (int): The number of platforms. d (int): The maximum allowed height difference. heights (list): The heights of the platforms. Returns: str: \\"YES\\" if the player can reach the last platform, otherwise \\"NO\\". for i in range(n - 1): if abs(heights[i + 1] - heights[i]) > d: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def longest_palindromic_substring(s: str) -> str: Find the longest substring of \`s\` that can be permuted to form a palindrome. If there are multiple answers, return the lexicographically smallest one. pass def solve(test_cases: List[str]) -> List[str]: Solve multiple test cases to find the longest palindromic substrings. >>> solve([\\"abacaba\\", \\"aabb\\"]) [\\"abacaba\\", \\"aabb\\"] >>> solve([\\"abcd\\", \\"a\\", \\"abcba\\"]) [\\"a\\", \\"a\\", \\"abcba\\"] pass","solution":"def longest_palindromic_substring(s): from collections import Counter n = len(s) max_len = 0 best_substring = None # Check all substrings for i in range(n): for j in range(i, n): substring = s[i:j+1] counter = Counter(substring) odd_count = sum(1 for count in counter.values() if count % 2 == 1) # If at most one character has an odd count, it can be permuted to a palindrome if odd_count <= 1: if (j - i + 1) > max_len or ((j - i + 1) == max_len and substring < best_substring): max_len = j - i + 1 best_substring = substring return best_substring def solve(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring(s)) return results"},{"question":"def lexicographically_smallest_string(t: int, strings: List[str]) -> List[str]: Determine the lexicographically smallest string you can obtain by applying the allowed operation any number of times for each test case. Args: t: Number of test cases. strings: List of strings for each test case. Returns: List of lexicographically smallest strings for each test case. >>> lexicographically_smallest_string(3, [\\"cba\\", \\"aabc\\", \\"dcab\\"]) ['abc', 'aabc', 'abcd'] >>> lexicographically_smallest_string(2, [\\"a\\", \\"b\\"]) ['a', 'b'] >>> lexicographically_smallest_string(2, [\\"abc\\", \\"abcd\\"]) ['abc', 'abcd'] >>> lexicographically_smallest_string(2, [\\"cba\\", \\"dcba\\"]) ['abc', 'abcd'] >>> lexicographically_smallest_string(3, [\\"aab\\", \\"bba\\", \\"ccba\\"]) ['aab', 'abb', 'abcc']","solution":"def lexicographically_smallest_string(t, strings): results = [] for s in strings: results.append(\\"\\".join(sorted(s))) return results"},{"question":"class ServerNetwork: def __init__(self, n): self.n = n self.tree = [[] for _ in range(n + 1)] self.suspended = [False] * (n + 1) def add_edge(self, parent, child): self.tree[parent].append(child) def suspend(self, server): self.suspended[server] = True def can_communicate(self, server): while server != 1: if self.suspended[server]: return \\"no\\" for parent in range(1, self.n + 1): if server in self.tree[parent]: server = parent break return \\"no\\" if self.suspended[1] else \\"yes\\" def process_queries(n, m, edges, queries): Simulate the suspension of servers and determine which servers can still communicate with the root based on the given queries. Args: n (int): Number of servers m (int): Number of queries edges (List[Tuple[int, int]]): List of edges where each edge (u, v) denotes server u is parent of server v queries (List[Tuple[str, int]]): List of queries where 's x' is to suspend server x and 'q x' is to query if server x can communicate with the root Returns: List[str]: List of \\"yes\\" or \\"no\\" for each query of type 'q x' Examples: >>> process_queries(6, 5, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], [('s', 2), ('q', 4), ('q', 5), ('q', 6), ('s', 1), ('q', 3)]) ['no', 'no', 'yes', 'no'] >>> process_queries(4, 3, [(1, 2), (1, 3), (3, 4)], [('q', 2), ('q', 3), ('q', 4)]) ['yes', 'yes', 'yes']","solution":"class ServerNetwork: def __init__(self, n): self.n = n self.tree = [[] for _ in range(n + 1)] self.suspended = [False] * (n + 1) def add_edge(self, parent, child): self.tree[parent].append(child) def suspend(self, server): self.suspended[server] = True def can_communicate(self, server): while server != 1: if self.suspended[server]: return \\"no\\" for parent in range(1, self.n + 1): if server in self.tree[parent]: server = parent break return \\"no\\" if self.suspended[1] else \\"yes\\" def process_queries(n, m, edges, queries): sn = ServerNetwork(n) for u, v in edges: sn.add_edge(u, v) results = [] for query in queries: if query[0] == 's': sn.suspend(query[1]) elif query[0] == 'q': results.append(sn.can_communicate(query[1])) return results"},{"question":"def find_missing_side_length(test_cases): Determines the missing side length for a given number of rectangles. Parameters: test_cases (list of tuples): List of tuples containing the lengths of three sides of the rectangle. Returns: list of int: List of the missing side lengths for each rectangle. Examples: >>> find_missing_side_length([(5, 10, 5)]) [10] >>> find_missing_side_length([(7, 7, 14)]) [14] >>> find_missing_side_length([(8, 8, 16)]) [16] >>> find_missing_side_length([(20, 15, 20)]) [15]","solution":"def find_missing_side_length(test_cases): Determines the missing side length for a given number of rectangles Parameters: test_cases (list of tuples): List of tuples containing the lengths of three sides of the rectangle Returns: list of int: List of the missing side lengths for each rectangle results = [] for a, b, c in test_cases: if a == b: results.append(c) elif a == c: results.append(b) else: results.append(a) return results"},{"question":"def find_connected_components_and_largest(graph, n, m): Given an undirected graph with n nodes and m edges, find the number of connected components in the graph and determine the size of the largest connected component. Args: graph : List[Tuple[int, int]] : List containing the edges of the graph n : int : Number of nodes in the graph m : int : Number of edges in the graph Returns: Tuple[int, int] : Number of connected components and size of the largest connected component >>> find_connected_components_and_largest([(1, 2), (2, 3), (4, 5)], 6, 3) (3, 3) >>> find_connected_components_and_largest([], 1, 0) (1, 1) >>> find_connected_components_and_largest([(1, 2), (1, 3), (2, 3)], 3, 3) (1, 3) >>> find_connected_components_and_largest([], 4, 0) (4, 1) >>> find_connected_components_and_largest([(1, 2), (2, 3), (3, 4), (4, 5)], 5, 4) (1, 5)","solution":"def find_connected_components_and_largest(graph, n, m): def dfs(node, visited, adj_list): stack = [node] size = 0 while stack: v = stack.pop() if v not in visited: visited.add(v) size += 1 for neighbor in adj_list[v]: if neighbor not in visited: stack.append(neighbor) return size adj_list = {i: [] for i in range(1, n+1)} for u, v in graph: adj_list[u].append(v) adj_list[v].append(u) visited = set() num_components = 0 largest_component_size = 0 for node in range(1, n+1): if node not in visited: num_components += 1 component_size = dfs(node, visited, adj_list) largest_component_size = max(largest_component_size, component_size) return num_components, largest_component_size"},{"question":"def is_anagram(S: str, T: str) -> str: Determines if T is an anagram of S. :param S: Original string. :param T: String to test if anagram of S. :return: \\"YES\\" if T is an anagram of S, otherwise \\"NO\\". >>> is_anagram(\\"listen\\", \\"silent\\") \\"YES\\" >>> is_anagram(\\"triangle\\", \\"integral\\") \\"YES\\" >>> is_anagram(\\"hello\\", \\"bello\\") \\"NO\\"","solution":"def is_anagram(S: str, T: str) -> str: Determines if T is an anagram of S. :param S: Original string. :param T: String to test if anagram of S. :return: \\"YES\\" if T is an anagram of S, otherwise \\"NO\\". from collections import Counter return \\"YES\\" if Counter(S) == Counter(T) else \\"NO\\""},{"question":"from typing import List def reorganize_string(s: str) -> str: Given a string s consisting of lowercase Latin letters, determine if it is possible to reorder the characters of s to form a string that does not contain two identical adjacent characters. If it is possible, return any possible reorganization of the string. If it is not possible, return \\"IMPOSSIBLE\\". >>> reorganize_string(\\"aab\\") in [\\"aba\\", \\"bab\\"] True >>> reorganize_string(\\"aaab\\") == \\"IMPOSSIBLE\\" True >>> reorganize_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases for the reorganization of strings. >>> process_test_cases(3, [\\"aab\\", \\"aaab\\", \\"abc\\"]) ['aba', 'IMPOSSIBLE', 'acb'] def test_reorganize_string(): assert reorganize_string(\\"aab\\") in [\\"aba\\", \\"bab\\"] assert reorganize_string(\\"aaab\\") == \\"IMPOSSIBLE\\" assert reorganize_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_process_test_cases(): t = 3 test_cases = [\\"aab\\", \\"aaab\\", \\"abc\\"] expected_output = [\\"aba\\", \\"IMPOSSIBLE\\", \\"acb\\"] output = process_test_cases(t, test_cases) assert output[0] in [\\"aba\\", \\"bab\\"] assert output[1] == \\"IMPOSSIBLE\\" assert output[2] in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] if __name__ == \\"__main__\\": test_reorganize_string() test_process_test_cases()","solution":"from heapq import heappush, heappop from collections import Counter def reorganize_string(s): counter = Counter(s) max_count = max(counter.values()) if max_count > (len(s) + 1) // 2: return \\"IMPOSSIBLE\\" max_heap = [] for char, count in counter.items(): heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) if prev_char is not None: heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 if prev_count == 0: prev_char = None prev_count = 0 if len(result) != len(s): return \\"IMPOSSIBLE\\" return ''.join(result) def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(reorganize_string(s)) return results"},{"question":"def longest_contiguous_subsequence(arr): Finds the length of the longest contiguous subsequence where the difference between consecutive elements is consistently either 1 or -1. :param arr: List of integers :return: Length of the longest contiguous subsequence >>> longest_contiguous_subsequence([1, 2, 3, 2, 1, 2, 3]) 7 >>> longest_contiguous_subsequence([5, 6, 7, 8, 5, 4, 3, 2, 3, 4]) 6 >>> longest_contiguous_subsequence([1]) 1 >>> longest_contiguous_subsequence([1, 3, 5, 7, 9]) 1 >>> longest_contiguous_subsequence([4, 4, 4, 4]) 1 >>> longest_contiguous_subsequence([1, 2, 1, 2, 1, 2, 1, 2]) 8 >>> longest_contiguous_subsequence(list(range(1, 100001))) 100000 >>> longest_contiguous_subsequence([5, 1, 2, 3, 2, 1, 10, 20]) 5 >>> longest_contiguous_subsequence([1000000, 999999, 1000000, 999999, 999998]) 5","solution":"def longest_contiguous_subsequence(arr): Finds the length of the longest contiguous subsequence where the difference between consecutive elements is consistently either 1 or -1. :param arr: List of integers :return: Length of the longest contiguous subsequence if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def longest_subarray_with_product_not_greater_than_k(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subarray with product of elements not greater than k. >>> longest_subarray_with_product_not_greater_than_k(5, 10, [1, 2, 3, 4, 5]) 3 >>> longest_subarray_with_product_not_greater_than_k(4, 2, [3, 4, 5, 6]) 0 >>> longest_subarray_with_product_not_greater_than_k(1, 5, [5]) 1 >>> longest_subarray_with_product_not_greater_than_k(5, 120, [2, 3, 4, 5, 1]) 5 >>> longest_subarray_with_product_not_greater_than_k(5, 4, [5, 2, 2, 4, 1]) 2 >>> longest_subarray_with_product_not_greater_than_k(6, 6, [1, 1, 1, 1, 1, 1]) 6 >>> longest_subarray_with_product_not_greater_than_k(4, 1000000000000000000, [100000, 1000000, 1000, 10]) 4 pass","solution":"def longest_subarray_with_product_not_greater_than_k(n, k, arr): Returns the length of the longest subarray with product of elements not greater than k. left = 0 right = 0 max_length = 0 current_product = 1 for right in range(n): current_product *= arr[right] while left <= right and current_product > k: current_product /= arr[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_be_palindrome_by_removing_one_char(s: str) -> bool: Determine if we can make the string a palindrome by removing at most one character. >>> can_be_palindrome_by_removing_one_char(\\"abca\\") True >>> can_be_palindrome_by_removing_one_char(\\"abc\\") False >>> can_be_palindrome_by_removing_one_char(\\"a\\") True >>> can_be_palindrome_by_removing_one_char(\\"racecar\\") True >>> can_be_palindrome_by_removing_one_char(\\"\\") True >>> can_be_palindrome_by_removing_one_char(\\"raacecar\\") True >>> can_be_palindrome_by_removing_one_char(\\"raccecar\\") True >>> can_be_palindrome_by_removing_one_char(\\"goog\\") True >>> can_be_palindrome_by_removing_one_char(\\"gool\\") False >>> can_be_palindrome_by_removing_one_char(\\"abccba\\") True","solution":"def can_be_palindrome_by_removing_one_char(s): Determine if we can make the string a palindrome by removing at most one character. def is_palindrome_range(i, j): return all(s[x] == s[j-x+i] for x in range(i, j//2+1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 return True"},{"question":"from typing import List, Dict def process_feedback(feedback_list: List[Dict]) -> Dict: Processes a list of feedback submissions and computes average ratings and comments count. Parameters: feedback_list (list): A list of dictionaries, each representing a feedback submission. Returns: dict: A dictionary containing the average ratings and the count of feedback submissions with comments. Example: >>> feedback_list = [ ... { ... \\"customer_id\\": 1234, ... \\"ratings\\": { ... \\"product_quality\\": 4, ... \\"delivery_service\\": 5, ... \\"customer_service\\": 3 ... }, ... \\"comments\\": \\"The product was as described, but the delivery was slow.\\" ... }, ... { ... \\"customer_id\\": 5678, ... \\"ratings\\": { ... \\"product_quality\\": 3, ... \\"delivery_service\\": 4, ... \\"customer_service\\": 5 ... }, ... \\"comments\\": \\"\\" ... }, ... { ... \\"customer_id\\": 4321, ... \\"ratings\\": { ... \\"product_quality\\": 5, ... \\"delivery_service\\": 4, ... \\"customer_service\\": 2 ... }, ... \\"comments\\": \\"The support was very helpful but the product was damaged during delivery.\\" ... } ... ] >>> process_feedback(feedback_list) { \\"average_ratings\\": { \\"product_quality\\": 4.0, \\"delivery_service\\": 4.3, \\"customer_service\\": 3.3 }, \\"comments_count\\": 2 } # Your code here def test_process_feedback_basic(): feedback_list = [ { \\"customer_id\\": 1234, \\"ratings\\": { \\"product_quality\\": 4, \\"delivery_service\\": 5, \\"customer_service\\": 3 }, \\"comments\\": \\"The product was as described, but the delivery was slow.\\" }, { \\"customer_id\\": 5678, \\"ratings\\": { \\"product_quality\\": 3, \\"delivery_service\\": 4, \\"customer_service\\": 5 }, \\"comments\\": \\"\\" }, { \\"customer_id\\": 4321, \\"ratings\\": { \\"product_quality\\": 5, \\"delivery_service\\": 4, \\"customer_service\\": 2 }, \\"comments\\": \\"The support was very helpful but the product was damaged during delivery.\\" } ] result = process_feedback(feedback_list) expected = { \\"average_ratings\\": { \\"product_quality\\": 4.0, \\"delivery_service\\": 4.3, \\"customer_service\\": 3.3 }, \\"comments_count\\": 2 } assert result == expected def test_process_feedback_all_comments_empty(): feedback_list = [ { \\"customer_id\\": 1234, \\"ratings\\": { \\"product_quality\\": 4, \\"delivery_service\\": 5, \\"customer_service\\": 3 }, \\"comments\\": \\"\\" }, { \\"customer_id\\": 5678, \\"ratings\\": { \\"product_quality\\": 3, \\"delivery_service\\": 4, \\"customer_service\\": 5 }, \\"comments\\": \\"\\" } ] result = process_feedback(feedback_list) expected = { \\"average_ratings\\": { \\"product_quality\\": 3.5, \\"delivery_service\\": 4.5, \\"customer_service\\": 4.0 }, \\"comments_count\\": 0 } assert result == expected def test_process_feedback_single_submission(): feedback_list = [ { \\"customer_id\\": 1234, \\"ratings\\": { \\"product_quality\\": 5, \\"delivery_service\\": 3, \\"customer_service\\": 4 }, \\"comments\\": \\"Great product but average delivery.\\" } ] result = process_feedback(feedback_list) expected = { \\"average_ratings\\": { \\"product_quality\\": 5.0, \\"delivery_service\\": 3.0, \\"customer_service\\": 4.0 }, \\"comments_count\\": 1 } assert result == expected def test_process_feedback_no_comments(): feedback_list = [ { \\"customer_id\\": 1234, \\"ratings\\": { \\"product_quality\\": 4, \\"delivery_service\\": 5, \\"customer_service\\": 3 }, \\"comments\\": None }, { \\"customer_id\\": 5678, \\"ratings\\": { \\"product_quality\\": 3, \\"delivery_service\\": 4, \\"customer_service\\": 5 }, \\"comments\\": \\"\\" } ] result = process_feedback(feedback_list) expected = { \\"average_ratings\\": { \\"product_quality\\": 3.5, \\"delivery_service\\": 4.5, \\"customer_service\\": 4.0 }, \\"comments_count\\": 0 } assert result == expected def test_process_feedback_mixed_comments(): feedback_list = [ { \\"customer_id\\": 1234, \\"ratings\\": { \\"product_quality\\": 4, \\"delivery_service\\": 5, \\"customer_service\\": 3 }, \\"comments\\": \\"\\" }, { \\"customer_id\\": 5678, \\"ratings\\": { \\"product_quality\\": 3, \\"delivery_service\\": 4, \\"customer_service\\": 5 }, \\"comments\\": \\"Satisfied with the service.\\" } ] result = process_feedback(feedback_list) expected = { \\"average_ratings\\": { \\"product_quality\\": 3.5, \\"delivery_service\\": 4.5, \\"customer_service\\": 4.0 }, \\"comments_count\\": 1 } assert result == expected","solution":"def process_feedback(feedback_list): Processes a list of feedback submissions and computes average ratings and comments count. Parameters: feedback_list (list): A list of dictionaries, each representing a feedback submission. Returns: dict: A dictionary containing the average ratings and the count of feedback submissions with comments. total_ratings = {} count_ratings = {} comments_count = 0 for feedback in feedback_list: # Count the comments if present if feedback.get(\\"comments\\"): comments_count += 1 # Aggregate ratings for aspect, rating in feedback[\\"ratings\\"].items(): if aspect not in total_ratings: total_ratings[aspect] = 0 count_ratings[aspect] = 0 total_ratings[aspect] += rating count_ratings[aspect] += 1 # Calculate average ratings average_ratings = {aspect: round(total / count_ratings[aspect], 1) for aspect, total in total_ratings.items()} return { \\"average_ratings\\": average_ratings, \\"comments_count\\": comments_count }"},{"question":"def min_operations_to_equalize_sequence(n: int, a: List[int]) -> int: Returns the minimum number of operations required to make all elements of the sequence equal. Each operation consists of adding 1 to two adjacent elements. >>> min_operations_to_equalize_sequence(3, [1, 2, 3]) == 3 >>> min_operations_to_equalize_sequence(4, [5, 5, 5, 5]) == 0 >>> min_operations_to_equalize_sequence(1, [1000]) == 0 >>> min_operations_to_equalize_sequence(5, [0, 2, 4, 6, 8]) == 20 >>> min_operations_to_equalize_sequence(4, [0, 0, 0, 10]) == 30 >>> min_operations_to_equalize_sequence(3, [100, 200, 300]) == 300 # Your code here","solution":"def min_operations_to_equalize_sequence(n, a): Returns the minimum number of operations required to make all elements of the sequence equal. Each operation consists of adding 1 to two adjacent elements. max_val = max(a) operations = 0 for num in a: operations += max_val - num return operations"},{"question":"def minimize_sum_of_differences(n: int, scores: List[int], prizes: List[int]) -> int: Minimizes the sum of absolute differences between contestant scores and prize values. Args: n (int): Number of contestants scores (list of int): Scores of the contestants prizes (list of int): Values of the prizes Returns: int: The minimized sum of absolute differences Example: >>> minimize_sum_of_differences(4, [1, 2, 3, 4], [4, 3, 2, 1]) 0 >>> minimize_sum_of_differences(3, [5, 5, 5], [5, 5, 5]) 0","solution":"def minimize_sum_of_differences(n, scores, prizes): Minimizes the sum of absolute differences between contestant scores and prize values. Args: n (int): Number of contestants scores (list of int): Scores of the contestants prizes (list of int): Values of the prizes Returns: int: The minimized sum of absolute differences # Sort both lists scores.sort() prizes.sort() # Calculate the minimized sum of absolute differences minimized_sum = sum(abs(scores[i] - prizes[i]) for i in range(n)) return minimized_sum"},{"question":"from typing import List, Tuple def find_feeders(t: int, cases: List[Tuple[int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]: Determine the minimum number of feeders required and their possible positions. Args: t (int): The number of test cases. cases (List[Tuple[int, List[Tuple[int, int, int]]]]): Each test case contains the number of beehives and a list describing the beehives with their coordinates and radii. Returns: List[List[Tuple[int, int]]]: A list of lists where each inner list contains the coordinates of each feeder for the corresponding test case. >>> find_feeders(1, [(1, [(0, 0, 1)])]) [[(0, 0)]] >>> find_feeders(1, [(2, [(0, 0, 1), (5, 5, 1)])]) [[(0, 0), (5, 5)]] >>> find_feeders(1, [(2, [(0, 0, 3), (2, 2, 3)])]) [[(0, 0), (2, 2)]] >>> find_feeders(2, [(1, [(0, 0, 2)]), (2, [(0, 0, 2), (5, 5, 2)])]) [[(0, 0)], [(0, 0), (5, 5)]] # Function implementation to be added here","solution":"def find_feeders(t, cases): results = [] for i in range(t): n = cases[i][0] beehives = cases[i][1] feeders = set() for x, y, r in beehives: found_feeder = False for xi in range(x - r, x + r + 1): if found_feeder: break for yi in range(y - r, y + r + 1): if (xi - x)**2 + (yi - y)**2 <= r**2: feeders.add((xi, yi)) found_feeder = True break results.append(list(feeders)) return results"},{"question":"def min_moves_to_gather_haystacks(n: int, m: int, grid: List[str]) -> int: Farmer Joe has a rectangular barn, which is represented as a grid of size n x m. Each cell in the grid is either empty or contains a haystack. Joe wants to move all haystacks to a single target cell using the minimum number of moves. A move consists of moving a haystack from one cell to an adjacent cell (up, down, left, right). Given the initial positions of all haystacks and the dimensions of the barn, determine the minimum number of moves required to gather all haystacks into one cell. Example: >>> min_moves_to_gather_haystacks(3, 3, [\\"H..\\", \\".H.\\", \\"..H\\"]) 4 >>> min_moves_to_gather_haystacks(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> min_moves_to_gather_haystacks(1, 1, [\\"H\\"]) 0 >>> min_moves_to_gather_haystacks(3, 3, [\\"HHH\\", \\"...\\", \\"...\\"]) 2 >>> min_moves_to_gather_haystacks(3, 3, [\\"H..\\", \\"H..\\", \\"H..\\"]) 2 >>> min_moves_to_gather_haystacks(3, 3, [\\"H..\\", \\".H.\\", \\"..H\\"]) 4","solution":"def min_moves_to_gather_haystacks(n, m, grid): haystacks = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'H'] def total_moves_to_target(target_i, target_j): return sum(abs(hi - target_i) + abs(hj - target_j) for hi, hj in haystacks) min_moves = float('inf') for i in range(n): for j in range(m): min_moves = min(min_moves, total_moves_to_target(i, j)) return min_moves"},{"question":"from typing import List def count_subsets_with_sum(arr: List[int], target: int) -> int: Given an array of integers and a target integer, find the number of ways to select a subset of the array that sums exactly to the target integer. Each element in the array can only be used once. Parameters: arr (List[int]): The list of integers. target (int): The target sum. Returns: int: The number of subsets that sum to the target integer. Example: >>> count_subsets_with_sum([2, 3, 7, 8, 10], 10) 3 >>> count_subsets_with_sum([1, 2, 3, 4, 5], 5) 3 >>> count_subsets_with_sum([2, 4, 6], 5) 0 # Unit Tests def test_single_element(): assert count_subsets_with_sum([10], 10) == 1 def test_multiple_elements_single_subset(): assert count_subsets_with_sum([2, 3, 7, 8, 10], 10) == 3 def test_no_subsets(): assert count_subsets_with_sum([2, 4, 6], 5) == 0 def test_multiple_elements_multiple_subsets(): assert count_subsets_with_sum([2, 3, 7, 8, 10], 10) == 3 assert count_subsets_with_sum([1, 2, 3, 4, 5], 5) == 3 def test_empty_array(): assert count_subsets_with_sum([], 10) == 0 def test_large_target(): assert count_subsets_with_sum([1, 2, 3, 4, 5], 15) == 1 def test_repeated_elements(): assert count_subsets_with_sum([1, 1, 1, 1], 2) == 6","solution":"from itertools import combinations def count_subsets_with_sum(arr, target): Given an array of integers and a target integer, this function finds the number of ways to select a subset of the array that sums exactly to the target integer. Each element in the array can only be used once. Parameters: arr (list): The list of integers. target (int): The target sum. Returns: int: The number of subsets that sum to the target integer. n = len(arr) count = 0 # Generate all possible subsets and check their sums for r in range(1, n + 1): for subset in combinations(arr, r): if sum(subset) == target: count += 1 return count"},{"question":"def largest_special_k(n, A, B): Finds the largest special k such that for every ai in A and bi in B: ai % k == bi % k Parameters: n: int - the length of the sequences A: List[int] - the sequence A B: List[int] - the sequence B Returns: int - the largest special integer k or -1 if no such k exists >>> largest_special_k(3, [1, 2, 3], [3, 4, 5]) == 2 >>> largest_special_k(3, [1, 1, 1], [1, 1, 1]) == 0 >>> largest_special_k(3, [1, 2, 3], [7, 8, 9]) == 6 >>> largest_special_k(5, [100000000, 200000000, 300000000, 400000000, 500000000], [100000000, 200000001, 300000002, 400000003, 500000004]) == 1 >>> largest_special_k(4, [10, 20, 30, 40], [0, 10, 20, 30]) == 10","solution":"def largest_special_k(n, A, B): Finds the largest special k such that for every ai in A and bi in B: ai % k == bi % k # Compute the differences between corresponding elements of A and B diffs = [abs(A[i] - B[i]) for i in range(n)] # Function to compute the greatest common divisor def gcd(x, y): while y: x, y = y, x % y return x # Find the gcd of all differences common_gcd = diffs[0] for diff in diffs[1:]: common_gcd = gcd(common_gcd, diff) if common_gcd == 1: # Early exit if gcd becomes 1 break return common_gcd # Example usage: # print(largest_special_k(3, [1, 2, 3], [3, 4, 5])) # Output should be 2"},{"question":"def can_form_team(n: int, employees: List[str], essential_skills: str) -> str: Determine if a combination of employees can be found such that all essential skills are covered. >>> can_form_team(3, [\\"abc\\", \\"bcd\\", \\"def\\"], \\"abcdef\\") \\"Yes\\" >>> can_form_team(3, [\\"ab\\", \\"cd\\", \\"ef\\"], \\"abcdefg\\") \\"No\\" >>> can_form_team(1, [\\"abcdef\\"], \\"abcdef\\") \\"Yes\\" >>> can_form_team(3, [\\"abcdef\\", \\"ghij\\", \\"klmnop\\"], \\"abcdefghijklmnop\\") \\"Yes\\" >>> can_form_team(3, [\\"abc\\", \\"def\\", \\"ghi\\"], \\"abcdefghijklmnopqrstuvwxyz\\") \\"No\\"","solution":"def can_form_team(n, employees, essential_skills): from functools import reduce # Combine all unique skills from the employees combined_skills = reduce(set.union, map(set, employees), set()) # Check if the combined skills covers all essential skills if all(skill in combined_skills for skill in essential_skills): return \\"Yes\\" else: return \\"No\\""},{"question":"def find_most_beautiful_arrangement(n, m, heights, adjacency_constraints): Daniel is an avid gardener and loves to plant trees in his garden. He recently purchased n different types of trees, and he wants to plant them in a way that maximizes the beauty of his garden. The beauty of the garden is determined by the height differences between adjacent trees - the smaller the difference, the more beautiful the arrangement. Daniel has also noted that some trees need to be planted next to each other to ensure they grow properly. He has m pairs of trees that need to be adjacent when planted. Your task is to help Daniel find the most beautiful arrangement of the trees, while respecting the adjacency constraints. Each type of tree i has a given height hi. The difference in height between two adjacent trees i and j is |hi - hj|. Args: n (int): the number of different types of trees. m (int): the number of pairs of trees that need to be adjacent. heights (List[int]): array of n integers heights[i] representing the height of the i-th type of tree. adjacency_constraints (List[Tuple[int, int]]): m pairs of integers indicating trees that need to be adjacent. Returns: int: The maximum beauty factor of the garden if it's possible to plant the trees as required. If it is not possible to plant the trees while respecting the adjacency constraints, return -1. Test cases: >>> find_most_beautiful_arrangement(3, 2, [3, 4, 5], [(1, 2), (2, 3)]) 2 >>> find_most_beautiful_arrangement(3, 2, [1, 3, 2], [(1, 2), (1, 3)]) -1 >>> find_most_beautiful_arrangement(3, 0, [5, 10, 15], []) 10 >>> find_most_beautiful_arrangement(1, 0, [10], []) 0 >>> find_most_beautiful_arrangement(4, 3, [1, 1, 1, 1], [(1, 2), (2, 3), (3, 4)]) 0","solution":"def find_most_beautiful_arrangement(n, m, heights, adjacency_constraints): from itertools import permutations import sys constraints_list = set() for a, b in adjacency_constraints: constraints_list.add((a - 1, b - 1)) constraints_list.add((b - 1, a - 1)) def is_valid_arrangement(arr): for i in range(n - 1): if (arr[i], arr[i + 1]) in constraints_list: constraints_list.remove((arr[i], arr[i + 1])) else: return False return True if m == 0: return sum(abs(heights[i] - heights[i + 1]) for i in range(n - 1)) min_diff = sys.maxsize for perm in permutations(range(n)): if is_valid_arrangement(perm): diff = sum(abs(heights[perm[i]] - heights[perm[i + 1]]) for i in range(n - 1)) if diff < min_diff: min_diff = diff return min_diff if min_diff != sys.maxsize else -1"},{"question":"from typing import List, Tuple def minimum_maintenance_cost(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> int: Returns the minimum maintenance cost required to keep all islands connected. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST) of the given graph. >>> minimum_maintenance_cost(4, 5, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)]) 6 >>> minimum_maintenance_cost(3, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 1)]) 3 >>> minimum_maintenance_cost(5, 7, [(1, 2, 4), (1, 3, 4), (2, 3, 2), (3, 4, 3), (4, 5, 5), (3, 5, 1), (2, 4, 3)]) 10 >>> minimum_maintenance_cost(2, 1, [(1, 2, 10)]) 10 >>> minimum_maintenance_cost(4, 6, [(1, 2, 2), (1, 3, 3), (2, 3, 1), (2, 4, 5), (3, 4, 7), (1, 4, 6)]) 8","solution":"def minimum_maintenance_cost(n, m, bridges): Returns the minimum maintenance cost required to keep all islands connected. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST) of the given graph. # Helper function to find the parent of a node def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to union two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) # Attach smaller rank tree under root of higher rank tree if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x # If the ranks are the same, make one root and increment its rank by one else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal's algorithm to find the MST bridges.sort(key=lambda x: x[2]) # Sort all bridges by cost parent = [i for i in range(n)] rank = [0] * n total_cost = 0 edge_count = 0 for u, v, w in bridges: u -= 1 # Convert to 0 based index v -= 1 # Convert to 0 based index root_u = find(parent, u) root_v = find(parent, v) # If including this edge does not form a cycle if root_u != root_v: total_cost += w edge_count += 1 union(parent, rank, root_u, root_v) # If we've included n-1 edges, stop early if edge_count == n - 1: break return total_cost"},{"question":"def max_calories(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum calories one can collect by reaching the bottom-right corner of the grid. >>> max_calories(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 12 >>> max_calories(1, 5, [ [1, 2, 3, 4, 5] ]) 15 >>> max_calories(5, 1, [ [1], [2], [3], [4], [5] ]) 15 >>> max_calories(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> max_calories(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 29 >>> max_calories(3, 3, [ [1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000] ]) 5000 >>> max_calories(1, 1, [ [1000] ]) 1000","solution":"def max_calories(n, m, grid): # Initialize dp table dp = [[0] * m for _ in range(n)] # Set the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def max_flowers(n: int, m: int) -> int: Calculate the maximum number of flowers that can be planted in a garden with n rows and m columns such that no two flowers are adjacent. Parameters: n (int): Number of rows in the garden. m (int): Number of columns in the garden. Returns: int: Maximum number of flowers that can be planted without any two being adjacent. >>> max_flowers(3, 3) 5 >>> max_flowers(2, 2) 2 def test_max_flowers_small_grids(): assert max_flowers(1, 1) == 1 assert max_flowers(2, 2) == 2 assert max_flowers(3, 3) == 5 def test_max_flowers_even_dimensions(): assert max_flowers(4, 4) == 8 assert max_flowers(6, 6) == 18 def test_max_flowers_odd_dimensions(): assert max_flowers(5, 5) == 13 assert max_flowers(7, 7) == 25 def test_max_flowers_mixed_dimensions(): assert max_flowers(2, 3) == 3 assert max_flowers(3, 4) == 6 assert max_flowers(5, 6) == 15 def test_max_flowers_large_dimensions(): assert max_flowers(1000, 1000) == 500000 assert max_flowers(999, 999) == 499001","solution":"def max_flowers(n, m): Returns the maximum number of flowers that can be planted in a n x m grid garden such that no two flowers are adjacent. if n % 2 == 0 or m % 2 == 0: return (n * m) // 2 else: return (n * m) // 2 + 1"},{"question":"class SequenceOperations: def __init__(self): self.sequence = [] def insert(self, x): Insert an integer at the end of the sequence. >>> seq_ops = SequenceOperations() >>> seq_ops.insert(1) >>> seq_ops.sequence [1] pass def delete(self): Delete the element at the end of the sequence. >>> seq_ops = SequenceOperations() >>> seq_ops.insert(1) >>> seq_ops.insert(2) >>> seq_ops.delete() >>> seq_ops.sequence [1] pass def max_sum(self, l, r): Given two indices l and r (1-based, inclusive), find the maximum possible sum of any subarray within the subarray from l to r (inclusive). >>> seq_ops = SequenceOperations() >>> seq_ops.insert(1) >>> seq_ops.insert(2) >>> seq_ops.insert(-3) >>> seq_ops.max_sum(1, 3) 3 pass","solution":"class SequenceOperations: def __init__(self): self.sequence = [] def insert(self, x): self.sequence.append(x) def delete(self): if self.sequence: self.sequence.pop() def max_sum(self, l, r): subarray = self.sequence[l-1:r] max_ending_here = max_so_far = subarray[0] for x in subarray[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"import heapq from typing import List, Tuple def min_latency(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum latency required to send a message from the first computer to the last computer. Parameters: n (int): Number of computers m (int): Number of communication channels edges (List[Tuple[int, int, int]]): List of communication channels Returns: int: The minimum latency required, or -1 if not possible >>> min_latency(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 4)]) 3 >>> min_latency(4, 3, [(1, 2, 1), (2, 3, 2)]) -1 >>> min_latency(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 2)]) 2 >>> min_latency(4, 4, [(1, 2, 4), (1, 3, 2), (3, 4, 2), (2, 4, 1)]) 4 >>> min_latency(2, 1, [(1, 2, 1)]) 1 >>> min_latency(1000, 999, [(i, i+1, 1) for i in range(1, 999)] + [(1, 1000, 1)]) 1","solution":"import heapq def min_latency(n, m, edges): # Create adjacency list representation of the graph graph = [[] for _ in range(n+1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path from node 1 to node n pq = [(0, 1)] # priority queue of (latency, node) min_latency = [float('inf')] * (n + 1) min_latency[1] = 0 while pq: current_latency, u = heapq.heappop(pq) if current_latency > min_latency[u]: continue for v, w in graph[u]: if current_latency + w < min_latency[v]: min_latency[v] = current_latency + w heapq.heappush(pq, (current_latency + w, v)) return min_latency[n] if min_latency[n] != float('inf') else -1 # Example usage edges = [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 4)] print(min_latency(4, 4, edges)) # Output should be 4"},{"question":"def optimal_string_length(t: int, cases: List[str]) -> List[int]: Determines the length of the final string after performing all possible operations optimally for each test case. Parameters: t (int): number of test cases. cases (list of str): list of strings - each string is a test case. Returns: list of int: final string lengths after performing the operations on each test case. >>> optimal_string_length(3, [\\"abccba\\", \\"aa\\", \\"abc\\"]) [0, 0, 3] >>> optimal_string_length(1, [\\"abcde\\"]) [5]","solution":"def optimal_string_length(t, cases): Determines the length of the final string after performing all possible operations optimally for each test case. Parameters: t (int): number of test cases. cases (list of str): list of strings - each string is a test case. Returns: list of int: final string lengths after performing the operations on each test case. results = [] for s in cases: stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last element if it's the same as the current char else: stack.append(char) # Add the current char to the stack results.append(len(stack)) # The remaining stack length is the final length return results"},{"question":"from typing import List def shortest_path_grid(n: int, m: int, grid: List[str]) -> int: Returns the length of the shortest path from the top-left to the bottom-right of the grid. Returns -1 if there is no such path. >>> shortest_path_grid(4, 4, [ ... \\"....\\", ... \\".#..\\", ... \\"..#.\\", ... \\"....\\" ... ]) 7 >>> shortest_path_grid(4, 4, [ ... \\"....\\", ... \\"\\", ... \\"....\\", ... \\"....\\" ... ]) -1 >>> shortest_path_grid(1, 4, [\\"....\\"]) 4 >>> shortest_path_grid(4, 1, [ ... \\".\\", ... \\".\\", ... \\".\\", ... \\".\\" ... ]) 4 >>> shortest_path_grid(4, 4, [ ... \\"#...\\", ... \\"....\\", ... \\"..#.\\", ... \\"....\\" ... ]) -1 >>> shortest_path_grid(4, 4, [ ... \\"....\\", ... \\"....\\", ... \\"..#.\\", ... \\"...#\\" ... ]) -1 >>> shortest_path_grid(5, 5, [ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ]) 9","solution":"from collections import deque def shortest_path_grid(n, m, grid): Returns the length of the shortest path from the top-left to the bottom-right of the grid. Returns -1 if there is no such path. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"import heapq import math from typing import List, Tuple def find_shortest_path(n: int, coordinates: List[Tuple[int, int]], m: int, links: List[Tuple[int, int, int]]) -> int: Find the minimum time required to travel between the two outposts that are farthest apart. Args: n: The number of outposts. coordinates: A list of tuples representing the coordinates of each outpost. m: The number of transport links. links: A list of tuples representing each transport link with travel times. Returns: The minimum time required to travel between the two outposts that are farthest apart. Example: >>> n = 4 >>> coordinates = [(0, 0), (0, 3), (4, 0), (4, 3)] >>> m = 5 >>> links = [(1, 2, 2), (2, 4, 3), (4, 3, 2), (3, 1, 5), (2, 3, 1)] >>> find_shortest_path(n, coordinates, m, links) 5 >>> n = 2 >>> coordinates = [(0, 0), (10, 10)] >>> m = 1 >>> links = [(1, 2, 8)] >>> find_shortest_path(n, coordinates, m, links) 8","solution":"import heapq import math def find_shortest_path(n, coordinates, m, links): def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) # Function to find farthest pair of points def find_farthest_pair(coordinates): max_dist = -1 farthest_pair = (0, 0) for i in range(len(coordinates)): for j in range(i + 1, len(coordinates)): dist = euclidean_distance(coordinates[i], coordinates[j]) if dist > max_dist: max_dist = dist farthest_pair = (i, j) return farthest_pair # Construct the graph graph = {i: [] for i in range(n)} for u, v, t in links: graph[u - 1].append((v - 1, t)) graph[v - 1].append((u - 1, t)) # Find the farthest pair of outposts u, v = find_farthest_pair(coordinates) # Dijkstra's algorithm to find the shortest path in a weighted graph def dijkstra(start): distances = {i: float(\\"inf\\") for i in range(n)} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances dist_from_u = dijkstra(u) return dist_from_u[v] # Example Usage n = 4 coordinates = [(0, 0), (0, 3), (4, 0), (4, 3)] m = 5 links = [(1, 2, 2), (2, 4, 3), (4, 3, 2), (3, 1, 5), (2, 3, 1)] print(find_shortest_path(n, coordinates, m, links)) # Output: 5"},{"question":"def check_marks_improvement(n: int, m: int, marks: List[List[int]]) -> List[str]: Determine for each student if their marks in each subject improve as they move from the first subject to the last. :param n: Number of students :param m: Number of subjects :param marks: 2D list of integers representing marks of students in each subject :return: List of strings, \\"YES\\" if marks improve, otherwise \\"NO\\" >>> check_marks_improvement(3, 4, [ ... [25, 35, 45, 55], ... [30, 30, 30, 30], ... [10, 20, 19, 30] ... ]) ['YES', 'YES', 'NO'] >>> check_marks_improvement(2, 4, [ ... [10, 20, 30, 40], ... [5, 10, 15, 20] ... ]) ['YES', 'YES'] >>> check_marks_improvement(2, 4, [ ... [40, 30, 20, 10], ... [20, 10, 5, 0] ... ]) ['NO', 'NO'] >>> check_marks_improvement(3, 1, [ ... [10], ... [20], ... [30] ... ]) ['YES', 'YES', 'YES'] >>> check_marks_improvement(2, 4, [ ... [20, 20, 20, 20], ... [15, 15, 15, 15] ... ]) ['YES', 'YES']","solution":"def check_marks_improvement(n, m, marks): results = [] for student_marks in marks: improved = True for i in range(1, m): if student_marks[i] < student_marks[i-1]: improved = False break if improved: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage marks = [ [25, 35, 45, 55], [30, 30, 30, 30], [10, 20, 19, 30] ] print(check_marks_improvement(3, 4, marks)) # ['YES', 'YES', 'NO']"},{"question":"def top_student(n: int, students: List[Tuple[str, int, int, int]]) -> str: Determines the top-performing student based on the total scores across all subjects. In case of a tie, selects the student who comes first alphabetically. :param n: int, number of students :param students: list of tuples, where each tuple contains a student's name and their scores in math, science, and literature :return: string, name of the top-performing student >>> top_student(4, [(\\"Alice\\", 90, 95, 80), (\\"Bob\\", 85, 90, 82), (\\"Charlie\\", 95, 85, 90), (\\"David\\", 95, 85, 90)]) == \\"Charlie\\" >>> top_student(3, [(\\"Eve\\", 100, 100, 100), (\\"Fred\\", 100, 100, 100), (\\"George\\", 99, 100, 100)]) == \\"Eve\\" >>> top_student(2, [(\\"Anna\\", 85, 90, 92), (\\"Zoe\\", 91, 81, 85)]) == \\"Anna\\" >>> top_student(1, [(\\"John\\", 70, 80, 90)]) == \\"John\\" >>> top_student(5, [(\\"Alan\\", 88, 77, 86), (\\"Barbara\\", 95, 85, 90), (\\"Charlie\\", 85, 95, 89), (\\"David\\", 90, 92, 94), (\\"Eve\\", 94, 94, 94)]) == \\"Eve\\"","solution":"def top_student(n, students): Determines the top-performing student based on the total scores across all subjects. In case of a tie, selects the student who comes first alphabetically. :param n: int, number of students :param students: list of tuples, where each tuple contains a student's name and their scores in math, science, and literature :return: string, name of the top-performing student top_student = (\\"\\", -1) # Hold the name and total score of the top student for student in students: name, math, science, literature = student total_score = math + science + literature # Check if this student has a higher score or comes first alphabetically in case of tie if (total_score > top_student[1]) or (total_score == top_student[1] and name < top_student[0]): top_student = (name, total_score) return top_student[0]"},{"question":"from typing import List def max_hourglass_sum(grid: List[List[int]]) -> int: Find the maximum sum of the hourglass pattern in a 2D grid of numbers. >>> max_hourglass_sum([ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ]) 19 >>> max_hourglass_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 7","solution":"from typing import List def max_hourglass_sum(grid: List[List[int]]) -> int: n = len(grid) m = len(grid[0]) max_sum = float('-inf') for i in range(n - 2): for j in range(m - 2): top = grid[i][j] + grid[i][j+1] + grid[i][j+2] mid = grid[i+1][j+1] bot = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] hourglass_sum = top + mid + bot if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray in the given array arr. Parameters: arr (list): A list of integers representing the daily profit/loss values. Returns: int: The maximum sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([3, -1, 2, -1]) 4 >>> max_subarray_sum([0, -2, 3, -1, 8]) 10 >>> max_subarray_sum([-5, -1, -2, -3, -4, -6]) -1 def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list of integers. Parameters: test_cases (list): A list of tuples, where each tuple contains an integer \`n\` and a list of \`n\` integers representing the daily profit/loss values. Returns: list: A list of integers, where each integer is the result for the corresponding test case. >>> process_test_cases([(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (5, [1, 2, 3, 4, 5]), (4, [-1, -2, -3, -4])]) [6, 15, -1] >>> process_test_cases([(1, [1]), (2, [-1, 0]), (3, [0, 1, 0]), (1, [-3]), (4, [-2, 1, -1, 3])]) [1, 0, 1, -3, 3]","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray in the given array arr. current_max = arr[0] global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) if current_max > global_max: global_max = current_max return global_max def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list of integers. Parameters: test_cases (list): A list of tuples, where each tuple contains an integer \`n\` and a list of \`n\` integers representing the daily profit/loss values. Returns: list: A list of integers, where each integer is the result for the corresponding test case. results = [] for n, arr in test_cases: results.append(max_subarray_sum(arr)) return results"},{"question":"def process_submissions(n: int, submissions: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Process the submissions and produce the final ranking list of participants. :param n: Number of submissions :param submissions: List of tuples (timestamp, participant_id, score) :return: List of tuples (participant_id, highest_score) sorted based on the criteria >>> process_submissions(7, [(1, 1, 50), (2, 2, 60), (3, 1, 70), (4, 2, 50), (5, 3, 90), (6, 3, 85), (7, 3, 90)]) [(3, 90), (1, 70), (2, 60)]","solution":"def process_submissions(n, submissions): Process the submissions and produce the final ranking list of participants. :param n: Number of submissions :param submissions: List of tuples (timestamp, participant_id, score) :return: List of tuples (participant_id, highest_score) sorted based on the criteria from collections import defaultdict # Dictionary to store the best score and earliest timestamp for a participant participants = defaultdict(lambda: (-1, float('inf'))) for t, id_, score in submissions: current_best_score, current_earliest_time = participants[id_] if (score > current_best_score) or (score == current_best_score and t < current_earliest_time): participants[id_] = (score, t) # Create a list of participant scores and sort by score and earliest timestamp ranking = [(id_, score, time) for id_, (score, time) in participants.items()] ranking.sort(key=lambda x: (-x[1], x[2])) # Convert to required output format result = [(id_, score) for id_, score, _ in ranking] return result"},{"question":"def are_points_collinear(n: int, coordinates: List[Tuple[int, int]]) -> str: Determine if there are at least three collinear points among the given set of resting spots. >>> are_points_collinear(3, [(1, 1), (2, 2), (3, 3)]) \\"YES\\" >>> are_points_collinear(3, [(1, 1), (2, 2), (2, 3)]) \\"NO\\" >>> are_points_collinear(5, [(1, 1), (2, 2), (3, 3), (4, 5), (5, 6)]) \\"YES\\" >>> are_points_collinear(6, [(0, 0), (2, 4), (3, 6), (1, 2), (4, 8), (5, 10)]) \\"YES\\" >>> are_points_collinear(4, [(0, 0), (2, 6), (3, 6), (1, 5)]) \\"NO\\" >>> are_points_collinear(6, [(0, 0), (2, 6), (3, 6), (1, 5), (5, 10), (10, 20)]) \\"YES\\"","solution":"def are_points_collinear(n, coordinates): def on_same_line(p1, p2, p3): # Check if three points (p1, p2, p3) are collinear using the cross product method return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0]) for i in range(n): for j in range(i + 1, n): count = 2 # Two points (i, j) are initially assumed to be collinear for k in range(j + 1, n): if on_same_line(coordinates[i], coordinates[j], coordinates[k]): count += 1 if count >= 3: return \\"YES\\" return \\"NO\\""},{"question":"def magic_sequence(n: int, k: int) -> int: Calculate the nth element of the Magic Sequence. >>> magic_sequence(5, 2) == 8 >>> magic_sequence(4, 3) == 6 >>> magic_sequence(6, 2) == 13 >>> magic_sequence(1, 3) == 1 >>> magic_sequence(10, 2) == 89","solution":"def magic_sequence(n, k): if n == 1: return 1 elif n == 2: return 2 sequence = [1, 2] for i in range(2, n): next_value = sum(sequence[-k:]) sequence.append(next_value) return sequence[n-1]"},{"question":"def max_ticket_value(n: int, ticket_values: List[int]) -> int: You're given a sequence of integers which represents the value of tickets sold for a series of events. The event organizer wants to maximize the total ticket value by selecting a non-empty subsequence of events while ensuring that no two events in the chosen subsequence are consecutive in the original sequence. Write a program to find the maximum possible sum of the selected subsequence under this constraint. >>> max_ticket_value(5, [3, 2, 5, 10, 7]) 15 >>> max_ticket_value(1, [5]) 5 >>> max_ticket_value(2, [5, 10]) 10 >>> max_ticket_value(2, [10, 5]) 10 >>> max_ticket_value(5, [10000, 9000, 8000, 7000, 6000]) 24000 >>> max_ticket_value(6, [10, 1, 10, 1, 10, 1]) 30 >>> max_ticket_value(6, [5, 5, 5, 5, 5, 5]) 15","solution":"def max_ticket_value(n, ticket_values): if n == 0: return 0 elif n == 1: return ticket_values[0] # Base case initialization prev_prev_max = ticket_values[0] prev_max = max(ticket_values[0], ticket_values[1]) # Iterate through rest of the events starting from the third one. for i in range(2, n): current_max = max(prev_max, prev_prev_max + ticket_values[i]) prev_prev_max, prev_max = prev_max, current_max return prev_max # Example usage: # n = 5 # ticket_values = [3, 2, 5, 10, 7] # print(max_ticket_value(n, ticket_values)) # Output: 15"},{"question":"from typing import List def spiral_fill(n: int, wand_lengths: List[int]) -> List[List[int]]: Arrange magical wands in a spiral pattern in a n x n grid. Args: n (int): the size of the grid. wand_lengths (List[int]): the lengths of the wands to arrange. Returns: List[List[int]]: The n x n grid arranged in a spiral pattern. Examples: >>> spiral_fill(3, [9, 2, 7, 1, 6, 5, 8, 3, 4]) [[9, 2, 7], [3, 4, 1], [8, 5, 6]] >>> spiral_fill(1, [1]) [[1]] pass # Complete the function here def print_grid(grid: List[List[int]]) -> None: Print the grid row by row. Args: grid (List[List[int]]): The grid to print. Examples: >>> print_grid([[9, 2, 7], [3, 4, 1], [8, 5, 6]]) 9 2 7 3 4 1 8 5 6 pass # Complete the function here","solution":"def spiral_fill(n, wand_lengths): grid = [[0] * n for _ in range(n)] dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up direction = 0 # Starting with moving right row, col = 0, 0 for length in wand_lengths: grid[row][col] = length next_row, next_col = row + dirs[direction][0], col + dirs[direction][1] if not (0 <= next_row < n and 0 <= next_col < n and grid[next_row][next_col] == 0): direction = (direction + 1) % 4 next_row, next_col = row + dirs[direction][0], col + dirs[direction][1] row, col = next_row, next_col return grid def print_grid(grid): for row in grid: print(\\" \\".join(map(str, row))) # Example usage: n = 3 wand_lengths = [9, 2, 7, 1, 6, 5, 8, 3, 4] grid = spiral_fill(n, wand_lengths) print_grid(grid)"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one house. Args: prices (List[int]): List of integers representing house prices. Returns: int: Maximum profit possible, or 0 if no profit can be made. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([9, 1, 6, 1, 3, 7]) 6 >>> max_profit([]) 0 >>> max_profit([1]) 0 >>> max_profit([4, 7, 2, 8, 1, 5]) 6 >>> max_profit([1, 1, 1, 1]) 0 >>> max_profit([1, 6, 2, 0, 4, 5]) 5","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling one house. if not prices: return 0 # Initialize the minimum price to the first price and max profit to 0 min_price = prices[0] max_profit = 0 # Iterate through the list of prices for price in prices[1:]: # Update the maximum profit if the current price minus the minimum price is higher than the current max profit max_profit = max(max_profit, price - min_price) # Update the minimum price if the current price is lower than the current minimum price min_price = min(min_price, price) return max_profit"},{"question":"def min_scarecrows(N: int, M: int, field: List[str]) -> int: Returns the minimum number of scarecrows required to ensure that every tree has a scarecrow in one of the immediately adjacent cells (above, below, left, or right). >>> min_scarecrows(3, 3, [\\".*.\\", \\"*..\\", \\"..*\\"]) # Output: 3 >>> min_scarecrows(2, 2, [\\"**\\", \\"**\\"]) # Output: 0 >>> min_scarecrows(3, 3, [\\"...\\", \\".*.\\", \\"...\\"]) # Output: 1 >>> min_scarecrows(3, 3, [\\".*.\\", \\"...\\", \\".*.\\"]) # Output: 2 >>> min_scarecrows(1, 1, [\\".\\"]) # Output: 0 >>> min_scarecrows(1, 1, [\\"*\\"]) # Output: 0","solution":"def min_scarecrows(N, M, field): Returns the minimum number of scarecrows required to ensure that every tree has a scarecrow in one of the immediately adjacent cells (above, below, left, or right). scarecrows = [[0] * M for _ in range(N)] # Helper function to check if a cell is within boundaries def in_bounds(x, y): return 0 <= x < N and 0 <= y < M # List of directions for adjacent cells (right, left, bottom, top) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Iterate over all cells to place scarecrows for i in range(N): for j in range(M): if field[i][j] == '*': tree_protected = False for dx, dy in directions: nx, ny = i + dx, j + dy if in_bounds(nx, ny) and scarecrows[nx][ny] == 1: tree_protected = True break if not tree_protected: for dx, dy in directions: nx, ny = i + dx, j + dy if in_bounds(nx, ny) and field[nx][ny] == '.': scarecrows[nx][ny] = 1 break return sum(sum(row) for row in scarecrows) # Example usage N = 3 M = 3 field = [ \\".*.\\", \\"*..\\", \\"..*\\", ] print(min_scarecrows(N, M, field)) # Output: 3"},{"question":"def has_pair_with_difference(arr, k): Determine if there exists a pair of elements in the array whose difference is exactly k. Args: arr (list of int): List of integers representing the array k (int): Target difference Returns: str: \\"YES\\" if a pair exists with the given difference, otherwise \\"NO\\" Example: >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) 'YES' >>> has_pair_with_difference([4, 2, 1, 3], 0) 'YES'","solution":"def has_pair_with_difference(arr, k): Determine if there exists a pair of elements in the array whose difference is exactly k. Args: arr (list of int): List of integers representing the array k (int): Target difference Returns: str: \\"YES\\" if a pair exists with the given difference, otherwise \\"NO\\" value_set = set(arr) for num in arr: if (num + k) in value_set or (num - k) in value_set: return \\"YES\\" return \\"NO\\""},{"question":"def min_knight_moves(t: int, sizes: List[int]) -> List[int]: Determine the fewest number of moves required for a knight to reach the bottom-right corner of a chessboard. Args: t (int): The number of test cases. sizes (List[int]): List of sizes of the chessboards. Returns: List[int]: Minimum number of moves required to reach the bottom-right corner for each test case, or -1 if unreachable. Examples: >>> min_knight_moves(3, [1, 2, 3]) [0, -1, 2] >>> min_knight_moves(1, [4]) [4] from typing import List # Unit Tests def test_case_1(): assert min_knight_moves(3, [1, 2, 3]) == [0, -1, 2] def test_case_2(): assert min_knight_moves(1, [1]) == [0] def test_case_3(): assert min_knight_moves(1, [2]) == [-1] def test_case_4(): assert min_knight_moves(1, [3]) == [2] def test_even_larger_than_3(): assert min_knight_moves(1, [4]) == [4] def test_odd_larger_than_3(): assert min_knight_moves(1, [5]) == [4]","solution":"def min_knight_moves(t, sizes): results = [] for n in sizes: if n == 1: results.append(0) elif n == 2: results.append(-1) elif n == 3: results.append(2) elif n % 2 == 1: results.append(n - 1) else: results.append(n) return results"},{"question":"def wave_array(arr: List[int]) -> List[int]: Transforms the given list into a wave array where: - If i is even, arr[i] >= arr[i+1] (if i+1 < n) - If i is odd, arr[i] <= arr[i+1] (if i+1 < n) >>> wave_array([5, 3, 8, 6, 2]) [5, 3, 8, 2, 6] >>> wave_array([1, 2, 3]) [2, 1, 3]","solution":"def wave_array(arr): Transforms the given list into a wave array where: - If i is even, arr[i] >= arr[i+1] (if i+1 < n) - If i is odd, arr[i] <= arr[i+1] (if i+1 < n) n = len(arr) for i in range(n-1): if i % 2 == 0: if arr[i] < arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] else: if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"def maximum_energy(n: int, milestones: List[int], E: int) -> int: Given the number of milestones \`n\`, a list of energy changes \`milestones\`, and an initial energy \`E\`, determine the maximum energy that can be achieved at the last milestone. >>> maximum_energy(5, [2, -3, 4, -1, 3], 5) 10 >>> maximum_energy(4, [-5, 1, -2, 3], 4) -1 >>> maximum_energy(3, [2, 3, 4], 8) 17 >>> maximum_energy(4, [-2, -2, 5, -1], 5) 5 >>> maximum_energy(3, [2, -10, 5], 6) -1","solution":"def maximum_energy(n, milestones, E): Given the number of milestones \`n\`, a list of energy changes \`milestones\`, and an initial energy \`E\`, determine the maximum energy that can be achieved at the last milestone. energy = E for milestone in milestones: energy += milestone if energy <= 0: return -1 return energy"},{"question":"def minimum_deletions(s: str) -> int: Determines the minimum number of deletions needed so that no two adjacent characters in the string are the same. Parameters: s (str): input string Returns: int: minimum number of deletions needed >>> minimum_deletions(\\"aabcc\\") 2 >>> minimum_deletions(\\"abcdefg\\") 0 >>> minimum_deletions(\\"aaaaa\\") 4 >>> minimum_deletions(\\"ababab\\") 0 >>> minimum_deletions(\\"aabbaabb\\") 4 >>> minimum_deletions(\\"a\\") 0","solution":"def minimum_deletions(s): Determines the minimum number of deletions needed so that no two adjacent characters in the string are the same. Parameters: s (str): input string Returns: int: minimum number of deletions needed deletions = 0 # Iterate through the string, comparing each character to the next one for i in range(len(s) - 1): if s[i] == s[i + 1]: deletions += 1 return deletions"},{"question":"def find_subarray_to_sort(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find the smallest subarray that must be sorted so that the entire array becomes sorted in non-decreasing order. Parameters: arr (List[int]): List of integers to evaluate. Returns: Tuple[int, int]: 1-based starting and ending indices of the subarray to be sorted, or (1, 1) if the entire array is already sorted. Examples: >>> find_subarray_to_sort([1, 3, 5, 4, 2, 6]) (2, 5) >>> find_subarray_to_sort([1, 2, 3, 4, 5]) (1, 1) >>> find_subarray_to_sort([5, 4, 3, 2, 1]) (1, 5) >>> find_subarray_to_sort([1, 2, 6, 5, 4, 3, 7, 8]) (3, 6) >>> find_subarray_to_sort([1]) (1, 1) pass # Implement the function here def test_already_sorted(): assert find_subarray_to_sort([1, 2, 3, 4, 5]) == (1, 1) def test_needs_sorting_subarray(): assert find_subarray_to_sort([1, 3, 5, 4, 2, 6]) == (2, 5) assert find_subarray_to_sort([1, 2, 6, 5, 4, 3, 7, 8]) == (3, 6) def test_reverse_sorted(): assert find_subarray_to_sort([5, 4, 3, 2, 1]) == (1, 5) def test_single_element(): assert find_subarray_to_sort([1]) == (1, 1) def test_with_duplicates(): assert find_subarray_to_sort([1, 3, 3, 4, 2, 6, 7, 8]) == (2, 5) assert find_subarray_to_sort([4, 2, 2, 2, 3, 3, 1, 1, 5]) == (1, 8)","solution":"def find_subarray_to_sort(arr): This function finds the smallest subarray that must be sorted so that the entire array becomes sorted. n = len(arr) start, end = 0, n - 1 # Find the first element which is out of the sorting order from the start while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 # If the array is already sorted if start == n - 1: return (1, 1) # Find the first element which is out of the sorting order from the end while end > 0 and arr[end] >= arr[end - 1]: end -= 1 # Find the min and max elements in the arr[start:end+1] subarray_min = min(arr[start:end + 1]) subarray_max = max(arr[start:end + 1]) # Extend the subarray to include any number which is greater than the min in the subarray while start > 0 and arr[start - 1] > subarray_min: start -= 1 # Extend the subarray to include any number which is less than the max in the subarray while end < n - 1 and arr[end + 1] < subarray_max: end += 1 # Return 1-based indices return (start + 1, end + 1)"},{"question":"def find_winner(n: int, m: int, scores: List[Tuple[int, int]]) -> int: Finds the participant with the highest average score. Parameters: n (int): Number of participants m (int): Number of recorded scores scores (list of tuples): Each tuple contains participant ID and score Returns: int: The ID of the winning participant >>> find_winner(3, 5, [(1, 80), (2, 90), (1, 70), (2, 95), (3, 90)]) 2 >>> find_winner(1, 3, [(1, 60), (1, 70), (1, 80)]) 1 >>> find_winner(3, 3, [(1, 80), (2, 80), (3, 80)]) 1 >>> find_winner(3, 2, [(2, 85), (3, 95)]) 3 >>> find_winner(4, 6, [(1, 50), (1, 100), (2, 75), (2, 85), (3, 90), (4, 80)]) 3","solution":"def find_winner(n, m, scores): Finds the participant with the highest average score. Parameters: n (int): Number of participants m (int): Number of recorded scores scores (list of tuples): Each tuple contains participant ID and score Returns: int: The ID of the winning participant from collections import defaultdict # Dictionary to store total scores and count of scores per participant participant_scores = defaultdict(lambda: [0, 0]) # [total_score, count] for p, s in scores: participant_scores[p][0] += s participant_scores[p][1] += 1 best_avg = -1 best_id = -1 for p in range(1, n + 1): if participant_scores[p][1] > 0: avg_score = participant_scores[p][0] / participant_scores[p][1] if avg_score > best_avg or (avg_score == best_avg and p < best_id): best_avg = avg_score best_id = p return best_id"},{"question":"def can_reorganize_sequence(n: int, serial_numbers: List[int]) -> str: Determines if the sequence of books' serial numbers can be reorganized such that inserting one new book at any possible position results in a strictly increasing or strictly decreasing order. >>> can_reorganize_sequence(1, [5]) \\"YES\\" >>> can_reorganize_sequence(3, [1, 2, 3]) \\"YES\\" >>> can_reorganize_sequence(3, [3, 2, 1]) \\"YES\\" >>> can_reorganize_sequence(5, [3, 1, 4, 1, 5]) \\"NO\\" >>> can_reorganize_sequence(5, [3, 5, 4, 1, 2]) \\"YES\\" >>> can_reorganize_sequence(4, [2, 2, 2, 2]) \\"NO\\" >>> can_reorganize_sequence(4, [1, 3, 2, 4]) \\"YES\\"","solution":"def can_reorganize_sequence(n, serial_numbers): Determines if the sequence of books' serial numbers can be reorganized such that inserting one new book at any possible position results in a strictly increasing or strictly decreasing order. if n == 1: return \\"YES\\" serial_numbers.sort() # Check for strictly increasing order possibility increasing = all(serial_numbers[i] != serial_numbers[i + 1] for i in range(n - 1)) # Check for strictly decreasing order possibility decreasing = all(serial_numbers[i] != serial_numbers[n - 1 - i] for i in range(n - 1)) return \\"YES\\" if increasing or decreasing else \\"NO\\""},{"question":"def min_stacks_required(n: int, thicknesses: List[int]) -> int: Yelena wants to organize her bookshelf. She has a collection of n books. Each book has a certain thickness. To make her shelf aesthetics pleasing, she decides to stack the books in such a way that the thickness of each book in a stack is strictly less than the thickness of the book directly above it. Help Yelena determine the minimum number of stacks required to organize all her books. Parameters: n (int): The number of books (1 ≤ n ≤ 1000) thicknesses (list of int): The thicknesses of the books (1 ≤ ti ≤ 1000) Returns: int: The minimum number of stacks required >>> min_stacks_required(1, [5]) 1 >>> min_stacks_required(3, [4, 3, 2]) 1 >>> min_stacks_required(3, [1, 2, 3]) 3 >>> min_stacks_required(5, [4, 5, 3, 2, 6]) 3 >>> min_stacks_required(4, [2, 2, 2, 2]) 4 >>> min_stacks_required(6, [6, 5, 4, 4, 5, 6]) 4","solution":"def min_stacks_required(n, thicknesses): Returns the minimum number of stacks required to organize the books. Parameters: n (int): The number of books thicknesses (list of int): The thicknesses of the books Returns: int: The minimum number of stacks required stacks = [] for t in thicknesses: placed = False for stack in stacks: if stack[-1] > t: stack.append(t) placed = True break if not placed: stacks.append([t]) return len(stacks)"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, zip_codes: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process the requests to find the most common zip code among a contiguous segment of people. Args: n (int): The number of people. q (int): The number of requests. zip_codes (List[int]): The zip codes of the people. queries (List[Tuple[int, int]]): The range queries. Returns: List[int]: The most common zip code for each query. >>> process_queries(8, 3, [1, 2, 2, 3, 3, 3, 2, 2], [(1, 3), (4, 8), (2, 5)]) [2, 3, 2] >>> process_queries(5, 2, [1, 1, 2, 2, 3], [(1, 4), (2, 5)]) [1, 2] >>> process_queries(3, 1, [1, 2, 3], [(1, 3)]) [1] >>> process_queries(1, 1, [1], [(1, 1)]) [1] >>> process_queries(2, 1, [2, 1], [(1, 2)]) [1] >>> process_queries(100000, 1, list(range(1, 100001)), [(1, 100000)]) [1]","solution":"from collections import defaultdict, Counter class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.tree = [None] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.tree[node] = Counter([self.data[start]]) else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(left_child, start, mid) self.build(right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def query(self, L, R, node, start, end): if R < start or L > end: return Counter() if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_counter = self.query(L, R, left_child, start, mid) right_counter = self.query(L, R, right_child, mid + 1, end) return left_counter + right_counter def range_query(self, L, R): result = self.query(L, R, 0, 0, self.n - 1) max_count = max(result.values()) most_common_zip = min(zip_code for zip_code, count in result.items() if count == max_count) return most_common_zip def process_queries(n, q, zip_codes, queries): seg_tree = SegmentTree(zip_codes) results = [] for li, ri in queries: results.append(seg_tree.range_query(li - 1, ri - 1)) # Convert to zero-based indexing return results"},{"question":"def max_even_sum_pairs(arr: List[int]) -> int: Rearrange the array such that each element in the first \`N\` elements is paired with one unique element from the second \`N\` elements, and their sum is even. Determine the maximum number of such pairs that can be created. >>> max_even_sum_pairs([2, 3, 4, 5, 6, 7]) 3 >>> max_even_sum_pairs([2, 4, 6, 8, 10, 12]) 0 >>> max_even_sum_pairs([1, 3, 5, 7, 9, 11]) 0 >>> max_even_sum_pairs([1, 2, 3, 4]) 2 >>> max_even_sum_pairs([1, 3, 2, 4, 6, 8]) 2 >>> max_even_sum_pairs([1, 3, 5, 7, 2, 4]) 2 >>> max_even_sum_pairs(range(1, 200001)) 100000","solution":"def max_even_sum_pairs(arr): # Separate the numbers into even and odd lists evens = [num for num in arr if num % 2 == 0] odds = [num for num in arr if num % 2 != 0] # The maximum number of pairs (even sum) we can form is the smaller count of evens or odds return min(len(evens), len(odds)) # Example usage if __name__ == \\"__main__\\": arr = [2, 3, 4, 5, 6, 7] print(max_even_sum_pairs(arr)) # Output: 3"},{"question":"def min_extensions(segments: List[Tuple[int, int]]) -> int: Given a list of non-overlapping segments, determine the minimal number of extensions needed to convert them such that they form a continuous path without any gaps. :param segments: List of tuples, where each tuple contains two integers (a, b) representing the start and end of a segment. :return: Integer representing the minimal number of extensions needed. >>> min_extensions([(1, 3), (5, 8), (10, 12)]) == 2 >>> min_extensions([(1, 3)]) == 0 >>> min_extensions([(100, 200), (500, 600), (1000, 1100)]) == 698 >>> min_extensions([(1, 5), (5, 10), (10, 15)]) == 0 >>> min_extensions([(1, 3), (4, 5), (6, 8)]) == 0 >>> min_extensions([(1, 2), (4, 6), (8, 10), (12, 14)]) == 3 pass","solution":"def min_extensions(segments): Given a list of non-overlapping segments, determine the minimal number of extensions needed to convert them such that they form a continuous path without any gaps. :param segments: List of tuples, where each tuple contains two integers (a, b) representing the start and end of a segment. :return: Integer representing the minimal number of extensions needed. # Sort segments based on their starting points segments.sort() # Initialize the number of extensions needed extensions_count = 0 # Initialize the end of the previous segment previous_end = segments[0][1] for i in range(1, len(segments)): current_start, current_end = segments[i] # If there is a gap between the current segment and the previous segment if current_start > previous_end + 1: extensions_count += current_start - previous_end - 1 # Update the end of the previous segment previous_end = max(previous_end, current_end) return extensions_count"},{"question":"def manage_village(queries): Manages the buildings in the village and processes the given queries. Parameters: queries (list of str): The list of queries to be processed. Returns: list: Results of the \\"query r\\" and \\"query c\\" queries. residential_buildings = {} commercial_buildings = {} results = [] for query in queries: parts = query.split() if parts[0] == 'build': if parts[1] == 'r': # Build a residential building building_num = int(parts[2]) occupants = int(parts[3]) residential_buildings[building_num] = occupants elif parts[1] == 'c': # Build a commercial building building_num = int(parts[2]) employees = int(parts[3]) commercial_buildings[building_num] = employees elif parts[0] == 'query': if parts[1] == 'r': # Query a residential building building_num = int(parts[2]) results.append(residential_buildings[building_num]) elif parts[1] == 'c': # Query a commercial building building_num = int(parts[2]) results.append(commercial_buildings[building_num]) return results # Test cases def test_manage_village_scenario(): queries = [ \\"build r 3 200\\", \\"build r 5 150\\", \\"build c 2 50\\", \\"query r 3\\", \\"query c 2\\", \\"build c 1 100\\", \\"query c 1\\" ] assert manage_village(queries) == [200, 50, 100] def test_empty_village(): queries = [] assert manage_village(queries) == [] def test_single_residential_query(): queries = [ \\"build r 1 100\\", \\"query r 1\\" ] assert manage_village(queries) == [100] def test_single_commercial_query(): queries = [ \\"build c 1 200\\", \\"query c 1\\" ] assert manage_village(queries) == [200] def test_multiple_queries(): queries = [ \\"build r 3 200\\", \\"build r 5 150\\", \\"build c 2 50\\", \\"query r 3\\", \\"query c 2\\", \\"build r 4 175\\", \\"query r 5\\", \\"query r 4\\", \\"build c 6 300\\", \\"query c 6\\" ] assert manage_village(queries) == [200, 50, 150, 175, 300]","solution":"def manage_village(queries): Manages the buildings in the village and processes the given queries. Parameters: queries (list of str): The list of queries to be processed. Returns: list: Results of the \\"query r\\" and \\"query c\\" queries. residential_buildings = {} commercial_buildings = {} results = [] for query in queries: parts = query.split() if parts[0] == 'build': if parts[1] == 'r': # Build a residential building building_num = int(parts[2]) occupants = int(parts[3]) residential_buildings[building_num] = occupants elif parts[1] == 'c': # Build a commercial building building_num = int(parts[2]) employees = int(parts[3]) commercial_buildings[building_num] = employees elif parts[0] == 'query': if parts[1] == 'r': # Query a residential building building_num = int(parts[2]) results.append(residential_buildings[building_num]) elif parts[1] == 'c': # Query a commercial building building_num = int(parts[2]) results.append(commercial_buildings[building_num]) return results"},{"question":"def simulate_caves(n: int, q: int, initial_creatures: List[int], events: List[str]) -> List[int]: Simulate the state of the caves after a series of events involving magical creatures. Args: n (int): Number of caves. q (int): Number of events. initial_creatures (List[int]): Initial number of magical creatures in each cave. events (List[str]): List of events. Returns: List[int]: The number of magical creatures in the cave for each query of type 3. >>> simulate_caves(5, 4, [5, 3, 8, 6, 2], [\\"1 2 4\\", \\"2 4 5\\", \\"3 3\\", \\"3 5\\"]) [16, 14] >>> simulate_caves(3, 2, [1, 1, 1], [\\"1 1 3\\", \\"3 2\\"]) [2] >>> simulate_caves(4, 3, [10, 20, 30, 40], [\\"2 1 4\\", \\"2 2 3\\", \\"3 4\\"]) [50] >>> simulate_caves(5, 5, [2, 4, 6, 8, 10], [\\"1 1 3\\", \\"2 3 5\\", \\"3 1\\", \\"3 5\\", \\"1 4 5\\"]) [4, 22] >>> simulate_caves(5, 0, [1, 2, 3, 4, 5], []) []","solution":"def simulate_caves(n, q, initial_creatures, events): caves = initial_creatures.copy() result = [] for event in events: parts = event.split() event_type = int(parts[0]) if event_type == 1: l, r = int(parts[1]) - 1, int(parts[2]) - 1 for i in range(l, r + 1): caves[i] *= 2 elif event_type == 2: l, r = int(parts[1]) - 1, int(parts[2]) - 1 caves[r] += caves[l] caves[l] = 0 elif event_type == 3: l = int(parts[1]) - 1 result.append(caves[l]) return result"},{"question":"def max_tasks(t: int, participants: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum number of tasks a participant can complete based on their limit. >>> max_tasks(2, [(10, 4, [4, 5, 1, 3]), (8, 5, [2, 4, 2, 2, 1])]) [3, 4] >>> max_tasks(1, [(5, 3, [1, 2, 3])]) [2] pass def parse_input(raw_input: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Parse the raw input string to extract the number of participants and their task limits and difficulties. >>> parse_input(\\"1n5 3n1 2 3\\") (1, [(5, 3, [1, 2, 3])]) >>> parse_input(\\"2n10 4n4 5 1 3n8 5n2 4 2 2 1\\") (2, [(10, 4, [4, 5, 1, 3]), (8, 5, [2, 4, 2, 2, 1])]) pass def main(raw_input: str): Main function to read input and print the maximum number of tasks for each participant. pass from solution import max_tasks, parse_input, main def test_example_case(): raw_input = \\"2n10 4n4 5 1 3n8 5n2 4 2 2 1\\" t, participants = parse_input(raw_input) assert max_tasks(t, participants) == [3, 4] def test_single_participant(): raw_input = \\"1n5 3n1 2 3\\" t, participants = parse_input(raw_input) assert max_tasks(t, participants) == [2] def test_large_limit(): raw_input = \\"1n1000000000 3n1000000 1000000 1000000\\" t, participants = parse_input(raw_input) assert max_tasks(t, participants) == [3] def test_no_tasks(): raw_input = \\"1n5 3n6 7 8\\" t, participants = parse_input(raw_input) assert max_tasks(t, participants) == [0] def test_parse_input(): raw_input = \\"1n5 3n1 2 3\\" t, participants = parse_input(raw_input) assert t == 1 assert participants == [(5, 3, [1, 2, 3])] def test_main_output(capfd): raw_input = \\"2n10 4n4 5 1 3n8 5n2 4 2 2 1\\" main(raw_input) out, err = capfd.readouterr() assert out.strip().split('n') == ['3', '4']","solution":"def max_tasks(t, participants): results = [] for p in participants: L, n, tasks = p tasks.sort() task_count = 0 current_sum = 0 for task in tasks: if current_sum + task <= L: current_sum += task task_count += 1 else: break results.append(task_count) return results def parse_input(raw_input): lines = raw_input.strip().split('n') t = int(lines[0]) participants = [] idx = 1 for _ in range(t): L, n = map(int, lines[idx].split()) tasks = list(map(int, lines[idx+1].split())) participants.append((L, n, tasks)) idx += 2 return t, participants def main(raw_input): t, participants = parse_input(raw_input) results = max_tasks(t, participants) for result in results: print(result)"},{"question":"import math from typing import List, Tuple class ArrayManipulator: def __init__(self, array: List[int]): self.array = array def update(self, index: int, value: int): Update the value at a specified index. self.array[index-1] = value def compute_gcd(self, l: int, r: int) -> int: Compute the GCD of the subarray from index l to index r. # Implement GCD computation over the specified range def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process the given list of queries on the array. :param n: number of elements in the array. :param q: number of queries. :param array: list of integers representing the array. :param queries: list of queries to process. :return: list of results for the \\"compute_gcd\\" queries. >>> process_queries(6, 4, [12, 15, 18, 9, 24, 30], [(2, 1, 3), (1, 2, 6), (2, 1, 3), (2, 4, 6)]) [3, 6, 3] >>> process_queries(5, 3, [10, 20, 30, 40, 50], [(2, 1, 5), (1, 3, 60), (2, 2, 4)]) [10, 20]","solution":"import math class ArrayManipulator: def __init__(self, array): self.array = array def update(self, index, value): self.array[index-1] = value def compute_gcd(self, l, r): gcd_value = self.array[l-1] for i in range(l, r): gcd_value = math.gcd(gcd_value, self.array[i]) return gcd_value def process_queries(n, q, array, queries): manipulator = ArrayManipulator(array) results = [] for query in queries: q_type, *args = query if q_type == 1: i, x = args manipulator.update(i, x) elif q_type == 2: l, r = args results.append(manipulator.compute_gcd(l, r)) return results # Sample Usage for debugging # n, q = 6, 4 # array = [12, 15, 18, 9, 24, 30] # queries = [(2, 1, 3), (1, 2, 6), (2, 1, 3), (2, 4, 6)] # print(process_queries(n, q, array, queries)) # Output [3, 6, 3]"},{"question":"def count_unique_partitions(n: int) -> int: Returns the number of unique ways to partition n stars into groups where each group has at least 2 stars. >>> count_unique_partitions(2) == 0 >>> count_unique_partitions(3) == 0 >>> count_unique_partitions(4) == 1 # (2,2) >>> count_unique_partitions(5) == 1 # (2,3) >>> count_unique_partitions(6) == 2 # (2,4) and (3,3) >>> count_unique_partitions(10) == 4 # (2,8), (3,7), (4,6), (5,5) >>> count_unique_partitions(8) == 3 # (2,6), (3,5), (4,4)","solution":"def count_unique_partitions(n): Returns the number of unique ways to partition n stars into groups where each group has at least 2 stars. if n < 4: return 0 # Dictionary to store unique pairs, to ensure order does not matter partitions = {} # Iterate over each possible group size for i in range(2, n): for j in range(i, n): if i + j == n: partitions[(i, j)] = True return len(partitions)"},{"question":"def find_shortest_route(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Finds the length of the shortest route that starts at city 1, passes through all cities exactly once, and returns to city 1. Args: n : int : The number of cities in Berland. m : int : The number of roads in Berland. roads : List[Tuple[int, int, int]] : A list of roads, where each road is represented by a tuple (u, v, l) indicating a road between city u and city v with length l. Returns: int : The length of the shortest route, or -1 if no such route exists. >>> find_shortest_route(4, 4, [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 1, 5)]) 14 >>> find_shortest_route(4, 2, [(1, 2, 4), (3, 4, 5)]) -1 >>> find_shortest_route(3, 0, []) -1 >>> find_shortest_route(2, 1, [(1, 2, 3)]) 6 >>> find_shortest_route(2, 1, [(1, 2, 1)]) 2","solution":"import itertools def find_shortest_route(n, m, roads): # Create the adjacency matrix adj_matrix = [[float('inf')] * n for _ in range(n)] for u, v, l in roads: adj_matrix[u-1][v-1] = l adj_matrix[v-1][u-1] = l # Function to calculate the distance of given path def path_length(path): length = 0 for i in range(n): length += adj_matrix[path[i]][path[(i + 1) % n]] if adj_matrix[path[i]][path[(i + 1) % n]] == float('inf'): return float('inf') return length # Generate all permutations of cities except the first one cities = list(range(1, n)) min_distance = float('inf') for perm in itertools.permutations(cities): route = [0] + list(perm) + [0] # Starting and ending at city 1 min_distance = min(min_distance, path_length(route)) return -1 if min_distance == float('inf') else min_distance"},{"question":"def ariel_palindrome(n: int, m: int, s: str, queries: List[Tuple[int, int]]) -> List[str]: Ariel is fascinated by palindromes. You are given a string \`s\` consisting of lowercase English letters and a list of \`m\` queries. Each query is composed of two integers \`l\` and \`r\` which define a substring of \`s\`. For each query, determine if the substring \`s[l:r+1]\` (inclusive) is a palindrome. Return a list of strings \\"YES\\" or \\"NO\\" for each query, indicating whether each specified substring is a palindrome or not. Example: >>> n = 7 >>> m = 3 >>> s = \\"abacaba\\" >>> queries = [(0, 6), (2, 4), (1, 2)] >>> ariel_palindrome(n, m, s, queries) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindrome(s, l, r): Returns whether the substring s[l:r+1] is a palindrome. sub_str = s[l:r+1] return sub_str == sub_str[::-1] def process_queries(n, m, s, queries): results = [] for l, r in queries: if is_palindrome(s, l, r): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def ariel_palindrome(n, m, s, queries): return process_queries(n, m, s, queries)"},{"question":"from typing import List, Tuple def find_duplicate(arr: List[int]) -> int: Finds the duplicate element in an array where elements range from 1 to n-1 and exactly one element is duplicated. >>> find_duplicate([1, 3, 4, 2, 4]) 4 >>> find_duplicate([1, 2, 3, 2]) 2 >>> find_duplicate([5, 3, 2, 1, 4, 3]) 3 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases to find duplicates in each. >>> process_test_cases([(5, [1, 3, 4, 2, 4]), (4, [1, 2, 3, 2]), (6, [5, 3, 2, 1, 4, 3])]) [4, 2, 3] >>> process_test_cases([(7, [6, 1, 2, 4, 3, 5, 6]), (8, [1, 2, 3, 4, 5, 5, 6, 7])]) [6, 5] pass","solution":"def find_duplicate(arr): Finds the duplicate element in an array where elements range from 1 to n-1 and exactly one element is duplicated. seen = set() for num in arr: if num in seen: return num seen.add(num) def process_test_cases(test_cases): Processes multiple test cases to find duplicates in each. results = [] for n, arr in test_cases: results.append(find_duplicate(arr)) return results"},{"question":"def can_move(n: int, m: int, blocked_cells: List[Tuple[int, int]]) -> str: Check if you can move from the top-left corner of the grid to the bottom-right corner. >>> can_move(4, 4, [(2, 2), (3, 2), (4, 3)]) 'YES' >>> can_move(3, 3, [(1, 2), (2, 1)]) 'NO' >>> can_move(2, 2, []) 'YES' >>> can_move(3, 3, [(2, 2)]) 'YES' >>> can_move(3, 3, [(1, 1)]) 'NO' >>> can_move(3, 3, [(3, 3)]) 'NO' >>> blocked = [(i, j) for i in range(1, 1001) for j in range(1, 1001) if i == 1 or j == 1] >>> can_move(1000, 1000, blocked) 'NO' >>> blocked = [(i, 1000) for i in range(1, 1000)] >>> can_move(1000, 1000, blocked) 'YES'","solution":"def can_move(n, m, blocked_cells): from collections import deque grid = [[0] * m for _ in range(n)] for r, c in blocked_cells: grid[r-1][c-1] = 1 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return \\"NO\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def longest_arithmetic_subsequence_length(n: int, sequence: List[int]) -> int: Find the length of the longest contiguous subsequence which forms an arithmetic progression. >>> longest_arithmetic_subsequence_length(7, [10, 20, 30, 50, 60, 70, 80]) 4 >>> longest_arithmetic_subsequence_length(5, [1, 7, 13, 19, 25]) 5","solution":"def longest_arithmetic_subsequence_length(n, sequence): if n == 2: return n max_length = 2 current_length = 2 current_diff = sequence[1] - sequence[0] for i in range(2, n): diff = sequence[i] - sequence[i - 1] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 2 if current_length > max_length: max_length = current_length return max_length"},{"question":"def count_increases(n: int, rainfall_levels: List[int]) -> int: Determine the number of times the rainfall level increased compared to the previous measurement. Parameters: n (int): The number of days. rainfall_levels (List[int]): A list of 2n integers, representing rainfall levels recorded at noon and midnight for each day. Returns: int: The number of times the rainfall level increased compared to the previous measurement. Example: >>> count_increases(4, [10, 20, 20, 15, 15, 25, 25, 30]) 3 >>> count_increases(3, [10, 10, 10, 10, 10, 10]) 0 >>> count_increases(3, [1, 2, 3, 4, 5, 6]) 5 >>> count_increases(4, [1, 3, 2, 4, 3, 5, 4, 6]) 4 >>> count_increases(4, [10, 9, 8, 7, 6, 5, 4, 3]) 0 >>> count_increases(1, [5, 10]) 1","solution":"def count_increases(n, rainfall_levels): increase_count = 0 for i in range(1, 2 * n): if rainfall_levels[i] > rainfall_levels[i - 1]: increase_count += 1 return increase_count"},{"question":"def min_shelves(n: int, m: int, capacities: List[int], demands: List[int]) -> int: Distribute the products across the shelves such that the total demand of products on any shelf does not exceed its capacity and the total number of unique shelves used is minimized. Args: n (int): the number of shelves m (int): the number of products capacities (List[int]): list of integers representing the capacities of the shelves demands (List[int]): list of integers representing the demands of the products Returns: int: minimum number of shelves used to store all products. If it is impossible to store all products given the constraints, return -1. >>> min_shelves(4, 6, [10, 20, 15, 25], [5, 10, 15, 5, 10, 5]) 3 >>> min_shelves(3, 4, [10, 10, 10], [5, 5, 5, 5]) 2 >>> min_shelves(2, 3, [5, 5], [6, 6, 6]) -1 >>> min_shelves(1, 1, [10], [5]) 1 >>> min_shelves(5, 10, [100, 100, 100, 100, 100], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) 1","solution":"def min_shelves(n, m, capacities, demands): capacities.sort(reverse=True) demands.sort(reverse=True) shelves_used = 0 shelves_loads = [0] * n for demand in demands: placed = False for i in range(n): if shelves_loads[i] + demand <= capacities[i]: shelves_loads[i] += demand placed = True break if not placed: return -1 for load in shelves_loads: if load > 0: shelves_used += 1 return shelves_used"},{"question":"from typing import List, Tuple def minimum_total_vulnerability(n: int, m: int, k: int, vulnerability_levels: List[int], connections: List[Tuple[int, int]]) -> int: Calculate the minimum total vulnerability level of the remaining servers after installing k firewalls. Args: n (int): Number of servers. m (int): Number of direct connections between servers. k (int): Number of firewalls to be installed. vulnerability_levels (List[int]): List of vulnerability levels for each server. connections (List[Tuple[int, int]]): List of direct connections between servers. Returns: int: Minimum total vulnerability level of the remaining servers. Example: >>> n, m, k = 6, 7, 3 >>> vulnerability_levels = [1, 3, 5, 7, 9, 2] >>> connections = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6), (2, 5)] >>> minimum_total_vulnerability(n, m, k, vulnerability_levels, connections) 6 # Sort the vulnerability levels in descending order pass # Implementation goes here def test_example(): n = 6 m = 7 k = 3 vulnerability_levels = [1, 3, 5, 7, 9, 2] connections = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6), (2, 5)] assert minimum_total_vulnerability(n, m, k, vulnerability_levels, connections) == 6 def test_case1(): n = 5 m = 4 k = 2 vulnerability_levels = [4, 3, 8, 1, 6] connections = [(1, 2), (2, 3), (3, 4), (4, 5)] assert minimum_total_vulnerability(n, m, k, vulnerability_levels, connections) == 8 # 4+3+1 def test_case2(): n = 4 m = 3 k = 1 vulnerability_levels = [10, 20, 15, 25] connections = [(1, 2), (2, 3), (3, 4)] assert minimum_total_vulnerability(n, m, k, vulnerability_levels, connections) == 45 # 10+20+15 def test_case3(): n = 3 m = 2 k = 1 vulnerability_levels = [5, 10, 3] connections = [(1, 2), (2, 3)] assert minimum_total_vulnerability(n, m, k, vulnerability_levels, connections) == 8 # 5+3 def test_case4(): n = 2 m = 1 k = 1 vulnerability_levels = [100, 50] connections = [(1, 2)] assert minimum_total_vulnerability(n, m, k, vulnerability_levels, connections) == 50 # only 1 server left at 50","solution":"def minimum_total_vulnerability(n, m, k, vulnerability_levels, connections): Calculate the minimum total vulnerability level of the remaining servers after installing k firewalls. # Sort the vulnerability levels in descending order sorted_vulnerabilities = sorted(vulnerability_levels, reverse=True) # Sum the vulnerability levels of the k highest servers total_vulnerability_to_be_protected = sum(sorted_vulnerabilities[:k]) # Calculate the total vulnerability of all servers total_vulnerability = sum(vulnerability_levels) # The minimum total vulnerability of the remaining servers remaining_vulnerability = total_vulnerability - total_vulnerability_to_be_protected return remaining_vulnerability # Example usage for verification: n, m, k = 6, 7, 3 vulnerability_levels = [1, 3, 5, 7, 9, 2] connections = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6), (2, 5)] print(minimum_total_vulnerability(n, m, k, vulnerability_levels, connections)) # Output: 6"},{"question":"def uptime_analysis(n: int, uptimes: List[int], t: int) -> Tuple[int, List[int], float]: Analyzes server uptimes based on threshold. Args: n (int): Number of servers. uptimes (list of int): List of server uptimes. t (int): Threshold value. Returns: tuple: (count of servers >= threshold, list of uptimes >= threshold, average uptime >= threshold) >>> uptime_analysis(5, [100, 200, 300, 400, 500], 300) (3, [300, 400, 500], 400.00) >>> uptime_analysis(4, [20, 30, 10, 40], 50) (0, [], 0.00)","solution":"def uptime_analysis(n, uptimes, t): Analyzes server uptimes based on threshold. Args: n (int): Number of servers. uptimes (list of int): List of server uptimes. t (int): Threshold value. Returns: tuple: (count of servers >= threshold, list of uptimes >= threshold, average uptime >= threshold) filtered_uptimes = [uptime for uptime in uptimes if uptime >= t] count = len(filtered_uptimes) if count > 0: average_uptime = round(sum(filtered_uptimes) / count, 2) else: average_uptime = 0.00 return count, filtered_uptimes, average_uptime"},{"question":"def max_min_distance(n: int, k: int, positions: List[int]) -> int: Determine the maximum possible minimum distance between any two adjacent items when placed on valid positions on a conveyor belt with n positions. Parameters: n (int): Number of total positions on the conveyor belt k (int): Number of valid positions positions (List[int]): List of valid positions Returns: int: Maximum possible minimum distance between any two adjacent items Example: >>> max_min_distance(10, 5, [2, 4, 6, 8, 10]) 2 >>> max_min_distance(10, 1, [5]) 0 >>> max_min_distance(10, 5, [1, 2, 3, 4, 5]) 1","solution":"def max_min_distance(n, k, positions): positions.sort() def is_feasible(distance): count = 1 last_position = positions[0] for i in range(1, k): if positions[i] - last_position >= distance: count += 1 last_position = positions[i] if count == k: return True return False left, right = 0, positions[-1] - positions[0] best_d = 0 while left <= right: mid = (left + right) // 2 if is_feasible(mid): best_d = mid left = mid + 1 else: right = mid - 1 return best_d if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n, k = int(data[0]), int(data[1]) positions = list(map(int, data[2:2+k])) print(max_min_distance(n, k, positions))"}]`),S={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},z={class:"card-container"},D={key:0,class:"empty-state"},C=["disabled"],Y={key:0},O={key:1};function P(i,e,u,c,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):m("",!0)]),t("div",z,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",D,' No results found for "'+l(r.searchQuery)+'". ',1)):m("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",O,"Loading...")):(s(),n("span",Y,"See more"))],8,C)):m("",!0)])}const I=d(S,[["render",P],["__scopeId","data-v-f4d2029d"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/41.md","filePath":"guide/41.md"}'),F={name:"guide/41.md"},U=Object.assign(F,{setup(i){return(e,u)=>(s(),n("div",null,[q(I)]))}});export{B as __pageData,U as default};
