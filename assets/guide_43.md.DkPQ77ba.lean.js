import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",E],["__scopeId","data-v-2356756a"]]),S=JSON.parse('[{"question":"# Challenging Markov Chain Simulation You are given a Markov Chain represented by a dictionary where keys are state names and values are dictionaries of probabilities of transitioning from the key state to other states. For instance: ```python my_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } ``` Your task is to write two functions based on the Markov Chain implementation provided: 1. `simulate_markov_chain(chain, start_state, steps)`: Given a Markov Chain `chain`, an initial state `start_state`, and number of steps to simulate `steps`, return the sequence of states visited. 2. `steady_state_probability(chain, threshold=1e-6)`: Compute the steady-state probabilities of each state. The steady-state probability distribution does not change after further applications of the transition probabilities. Function Descriptions and Constraints: - **simulate_markov_chain** - **Input**: - `chain` (dict): The Markov Chain. - `start_state` (str): The starting state. - `steps` (int): The number of steps to simulate. - **Output**: - List of states visited in the given number of steps, starting from `start_state`. - **steady_state_probability** - **Input**: - `chain` (dict): The Markov Chain. - `threshold` (float): Tolerance threshold below which to consider steady-state achieved. - **Output**: - Dictionary where keys are state names and values are their steady-state probabilities. Example Given the Markov Chain: ```python my_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } ``` **simulate_markov_chain** ``` simulate_markov_chain(my_chain, \'A\', 5) ``` Could return a sequence like: `[\'A\', \'A\', \'E\', \'A\', \'E\']` **steady_state_probability** ``` steady_state_probability(my_chain, threshold=1e-6) ``` Should return probabilities close to: `{\'A\': 0.6363, \'E\': 0.3636}` Additional Constraints - Transition probabilities in the chain for each state must sum up to 1.0. - Assume there are no disconnected states in the provided Markov Chain.","solution":"import numpy as np def simulate_markov_chain(chain, start_state, steps): Simulate the number of steps in a Markov Chain starting from a given state. Parameters: - chain (dict): The Markov Chain. - start_state (str): The starting state. - steps (int): The number of steps to simulate. Returns: - list of states visited in the given number of steps, starting from `start_state`. current_state = start_state state_sequence = [current_state] for _ in range(steps): next_state = np.random.choice(list(chain[current_state].keys()), 1, p=list(chain[current_state].values()))[0] state_sequence.append(next_state) current_state = next_state return state_sequence def steady_state_probability(chain, threshold=1e-6): Compute the steady-state probabilities of each state in a Markov Chain. Parameters: - chain (dict): The Markov Chain. - threshold (float): Tolerance threshold below which to consider steady-state achieved. Returns: - dictionary: Keys are state names and values are their steady-state probabilities. states = list(chain.keys()) n = len(states) # Transpose the matrix so we can multiply it on the left transition_matrix = np.array([[chain[i].get(j, 0) for j in states] for i in states]).T # Start with an equal probability distribution prob_dist = np.ones(n) / n while True: new_prob_dist = transition_matrix @ prob_dist if np.max(np.abs(new_prob_dist - prob_dist)) < threshold: break prob_dist = new_prob_dist return dict(zip(states, new_prob_dist))"},{"question":"**Problem Statement**: You are given a 2D board of characters and a list of strings representing words. Your task is to find all words in the list that can be formed by tracing a path in the board. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once for any word. **Function Signature**: ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: pass ``` **Input**: * `board`: A list of lists of characters, `board[i][j]` is a character in the board. * `words`: A list of strings representing the words to search for. **Output**: * Return a list of strings that are found in the board. **Constraints**: * The length of all words will sum to at most `15*10^4`. * The board will have a maximum of `100` rows and `100` columns. * Each word and each character of the board consists of lowercase English letters. * Words may overlap on the board as long as the same letter cell is not reused within each individual word search. **Example**: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # Example Output find_words(board, words) # Output: [\\"oath\\", \\"eat\\"] ``` **Directions**: 1. Construct a Trie (Prefix Tree) from the words list. 2. Implement the backtracking algorithm to search words from the board using the Trie. 3. Manage the visited status of cells to prevent reusing the same cell within a single word search. 4. Handle edge cases like empty board or words list gracefully. 5. Optimize for performance considering the large input constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def find_words(board, words): def backtrack(node, i, j, path, visited): if node.is_end_of_word: result.add(path) node.is_end_of_word = False # avoid duplicate entries if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or (i, j) in visited: return char = board[i][j] if char not in node.children: return # mark the cell as visited visited.add((i, j)) next_node = node.children[char] # explore neighbor cells in the up, down, left, right direction for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: backtrack(next_node, x, y, path + char, visited) # unmark the cell as visited visited.remove((i, j)) # create a trie of words trie = Trie() for word in words: trie.insert(word) result = set() # iterate each cell on the board for i in range(len(board)): for j in range(len(board[0])): backtrack(trie.root, i, j, \'\', set()) return list(result)"},{"question":"**Context**: When securing communication, it is sometimes necessary to validate that data received matches what was sent. In a simpler scenario, this can be exemplified by finding a single character that was added to a string after shuffling. **Problem**: You are given two strings `s` and `t`, where: - `s` is an original string. - `t` is a string created by shuffling the characters of `s` and adding one additional lowercase letter. Write a function `find_added_character(s: str, t: str) -> str` which finds and returns the letter that was added to the string `t`. **Input**: - `s`: A string of lowercase letters (1 <= len(s) <= 10^5). - `t`: A string of lowercase letters such that `t` contains all the characters of `s` plus one additional character (len(t) = len(s) + 1). **Output**: - Return a single character that was added to `t`. **Constraints**: - Both `s` and `t` consist of only lowercase letters. - The additional letter in `t` will appear exactly once. **Examples**: ```python assert find_added_character(\\"abcd\\", \\"abecd\\") == \'e\' assert find_added_character(\\"\\", \\"y\\") == \'y\' assert find_added_character(\\"a\\", \\"aa\\") == \'a\' assert find_added_character(\\"xyz\\", \\"zxyz\\") == \'z\' ``` **Performance Requirements**: - The time complexity should be O(n). - The space complexity should be O(1). **Notes**: - Utilize the XOR bitwise operation to solve this problem optimally. **Function Signature**: ```python def find_added_character(s: str, t: str) -> str: # TODO: Implement the function pass ```","solution":"def find_added_character(s: str, t: str) -> str: Returns the single character that was added to string t. The function utilizes XOR to achieve O(n) time complexity and O(1) space complexity. result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"# Context: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. While it is simple to define the nth Fibonacci number recursively, this method can be highly inefficient for large n. Alternative methods utilize dynamic programming or iterative methods to overcome these inefficiencies. # Task: Write a Python function to compute the nth Fibonacci number in an efficient manner. You must use an iterative approach to achieve optimal time and space complexity. # Requirements: 1. **Function Name**: `fib_iter_optimized` 2. **Input**: - An integer `n` (0 <= n <= 10^6), representing the position in the Fibonacci sequence. 3. **Output**: - An integer, the nth Fibonacci number. 4. **Constraints**: - The solution should have a time complexity O(n). - The solution should use O(1) additional space for variables apart from the input and output. # Example Usage: ```python assert fib_iter_optimized(0) == 0 assert fib_iter_optimized(1) == 1 assert fib_iter_optimized(10) == 55 assert fib_iter_optimized(50) == 12586269025 ``` # Notes: * Ensure that your function handles the edge cases correctly like n=0 and n=1. * Pay attention to performance. The function should execute within a reasonable time frame for very large n (up to 10^6).","solution":"def fib_iter_optimized(n): Computes the nth Fibonacci number using an iterative approach. Args: n : int The position in the Fibonacci sequence (0 <= n <= 10^6). Returns: int : the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Priority Queue Optimization Challenge You are given a linear array-based implementation of a priority queue where insertion takes O(n) time and extraction takes O(1) time. This implementation is straightforward but inefficient for applications requiring frequent insertions. Your task is to optimize the `PriorityQueue` class to improve the insertion operation while maintaining or improving the overall efficiency of the priority queue. You should use a data structure that supports efficient insertion and extraction operations. **Requirements**: 1. **Input/Output**: - You should implement the optimized priority queue as a new class `OptimizedPriorityQueue`. - The class should support the following methods: - `__init__(self, items=None, priorities=None)`: Constructor to initialize the priority queue. - `size(self)`: Return the number of elements in the queue. - `push(self, item, priority=None)`: Insert an element into the queue. If `priority` is not provided, use the value of `item` as its priority. - `pop(self)`: Remove and return the element with the lowest priority. - The constructor should support initializing the queue with a list (or iterable) of items and their associated priorities. 2. **Constraints**: - You can use the heapq module or any other appropriate existing data structure from the standard library to improve efficiency. - The expected average time complexity for `push` and `pop` operations should be O(log n). 3. **Performance Requirements**: - Ensure that `push` operations are significantly faster than the original O(n) implementation. - The `pop` operation should remain efficient (preferably O(log n) or better). 4. **Scenario**: - You are working on a task scheduling system where tasks have priorities. Efficient task insertion and execution order determination are critical. Your optimized priority queue will be used to manage the tasks. **Example**: ```python pq = OptimizedPriorityQueue() pq.push(\\"task1\\", 3) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 2) print(pq.pop()) # Output: \\"task2\\" print(pq.pop()) # Output: \\"task3\\" print(pq.pop()) # Output: \\"task1\\" ```","solution":"import heapq class OptimizedPriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): return heapq.heappop(self.heap)[1]"},{"question":"# Design and Implement a Randomized Collection Objective You are required to extend the `RandomizedSet` to support duplicate elements. This new data structure, `RandomizedCollection`, must still support the following operations in average O(1) time: 1. `insert(val)`: Inserts an item val into the collection. 2. `remove(val)`: Removes an item val from the collection. 3. `random_element()`: Returns a random element from the collection. Each element must have an equal probability of being returned. Input and Output Implement a class `RandomizedCollection` with the following methods: - `__init__(self)`: Initialize your data structure. - `insert(self, val: int) -> bool`: Inserts a value to the collection. Returns `true` if the collection did not already contain the specified element. - `remove(self, val: int) -> bool`: Removes a value from the collection. Returns `true` if the collection contained the specified element. - `random_element(self) -> int`: Get a random element from the collection. Constraints - Values in the collection can range between -10^4 and 10^4. - Functions should run in average O(1) time. - Duplicate values are allowed. Example ``` collection = RandomizedCollection() print(collection.insert(1)) # true, collection becomes [1] print(collection.insert(1)) # false, collection becomes [1, 1] print(collection.insert(2)) # true, collection becomes [1, 1, 2] print(collection.random_element()) # returns 1 with probability 2/3, and 2 with probability 1/3 print(collection.remove(1)) # true, collection becomes [1, 2] print(collection.random_element()) # returns 1 or 2 both with equal probability ```","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): self.values = [] self.indices = defaultdict(set) def insert(self, val: int) -> bool: self.values.append(val) self.indices[val].add(len(self.values) - 1) return len(self.indices[val]) == 1 def remove(self, val: int) -> bool: if not self.indices[val]: return False remove_idx = self.indices[val].pop() last_val = self.values[-1] if remove_idx != len(self.values) - 1: self.values[remove_idx] = last_val self.indices[last_val].add(remove_idx) self.indices[last_val].remove(len(self.values) - 1) self.values.pop() if not self.indices[val]: del self.indices[val] return True def random_element(self) -> int: return random.choice(self.values)"},{"question":"# Matrix Inversion Enhancement Objective You are tasked with enhancing the provided matrix inversion function to handle larger matrices more efficiently and accurately. Your solution should aim to reduce the computational overhead and manage error scenarios robustly. Problem Statement Write a function `enhanced_invert_matrix(matrix)` that takes a square matrix as input and returns its inverse. Ensure your function is optimized for efficiency and clarity. Utilize cache mechanisms to speed up determinant calculations and handle large matrices elegantly. # Expected Input and Output - **Input**: A 2D list `matrix` representing an n x n matrix, where 2 <= n <= 100. ```python matrix = [ [4, 7], [2, 6] ] ``` - **Output**: A 2D list representing the inverse of the provided matrix. If the matrix is not invertible, return `None`. ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` # Constraints 1. Do not use any built-in functions that directly compute matrix inverses. 2. Handle edge cases such as non-invertible matrices and validate inputs appropriately. 3. Optimize the determinant calculation using caching where possible to improve efficiency. # Function Signature ```python def enhanced_invert_matrix(matrix: List[List[int]]) -> List[List[float]]: pass ``` # Example Input: ```python matrix = [ [4, 7], [2, 6] ] ``` Output: ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` # Performance - Aim to maintain or improve the time complexity where possible. - Ensure efficient memory usage, especially when dealing with determinant caching.","solution":"from typing import List def get_matrix_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def get_matrix_determinant(matrix): # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1)**c) * matrix[0][c] * get_matrix_determinant(get_matrix_minor(matrix, 0, c)) return determinant def get_matrix_inverse(matrix): determinant = get_matrix_determinant(matrix) if determinant == 0: return None # Not invertible # Special case for 2x2 matrix if len(matrix) == 2: return [ [matrix[1][1] / determinant, -1 * matrix[0][1] / determinant], [-1 * matrix[1][0] / determinant, matrix[0][0] / determinant] ] # Find matrix of cofactors cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor = get_matrix_minor(matrix, r, c) cofactor = ((-1)**(r+c)) * get_matrix_determinant(minor) cofactor_row.append(cofactor) cofactors.append(cofactor_row) cofactors = list(map(list, zip(*cofactors))) # Transpose for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors def enhanced_invert_matrix(matrix: List[List[int]]) -> List[List[float]]: return get_matrix_inverse(matrix)"},{"question":"Implementing Enhanced Ternary Search Context: You have been given an array sorted in ascending order and a target key. Your task is to determine the index of the key in this array using an enhanced variation of the ternary search algorithm. In this enhanced version, you must also handle cases where the array can contain duplicates and return all the indices where the target key is found. Task: Write a function `enhanced_ternary_search` to find all occurrences of a given target key in an array sorted in ascending order. If the target key is found, return a list of indices where the key appears in the array. If the target key is not found, return an empty list. Function Signature: ```python def enhanced_ternary_search(arr, left, right, key): Find all occurrences of the target key in an array sorted in ascending order. Args: - arr (list of int): Sorted array of integers. - left (int): Left boundary of the search interval. - right (int): Right boundary of the search interval. - key (int): Target value to search for. Returns: - list of int: List of indices where the key appears in the array, empty list if key is not found. pass ``` Input: - `arr`: A list of integers in ascending order, with possible duplicate values. (1 <= len(arr) <= 10^5) - `left`: The starting index of the array (generally 0). - `right`: The ending index of the array (generally len(arr)-1). - `key`: The target value to search for (-10^5 <= key <= 10^5). Output: - A list of integers representing the indices where the key appears in the array. If the key does not exist, return an empty list. Constraints: - The input array can have up to 100,000 elements. - Your solution should have a time complexity better than O(N), ideally close to O(log3(N)). Example: ```python # Example 1 arr = [1, 2, 2, 2, 3, 4, 5] key = 2 enhanced_ternary_search(arr, 0, len(arr) - 1, key) # Output: [1, 2, 3] # Example 2 arr = [1, 3, 5, 7] key = 4 enhanced_ternary_search(arr, 0, len(arr) - 1, key) # Output: [] ``` Notes: - Ensure to properly handle edge cases like arrays of size zero or one. - Consider a strategy to gather indices when duplicates are found. - Optimize your approach to maintain an overall time complexity close to O(log3(N)).","solution":"def enhanced_ternary_search(arr, left, right, key): Find all occurrences of the target key in an array sorted in ascending order. Args: - arr (list of int): Sorted array of integers. - left (int): Left boundary of the search interval. - right (int): Right boundary of the search interval. - key (int): Target value to search for. Returns: - list of int: List of indices where the key appears in the array, empty list if key is not found. indexes = [] def binary_search_all(arr, key): first = binary_search_first_occurrence(arr, key) last = binary_search_last_occurrence(arr, key) if first == -1: return [] return list(range(first, last + 1)) def binary_search_first_occurrence(arr, key): left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == key: result = mid right = mid - 1 elif arr[mid] < key: left = mid + 1 else: right = mid - 1 return result def binary_search_last_occurrence(arr, key): left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == key: result = mid left = mid + 1 elif arr[mid] < key: left = mid + 1 else: right = mid - 1 return result indexes = binary_search_all(arr[left:right+1], key) # Adjust the result because we have passed a portion of the array return [index + left for index in indexes]"},{"question":"Write a function `is_consecutive(stack)` that determines whether a given stack contains a sequence of consecutive integers from the bottom to the top. You must return `True` if the stack contains consecutive integers in ascending order, and `False` otherwise. After the function executes, the original order of the stack should remain unchanged. You are required to implement this function using one of the two approaches described below: 1. **Using an auxiliary stack** 2. **Using an auxiliary queue** Implementation Details * **Input**: A `stack` which is a list of integers. * **Output**: A boolean value (`True` or `False`). * **Constraints**: - The stack can contain negative integers. - The size of the stack will not exceed 10^5. Example 1. Input: `stack = [3, 4, 5, 6, 7]` Output: `True` 2. Input: `stack = [3, 4, 6, 7]` Output: `False` 3. Input: `stack = [3, 2, 4]` Output: `False` Context You are given a stack of integers, and you need to check if the integers from bottom to top form a consecutive increasing sequence. This can be useful for data integrity checks or automated grading systems where sequential data must be validated. Performance Requirements Your implementation should maintain O(n) time complexity, where n is the number of elements in the stack. The auxiliary storage should also not exceed O(n) space complexity. Guidelines - You may use either an additional stack or a queue for auxiliary storage. - Avoid modifying the original order of the stack after execution. Function Signature ```python def is_consecutive(stack: list[int]) -> bool: pass ```","solution":"from collections import deque def is_consecutive(stack): Checks if the stack contains a sequence of consecutive integers from bottom to top. Parameters: stack (list): A list of integers representing the stack, where the 0th element is the bottom. Returns: bool: True if the stack contains consecutive integers in ascending order, False otherwise. # Helper function to copy the stack into a queue def copy_to_queue(stack): queue = deque() for item in stack: queue.append(item) return queue # Use an auxiliary queue to check consecutive queue = copy_to_queue(stack) while len(queue) > 1: first = queue.popleft() second = queue[0] if first + 1 != second: return False return True"},{"question":"# Problem Description You are tasked with implementing a function to quickly determine the number of digits in an integer. This function must work efficiently even for very large integers. You should use mathematical principles rather than converting the number to a string to achieve this. # Function Signature ```python def num_digits(n: int) -> int: pass ``` # Input * An integer `n`, where `-10^18 <= n <= 10^18`. # Output * Returns an integer indicating the number of digits in `n`. # Constraints * The function should operate in constant time O(1). # Examples ```python assert num_digits(12345) == 5 assert num_digits(0) == 1 assert num_digits(-987654321) == 9 assert num_digits(1000000000) == 10 ``` # Explanation 1. `num_digits(12345)` should return `5` because 12345 has 5 digits. 2. `num_digits(0)` should return `1` because 0 is a single digit. 3. `num_digits(-987654321)` should return `9` because after taking the absolute value, 987654321 has 9 digits. 4. `num_digits(1000000000)` should return `10` because 1000000000 has 10 digits. Implement the function considering the above edge cases and constraints.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in an integer n. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Problem Context Consider a scenario where you are given a string and need to determine if it is a palindrome. For this problem, a palindromic string is a string that reads the same backward as forward, ignoring spaces, punctuation, and case differences. Your task is to implement a function that checks for palindromes using an efficient method. # Function Signature ```python def is_palindromic_string(s: str) -> bool: pass ``` # Input: - `s`: A string that may contain alphanumeric characters and punctuation. # Output: - Returns `True` if the string is a palindrome, and `False` otherwise. # Constraints: - The input string `s` can be of length up to (10^5). - The string will always be composed of printable ASCII characters. # Example ```python print(is_palindromic_string(\\"A man, a plan, a canal: Panama\\")) # Output: True print(is_palindromic_string(\\"race a car\\")) # Output: False print(is_palindromic_string(\\"\\")) # Output: True print(is_palindromic_string(\\" \\")) # Output: True print(is_palindromic_string(\\"No lemon, no melon\\")) # Output: True ``` # Notes: 1. You must only consider alphanumeric characters and ignore cases while checking if the string is a palindrome. 2. Implement the function without using any external libraries (aside from the standard library if necessary). 3. Aim to solve the problem with a time complexity of O(n) and use O(1) additional space.","solution":"def is_palindromic_string(s: str) -> bool: import re # Remove non-alphanumeric characters and convert to lower case filtered_s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Check if the filtered string is a palindrome return filtered_s == filtered_s[::-1]"},{"question":"# Code Assessment Question Context You are developing a feature for a text editing application where you need to determine if a given string is a rotated version of another string. This is crucial for implementing functionalities involving cyclic patterns like cyclic playlists, repeating reminders, and circular buffers. Problem Statement Write a function `is_rotated_optimized(s1: str, s2: str) -> bool` that checks if the string `s2` is a rotated version of `s1`. # Example ```python assert is_rotated_optimized(\\"hello\\", \\"llohe\\") == True assert is_rotated_optimized(\\"hello\\", \\"helol\\") == False assert is_rotated_optimized(\\"abcd\\", \\"cdab\\") == True assert is_rotated_optimized(\\"\\", \\"\\") == True assert is_rotated_optimized(\\"a\\", \\"a\\") == True assert is_rotated_optimized(\\"ab\\", \\"ba\\") == True assert is_rotated_optimized(\\"abc\\", \\"acb\\") == False ``` # Input Format - `s1` and `s2` are strings with lengths in the range [0, 1000]. # Constraints 1. The function should run in O(N) time complexity. 2. Only the methods mentioned should be used (no additional imported libraries allowed). # Performance Criteria - The function should correctly handle all edge cases. - Ensure efficient memory usage, particularly when dealing with large input sizes.","solution":"def is_rotated_optimized(s1: str, s2: str) -> bool: Checks if s2 is a rotated version of s1. Args: s1 (str): The original string. s2 (str): The string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False # Concatenate s1 with itself. s2 should appear as a substring if it\'s a rotation concatenated_s1 = s1 + s1 return s2 in concatenated_s1"},{"question":"You are given a list of integers representing the weights of packages. Your task is to write a function to compute the frequency distribution of these weights, represented as a histogram. In a histogram, each unique weight should be mapped to the number of times it occurs in the list. # Function Signature ```python def package_weight_histogram(package_weights: list) -> dict: pass ``` # Input - `package_weights`: A list of integers, where each integer represents a weight. The list may contain duplicate weights (1 <= len(package_weights) <= 10^5). # Output - A dictionary where the keys are the unique weights, and the values are the counts of those weights in the list. # Example ```python package_weights = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} package_weights = [] # Expected output: {} package_weights = [10, 10, 10] # Expected output: {10: 3} ``` # Constraints and Performance Requirements * The function should handle large lists efficiently. * Assume that the list can have at most (10^5) elements. * Ensure the function operates within O(n) time complexity to cope with the upper limit of input size. # Additional Context In statistical analysis or during warehouse inventory management, understanding the frequency of package weights can help optimize storage and movement strategies.","solution":"def package_weight_histogram(package_weights): Returns a dictionary where keys are unique weights and values are the counts of those weights in the list. histogram = {} for weight in package_weights: if weight in histogram: histogram[weight] += 1 else: histogram[weight] = 1 return histogram"},{"question":"**Tarjan\'s Algorithm for Strongly Connected Components** As part of a network analysis, you need to identify all the strongly connected components (SCCs) in a given directed graph. Your task is to implement Tarjan\'s Algorithm to find these SCCs. # Context: You have a directed graph where each node represents a city, and each edge represents a direct road connecting one city to another. Your goal is to find clusters of cities that are mutually reachable, i.e., from any city in a cluster, you can reach any other city in the same cluster. # Function Specification: **Function Name**: `find_scc_tarjan` **Input**: - A dictionary representing the directed graph, where keys are nodes and values are lists of adjacent nodes. **Output**: - A list of lists, where each sublist contains nodes that form a strongly connected component. **Constraints**: - Nodes are represented as integers. - The graph can contain cycles and self-loops. - The graph is guaranteed to have at least one node. **Performance requirements**: - The solution should work efficiently within the time complexity of O(V + E). # Example: ```python # Example Input: graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3, 6], 6: [], 7: [8], 8: [9], 9: [7] } # Expected Output: [[0, 1, 2], [3, 4, 5], [6], [7, 8, 9]] ``` # Requirements: 1. Implement the function `find_scc_tarjan(graph: dict) -> list`. 2. Ensure that each strongly connected component is returned as a sorted list of nodes. 3. The entire list of SCCs should not have any specific order. # Main Operations: 1. Implement a depth-first search (DFS) traversal. 2. Use stacking to manage the path and identify SCCs as you backtrack. 3. Maintain indexes and lowlink values as per Tarjan\'s algorithm specification. # Notes: - Consider edge cases like graphs with no edges, single-node graphs, and disconnected components. - Pay attention to optimizing your solution to work within the given time complexity constraints. - Write clean, modular, and well-documented code.","solution":"def find_scc_tarjan(graph): Find all the strongly connected components (SCCs) in the given directed graph using Tarjan\'s Algorithm. Parameters: graph (dict): A dictionary representing the directed graph, where keys are nodes and values are lists of adjacent nodes. Returns: list: A list of lists, where each sublist contains nodes that form a strongly connected component. index = 0 stack = [] index_map = {} lowlink_map = {} in_stack = set() sccs = [] def strongconnect(node): nonlocal index index_map[node] = index lowlink_map[node] = index index += 1 stack.append(node) in_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in index_map: strongconnect(neighbor) lowlink_map[node] = min(lowlink_map[node], lowlink_map[neighbor]) elif neighbor in in_stack: lowlink_map[node] = min(lowlink_map[node], index_map[neighbor]) if lowlink_map[node] == index_map[node]: scc = [] while True: w = stack.pop() in_stack.discard(w) scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph.keys(): if node not in index_map: strongconnect(node) return sccs"},{"question":"# Conversion Between Little Endian and Big Endian Given a list of integers, devise a function to perform the following transformations: 1. Convert each integer to its byte array representation in both big endian and little endian conventions. 2. Convert these byte arrays back to integers. You need to implement the following functions: 1. `convert_to_endians(int_list)` - Input: `int_list` (List of non-negative integers) - Output: Returns a list of tuples where each tuple contains the big endian byte representation, and little endian byte representation of the integer. 2. `convert_from_endians(bytes_list)` - Input: `bytes_list` (List of tuples where each tuple contains a big endian byte array and a little endian byte array) - Output: Returns a list of integers retrieved from the provided byte arrays. # Example: ```python assert convert_to_endians([500, 1024]) == [ (b\'x01xf4\', b\'xf4x01\'), (b\'x04x00\', b\'x00x04\') ] assert convert_from_endians([(b\'x01xf4\', b\'xf4x01\'), (b\'x04x00\', b\'x00x04\')]) == [500, 1024] ``` # Constraints: - Input integers are non-negative. - Byte arrays represent the integer in its correct endianness. - Additionally, these functions should handle edge cases such as zero appropriately and avoid unnecessary memory overhead.","solution":"def convert_to_endians(int_list): Given a list of integers, convert each integer to its byte array representation in both big endian and little endian conventions. result = [] for num in int_list: big_endian = num.to_bytes((num.bit_length() + 7) // 8 or 1, \'big\') little_endian = num.to_bytes((num.bit_length() + 7) // 8 or 1, \'little\') result.append((big_endian, little_endian)) return result def convert_from_endians(bytes_list): Given a list of tuples where each tuple contains a big endian byte array and a little endian byte array, convert these byte arrays back to integers. result = [] for big_endian, little_endian in bytes_list: # Convert big endian byte array to integer big_int = int.from_bytes(big_endian, \'big\') # Convert little endian byte array to integer little_int = int.from_bytes(little_endian, \'little\') assert big_int == little_int # They should be equal result.append(big_int) return result"},{"question":"You are given a number represented as a list of digits in big-endian order, where each element in the list is a digit between 0 and 9. Implement a function to add one to the number and return the resulting list of digits. # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: ``` # Input - A list of integers representing the digits of a non-negative number. - The digits are in big-endian order (most significant digit first), and there may be leading zeros, although in the context of non-negative integers there should not be any leading zero for typical use cases except the number 0 itself. # Output - A list of integers representing the digits of the number after adding one to it. # Example ```python assert plus_one([1, 2, 3]) == [1, 2, 4] assert plus_one([1, 2, 9]) == [1, 3, 0] assert plus_one([9, 9, 9]) == [1, 0, 0, 0] assert plus_one([0]) == [1] assert plus_one([9, 0, 0, 9]) == [9, 0, 1, 0] ``` # Constraints - The input list will not be empty and will contain valid digits (0-9). - The result should be accurate and handle edge cases efficiently, particularly the propagation of carries. - Aim for both time and space efficiency. # Scenario and Context Imagine you are developing a low-level arithmetic library that needs to handle extremely large numbers that can\'t be stored in standard data types. Instead, you\'re using arrays to represent these numbers and need to implement fundamental arithmetic operations such as incrementing a number.","solution":"def plus_one(digits): Adds one to the number represented by the list of digits. Returns the resulting list of digits. n = len(digits) for i in range(n-1, -1, -1): # Add one to the last digit, and handle carries if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we are here it means there was a carry out of the most significant digit return [1] + digits"},{"question":"Scenario: You are a software engineer tasked with improving the efficiency of a binary data stream by increasing the consecutive `1`s. Given a binary array, you need to identify the optimal position to switch a `0` to a `1` to maximize the consecutive sequence of `1`s. Task: Implement a function `find_optimal_zero_to_flip` that identifies the index of `0` to flip to achieve the longest continuous sequence of `1`s. Function Signature: ```python def find_optimal_zero_to_flip(arr: List[int]) -> int: pass ``` Input: - `arr`: A list of integers containing only `0`s and `1`s. Constraints: - The length of `arr` will be between 1 and 10^5. Output: - The function should return an integer, representing the index of `0` that should be flipped to `1`. If the array has no `0` or if no `0` needs to be flipped (if all `1`s), return `-1`. Constraints & Considerations: - If the length of `arr` is shorter than 3, handle separately since an empty array indicates no change needed, and arrays of size `1` or `2` are trivial. - Aim for an O(n) time complexity solution. - Ensure space complexity remains O(1). Example: ```python # Example 1: arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] # The 0 at index 3 should be replaced with 1 to achieve the longest sequence of 1s. # So, the function returns 3. assert find_optimal_zero_to_flip(arr) == 3 # Example 2: arr = [1, 1, 1, 1, 1] # Since there is no 0 to flip, return -1. assert find_optimal_zero_to_flip(arr) == -1 # Example 3: arr = [0, 0, 0, 0] # Any 0 can be flipped. The function can return any valid index like 0. assert find_optimal_zero_to_flip(arr) in [0, 1, 2, 3] ```","solution":"def find_optimal_zero_to_flip(arr): Identifies the index of `0` to flip to achieve the longest continuous sequence of `1`s. :param arr: List of integers containing only `0`s and `1`s. :type arr: List[int] :return: Index of the `0` to flip. Return -1 if no flip needed or no `0`s. :rtype: int n = len(arr) if n == 0: return -1 # Handling cases with no zeros if 0 not in arr: return -1 max_count = 0 zero_index = -1 current_count = 0 prev_zero_count = 0 best_zero_index = -1 for i in range(n): if arr[i] == 1: current_count += 1 else: # When we hit a zero, update the counts and reset if zero_index != -1: if current_count + prev_zero_count + 1 > max_count: max_count = current_count + prev_zero_count + 1 best_zero_index = zero_index # Update for the encountered zero prev_zero_count = current_count current_count = 0 zero_index = i # Last segment check if zero_index != -1: if current_count + prev_zero_count + 1 > max_count: best_zero_index = zero_index return best_zero_index"},{"question":"Coding Challenge: Implement Radix Sort with String Conversion for Large Integers # Problem Statement You are tasked with extending the radix sort algorithm to handle large integers of varying lengths efficiently, leveraging string manipulation for digit extraction. Your implementation should be capable of sorting a list of numbers that might exceed standard integer ranges. # Input Format - A list of non-negative integers represented as strings (`arr`). # Output Format - A list of sorted integers represented as strings in ascending order. # Function Signature ```python def radix_sort_string(arr: List[str]) -> List[str]: ``` # Constraints - Each integer in the list `arr` is represented as a string. - All integers are non-negative. - Length of the integers (in terms of digits) can vary. - The input list can be empty. # Performance Requirements - Your function should strive for O(nk) time complexity, similar to the fundamental radix sort. - Aim for optimal space usage while ensuring stability in sorting. # Example Input ```python arr = [\\"170\\", \\"45\\", \\"75\\", \\"90\\", \\"802\\", \\"24\\", \\"2\\", \\"66\\"] ``` Output ```python [\\"2\\", \\"24\\", \\"45\\", \\"66\\", \\"75\\", \\"90\\", \\"170\\", \\"802\\"] ``` # Guidelines - Consider zero-padding shorter numbers to ensure uniform digit length during sorting. - Utilize radix sort principles but adjust digit extraction via string indexing. - Ensure your final implementation is stable and handles edge cases effectively, such as empty inputs. Complete the function definition and ensure it passes the given example. You may add additional test cases to validate the robustness of your solution.","solution":"from typing import List def radix_sort_string(arr: List[str]) -> List[str]: if not arr: return [] # Find the maximum length of the numbers max_length = max(len(num) for num in arr) # Pad all numbers with leading zeros to make them the same length padded_arr = [num.zfill(max_length) for num in arr] # Perform radix sort from least significant digit to most significant digit for digit in range(max_length - 1, -1, -1): # Creating buckets for each digit (0-9) buckets = [[] for _ in range(10)] for num in padded_arr: bucket_index = int(num[digit]) buckets[bucket_index].append(num) # Flatten the list of buckets padded_arr = [num for bucket in buckets for num in bucket] # Remove the zero-padding used for sorting before returning results sorted_arr = [num.lstrip(\'0\') or \'0\' for num in padded_arr] return sorted_arr"},{"question":"# Radix Sort Function Implementation Context You are given a list of non-negative integers, and your task is to implement the Radix Sort algorithm to sort this list in ascending order. The algorithm should use the least significant digit (LSD) approach. Function Signature ```python def radix_sort(arr: list, simulation: bool = False) -> list: ``` Input Format * A list of non-negative integers, `arr` (1 <= len(arr) <= 10^5, 0 <= arr[i] <= 10^9). * An optional boolean `simulation`, defaulting to `False`. If set to `True`, the function should print the state of the list after each significant digit sorting step. Output Format * A list of integers sorted in ascending order. Constraints * You may assume all integers fit within standard integer range. * The function must handle lists with very large numbers efficiently. Performance Requirements * The function should run in O(nk + n) time complexity, where n is the length of the list and k is the number of digits in the maximum number of the list. Example ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` Additionally, if `simulation` is set to `True`, the function should print each intermediate sorting step: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr, True)) # Output: # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 802 2 24 45 66 170 75 90 # iteration 2 : 2 24 45 66 75 90 170 802 # iteration 3 : 2 24 45 66 75 90 170 802 ``` Notes Be mindful of performance and edge cases such as empty lists or lists containing zeroes. Ensure that the function remains stable and efficient across a wide range of potential inputs.","solution":"def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[(index) % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[(index) % 10] - 1] = arr[i] count[(index) % 10] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] def radix_sort(arr, simulation=False): max_val = max(arr) if arr else 0 exp = 1 while max_val // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {exp} : {\' \'.join(map(str, arr))}\\") exp *= 10 return arr"},{"question":"# Problem Description You are tasked with creating a function that determines the next higher number formed from the same set of digits as the given number. Your function should be designed to handle non-negative integers efficiently and correctly identify when no such permutation exists. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Input 1. `num` (integer): A non-negative integer. # Output - Returns the next number that can be formed with the same digits in numerical order. - If no such number exists, return `-1`. # Constraints - The input number will be a non-negative integer (0 <= num <= 10^9). # Performance Requirements - Your solution must be optimized to run efficiently within O(n) time complexity, where n is the number of digits in the number. - Space complexity should be handled efficiently and kept within reasonable limits. # Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` # Detailed Explanation 1. **Identify Pivot**: Traverse the digits from right to left until you find a pair where the left digit is smaller than the right digit. The left digit is the pivot. 2. **Find Swap Element**: From the end of the list, find the smallest digit greater than the pivot and swap the two. 3. **Reverse Suffix**: Reverse the order of digits to the right of the pivot to get the smallest lexicographical order. # Notes - The provided function should handle edge cases effectively, ensuring correct identification of situations where no higher permutation is possible. - Be mindful of type conversions between integers and lists to maintain efficiency.","solution":"def next_bigger(num: int) -> int: Returns the next higher number formed from the same set of digits as the given number. If no such permutation exists, returns -1. num_str = list(str(num)) length = len(num_str) # Step 1: Find the rightmost digit which is smaller than the digit next to it. pivot = -1 for i in range(length - 2, -1, -1): if num_str[i] < num_str[i + 1]: pivot = i break # If no such pivot is found, return -1 as no larger number is possible. if pivot == -1: return -1 # Step 2: Find the smallest digit on right side of pivot which is larger than num_str[pivot] for i in range(length - 1, pivot, -1): if num_str[i] > num_str[pivot]: # Step 3: Swap the found digit with pivot num_str[pivot], num_str[i] = num_str[i], num_str[pivot] break # Step 4: Reverse the digits after pivot\'s position num_str = num_str[:pivot + 1] + sorted(num_str[pivot + 1:]) return int(\'\'.join(num_str))"},{"question":"# Summary of Ranges - Coding Challenge Scenario You are working on a system to process sorted logs that identify sequential activity periods. For efficient storage and retrieval, you need to summarize these periods as ranges. Task Write a function `summarize_ranges(array: List[int]) -> List[str]` that converts a sorted list of integers into a list of summarized ranges. A range is defined by consecutive integers, and single integers should be reported as themselves. Input and Output Format * **Input**: A sorted list of integers without duplicates. - Example: `[0, 1, 2, 4, 5, 7]` * **Output**: A list of strings representing summarized ranges. - Example: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` Constraints * The input list should contain at most 10^4 integers. * The integers are all unique and sorted in ascending order. * The integer values are within the range [-10^4, 10^4]. Example ```python >>> summarize_ranges([0, 1, 2, 4, 5, 7]) [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` Performance Requirements * Should complete in O(n) time where n is the length of the input list. * Use O(1) extra space excluding the input and output lists. Edge Cases to Consider * A single-element list. * A list where there is no consecutive sequence. * A list where all elements form a single consecutive range. Write your function below: ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: res = [] if not array: return res if len(array) == 1: return [str(array[0])] it = iter(array) start = end = next(it) for num in it: if num - end == 1: end = num else: res.append((start, end) if start != end else (start,)) start = end = num res.append((start, end) if start != end else (start,)) return [f\\"{r[0]}-{r[1]}\\" if len(r) > 1 else str(r[0]) for r in res] ```","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: res = [] if not array: return res start, end = array[0], array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: res.append(f\\"{start}\\") else: res.append(f\\"{start}-{end}\\") start, end = num, num if start == end: res.append(f\\"{start}\\") else: res.append(f\\"{start}-{end}\\") return res"},{"question":"Flatten Nested Dictionaries **Background**: In various data processing applications, you often encounter nested dictionaries. A common task is to \\"flatten\\" these dictionaries so that there are no nested dictionaries remaining. In this question, you are given a nested dictionary. Your task is to flatten it such that the resulting dictionary contains no nested dictionaries. The keys in the resulting dictionary should be the concatenation of the keys from the nested levels, separated by the provided delimiter. **Example**: ```python Input: nested_dict = { \'a\': 1, \'b\': { \'c\': 2, \'d\': { \'e\': 3 } }, \'f\': 4 } delimiter = \'_\' Output: { \'a\': 1, \'b_c\': 2, \'b_d_e\': 3, \'f\': 4 } ``` **Task**: Complete the function `flatten_dict(nested_dict, delimiter)` that takes in a nested dictionary `nested_dict` and a string `delimiter`, and returns a flattened dictionary. **Function Signature**: ```python def flatten_dict(nested_dict: dict, delimiter: str) -> dict: pass ``` **Input**: - `nested_dict`: A dictionary that may contain nested dictionaries. - `delimiter`: A string that will be used to concatenate keys. **Output**: - Returns a flattened dictionary where the nested keys are concatenated by the specified delimiter. **Constraints**: - The keys in the dictionary are strings. - The values in the dictionary are either dictionaries or integers/floats/strings. - You can assume there are no cyclic references in the dictionary. **Examples**: 1. `flatten_dict({\'a\': 1, \'b\': {\'c\': 2, \'d\': {\'e\': 3}}, \'f\': 4}, \'_\')` should return `{\'a\': 1, \'b_c\': 2, \'b_d_e\': 3, \'f\': 4}`. 2. `flatten_dict({\'key\': {\'sub_key\': {\'sub_sub_key\': \'value\'}}}, \':\')` should return `{\'key:sub_key:sub_sub_key\': \'value\'}`. **Additional Notes**: - Consider edge cases such as empty dictionaries. - Think about performance implications for very deeply nested structures.","solution":"def flatten_dict(nested_dict, delimiter): def flatten(current_dict, parent_key, result_dict): for k, v in current_dict.items(): new_key = parent_key + delimiter + k if parent_key else k if isinstance(v, dict): flatten(v, new_key, result_dict) else: result_dict[new_key] = v result = {} flatten(nested_dict, \'\', result) return result"},{"question":"Question **Regular Expression Matching** You are tasked with implementing a regular expression matcher that supports two special characters: `\'.\'` and `\'*\'`. * `\'.\'` Matches any single character. * `\'*\'` Matches zero or more of the preceding element. The function should take two inputs: 1. `s` (the input string, type `str`) 2. `p` (the pattern string, type `str`) The function should return `True` if the pattern `p` matches the entire string `s`, otherwise return `False`. # Input: * `s` : string, consists of lowercase letters (a-z). * `p` : string, consists of lowercase letters (a-z), `\'.\'`, and `\'*\'`. # Output: * `bool`: `True` if pattern matches the whole string, `False` otherwise. # Constraints: * `0 <= len(s) <= 1000` * `0 <= len(p) <= 1000` # Example: ```python print(is_match(\\"aa\\", \\"a\\")) # Output: False print(is_match(\\"aa\\", \\"aa\\")) # Output: True print(is_match(\\"aaa\\", \\"aa\\")) # Output: False print(is_match(\\"aa\\", \\"a*\\")) # Output: True print(is_match(\\"aa\\", \\".*\\")) # Output: True print(is_match(\\"ab\\", \\".*\\")) # Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Output: True ``` # Notes: * Ensure the function processes the entire strings without short-circuiting. * Consider edge cases such as empty strings and patterns like \\".*\\" or \\"a*\\".","solution":"def is_match(s, p): Returns True if the entire string `s` matches the pattern `p`, otherwise returns False. The pattern `p` can include \'.\' and \'*\' where: - \'.\' matches any single character - \'*\' matches zero or more of the preceding element m, n = len(s), len(p) # dp[i][j] means s[0..i-1] matches p[0..j-1] dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Deal with patterns like a* or a*b* or a*b*c* for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] |= dp[i - 1][j] return dp[m][n]"},{"question":"# Question You are provided with a square matrix `A` represented as a 2D list. Your task is to implement a function `crout_matrix_decomposition(A)` that decomposes the matrix `A` into a lower triangular matrix `L` and an upper triangular matrix `U` such that `L * U = A`. For this decomposition: - `L` should be a lower triangular matrix with non-zero elements on and below the diagonal. - `U` should be an upper triangular matrix with ones on the diagonal and non-zero elements above the diagonal. # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ... ``` # Input * A: A list of n lists, each containing n floats representing the square matrix `A` (1 <= n <= 100). # Output * A tuple (L, U) where: * `L` is a list of n lists representing the lower triangular matrix. * `U` is a list of n lists representing the upper triangular matrix. # Constraints * Ensure that elements on the diagonal of `L` are not zero by replacing zeros with a very small value if needed. # Example ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] L, U = crout_matrix_decomposition(A) # L should be: # [ # [1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0] # ] # U should be: # [ # [1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0] # ] ``` Implement the function `crout_matrix_decomposition` using Python. Note: - Handle edge cases such as if a zero occurs on the diagonal. - Ensure your implementation is efficient for the provided constraints.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 for j in range(i, n): sum_l = sum(L[j][k] * U[k][i] for k in range(i)) L[j][i] = A[j][i] - sum_l for j in range(i + 1, n): sum_u = sum(L[i][k] * U[k][j] for k in range(i)) # Avoid division by zero L_diag = L[i][i] if L[i][i] != 0 else 1e-15 U[i][j] = (A[i][j] - sum_u) / L_diag return L, U"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Set Cover Problem (Optimization Problem) * **Complexity**: - **Optimal Algorithm**: Exponential time complexity of (O(2^n)), as it examines all subsets of the given subsets to find the minimum cost set covering the universe. - **Greedy Algorithm**: Polynomial time complexity that is much faster than the optimal algorithm, generally (O(n log n)), but not guaranteed to find the globally optimal solution. * **Principles**: - **Optimal Algorithm**: This algorithm generates all possible subsets (power set) of given subsets and determines the one with the smallest cost that covers the entire universe. - **Greedy Algorithm**: Selects subsets based on cost-effectiveness (cost per element covered) iteratively until the universe is fully covered. # Characteristics & Applications * **Properties**: - The optimal algorithm is precise but highly inefficient for large input sizes due to its exhaustive nature. - The greedy algorithm is efficient and scalable but may not always yield the optimal solution. * **Common Use Cases**: - Efficient resource allocation. - Network coverage optimization. - Database & document search engines. * **Strengths/Limitations**: - **Optimal Algorithm**: - **Strengths**: Guarantees the minimum cost solution. - **Limitations**: Exponential time complexity makes it impractical for large datasets. - **Greedy Algorithm**: - **Strengths**: Faster and suitable for larger input sizes. - **Limitations**: May not always result in the optimal solution. # Implementation Challenges * **Edge Cases**: - Subsets that have overlapping elements. - Universe elements that do not belong to any subset. - Subsets with zero cost. * **Performance Bottlenecks**: - Power set generation in the optimal algorithm can become infeasible with large inputs. - Greedy algorithm\'s set evaluation in dense subsets can lead to longer execution times. * **Error Scenarios**: - The universe not fully covered by the provided subsets. - Division by zero error in the greedy algorithm. * **Optimization Points**: - Using memoization for dynamic subset evaluations. - Parallel processing for set evaluations. <|Analysis End|> <|Question Begin|> # Problem Statement You are tasked with solving the set cover problem to support an optimization strategy for resource allocation. Given a universe of elements and a collection of subsets from this universe with associated costs, you need to implement and compare two algorithms—an optimal algorithm and a greedy approximation algorithm—to find the minimum cost set cover. # Requirements Implement the following two functions in Python: 1. `optimal_set_cover(universe: set, subsets: dict, costs: dict) -> set`: - **Input**: - `universe`: A set of elements that need to be covered. - `subsets`: A dictionary where the keys are subset names and the values are sets representing the elements contained in each subset. - `costs`: A dictionary where the keys are subset names matching those in `subsets` and the values are integers representing the cost of including that subset in the cover. - **Output**: Returns a set of subset names which represent the minimum cost cover of the universe. - **Constraints**: - Assume the universe has up to 20 elements for optimal algorithm. - Subsets might overlap. 2. `greedy_set_cover(universe: set, subsets: dict, costs: dict) -> set`: - **Input**: - `universe`: A set of elements that need to be covered. - `subsets`: A dictionary where the keys are subset names and the values are sets representing the elements contained in each subset. - `costs`: A dictionary where the keys are subset names matching those in `subsets` and the values are integers representing the cost of including that subset in the cover. - **Output**: Returns a set of subset names which represent the cover of the universe found using a greedy approach. - **Constraints**: - Subsets might overlap. # Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} opt_cover = optimal_set_cover(universe, subsets, costs) print(opt_cover) # Expected Output: {\'S3\', \'S2\'} print(sum(costs[s] for s in opt_cover)) # Expected Output: 13 greedy_cover = greedy_set_cover(universe, subsets, costs) print(greedy_cover) # Expected Output: {\'S3\', \'S2\'} print(sum(costs[s] for s in greedy_cover)) # Expected Output: 13 ``` # Notes - Make sure to handle any edge cases such as empty subsets or the universe not being entirely coverable. - Analyze and compare the results from both algorithms for different inputs in terms of cost and performance.","solution":"import itertools def optimal_set_cover(universe, subsets, costs): Find the minimum cost set cover using an optimal algorithm. best_cover = None min_cost = float(\'inf\') subset_list = list(subsets.keys()) # Generate all possible combinations of subsets for r in range(1, len(subset_list) + 1): for combination in itertools.combinations(subset_list, r): combined_cover = set() cost = 0 for subset in combination: combined_cover.update(subsets[subset]) cost += costs[subset] if combined_cover == universe and cost < min_cost: min_cost = cost best_cover = combination return set(best_cover) if best_cover is not None else set() def greedy_set_cover(universe, subsets, costs): Find a set cover using a greedy approximation algorithm. remaining_elements = set(universe) selected_subsets = set() while remaining_elements: best_subset = None best_cost = float(\'inf\') best_coverage = set() for subset, elements in subsets.items(): # Calculate cost-effectiveness coverage = elements & remaining_elements if coverage: cost_effectiveness = costs[subset] / len(coverage) if cost_effectiveness < best_cost: best_cost = cost_effectiveness best_subset = subset best_coverage = coverage if not best_subset: break selected_subsets.add(best_subset) remaining_elements -= best_coverage if remaining_elements: return set() return selected_subsets"},{"question":"# Custom Encoding and Decoding of Strings Objective Design encoding and decoding functions to serialize and deserialize a list of strings for transmission over a network. You must ensure that both functions handle edge cases and perform efficiently. Function Signature ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` Input and Output Formats * **encode Function:** * Input: A list of strings `strs` * Output: A single encoded string * **decode Function:** * Input: An encoded string `s` * Output: A list of original strings Constraints * Non-null input for both functions. * Strings may contain any visible ASCII character, but no non-printable characters or spaces. * The delimiter `:` used for encoding will not appear within the actual strings. Example ```python # Example 1: input_strs_1 = [\\"hello\\", \\"world\\", \\"python\\"] encoded_str_1 = encode(input_strs_1) print(encoded_str_1) # Expected: \\"5:hello5:world6:python\\" decoded_list_1 = decode(encoded_str_1) print(decoded_list_1) # Expected: [\\"hello\\", \\"world\\", \\"python\\"] # Example 2: input_strs_2 = [\\"data\\", \\"structures\\", \\"and\\", \\"algorithms\\"] encoded_str_2 = encode(input_strs_2) print(encoded_str_2) # Expected: \\"4:data10:structures3:and10:algorithms\\" decoded_list_2 = decode(encoded_str_2) print(decoded_list_2) # Expected: [\\"data\\", \\"structures\\", \\"and\\", \\"algorithms\\"] # Example 3: input_strs_3 = [] encoded_str_3 = encode(input_strs_3) print(encoded_str_3) # Expected: \\"\\" decoded_list_3 = decode(encoded_str_3) print(decoded_list_3) # Expected: [] ``` Performance Requirements * Time Complexity: O(n) for both `encode` and `decode`, where n is the total length of all the input strings combined. * Space Complexity: O(n) for the encoded or decoded data. # Notes * Ensure to handle edge cases, including empty lists and strings. * Assure the proper use of delimiters to avoid misinterpretation during parsing.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :param strs: List of strings :return: Encoded string return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> List[str]: Decodes a single string to a list of strings. :param s: Encoded string :return: List of original strings strs, i = [], 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length strs.append(s[j+1:i]) return strs"},{"question":"Suppose you are designing an algorithm for a simple search engine that needs to support adding dictionary words and allowing users to search for words. The search engine must support queries with wildcards (`.`), where each `.` can represent any letter. You are required to implement an efficient data structure that provides two main operations: 1. `add_word(word)` - Adds a word to the dictionary. 2. `search(word)` - Searches for a word, where `.` can match any letter. # Requirements 1. Design and implement a class `WordDictionary` that: - Has a constructor `__init__()` to initialize the data structure. - Method `add_word(word: str)` to add a word to the dictionary. - Method `search(word: str) -> bool` to search a word in the dictionary. 2. Method `search` should return `True` if the word (possibly containing wildcards) is in the dictionary and `False` otherwise. # Example ```python # Initialize the dictionary wordDictionary = WordDictionary() # Add words to the dictionary wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") # Search for words in the dictionary print(wordDictionary.search(\\"pad\\")) # Output: False print(wordDictionary.search(\\"bad\\")) # Output: True print(wordDictionary.search(\\".ad\\")) # Output: True print(wordDictionary.search(\\"b..\\")) # Output: True ``` # Constraints - Assume the inputs are ASCII letters (a-z) and are case-insensitive. - The input length is limited to 25 characters. - Each word can be considered distinct even if re-added. Write your class implementation in Python below: ```python class WordDictionary: def __init__(self): # Initialize your data structure here. pass def add_word(self, word: str): # Adds a word into the data structure. pass def search(self, word: str) -> bool: # Returns if the word is in the data structure. A word could contain the \'.\' character to represent any one letter. pass ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, 0, self.root) def _search_recursive(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True return False else: if char in node.children: return self._search_recursive(word, index + 1, node.children[char]) else: return False"},{"question":"You are given the definition for a graph as well as three different functions for cloning an undirected graph: `clone_graph1` (using BFS), `clone_graph2` (using iterative DFS), and `clone_graph` (using recursive DFS). Each node in the graph has a `label` and a list of `neighbors`. Your task is to implement a function to detect a cycle in an undirected graph. A cycle in a graph is a non-empty trail in which only the first and last vertices are equal. The function you need to implement is: # Function Signature ```python def detect_cycle(node: UndirectedGraphNode) -> bool: Given a starting node of an undirected graph, this function should detect if there is any cycle in the graph. :param node: UndirectedGraphNode - starting node of the graph :return: bool - True if there is a cycle, False otherwise ``` # Constraints - The graph is undirected. - Each node has a unique label. - The graph may be disconnected. - The input graph may contain self-loops and multiple edges between any pair of nodes. # Expected Input and Output - Input: - One node of the undirected graph (starting point). - Output: - A boolean value: `True` if there is a cycle in the graph, otherwise `False`. # Example Given the serialized graph `{0,1,2#1,2#2,2}`, the function should return `True` because the graph contains a cycle involving nodes 0, 1, and 2 as well as a self-loop on node 2. # Notes You may reuse parts of the provided graph traversal functions to help implement the cycle detection. Ensure your solution is efficient and robust against the constraints provided.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def detect_cycle(node: UndirectedGraphNode) -> bool: Given a starting node of an undirected graph, this function detects if there is any cycle in the graph. :param node: UndirectedGraphNode - starting node of the graph :return: bool - True if there is a cycle, False otherwise def dfs(current, parent): visited.add(current) for neighbor in current.neighbors: if neighbor not in visited: if dfs(neighbor, current): return True elif neighbor != parent: return True return False visited = set() return dfs(node, None)"},{"question":"# Array Rotation Question Scenario Given an array of integers, you are tasked with implementing a rotation algorithm that shifts the elements to the right by `k` steps. Various methods are used to achieve this, and some are more efficient than others in terms of time complexity and space usage. Function Signature ```python def rotate_array(array: List[int], k: int) -> List[int]: Rotate the given array to the right by k steps. :param array: List[int] - A list of integers to be rotated. :param k: int - The number of steps to rotate the list. :return: List[int] - The rotated list. ``` Input * `array` (List[int]): The list of integers, with constraints 0 <= len(array) <= 10^5. * `k` (int): Number of steps to rotate the list, 0 <= k <= 10^5. Output * The function should return a new list that contains the rotated elements. Constraints * Use O(n) time complexity and, if possible, O(1) additional space complexity. * Handle edge cases like empty input and `k` larger than the length of the array. * The solution should be in Python and efficiently handle the above constraints. Example ``` Example 1: Input: array = [1, 2, 3, 4, 5, 6, 7], k = 3 Output: [5, 6, 7, 1, 2, 3, 4] Example 2: Input: array = [1, 2, 3], k = 5 Output: [2, 3, 1] ``` Additional Notes * Describe any assumptions made during your implementation. * Provide comments to explain the logic, especially around critical sections. * Avoid using Python built-in functions that directly solve the problem (e.g., using slicing alone is not acceptable).","solution":"from typing import List def rotate_array(array: List[int], k: int) -> List[int]: Rotate the given array to the right by k steps. :param array: List[int] - A list of integers to be rotated. :param k: int - The number of steps to rotate the list. :return: List[int] - The rotated list. if not array: return array # Return the array as is if it\'s empty n = len(array) k = k % n # In case k is greater than the length of the array # Reverse the entire array array.reverse() # Reverse the first k elements array[:k] = reversed(array[:k]) # Reverse the remaining n-k elements array[k:] = reversed(array[k:]) return array"},{"question":"Problem: You are given a list of `N` vectors, each consisting of `M` elements (comparable to a matrix of size `N x M`). Your task is to compute the cosine similarity between every pair of vectors and store the results in an `N x N` matrix. Each element (i, j) in this matrix should represent the cosine similarity between the i-th and j-th vector from the provided list. # Input: - A list of `N` vectors, each containing `M` float numbers. # Output: - An `N x N` matrix (2D list) where each element [i][j] is the cosine similarity between vector `i` and vector `j`. # Constraints: - 2 ≤ N ≤ 100 (number of vectors) - 2 ≤ M ≤ 1000 (number of elements in each vector) - Inputs are valid numerical values. # Example: ```python vectors = [ [1, 0, 0], [0, 1, 0], [1, 1, 0] ] # Expected Output: # [ # [1.0, 0.0, 0.7071], # [0.0, 1.0, 0.7071], # [0.7071, 0.7071, 1.0] # ] ``` # Note: - Ensure your solution scales efficiently with the given constraints. - You may reuse the provided snippet of the `cosine_similarity` function, ensuring to handle edge cases appropriately. Write a function `cosine_similarity_matrix(vectors)` that implements the above logic.","solution":"import math def cosine_similarity(u, v): Computes the cosine similarity between two vectors u and v. dot_product = sum(ui * vi for ui, vi in zip(u, v)) magnitude_u = math.sqrt(sum(ui**2 for ui in u)) magnitude_v = math.sqrt(sum(vi**2 for vi in v)) if magnitude_u == 0 or magnitude_v == 0: return 0.0 return dot_product / (magnitude_u * magnitude_v) def cosine_similarity_matrix(vectors): Computes the cosine similarity matrix for given list of vectors. n = len(vectors) similarity_matrix = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i, n): similarity = cosine_similarity(vectors[i], vectors[j]) similarity_matrix[i][j] = similarity similarity_matrix[j][i] = similarity return similarity_matrix"},{"question":"# Problem Background You are given an integer and asked to flip exactly one bit from 0 to 1 in its binary representation. Your task is to determine the length of the longest sequence of 1s that can be obtained by performing this operation. This problem focuses on understanding bitwise operations and sequences within the binary format of an integer. # Task Write a function `find_longest_sequence_after_flip(num: int) -> int` that takes a single integer `num` as input and returns the length of the longest sequence of consecutive 1s that can be obtained by flipping exactly one bit from 0 to 1. # Input and Output * **Input**: A single integer `num`. * **Output**: An integer representing the length of the longest sequence of consecutive 1s obtainable. # Constraints * The input number `num` is a positive integer. * The function should be efficient, ideally with a time complexity of O(b), where b is the number of bits in the binary representation of `num`. # Example ```python print(find_longest_sequence_after_flip(1775)) # Output: 8 (binary representation: 11011101111, flipping one 0 can maximize to 11011111111) print(find_longest_sequence_after_flip(15)) # Output: 5 (binary representation: 1111, flipping the zero at the boundary results in 11111) ``` # Notes * Consider special cases where the entire binary representation consists of either all 1s or all 0s. * Think about how the bitwise operations can be utilized efficiently to traverse and manipulate the bits.","solution":"def find_longest_sequence_after_flip(num: int) -> int: This function finds the length of the longest sequence of 1s in the binary representation of a given number after flipping exactly one bit from 0 to 1. :param num: integer number :return: length of the longest sequence of 1s obtainable after a single bit flip # Convert number to binary string and remove the \'0b\' prefix bin_str = bin(num)[2:] if \'0\' not in bin_str: # If there is no \'0\' in binary representation, the whole binary string is 1s return len(bin_str) + 1 # List to hold lengths of sequences segments = [] # Split the binary string by \'0\'s to find segments of \'1\'s ones_segments = bin_str.split(\'0\') for segment in ones_segments: # Append the length of each segment of 1s segments.append(len(segment)) # Find possible maximum length of 1s sequence by merging around one \'0\' max_length = 0 for i in range(len(segments) - 1): # Current max length is the sum of current and next segments plus 1 max_length = max(max_length, segments[i] + segments[i+1] + 1) return max_length"},{"question":"# Pathfinding in a Directed Graph Given a directed graph represented as an adjacency list, implement a function to efficiently find the shortest path from a given start node to an end node. If there is no path, return None. Your implementation needs to handle graphs with cycles and disconnected graphs. The graph can be represented as a dictionary where the keys are the nodes and the values are lists of neighboring nodes. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start = \'A\' end = \'F\' ``` For the above graph, the shortest path from \'A\' to \'F\' is `[\'A\', \'C\', \'F\']`. Function Signature ```python def find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: ``` Requirements * **Input**: - `graph`: Dict[str, List[str]] - The graph as an adjacency list. - `start`: str - The starting node. - `end`: str - The target node. * **Output**: Optional[List[str]] - A list of nodes representing the shortest path, or `None` if no path exists. Constraints * Assume all node names are unique strings. * There will be at most (10^4) nodes in the graph. * The function should aim to be efficient both in terms of time and space complexity. Example Usage ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } print(find_shortest_path(graph, \'A\', \'F\')) # [\'A\', \'C\', \'F\'] print(find_shortest_path(graph, \'A\', \'E\')) # [\'A\', \'B\', \'E\'] print(find_shortest_path(graph, \'A\', \'D\')) # [\'A\', \'B\', \'D\'] print(find_shortest_path(graph, \'D\', \'A\')) # None ``` Implementation Notes: - Consider using a Breadth-First Search (BFS) instead of a Depth-First Search (DFS) for efficiency. - Ensure you handle cyclic graphs appropriately to avoid infinite loops. - Validate inputs and handle cases where either the start or end node does not exist in the graph.","solution":"from typing import Dict, List, Optional from collections import deque def find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: new_path = list(path) new_path.append(neighbor) queue.append((neighbor, new_path)) return None"},{"question":"You are provided with two implementations of the Stack Abstract Data Type (ADT): `ArrayStack` using a static array, and `LinkedListStack` using a linked list. Your task is to implement a new class called `MinStack` that extends the `ArrayStack`. This `MinStack` should be able to support all basic stack operations (`push`, `pop`, `peek`, `is_empty`) and additionally provide a method `get_min` that returns the minimum element in the stack in constant time O(1). # Requirements: 1. Implement the class `MinStack` extending `ArrayStack`. 2. Implement the `get_min` method which returns the minimum element in the stack. 3. Ensure that your implementation handles all edge cases appropriately. 4. Ensure efficient runtime complexity for all operations. # Constraints: 1. The stack can contain up to 10^6 elements. 2. The values in the stack are all integers within the range [-10^9, 10^9]. # Function Signatures: ```python class MinStack(ArrayStack): def __init__(self, size=10): super().__init__(size) def push(self, value): Override the push method to support minimum element tracking. # Your implementation here def pop(self): Override the pop method to support minimum element tracking. # Your implementation here def get_min(self): Return the minimum element in the stack. # Your implementation here ``` # Example: ```python min_stack = MinStack() min_stack.push(5) min_stack.push(3) min_stack.push(7) print(min_stack.get_min()) # Should output 3 min_stack.pop() print(min_stack.get_min()) # Should output 3 min_stack.pop() print(min_stack.get_min()) # Should output 5 ``` # Explanation: - Use an auxiliary stack to keep track of the minimal elements alongside the main stack operations. - Ensure the auxiliary stack is updated correctly during `push` and `pop` operations to maintain efficient `get_min` operations.","solution":"class ArrayStack: def __init__(self, size=10): self.array = [None] * size self.top = -1 self.size = size def push(self, value): if self.top >= self.size - 1: raise OverflowError(\\"Stack overflow\\") self.top += 1 self.array[self.top] = value def pop(self): if self.top == -1: raise IndexError(\\"Stack underflow\\") value = self.array[self.top] self.array[self.top] = None self.top -= 1 return value def peek(self): if self.top == -1: raise IndexError(\\"Stack is empty\\") return self.array[self.top] def is_empty(self): return self.top == -1 class MinStack(ArrayStack): def __init__(self, size=10): super().__init__(size) self.min_stack = ArrayStack(size) def push(self, value): super().push(value) if self.min_stack.is_empty() or value <= self.min_stack.peek(): self.min_stack.push(value) else: self.min_stack.push(self.min_stack.peek()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack underflow\\") self.min_stack.pop() return super().pop() def get_min(self): if self.min_stack.is_empty(): raise IndexError(\\"Stack is empty\\") return self.min_stack.peek()"},{"question":"# Context A library search function needs optimizing. Users commonly search for a list of keywords within large texts such as books and articles. Using an efficient pattern matching algorithm can significantly reduce search times and improve user satisfaction. # Problem Statement You are required to implement an optimized search function that, given a text and multiple search keywords (patterns), returns a dictionary where keys are the patterns and values are lists of starting indices in the text where patterns appear. # Function Signature ```python def search_patterns(text: str, patterns: List[str]) -> Dict[str, List[int]]: Given a text and a list of patterns, return a dictionary with patterns as keys and lists of starting indices where patterns appear in the text. Args: text (str): The text to search within patterns (List[str]): A list of patterns to search in the text Returns: Dict[str, List[int]]: A dictionary where each pattern maps to a list of starting indices in the text Example: >>> search_patterns(\'the quick brown fox jumps over the lazy dog\', [\'the\', \'fox\']) {\'the\': [0, 31], \'fox\': [16]} pass ``` # Constraints - The function must handle both small and large texts (up to 10^5 characters). - The list of patterns can have up to 100 patterns, each up to 100 characters long. - You must use the Knuth-Morris-Pratt (KMP) algorithm to perform pattern matching. - Your implementation should keep space and time complexity as efficient as possible.","solution":"from typing import List, Dict def compute_kmp_table(pattern: str) -> List[int]: This function computes the partial match table (also known as the \\"next\\" table or \\"failure function\\") used in KMP algorithm. m = len(pattern) kmp_table = [0] * m length = 0 # length of the previous longest prefix suffix i = 1 # the loop calculates kmp_table[i] for i = 1 to m-1 while i < m: if pattern[i] == pattern[length]: length += 1 kmp_table[i] = length i += 1 else: if length != 0: # this is tricky. Consider the example AAACAAAA and i = 7. length = kmp_table[length-1] else: kmp_table[i] = 0 i += 1 return kmp_table def kmp_search(text: str, pattern: str) -> List[int]: KMP algorithm for pattern searching in text. Returns the starting indices where the pattern is found. n = len(text) m = len(pattern) kmp_table = compute_kmp_table(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = kmp_table[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = kmp_table[j - 1] else: i += 1 return result def search_patterns(text: str, patterns: List[str]) -> Dict[str, List[int]]: result = {} for pattern in patterns: result[pattern] = kmp_search(text, pattern) return result"},{"question":"You are tasked with writing a function that efficiently determines whether a number has a primitive root and, if so, returns one such primitive root. The primary goal is to assess your understanding of Euler\'s Totient Function and the concept of order in modular arithmetic. Requirements: - **Function Name**: `find_one_primitive_root` - **Input**: - `n` (int): A positive integer. - **Output**: - An integer representing one primitive root of `n` if it exists, or `-1` if no primitive root is found. - **Constraints**: - The function should optimize for performance and handle `n` up to 10^6 efficiently. - Handle edge cases where `n` is 1 separately and ensure appropriate checks for determining the relative primality of integers. Function Signature: ```python def find_one_primitive_root(n: int) -> int: pass ``` Example: ```python # Example 1 n = 7 print(find_one_primitive_root(7)) # Output: 3 (Note: 3 is one of the primitive roots of 7) # Example 2 n = 10 print(find_one_primitive_root(10)) # Output: -1 (Primitive root does not exist for 10) # Example 3 n = 1 print(find_one_primitive_root(1)) # Output: 0 ``` Evaluation: 1. **Correctness**: Does the function return correct results for various values of `n`? 2. **Performance**: Does the function handle large inputs efficiently? 3. **Edge Cases**: Does the function adequately handle edge cases such as `n = 1`? This problem requires a depth of understanding of number theory and modular arithmetic to not only apply the provided algorithms but also optimize them for performance.","solution":"def find_one_primitive_root(n: int) -> int: if n == 1: return 0 # Function to check if a number is prime def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True # Function to calculate Euler\'s Totient Function def euler_totient(n): result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result # Function to compute gcd def gcd(a, b): while b: a, b = b, a % b return a # Function to get all prime factors of a given number def get_prime_factors(n): factors = set() while n % 2 == 0: factors.add(2) n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.add(i) n //= i if n > 2: factors.add(n) return factors if not is_prime(n): return -1 phi_n = euler_totient(n) prime_factors = get_prime_factors(phi_n) for r in range(2, n): if all(pow(r, phi_n // pf, n) != 1 for pf in prime_factors): return r return -1"},{"question":"# ZigZag Iterator Extension You have been provided with a ZigZag Iterator that alternates between two lists. Your task is to extend this implementation to handle an arbitrary number of input lists. The Zigzag order should continue until all elements in all lists are exhausted. Function Signature ```python class ZigZagIterator: def __init__(self, *args): Initialize the iterator with any number of input lists. :param args: Each argument is a list of integers. pass def next(self): :return: The next element in zigzag order. :rtype: int pass def has_next(self): :return: True if there are more elements to iterate through, False otherwise. :rtype: bool pass ``` Input - The constructor will take any number of lists, containing integers. - `next()` will return the next element in the sequence. - `has_next()` will return boolean indicating if there are more elements to process. Output - `next()`: Returns the next integer in the zigzag order. - `has_next()`: Boolean (`True` or `False`). Constraints - The number of input lists is between 1 and 1000. - Each list\'s length is between 0 and 1000. Example ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7, 8] l3 = [9, 10] iterator = ZigZagIterator(l1, l2, l3) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) ``` **Expected Output**: `[1, 4, 9, 2, 5, 10, 3, 6, 7, 8]` Requirements 1. The implementation should work for an arbitrary number of lists (not just two). 2. Ensure efficient handling of edge cases such as empty lists or input lists of different lengths. 3. Optimize for performance in terms of time and space.","solution":"from collections import deque class ZigZagIterator: def __init__(self, *args): Initialize the iterator with any number of input lists. :param args: Each argument is a list of integers. # Deque of iterators self.queue = deque([iter(lst) for lst in args if lst]) def next(self): :return: The next element in zigzag order. :rtype: int if self.has_next(): current_iter = self.queue.popleft() next_value = next(current_iter, None) if next_value is not None: self.queue.append(current_iter) return next_value raise StopIteration(\\"No more elements\\") def has_next(self): :return: True if there are more elements to iterate through, False otherwise. :rtype: bool while self.queue: current_iter = self.queue[0] try: peek = next(current_iter) self.queue.popleft() # remove iter self.queue.appendleft(iter([peek] + list(current_iter))) # reinsert iter with peek at front return True except StopIteration: self.queue.popleft() return False"},{"question":"# Question: Optimal Building Placement on Grid **Context**: You are tasked with urban planning for a new city grid. Given a 2D grid where each element denotes: - `0`: an empty lot where you can build a facility. - `1`: an existing building. - `2`: an obstacle that prevents passage. Your goal is to place a new facility (like a park or community center) such that the total distance to all existing buildings is minimized. **Function Signature**: Write a function `findOptimalFacilityPlacement(grid: List[List[int]]) -> int` that takes a grid and returns the minimum distance sum from a new facility placed on an empty lot to all existing buildings. If it\'s impossible to place a facility, return `-1`. # Input - `grid`: a list of lists of integers where `grid[i][j]` can be `0`, `1`, or `2`. - **Constraints**: - Size of the grid: `1 <= len(grid), len(grid[0]) <= 50` - Except for the values `0`, `1`, `2`, there are no other values in the grid. # Output - An integer representing the minimum sum of distances from the facility to all buildings, or `-1` if no valid placement is possible. # Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert findOptimalFacilityPlacement(grid) == 7 grid = [ [1, 0], [0, 1] ] assert findOptimalFacilityPlacement(grid) == 2 grid = [ [1, 2, 0], [2, 2, 2], [0, 2, 1] ] assert findOptimalFacilityPlacement(grid) == -1 ``` **Explanation of Examples**: 1. In the first example, placing the facility at the middle bottom row (2,2) leads to distance sum `1+2+4=7`. 2. In the second example, optimal placement at any empty cell results in equal distance sum of 2. 3. In the third example, no empty cell is reachable by both buildings due to obstacles. Provide a clear, well-commented solution that adheres to the specified constraints. Ensure the solution efficiently handles the grid traversal and distance computations using BFS.","solution":"from collections import deque from typing import List def findOptimalFacilityPlacement(grid: List[List[int]]) -> int: directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] rows, cols = len(grid), len(grid[0]) def bfs(start_i, start_j): visited = [[False] * cols for _ in range(rows)] distance_map = [[0] * cols for _ in range(rows)] queue = deque([(start_i, start_j, 0)]) visited[start_i][start_j] = True while queue: x, y, dist = queue.popleft() distance_map[x][y] = dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] != 2: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return distance_map buildings = [(i, j) for i in range(rows) for j in range(cols) if grid[i][j] == 1] if not buildings: return -1 total_distance = [[0] * cols for _ in range(rows)] reachable_count = [[0] * cols for _ in range(rows)] for bi, bj in buildings: distance_map = bfs(bi, bj) for i in range(rows): for j in range(cols): if grid[i][j] == 0 and distance_map[i][j] != 0: total_distance[i][j] += distance_map[i][j] reachable_count[i][j] += 1 min_distance = float(\'inf\') for i in range(rows): for j in range(cols): if grid[i][j] == 0 and reachable_count[i][j] == len(buildings): min_distance = min(min_distance, total_distance[i][j]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"Question: Word Pattern Mapping # Context Given two sequences: a pattern and a string (a sequence of words), you need to determine if there is a bijection between the characters in the pattern and the words in the string. For example, a character in the pattern should correspond to exactly one word in the string and vice versa. # Problem Statement Implement a function `word_pattern` to determine if the given pattern matches the given string. # Function Signature ```python def word_pattern(pattern: str, str: str) -> bool: pass ``` # Input - **pattern**: A string containing only lowercase letters. - **str**: A string containing lowercase letters separated by a single space. # Output - **bool**: Return `True` if `str` follows the same pattern as `pattern`. Otherwise, return `False`. # Constraints - Pattern and string lengths are not guaranteed to match. - You may assume the input strings are non-empty. # Examples ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == True assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Notes This problem evaluates your ability to: - Use dictionaries and sets to establish constraints. - Handle edge cases by pre-checking pattern and string lengths. - Optimize basic operations within a linear time complexity framework. The solution should handle patterns where characters in the pattern correspond to non-repeating words in the string, ensuring both the dictionary and set reflect a valid bijection relationship.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# Deepest Left Child Node Finder Given the following class definition for a binary tree node: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Problem: Write a function `find_deepest_left_node(root: TreeNode) -> int` that takes the root of a binary tree and returns the value of the deepest node that is the left child of its parent. If no such node exists, return -1. # Guidelines: * You must implement the function using a depth-first search (DFS) traversal strategy. * Ensure to consider edge cases such as: * The tree has only one node. * The tree is completely left-heavy or right-heavy. * Do not assume any specific tree structure other than the one provided. # Expected Input and Output * **Input**: `root` (the root node of the binary tree) * **Output**: Integer value of the deepest left child node, or -1 if no such node exists. # Examples *Example 1*: ```plaintext Input: 1 / 2 3 / 4 5 6 7 Output: 4 ``` *Example 2*: ```plaintext Input: 1 / 2 3 6 / 7 8 Output: 7 ``` # Constraints: * The tree contains at most 10^4 nodes. * Node values will be unique. * Tree node classes will be provided and should be used as is. # Implementation: You can use the provided Python code as a reference to understand the initial approach. However, re-implement the solution without referencing the given code snippet.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_deepest_left_node(root: TreeNode) -> int: if not root: return -1 stack = [(root, False, 0)] # (node, is_left, depth) deepest_left_val = -1 deepest_depth = -1 while stack: node, is_left, depth = stack.pop() if node: if is_left and (depth > deepest_depth): deepest_left_val = node.value deepest_depth = depth stack.append((node.right, False, depth + 1)) stack.append((node.left, True, depth + 1)) return deepest_left_val"},{"question":"# Problem Scenario You are developing a system to validate sequences of commands sent to a robot in a factory. Each command sequence needs to be verified against a deterministic set of rules encoded in a deterministic finite automaton (DFA). The robot can only start processing sequences from a defined start state and considers a sequence valid only if it ends up in one of its final states after processing all commands. Your task is to implement a function to perform this validation. # Coding Task Write a Python function `validate_command_sequence(transitions, start, final, sequence)` that verifies if a given sequence of commands is accepted by a DFA. # Function Signature ```python def validate_command_sequence(transitions: dict, start: int, final: list, sequence: str) -> bool: pass ``` # Input - `transitions` (dict): A dictionary representing the state transitions. The keys are state identifiers, and the values are dictionaries mapping input symbols to the next state. - `start` (int): The initial state of the DFA. - `final` (list of int): A list of final (accepting) states. - `sequence` (str): The command sequence to be validated. # Output - Returns `True` if the sequence is accepted by the DFA. - Returns `False` otherwise. # Constraints 1. The `transitions` dictionary will only contain valid state transitions. 2. The sequence will only contain symbols that are defined within the `transitions` dictionary. 3. States and symbols are strictly non-negative integers. # Example ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 2, \'b\': 2} } start = 0 final = [2] sequence = \\"abba\\" assert validate_command_sequence(transitions, start, final, sequence) == True ```","solution":"def validate_command_sequence(transitions: dict, start: int, final: list, sequence: str) -> bool: current_state = start for command in sequence: if command not in transitions[current_state]: return False current_state = transitions[current_state][command] return current_state in final"},{"question":"Scenario You are tasked with implementing an extension of the provided function to handle a more complex case involving circular linked lists. In a circular linked list, the next pointer of the last node points back to the first node. You need to determine if the circular linked list is sorted in non-decreasing order. Problem Statement Write a function `is_circular_sorted(head)` that determines if a given circular linked list is sorted in non-decreasing order. An empty list or a list with a single node should be considered sorted. # Function Signature ```python def is_circular_sorted(head) -> bool: # Your code here ``` # Input and Output Formats * **Input**: * `head` - The head node of the circular linked list. * **Output**: * Returns `True` if the list is sorted in non-decreasing order, or `False` otherwise. # Constraints * The function must handle lists with potentially millions of nodes efficiently. * The linked list is circular; the last node\'s next pointer points back to the first node. * You may assume the list nodes contain integer values. # Examples ```python # Example 1: # Linked List: 1 -> 2 -> 3 -> 4 (circular) # Expected Output: True assert is_circular_sorted(node1) == True # Example 2: # Linked List: 4 -> 1 -> 2 -> 3 (circular) # Expected Output: True assert is_circular_sorted(node4) == True # Example 3: # Linked List: 2 -> 1 -> 3 -> 4 (circular) # Expected Output: False assert is_circular_sorted(node2) == False ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_circular_sorted(head) -> bool: if not head or head.next == head: return True curr = head while curr.next != head: if curr.val > curr.next.val: break curr = curr.next start = curr.next curr = start while curr.next != start: if curr.val > curr.next.val: return False curr = curr.next return True"},{"question":"# Matrix Transformation Challenge Context You are working on an image manipulation software where matrix transformations are a key functionality. The software involves various operations to adjust the orientation and position of pixel data represented as 2D matrices. Task Write functions to apply the following transformations to a given 2D matrix (list of lists): 1. **rotate_clockwise**: Rotates the matrix 90 degrees clockwise. 2. **rotate_counterclockwise**: Rotates the matrix 90 degrees counterclockwise. 3. **top_left_invert**: Vertically inverts the matrix while keeping the top left elements in place. 4. **bottom_left_invert**: Vertically and horizontally inverts the matrix while keeping the bottom left elements in place. Requirements - **Input**: A 2D matrix `matrix` represented as a list of lists. - **Output**: A new 2D matrix that has undergone the specified transformation. Constraints - The matrix will always have non-negative dimensions. - The elements of the matrix will be integers. Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` Example Given the following initial matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` # Expected Output: - `rotate_clockwise(matrix)`: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` - `rotate_counterclockwise(matrix)`: ```python [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` - `top_left_invert(matrix)`: ```python [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` *(Note: This function keeps it same since top-left inversion is based on column mirroring)* - `bottom_left_invert(matrix)`: ```python [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` Implement the required transformations based on the described criteria.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. return [list(reversed(col)) for col in zip(*matrix)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees counterclockwise. return list(reversed([list(col) for col in zip(*matrix)])) def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Vertically inverts the matrix while keeping the top left elements in place. return [list(reversed(row)) for row in matrix] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Vertically and horizontally inverts the matrix while keeping the bottom left elements in place. return [list(reversed(row)) for row in reversed(matrix)]"},{"question":"You are given a task to implement the classic FizzBuzz algorithm with additional twists to challenge your understanding of loops and conditionals. # Task Description Write a function `fizzbuzz_with_twist(n: int, a: int, b: int) -> List[Union[str, int]]` that returns a list containing numbers from 1 to `n` with the following modifications: 1. For multiples of `a`, replace the number with \\"Fizz\\". 2. For multiples of `b`, replace the number with \\"Buzz\\". 3. For multiples of both `a` and `b`, replace the number with \\"FizzBuzz\\". 4. If a number is not a multiple of either `a` or `b`, retain the number as is. # Input * An integer `n` (1 ≤ n ≤ 10^5) * An integer `a` (1 ≤ a ≤ n) * An integer `b` (1 ≤ b ≤ n) # Output The function should return a list of length `n` with the modified values as specified. # Constraints * `1 ≤ n ≤ 100000` * `1 ≤ a, b ≤ n` * The function should handle inputs efficiently to avoid timeouts. # Example ```python >>> fizzbuzz_with_twist(15, 3, 5) [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] >>> fizzbuzz_with_twist(10, 2, 3) [1, \'Fizz\', \'Buzz\', \'Fizz\', 5, \'FizzBuzz\', 7, \'Fizz\', \'Buzz\', \'Fizz\'] ``` # Notes * Ensure your solution is efficient for large values of `n`. * Remember to handle input validation and edge cases properly.","solution":"from typing import List, Union def fizzbuzz_with_twist(n: int, a: int, b: int) -> List[Union[str, int]]: result = [] for i in range(1, n + 1): if i % a == 0 and i % b == 0: result.append(\\"FizzBuzz\\") elif i % a == 0: result.append(\\"Fizz\\") elif i % b == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"You are required to implement a function that computes the transitive closure of a directed graph using Depth-First Search (DFS). The transitive closure of a graph is a reachability matrix where each entry (i, j) is True if there is a path from node i to node j (including itself), and False otherwise. # Function Signature ```python def transitive_closure(num_nodes: int, edges: List[Tuple[int, int]]) -> List[List[bool]]: pass ``` # Input - `num_nodes`: An integer representing the number of vertices in the graph. - `edges`: A list of tuples where each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. # Output - The function should return a 2D list (matrix) of size `num_nodes x num_nodes` where the cell at row i and column j should be `True` if there is a path from vertex `i` to vertex `j`, and `False` otherwise. # Example ```python num_nodes = 4 edges = [(0, 1), (1, 2), (2, 3)] result = transitive_closure(num_nodes, edges) # Expected Output: # [ # [True, True, True, True], # [False, True, True, True], # [False, False, True, True], # [False, False, False, True] # ] ``` # Constraints - All vertex indices will be between `0` to `num_nodes-1`. - The graph may contain self-loops and/or multiple edges. # Notes - You need to ensure that each node is reachable from itself reflecting the path from a node to itself. - Efficient implementation of graph traversal and matrix management is crucial to avoid performance bottlenecks. # Requirements - Implement the function using Depth-First Search (DFS). - Avoid any in-place modifications on the edges list to ensure the original graph structure remains intact.","solution":"from typing import List, Tuple def dfs(node: int, graph: List[List[int]], reachable: List[List[bool]], visited: List[bool], start: int): Perform DFS to mark all reachable nodes from the starting node. reachable[start][node] = True visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, graph, reachable, visited, start) def transitive_closure(num_nodes: int, edges: List[Tuple[int, int]]) -> List[List[bool]]: Computes the transitive closure of a directed graph using DFS. :param num_nodes: Number of vertices in the graph. :param edges: List of directed edges in the graph. :return: 2D list representing the reachability matrix. # Initialize adjacency list for the graph graph = [[] for _ in range(num_nodes)] for u, v in edges: graph[u].append(v) # Initialize reachability and visited matrices reachable = [[False] * num_nodes for _ in range(num_nodes)] # Compute reachability using DFS for node in range(num_nodes): visited = [False] * num_nodes dfs(node, graph, reachable, visited, node) return reachable"},{"question":"# Problem: Implementation of a Safe Bogo Sort Bogo Sort is a highly impractical sorting algorithm due to its reliance on sheer luck to sort the array. Your task is to write a function that partially utilizes Bogo Sort principles but safely handles large datasets by allowing a maximum number of iterations. If the sorting does not succeed within the given iteration limit, the function should return the partially sorted array. Requirements: - **Function Name**: `safe_bogo_sort` - **Inputs**: - `arr`: A list of integers that needs to be sorted. - `max_iterations`: An integer representing the maximum number of iterations before the function terminates the attempt and returns the partially sorted array. - `simulation` (optional): A boolean to indicate if intermediate states should be printed for simulation purposes (default is `False`). - **Outputs**: - A list of integers representing the (potentially partially) sorted array. Constraints: - The function should handle arrays with lengths ranging from 0 to 1000 elements. - The maximum number of iterations will be given as a non-negative integer, up to 1,000,000. Example Usage: ```python result = safe_bogo_sort([3, 2, 5, 4, 1], 100) print(result) # Might be [1, 2, 3, 4, 5] or a partially sorted version depending on `max_iterations` ``` Parameters: - `arr`: The input array that needs sorting. - `max_iterations`: The upper limit on the number of shuffling attempts. - `simulation`: If `True`, print the state of the array after each shuffle attempt. **Note**: Ensure your code optimally handles the iteration limit and doesn\'t run indefinitely.","solution":"import random def is_sorted(arr): Helper function to check if an array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def safe_bogo_sort(arr, max_iterations, simulation=False): Partially utilizes Bogo Sort principles but safely handles large datasets by allowing a maximum number of iterations. If sorting does not succeed within the given iteration limit, it returns the partially sorted array. Args: - arr (list): A list of integers that needs to be sorted. - max_iterations (int): Maximum number of iterations. - simulation (bool): Optional; if True, prints intermediate states. Returns: - list: A (potentially partially) sorted array. for iteration in range(max_iterations): if is_sorted(arr): return arr random.shuffle(arr) if simulation: print(f\\"Iteration {iteration + 1}: {arr}\\") return arr"},{"question":"# Context You are developing a transportation network that requires ensuring maximum throughput from a starting point to a destination. By interpreting the capacity limits between multiple transportation hubs (nodes) represented by an adjacency matrix, your task is to calculate the maximum flow from the source node to the sink node. **Function Specification:** Implement a function `calculate_maximum_flow(adjacency_matrix: List[List[int]]) -> int`: - **Input**: A n x n adjacency matrix, where `n` represents the number of nodes. The element at `matrix[i][j]` represents the capacity of the edge from node `i` to node `j`. The first node is always the source, and the last node is always the sink. - **Output**: An integer value representing the maximum flow from the source to the sink. # Constraints - The matrix will be a square matrix with dimensions (2 leq n leq 50). - All capacities are non-negative integers. # Example ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] print(calculate_maximum_flow(graph)) # Output: 23 ``` # Notes - You need to handle edge cases such as no connection from source to sink efficiently. - Consider duplicate paths with different flows and ensure the residual capacities are updated correctly.","solution":"from typing import List def bfs(residual_graph: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(residual_graph) queue = [source] visited[source] = True while queue: u = queue.pop(0) for ind, val in enumerate(residual_graph[u]): if visited[ind] == False and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def calculate_maximum_flow(adjacency_matrix: List[List[int]]) -> int: source = 0 sink = len(adjacency_matrix) - 1 parent = [-1] * len(adjacency_matrix) max_flow = 0 residual_graph = [row[:] for row in adjacency_matrix] while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"Linear Search Optimization You are tasked with optimizing a search algorithm for a large dataset, but for this problem, we will focus on a fundamental search method. Given an unsorted array of integers, implement a function that attempts to find an integer, but with added constraints to simulate a realistic scenario: **Scenario Context**: You are working for a ticketing system where customers often inquire about their ticket numbers. To handle frequent spikes in queries, you want to introduce a more efficient way to search when certain high-priority tickets (VIP tickets) often get sought after. **Function Requirements**: 1. Implement the function `optimized_linear_search` that handles both general and VIP ticket search. 2. The array will contain a mix of general and VIP ticket numbers. VIP tickets are identified as having a special prefix or a specific range of numbers (e.g., all numbers greater than 1000). **Input/Output Format**: - Input: `optimized_linear_search(array, query, vip_prefix)` where: - `array` is a list of integers representing ticket numbers. - `query` is the integer ticket number to search for. - `vip_prefix` is a function that takes an integer and returns `True` if it\'s a VIP ticket, and `False` otherwise. - Output: Return the index of the ticket in the array if found, or -1 if not found. **Constraints and Notes**: - VIP ticket numbers should be checked first to optimize for common inquiries. - The function should still handle all edge cases, such as empty arrays and queries not found in the list. - The search must maintain O(n) time complexity. ```python def optimized_linear_search(array, query, vip_prefix): Searches for the query ticket number in the array. VIP tickets should be checked first to optimize for common inquiries. Parameters: - array: list of integers - query: integer to find - vip_prefix: function that returns True for VIP tickets Returns: - int: index of the ticket number in the array, or -1 if not found # Write your code here # Examples: # vip_prefix = lambda x: x > 1000 # optimized_linear_search([1200, 100, 200, 3000, 50], 3000, vip_prefix) should return 3 # optimized_linear_search([1200, 100, 200, 3000, 50], 50, vip_prefix) should return 4 # optimized_linear_search([1200, 100, 200, 3000, 50], 1000, vip_prefix) should return -1 ``` **Performance Requirements**: Maintaining O(n) complexity while ensuring VIP tickets are optimized in search order. Make sure to include test cases to verify your function with various inputs, including those that test edge cases.","solution":"def optimized_linear_search(array, query, vip_prefix): Searches for the query ticket number in the array. VIP tickets should be checked first to optimize for common inquiries. Parameters: - array: list of integers - query: integer to find - vip_prefix: function that returns True for VIP tickets Returns: - int: index of the ticket number in the array, or -1 if not found # Search for query among VIP tickets first for index, ticket in enumerate(array): if vip_prefix(ticket) and ticket == query: return index # Search for query among non-VIP tickets next for index, ticket in enumerate(array): if not vip_prefix(ticket) and ticket == query: return index # Return -1 if the ticket is not found return -1"},{"question":"# Three Sum to Zero: Unique Triplets Problem Statement Given an array `S` of `n` integers, are there three distinct elements `a`, `b`, `c` in `S` such that `a + b + c = 0`? Write a function to find all unique triplets in the array which gives the sum of zero. Function Signature ```python def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: ``` Input * `array`: A list of integers `S` where `|S| <= 10^3`. Output * A set of tuples, where each tuple contains three integers which sum up to zero and are ordered in ascending order within the tuple. Constraints * The solution set must not contain duplicate triplets. * Optimize to avoid checking the same triplet more than once. Example ```python # Example 1 S = [-1, 0, 1, 2, -1, -4] assert three_sum(S) == {(-1, 0, 1), (-1, -1, 2)} # Example 2 S = [0, 0, 0] assert three_sum(S) == {(0, 0, 0)} ``` Requirements 1. Implement the `three_sum` function. 2. Ensure the code passes edge cases and handles large input sizes efficiently. **Scenario/Context:** Imagine you are working at a financial institution that analyzes transactional data. One such analysis involves identifying sets of three transactions that net zero balance, crucial for fraud detection mechanisms. You are tasked with implementing this efficient triplet finder to enhance the institution\'s fraud detection capability.","solution":"from typing import List, Set, Tuple def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: array.sort() result = set() for i in range(len(array) - 2): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, len(array) - 1 while left < right: total = array[i] + array[left] + array[right] if total == 0: result.add((array[i], array[left], array[right])) while left < right and array[left] == array[left + 1]: left += 1 while left < right and array[right] == array[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"# Union-Find Implementation in Grid Problem You are provided with a `Union` class (Union-Find data structure) which supports the functionality to add elements, find the root (representative) of a set, and unite (merge) two sets. Problem Statement: Write a function `num_islands(positions)` that operates on a grid to add land blocks at specified positions and returns the number of islands after each operation. An island is a group of \'land\' cells connected horizontally or vertically. Initially, the entire grid is filled with water. Input: A list of tuples representing positions where land should be added. Each position is a tuple of two integers `(x, y)`, representing the coordinates in the grid. e.g., ``` positions = [(0, 0), (0, 1), (1, 2), (2, 1)] ``` Output: A list of integers where the ith integer is the number of islands after the ith operation. e.g., ``` [1, 1, 2, 3] ``` Example: Given a 3x3 grid, positions = [(0, 0), (0, 1), (1, 2), (2, 1)]. Initially, the grid looks like this (0 represents water, 1 represents land): ``` 0 0 0 0 0 0 0 0 0 ``` Operations: 1. addLand(0, 0) transforms the grid to: ``` 1 0 0 0 0 0 0 0 0 => Number of islands = 1 ``` 2. addLand(0, 1) transforms the grid to: ``` 1 1 0 0 0 0 0 0 0 => Number of islands = 1 ``` 3. addLand(1, 2) transforms the grid to: ``` 1 1 0 0 0 1 0 0 0 => Number of islands = 2 ``` 4. addLand(2, 1) transforms the grid to: ``` 1 1 0 0 0 1 0 1 0 => Number of islands = 3 ``` The function should return `[1, 1, 2, 3]`. Constraints: * The grid has `N` rows and `M` columns. * The number of positions `P` is at most `N * M`. * The function should run efficiently with respect to both time and space, ensure the use of Union-Find optimizations like path compression and union by size.","solution":"class UnionFind: def __init__(self, size): self.parent = [i for i in range(size)] self.rank = [0] * size self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def num_islands(positions, n, m): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] result = [] for x, y in positions: if grid[x][y] == 1: result.append(uf.count) continue grid[x][y] = 1 uf.count += 1 index = x * m + y for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: neighbor_index = nx * m + ny uf.union(index, neighbor_index) result.append(uf.count) return result"},{"question":"You are provided with a partially implemented hash table using separate chaining for collision resolution. This hash table is designed to map keys to values efficiently. Your task is to enhance its functionality by implementing a new method called `resize` that dynamically adjusts the size of the hash table to ensure optimal performance based on its load factor. # Requirements 1. **Method to Implement**: `resize` 2. **Input and Output**: * The `resize` method should take no parameters. * It should double the current size of the hash table and rehash all existing elements. * The method should ensure all existing data is preserved and accessible after resizing. 3. **Constraints**: * The hash table should maintain efficient operations with an average-case time complexity of O(1) for basic operations. * Ensure that the implementation handles both small and large data sets gracefully. * The initial table size is provided as a parameter during the hash table initialization (default to 11). * Use a good quality hash function already provided in the class. # Example Usage ```python table = SeparateChainingHashTable() table.put(\'apple\', \'fruit\') table.put(\'carrot\', \'vegetable\') table.resize() assert table.get(\'apple\') == \'fruit\' assert table.get(\'carrot\') == \'vegetable\' assert len(table) == 2 table.put(\'banana\', \'fruit\') assert table.get(\'banana\') == \'fruit\' assert len(table) == 3 ``` # Function Definition ```python class SeparateChainingHashTable(object): ... def resize(self): pass ``` # Testing * Ensure that the table correctly retrieves all values after resizing. * Check performance to maintain at average-case O(1) for put, get, and delete operations after resizing. * Verify that the hash table maintains its correctness over multiple resizes.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def hash_function(self, key): return hash(key) % self.size def put(self, key, value): hash_key = self.hash_function(key) bucket = self.table[hash_key] for i, kv in enumerate(bucket): k, v = kv if key == k: bucket[i] = (key, value) return bucket.append((key, value)) self.count += 1 def get(self, key): hash_key = self.hash_function(key) bucket = self.table[hash_key] for k, v in bucket: if k == key: return v return None def delete(self, key): hash_key = self.hash_function(key) bucket = self.table[hash_key] for i, kv in enumerate(bucket): k, v = kv if key == k: del bucket[i] self.count -= 1 return True return False def resize(self): new_size = self.size * 2 new_table = [[] for _ in range(new_size)] for bucket in self.table: for key, value in bucket: new_hash_key = hash(key) % new_size new_table[new_hash_key].append((key, value)) self.table = new_table self.size = new_size def __len__(self): return self.count"},{"question":"**Objective**: To assess your understanding of the Radix Sort algorithm and its implementation. **Problem Statement**: Implement a function `custom_radix_sort` that sorts a list of non-negative integers using the radix sort algorithm. The function should also account for specific constraints and limitations as stated below: **Function Signature**: ```python def custom_radix_sort(arr, simulation=False): pass ``` **Input**: 1. `arr`: A list of non-negative integers (0 ≤ arr[i] ≤ 10^6) to be sorted. 2. `simulation`: A boolean flag. If `True`, the function should print the state of the array after each pass. Default is `False`. **Output**: - The function should return a list of integers sorted in ascending order. **Constraints**: - The array `arr` can have a length ranging from `0` to `10^5`. - The integers in the array will not have leading zeros. **Requirements**: 1. The function should not use Python\'s built-in sorting methods. 2. The function should be implemented using radix sort as per the described algorithm. 3. Consider edge cases where the input array might be empty or contain only one element. 4. Ensure that your function handles the memory efficiently, especially considering large datasets. 5. Optimize for performance to handle the upper limits of the input size. **Example**: ```python print(custom_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], True)) # Expected Output: # iteration 0 : 170, 45, 75, 90, 802, 24, 2, 66 # iteration 1 : 170, 802, 2, 24, 45, 75, 66, 90 # iteration 2 : 2, 24, 45, 66, 75, 90, 170, 802 print(custom_radix_sort([3, 6, 7, 1, 11], False)) # Expected Output: [1, 3, 6, 7, 11] print(custom_radix_sort([])) # Expected Output: [] ``` **Scenarios and Edge Cases**: 1. An empty array should return an empty list. 2. Arrays of size one should return the same single-element list. 3. Arrays with repeated numbers should still return correctly sorted lists.","solution":"def custom_radix_sort(arr, simulation=False): Sorts a list of non-negative integers using the radix sort algorithm. If simulation is True, prints the state of the array after each pass. if not arr: return arr # Find the maximum number to know number of digits max_num = max(arr) # Function to do counting sort of arr based on digit represented by exp def counting_sort(arr, exp): n = len(arr) # Initialize count array and output array output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr, so that arr now contains sorted numbers based on the current digit for i in range(n): arr[i] = output[i] # Initial exponent (1\'s place) exp = 1 iteration = 0 while max_num // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {iteration} : {\', \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"# Question You are given a training dataset of labeled N-dimensional points, and a single query point. Implement a function to classify the query point using the nearest neighbor algorithm as described above. Your implementation should read an input of N-dimensional points, compute the Euclidean distance, and return the label of the nearest point. # Function Signature ```python def classify_query_point(query_point: tuple, training_set: dict) -> any: Classifies the query point based on the nearest neighbor in the training set. Arguments: query_point (tuple): The point to classify. training_set (dict): A dictionary where keys are tuples representing points and values are labels. Returns: any: The label of the nearest point in the training set. pass ``` # Input and Output - **Input**: - `query_point`: A tuple representing the query point (each element is a coordinate). - `training_set`: A dictionary with points as keys (tuples) and their corresponding labels as values. - **Output**: - The label of the nearest point in the training set. # Constraints - The length of `query_point` and each key in `training_set` will be the same. - There will be at least one point in the `training_set`. - The inputs will always be correctly typed so you do not need to handle incorrect types. # Example ```python # Example input and expected output query_point = (2, 3) training_set = { (1, 2): \'ClassA\', (3, 3): \'ClassB\', (2, 4): \'ClassC\' } print(classify_query_point(query_point, training_set)) # Expected output: \'ClassC\' ``` # Explanation In this example, the Euclidean distances between the query point `(2, 3)` and the points in the training set are calculated as follows: - Distance to `(1, 2)` is sqrt((2-1)^2 + (3-2)^2) = sqrt(1 + 1) = sqrt(2) - Distance to `(3, 3)` is sqrt((2-3)^2 + (3-3)^2) = sqrt(1 + 0) = 1 - Distance to `(2, 4)` is sqrt((2-2)^2 + (3-4)^2) = sqrt(0 + 1) = 1 Since `(2, 4)` and `(3, 3)` are both at the same minimum distance of `1`, the label of `(2, 4)` is arbitrarily chosen and returned. # Requirements * You must implement and use a helper function to calculate the Euclidean distance. * Your solution should ensure all edge cases are properly handled.","solution":"import math def euclidean_distance(point1, point2): Calculates the Euclidean distance between two N-dimensional points. Arguments: point1 (tuple): The first point. point2 (tuple): The second point. Returns: float: The Euclidean distance between the points. return math.sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2))) def classify_query_point(query_point, training_set): Classifies the query point based on the nearest neighbor in the training set. Arguments: query_point (tuple): The point to classify. training_set (dict): A dictionary where keys are tuples representing points and values are labels. Returns: any: The label of the nearest point in the training set. nearest_point = min(training_set.keys(), key=lambda point: euclidean_distance(point, query_point)) return training_set[nearest_point]"},{"question":"# Problem Description Write a function named `is_consecutive_with_sets` that takes a stack (implemented as a list) as a parameter and returns whether the stack contains a sequence of consecutive integers starting from the bottom to the top of the stack. Unlike the provided solutions, this function should use a set as the auxiliary data structure to enhance performance in terms of checking for consecutive elements. Function Signature ```python def is_consecutive_with_sets(stack: list) -> bool: pass ``` # Input * A single list of integers, `stack`, where the bottom of the stack is represented by the 0-th index, and the top of the stack is the last index. # Output * A boolean value: * `True` if the stack contains consecutive integers from bottom to top. * `False` otherwise. # Constraints * All integers in the stack are distinct. * The stack may contain any integer within the range of 32-bit signed integers. # Example ```plaintext Input: [3, 4, 5, 6, 7] Output: True Input: [3, 4, 6, 7] Output: False Input: [1] Output: True Input: [1, 3, 2] Output: True (Note: Consecutive starting from bottom but the order incorrect) ``` # Notes * Ensure the function does not modify the original stack. * Use a set to aid in the consecutive check, focusing on performance improvements. * Consider edge cases such as an empty stack, stack with a single element, and stack with elements in no specific order.","solution":"def is_consecutive_with_sets(stack): Determines if the stack (list) contains a sequence of consecutive integers from bottom to top. if not stack: # If the stack is empty return True min_val = min(stack) max_val = max(stack) # Create a set from the stack stack_set = set(stack) # Check if set has the same number of elements as the difference between max and min and are consecutive return len(stack) == len(stack_set) and len(stack) == (max_val - min_val + 1)"},{"question":"**Primal Rabin-Miller Assessment** **Objective**: Assess the functionality of the Rabin-Miller probabilistic primality test by implementing an optimized variant that ensures numbers less than 5 are properly handled and returns results according to performance requirements. **Problem Statement**: Given an integer `n` and an integer `k` representing the number of iterations, implement a function `is_probably_prime(n: int, k: int) -> bool` which determines if `n` is probably prime using the Rabin-Miller primality test. **Function Definition**: ```python def is_probably_prime(n: int, k: int) -> bool: ``` **Input Parameters**: - `n`: An integer `n >= 2` (1 <= n <= 10**18) - `k`: An integer representing the number of accuracy trials. (1 <= k <= 30) **Output**: - Returns `True` if `n` is probably prime, else `False`. **Constraints**: - Ensure the accuracy of probable prime numbers, meaning the probability of error should stay within acceptable limits. **Performance**: - Time complexity should be kept as efficient as possible, considering O(k * log^3 n). **Example**: ```python assert is_probably_prime(31, 5) == True assert is_probably_prime(16, 5) == False assert is_probably_prime(9999999967, 10) == True assert is_probably_prime(2, 5) == True assert is_probably_prime(1, 5) == False ``` **Important Notes**: 1. Handle edge cases explicitly: `n < 5` should be handled correctly. 2. Consider large integers close to upper constraints. 3. Include robust checks to avoid repetitions and potential pitfalls of random selection.","solution":"import random def is_probably_prime(n: int, k: int) -> bool: Determine if a number is probably prime using the Rabin-Miller primality test. :param n: integer to test for primality :param k: number of accuracy trials :return: True if n is probably prime, False otherwise if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n - 1 as 2^r * d r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Witness loop def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True"},{"question":"# Segment Tree Range Minimum Query Context: You are provided with an array and need to frequently check the minimum value within a specific range of indices in the array. Implement a Segment Tree that supports finding the minimum value within any given range efficiently. Task: Implement a SegmentTree class with the following methods: 1. **__init__(self, arr)**: Initialize the segment tree with a given array. 2. **query(self, L, R)**: Return the minimum value within the indices L and R (inclusive). Requirements: * **Input Format**: - The `arr` parameter will be a list of integers. - L and R for the query method will be integers such that 0 <= L <= R < len(arr). * **Output Format**: - The `query` method should return an integer representing the minimum value in the specified range. * **Constraints**: - The length of `arr` will be between 1 and 10^5. - The values in `arr` will be between -10^9 and 10^9. Implementation Details: - Your implementation should handle out-of-bound queries gracefully by returning an appropriate error message or None. - Ensure optimal performance for both initialization and range queries using the segment tree properties. - Avoid unnecessary space usage by trimming down the segment tree to match the given array size. ```python class SegmentTree: def __init__(self, arr): self.n = len(arr) self.segment = [float(\'inf\')] * (4 * self.n) self._build(arr, 0, 0, self.n - 1) def _build(self, arr, idx, left, right): if left == right: self.segment[idx] = arr[left] else: mid = (left + right) // 2 self._build(arr, 2 * idx + 1, left, mid) self._build(arr, 2 * idx + 2, mid + 1, right) self.segment[idx] = min(self.segment[2 * idx + 1], self.segment[2 * idx + 2]) def _query(self, idx, seg_left, seg_right, query_left, query_right): if query_left > seg_right or query_right < seg_left: return float(\'inf\') if query_left <= seg_left and seg_right <= query_right: return self.segment[idx] mid = (seg_left + seg_right) // 2 left_query = self._query(2 * idx + 1, seg_left, mid, query_left, query_right) right_query = self._query(2 * idx + 2, mid + 1, seg_right, query_left, query_right) return min(left_query, right_query) def query(self, L, R): if L < 0 or R >= self.n or L > R: return None return self._query(0, 0, self.n - 1, L, R) # Example usage: # arr = [2, 4, 5, 3, 4] # seg_tree = SegmentTree(arr) # print(seg_tree.query(1, 3)) # Output: 3 # print(seg_tree.query(0, 4)) # Output: 2 ```","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.segment = [float(\'inf\')] * (4 * self.n) self._build(arr, 0, 0, self.n - 1) def _build(self, arr, idx, left, right): if left == right: self.segment[idx] = arr[left] else: mid = (left + right) // 2 self._build(arr, 2 * idx + 1, left, mid) self._build(arr, 2 * idx + 2, mid + 1, right) self.segment[idx] = min(self.segment[2 * idx + 1], self.segment[2 * idx + 2]) def _query(self, idx, seg_left, seg_right, query_left, query_right): if query_left > seg_right or query_right < seg_left: return float(\'inf\') if query_left <= seg_left and seg_right <= query_right: return self.segment[idx] mid = (seg_left + seg_right) // 2 left_query = self._query(2 * idx + 1, seg_left, mid, query_left, query_right) right_query = self._query(2 * idx + 2, mid + 1, seg_right, query_left, query_right) return min(left_query, right_query) def query(self, L, R): if L < 0 or R >= self.n or L > R: return None return self._query(0, 0, self.n - 1, L, R) # Example usage: # arr = [2, 4, 5, 3, 4] # seg_tree = SegmentTree(arr) # print(seg_tree.query(1, 3)) # Output: 3 # print(seg_tree.query(0, 4)) # Output: 2"},{"question":"# Question: Radix Sort Implementation Challenge **Problem Statement**: You are required to implement the Radix Sort algorithm from scratch. Radix Sort is an efficient, non-comparative sorting algorithm that sorts numbers based on individual digits. The algorithm uses a positional processing approach where it starts sorting from the least significant digit to the most significant digit. **Requirements**: - Implement a function `radix_sort` to take a list of non-negative integers and return the sorted list. - You should not use any existing sort functions provided by your programming language (e.g., Python\'s `sorted`). **Function Signature**: ```python def radix_sort(arr: List[int]) -> List[int]: ``` **Input**: - A list of non-negative integers `arr` where (0 leq text{arr[i]} leq 10^9). - The length of the list is (1 leq text{len(arr)} leq 10^5). **Output**: - A list of integers sorted in ascending order. **Constraints**: - Optimize your implementation for time and space efficiency. - Consider edge cases such as an empty list and lists containing duplicate numbers. - Ensure your algorithm remains stable and returns results accurately sorted. **Example**: ```python # Example 1: input: [170, 45, 75, 90, 802, 24, 2, 66] output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2: input: [3, 3, 1, 2] output: [1, 2, 3, 3] ``` **Explanation**: The first example shows a list of integers sorted using Radix Sort, considering the positional value from units to the most significant digits. Good luck with your implementation! Ensure to analyze and test your solution thoroughly.","solution":"def radix_sort(arr): Perform Radix Sort on a list of non-negative integers. :param arr: List[int] - a list of non-negative integers :return: List[int] - the sorted list if not arr: return arr # Find the maximum number to know the number of digits max_num = max(arr) exp = 1 # Initialize exponent to 1 (10^0) # Perform counting sort for every digit, starting from least significant digit while max_num // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr def counting_sort(arr, exp): A helper function to perform counting sort based on the digit represented by exp. :param arr: List[int] - the list to be sorted :param exp: int - the exponent representing the digit to be sorted :return: List[int] - the sorted list based on the current digit n = len(arr) output = [0] * n # Output array to build the sorted list count = [0] * 10 # There are 10 possible digits (0 to 9) # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count so that it contains actual positions of digits in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 # Copy the output array to arr, so that arr contains sorted numbers based on current digit return output"},{"question":"# Programming Task: Resolving Absolute Paths Scenario You are tasked with implementing a utility function that resolves any given file path to its absolute form. Your function should correctly handle paths that start with a `~` symbol and any relative paths. This is a common requirement in scripting and applications to avoid issues with path resolution. Task Write a function `resolve_path` that takes an input file path and returns the absolute path. The function should cover the following: 1. If the path starts with `~`, it should expand it to the user\'s home directory. 2. If the path is relative, it should convert it to an absolute path based on the current working directory. 3. If the path is already absolute, it should return it as-is. Ensure your function handles various edge cases and paths with special characters or white spaces. Function Signature ```python def resolve_path(file_path: str) -> str: pass ``` Input - `file_path` (str): A string representing a file path which can be relative or contain `~`. Output - (str): The absolute path corresponding to the input. Constraints - The input path length will be within the range of 1 to 2048 characters. - The function needs to run efficiently within typical script runtimes. Example Usage ```python print(resolve_path(\\"~/Documents/project\\")) # \\"/home/user/Documents/project\\" (example for Linux/MacOS user) print(resolve_path(\\"docs/report.txt\\")) # \\"/current/working/directory/docs/report.txt\\" print(resolve_path(\\"/usr/local/bin\\")) # \\"/usr/local/bin\\" ``` Ensure to test your implementation thoroughly against edge cases.","solution":"import os def resolve_path(file_path: str) -> str: Resolves an input file path to an absolute path. Parameters: file_path (str): A string representing a file path which can be relative or contain `~`. Returns: str: The absolute path corresponding to the input. # Expand user home directory if path starts with `~` file_path = os.path.expanduser(file_path) # Convert relative path to absolute path absolute_path = os.path.abspath(file_path) return absolute_path"},{"question":"**Description**: You are tasked with implementing an efficient algorithm to determine the edit distance between two given strings. The edit distance is the Levenshtein distance, defined as the minimum number of character insertions, deletions, and substitutions required to transform one string into another. **Details**: - Implement a function `optimized_edit_distance(word_a: str, word_b: str) -> int` that takes in two strings `word_a` and `word_b` and returns an integer representing the edit distance between the two strings. - Optimize the function to use only O(min(length_a, length_b)) space. **Input**: - `word_a` (1 ≤ len(word_a) ≤ 1000): A string containing lowercase/uppercase English letters. - `word_b` (1 ≤ len(word_b) ≤ 1000): A string containing lowercase/uppercase English letters. **Output**: - An integer representing the edit distance between the input strings. **Constraints**: - You cannot use an external library to calculate the edit distance. - The solution should be optimized in terms of space usage. **Example**: ```python assert optimized_edit_distance(\\"FOOD\\", \\"MONEY\\") == 4 assert optimized_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert optimized_edit_distance(\\"sunday\\", \\"saturday\\") == 3 assert optimized_edit_distance(\\"abc\\", \\"yabd\\") == 2 ``` **Performance Requirements**: - Time Complexity: O(length_a * length_b) - Space Complexity: O(min(length_a, length_b)) Implement the function `optimized_edit_distance` based on the given details and constraints. Your solution should handle all edge cases effectively, and should run efficiently for the upper limit of the input size.","solution":"def optimized_edit_distance(word_a: str, word_b: str) -> int: Computes the Levenshtein distance between two strings using optimized space complexity. len_a, len_b = len(word_a), len(word_b) # Ensure word_a is the shorter string if len_a > len_b: word_a, word_b = word_b, word_a len_a, len_b = len_b, len_a # Initialize the previous row prev_row = list(range(len_a + 1)) for j in range(1, len_b + 1): curr_row = [j] * (len_a + 1) for i in range(1, len_a + 1): if word_a[i - 1] == word_b[j - 1]: cost = 0 else: cost = 1 curr_row[i] = min(prev_row[i] + 1, # Deletion curr_row[i - 1] + 1, # Insertion prev_row[i - 1] + cost) # Substitution prev_row = curr_row return prev_row[len_a]"},{"question":"# Problem: Determine the Height of a Binary Search Tree Context You are working as a software engineer tasked with implementing and managing an efficient binary search tree (BST). One of the essential tasks is to calculate the height of the binary tree. The height of a BST is crucial because it affects the performance of search, insert, and delete operations. Task Implement a function `height` that calculates the height of a binary search tree. The tree is represented as a series of nodes where each node contains a value and pointers to its left and right children. The height is the length of the longest path from the root to a leaf node. Function Signature ```python def height(root) -> int: # Your code here ``` Input * `root`: The root node of the binary search tree (BST) or `None` if the tree is empty. Output * Return an integer representing the height of the BST. Example Consider the following binary search tree (BST): ```plaintext 9 / 6 12 / / 3 8 10 15 / 7 18 ``` * The height of the tree is **4**. Constraints 1. You may assume that the value of each node is a distinct integer. 2. The BST can contain up to (10^4) nodes. Performance Requirements * Your implementation should aim for a time complexity of (O(n)), where (n) is the number of nodes in the tree. * Space complexity should be (O(h)), where (h) is the height of the tree, primarily due to the recursive call stack.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def height(root): Calculate the height of a binary search tree. :param root: TreeNode, the root node of the BST :return: int, the height of the BST if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Maximum Flow Problem in Social Network Connections You are working on a project for a social media application where users can send messages to each other. The application server must handle the maximum possible flow of messages between users. Given the following algorithms to solve network flow problems and their respective efficiency, implement a function that leverages the most appropriate algorithm under specified constraints. Task Write a function using Dinic\'s algorithm to compute the maximum flow of messages between two users in a social network. Function Signature ```python def compute_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: Given a capacity matrix, source node, and sink node, compute the maximum possible flow using Dinic\'s algorithm. :param capacity: A list of lists where each list represents capacities between nodes. :param source: The starting node (user) for the message flow. :param sink: The ending node (user) for the message flow. :return: The maximum possible flow from source to sink. ``` Input * `capacity`: A 2D list of integers where `capacity[i][j]` represents the capacity of the direct connection from user `i` to user `j` (0 if no direct connection). * `source`: An integer representing the user ID which is the source of the messages. * `sink`: An integer representing the user ID which is the destination of the messages. Output * Return an integer representing the maximum possible message flow from the source user to the sink user. Constraints * 1 <= Number of users (nodes) <= 500 * 0 <= Capacity of an edge <= 1000 Example ```python capacity = [ [0, 10, 0, 10, 0, 0], [0, 0, 4, 2, 8, 0], [0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 9, 0], [0, 0, 6, 0, 0, 10], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(compute_max_flow(capacity, source, sink)) # Output: 19 ```","solution":"from collections import deque from typing import List def bfs_level_graph(capacity: List[List[int]], source: int, sink: int, level: List[int]) -> bool: n = len(capacity) for i in range(n): level[i] = -1 level[source] = 0 q = deque([source]) while q: u = q.popleft() for v in range(n): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 q.append(v) return level[sink] >= 0 def dfs_flow(u: int, flow: int, sink: int, capacity: List[List[int]], level: List[int], start: List[int]) -> int: if u == sink: return flow n = len(capacity) while start[u] < n: v = start[u] if capacity[u][v] > 0 and level[v] == level[u] + 1: current_flow = min(flow, capacity[u][v]) temp_flow = dfs_flow(v, current_flow, sink, capacity, level, start) if temp_flow > 0: capacity[u][v] -= temp_flow capacity[v][u] += temp_flow return temp_flow start[u] += 1 return 0 def compute_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: n = len(capacity) level = [-1] * n max_flow = 0 while bfs_level_graph(capacity, source, sink, level): start = [0] * n while True: flow = dfs_flow(source, float(\'inf\'), sink, capacity, level, start) if flow <= 0: break max_flow += flow return max_flow"},{"question":"Sum Range and Update in Array You are provided with an integer array `arr` of length `n` and you need to perform the following operations efficiently: 1. Compute the prefix sum of the first `i` elements. 2. Update the value of a specified element in the array. Implement a class `FenwickTree` with the following methods: 1. `__init__(self, arr: List[int]) -> None`: Initializes the object with the array `arr`. 2. `update(self, i: int, val: int) -> None`: Updates the value of `arr[i]` to `val`. 3. `prefix_sum(self, i: int) -> int`: Returns the sum of the array elements from index `0` to index `i`. # Input and Output Formats: Input: * An integer array `arr` of length `n`. * A method `update` which takes an integer index `i` and a value `val`. * A method `prefix_sum` which takes an integer index `i`. Output: * The `update` method does not return anything. * The `prefix_sum` method returns the sum of elements from index `0` to `i`. # Constraints: * `1 <= n <= 10^5` * `1 <= arr[i], val <= 10^4` * `0 <= i < n` # Example: ```python arr = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] # Initialize FenwickTree fenwick_tree = FenwickTree(arr) # Get prefix sum for index 5 print(fenwick_tree.prefix_sum(5)) # Output: 26 (1 + 7 + 3 + 0 + 7 + 8) # Update element at index 3 to 6 fenwick_tree.update(3, 6) # Get updated prefix sum for index 5 print(fenwick_tree.prefix_sum(5)) # Output: 32 (1 + 7 + 3 + 6 + 7 + 8) ``` # Explanation: 1. **Initialize Fenwick Tree**: The `arr` is used to initialize a Fenwick Tree which will allow efficient range sum queries and updates. 2. **Query Prefix Sum**: The `prefix_sum(i)` method returns the sum of elements from index `0` to `i`. 3. **Update Element**: The `update(i, val)` method sets `arr[i]` to `val` and updates the internal data structure to reflect this change efficiently.","solution":"class FenwickTree: def __init__(self, arr): Initialize the Fenwick Tree with the given array. self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = [0] * self.n # Build the tree for i, val in enumerate(arr): self.update(i, val) def update(self, i, val): Update the value at index i to val. delta = val - self.arr[i] self.arr[i] = val i += 1 # Fenwick Tree indices are 1-based while i <= self.n: self.tree[i] += delta i += i & -i def prefix_sum(self, i): Return the prefix sum from index 0 to i. sum = 0 i += 1 # Fenwick Tree indices are 1-based while i > 0: sum += self.tree[i] i -= i & -i return sum"},{"question":"# Problem: Enhanced Substring Search Using KMP You are working on a text processing tool that requires efficient substring matching. To accomplish this, you will implement an optimized substring search algorithm using the Knuth-Morris-Pratt (KMP) algorithm. The task is to write a function that takes a text and a pattern as inputs and returns the starting indices of all occurrences of the pattern in the text. Task Implement a function `enhanced_kmp_search(text: str, pattern: str) -> List[int]` that: 1. Accepts a **text** (string) and a **pattern** (string). 2. Returns a list of starting indices in the **text** where the **pattern** occurs. Requirements: 1. If the **pattern** is not found in the **text**, return an empty list. 2. If either the **text** or **pattern** is empty, return an empty list. 3. Ensure that your function handles large inputs efficiently in linear time complexity based on the lengths of the **text** and **pattern**. Example: ```python >>> enhanced_kmp_search(\\"hello there hero!\\", \\"he\\") [0, 7, 12] >>> enhanced_kmp_search(\\"abcdef\\", \\"gh\\") [] >>> enhanced_kmp_search(\\"\\", \\"hi\\") [] >>> enhanced_kmp_search(\\"mississippi\\", \\"issi\\") [1, 4] ``` Constraints: * The lengths of **text** and **pattern** will be at most 10^5. * You must use the KMP algorithm for this implementation.","solution":"from typing import List def kmp_prefix_function(pattern: str) -> List[int]: Computes the prefix function for KMP algorithm. prefix = [0] * len(pattern) j = 0 # length of previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 prefix[i] = j i += 1 else: if j != 0: j = prefix[j - 1] else: prefix[i] = 0 i += 1 return prefix def enhanced_kmp_search(text: str, pattern: str) -> List[int]: Searches for all occurrences of the pattern in the text using KMP algorithm. if not text or not pattern: return [] prefix = kmp_prefix_function(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = prefix[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = prefix[j - 1] else: i += 1 return result"},{"question":"Scenario A scientific researcher needs to evaluate a large set of numerical data. For further statistical analysis, it is necessary to determine the number of decimal digits each integer presents efficiently. Task Your task is to implement a function `num_digits(n)` that returns the number of digits in the given integer `n`. Function Signature ```python def num_digits(n: int) -> int: pass ``` Input - A single integer, `n` (between `-10^9` and `10^9`). Output - An integer representing the number of digits in the given integer `n`. Constraints - The input range is limited to integers between `-10^9` to `10^9`. - The function must handle both positive and negative numbers and zero. - The solution must have O(1) time complexity. Example ```python print(num_digits(123)) # Output: 3 print(num_digits(-9876)) # Output: 4 print(num_digits(0)) # Output: 1 ``` Hint You may use logarithmic properties to achieve a constant-time solution.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the given integer n. Handles both positive and negative integers and zero. if n == 0: return 1 n = abs(n) return len(str(n))"},{"question":"# Trie Implementation and Application Background You are tasked with building a system for a search engine that supports fast word insertions and prefix-based query suggestions. Using a Trie, you will provide functionalities to add words, search for exact words, and find words that start with a given prefix. Task 1. Implement a Trie with the following methods: * `insert(word: str) -> None`: Inserts a word into the trie. * `search(word: str) -> bool`: Returns True if the word is in the trie, else False. * `starts_with(prefix: str) -> bool`: Returns True if there is any word in the trie that starts with the given prefix. 2. Additionally, implement a method: * `list_words_with_prefix(prefix: str) -> List[str]`: Returns all words in the trie that start with the given prefix. Constraints * All inputs consist of lowercase letters \'a\'-\'z\'. * The length of word and prefix will not exceed 100. Input/Output Formats * `insert(word: str) -> None`: Takes a word to insert into the Trie. * `search(word: str) -> bool`: Takes a word and returns `True` if found, otherwise `False`. * `starts_with(prefix: str) -> bool`: Takes a prefix and returns `True` if any word starts with the prefix. * `list_words_with_prefix(prefix: str) -> List[str]`: Takes a prefix and returns a list of all words starting with the prefix. Scenario Consider a scenario where you are managing a real-time suggestion feature for a search bar. Words are frequently added based on recent user searches, and you need prompt recommendations based on partial input. Example ```python trie = Trie() trie.insert(\\"apple\\") trie.search(\\"apple\\") # Returns True trie.search(\\"app\\") # Returns False trie.starts_with(\\"app\\") # Returns True trie.insert(\\"app\\") trie.search(\\"app\\") # Returns True trie.list_words_with_prefix(\\"ap\\") # Returns [\\"apple\\", \\"app\\"] trie.list_words_with_prefix(\\"b\\") # Returns [] ``` Implement the `list_words_with_prefix` method and test the entire Trie functionality with provided methods.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._search_prefix(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._search_prefix(prefix) is not None def list_words_with_prefix(self, prefix: str) -> list: results = [] node = self._search_prefix(prefix) if node is not None: self._find_words_with_prefix(node, prefix, results) return results def _search_prefix(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node def _find_words_with_prefix(self, node: TrieNode, prefix: str, results: list): if node.is_end_of_word: results.append(prefix) for char, next_node in node.children.items(): self._find_words_with_prefix(next_node, prefix + char, results)"},{"question":"# Question: Find the Next Higher Permutation of Digits Scenario You are given a number represented as a sequence of digits. Your task is to write a function that finds the next higher number which is a permutation of the original sequence of digits. If no such permutation exists, return -1. Function Signature ```python def next_bigger(num: int) -> int: ``` Input * `num`: An integer `1 <= num <= 10^9`. Output * An integer representing the next higher permutation of the digits or `-1` if no such permutation exists. Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(99999) == -1 ``` Constraints * Consider edge cases where the given number is the highest permutation of its digits. * The function should be efficient, with a linear O(n) time complexity where `n` is the number of digits in the number. * Pay attention to potential integer overflows and ensure your code handles single-digit numbers and very large numbers. Detailed Task * Identify the largest index `i` such that `array[i-1] < array[i]`. * If no such index exists, return `-1`. * Find the largest index `j` such that `j >= i` and `array[j] > array[i-1]`. * Swap the values at `array[i-1]` and `array[j]`. * Reverse the sequence from `array[i]` to end of the array. * Return the number formed by the altered sequence of digits. Write tests to verify your solution.","solution":"def next_bigger(num: int) -> int: Returns the next higher permutation of digits of the input number. If no such permutation exists, returns -1. digits = list(str(num)) n = len(digits) # Step 1: Find the largest index i such that digits[i-1] < digits[i] i = n - 1 while i > 0 and digits[i - 1] >= digits[i]: i -= 1 if i == 0: return -1 # No higher permutation possible # Step 2: Find the largest index j such that j >= i and digits[j] > digits[i - 1] j = n - 1 while digits[j] <= digits[i - 1]: j -= 1 # Step 3: Swap digits[i - 1] and digits[j] digits[i - 1], digits[j] = digits[j], digits[i - 1] # Step 4: Reverse the sequence from digits[i] to the end digits[i:] = reversed(digits[i:]) return int(\'\'.join(digits))"},{"question":"# Matrix Multiplication Function Context Matrix multiplication is a fundamental operation in many applications, such as scientific computing, graphics transformations, and statistical modeling using Markov chains. It involves combining two matrices to form a new matrix where each cell is the dot product of a row from the first matrix and a column from the second matrix. Task Implement a function `matrix_multiplication` that takes two matrices as input and returns their product. Function Signature ```python def matrix_multiplication(multiplicand: list, multiplier: list) -> list: pass ``` Input - `multiplicand` (List[List[int]]): A 2D list representing the first matrix. - `multiplier` (List[List[int]]): A 2D list representing the second matrix. Output - Returns a 2D list representing the resulting matrix of their multiplication. Constraints - The matrices are compatible for multiplication (i.e., the number of columns in `multiplicand` is equal to the number of rows in `multiplier`). - Each matrix element is an integer. - Matrices will not be empty. Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiplication(multiplicand, multiplier) # result should be: # [ # [58, 64], # [139, 154] # ] ``` Performance Requirements - Ensure the implementation considers edge cases without causing errors. - Aim for a time complexity of O(n^3) where possible with consideration for matrix dimensions.","solution":"def matrix_multiplication(multiplicand, multiplier): Perform matrix multiplication between multiplicand and multiplier. Args: multiplicand (List[List[int]]): The first matrix. multiplier (List[List[int]]): The second matrix. Returns: List[List[int]]: The product matrix which is the result of matrix multiplication. # Number of rows in multiplicand rows_m = len(multiplicand) # Number of columns in multiplicand (and rows in multiplier) cols_m = len(multiplicand[0]) # Number of columns in multiplier cols_n = len(multiplier[0]) # Initialize result matrix with zeros result = [[0 for _ in range(cols_n)] for _ in range(rows_m)] # Perform matrix multiplication for i in range(rows_m): for j in range(cols_n): for k in range(cols_m): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Sum of Digit Lengths of an Array You are given an array of integers, and your task is to write a function that returns the sum of the number of digits of all the integers in the array. Function Signature ```python def sum_digit_lengths(arr: List[int]) -> int: ``` Input - `arr`: A list of integers. Example: `[123, 4, 56789, -12, 0]` Output - An integer representing the sum of the number of digits of all the integers in the list. Example: `16` for the given list. Constraints - The array can contain up to 10^5 elements. - Each element in the array is an integer within the range [-10^9, 10^9]. Example 1. `sum_digit_lengths([123, 4, 56789, -12, 0])` should return `16`. 2. `sum_digit_lengths([1, -1, 1000000000])` should return `21`. Explanation For the first example: - Number of digits in 123 is 3. - Number of digits in 4 is 1. - Number of digits in 56789 is 5. - Number of digits in -12 is 2. - Number of digits in 0 is 1. - Summing these up gives: 3 + 1 + 5 + 2 + 1 = 12. Write a function `sum_digit_lengths` that implements this functionality efficiently, making use of the provided `num_digits` function if needed.","solution":"from typing import List def num_digits(n: int) -> int: Returns the number of digits in an integer n. For negative numbers, the \'-\' sign is not counted. return len(str(abs(n))) def sum_digit_lengths(arr: List[int]) -> int: Returns the sum of the number of digits of all the integers in the given list `arr`. return sum(num_digits(x) for x in arr)"},{"question":"Given two binary trees, `big` and `small`, write a function that checks if `small` is a subtree of `big`. A subtree of a tree `T` is a tree consisting of a node in `T` and all of its descendants in `T`. Function Signature ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: ``` # Input Format * `big`: The root node of the larger binary tree. * `small`: The root node of the smaller binary tree. Each `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output Format * Return `True` if `small` is a subtree of `big`, otherwise return `False`. # Constraints * Heights of the trees can be up to 1000 nodes. * Values of tree nodes are integers and unique within each tree. * Avoid unnecessary computations; optimize for efficiency. # Examples Example 1 ```plaintext big: 3 / 4 5 / 1 2 small: 4 / 1 2 Output: True ``` Example 2 ```plaintext big: 3 / 4 5 / 1 2 / 0 small: 3 / 4 / 1 2 Output: False ``` # Follow-up Consider a scenario where the big tree is significantly larger than the small tree. How can you optimize your solution for better performance?","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: return True if not big: return False if is_identical(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def is_identical(tree1: TreeNode, tree2: TreeNode) -> bool: if not tree1 and not tree2: return True if not tree1 or not tree2: return False if tree1.val != tree2.val: return False return is_identical(tree1.left, tree2.left) and is_identical(tree1.right, tree2.right)"},{"question":"You are provided with a **Union-Find** class implemented to track islands in a grid of water. An island is formed by connecting adjacent land horizontally or vertically. Initially, the grid is filled with water (`0`), and land (`1`) is formed by specific operations. Implement the following additional operations for the Union-Find data structure and associated functionality in a grid: 1. **Query Operation**: Given a grid of size `m x n`, identify if two given positions are part of the same island or not. 2. **Largest Island Operation**: Given a grid of `m x n`, return the size of the largest island formed after all the addLand operations have been completed. # Function Signatures ```python def query_same_island(uf: Union, position1: tuple, position2: tuple) -> bool: Determine if `position1` and `position2` are part of the same island. Parameters: uf (Union): The Union-Find data structure with the island data. position1 (tuple): First position tuple (i, j). position2 (tuple): Second position tuple (i, j). Returns: bool: True if `position1` and `position2` are part of the same island, otherwise False. def largest_island_size(uf: Union) -> int: Return the size of the largest island. Parameters: uf (Union): The Union-Find data structure with the island data. Returns: int: Size of the largest island. ``` # Input Constraints - `position1` and `position2` are within range of the grid dimensions. - All positions are valid (i.e., have been added as land). # Example ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] islands = Union() for position in map(tuple, positions): islands.add(position) for delta in (0, 1), (0, -1), (1, 0), (-1, 0): adjacent = (position[0] + delta[0], position[1] + delta[1]) if adjacent in islands.parents: islands.unite(position, adjacent) assert query_same_island(islands, (0, 0), (0, 1)) == True # Same island assert query_same_island(islands, (0, 0), (1, 2)) == False # Different islands assert largest_island_size(islands) == 2 # The largest island size after all operations ``` Implement the functions to support the above operations using the Union-Find data structure.","solution":"class UnionFind: def __init__(self): self.parents = {} self.rank = {} self.size = {} def find(self, x): if self.parents[x] != x: self.parents[x] = self.find(self.parents[x]) return self.parents[x] def unite(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parents[rootY] = rootX self.size[rootX] += self.size[rootY] elif self.rank[rootX] < self.rank[rootY]: self.parents[rootX] = rootY self.size[rootY] += self.size[rootX] else: self.parents[rootY] = rootX self.rank[rootX] += 1 self.size[rootX] += self.size[rootY] def add(self, x): if x not in self.parents: self.parents[x] = x self.rank[x] = 0 self.size[x] = 1 def query_same_island(uf, position1, position2): return uf.find(position1) == uf.find(position2) def largest_island_size(uf): return max(uf.size.values(), default=0) # Setup function to add land positions and unite adjacent lands def add_land(uf, positions): for position in positions: position = tuple(position) uf.add(position) for delta in [(0, 1), (0, -1), (1, 0), (-1, 0)]: adjacent = (position[0] + delta[0], position[1] + delta[1]) if adjacent in uf.parents: uf.unite(position, adjacent)"},{"question":"Pigeonhole Sort Implementation Context & Objective You have a small database of students\' test grades for a particular subject, and you need to sort this data in ascending order. The grades are integers ranging from 0 to 100. Implement a function to sort the grades using Pigeonhole Sort. Function Specification **Function Name**: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers where 0 <= arr[i] <= 100 for all i. **Output**: * A new list sorted in ascending order. Constraints * 1 <= len(arr) <= 10^6 * 0 <= arr[i] <= 100 Performance Requirements * Expected time complexity: O(n + Range) * Expected space complexity: O(Range) Example Usage ```python grades = [73, 67, 38, 33, 90, 85, 100, 0, 76, 88] sorted_grades = pigeonhole_sort(grades) print(sorted_grades) # [0, 33, 38, 67, 73, 76, 85, 88, 90, 100] ``` Edge Cases to Consider * Array containing a single element. * Array containing duplicate elements. * Array with all elements being the same. * Empty array. Ensure that your implementation handles all edge cases and optimally manages the space and time complexity within the constraints.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts a list of integers using Pigeonhole Sort algorithm. Parameters: arr (List[int]): List of integers where 0 <= arr[i] <= 100 for all i Returns: List[int]: A new list sorted in ascending order if not arr: return [] min_val = 0 max_val = 100 range_val = max_val - min_val + 1 # Create pigeonholes pigeonholes = [0] * range_val # Populate the pigeonholes for num in arr: pigeonholes[num - min_val] += 1 # Collect the sorted elements sorted_arr = [] for idx in range(range_val): sorted_arr.extend([idx + min_val] * pigeonholes[idx]) return sorted_arr"},{"question":"# Decode Ways Challenge Scenario In secret organization communications, messages are encoded as numerical strings according to the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing only digits, your task is to determine the total number of ways it can be decoded. Function Signature ```python def decode_ways(s: str) -> int: :param s: Encoded message as a string :return: The total number of ways to decode the message ``` Input * A single string `s` of length n (0 <= n <= 100) containing only digits. Output * An integer representing the total number of ways to decode the message. Constraints * The input `s` may contain leading zeroes. * Decoding results must be valid as per the mapping rules. Example 1. Input: `\\"12\\"` Output: `2` Explanation: It could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. Input: `\\"226\\"` Output: `3` Explanation: It could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6) or \\"BBF\\" (2 2 6). 3. Input: `\\"0\\"` Output: `0` Explanation: There\'s no valid encoding for `0`. Notes * Consider edge cases like empty strings or strings containing invalid sequences (e.g., \\"30\\"). Implementation Helper You may find it useful to: * Use dynamic programming to keep track of valid decoding ways up to each character. * Store intermediate results to avoid redundant calculations. Starter Code ```python def decode_ways(s: str) -> int: if not s or s[0] == \'0\': return 0 # Initialize tracking variables last_char, last_two_chars = 1, 1 for i in range(1, len(s)): current = 0 if s[i] != \'0\': current = last_char if 10 <= int(s[i-1:i+1]) <= 26: current += last_two_chars last_two_chars = last_char last_char = current return last_char ```","solution":"def decode_ways(s: str) -> int: Determine the total number of ways to decode a message encoded as a string of digits. if not s or s[0] == \'0\': return 0 # `dp` array to store the number of ways to decode up to each character n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: An empty string has one way to be decoded (doing nothing) dp[1] = 1 # Base case: A single character string (other than \'0\') can only be decoded one way for i in range(2, n + 1): # Single character decoding is possible if the current character is not \'0\' if s[i - 1] != \'0\': dp[i] += dp[i - 1] # Two character decoding is possible if the two character string is between \\"10\\" and \\"26\\" two_char = int(s[i - 2:i]) if 10 <= two_char <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"Given a binary tree, implement the function `inorder_iterative` that performs an iterative inorder traversal and the function `inorder_recursive` that performs a recursive inorder traversal. Both functions should return a list of node values in the inorder sequence. Requirements * Implement the functions: ```python def inorder_iterative(root: Node) -> list[int]: pass def inorder_recursive(root: Node, res: list[int] = None) -> list[int]: pass ``` * **Input**: The `root` of a binary tree (the `Node` class is already defined as per the provided snippet). * **Output**: A list of integers representing the inorder traversal of the tree. * **Constraints**: - The binary tree can have up to 10^4 nodes. - Node values are integers within the range [-10^5, 10^5]. * You should handle edge cases like empty trees. Example ```python if __name__ == \'__main__\': # Example Tree: n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ``` - `inorder_iterative` should traverse the tree iteratively using a stack. - `inorder_recursive` should traverse the tree recursively using function calls.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def inorder_iterative(root: Node) -> list[int]: result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result def inorder_recursive(root: Node, res: list[int] = None) -> list[int]: if res is None: res = [] if root is not None: inorder_recursive(root.left, res) res.append(root.value) inorder_recursive(root.right, res) return res"},{"question":"# Coding Challenge: Merge Two Sorted Linked Lists Objective You are given two singly linked lists, each of which is sorted in ascending order. Your task is to write an algorithm to merge these two lists into a single sorted linked list. The merged linked list should also be sorted in ascending order. Requirements - Your solution must effectively handle edge cases. - The performance of your algorithm is crucial. Aim for a time complexity of O(n + m) where n and m are the lengths of the two lists. - Aim for an in-place merge, optimizing for space complexity O(1). Input - You are provided with the heads of two singly linked lists, `l1` and `l2`. Output - Return the head of the merged singly linked list. Constraints - The number of nodes in both linked lists is in the range `[0, 10^4]`. - The linked lists themselves have nodes with integer values. - The nodes in each linked list are sorted in ascending order. Example ```python # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_lists(l1, l2): :type l1: ListNode :type l2: ListNode :rtype: ListNode # Implement your solution here pass # Example: # l1: 1 --> 3 --> 5 # l2: 2 --> 4 --> 6 # merge_lists(l1, l2) should return 1 --> 2 --> 3 --> 4 --> 5 --> 6 ``` **Hints**: - Consider using a dummy node to simplify the merging process. - Traverse both lists simultaneously, linking nodes in ascending order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_lists(l1, l2): Merge two sorted linked lists and return the new sorted list. :type l1: ListNode :type l2: ListNode :rtype: ListNode dummy = ListNode(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"# Question: Implement the `__pow__` Method for the Polynomial Class You are tasked with enhancing the capabilities of the `Polynomial` class by adding a new method to support exponentiation. Specifically, you should implement the `__pow__` method to allow raising a polynomial to an integer power. This involves careful considerations of the arithmetic properties of polynomials and monomials. A proper implementation should handle both positive and zero powers. Function Specification * **Method Signature**: ```python def __pow__(self, power: int) -> Polynomial: ``` * **Inputs**: - `self`: The instance of the `Polynomial` class. - `power`: An integer representing the exponent to which the polynomial should be raised. * **Outputs**: - Returns a new `Polynomial` representing the original polynomial raised to the given power. * **Constraints**: - The power parameter must be a non-negative integer (( n geq 0 )). - You may assume `Polynomial` and `Monomial` classes have already been defined with all necessary operator overloading and utility methods. Example ```python # Example usage poly = Polynomial([Monomial({1: 1}, 2), Monomial({2: 1}, 3)]) result_poly = poly ** 2 print(result_poly) # Expected Output # (4(a_1)^2 + 12(a_1)(a_2) + 9(a_2)^2) ``` Notes: 1. You should raise `ValueError` if `power` is not a non-negative integer. 2. The implementation should handle multiplication correctly per polynomial arithmetic rules. 3. Consider edge cases such as raising to power of 0, which should return a `Polynomial` equivalent to 1.","solution":"class Polynomial: def __init__(self, coefficients): coefficients is a list of coefficients, where the index represents the corresponding power of x. For example, [1, 2, 3] represents the polynomial 1 + 2x + 3x^2. self.coefficients = coefficients def __pow__(self, power: int): if not isinstance(power, int) or power < 0: raise ValueError(\\"Power must be a non-negative integer.\\") # A polynomial raised to the power of 0 is 1 (which we represent by [1]) if power == 0: return Polynomial([1]) result = Polynomial(self.coefficients) for _ in range(1, power): result = result * self return result def __mul__(self, other): # To multiply two polynomials if not isinstance(other, Polynomial): raise ValueError(\\"Can only multiply by another Polynomial\\") result_coefficients = [0] * (len(self.coefficients) + len(other.coefficients) - 1) for self_power, self_coeff in enumerate(self.coefficients): for other_power, other_coeff in enumerate(other.coefficients): result_coefficients[self_power + other_power] += self_coeff * other_coeff return Polynomial(result_coefficients) def __eq__(self, other): return self.coefficients == other.coefficients def __repr__(self): return \\"Polynomial(\\" + str(self.coefficients) + \\")\\""},{"question":"# Advanced Matrix Question You are required to implement matrix multiplication and matrix exponentiation efficiently for solving a problem in computer graphics transformations. Problem Statement: You are given two essential functions: 1. `multiply(matA: list, matB: list) -> list`: Multiplies two matrices A and B. 2. `identity(n: int) -> list`: Creates an identity matrix of size n x n. 3. `matrix_exponentiation(mat: list, n: int) -> list`: Exponentiates matrix mat to the power n using repeated squaring. Function to Implement You need to implement the following function: ```python def transform_point(matrix: list, point: list, power: int) -> list: Applies the transformation matrix raised to the given power to the point. Parameters: matrix (list): A 2D list representing the transformation matrix of size 2x2. point (list): A list representing the point as [x, y]. power (int): The exponent to which the transformation matrix is raised. Returns: list: A list representing the transformed point as [x\', y\']. ``` Input: * `matrix`: A 2x2 transformation matrix. * `point`: A two-dimensional point `[x, y]`. * `power`: A non-negative integer. Output: * A transformed point `[x\', y\']` after applying the transformation matrix raised to the given power. Constraints: * The `matrix` will always be of size 2x2. * The `point` will always be a list containing two integers. * `power` will be a non-negative integer. Example: ```python matrix = [ [2, 0], [0, 2] ] point = [1, 2] power = 3 # Applying transformation matrix to the power 3 on point [1, 2]: # First we compute: matrix^3 = [[8, 0], [0, 8]] # Then applying on point [1, 2], resulting in [8*1 + 0*2, 0*1 + 8*2] = [8, 16] assert transform_point(matrix, point, power) == [8, 16] ``` Note: * Make sure to handle the edge cases like `power = 0` or `power = 1`. * The function should leverage efficient matrix exponentiation for large powers.","solution":"def multiply(matA, matB): Multiplies two 2x2 matrices. return [ [ matA[0][0] * matB[0][0] + matA[0][1] * matB[1][0], matA[0][0] * matB[0][1] + matA[0][1] * matB[1][1] ], [ matA[1][0] * matB[0][0] + matA[1][1] * matB[1][0], matA[1][0] * matB[0][1] + matA[1][1] * matB[1][1] ] ] def identity(n): Creates an identity matrix of size n x n. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_exponentiation(mat, n): Returns matrix `mat` raised to the power `n` using repeated squaring. res = identity(len(mat)) base = mat while n > 0: if n % 2 == 1: res = multiply(res, base) base = multiply(base, base) n //= 2 return res def transform_point(matrix, point, power): Applies the transformation matrix raised to the given power to the point. Parameters: matrix (list): A 2D list representing the transformation matrix of size 2x2. point (list): A list representing the point as [x, y]. power (int): The exponent to which the transformation matrix is raised. Returns: list: A list representing the transformed point as [x\', y\']. if power == 0: return point # No transformation needed elif power == 1: transformed_matrix = matrix else: transformed_matrix = matrix_exponentiation(matrix, power) x, y = point x_new = transformed_matrix[0][0] * x + transformed_matrix[0][1] * y y_new = transformed_matrix[1][0] * x + transformed_matrix[1][1] * y return [x_new, y_new]"},{"question":"**Problem Statement**: You are given a list of integers `lst` and a threshold integer `N`. Your task is to implement a function `filter_list(lst, N)` that constructs and returns a new list where each distinct element from `lst` appears at most `N` times, while preserving the original order. # Input: - `lst`: A list of integers (1 <= len(lst) <= 100,000). - `N`: An integer (1 <= N <= 100). # Output: - A list of integers with the constraints applied. # Constraints: - Elements should preserve their original order in the input list. - Each element in the resulting list should not appear more than `N` times. # Examples: ```python # Example 1: lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 # Output should be: # [1, 2, 3, 1, 2, 3] # Example 2: lst = [20, 37, 20, 21] N = 1 # Output should be: # [20, 37, 21] ``` # Function Signature: ```python def filter_list(lst, N): # your code here pass ``` # Additional Notes: - Ensure your implementation is efficient for large lists. - Think carefully about possible edge cases and ensure your solution handles them gracefully.","solution":"def filter_list(lst, N): Filters the list so each element appears at most N times, preserving the original order. :param lst: List of integers (1 <= len(lst) <= 100,000). :param N: Maximum times each distinct element can appear (1 <= N <= 100). :return: A filtered list with each element appearing at most N times. from collections import defaultdict count_dict = defaultdict(int) result = [] for number in lst: if count_dict[number] < N: result.append(number) count_dict[number] += 1 return result"},{"question":"**Objective**: Implement a function to generate all unique permutations of a given list of numbers. Problem Description: You are given a collection of distinct and duplicate numbers as a list. Your task is to write a function that returns all possible unique permutations of the given list. Function Signature: ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` **Input**: - `nums`: A list of integers, which may include duplicates. **Output**: - A list of lists, where each sublist is a unique permutation of the input list. Constraints: - The input list can have a maximum of 10 elements. - The elements in the list are integers within the range `-10` to `10`. Examples: 1. Input: `[1,1,2]` Output: `[[1,1,2], [1,2,1], [2,1,1]]` 2. Input: `[1,2,3]` Output: `[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]` 3. Input: `[2,2,2]` Output: `[[2, 2, 2]]` Performance Requirements: - Your solution should efficiently handle the constraints and avoid redundant computations by correctly managing duplicates. Scenario: Imagine you are working on a project to generate test cases for a sorting algorithm. You need to ensure all possible orderings of the input list are tested. However, to save time and computational resources, you must avoid testing redundant cases that result from duplicate numbers. Implementing this function will help your project generate a minimal and comprehensive set of test cases. **Note**: You must not use any libraries or functions that directly solve the problem (e.g., `itertools.permutations`).","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(first=0): # if all integers are used up if first == n: perm = nums[:] if perm not in output: output.append(perm) for i in range(first, n): # skip duplicates if i != first and nums[i] == nums[first]: continue # place i-th integer first in the current permutation nums[first], nums[i] = nums[i], nums[first] # use next integers to complete the permutations backtrack(first + 1) # backtrack nums[first], nums[i] = nums[i], nums[first] # sort the array (necessary to detect duplicates) nums.sort() n = len(nums) output = [] backtrack() return output"},{"question":"Ternary Search Application You are tasked with implementing a function that uses ternary search to find an element in a sorted array. Your function should follow the principles of the ternary search algorithm, as analyzed above. Function Signature ```python def ternary_search(arr: List[int], left: int, right: int, key: int) -> int: pass ``` Input - `arr`: A list of integers sorted in ascending order. (1 <= len(arr) <= 10^5) - `left`: An integer representing the left index from where to start the search (0 <= left < len(arr)). - `right`: An integer representing the right index where to end the search (0 <= right < len(arr)). - `key`: An integer representing the value to search for in the array. Output - Returns an integer representing the index of the `key` in the array if found, otherwise returns -1. Constraints - You should ensure that your solution has a time complexity of O(log3(N)). - The array is guaranteed to be sorted in ascending order. Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert ternary_search(arr, 0, len(arr)-1, 5) == 4 # Example 2 arr = [10, 22, 30, 42, 55, 66, 78] assert ternary_search(arr, 0, len(arr)-1, 22) == 1 # Example 3 arr = [3, 5, 7, 9, 11, 14, 20] assert ternary_search(arr, 0, len(arr)-1, 8) == -1 ``` Clarifications - You may assume that all inputs are valid according to the constraints described. - The function should only return the first occurrence of the element found. Develop your function to ensure it can efficiently and correctly determine the position of a given key within a sorted array.","solution":"from typing import List def ternary_search(arr: List[int], left: int, right: int, key: int) -> int: Uses ternary search to find the index of key in the sorted list arr. If the key is found, returns its index. Otherwise, returns -1. while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Graph Pathfinding Challenge Objective Implement a function to find the longest path between two nodes in a directed acyclic graph (DAG). The function should explore all possible paths and return the one with the maximum length. Problem Statement Given a graph represented as an adjacency list, implement a function `find_longest_path(graph, start, end)` that finds the longest path from the starting node `start` to the target node `end`. Input * `graph`: A dictionary where keys are nodes and values are lists of adjacent nodes. * `start, end`: The starting and ending nodes for the path finding. Output * Return a list of nodes representing the longest path from `start` to `end`. If no path exists, return an empty list. Constraints * The graph is guaranteed to be a Directed Acyclic Graph (DAG). * The number of nodes n is such that 1 <= n <= 1000. * Assume all node values are unique. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\', \'E\'], \'D\': [\'E\'], \'E\': [] } start = \'A\' end = \'E\' assert find_longest_path(graph, start, end) == [\'A\', \'B\', \'C\', \'D\', \'E\'] ``` Notes * Think about how to modify existing pathfinding algorithms to keep track of the longest paths. * Consider implementing a recursive approach with suitable base cases to handle the termination of paths. Solution Template ```python def find_longest_path(graph, start, end, path=[]): Find the longest path between two nodes in a DAG. path = path + [start] if start == end: return path if start not in graph: return [] longest = [] for node in graph[start]: if node not in path: newpath = find_longest_path(graph, node, end, path) if len(newpath) > len(longest): longest = newpath return longest ```","solution":"def find_longest_path(graph, start, end, path=None): Find the longest path between two nodes in a DAG. Args: - graph (dict): A dictionary where keys are nodes and values are lists of adjacent nodes. - start: The starting node for the pathfinding. - end: The target node for the pathfinding. - path (list, optional): The current path being explored. Returns: - list: A list of nodes representing the longest path from start to end. If no path exists, return an empty list. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return [] longest = [] for node in graph[start]: if node not in path: newpath = find_longest_path(graph, node, end, path) if len(newpath) > len(longest): longest = newpath return longest"},{"question":"You are given the task of calculating the maximum depth (or height) of a Binary Search Tree (BST). The height is defined as the number of levels in the tree. The empty tree has height 0, a tree of one node has height 1, a root node with one or two leaves as children has height 2, and so on. # Function Signature ```python def height(root) -> int: ``` # Input - `root` (Node): The root node of the BST. The Node class is defined with attributes `value`, `left`, and `right`. # Output - `int`: The height of the tree. # Examples Consider the following tree structure: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` For this tree, the height is `4`. # Constraints - You may assume that the tree does not contain any duplicate values. - The tree can be highly unbalanced. - The number of nodes, N, in the tree may be as large as 10^5. # Performance Requirements - Ensure your solution handles very deep BSTs efficiently. If using recursion, be aware of potential stack overflow issues. # Implementation Requirements Implement the function `height` as specified. Ensure that you handle edge cases such as an empty tree and a very deep tree. Write accompanying test cases to demonstrate the correctness of your solution. # Example Test Case ```python import unittest class TestTreeHeight(unittest.TestCase): def setUp(self): self.tree = bst() # Assume bst() initializes an empty BST and has an insert method self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_tree_height(self): self.assertEqual(height(self.tree.root), 4) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def height(root) -> int: Returns the height of the binary search tree with the given root node. if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Single Number II - Coding Challenge Objective You are given an array of integers `nums` where every element appears exactly three times except for one which appears only once. Your task is to find and return the element that appears only once. Write a function named `find_single_number` that implements this logic with a linear time complexity, O(n), and constant space complexity, O(1). # Function Signature: ```python def find_single_number(nums: list) -> int: pass ``` # Input * `nums`: A list of integers where each integer appears exactly three times except for one integer which appears exactly one time. **Constraints**: * The length of `nums` is in the range [3, 3 * 10^4]. * Each element in `nums` is within the range of a 32-bit signed integer. # Output * Returns an integer that appears exactly once in the list. # Example ```python # Example 1: input = [2, 2, 3, 2] output = 3 # Example 2: input = [0, 1, 0, 1, 0, 1, 99] output = 99 ``` # Requirements * Your algorithm should run in O(n) time complexity. * You must use constant space complexity, O(1). # Performance * Use bitwise logic to achieve the desired performance constraints. * Avoid auxiliary data structures such as dictionaries or additional arrays. # Additional Notes * Think about how bits are represented in integers and how bitwise operations can help keep track of the count of every bit position. Good luck!","solution":"def find_single_number(nums): Finds the number that appears exactly once while every other number appears three times. Args: nums (list): List of integers where every integer except one appears three times. Returns: int: The integer that appears exactly once. x1 = x2 = mask = 0 for num in nums: x2 ^= x1 & num # Add num to x2 if it\'s in x1 but not yet in x2 x1 ^= num # Add num to x1 if it\'s not already in x1 mask = ~(x1 & x2) # If both x1 and x2 have a bit set, it has appeared 3 times, clear those bits x1 &= mask # Clear bits in x1 that have appeared 3 times x2 &= mask # Clear bits in x2 that have appeared 3 times return x1 # The answer will be in x1"},{"question":"Extended Euclidean Algorithm Application **Context:** The extended Euclidean algorithm helps find coefficients for linear combinations of two integers that result in their GCD. This has practical applications, including solving linear Diophantine equations and calculating modular multiplicative inverses. **Problem Description:** You are tasked to implement a function `find_mod_inv` that, given two integers (a) and (m), returns the modular multiplicative inverse of (a) under modulo (m). The modular multiplicative inverse of an integer (a) with respect to (m) is an integer (x) such that: [ (a times x) mod m = 1 ] If no such integer exists, return `None`. **Input:** 1. An integer (a) (0 ( leq a < 10^9)). 2. An integer (m) (0 < ( m < 10^9)). **Output:** - An integer representing (a)‘s modular multiplicative inverse under (m), or `None` if no such inverse exists. **Constraints:** - The function should handle the case where ( text{GCD}(a, m) neq 1 ) by returning `None` since that implies no modular inverse exists. - Ensure the time complexity is efficient given large inputs. **Function Signature:** ```python def find_mod_inv(a: int, m: int) -> Optional[int]: pass ``` **Example:** ```python print(find_mod_inv(3, 11)) # Output: 4, since 3 * 4 % 11 == 1 print(find_mod_inv(10, 20)) # Output: None, since GCD(10, 20) != 1 ``` Implement this function with your understanding of the extended Euclidean algorithm.","solution":"from typing import Optional def find_mod_inv(a: int, m: int) -> Optional[int]: def extended_gcd(aa, bb): last_remainder, remainder = abs(aa), abs(bb) x, last_x, y, last_y = 0, 1, 1, 0 while remainder: last_remainder, (quotient, remainder) = remainder, divmod(last_remainder, remainder) x, last_x = last_x - quotient * x, x y, last_y = last_y - quotient * y, y return last_remainder, last_x * (-1 if aa < 0 else 1), last_y * (-1 if bb < 0 else 1) gcd, x, y = extended_gcd(a, m) if gcd != 1: return None # Modular inverse doesn\'t exist if a and m are not coprime else: return x % m # x might be negative, so get the positive equivalent with x % m"},{"question":"You are given an integer `n` and are required to generate the hailstone sequence starting from `n` until you reach 1. Additionally, you should implement a function that calculates the total number of steps required to reach 1 and the maximum value encountered in the sequence. Function Signature ```python def hailstone_analysis(n: int) -> Tuple[List[int], int, int]: ``` Input * `n` (1 ≤ n ≤ 10^6): The starting point of the hailstone sequence. Output * A tuple containing: 1. The hailstone sequence as a list. 2. An integer representing the total number of steps to reach 1. 3. An integer representing the maximum value encountered in the sequence. Constraints * Ensure the function runs efficiently for large values of n. * You may assume `n` is always a positive integer. Example ```python hailstone_analysis(7) ``` Output: ```python ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 16, 52) ``` Explanation The function starts with 7. The sequence generated is `[7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]` which takes 16 steps to reach 1 and the maximum value encountered is 52.","solution":"from typing import List, Tuple def hailstone_analysis(n: int) -> Tuple[List[int], int, int]: sequence = [] steps = 0 max_val = n while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 max_val = max(max_val, n) steps += 1 sequence.append(1) return sequence, steps, max_val"},{"question":"# Histogram Generation Function Context Histograms are widely used in data analysis for providing a visual representation of the distribution of a dataset. Your task is to write a function that generates the histogram of a given list of numbers. Problem Statement Write a function `histogram(lst: List[int]) -> Dict[int, int]` that takes a list of integers and returns a dictionary representing the histogram of the list. Requirements 1. **Input**: A list `lst` of integers where `1 <= len(lst) <= 10^5` and `-10^5 <= lst[i] <= 10^5`. 2. **Output**: A dictionary where the keys are integers from the list and the values are their counts. 3. The function must run efficiently with a time complexity of O(n). 4. Handle edge cases such as empty lists and lists with all identical or all unique elements. Sample Inputs and Outputs ```python # Sample Input 1: lst = [3, 3, 2, 1] # Sample Output 1: # {1: 1, 2: 1, 3: 2} # Sample Input 2: lst = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Sample Output 2: # {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Sample Input 3: lst = [] # Sample Output 3: # {} # Sample Input 4: lst = [1, 1, 1, 1, 1] # Sample Output 4: # {1: 5} # Sample Input 5: lst = [4, 3, -2, 1, 99999, -100000] # Sample Output 5: # {4: 1, 3: 1, -2: 1, 1: 1, 99999: 1, -100000: 1} ``` Constraints 1. The input list will have at least one and at most 100,000 integers. 2. Each integer in the list will be in the range from -100,000 to 100,000. Your Task Implement the function `histogram(lst: List[int]) -> Dict[int, int]` to meet the requirements above.","solution":"from typing import List, Dict def histogram(lst: List[int]) -> Dict[int, int]: Generates a histogram dictionary from a list of integers. Parameters: lst (List[int]): A list of integers. Returns: Dict[int, int]: A dictionary where keys are integers from the list and values are their counts. hist = {} for num in lst: if num in hist: hist[num] += 1 else: hist[num] = 1 return hist"},{"question":"You are given a singly linked list. Write a python function that finds the first node of the cycle in it, if such a cycle exists. If there is no cycle, return `None`. # Function Signature: ``` def first_cyclic_node(head: Node) -> Node: ``` # Input: - `head` (Node): The head node of the singly linked list. # Output: - `Node`: The node where the cycle begins, or `None` if no cycle is present. # Constraints: - The linked list can have 0 or more nodes. - The `Node` class is already defined and has a `val` attribute and a `next` attribute. # Example: Example 1: ```python # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle starts at node with value 1) head = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) head.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = head # Cycle here result = first_cyclic_node(head) # Output: head (Node with value 1, where cycle starts) ``` Example 2: ```python # Input: A -> B -> C -> D -> E -> C (cycle starts at node with value \'C\') head = Node(\'A\') nodeB = Node(\'B\') nodeC = Node(\'C\') nodeD = Node(\'D\') nodeE = Node(\'E\') head.next = nodeB nodeB.next = nodeC nodeC.next = nodeD nodeD.next = nodeE nodeE.next = nodeC # Cycle here result = first_cyclic_node(head) # Output: nodeC (Node with value \'C\', where cycle starts) ``` # Notes: - You can assume that the linked list is correctly formed. - Do not use any extra space; try to solve it using Floyd\'s Cycle Finding algorithm which ensures O(1) space complexity.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def first_cyclic_node(head: Node) -> Node: Detects the first node of the cycle in the linked list if a cycle exists. If no cycle is found, returns None. if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"**Objective**: Implement a function `is_probably_prime` using the Rabin-Miller Primality Test, which returns `True` if a given number `n` is \'probably\' prime, with a probability of error being `4 ** -k`. Otherwise, the function should return `False`. # Detailed Requirements - Implement the function `is_probably_prime(n, k)`: - `n` (integer): The number to be tested for primality (n >= 2). - `k` (integer): Number of trials for accuracy. # Input - An integer `n` that is at least 2. - An integer `k` indicating the number of accuracy trials. # Output - Boolean: `True` if `n` is probably prime, `False` if `n` is composite. # Constraints - 2 <= `n` <= 10^18 - 1 <= `k` # Performance Requirements - The function should handle inputs up to 10^18 efficiently. - The probability of error should be minimized with the given `k` trials. # Implementation Hint Utilize modular exponentiation and the power factorization method to simplify n-1 into components that can be tested with the Rabin-Miller witness process. # Example ```python def is_probably_prime(n, k): import random if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False def pow2_factor(num): power = 0 while num % 2 == 0: num //= 2 power += 1 return power, num def valid_witness(a, r, d, n): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True r, d = pow2_factor(n - 1) for _ in range(k): a = random.randint(2, n - 2) if valid_witness(a, r, d, n): return False return True # Example usage: print(is_probably_prime(31, 5)) # Outputs: True print(is_probably_prime(15, 5)) # Outputs: False ``` # Notes - Ensure to handle all edge cases, such as even numbers greater than 2 and very large values of `n`. - Consider performance optimizations where applicable, without compromising the accuracy of the results.","solution":"import random def is_probably_prime(n, k): Returns True if n is probably prime, False if n is composite. `k` is the number of accuracy trials. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False def pow2_factor(num): power = 0 while num % 2 == 0: num //= 2 power += 1 return power, num def valid_witness(a, r, d, n): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True r, d = pow2_factor(n - 1) for _ in range(k): a = random.randint(2, n - 2) if valid_witness(a, r, d, n): return False return True"},{"question":"# Word Pattern Matching **Context:** You are tasked with implementing a function that determines if a given string follows a specified pattern. This is a common scenario in text processing, template validation, and sequence verification tasks where pattern compliance is essential. **Objective:** Write a function `does_follow_pattern(pattern: str, str: str) -> bool` that checks whether the provided string follows the given pattern. It needs to ensure a bijective (one-to-one and onto) match between the pattern characters and the words in the string. **Function Signature:** ```python def does_follow_pattern(pattern: str, str: str) -> bool: pass ``` **Input:** * `pattern` (str): A string containing only lowercase letters. * `str` (str): A string containing lowercase words separated by single spaces. **Output:** * `bool`: Return `True` if the string follows the pattern, otherwise return `False`. **Constraints:** * Assume pattern contains only lowercase letters (a-z). * Assume the input string contains lowercase words separated by single spaces. * The length of the pattern and the number of words in the string will be at most 1000. **Examples:** 1. `pattern = \\"abba\\", str = \\"dog cat cat dog\\"` should return `True`. 2. `pattern = \\"abba\\", str = \\"dog cat cat fish\\"` should return `False`. 3. `pattern = \\"aaaa\\", str = \\"dog cat cat dog\\"` should return `False`. 4. `pattern = \\"abba\\", str = \\"dog dog dog dog\\"` should return `False`. **Explanation:** * Example 1: Pattern `abba` corresponds perfectly to `dog cat cat dog`. * Example 2: The first `a` maps to `dog`, the first `b` maps to `cat`, but the second `b` maps to `fish` which violates the previously established map. * Example 3: All `a`s cannot map to multiple different words. * Example 4: All the words are `dog` which contradicts having different mappings for `a` and `b`. **Notes:** * Validate the length of pattern and sentence split before proceeding with mapping. * Ensure no pattern character or word violates the bijection rule. * Think about edge cases like empty strings or patterns with single characters.","solution":"def does_follow_pattern(pattern: str, string: str) -> bool: words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"You\'ve learned various techniques to reverse a string. Now, let\'s put your understanding to the test. Implement an efficient string reversal function that: 1. Ensures minimal time and space complexity. 2. Handles edge cases, such as empty strings, single-character strings, and strings with special characters. The function signature should be: ```python def reverse_string(s: str) -> str: \\"\\" Reverses the string using efficient algorithms. Parameters: s (str): The string to reverse. Returns: str: The reversed string. \\"\\" ``` # Constraints * Input string length should not exceed 10^6 characters. * You are encouraged to use the most efficient approach discussed but you should strive for a solution that would work well even if those native methods were unavailable. # Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"Python\\") == \\"nohtyP\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"!@#\\") == \\"#@!\\" ``` # Guidelines * Focus on writing a clear and efficient equivalent to Python’s built-in methods. * Consider edge cases and make sure your solution does not fail for inputs with special characters and whitespace. * Avoid string concatenation in loops as it can be inefficient for large strings.","solution":"def reverse_string(s: str) -> str: Reverses the string using efficient algorithms. Parameters: s (str): The string to reverse. Returns: str: The reversed string. return s[::-1]"},{"question":"# Sorting a Sequence with Bitonic Sort You have been given the task of implementing the Bitonic Sort algorithm to order a sequence of numbers. The Bitonic Sort algorithm merges sorted subsequences (called bitonic sequences) recursively. **Function Signature**: ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers of length ( n ), where ( n ) is a power of two. - `reverse`: A boolean indicating the order of sorting. Default value is `False`. If `True`, the function sorts in descending order; if `False`, it sorts in ascending order. # Output - The function should return a new list of integers sorted according to the specified order. # Constraints - The length of `arr` is always a power of two. - ( 1 leq n leq 2^{10} ) - ( -10^6 leq arr[i] leq 10^6 ) for any integer element in `arr`. # Example ```python assert bitonic_sort([3, 7, 2, 1, 5, 4, 6, 8], False) == [1, 2, 3, 4, 5, 6, 7, 8] assert bitonic_sort([3, 7, 2, 1, 5, 4, 6, 8], True) == [8, 7, 6, 5, 4, 3, 2, 1] ``` # Note - Be careful with the base cases in your recursive calls. - Ensure your implementation raises an error if the input length is not a power of two. - Consider edge cases like arrays with identical elements or already sorted arrays. Good luck, and happy coding!","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Sorts a list of integers using the Bitonic Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. reverse (bool): Sort order. Default is ascending (False). Returns: List[int]: The sorted list of integers. def compare_and_swap(arr, i, j, ascending): if (arr[i] > arr[j]) == ascending: arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, ascending): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, ascending) bitonic_merge(arr, low, k, ascending) bitonic_merge(arr, low + k, k, ascending) def bitonic_sort_recursive(arr, low, cnt, ascending): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, ascending) # Verify that the length of `arr` is a power of two n = len(arr) if n & (n - 1) != 0: raise ValueError(\\"The length of the input list must be a power of two.\\") # Create a copy of the array to avoid in-place modifications sorted_arr = arr.copy() bitonic_sort_recursive(sorted_arr, 0, n, not reverse) return sorted_arr"},{"question":"Your task is to implement a function `format_license_key(key: str, k: int) -> str` which reads a given alphanumeric license string and re-formats it so that alphanumeric characters are grouped into fixed-size segments. The function does the following: 1. It removes all the dashes (`-`) from the input string. 2. Groups the resulting characters from right to left into groups of `k`. 3. Inserts a dash (`-`) between each group. 4. Maintains upper or lower casing of original characters. # Input * `key`: A string consisting of alphanumeric characters and dashes. * `k`: An integer representing the group size. # Output * Returns a formatted string with alphanumeric characters grouped by the size `k` and dashes in between groups. # Constraints * The length of the string `key` will be in the range `[1, 1000]`. * `k` is a positive integer. # Example ```python assert format_license_key(\\"2-5g-3-J\\", 2) == \\"2-5G-3J\\" assert format_license_key(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" assert format_license_key(\\"a-bC-Def\\", 1) == \\"A-B-C-D-E-F\\" assert format_license_key(\\"A\\", 1) == \\"A\\" assert format_license_key(\\"-----\\", 2) == \\"\\" ``` # Guidelines Consider both edge cases like only dashes in input or segment sizes where `k` greater than the length of the alphanumeric content. Focus on clean, efficient code.","solution":"def format_license_key(key: str, k: int) -> str: # Remove all dashes and convert to uppercase key = key.replace(\'-\', \'\').upper() # Initialize the result string n = len(key) result = [] # Process the key string in reverse order for i in range(n): if i > 0 and i % k == 0: result.append(\'-\') result.append(key[n - 1 - i]) # Join the result and reverse it back to the correct order return \'\'.join(result[::-1])"},{"question":"# Question: Refactored Insertion Sort with Binary Insertion You are asked to optimize the insertion sort algorithm by reducing the number of comparisons while finding the position to insert the current element. Implement this by using binary search to determine the correct insertion position. Function Signature ```python def binary_insertion_sort(arr: list) -> list: Sorts the input list using an optimized insertion sort algorithm employing binary search to find insertion points. Args: - arr (list): A list of comparable elements to be sorted. Returns: - list: The sorted list in non-decreasing order. pass ``` Input - `arr`: A list of comparable elements (e.g., integers, floats, strings). Output - A sorted list in non-decreasing order. Constraints - The function should run in O(n^2) time complexity in the worst case. - The algorithm must maintain the stability of the input list. Performance Requirements - The implementation should use binary search to optimize the insertion point search. Example ```python >>> binary_insertion_sort([12, 11, 13, 5, 6]) [5, 6, 11, 12, 13] >>> binary_insertion_sort([\'banana\', \'apple\', \'cherry\', \'date\']) [\'apple\', \'banana\', \'cherry\', \'date\'] ``` Edge Cases - Handle empty list `[]` and single-element list `[x]`. - Lists with duplicate values must retain their relative positions in the sorted output. **Hints**: 1. Implement a helper function for binary search. 2. Use this helper function to find the position at which to insert the current element during the iteration.","solution":"def binary_search(arr, val, start, end): Helper function to perform binary search on the sorted part of the array. if start == end: if arr[start] > val: return start else: return start + 1 elif start > end: return start mid = (start + end) // 2 if arr[mid] < val: return binary_search(arr, val, mid + 1, end) elif arr[mid] > val: return binary_search(arr, val, start, mid - 1) else: return mid def binary_insertion_sort(arr): Sorts the input list using an optimized insertion sort algorithm employing binary search to find insertion points. for i in range(1, len(arr)): val = arr[i] j = binary_search(arr, val, 0, i - 1) arr = arr[:j] + [val] + arr[j:i] + arr[i + 1:] return arr"},{"question":"Your task is to implement a function that sorts an array of integers using a more efficient sorting algorithm. Bubble Sort is simple but inefficient for larger datasets due to its O(N^2) time complexity. This challenge will help you practice implementing a sorting algorithm that is more efficient. # Requirements 1. **Function Name**: `insertion_sort` 2. **Input**: * A list of integers, `arr` (1 <= len(arr) <= 10^4). 3. **Output**: * A list of integers sorted in non-decreasing order. 4. **Constraints**: * You must not use Python\'s built-in sorting functions. * The algorithm should avoid excessive time complexity and work efficiently for the given constraints. # Example ```python def insertion_sort(arr): # Your code here # Example usage arr = [5, 2, 9, 1, 5, 6] sorted_arr = insertion_sort(arr) print(sorted_arr) # Output: [1, 2, 5, 5, 6, 9] ``` # Explanation - Your function, `insertion_sort`, should implement the insertion sort algorithm. - **Steps**: 1. Iterate from the second element to the last element. 2. For each element in the iteration, compare it to its predecessor. 3. If the current element is smaller than its predecessor, compare it to the elements before and insert it into its correct position. - The resulting list after sorting should be returned. # Notes * Consider edge cases such as empty lists, a list with one element, and lists that are already in sorted order. * Ensure your implementation works efficiently for up to 10,000 elements.","solution":"def insertion_sort(arr): Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list): A list of integers. Returns: list: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Prime Number Check **Objective** You need to implement a function `prime_check` to determine if a given integer `n` is a prime number. **Function Signature** ```python def prime_check(n: int) -> bool: Determine if `n` is a prime number. :param n: An integer number to check for primality. :return: True if `n` is a prime number, otherwise False. ``` **Input** - A single integer `n` (where ( -10^9 leq n leq 10^9 )). **Output** - Returns a boolean value: - `True` if `n` is a prime number. - `False` otherwise. **Constraints** - The function should be efficient enough to handle the upper bounds of input constraints. **Example** ```python assert prime_check(1) == False assert prime_check(2) == True assert prime_check(17) == True assert prime_check(18) == False assert prime_check(-3) == False assert prime_check(0) == False ``` **Explanation** 1. If `n` is less than or equal to 1, return `False`. 2. If `n` is exactly 2 or 3, return `True` because these are the smallest prime numbers. 3. If `n` is divisible by 2 or 3, return `False`. 4. Use a loop starting from 5 and increment by 6 in each iteration to check divisibility up to the square root of `n`. **Edge Cases** 1. Negative numbers and zero should return `False`. 2. The function should handle small prime numbers accurately (e.g., 2, 3). 3. The function should accurately determine the primality of large numbers close to the upper limit of the constraint. Write a solution implementing the described steps and constraints.","solution":"import math def prime_check(n: int) -> bool: Determine if `n` is a prime number. :param n: An integer number to check for primality. :return: True if `n` is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"**Scenario**: You are working for a company that provides search functionality for a large text repository. Your task is to optimize the search operations by implementing the Knuth-Morris-Pratt (KMP) algorithm. Your solution should efficiently find all occurrences of a given pattern in a text, regardless of its size. **Task**: Write a function `search_pattern` that takes two strings, `text` and `pattern`, and returns a list of starting indices where the pattern is found within the text using the KMP algorithm. **Function Signature**: ```python from typing import List def search_pattern(text: str, pattern: str) -> List[int]: ``` **Input**: * `text`: A string representing the text to search within. (0 <= len(text) <= 10^6) * `pattern`: A string representing the pattern to search for. (0 <= len(pattern) <= 10^5) **Output**: * Return a list of starting indices where the pattern is found within the text. - If the pattern is not found, return an empty list. **Constraints**: * Case sensitivity should be maintained during search. * The function should handle edge cases like empty strings efficiently. **Example**: ```python assert search_pattern(\\"hello there hero!\\", \\"he\\") == [0, 7, 12] assert search_pattern(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] assert search_pattern(\\"abcdef\\", \\"gh\\") == [] assert search_pattern(\\"\\", \\"pat\\") == [] assert search_pattern(\\"text\\", \\"\\") == [] ``` **Performance Requirement**: * Your solution should run in linear time `O(N + M)`. Hint: Use the Knuth-Morris-Pratt (KMP) algorithm to build a partial match table and perform efficient string search.","solution":"from typing import List def kmp_prefix_function(pattern: str) -> List[int]: Builds the prefix function for the KMP algorithm. m = len(pattern) prefix = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = prefix[j - 1] if pattern[i] == pattern[j]: j += 1 prefix[i] = j return prefix def search_pattern(text: str, pattern: str) -> List[int]: Uses the KMP algorithm to find all occurrences of the pattern in the text. if not pattern: return [] n = len(text) m = len(pattern) prefix = kmp_prefix_function(pattern) result = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = prefix[j - 1] if text[i] == pattern[j]: j += 1 if j == m: result.append(i - m + 1) j = prefix[j - 1] return result"},{"question":"# Question: Implementing and Optimizing Exchange Sort Context: You are working on a legacy system that uses an inefficient sorting algorithm known as Exchange Sort. Your task is to improve the sorting functionality by implementing a more efficient sorting algorithm while maintaining the correctness of the sorting task. Task: 1. Implement the provided Exchange Sort algorithm as a baseline for comparison. 2. Replace the Exchange Sort with a more efficient sorting algorithm of your choice. 3. Ensure the improved algorithm handles all potential edge cases and performs efficiently on larger datasets. Function Requirements: 1. **Function Name**: `improved_sort` 2. **Input**: A list of integers `arr` where (1 leq text{len}(arr) leq 10^5). 3. **Output**: A sorted list of integers in ascending order. Constraints: * Ensure the implementation can handle sorting of large datasets efficiently (time complexity should be (O(n log n)) on average or better). Example: ```python def improved_sort(arr): # Implement your improved sorting algorithm here pass # Example Usage: arr = [64, 34, 25, 12, 22, 11, 90] print(improved_sort(arr)) # Expected Output: [11, 12, 22, 25, 34, 64, 90] ``` Notes: * Do not use Python\'s built-in sorting functions (`sorted` or `sort`). * Clearly comment your code to indicate how your chosen algorithm improves upon the provided Exchange Sort. * Consider and handle edge cases such as empty arrays, arrays with one element, or arrays with all identical elements.","solution":"def improved_sort(arr): This function sorts an array of integers in ascending order using the Quick Sort algorithm. Quick Sort is chosen due to its average-case time complexity of O(n log n), which is suitable for handling large datasets efficiently. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return improved_sort(left) + middle + improved_sort(right)"},{"question":"Write a function that takes a list of integers and a target endianness (\\"big\\" or \\"little\\"), and converts each integer in the list to a byte representation using the specified endianness. Then, convert these byte representations back into integers and return a list of the results. You need to ensure that the conversion and re-conversion processes are accurate and efficient. Function Signature: ```python def convert_and_revert_integers(int_list: list[int], endianness: str) -> list[int]: pass ``` Input: - `int_list`: A list of positive integers (0 ≤ integer ≤ 2^64 - 1). - `endianness`: A string that can be either \\"big\\" for big-endian or \\"little\\" for little-endian. Output: - A list of integers that were converted to byte arrays and then back to integers. Constraints: - The list of integers could be empty. - You must handle the conversion accurately regardless of the list size. - Ensure that the time complexity of the function remains efficient (O(n) for the length of the list). Performance Requirements: - Your solution should be optimized for handling large lists efficiently in both time and space. Example: ```python >>> convert_and_revert_integers([1, 256, 65536], \\"big\\") [1, 256, 65536] >>> convert_and_revert_integers([1, 256, 65536], \\"little\\") [1, 256, 65536] >>> convert_and_revert_integers([4294967296, 18446744073709551615], \\"big\\") [4294967296, 18446744073709551615] ``` Notes: - If any integer in the list is converted incorrectly, ensure to handle and reflect that in the output as accurately as possible. - Provide efficient and clean code with proper justification of any optimizations.","solution":"def convert_and_revert_integers(int_list: list[int], endianness: str) -> list[int]: Converts a list of integers to their byte representation using the specified endianness, and converts them back to integers. Parameters: int_list (list[int]): List of positive integers endianness (str): The target endianness (\\"big\\" or \\"little\\") Returns: list[int]: List of integers after conversion to byte representation and back result = [] for num in int_list: # Determine the number of bytes needed to represent the integer num_bytes = (num.bit_length() + 7) // 8 or 1 # Convert integer to bytes byte_repr = num.to_bytes(num_bytes, byteorder=endianness) # Convert back from bytes to integer reverted_num = int.from_bytes(byte_repr, byteorder=endianness) result.append(reverted_num) return result"},{"question":"You are developing a cryptographic application and need to efficiently compute multiplicative inverses in modular arithmetic. To do this, you will use the extended Euclidean algorithm to find Bézout\'s coefficients for given numbers. Write a function `find_bezout_coefficients(num1, num2)` that returns a tuple `(s, t, g)` where: - `s` and `t` are the coefficients such that `num1 * s + num2 * t = GCD(num1, num2)`, - `g` is the GCD of `num1` and `num2`. # Input Format - Two integers `num1` and `num2` where (1 leq num1, num2 leq 10^9). # Output Format - A tuple of three integers `(s, t, g)`. # Constraints and Requirements - Ensure that the algorithm handles large input sizes efficiently. - You must use integer division to prevent floating-point inaccuracies. - The function should handle both positive integers only. # Example ```python def find_bezout_coefficients(num1, num2): # Implementation of the function goes here # Example usage: # Example 1 print(find_bezout_coefficients(30, 20)) # Output: (-1, 2, 10) # Explanation: 30 * (-1) + 20 * 2 = 10 # Example 2 print(find_bezout_coefficients(56, 15)) # Output: (-1, 4, 1) # Explanation: 56 * (-1) + 15 * 4 = 1 ``` Implement `find_bezout_coefficients(num1, num2)` to verify your understanding of the extended Euclidean algorithm.","solution":"def find_bezout_coefficients(num1, num2): Finds the Bézout coefficients s and t such that num1 * s + num2 * t = GCD(num1, num2), and returns (s, t, GCD). def extended_gcd(a, b): if a == 0: return (b, 0, 1) gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return (gcd, x, y) gcd, s, t = extended_gcd(num1, num2) return (s, t, gcd)"},{"question":"# Problem: Optimized Merge Sort with In-Place Merging You are required to implement an optimized merge sort algorithm with an in-place merging technique. This will reduce the space complexity of the merge sort algorithm, making it more suitable for systems with limited memory resources. # Function Specification * **Function Name**: `merge_sort_in_place` * **Input**: A list of integers `arr` of length `n` (0 <= n <= 10^5). * **Output**: The sorted list of integers in non-decreasing order. # Constraints: * You should not use any additional lists or large data structures. You can only use a constant amount of extra space. * The function should handle edge cases such as empty arrays, arrays with one element, and arrays with identical elements gracefully. # Example: ```python >>> merge_sort_in_place([3, 1, 2, 4]) [1, 2, 3, 4] >>> merge_sort_in_place([5, 1, 1, 2, 0, 0]) [0, 0, 1, 1, 2, 5] >>> merge_sort_in_place([]) [] ``` # Performance: * The implementation should have a time complexity of O(n log(n)). * The implementation should have a space complexity of O(1) (excluding the call stack). # Guidance: * Write helper functions for the merging step if necessary. * Ensure your implementation avoids unnecessary array copying. Utilize in-place techniques where possible. * Carefully manage and adjust indices to avoid out-of-bounds errors or incorrect sorting.","solution":"def merge_sort_in_place(arr): Sorts the array in place using a modified merge sort algorithm with in-place merging to achieve O(1) space complexity. def merge(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort(arr, left, right): if left < right: mid = (left + right) // 2 merge_sort(arr, left, mid) merge_sort(arr, mid + 1, right) merge(arr, left, mid, right) merge_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Coding Challenge: Digit-Powered Sum Numbers Objective You are given a range of integers. Your task is to identify and return a list of numbers within this range that satisfy a particular mathematical property: The number is equal to the sum of its digits each raised to consecutive powers starting from 1. Detailed Steps 1. Iterate over each number in the specified range. 2. Convert the number into its individual digits. 3. Compute the sum of these digits, each raised to a power consecutively starting from 1. 4. Check if this sum equals the original number. If so, include it in the result. Input Format - `low (int)`: The starting integer of the range. - `high (int)`: The ending integer of the range. Output Format - A list of integers that satisfy the property within the given range. Constraints - `1 <= low <= high <= 10^6` Example ```python def sum_dig_pow(low, high): # Your implementation here # Example Test Case assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Explanation The function `sum_dig_pow(1, 100)` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]` because: - For numbers `1` to `9`, the sum of their digits to the power of their positions equals the number itself. - `89` is included because (8^1 + 9^2 = 89).","solution":"def sum_dig_pow(low, high): Returns a list of numbers within the range [low, high] which are equal to the sum of their digits each raised to consecutive powers starting from 1. result = [] for num in range(low, high + 1): digits = list(map(int, str(num))) powered_sum = sum(digit ** (i + 1) for i, digit in enumerate(digits)) if powered_sum == num: result.append(num) return result"},{"question":"Implement a Secure Communication Setup Using Diffie-Hellman Key Exchange As a cybersecurity student, you are tasked with implementing a secure communication setup using the Diffie-Hellman key exchange protocol. This will involve several steps where you incorporate checks and additional functionalities to ensure a robust implementation. Problem Statement Implement functions to perform a secure Diffie-Hellman key exchange between two parties, Alice and Bob. The functions should include the following components: 1. **Prime Check Algorithm**: Validate if a given number is a prime. 2. **Order Checking Algorithm**: Determine the order of a number `a` modulo `n`. 3. **Euler\'s Totient Function**: Calculate Euler’s totient function for a given `n`. 4. **Primitive Root Finder**: Identify all primitive roots of a given number `n`. 5. **Key Generation and Exchange**: Use the properties above to execute the Diffie-Hellman key exchange securely. Expected Input and Output Formats 1. `is_prime(num: int) -> bool`: - **Input**: A single integer `num`. - **Output**: Boolean indicating whether `num` is a prime. 2. `find_order(a: int, n: int) -> int`: - **Input**: Two integers `a` and `n`. - **Output**: The order of `a` modulo `n`. 3. `euler_totient(n: int) -> int`: - **Input**: A single integer `n`. - **Output**: The value of Euler\'s totient function ϕ(n). 4. `find_primitive_root(n: int) -> List[int]`: - **Input**: A single integer `n`. - **Output**: A list of all primitive roots of `n`. 5. `diffie_hellman_key_exchange(a: int, p: int, verbose: bool = False) -> bool`: - **Input**: Two integers `a` (possible primitive root) and `p` (large prime), and an optional verbose flag. - **Output**: Boolean indicating whether the shared key was successfully exchanged and matched. Constraints and Limitations 1. Use the provided functions for prime checks, order checking, and totient calculation. 2. Ensure to handle edge cases thoroughly, such as non-prime and small inputs. 3. Include necessary validations and error messages. Performance Requirements 1. Ensure that all functions are performant for large prime numbers up to 10^6. 2. Optimize algorithms for large inputs wherever possible. Bonuses 1. Display the progress of the Diffie-Hellman key exchange step-by-step if the `verbose` flag is set to True. 2. Provide detailed error messages to assist in debugging any issues with primality checks or root calculations. Example Scenario (for Context) Alice and Bob want to securely share a key using the Diffie-Hellman protocol. They agree upon a large prime number `p` and a primitive root `a` of `p`. They each generate private and public keys, exchange the public keys, and then compute the shared secret key. ```python # Example Usage: result = diffie_hellman_key_exchange(5, 23, True) # This should print the step-by-step process of the key exchange and finally whether the shared keys match. ```","solution":"import math from typing import List def is_prime(num: int) -> bool: Check if a number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_order(a: int, n: int) -> int: Find the order of a number \'a\' modulo \'n\'. if math.gcd(a, n) != 1: return -1 order = 1 k = a % n while k != 1: k = (k * a) % n order += 1 return order def euler_totient(n: int) -> int: Calculate Euler\'s totient function for a given number \'n\'. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n: int) -> List[int]: Find all primitive roots of a given number \'n\'. if not is_prime(n): return [] phi = euler_totient(n) primitive_roots = [] required_set = set(num for num in range(1, n) if math.gcd(num, n) == 1) for g in range(1, n): actual_set = set(pow(g, powers, n) for powers in range(1, phi + 1)) if required_set == actual_set: primitive_roots.append(g) return primitive_roots def diffie_hellman_key_exchange(a: int, p: int, verbose: bool = False) -> bool: Execute the Diffie-Hellman key exchange securely and validate the shared secret. if not is_prime(p): raise ValueError(f\\"The number {p} is not a prime number.\\") if a not in find_primitive_root(p): raise ValueError(f\\"The number {a} is not a primitive root of {p}.\\") # Private keys alice_private = 6 # Normally, this would be a securely chosen random number bob_private = 15 # Normally, this would be a securely chosen random number # Public keys alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) # Shared secrets alice_shared_secret = pow(bob_public, alice_private, p) bob_shared_secret = pow(alice_public, bob_private, p) if verbose: print(f\\"Prime number (p): {p}\\") print(f\\"Primitive root (a): {a}\\") print(f\\"Alice\'s private key: {alice_private}\\") print(f\\"Bob\'s private key: {bob_private}\\") print(f\\"Alice\'s public key: {alice_public}\\") print(f\\"Bob\'s public key: {bob_public}\\") print(f\\"Alice\'s shared secret: {alice_shared_secret}\\") print(f\\"Bob\'s shared secret: {bob_shared_secret}\\") return alice_shared_secret == bob_shared_secret"},{"question":"Palindrome Permutation Algorithm Given a string `s`, write a Python function `can_permute_palindrome(s)` to determine if a permutation of the string could form a palindrome. A palindrome reads the same forwards and backwards, and case sensitivity and non-alphanumeric characters should be ignored. Your function should: - Take a string `s` as input. - Return a boolean indicating whether any permutation of the string can form a palindrome. # Constraints - The input string `s` will have a length from 0 to 1000 characters. - You should ignore spaces, punctuation, and case sensitivity in determining permutations that form a palindrome. # Performance Requirements - Your solution should run in O(n) time, where n is the length of the string. - Aim to minimize space complexity. # Function Signature ```python def can_permute_palindrome(s: str) -> bool: pass ``` # Example ```python print(can_permute_palindrome(\\"Tact Coa\\")) # Output: True (Permutations: \\"taco cat\\", \\"atco cta\\", etc.) print(can_permute_palindrome(\\"RaceCar!\\")) # Output: True (Permutations: \\"racecar\\") print(can_permute_palindrome(\\"hello\\")) # Output: False print(can_permute_palindrome(\\"\\")) # Output: True ``` # Edge Cases 1. The input string is empty. 2. All characters in the input string are non-alphanumeric. 3. The input string already forms a palindrome despite extraneous characters. **Hint**: Consider using a data structure that allows you to count occurrences of each character efficiently.","solution":"def can_permute_palindrome(s: str) -> bool: from collections import Counter import re # Use regex to filter only alphanumeric and convert to lower case filtered_s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Count the frequency of each character char_count = Counter(filtered_s) # Track the number of characters that have odd counts odd_count = 0 # Iterate through the character frequencies for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"# Binary Search to Find First Occurrence Scenario You are tasked with developing efficient software for a library database which needs to quickly find the first occurrence of a publication year in a list of sorted publication years. Given the sorted nature of the list, you decide to implement a binary search algorithm to achieve this efficiently. Task Implement the `first_occurrence` function to find the first occurrence of a given publication year in a sorted list of publication years. Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: pass ``` Input - `array`: A list of integers representing the sorted publication years. - `query`: An integer representing the publication year to search for. Output - Return an integer, the index of the first occurrence of the query in the array. Return `-1` if the query is not found. Constraints - The array is sorted in increasing order. - The array will contain at most ( 10^6 ) elements. - The values in the array and the query will be between -( 10^9 ) and ( 10^9 ). Examples ```python assert first_occurrence([1, 2, 2, 2, 3, 4], 2) == 1 assert first_occurrence([1, 2, 4, 5, 6, 8], 5) == 3 assert first_occurrence([1, 2, 3, 4, 5, 6], 0) == -1 assert first_occurrence([], 3) == -1 ``` Notes - Be sure to handle the edge cases: empty arrays, query values not present in the array, and values at the boundaries. - Your solution should have a time complexity of O(log n) and a space complexity of O(1).","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of the query in the sorted array. If the query is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # Continue searching in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Unique Single Number Challenge You are given an array of integers where every element appears exactly three times except for one, which appears exactly once. Your task is to write a function that finds that single number. **Function Signature:** ```python def unique_single_number(nums: List[int]) -> int: ``` # Input - `nums` (List[int]): A list of integers where every element appears three times except for one. # Output - `int`: The single integer that appears only once in the array. # Constraints 1. The array `nums` will have at least one element and at most (10^5) elements. 2. The values stored in `nums` will be within the range of a 32-bit signed integer: (-2^{31}) to (2^{31} - 1). # Requirements - Your solution should have a linear runtime complexity, O(n). - You should not use extra memory, ensuring an O(1) space complexity. # Example: ```python # Example 1 print(unique_single_number([2, 2, 3, 2])) # Output: 3 # Example 2 print(unique_single_number([0, 1, 0, 1, 0, 1, 99])) # Output: 99 ``` # Detailed Explanation **Approach**: Utilize bitwise operations to keep track of bits appearing once and twice. This way, bits appearing three times will be nullified, leaving the unique number\'s bits. **Hint**: Use two variables to store intermediate bit values: `ones` and `twos`.","solution":"from typing import List def unique_single_number(nums: List[int]) -> int: Find the unique number in the list where every other number appears exactly three times. Args: nums (List[int]): A list of integers where every element appears exactly three times except for one. Returns: int: The single integer that appears only once in the array. ones, twos = 0, 0 for num in nums: # Calculate twos as the bits that were already in ones and now appear again twos |= ones & num # Calculate ones as the bits that appear the first time or flip the bits in ones if they are in the current number ones ^= num # Mask to remove bits appearing three times common_bit_mask = ~(ones & twos) ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Polynomial Simplification and Evaluation Given the provided `Monomial` and `Polynomial` classes, design and implement a function `simplify_and_evaluate` that takes a polynomial expression as input, simplifies it, and then evaluates it with given variable substitutions. Input - `poly`: a `Polynomial` object representing the polynomial to be simplified and evaluated. - `substitutions`: a dictionary mapping variable indices to their values. These values can be integers, floats, or fractions. Output - The simplified form of the polynomial as a string. - The evaluated result after substituting the given variable values, either as a Fraction or a float depending on the input. Constraints 1. The `substitutions` dictionary will provide values for all variables present in the polynomial. 2. Handle both positive and negative exponents in monomials. 3. Coefficient values in monomials can be integers, floats, or fractions. 4. No coefficient will be zero after simplification. Example ```python from fractions import Fraction # Example Polynomials monomials = [ Monomial({1:2}, 3), Monomial({1:1, 2:1}, -2), Monomial({}, 4) ] poly = Polynomial(monomials) # Substitution substitutions = {1: Fraction(1, 2), 2: 3} # Function Call simplified_poly_str, evaluated_result = simplify_and_evaluate(poly, substitutions) print(simplified_poly_str) # Should output the simplified polynomial as a string print(evaluated_result) # Should output the evaluated result as a Fraction ``` You must implement the following function: ```python def simplify_and_evaluate(poly: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> Tuple[str, Union[int, float, Fraction]]: # Your code here pass ``` # Evaluation Criteria - **Correctness**: The function correctly simplifies the polynomial and performs the evaluation based on the given substitutions. - **Efficiency**: The function handles large polynomials and complex substitution values efficiently and without excessive computational overhead. - **Edge Cases**: Proper handling of edge cases as described under the implementation challenges.","solution":"from fractions import Fraction from typing import Tuple, Union, Dict, List class Monomial: def __init__(self, exponents: Dict[int, int], coefficient: Union[int, float, Fraction]): self.exponents = exponents # Dictionary {variable_index: exponent} self.coefficient = coefficient def __repr__(self): terms = [] for var, exp in self.exponents.items(): if exp == 1: terms.append(f\\"x{var}\\") else: terms.append(f\\"x{var}^{exp}\\") if terms: return f\\"{self.coefficient}*{\'*\'.join(terms)}\\" else: return str(self.coefficient) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def __repr__(self): return \\" + \\".join(map(str, self.monomials)) def simplify_and_evaluate(poly: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> Tuple[str, Union[int, float, Fraction]]: # Simplify the polynomial by combining like terms (same exponents) simplified_monomials = {} for monomial in poly.monomials: exponents_tuple = tuple(sorted(monomial.exponents.items())) if exponents_tuple in simplified_monomials: simplified_monomials[exponents_tuple].coefficient += monomial.coefficient else: simplified_monomials[exponents_tuple] = Monomial(monomial.exponents, monomial.coefficient) # Filter out zero coefficient monomials simplified_poly = Polynomial([m for m in simplified_monomials.values() if m.coefficient != 0]) # Evaluate the simplified polynomial evaluated_result = 0 for monomial in simplified_poly.monomials: term_val = monomial.coefficient for var, exp in monomial.exponents.items(): term_val *= substitutions[var] ** exp evaluated_result += term_val # Return simplified polynomial string and evaluated result return str(simplified_poly), evaluated_result"},{"question":"**Polynomial Evaluation and Derivative Function Implementation** *Scenario:* You are working on a symbolic algebraic calculator that supports polynomial operations. As part of this calculator, you need to handle polynomial evaluation for given variable values and compute the derivative of polynomials with respect to a specific variable. *Your task is to implement two functions:* 1. **evaluate_polynomial(poly: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]**: This function should evaluate the polynomial for given substitutions of variables. The `substitutions` dictionary contains the values for each variable. The function should replace the variables in the polynomial with the provided values and return the computed value. *Input:* ```python poly: Polynomial # The polynomial to evaluate substitutions: Dict[int, Union[int, float, Fraction]] # Variable substitutions ``` *Output:* ```python Union[int, float, Fraction] # The evaluated value of the polynomial ``` *Example:* ```python p = Polynomial([Monomial({1: 2}, 3), Monomial({2: 1}, 4)]) # p represents 3(a_1)^2 + 4(a_2) substitutions = {1: 2, 2: 3} # Substitute a_1=2, a_2=3 result = evaluate_polynomial(p, substitutions) # result should be 3*(2)^2 + 4*(3) = 12 + 12 = 24 ``` 2. **derivative_polynomial(poly: Polynomial, variable: int) -> Polynomial**: This function should return the derivative of the polynomial with respect to the specific variable. *Input:* ```python poly: Polynomial # The polynomial to differentiate variable: int # The variable with respect to which we calculate the derivative ``` *Output:* ```python Polynomial # The derivative of the polynomial ``` *Example:* ```python p = Polynomial([Monomial({1: 2}, 3), Monomial({2: 1}, 4)]) # p represents 3(a_1)^2 + 4(a_2) result = derivative_polynomial(p, 1) # result should be 6(a_1), as the derivative of 3(a_1)^2 with respect to a_1 is 6(a_1) ``` **Considerations:** - Ensure correct handling of polynomials with multiple variables and degrees. - The `evaluate_polynomial` function should appropriately handle zero coefficients. - For `derivative_polynomial`, if the variable is not present in any monomial, return a zero polynomial.","solution":"from typing import Dict, Union, List from fractions import Fraction from collections import defaultdict import numbers class Monomial: def __init__(self, degrees: Dict[int, int], coefficient: Union[int, float, Fraction]): self.degrees = degrees # dictionary mapping variables to their degrees self.coefficient = coefficient def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: result = self.coefficient for variable, degree in self.degrees.items(): if variable in substitutions: result *= substitutions[variable] ** degree else: result *= 0 return result def derivative(self, variable: int): if variable in self.degrees: new_coefficient = self.coefficient * self.degrees[variable] new_degrees = self.degrees.copy() if new_degrees[variable] == 1: del new_degrees[variable] else: new_degrees[variable] -= 1 return Monomial(new_degrees, new_coefficient) else: return Monomial({}, 0) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: result = sum(monomial.evaluate(substitutions) for monomial in self.monomials) return result def derivative(self, variable: int): result = [] for monomial in self.monomials: deriv_mono = monomial.derivative(variable) if deriv_mono.coefficient != 0: result.append(deriv_mono) return Polynomial(result) def evaluate_polynomial(poly: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: return poly.evaluate(substitutions) def derivative_polynomial(poly: Polynomial, variable: int) -> Polynomial: return poly.derivative(variable)"},{"question":"You have been tasked with enhancing the performance of an algorithm that calculates the sum of all k x k sub-squares in an n x n matrix. The existing implementation is straightforward but inefficient. Your job is to optimize it to leverage dynamic programming for better performance while maintaining correctness and handling edge cases gracefully. # Function Signature: ```python def optimized_sum_sub_squares(matrix: List[List[int]], k: int) -> Union[List[List[int]], None]: ``` # Input: - `matrix` (List[List[int]]): A non-empty, n x n list of lists containing integers. - `k` (int): The size of the sub-square to sum. # Output: - Returns a list of lists with the summed values of all k x k sub-squares within the matrix. The size of the output list should be [(n-k+1) x (n-k+1)]. - If `k` > `n`, return `None`. # Constraints: - 1 <= n <= 1000 - 1 <= k <= n - -10^4 <= matrix[i][j] <= 10^4 # Example: ```python matrix = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] k = 2 optimized_sum_sub_squares(matrix, k) # Output: [ # [4, 4, 4], # [4, 4, 4], # [4, 4, 4] # ] ``` # Requirements: 1. Implement a precomputed sum matrix to store the sum of sub-matrices to improve time complexity. 2. The implementation should be optimized to minimize redundant calculations and allocate space and time efficiently. 3. Provide a correct and efficient solution with attention to edge cases and input constraints. # Note: - Carefully handle boundary conditions. - Optimize both time and space complexities. - Thoroughly test your implementation with various sizes and edge cases.","solution":"from typing import List, Union def optimized_sum_sub_squares(matrix: List[List[int]], k: int) -> Union[List[List[int]], None]: n = len(matrix) if k > n: return None # Step 1: Create the sum matrix sum_matrix = [[0] * (n + 1) for _ in range(n + 1)] # Fill in the sum_matrix with cumulative sums for i in range(n): for j in range(n): sum_matrix[i + 1][j + 1] = matrix[i][j] + sum_matrix[i][j + 1] + sum_matrix[i + 1][j] - sum_matrix[i][j] # Step 2: Compute the sums of k x k sub-squares result = [] for i in range(n - k + 1): row = [] for j in range(n - k + 1): top_left_x = i top_left_y = j bottom_right_x = i + k bottom_right_y = j + k sub_square_sum = ( sum_matrix[bottom_right_x][bottom_right_y] - sum_matrix[top_left_x][bottom_right_y] - sum_matrix[bottom_right_x][top_left_y] + sum_matrix[top_left_x][top_left_y] ) row.append(sub_square_sum) result.append(row) return result"},{"question":"# Context You are given a singly linked list where each node contains a character. Your task is to separate the implementation from the initial examples to create a stand-alone function `clean_list` that removes duplicates. # Problem Statement Implement a function `clean_list` that removes duplicate nodes from a singly linked list. You must use two methods as described: one using a hash set to maintain a collection of seen values and another using a nested loop without extra space. Function Signatures ```python class Node: def __init__(self, val = None): self.val = val self.next = None def clean_list(head: Node, use_set: bool = True) -> Node: pass ``` # Input/Output Format * **Input**: * `head`: The head node of the linked list. * `use_set`: Boolean flag to decide whether to use a hash set (`True` for using set, `False` for nested loop approach). * **Output**: * Returns the head node of the modified linked list with duplicates removed. # Constraints * The linked list can have up to `10^5` nodes. * Node values are strings consisting of uppercase alphabet characters. # Performance Requirements * The solution should efficiently handle time and space constraints based on the mode selected via the `use_set` flag. # Examples * **Example 1**: * Input: `A -> A -> B -> C -> D -> C -> F -> G`, `use_set=True` * Output: `A -> B -> C -> D -> F -> G` * **Example 2**: * Input: `A -> A -> B -> C -> D -> C -> F -> G`, `use_set=False` * Output: `A -> B -> C -> D -> F -> G` Note Ensure your solution handles edge cases and performs within the expected time complexity.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def clean_list(head: Node, use_set: bool = True) -> Node: if not head: return head if use_set: # Use a hash set to remove duplicates seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next else: # Remove duplicates using a nested loop current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"**Question**: Write a function `fizzbuzz_custom` that generates a list of values from 1 to N (inclusive), meeting the following specifications: - If the number is divisible by 3, include \\"Fizz\\" in place of the number. - If the number is divisible by 5, include \\"Buzz\\" in place of the number. - If the number is divisible by both 3 and 5, include \\"FizzBuzz\\" in place of the number. - Otherwise, include the number itself. Additionally, handle cases where N is less than 1 by raising an appropriate ValueError and make sure to raise a TypeError when N is None. # Input: - An integer `N`, where `N` is the upper bound of the range of numbers (1 <= N <= 10^6). # Output: - A list of integers and/or strings (\\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\"). # Constraints: - N will be a positive integer. - N will not be None. # Example: ```python fizzbuzz_custom(15) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Notes: - Ensure the solution is efficient and handles large inputs within the constraints (1 <= N <= 1,000,000). - Consider edge cases and performance constraints in your approach. Implement the function `fizzbuzz_custom(N)` and ensure to include appropriate error handling for invalid inputs. # Function Signature: ```python def fizzbuzz_custom(N): # Your code here ```","solution":"def fizzbuzz_custom(N): Generate a list of values from 1 to N (inclusive) with \'Fizz\', \'Buzz\' or \'FizzBuzz\' replacements based on divisibility rules. :param N: int : The upper bound of the range (1 to N). :return: list : A list where certain integers are replaced based on the rules. :raises: ValueError, TypeError - If N is less than 1, raise ValueError. - If N is None, raise TypeError. if N is None: raise TypeError(\\"N must not be None.\\") if N < 1: raise ValueError(\\"N must be a positive integer.\\") result = [] for i in range(1, N + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Enhanced GCD Function with Improved Error Handling As a programmer, you are asked to implement an enhanced version of the `gcd` and `lcm` functions that not only compute the greatest common divisor and least common multiple of two integers but also handle various edge cases and error scenarios gracefully. # Problem Statement **Implement a function `enhanced_gcd` and `enhanced_lcm` that satisfy the following requirements:** 1. **enhanced_gcd(a: int, b: int) -> int:** * Computes the greatest common divisor of integers `a` and `b` using the Euclidean Algorithm. * Raises a `ValueError` if: * Either `a` or `b` is not an integer. * Either `a` or `b` is zero. 2. **enhanced_lcm(a: int, b: int) -> int:** * Computes the least common multiple of integers `a` and `b`. * Uses `enhanced_gcd` for computing the GCD. * Raises a `ValueError` if: * Either `a` or `b` is not an integer. * Either `a` or `b` is zero. # Input and Output Formats * **Input**: Two integers `a` and `b` (not zero). * **Output**: * `enhanced_gcd` returns an integer representing the greatest common divisor. * `enhanced_lcm` returns an integer representing the least common multiple. # Constraints * Inputs `a` and `b` will be within the range of [-10^9, 10^9] but not zero. # Example ```python # Examples for enhanced_gcd print(enhanced_gcd(54, 24)) # Output: 6 print(enhanced_gcd(0, 24)) # Raises ValueError # Examples for enhanced_lcm print(enhanced_lcm(4, 5)) # Output: 20 print(enhanced_lcm(0, 10)) # Raises ValueError ``` # Performance Requirements * Both `enhanced_gcd` and `enhanced_lcm` should run efficiently with a time complexity of ( O(log min(a, b)) ) and a space complexity of ( O(1) ). *You are required to test your functions with various edge cases to ensure robustness.*","solution":"def enhanced_gcd(a, b): Compute the greatest common divisor of integers a and b using the Euclidean Algorithm. Raises a ValueError for invalid inputs. Parameters: a (int): First integer b (int): Second integer Returns: int: GCD of a and b if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both a and b must be integers\\") if a == 0 or b == 0: raise ValueError(\\"Neither a nor b can be zero\\") while b: a, b = b, a % b return abs(a) def enhanced_lcm(a, b): Compute the least common multiple of integers a and b. Uses enhanced_gcd for computing the GCD. Raises a ValueError for invalid inputs. Parameters: a (int): First integer b (int): Second integer Returns: int: LCM of a and b if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both a and b must be integers\\") if a == 0 or b == 0: raise ValueError(\\"Neither a nor b can be zero\\") gcd = enhanced_gcd(a, b) return abs(a * b) // gcd"},{"question":"Fenwick Tree / Binary Indexed Tree Implementation Objective Implement a Fenwick Tree (Binary Indexed Tree) to process multiple point update and prefix sum queries efficiently. Problem Statement You are provided with an integer array `arr` of size `n`. Your task is to implement a Fenwick Tree to support the following operations: * **update(index, value)**: Update the element at `index` to `value`. * **prefix_sum(index)**: Return the sum of the elements from the start of the array to the `index`. Function Signatures Implement the following methods in the `FenwickTree` class: * **def __init__(self, arr: List[int]) -> None**: Constructor that takes an array and initializes the Fenwick Tree. * **def update(self, index: int, value: int) -> None**: Updates the element at the specified index. * **def prefix_sum(self, index: int) -> int**: Returns the sum of the elements from the start of the array to the index. Input and Output Formats * The `arr` parameter will be a list of integers with length `n` (1 ≤ n ≤ 10^5). * The `index` parameter for `update` and `prefix_sum` operations will be in the range [0, n-1]. * The `value` parameter for `update` operation will be an integer in the range [-10^4, 10^4]. Constraints * The number of operations (updates + queries) will not exceed 2 * 10^5. Example ```python # Example ft = FenwickTree([1, 2, 3, 4, 5]) print(ft.prefix_sum(2)) # Should output 6 (1+2+3) ft.update(1, 10) print(ft.prefix_sum(2)) # Should output 14 (1+10+3) ``` Notes * Pay attention to 1-based indexing in the Fenwick Tree while managing the 0-based input arrays. * Ensure the operations are optimized to run within logarithmic time complexity relative to the size of the array.","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]) -> None: self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = [0] * self.n for i in range(self.n): self.update(i, arr[i]) def update(self, index: int, value: int) -> None: diff = value - self.arr[index] self.arr[index] = value index += 1 # Convert to 1-based index while index <= self.n: self.tree[index] += diff index += index & -index def prefix_sum(self, index: int) -> int: index += 1 # Convert to 1-based index result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"Run-Length Encoding and Decoding You are tasked with implementing two functions, `encode_rle` and `decode_rle`, to compress and decompress strings using the Run-Length Encoding algorithm. Your implemented functions should strictly follow the principles of RLE as described below. **Requirements**: 1. `encode_rle(input: str) -> str`: Compress the input string using Run-Length Encoding. 2. `decode_rle(input: str) -> str`: Decompress the input string using Run-Length Decoding. Input and Output Formats * **Input**: * `encode_rle`: A string `input` only containing alphanumeric characters (`a-z`, `A-Z`, `0-9`). * `decode_rle`: A string `input` representing the encoded data consisting of numeric character counts followed by a single alphanumeric character for each run of characters. * **Output**: * `encode_rle`: Returns a compressed run-length encoded string. * `decode_rle`: Returns the decompressed original string. Constraints * The input string lengths will be in the range `[0, 1000]`. * Characters in the input for encoding can appear multiple times consecutively. * The encoded data produced and consumed is valid for run-length operations. Example ```python # Example 1 input_str = \\"aaabbbcccaaa\\" encoded_str = encode_rle(input_str) # Output: \\"3a3b3c3a\\" decoded_str = decode_rle(encoded_str) # Output: \\"aaabbbcccaaa\\" # Example 2 input_str = \\"abcd\\" encoded_str = encode_rle(input_str) # Output: \\"1a1b1c1d\\" decoded_str = decode_rle(encoded_str) # Output: \\"abcd\\" ``` Performance Requirements * Your implementation should handle edge cases, such as empty strings and strings without repetitions. * Ensure the solution operates within the mentioned time complexity to be efficient for the given constraints. Write your solution in Python programming language.","solution":"def encode_rle(input: str) -> str: Compress the input string using Run-Length Encoding. if not input: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_string.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded_string.append(f\\"{count}{input[-1]}\\") return \\"\\".join(encoded_string) def decode_rle(input: str) -> str: Decompress the input string using Run-Length Decoding. if not input: return \\"\\" decoded_string = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return \\"\\".join(decoded_string)"},{"question":"You are implementing a sorting algorithm called Cocktail Shaker Sort. This algorithm is a variation of Bubble Sort that sorts the list in two passes (left to right, then right to left). Your task is to implement this algorithm to sort a given list of integers in ascending order efficiently. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input - **arr**: A list of integers, with a length `N` where `0 <= N <= 10^4`. The integers can be negative, zero, or positive. # Output - Returns a list of integers sorted in ascending order. # Constraints - The function should sort the array **in-place** and return the sorted array. - Consider edge cases such as an empty array or an already sorted array. - Ensure your implementation handles the constraints efficiently. # Examples 1. **Example 1** - Input: `[3, 0, 2, 5, -1, 4, 1]` - Output: `[-1, 0, 1, 2, 3, 4, 5]` 2. **Example 2** - Input: `[5, 3, 8, 4, 2]` - Output: `[2, 3, 4, 5, 8]` 3. **Example 3** - Input: `[1, 2, 3, 4, 5]` - Output: `[1, 2, 3, 4, 5]` 4. **Example 4** - Input: `[]` - Output: `[]` # Note - You must handle edge cases and provide an optimal and correct solution. - Do not use Python’s built-in sorting functions, and focus on implementing the Cocktail Shaker Sort algorithm as described.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: n = len(arr) if n <= 1: return arr start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Context: In cryptographic protocols, secure key exchange over a public network is essential. The Diffie-Hellman key exchange method enables two parties to securely share a common secret key even if they don\'t know each other. This shared secret can then be used to encrypt subsequent communications. As part of this process, large prime numbers and the concepts of primitive roots, order, and Euler’s totient function are crucial for ensuring the security and effectiveness of the key exchange. # Task: Implement and demonstrate the Diffie-Hellman key exchange protocol, ensuring secure key generation and exchange between two parties. In addition, write additional helper functions necessary for this process. # Requirements: 1. **Functionality**: Implement the following functions: - `is_prime(n)`: Returns True if n is a prime number. - `order(a, n)`: Returns the order of a modulo n. - `euler_totient(n)`: Calculates the Euler’s totient function of n. - `primitive_roots(n)`: Finds all primitive roots of n. - `diffie_hellman(a, p)`: Performs the Diffie-Hellman key exchange given a primitive root a and a prime p. It should simulate the key sharing between two parties and print both private and public keys and the shared secret. # Constraints: - `p` must be a prime number greater than 2. - `a` must be a primitive root of `p`. - The functions should handle edge cases like non-prime `p`, non-primitive `a`, and invalid inputs. # Performance: - Ensure that the implementation is efficient and handles large prime numbers. # Input and Output Formats: Here\'s the outline for function definitions: ```python def is_prime(n: int) -> bool: # Determine if n is a prime number. pass def order(a: int, n: int) -> int: # Compute the order of a modulo n. pass def euler_totient(n: int) -> int: # Compute the Euler’s totient function for n. pass def primitive_roots(n: int) -> list: # Find all primitive roots of n. pass def diffie_hellman(a: int, p: int) -> None: # Simulate the Diffie-Hellman key exchange process. pass ``` # Example: ```python # Sample usage: p = 23 a = 5 # assume 5 is a primitive root of 23 result = diffie_hellman(a, p) # Output should show private keys, public keys, and the shared secret key. ``` # Notes: - Thoroughly test the helper functions before running the key exchange. - Demonstrate with both small and relatively large prime numbers to ensure robustness.","solution":"def is_prime(n): Determines if n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def order(a, n): Computes the order of a modulo n. if not is_prime(n): raise ValueError(\\"n must be a prime number.\\") k = 1 while pow(a, k, n) != 1: k += 1 return k def euler_totient(n): Computes the Euler\'s totient function for n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def primitive_roots(n): Finds all primitive roots of n. if not is_prime(n): raise ValueError(\\"n must be a prime number.\\") if n == 2: return [1] # Special case for the smallest prime phi = euler_totient(n) roots = [] for a in range(2, n): if order(a, n) == phi: roots.append(a) return roots def diffie_hellman(a, p): Simulates the Diffie-Hellman key exchange given a primitive root a and a prime p. import random if not is_prime(p): raise ValueError(\\"p must be a prime number.\\") if a not in primitive_roots(p): raise ValueError(\\"a must be a primitive root of p.\\") # Private keys (chosen randomly) private_key_A = random.randint(2, p - 2) private_key_B = random.randint(2, p - 2) # Public keys public_key_A = pow(a, private_key_A, p) public_key_B = pow(a, private_key_B, p) # Shared secret shared_secret_A = pow(public_key_B, private_key_A, p) shared_secret_B = pow(public_key_A, private_key_B, p) assert shared_secret_A == shared_secret_B print(f\\"Private key A: {private_key_A}\\") print(f\\"Private key B: {private_key_B}\\") print(f\\"Public key A: {public_key_A}\\") print(f\\"Public key B: {public_key_B}\\") print(f\\"Shared secret: {shared_secret_A}\\") return { \\"private_key_A\\": private_key_A, \\"private_key_B\\": private_key_B, \\"public_key_A\\": public_key_A, \\"public_key_B\\": public_key_B, \\"shared_secret\\": shared_secret_A }"},{"question":"**Problem Statement**: You are given an array of integers that was originally sorted in ascending order. However, it has been rotated at some pivot point unknown to you. Your task is to write a function `find_min_element` that finds the minimum element in this rotated sorted array. The function must have a time complexity of O(log N). # Function Signature ```python def find_min_element(array: List[int]) -> int: pass ``` # Input * `array` - A list of integers that was originally sorted in ascending order and then rotated. The length of the array is between 1 and 10^4. No duplicate elements exist in the array. # Output * Returns an integer which is the minimum element in the given array. # Constraints * The array will contain at least one element and at most 10^4 elements. * No two elements in the array are the same. # Example 1. Input: [4, 5, 6, 7, 0, 1, 2] Output: 0 2. Input: [3, 4, 5, 1, 2] Output: 1 3. Input: [11, 13, 15, 17] Output: 11 # Scenario You are designing a search mechanism for a library database where book IDs are stored in a circularly shifted list. Efficiently finding the minimum book ID helps in determining the start of a new section in the library system. # Performance Requirements The solution must handle large arrays efficiently with a time complexity of O(log N).","solution":"from typing import List def find_min_element(array: List[int]) -> int: Finds the minimum element in a rotated sorted array. Parameters: array (List[int]): A rotated sorted list of integers. Returns: int: The minimum element in the array. if len(array) == 1: return array[0] low, high = 0, len(array) - 1 # If the array is not rotated. if array[high] >= array[low]: return array[low] while low <= high: mid = (low + high) // 2 # Check if mid is the minimum element if array[mid] > array[mid + 1]: return array[mid + 1] if array[mid - 1] > array[mid]: return array[mid] # Decide the search space if array[mid] > array[0]: low = mid + 1 else: high = mid - 1 return -1 # This line will not be reached"},{"question":"# Question: Implement a MaxStack Data Structure Objective You are tasked to implement a new data structure called `MaxStack` which extends a stack\'s functionality by including an additional feature to retrieve the maximum element in the stack in constant time. Requirements 1. The `MaxStack` should support the following operations efficiently: - `push(val)`: Pushes an element onto the stack. - `pop()`: Removes the element on the top of the stack and returns it. - `peek()`: Gets the top element of the stack without removing it. - `get_max()`: Retrieves the maximum element in the stack without removing it. 2. The `MaxStack` should be implemented using a combination of the `ArrayStack` or `LinkedListStack` provided in the code snippet. 3. **Performance constraints**: - `push(val)`, `pop()`, `peek()`, and `get_max()` operations should all run in O(1) average time complexity. Input and Output Format You will be provided with a series of operations to perform on `MaxStack`. The operations will be in the form of a list of strings. For example: ``` [\\"push 3\\", \\"push 5\\", \\"get_max\\", \\"pop\\", \\"get_max\\"] ``` The expected result for the above operations is: ``` [None, None, 5, 5, 3] ``` Where `None` indicates the operation does not return any value. # Example ```python # Example usage of MaxStack: max_stack = MaxStack() max_stack.push(3) max_stack.push(5) print(max_stack.get_max()) # Output: 5 print(max_stack.pop()) # Output: 5 print(max_stack.get_max()) # Output: 3 ``` # Constraints * You may assume that the input will always be valid. * The operations `pop` and `peek` will never be called on an empty stack. * The input size will not exceed 1000 operations. # Implementation Challenge Implement the `MaxStack` class by defining the following methods, ensuring they meet the performance constraints: ```python class MaxStack: def __init__(self): Initialize your data structure here. # Your code here def push(self, val: int) -> None: # Your code here def pop(self) -> int: # Your code here def peek(self) -> int: # Your code here def get_max(self) -> int: # Your code here ```","solution":"class MaxStack: def __init__(self): Initialize your data structure here. self.stack = [] self.max_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.max_stack or val >= self.max_stack[-1]: self.max_stack.append(val) def pop(self) -> int: val = self.stack.pop() if val == self.max_stack[-1]: self.max_stack.pop() return val def peek(self) -> int: return self.stack[-1] def get_max(self) -> int: return self.max_stack[-1]"},{"question":"# Problem: Repeated String Match Objective: Write a function `minimum_repeats_needed(A: str, B: str) -> int` that determines the minimum number of times string A needs to be repeated so that B is a substring of the resulting string. If no such repetition can make B a substring, return -1. Input: - `A`: A string of length between 1 and 10000. - `B`: A string of length between 1 and 10000. Output: - An integer representing the minimum number of repetitions of A to make B a substring of the repeated string, or -1 if it\'s not possible. Constraints: - Consider edge cases where B is already a substring of A. - Optimize the solution to avoid unnecessary repetitions and concatenations. Example: With `A = \\"abcd\\"` and `B = \\"cdabcdab\\"`, the output should be `3` as repeating \\"abcd\\" three times makes \\"cdabcdab\\" a substring. Function Signature: ```python def minimum_repeats_needed(A: str, B: str) -> int: # Your implementation here ``` Scenario: Imagine you have a basic string `A` which represents a DNA sequence. You suspect that a shorter DNA pattern `B` exists as a subsequence within multiple repetitions of `A`. Your task is to determine the minimum number of repeats of the DNA sequence `A` to confirm the presence of `B`. Performance Requirements: Ensure the implementation is time-efficient and avoids excess memory usage. Consider using substrings and other string operations efficiently.","solution":"def minimum_repeats_needed(A: str, B: str) -> int: Determine the minimum number of times string A needs to be repeated so that B is a substring. len_a = len(A) len_b = len(B) # Calculate the maximum number of repeats needed max_repeats = -(-len_b // len_a) + 1 # Equivalent to ceil(len_b / len_a) + 1 # Generate the repeated string repeated_a = A * max_repeats # Check for B in repeated version of A for i in range(1, max_repeats + 1): if B in repeated_a[:i * len_a]: return i # If B is not found return -1"},{"question":"# Context: You have been hired by a company that processes large datasets and frequently requires cumulative sum computations and dynamic updates to their data. Your task is to implement a data structure that supports efficient point updates and prefix sum queries. # Problem: Implement a Fenwick Tree (Binary Indexed Tree) class to efficiently manage an array of integers and support the following operations: 1. **GetPrefixSum**: Returns the sum of elements from index 0 to a given index ( i ). 2. **UpdateElement**: Updates the value of an element at a given index and adjust the tree accordingly. # Requirements: 1. Implement the `FenwickTree` class which includes: * A constructor that initializes the data structure with a given list of integers. * `get_prefix_sum(self, i)`: Returns the sum from the start of the array to index `i`. * `update_element(self, i, value)`: Updates the element at index `i` with the provided `value` and reflects this change in the tree. # Constraints: * ( 1 leq n leq 10^5 ) * ( -10^9 leq text{arr[i]} leq 10^9 ) * All operations combined should run in at most ( O(n log n) ) time. # Input and Output: * Initialization: `obj = FenwickTree(arr)` * `get_prefix_sum(i)`: Returns an integer which is the sum of array elements from index 0 to `i`. * `update_element(i, value)`: No return; simply updates the value and the tree. # Example: ```python # Given array arr = [3, 2, -1, 6, 5] # Initialize Fenwick Tree fenwick_tree = FenwickTree(arr) # Get Prefix Sum from 0 to 3 returns (3 + 2 - 1 + 6) = 10 print(fenwick_tree.get_prefix_sum(3)) # Output: 10 # Update element at index 2 to 4 fenwick_tree.update_element(2, 4) # Get Prefix Sum from 0 to 3 returns (3 + 2 + 4 + 6) = 15 print(fenwick_tree.get_prefix_sum(3)) # Output: 15 ```","solution":"class FenwickTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr[:] for i in range(self.n): self._add(i, self.arr[i]) def _add(self, index, value): index += 1 # Fenwick Tree index starts from 1 while index <= self.n: self.tree[index] += value index += index & -index def get_prefix_sum(self, i): i += 1 # Fenwick Tree index starts from 1 s = 0 while i > 0: s += self.tree[i] i -= i & -i return s def update_element(self, i, value): diff = value - self.arr[i] self.arr[i] = value self._add(i, diff)"},{"question":"# Scenario You are developing a file management system where files from various directories are frequently accessed. To ensure consistency and to prevent errors due to relative paths, you need to implement a function that always returns the absolute path of a given file. # Task Write a function `resolve_absolute_path(file_path: str) -> str` that takes a file path as input and returns the absolute path. The function should correctly handle paths containing `~` and ensure it returns a proper absolute path. # Input Format - A single string representing the file path which could be relative, absolute, or containing `~` for the user’s home directory. # Output Format - A single string representing the absolute file path. # Constraints - The input path will be a valid string but may not necessarily exist on the file system. - Ensure consistent handling across different operating systems (consider common path conventions). # Examples Example 1: ```plaintext Input: \'~/documents/report.txt\' Output: \'/home/username/documents/report.txt\' (On Unix-based systems) ``` Example 2: ```plaintext Input: \'./data/info.log\' Output: \'/current/directory/data/info.log\' (Assuming the current directory is /current/directory) ``` Example 3: ```plaintext Input: \'/var/log/system.log\' Output: \'/var/log/system.log\' (Since it is already an absolute path) ``` **Note**: The actual output paths may vary depending on the operating system and the user\'s home directory. # Additional Requirements - Your implementation should handle edge cases such as empty strings or strings with only the home directory. - No need to check if the file actually exists in the directory.","solution":"import os def resolve_absolute_path(file_path: str) -> str: Returns the absolute path of the given file_path. It handles relative paths, absolute paths, and paths containing `~` for the user\'s home directory. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"You are tasked with implementing a regular expression matching function that supports the special characters `.` and `*`. The function should be able to determine if a given input string matches the pattern completely (not partially). # Function Signature: ```python def is_match(input_string: str, pattern: str) -> bool: # Your code here ``` # Input: - `input_string`: A string consisting of only lowercase letters (1 <= `len(input_string)` <= 1000). - `pattern`: A string consisting of lowercase letters, `.` and `*` (1 <= `len(pattern)` <= 1000). # Output: - Returns `True` if the entire input string matches the pattern, `False` otherwise. # Constraints: - *\'`\'.` matches any single character. - *\'`\'*` matches zero or more of the preceding element. - The pattern will be a valid regular expression. # Examples: 1. `is_match(\\"aa\\", \\"a\\")` should return `False`. 2. `is_match(\\"aa\\", \\"aa\\")` should return `True`. 3. `is_match(\\"aaa\\", \\"aa\\")` should return `False`. 4. `is_match(\\"aa\\", \\"a*\\")` should return `True`. 5. `is_match(\\"aa\\", \\".*\\")` should return `True`. 6. `is_match(\\"ab\\", \\".*\\")` should return `True`. 7. `is_match(\\"aab\\", \\"c*a*b\\")` should return `True`. # Explanation: To implement this, you will use dynamic programming to build a solution that efficiently determines whether the given string matches the pattern using a two-dimensional table to store intermediate results. Edge cases and scenarios such as empty strings, patterns with consecutive special characters, and differing lengths need to be handled appropriately. # Note: 1. Thoroughly test your implementation against different edge cases and large inputs. 2. Consider performance implications and ensure your solution works within the given constraints. 3. Do not use built-in regular expression libraries for this problem.","solution":"def is_match(input_string: str, pattern: str) -> bool: # Create a 2D table to store results of subproblems dp = [[False] * (len(pattern) + 1) for _ in range(len(input_string) + 1)] # Base case: empty string matches with empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* that can match empty string for j in range(1, len(pattern) + 1): if pattern[j-1] == \'*\': dp[0][j] = dp[0][j-2] # Fill the table in bottom-up fashion for i in range(1, len(input_string) + 1): for j in range(1, len(pattern) + 1): if pattern[j-1] == \'.\' or pattern[j-1] == input_string[i-1]: dp[i][j] = dp[i-1][j-1] elif pattern[j-1] == \'*\': dp[i][j] = dp[i][j-2] if pattern[j-2] == \'.\' or pattern[j-2] == input_string[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j] else: dp[i][j] = False return dp[len(input_string)][len(pattern)]"},{"question":"# Scenario You are working for a small startup developing custom data processing solutions. One day, you receive a complaint from a client about inefficiencies in their existing sorting solutions. Your task is to implement an optimized sorting function based on the provided insertion sort but with additional functionality and constraints. # Problem Statement Implement a function `optimized_insertion_sort` that sorts a list of integers in ascending order using insertion sort. The function must be optimized to handle large datasets and allow the user to enable or disable sorting stability explicitly. Furthermore, the function should simulate the sorting process by printing each iteration of the array state if a `simulation` flag is set to `True`. # Function Signature ```python def optimized_insertion_sort(arr: list[int], simulation: bool = False, stable: bool = True) -> list[int]: pass ``` # Input Format 1. A list of integers `arr` to be sorted. 2. A boolean `simulation` that prints the array state at each iteration if set to `True`. 3. A boolean `stable` that specifies whether the sorting should maintain stability. - If `stable` is `True`, maintain the original order of equivalent elements. - If `stable` is `False`, stability is not required, and you can focus purely on performance optimization. # Output Format - A list of sorted integers in ascending order. # Constraints 1. The length of the array `n` can be up to 10^5. 2. The integers in the list are in the range of -10^6 to 10^6. # Performance Requirements - Your solution should handle the worst-case input size gracefully within a reasonable time limit. # Examples ```python assert optimized_insertion_sort([5, 3, 8, 4, 2], True, True) == [2, 3, 4, 5, 8] assert optimized_insertion_sort([-1, -99, 3, 2, 1], False, False) == [-99, -1, 1, 2, 3] ``` # Notes - If the array is empty or contains only one element, it is already sorted, and the function should return the array as is without performing further operations. - Use efficient data structures or algorithms to optimize your solution for large input sizes.","solution":"def optimized_insertion_sort(arr: list[int], simulation: bool = False, stable: bool = True) -> list[int]: Sorts a list of integers using an optimized insertion sort. Optionally prints each iteration of the array state and maintains stability. if len(arr) <= 1: return arr for i in range(1, len(arr)): current = arr[i] j = i - 1 if stable: while j >= 0 and arr[j] > current: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = current else: # Not maintaining stability, using regular insertion sort logic while j >= 0 and arr[j] > current: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = current if simulation: print(f\\"Iteration {i}: {arr}\\") return arr"},{"question":"# Matrix Multiplication Function You are required to implement a matrix multiplication function. Given two matrices represented as lists of lists, your task is to perform the matrix multiplication and return the result. Function Signature: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ``` # Input: * `multiplicand` (List[List[int]]): A list of lists representing an n x m matrix. * `multiplier` (List[List[int]]): A list of lists representing an m x p matrix. # Output: * Returns a list of lists representing the n x p result matrix. # Constraints: - `1 <= n, m, p <= 100` - Matrix elements are integers and can be both positive and negative. - Raise an exception with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" if the number of columns in the multiplicand does not match the number of rows in the multiplier. # Performance Requirements: - You should strive for a time complexity within the bounds of classical matrix multiplication O(n^3), although better performance is appreciated if optimizations can be applied. # Example: ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(multiplicand, multiplier) # Expected Output: [[58, 64], [139, 154]] ``` # Additional Notes: - Carefully handle edge cases like empty matrices or incompatible dimensions. - Consider the performance implications for large matrices and validate the algorithm\'s efficiency within the given constraints. Write your implementation of matrix multiplication considering the given requirements and constraints.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: if len(multiplicand[0]) != len(multiplier): raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") n = len(multiplicand) m = len(multiplier) p = len(multiplier[0]) result = [[0] * p for _ in range(n)] for i in range(n): for j in range(p): for k in range(m): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# LinkedList Partition around a Value Using the provided description of the linked list partitioning operation, implement a function `partition(head: Node, x: int) -> Node` that performs the partitioning. Function Specification - **Function Name**: `partition` - **Input**: The function receives: - `head`: the head node of a linked list. - `x`: an integer value to partition the list around. - **Output**: The function should return: - The head node of the modified linked list such that all nodes with values less than `x` come before nodes with values greater than or equal to `x`. # Example Given the linked list: ``` 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 Partition value (x): 5 Expected output: 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 ``` # Constraints - The values of all linked list nodes are integers. - Do it in one pass and keep the original relative order of nodes within each partition. # Requirements - Maintain O(n) time complexity where `n` is the number of nodes in the linked list. - Maintain O(1) space complexity besides the space needed for the input list. # Notes - You may assume the linked list is initially well-formed. - Ensure your solution is robust and handles all mentioned edge cases. # Additional Context This problem is essential as it helps solidify the understanding of linked list manipulations, pointer operations, and algorithmic partitioning which are applicable in numerous advanced algorithm problems like quicksort.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def partition(head: Node, x: int) -> Node: Partition the linked list around a value x such that all nodes less than x come before nodes greater than or equal to x. Parameters: head (Node): The head of the linked list. x (int): The partition value. Returns: Node: The head of the modified linked list. if not head: return head before_head = Node(0) # Placeholder for the start of the \\"before\\" list before = before_head # Pointer to the current end of the \\"before\\" list after_head = Node(0) # Placeholder for the start of the \\"after\\" list after = after_head # Pointer to the current end of the \\"after\\" list current = head while current: if current.value < x: before.next = current before = before.next else: after.next = current after = after.next current = current.next after.next = None # Terminate the \\"after\\" list before.next = after_head.next # Connect \\"before\\" list with \\"after\\" list return before_head.next # Return the head of the combined list"},{"question":"# Question Given the root of a binary tree, invert the binary tree and return its root. # Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: # your code here ``` # Input - `root`: The root node of a binary tree. Each node has the following properties: * `val`: An integer value of the node. * `left`: A reference to the left child node (or None if no child). * `right`: A reference to the right child node (or None if no child). # Output - Return the root node of the inverted (mirrored) binary tree. # Example ```plaintext Input: Original Tree: 4 / 2 7 / / 1 3 6 9 Output: Inverted Tree: 4 / 7 2 / / 9 6 3 1 ``` # Constraints - The number of nodes in the tree is in the range `[0, 1000]`. - The tree nodes\' values are in the range `[-100, 100]`. # Notes - The solution must handle edge cases such as single-node trees, and completely left or right-skewed trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the sub-trees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Linked List Deduplication Challenge Problem Statement You are given a singly linked list that may contain duplicate values. Your task is to write a function to remove these duplicates. There are two parts to this problem. 1. First, implement a function that removes duplicates using additional data structure (hash set). 2. Second, implement another function that removes duplicates without using any additional data structure, i.e., with constant space complexity, other than the space required for the linked list itself. # Function Signatures: 1. `remove_dups(head: Node) -> None` 2. `remove_dups_without_set(head: Node) -> None` # Input - `head`: A reference to the head node of the singly linked list. Each node contains: - `val`: A string or integer representing the value. - `next`: A pointer/reference to the next node in the linked list. # Expected Output - Both functions modify the linked list in place and do not return any value. - The list should reflect the removal of duplicate values after each function is called. # Constraints - The elements of the linked list will be integers or strings. - The original relative order of the elements should be preserved. # Example Consider the following linked list: A -> A -> B -> C -> D -> C -> F -> G - After calling `remove_dups`, the linked list should be: A -> B -> C -> D -> F -> G - After calling `remove_dups_without_set`, the linked list should again be: A -> B -> C -> D -> F -> G **Note**: Ensure to handle edge cases such as an empty linked list or a list with a single node.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using an additional data structure. if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using extra space. if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are required to implement a function `is_sorted_stack` that checks if a given stack of integers is sorted in strictly ascending order from the bottom to the top without modifying the original stack. Function Signature ```python def is_sorted_stack(stack: List[int]) -> bool: ``` Input * `stack` : List[int] - A list of integers representing the stack, where index 0 represents the bottom of the stack, and the last element in the list represents the top. Output * Returns a boolean `True` if the stack is sorted in strictly ascending order from bottom to top, `False` otherwise. Constraints * All integers are within the range `[-10^6, 10^6]`. * The length of the stack will not exceed `10^6`. Performance Requirements Ensure that your solution is efficient and adheres to the following: * Time Complexity: O(n) * Space Complexity: O(n) Example ```python # Example 1 stack = [1, 2, 3, 4, 5, 6] print(is_sorted_stack(stack)) # Output: True # Example 2 stack = [6, 3, 5, 1, 2, 4] print(is_sorted_stack(stack)) # Output: False # Example 3 stack = [] print(is_sorted_stack(stack)) # Output: True # Example 4 stack = [1] print(is_sorted_stack(stack)) # Output: True # Example 5 stack = [3, 2, 1] print(is_sorted_stack(stack)) # Output: False ``` Additional Considerations * Pay close attention to edge cases such as an empty stack or a stack with a single element. * Make sure to restore the original order of the stack after function execution.","solution":"from typing import List def is_sorted_stack(stack: List[int]) -> bool: Returns True if the stack is sorted in strictly ascending order from bottom to top, otherwise returns False. The stack is represented by a list, where index 0 is the bottom. if not stack: return True for i in range(1, len(stack)): if stack[i - 1] >= stack[i]: return False return True"},{"question":"Problem Statement You are tasked with determining the number of unique binary search trees (BSTs) that can be formed with numbers from 1 to n. Each number from 1 to n must appear exactly once in any tree, and the structure of any two trees must be unique. Input * An integer `n` (1 ≤ n ≤ 19). Output * An integer representing the number of unique BSTs that can be constructed with values from 1 to n. Function Signature Write a function `number_of_unique_BSTs(n: int) -> int`. Examples ```python assert number_of_unique_BSTs(3) == 5 # Example trees shown earlier. assert number_of_unique_BSTs(1) == 1 # Only one possible structure. assert number_of_unique_BSTs(0) == 1 # Treating empty tree case. assert number_of_unique_BSTs(4) == 14 # Number of unique BSTs grows as n increases. ``` Constraints * Ensure the solution is efficient and handles the input constraints provided. * You may assume that the input value is a valid integer within the specified range. Special Instructions * Pay attention to edge cases such as n = 0 and n = 1. # Detailed Breakdown 1. **Initialize an array to store the results of subproblems** with a base case for `n` equal to 0 and 1. 2. **Implement nested loops** to populate the array using the Catalan number calculation formula. 3. **Return the final result** from the array, which corresponds to the number of unique BSTs for the given `n`. # Edge Cases & Performance Considerations 1. **Edge Cases**: Handle n = 0 and n = 1 appropriately. 2. **Performance Bottlenecks**: Assess for potential integer overflow or excessive computation in nested loops.","solution":"def number_of_unique_BSTs(n: int) -> int: Calculate the number of unique binary search trees that can be constructed with numbers from 1 to n. if n == 0: return 1 # An empty tree is considered to be a valid unique BST. # Create a list to store the result of unique BST counts for each number of nodes dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 # Fill the dynamic programming table for nodes in range(2, n + 1): for root in range(1, nodes + 1): left = root - 1 right = nodes - root dp[nodes] += dp[left] * dp[right] return dp[n]"},{"question":"You are given a list of integers where the total number of elements and the range of the elements are roughly comparable. Implement the `pigeonhole_sort` function to sort this list efficiently using the Pigeonhole Sort algorithm. Your solution should minimize memory usage while maintaining performance. Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input: * `arr`: A list of integers where `1 <= len(arr) <= 10^5` and the range of elements (max(arr) - min(arr)) is at most `10^5`. Output: * Returns a list of integers sorted in non-decreasing order. Constraints: * The list may contain both positive and negative integers. * Duplicates are allowed. Example: ```python # Example 1 input_arr = [4, 3, 2, 1, 0] output_arr = pigeonhole_sort(input_arr) print(output_arr) # Output: [0, 1, 2, 3, 4] # Example 2 input_arr = [-10, -5, 0, 5, 10] output_arr = pigeonhole_sort(input_arr) print(output_arr) # Output: [-10, -5, 0, 5, 10] # Example 3 input_arr = [5, 3, 4, 1, 2] output_arr = pigeonhole_sort(input_arr) print(output_arr) # Output: [1, 2, 3, 4, 5] ``` Your implementation should handle edge cases efficiently and ensure optimal performance for the given constraints.","solution":"def pigeonhole_sort(arr): Sorts a list of integers using the Pigeonhole Sort algorithm. if not arr: return arr # Return empty list if input is empty # Find the minimum and maximum values to determine range min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 # Initialize holes holes = [0] * range_size # Populate the holes for number in arr: holes[number - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for i in range(range_size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"Path Split Function Problem Statement You are given a function `split(path)` that is designed to divide a full path into the directory and the filename. Your task is to extend this function to handle additional scenarios, ensuring it works correctly across various path formats. Required Function: ```python def split(path: str) -> list: Splits the given path into two parts: the directory part and the file name. Parameters: path (str): The full path string (URL or file path) to be split. Returns: list: A list containing two strings, the directory part and the file name part. ``` Input and Output **Input**: - A string `path` representing a full path, which can be a URL or a file path. **Output**: - A list of two strings: - First element: Directory path - Second element: Filename Constraints - Input string may contain both forward slashes (`/`) and backward slashes (``). - It may be empty or contain relative paths (`.` and `..`). # Example ```python Input: \\"https://example.com/dir1/dir2/file.txt\\" Output: [\\"https://example.com/dir1/dir2\\", \\"file.txt\\"] Input: \\"C:Usersfile.txt\\" Output: [\\"C:Users\\", \\"file.txt\\"] Input: \\"/absolute/path/to/file.txt\\" Output: [\\"/absolute/path/to\\", \\"file.txt\\"] Input: \\"relative/path/to/file.txt\\" Output: [\\"relative/path/to\\", \\"file.txt\\"] Input: \\"filename.txt\\" Output: [\\"\\", \\"filename.txt\\"] ``` # Evaluation Criteria - Correct handling of both forward and backward slashes in paths. - Correct splitting of various types of paths (URLs, absolute paths, relative paths). - Effective handling of edge cases (e.g., paths without slashes, empty string). - Ensure the function does not crash on invalid inputs and handles unexpected scenarios gracefully.","solution":"def split(path: str) -> list: Splits the given path into two parts: the directory part and the file name. Parameters: path (str): The full path string (URL or file path) to be split. Returns: list: A list containing two strings, the directory part and the file name part. if not path: return [\\"\\", \\"\\"] path = path.replace(\\"\\", \\"/\\") if \'/\' not in path: return [\\"\\", path] directory, filename = path.rsplit(\\"/\\", 1) return [directory, filename]"},{"question":"# Linked List Intersection Detection You are provided two singly linked lists, and your task is to determine the intersection node where these lists merge for the first time, if such a node exists. The structure of each node in the linked list is as follows: ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None ``` # Input - Two head nodes of the linked lists (`headA`, `headB`). # Output - The common node where the lists merge. If there is no such node, return `None`. # Constraints - Your solution should run with a time complexity of O(m+n) where m and n are the lengths of the two linked lists. - You may not modify the linked lists. - You should use no additional memory beyond primitive variables (O(1) space complexity). # Example ```python # Define the nodes a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) # Create the first linked list: 1 -> 3 -> 5 -> 7 -> 9 -> 11 a1.next = b1 b1.next = c1 c1.next = d d.next = e e.next = f # Create the second linked list: 2 -> 4 -> 6 -> 7 -> 9 -> 11 a2.next = b2 b2.next = c2 c2.next = d # Running the function should return the node with value 7 result = intersection(a1, a2) print(result.val if result else \\"No intersection\\") ``` In this example, the lists intersect at the node with value 7. # Implementation Write the `intersection` function: ```python def intersection(headA, headB): # Your implementation goes here ``` **Note**: Consider edge cases such as if one or both linked lists are empty, linked lists with no intersection, and linked lists of different lengths.","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def intersection(headA, headB): Finds the intersection node of two singly linked lists. if not headA or not headB: return None # Two pointers for each list ptrA, ptrB = headA, headB # Traverse both lists while ptrA != ptrB: # If either pointer hits the end, switch head and continue the second traversal. # If not hit the end, just move to next. ptrA = headB if not ptrA else ptrA.next ptrB = headA if not ptrB else ptrB.next return ptrA"},{"question":"# Question - Search in a Row-Column Sorted Matrix You are given a matrix where each row and each column is sorted in non-decreasing order. Write a function `search_in_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]` that searches for a given integer `key` in the matrix and returns its position in the matrix as a tuple `(row_index, column_index)`. If the key is not found, return `(-1, -1)`. Input * `matrix`: List of lists of integers where each sublist represents a row in a matrix. Each row and each column is sorted in non-decreasing order. The matrix dimensions can be `0 <= m <= 1000` and `0 <= n <= 1000`. * `key`: An integer to search for in the matrix. Output * A tuple containing the row and column index `(row_index, column_index)` where the key is found. If not found, return `(-1, -1)`. Constraints * The matrix is guaranteed to have rows and columns sorted in non-decreasing order. * You should aim for O(m + n) time complexity and O(1) space complexity. Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 # The function should return (1, 2) matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 21 # The function should return (-1, -1) ``` Note * Use 0-based indexing for the row and column indices. * Consider edge cases such as empty matrix input and key not present in the matrix.","solution":"from typing import List, Tuple def search_in_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: Searches for a given key in a matrix where each row and each column are sorted in non-decreasing order. if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Prime Number Counting Function Problem Statement You are given an integer `n`. Write a function `count_primes_up_to_n(n)` that counts how many prime numbers exist up to and including `n`. Function Signature ```python def count_primes_up_to_n(n: int) -> int: Count the number of prime numbers up to and including n. :param n: Upper limit integer up to which primes are to be counted. :return: Number of prime numbers up to n. ``` Input - An integer `n`, where 0 ≤ n ≤ 100,000. Output - An integer representing the number of prime numbers from 2 up to `n`. Constraints - 0 ≤ n ≤ 100,000. Requirements - The implementation should be efficient and run within acceptable time limits for larger values of `n` (consider optimizations where applicable). Example ```python assert count_primes_up_to_n(10) == 4 # Primes: 2, 3, 5, 7 assert count_primes_up_to_n(0) == 0 assert count_primes_up_to_n(1) == 0 assert count_primes_up_to_n(30) == 10 # Primes: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ``` Additional Context You are to implement this function leveraging the prime-checking logic. Consider performance improvements like preprocessing multiple checks using a sieve method (Sieve of Eratosthenes) for a broader range when applicable.","solution":"def count_primes_up_to_n(n: int) -> int: Count the number of prime numbers up to and including n. :param n: Upper limit integer up to which primes are to be counted. :return: Number of prime numbers up to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return sum(sieve)"},{"question":"Flatten Nested Arrays You are given a multi-dimensional array that may contain nested arrays. Your task is to write a function that flattens the array to a single-dimensional array. The function should handle arbitrary levels of nesting and various types of iterables, but it should treat strings as atomic elements (i.e., individual strings should not be broken into their components). Function Signature ```python def flatten_array(input_arr: list) -> list: pass ``` Input * A nested list (which may contain other lists, tuples, sets, etc.) * **Example**: `[[1, 2, [3]], [4, 5], (6, 7, [8, (9, 10)])]` Output * A single flattened list with all elements in their natural order. * **Example**: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` Constraints * Nested arrays/iterables can be arbitrarily deep. * Do not break apart strings into individual characters. Performance Requirements * Your implementation should handle large and deeply nested structures efficiently. * Aim to minimize additional memory usage. Example ```python assert flatten_array([1, [2, [3, [4]]], 5]) == [1, 2, 3, 4, 5] assert flatten_array([1, \'abc\', [2, (3, \'def\')]]) == [1, \'abc\', 2, 3, \'def\'] assert flatten_array([[1, 2, [3]], [4, 5], (6, 7, [8, (9, 10)])]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Implement the function `flatten_array` to solve the problem.","solution":"def flatten_array(input_arr): def flatten_helper(arr): for elem in arr: if isinstance(elem, (list, tuple, set)): yield from flatten_helper(elem) else: yield elem return list(flatten_helper(input_arr))"},{"question":"# Bucket Sort with Index Range Analysis **Scenario**: You\'re working on a performance-critical application that processes large sets of numbers. The application often needs to sort these numbers quickly, and you\'re considering using bucket sort due to its potential efficiency when dealing with certain distributions of data. **Objective**: Your task is to enhance and implement the given `bucket_sort` function. You need to focus particularly on improving it to handle larger, more complex data distributions efficiently. # Requirements 1. **Input**: * An array of integers ( arr ) of length ( n ). Each element in the array will be between 0 and ( 10^6 ). * Example: `[29, 25, 3, 49, 9, 37, 21, 43]` 2. **Output**: * Return the sorted form of the array. 3. **Constraints**: * Consider edge cases such as: * An array containing duplicate elements. * Arrays with very small or very large numbers. * Avoid performance issues related to poor distribution. 4. **Performance**: * Ensure the solution handles an array length up to ( 10^5 ) efficiently. * The solution should be optimized beyond the base `O(n^2)` worst-case complexity if possible. ```python # Your task is to implement and improve the following bucket_sort function def bucket_sort(arr): \'\'\' Efficiently sort an array of integers using bucket sort algorithm. \'\'\' # Implement your code here: # 1. Create buckets and distribute the elements. # 2. Sort each bucket using an appropriate sorting algorithm. # 3. Concatenate the sorted elements from all the buckets. pass # Example usage: assert bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) == [3, 9, 21, 25, 29, 37, 43, 49] ``` **Hint**: Consider adjusting the number of buckets and optimizing the sub-sorting mechanism. You may use a sorting method other than insertion sort if it enhances performance for typical input ranges. --- Evaluate your solution based on correctness and efficiency.","solution":"def bucket_sort(arr): \'\'\' Efficiently sort an array of integers using bucket sort algorithm. \'\'\' if not arr: return arr # Return empty array if input is empty # Determine the minimum and maximum values in the array min_value, max_value = min(arr), max(arr) bucket_size = max(1, (max_value - min_value) // len(arr) + 1) # Compute a suitable bucket size # Create buckets buckets = [[] for _ in range((max_value - min_value) // bucket_size + 1)] # Distribute the elements into buckets for num in arr: index = (num - min_value) // bucket_size buckets[index].append(num) # Sort each bucket and concatenate the result sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array # Example usage (to be replaced with unit tests in the test section): # assert bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) == [3, 9, 21, 25, 29, 37, 43, 49]"},{"question":"Linked List Operations # Objective Design a class to manage a doubly linked list. This class should support core operations such as insertion, deletion, and traversal. The goal is to ensure students understand and correctly implement linked list manipulation. # Requirements Implement a class `DoublyLinkedList` containing the following methods: 1. **insert_at_head(value)**: * Inserts a node with the given value at the head of the list. * **Input**: An integer `value`. * **Output**: None. 2. **delete_by_value(value)**: * Deletes the first node containing the specified value from the list. * **Input**: An integer `value`. * **Output**: None. * **Constraints**: If the value is not found, do nothing. 3. **to_list()**: * Returns a list containing all elements in the doubly linked list from head to tail. * **Input**: None. * **Output**: List of integers. # Scenario Imagine you are developing a simple text editor with an undo feature. Every action (insertion/deletion) is recorded in a doubly linked list to facilitate undo operations efficiently. Implementing these methods would be a step towards building such a system. # Performance Requirements Ensure that the insertion and deletion operations work in O(1) time complexity, given direct access to the nodes. Traversal operations (e.g., `to_list`) should work in O(n) time complexity. ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): # Your code here pass def delete_by_value(self, value): # Your code here pass def to_list(self): # Your code here pass ``` # Example Execution ```python dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_head(20) dll.insert_at_head(30) print(dll.to_list()) # Output: [30, 20, 10] dll.delete_by_value(20) print(dll.to_list()) # Output: [30, 10] ``` # Constraints and Edge Cases * Do not assume the list is initially non-empty. * Handle deletion properly for the head and tail nodes, if applicable. * Ensure the node pointers are correctly updated to maintain the integrity of the list.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is not None: self.head.prev = new_node new_node.next = self.head self.head = new_node def delete_by_value(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: # Move head if necessary self.head = current.next return current = current.next def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Problem Description: Enhanced Counting Sort You are a software engineer at a logistics company where you need to sort large batches of shipment IDs. These shipment IDs are integers but can sometimes include negative values. To make sure that the sorting process is efficient, you have decided to implement an enhanced version of the Counting Sort algorithm which can handle both positive and negative numbers efficiently. # Objective Write a function `enhanced_counting_sort(arr: List[int]) -> List[int]` that sorts an input list of integers (which may include negative values) using an enhanced version of the Counting Sort algorithm. # Input * A list of integers, `arr`, where: * `1 <= len(arr) <= 10^6` * `-10^6 <= arr[i] <= 10^6` for all valid `i` # Output * A sorted list of integers. # Constraints * You may not use Python\'s built-in sorting functions. * Your algorithm must handle both positive and negative numbers efficiently. * The solution should aim to minimize memory usage where possible. # Example ```python # Input arr = [-5, -10, 0, -3, 8, 5, -1, 10] # Output [-10, -5, -3, -1, 0, 5, 8, 10] ``` # Additional Notes * Consider possible edge cases such as lists with only one element, or all elements being the same. * Pay attention to time and space complexity, aiming to keep these within acceptable bounds for large input sizes.","solution":"def enhanced_counting_sort(arr): Sorts an input list of integers (which may include negative values) using an enhanced version of the Counting Sort algorithm. if not arr: return arr min_value = min(arr) max_value = max(arr) # Create the count array count_range = max_value - min_value + 1 count_arr = [0] * count_range # Fill the count array for num in arr: count_arr[num - min_value] += 1 # Rebuild the sorted array index = 0 for i in range(count_range): while count_arr[i] > 0: arr[index] = i + min_value index += 1 count_arr[i] -= 1 return arr"},{"question":"Optimized Sliding Window Maximum Scenario You are working on a large-scale social media analytics platform that continuously processes data to find trends and insights. One common operation is to analyze the maximum value within a sliding window of user activity metrics. Given the need for efficiency due to high data volume, you must optimize the sliding window maximum calculation. Task Write a function `max_sliding_window_optimized(nums, k)` that efficiently computes the maximum value in each sliding window of size `k` within the list `nums`. # Function Signature ```python def max_sliding_window_optimized(nums: List[int], k: int) -> List[int]: ``` # Input - `nums`: List of integers representing the data stream, where (1 leq text{len}(nums) leq 10^5). - `k`: Integer representing the size of the sliding window, (1 leq k leq text{len}(nums)). # Output - List of integers representing the maximum values of each sliding window. # Constraints - The function should run in (O(n)) time complexity. # Example ```python nums = [1,3,-1,-3,5,3,6,7] k = 3 print(max_sliding_window_optimized(nums, k)) # Output: [3, 3, 5, 5, 6, 7] ``` # Performance Requirement Ensure the implementation has linear time complexity relative to the length of the input list to handle large datasets efficiently. # Hints - Utilize a deque to maintain indices of elements in the current window, ensuring the largest element\'s index is always at the front. - Remove indices that fall out of the current window from the deque. - Compare elements to maintain only useful indices in the deque.","solution":"from collections import deque from typing import List def max_sliding_window_optimized(nums: List[int], k: int) -> List[int]: Returns the maximum value in each sliding window of size k for the given list of integers nums. if not nums or k <= 0: return [] n = len(nums) if k == 1: return nums deq = deque() max_values = [] for i in range(n): # Remove elements from the deque that are out of the current window if deq and deq[0] == i - k: deq.popleft() # Remove elements from the deque that are smaller than the current element nums[i] while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add current element at the end of the deque deq.append(i) # The front of the deque is always the largest element index of the previous window if i >= k - 1: max_values.append(nums[deq[0]]) return max_values"},{"question":"# Problem Description You are tasked with implementing a data structure `WordDictionary` that stores words and supports efficient wildcard search. The wildcard character `.` can match any letter. Complete the `WordDictionary` class with the following methods: 1. `add_word(word: str) -> None`: Adds the word to the data structure. 2. `search(word: str) -> bool`: Returns `True` if the word or wildcard string is in the data structure, `False` otherwise. # Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True ``` # Implementation Constraints * All words are strings of lowercase letters (`a-z`). * The length of any word will be at most 50 characters. * Methods will be called at most 10^4 times in total. Your implementation should ensure that the operations, especially search, are efficient even under the upper limit. # Requirements * Implement the `WordDictionary` class with the `add_word` and `search` methods. * Ensure that your solution handles edge cases and is optimized for performance. Starter code: ```python class TrieNode: def __init__(self, letter, is_terminal=False): self.children = {} self.letter = letter self.is_terminal = is_terminal class WordDictionary: def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word: str) -> None: # Implement this method pass def search(self, word: str) -> bool: # Implement this method pass ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_terminal = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_terminal = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_terminal return search_in_node(word, self.root)"},{"question":"Context and Scenario You are given a sequence formed by concatenating all positive integers sequentially, such as \\"123456789101112...\\". Your task is to identify and return the nth digit in this expanding sequence. Rather than generating this sequence to incredible lengths, you need to implement an efficient algorithm. Objective Write a function `find_nth_digit(n)` that returns the nth digit in the concatenated sequence of all natural numbers. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input * An integer `n` (1 ≤ n ≤ 2 * 10^9), representing the position of the digit in the concatenated sequence. Output * A single integer representing the nth digit in the sequence. Example ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 ``` Constraints * Your solution should work efficiently for large values of n up to 2 billion. * Make sure to handle numerical edge cases effectively.","solution":"def find_nth_digit(n: int) -> int: Finds the nth digit in the concatenated sequence of natural numbers. length = 1 # Current length of the numbers we are considering (1 for 1-9, 2 for 10-99, ...). count = 9 # Number of integers of the current length. start = 1 # The first number with the current length. while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit. start += (n - 1) // length # String representation of the target number: num_str = str(start) # Find the nth digit within this number. digit_index = (n - 1) % length return int(num_str[digit_index])"},{"question":"# Instructions: Write a function `letter_combinations` that takes a string of digits and returns all possible letter combinations that the number could represent according to a standard phone\'s digit-to-letters mapping. Your implementation should aim to be efficient and handle various edge cases. Function Signature ```python def letter_combinations(digits: str) -> List[str]: pass ``` # Input: - `digits`: A string consisting of digits only (\'2\' to \'9\'). Example: \\"23\\" # Output: - A list of strings, where each string is a possible letter combination. Example: [\'ad\', \'ae\', \'af\', \'bd\', \'be\', \'bf\', \'cd\', \'ce\', \'cf\'] # Constraints: - The input string can be empty. In such a case, return an empty list. - Assume the input contains only valid digits (\'2\' to \'9\'). # Performance Requirements: - Your solution should efficiently handle combinations generation even if the length of the input string grows. - Ensure that recursion depth and concatenation processes do not excessive strain memory or processing power for moderately long inputs (up to 15 digits). # Example: ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"9\\") == [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] ```","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string of digits, return all possible letter combinations that the number could represent on a standard phone keypad. if not digits: return [] # Mapping of digits to letters phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): # If the current combination is complete if index == len(digits): combinations.append(path) return # Get the letters corresponding to the current digit possible_letters = phone_map[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"# Scenario You are working for a secure communication company that encrypts sensitive messages using the RSA encryption system. You need to implement a function that can generate RSA public and private keys, and functions to encrypt and decrypt messages. # Task Implement the following functions: 1. **`generate_key(bits, seed=None)`**: - **Input**: - `bits` (int): Number of bits for the modulus `n`. - `seed` (int, optional): Seed value for random number generation. - **Output**: Returns a tuple `(n, e, d)` where: - `n` (int): Modulus - `e` (int): Public exponent - `d` (int): Private exponent 2. **`encrypt(data, public_key)`**: - **Input**: - `data` (int): Plaintext message to encrypt. - `public_key` (tuple): A tuple `(e, n)` representing the public key. - **Output**: Returns an integer representing the encrypted message. 3. **`decrypt(data, private_key)`**: - **Input**: - `data` (int): Encrypted message to decrypt. - `private_key` (tuple): A tuple `(d, n)` representing the private key. - **Output**: Returns an integer representing the decrypted plaintext message. # Constraints 1. The number of bits `bits` will be an even number greater than 4. 2. The `data` message must be a non-negative integer smaller than `n`. 3. The implementation must handle edge cases such as invalid input types and values. # Example Usage ```python # Example usage n, e, d = generate_key(64, seed=42) public_key = (e, n) private_key = (d, n) message = 1234 encrypted_message = encrypt(message, public_key) decrypted_message = decrypt(encrypted_message, private_key) assert decrypted_message == message ```","solution":"import random import sympy def generate_key(bits, seed=None): if seed is not None: random.seed(seed) # Ensure bit length is correct if bits <= 4 or bits % 2 != 0: raise ValueError(\\"bits must be an even number greater than 4\\") half_bits = bits // 2 # Generate two distinct prime numbers p and q p = sympy.randprime(2**(half_bits-1), 2**half_bits) q = p while q == p: q = sympy.randprime(2**(half_bits-1), 2**half_bits) n = p * q phi = (p - 1) * (q - 1) # Choose e e = 65537 # common choice for e # Compute d, the modular multiplicative inverse of e modulo phi d = pow(e, -1, phi) return (n, e, d) def encrypt(data, public_key): e, n = public_key if data < 0 or data >= n: raise ValueError(\\"Data must be a non-negative integer smaller than n\\") encrypted_data = pow(data, e, n) return encrypted_data def decrypt(data, private_key): d, n = private_key decrypted_data = pow(data, d, n) return decrypted_data"},{"question":"Context You are working on a grid-based game involving islands. In the game, operations are performed on a grid to turn water cells into land cells. Each new land cell can potentially connect to existing land cells, forming islands. The goal is to track the number of distinct islands after each operation. Task Given a grid of size `m x n`, initially filled with water (`0`s), write a function to count the number of distinct islands after each operation. An island is formed by connecting adjacent land cells horizontally or vertically. Function Signature ```python def num_islands_after_operations(m: int, n: int, positions: List[List[int]]) -> List[int]: pass ``` Input and Output # Input * `m` (int): The number of rows in the grid. * `n` (int): The number of columns in the grid. * `positions` (List[List[int]]): A list of operations represented by positions where each position `[i, j]` turns the cell at `grid[i][j]` from water (`0`) to land (`1`). # Output * Returns a list of integers where each integer represents the number of distinct islands after the corresponding operation. # Constraints * `1 <= m, n <= 1000` * `1 <= len(positions) <= 10^4` * `positions[i]` will not repeat; i.e., the same position will not be added more than once. Example # Example 1: ```python m, n = 3, 3 positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands_after_operations(m, n, positions)) ``` Output: ``` [1, 1, 2, 3] ``` Explanation: Initially: ``` 0 0 0 0 0 0 0 0 0 ``` Operation #1 (`[0, 0]`): ``` 1 0 0 0 0 0 0 0 0 Number of islands = 1 ``` Operation #2 (`[0, 1]`): ``` 1 1 0 0 0 0 0 0 0 Number of islands = 1 ``` Operation #3 (`[1, 2]`): ``` 1 1 0 0 0 1 0 0 0 Number of islands = 2 ``` Operation #4 (`[2, 1]`): ``` 1 1 0 0 0 1 0 1 0 Number of islands = 3 ```","solution":"from typing import List def num_islands_after_operations(m: int, n: int, positions: List[List[int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) # Path compression return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: parent[root_x] = root_y return True return False parent = {} island_count = 0 results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for position in positions: x, y = position index = x * n + y if index not in parent: parent[index] = index island_count += 1 # New island for dx, dy in directions: nx, ny = x + dx, y + dy neighbor_index = nx * n + ny if 0 <= nx < m and 0 <= ny < n and neighbor_index in parent: if union(index, neighbor_index): island_count -= 1 # Merge islands results.append(island_count) return results"},{"question":"# Diffie-Hellman Key Exchange Implementation In this assessment, you will implement the Diffie-Hellman Key Exchange algorithm to demonstrate your understanding of both cryptographic principles and Python programming. # Task 1. Implement a function `generate_prime_candidates(start, end)` that generates a list of prime numbers within a given range. This function should use the `prime_check()` function provided in the snippets. 2. Implement a function `key_exchange(prime, root)` that performs the Diffie-Hellman key exchange operation using the provided prime number and its corresponding primitive root. This function should output both Alice\'s and Bob\'s public keys, as well as the shared secret key. # Inputs 1. **Function `generate_prime_candidates(start, end)`**: - `start`: Integer representing the starting number for prime generation. - `end`: Integer representing the ending number for prime generation. 2. **Function `key_exchange(prime, root)`**: - `prime`: A prime integer used for modular arithmetic. - `root`: A primitive root of the given prime integer. # Outputs 1. **Function `generate_prime_candidates(start, end)`**: List of prime numbers in the given range. 2. **Function `key_exchange(prime, root)`**: A tuple `(alice_public, bob_public, shared_secret)`. # Constraints - `1 <= start < end <= 10^6` - Assume that provided `prime` and `root` in `key_exchange()` function are valid. # Steps 1. Use the given `prime_check` function to implement the `generate_prime_candidates` function. 2. Use the provided key generation and exchange functions to generate and verify the Diffie-Hellman key exchange process in `key_exchange`. # Example ```python # Example usage # Generates prime numbers between 10 and 30 primes = generate_prime_candidates(10, 30) print(\\"Primes:\\", primes) # Perform key exchange with prime=23 and primitive root=5 alice_public, bob_public, shared_secret = key_exchange(23, 5) print(f\\"Alice\'s Public Key: {alice_public}\\") print(f\\"Bob\'s Public Key: {bob_public}\\") print(f\\"Shared Secret Key: {shared_secret}\\") ``` **Note**: Ensure to handle any potential edge cases and maintain efficiency in your implementation.","solution":"def prime_check(n): Returns True if n is a prime number, otherwise False if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_prime_candidates(start, end): Generates a list of prime numbers within a given range [start, end). primes = [] for num in range(start, end): if prime_check(num): primes.append(num) return primes import random def key_exchange(prime, root): Performs the Diffie-Hellman key exchange operation using the provided prime number and root. Returns a tuple of (alice_public, bob_public, shared_secret). # Alice and Bob choose private keys private_alice = random.randint(1, prime - 1) private_bob = random.randint(1, prime - 1) # Generate public keys public_alice = pow(root, private_alice, prime) public_bob = pow(root, private_bob, prime) # Calculate shared secret shared_secret_alice = pow(public_bob, private_alice, prime) shared_secret_bob = pow(public_alice, private_bob, prime) # Both shared secrets should be equal assert shared_secret_alice == shared_secret_bob return public_alice, public_bob, shared_secret_alice"},{"question":"# Context You have been allocated the task of optimizing memory use in a critical financial application. The application performs regular analysis on an array representing daily financial transaction profit and loss. Your task is to determine the maximum possible profit that can be obtained from any contiguous sub-array, but with additional requirements on handling potential zeros in the sub-array. # Question Write a function `max_contiguous_subsequence_sum(arr: List[int]) -> int` that takes a list of integers as input and returns the maximum sum of contiguous sub-array. Additionally: - If the array is empty, your function should return 0. - Ensure your function can handle zeros within the array without sidelining them unless absolutely needed. # Input & Output * **Input**: A list of integers `arr` where -10^5 <= arr[i] <= 10^5. * **Output**: An integer representing the maximum sum of a contiguous sub-array. # Example ```python assert max_contiguous_subsequence_sum([-2, 3, 8, -1, 4]) == 14 assert max_contiguous_subsequence_sum([-1, 1, 0]) == 1 assert max_contiguous_subsequence_sum([]) == 0 assert max_contiguous_subsequence_sum([-1, -3, -4]) == -1 assert max_contiguous_subsequence_sum([-2, 3, 8, -12, 8, 4]) == 12 ``` # Constraints - The array can contain up to 10^5 elements. - The function must be efficient with O(n) time complexity and O(1) space complexity. # Additional Notes - The answer must include proper handling of all edge cases mentioned in the analysis. - Avoid unnecessary extra space usage.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: if not arr: return 0 max_sum = float(\'-inf\') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Context: You are tasked with creating a function to decode messages encoded in a specific format. The encoded string consists of sections such as `k[encoded_string]`, where the encoded_string inside the square brackets repeats exactly `k` times. The input string is guaranteed to be valid, well-formed, and only includes repetitions denoted by positive integers followed by the strings in square brackets. # Function Specification: Your task is to implement the function `decode_string(s)` that takes in a single input parameter: **Parameters:** - `s` (string): The encoded string where `1 <= len(s) <= 30`, and the encoding follows the rules mentioned above. **Returns:** - A string that represents the fully decoded version of the input. # Performance Constraints: - Your solution should run in O(n) time complexity, where `n` is the length of the string `s`. # Example Scenarios: 1. **Example 1:** - Input: `s = \\"3[a]2[bc]\\"` - Output: `\\"aaabcbc\\"` 2. **Example 2:** - Input: `s = \\"3[a2[c]]\\"` - Output: `\\"accaccacc\\"` 3. **Example 3:** - Input: `s = \\"2[abc]3[cd]ef\\"` - Output: `\\"abcabccdcdcdef\\"` # Constraints: - The input `s` will contain only the characters `a-z`, `0-9`, and `[ ]`. - No spaces or invalid format strings are provided as input. - Maximum number of nested brackets is 10. **Write the implementation of the function `decode_string` based on the specifications provided above.**","solution":"def decode_string(s): stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"# Coding Exercise: Implement Word Search with Prefix and Wildcard Support Context: You have been tasked with implementing a data structure that can efficiently store a list of words and allow for quick searches. The search functionality must support the use of the \'.\' character, which can match any letter. This is particularly useful for implementing autocomplete features or solving word puzzle games. Requirements: 1. **Add Word**: Method to add a word to the data structure. 2. **Search Word**: Method to search for a word or pattern with wildcards. Detailed Specifications: *Implement the data structure with the following methods:* 1. `void addWord(word: str) -> None`: - Adds the word to the data structure. 2. `bool search(word: str) -> bool`: - Returns True if the word or wildcard pattern is present; otherwise, returns False. Expected Implementation Behavior: After inserting multiple words, you should be able to search using both exact matches and wildcard patterns. For example: ```python word_dict.addWord(\\"bad\\") word_dict.addWord(\\"dad\\") word_dict.addWord(\\"mad\\") assert word_dict.search(\\"pad\\") == False # \\"pad\\" is not added assert word_dict.search(\\"bad\\") == True # \\"bad\\" is added assert word_dict.search(\\".ad\\") == True # \\".ad\\" can match \\"bad\\", \\"dad\\", \\"mad\\" assert word_dict.search(\\"b..\\") == True # \\"b..\\" can match \\"bad\\" ``` Constraints: 1. Input words consist only of lowercase English letters. 2. Length of words can be up to 5000 characters. 3. Total number of words added can be up to 3x10^4. Additional Considerations: - Focus on optimizing the search operations. - Ensure the solution handles edge cases such as empty strings or full wildcard searches efficiently. **Function Signature**: ```python class WordDictionary: def __init__(self): pass def addWord(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` Develop a solution that is both time-efficient and space-efficient for the above requirements.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.end_of_word"},{"question":"# Question Implement a function `enhanced_euler_totient(n)` which computes the Euler\'s Totient Function in an optimized manner. Specifically, your solution should preprocess prime numbers up to √n to speed up the multiple calls to the function. Function Signature ```python def enhanced_euler_totient(n: int) -> int: pass ``` Input * `n` (1 <= n <= 10^7): an integer. Output * An integer which is the result of Euler\'s Totient Function for the input n. Constraints * The function should optimize multiple calls by leveraging preprocessing steps. * The function should gracefully handle values at the upper limit of the provided constraint. Example ```python assert enhanced_euler_totient(9) == 6 assert enhanced_euler_totient(1) == 1 assert enhanced_euler_totient(6) == 2 assert enhanced_euler_totient(10**7) # Ensure your solution scales for upper constraints. ``` # Context Given the usages of Euler’s Totient function in fields such as cryptography, computational efficiency is crucial. Thus, it is beneficial to preprocess information to handle repeated queries more effectively.","solution":"def enhanced_euler_totient(n: int) -> int: Computes Euler\'s Totient Function in an optimized manner. if n == 1: return 1 # Initialize result as n result = n # Create a list to store prime numbers up to √n primes = sieve(int(n**0.5) + 1) # Check divisibility by prime numbers and reduce n accordingly for prime in primes: if prime * prime > n: break if n % prime == 0: while n % prime == 0: n //= prime result -= result // prime # If n is still greater than 1, it means n is a prime number if n > 1: result -= result // n return result def sieve(limit): Helper function to create a list of primes up to limit using Sieve of Eratosthenes. is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 primes = [] for p in range(2, limit + 1): if is_prime[p]: primes.append(p) return primes"},{"question":"You are given the task of implementing a search feature for a large corpus of text documents. The feature should efficiently find all occurrences of a specified pattern within a given text and return the starting indices of each match. # Objective Write a function `search_pattern` that implements the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of a pattern in a given text. # Function Signature ```python from typing import List def search_pattern(text: str, pattern: str) -> List[int]: Args: text: str - The text where we search the pattern. pattern: str - The pattern to search within the text. Returns: List[int] - A list of starting indices indicating the start of each match of the pattern in the text. ``` # Inputs and Outputs * **Input**: * `text`: A string where the search is performed. * `pattern`: A string which acts as the pattern to find within the text. * **Output**: * A list of integers representing the starting indices of all occurrences of the pattern within the text. If the pattern is not found, return an empty list. # Constraints * `0 <= len(text) <= 10^6` * `0 <= len(pattern) <= 10^6` # Performance Requirements * The solution must operate in linear time complexity, O(N + M), where N is the length of the text and M is the length of the pattern. # Edge Cases to Handle * The pattern is longer than the text. * One or both strings are empty. * Pattern occurs multiple times in succession within the text. * Text and pattern include special characters or have case variations. # Example ```python assert search_pattern(\'abracadabra\', \'abra\') == [0, 7] assert search_pattern(\'aabaaabaaac\', \'aabaaac\') == [4] assert search_pattern(\'hello\', \'world\') == [] assert search_pattern(\'mississippi\', \'issi\') == [1, 4] assert search_pattern(\'\', \'\') == [] ``` # Explanation of Examples 1. In the text \'abracadabra\', the pattern \'abra\' starts at index 0 and 7. 2. In the text \'aabaaabaaac\', the pattern \'aabaaac\' starts at index 4. 3. In the text \'hello\', the pattern \'world\' does not appear, resulting in an empty list. 4. In the text \'mississippi\', the pattern \'issi\' starts at index 1 and 4. 5. An empty string text and an empty pattern should return an empty list.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array using the given pattern. The LPS array is used to skip characters while matching the pattern in the text. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def search_pattern(text: str, pattern: str) -> List[int]: Finds all occurrences of the pattern in the given text using the Knuth-Morris-Pratt (KMP) string matching algorithm. if not text or not pattern: return [] lps = compute_lps(pattern) result = [] i, j = 0, 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Hailstone Sequence Length Given the implementation of the Hailstone sequence in the provided code snippet, your task is to write a function that computes not only the Hailstone sequence but also the total number of steps required to reach 1 from any given positive integer n. Additionally, implement error handling to ensure the function only accepts positive integers. **Function Signature:** ```python def hailstone_length(n: int) -> tuple: Returns the hailstone sequence length and the sequence itself. Parameters: n (int): The positive integer starting point of the hailstone sequence. Returns: tuple: (length of the sequence, the sequence as a list) ``` **Inputs:** - n (int): A positive integer (1 ≤ n ≤ 10^6) **Outputs:** - Returns a tuple containing: - An integer representing the number of steps required to reach 1 - A list containing the Hailstone sequence **Constraints:** - Ensure the function is well-optimized within the given input constraints. - Provide suitable error handling for invalid input values (e.g., non-positive integers). # Examples: ```python assert hailstone_length(1) == (0, [1]) assert hailstone_length(7) == (16, [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]) assert hailstone_length(10) == (6, [10, 5, 16, 8, 4, 2, 1]) ``` # Scenario: Consider you are designing a system to analyze and predict patterns in mathematical sequences. The hailstone sequence is a curious iterative sequence with unpredictable patterns that have perplexed mathematicians. Your task in this scenario is to create a function that computes the sequence and the number of steps required to reach the endpoint (i.e., 1), extracted from the hailstone sequence function provided.","solution":"def hailstone_length(n: int) -> tuple: if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer\\") sequence = [n] while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(n) return len(sequence) - 1, sequence"},{"question":"You have been given a string and your task is to remove any reoccurring characters, returning the new string that consists of only the first unique occurrence of each character. Write a function `remove_duplicates` that implements this string filtering algorithm. # Function Signature ```python def remove_duplicates(input_string: str) -> str: ``` # Input - A single string, `input_string` (1 ≤ len(input_string) ≤ 1000), consisting of printable ASCII characters. # Output - A single string that contains only the first occurrence of each character from the input string, with all subsequent occurrences removed. # Constraints - The input string contains only printable ASCII characters. # Performance Requirements - Your solution should have a time complexity of O(n), where n is the length of the input string. # Example Example 1 Input: `\\"programming\\"` Output: `\\"progamin\\"` Example 2 Input: `\\"abracadabra\\"` Output: `\\"abrcd\\"` Example 3 Input: `\\"mississippi\\"` Output: `\\"misp\\"` # Notes - Consider both case sensitivity and the order of characters as they first appear in the input string. - Think about edge cases such as empty strings, strings with all unique characters, or strings with repeated characters.","solution":"def remove_duplicates(input_string: str) -> str: Remove duplicate characters from a string, only keeping the first occurrence of each character. Parameters: input_string (str): The input string consisting of printable ASCII characters. Returns: str: A string containing only the first occurrence of each character from the input string, with all subsequent occurrences removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Problem Description You are tasked with implementing a function that inverts an n x n matrix using the cofactor method. The function should handle various edge cases and input validations efficiently. Input Format 1. A 2D list `matrix` representing an n x n matrix of integers or floats. Output Format 1. A 2D list representing the inverted matrix if the input matrix is invertible. 2. In case of errors, return a specific list depending on the error type: - If the input is not a matrix: return `[[-1]]` - If the input matrix is not square: return `[[-2]]` - If the matrix is too small (less than 2x2): return `[[-3]]` - If the matrix is singular (determinant is zero): return `[[-4]]` Constraints - The matrix elements will be integers or floats. - The matrix can have up to 100 rows and columns. Example **Input**: ```python matrix = [ [4, 7], [2, 6] ] ``` **Output**: ```python [[0.6, -0.7], [-0.2, 0.4]] ``` # Function Signature ```python def invert_matrix(matrix: List[List]) -> List[List]: # your code here ``` # Detailed Instructions 1. Implement helper functions for the below tasks: - Validating if the input is a proper matrix. - Calculating the determinant of the matrix using recursion. - Finding the minor of a given element in the matrix. - Creating the matrix of minors and applying the \\"checkerboard\\" signs for cofactors. - Transposing and multiplying the matrix by a scalar. 2. Handle edge cases as specified in the output format.","solution":"from typing import List def invert_matrix(matrix: List[List]) -> List[List]: Inverts a given n x n matrix using the cofactor method. Returns special lists for various error types as specified in the instructions. # Helper function to validate the input matrix def is_valid_matrix(matrix: List[List]) -> bool: if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return False return True # Helper function to calculate the determinant of a matrix recursively def determinant(matrix: List[List]) -> float: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): det += ((-1) ** c) * matrix[0][c] * determinant(get_minor(matrix, 0, c)) return det # Helper function to get the minor of a matrix def get_minor(matrix: List[List], row: int, col: int) -> List[List]: return [row[:col] + row[col + 1:] for row in (matrix[:row] + matrix[row + 1:])] # Helper function to calculate the matrix of cofactors def cofactor_matrix(matrix: List[List]) -> List[List]: n = len(matrix) cofactors = [] for r in range(n): cofactor_row = [] for c in range(n): minor = get_minor(matrix, r, c) cofactor_row.append(((-1) ** (r + c)) * determinant(minor)) cofactors.append(cofactor_row) return cofactors # Helper function to transpose a matrix def transpose(matrix: List[List]) -> List[List]: return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix))] # Helper function to validate if a matrix is square def is_square(matrix: List[List]) -> bool: return all(len(row) == len(matrix) for row in matrix) # Check if input is a valid matrix if not is_valid_matrix(matrix): return [[-1]] # Check if the matrix is square if not is_square(matrix): return [[-2]] # Check if matrix is too small n = len(matrix) if n < 2: return [[-3]] # Calculate the determinant of the matrix det = determinant(matrix) if det == 0: return [[-4]] # Calculate the cofactor matrix cofactors = cofactor_matrix(matrix) # Transpose the cofactor matrix cofactors = transpose(cofactors) # Divide each element by the determinant for r in range(n): for c in range(n): cofactors[r][c] /= det return cofactors"},{"question":"Balanced Bracket Validation You are given a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and your task is to determine if the input string is valid. A string is considered valid if: 1. The brackets must be closed in the correct order. 2. Each type of bracket must close properly, e.g., \'()\', \'{}\' and \'[]\' are valid sequences. 3. Every opening bracket must have a corresponding closing bracket of the same type, and brackets must close in the correct order. Implement the function `is_valid` which takes a string `s` as input and returns `True` if the string is valid, and `False` otherwise. Function Signature: ```python def is_valid(s: str) -> bool: # Your code here ``` Input: - `s` : A string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', with `1 <= len(s) <= 10^4`. Output: - Returns `True` if `s` is a valid string of balanced brackets, otherwise returns `False`. Constraints: - The input string will only contain the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Example: ```python print(is_valid(\\"()\\")) # Should return True print(is_valid(\\"()[]{}\\")) # Should return True print(is_valid(\\"(]\\")) # Should return False print(is_valid(\\"([)]\\")) # Should return False print(is_valid(\\"{[]}\\")) # Should return True ``` Ensure your implementation is efficient and can handle the largest input sizes within reasonable time limits.","solution":"def is_valid(s: str) -> bool: Determines if the input string s containing \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are tasked with simulating a Markov chain using the provided Probabilistic Model implementation. Given a Markov chain represented as a dictionary and an initial state, you are to extend the current implementation to include methods for: 1. **Validating the Markov Chain**: Ensure that the provided chain is valid, i.e., all probability distributions for next states sum up to 1. 2. **Generating a Finite Sequence**: Create a function to iterate the Markov chain for a fixed number of steps starting from a given initial state. # Function Specs Function 1: `validate_markov_chain(chain)` * **Input**: * `chain` (dict): A dictionary representing the Markov chain similar to the provided example. * **Output**: * `bool`: Returns `True` if the chain is valid, `False` otherwise. Function 2: `generate_sequence(chain, initial_state, steps)` * **Input**: * `chain` (dict): A dictionary representing the Markov chain similar to the provided example. * `initial_state` (str): The state from which to start the chain. * `steps` (int): The number of steps to iterate. * **Output**: * `List[str]`: A list representing the sequence of states generated. # Constraints * Assume all states and transitions are strings. * All probabilities are non-negative and sum up to 1 for each state. * Steps is a non-negative integer. # Examples ```python # Example Markov Chain chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Validate Markov Chain print(validate_markov_chain(chain)) # True # Generate Sequence print(generate_sequence(chain, \'A\', 5)) # [\'A\', \'E\', \'A\', \'A\', \'E\'] ``` # Hints * You can use the provided helper functions `__choose_state` and `next_state` for choosing the next state. * You can assume that the chain will always have non-negative probabilities for the purpose of this task, even if validation will check for this condition.","solution":"import random def validate_markov_chain(chain): Validates the given Markov chain dictionary. Parameters: - chain (dict): A dictionary representing the Markov chain. Returns: - bool: True if the chain is valid, False otherwise. for state, transitions in chain.items(): total_prob = sum(transitions.values()) if not (0.99 <= total_prob <= 1.01): # allowing a tiny floating-point error margin return False return True def generate_sequence(chain, initial_state, steps): Generates a finite sequence using the provided Markov chain. Parameters: - chain (dict): A dictionary representing the Markov chain. - initial_state (str): The state from which to start the chain. - steps (int): The number of steps to iterate. Returns: - List[str]: A list representing the sequence of states generated. sequence = [initial_state] current_state = initial_state for _ in range(steps): current_state = next_state(chain, current_state) sequence.append(current_state) return sequence def next_state(chain, current_state): Determines the next state in the Markov chain. Parameters: - chain (dict): A dictionary representing the Markov chain. - current_state (str): The current state. Returns: - str: The next state. transitions = chain[current_state] return __choose_state(transitions) def __choose_state(transitions): Chooses the next state based on the state transition probabilities. Parameters: - transitions (dict): A dictionary of transitions with probabilities. Returns: - str: The chosen next state. states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(states, probabilities)[0]"},{"question":"In mathematics, the Fibonacci sequence commonly denoted `Fn`, forms a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. That is: ``` F0 = 0, F1 = 1 Fn = F(n-1) + F(n-2) for n > 1 ``` The Fibonacci sequence starts like this: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... Given a non-negative integer `n`, your task is to write a function that efficiently computes the `n`-th Fibonacci number. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Input A single integer `n` (0 <= n <= 10^6). # Output A single integer, the `n`-th Fibonacci number. # Constraints * You must ensure the implementation is efficient and runs within reasonable time limits for large values of `n`. * You must handle large inputs efficiently in terms of both time and space. # Example 1. `fibonacci(0)` should return `0`. 2. `fibonacci(1)` should return `1`. 3. `fibonacci(10)` should return `55`. # Note * For efficient computation, consider using iterative or optimized dynamic programming approaches to achieve the desired performance.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Scenario You are tasked with providing an efficient algorithm to compute the binomial coefficient for large values of (n) and (k). The recursive solution, though simple, may not perform efficiently for very large inputs due to deep recursion. You are required to optimize this calculation using dynamic programming and memoization to handle large inputs efficiently. Task Write a Python function `binomial_coefficient(n, k)` which calculates the binomial coefficient (C(n, k)) using dynamic programming. # Requirements * **Input**: Two integers `n` and `k` such that (0 leq k leq n). * **Output**: An integer representing the binomial coefficient (C(n, k)). # Constraints: * Ensure the function handles cases up to (n, k leq 1000). * Optimize to avoid repeated computations and potential stack overflow. # Function Signature: ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` Example: * `binomial_coefficient(5, 2)` should return `10`. * `binomial_coefficient(1000, 500)` should return a very large computed binomial coefficient.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using dynamic programming. if k > n: return 0 if k == 0 or k == n: return 1 # Use a DP table to store results of subproblems C = [[0 for _ in range(k + 1)] for _ in range(n + 1)] # Calculate value of Binomial Coefficient in bottom up manner for i in range(n + 1): for j in range(min(i, k) + 1): # Base cases if j == 0 or j == i: C[i][j] = 1 # Calculate value using previously stored values else: C[i][j] = C[i - 1][j - 1] + C[i - 1][j] return C[n][k]"},{"question":"# Bitwise Manipulation Task # Context: You are working on a project that involves manipulating binary representations of integers. To facilitate this, you need to implement a function that combines the functionalities of setting and clearing bits to create a bitwise toggle operation. The toggle operation should change the bit value at a specific index `i` to the opposite value (1 if it’s currently 0, and 0 if it’s currently 1). # Task: Implement a function `toggle_bit(num: int, i: int) -> int` that takes an integer `num` and an index `i` then toggles the bit at index `i` in the binary representation of `num`. # Input: * `num` - An integer representing the number whose bit you want to toggle. * `i` - An integer representing the index of the bit to be toggled. (0-indexed from the least significant bit). # Output: * Returns an integer representing the modified number after toggling the bit at index `i`. # Constraints: * `0 <= num <= 10^9` * `0 <= i < 32` (Assuming we are operating within a 32-bit integer range) # Example: ```python assert toggle_bit(10, 1) == 8 # Binary: 1010 -> 1000 assert toggle_bit(10, 2) == 14 # Binary: 1010 -> 1110 assert toggle_bit(5, 0) == 4 # Binary: 0101 -> 0100 assert toggle_bit(5, 1) == 7 # Binary: 0101 -> 0111 ``` # Additional Notes: * Ensure the solution handles edge cases such as toggling the highest possible indexed bit in the 32-bit range. * Think of the overall time and space efficiency and ensure your implementation adheres to O(1) complexity for both.","solution":"def toggle_bit(num: int, i: int) -> int: Toggles the bit at index i in the binary representation of num. Parameters: num (int): The input number. i (int): The index of the bit to toggle. Returns: int: The modified number after toggling the bit. # Create a bitmask with a 1 at the ith position bitmask = 1 << i # Toggle the bit at index i using XOR return num ^ bitmask"},{"question":"# Question: Root-to-Leaf Paths in a Binary Tree # Scenario You are tasked with developing a module for tree operations in a software engineering toolkit. One of the functions you need to implement is an extractor of all root-to-leaf paths for any given binary tree. Each path should be represented as a string with node values connected by `->`. # Instructions Implement a function `binary_tree_paths` that takes the root node of a binary tree and returns a list of all root-to-leaf paths as strings. # Function Signature ```python def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: ``` # Input - `root`: The root node of the binary tree, which is an object of type `TreeNode` or `None` if the tree is empty. A `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - A list of string paths, where each path represents the value from the root node to a leaf node, with each node value separated by \'->\'. # Constraints - The number of nodes in the tree is in the range [0, 100]. # Example ```python # Example tree: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) assert binary_tree_paths(root) == [\\"1->2->5\\", \\"1->3\\"] # Example tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert binary_tree_paths(root) == [\\"1->2->4\\", \\"1->2->5\\", \\"1->3\\"] ``` # Notes - Ensure your solution handles edge cases such as an empty tree and a single-node tree. - Emphasize efficiency in both time and space complexities.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: if not root: return [] def dfs(node: TreeNode, path: str, paths: List[str]): if not node.left and not node.right: # It\'s a leaf node paths.append(path) if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: Subset Generation Algorithm **Complexity**: * Time Complexity: (O(2^n)), where (n) is the length of `nums`. * Space Complexity: (O(2^n)) for storing all subsets. **Principles**: * The algorithm generates all possible subsets (the power set) of a given list of distinct integers using Backtracking or Iterative methods. * Backtracking involves recursively building subsets by including or excluding each element. * The iterative method iteratively builds subsets by adding each element to existing subsets. **Properties**: * Each subset is unique. * The total number of subsets for a list of length (n) is (2^n). **Common Use Cases**: * Finding all possible combinations to make specific sums (e.g., knapsack problem). * Generating combinations in various combinatorial problems. * Dynamic programming applications where all subproblems need to be considered. **Strengths/Limitations**: * **Strengths**: Simplicity and clarity in generating all subsets. The recursive solution highlights the appealing structure of Backtracking. The iterative solution demonstrates efficient subset building. * **Limitations**: Inefficient for large input sizes due to exponential growth in the number of subsets. **Implementation Challenges**: * **Edge Cases**: Empty input list should return `[[]]`. Inputs with only one element should return `[[], [element]]`. * **Performance Bottlenecks**: * Recursive methods could hit recursion depth limits with large inputs. * Memory use scales exponentially with the number of subsets. * **Error Scenarios**: * Incorrect list slicing/popping or mismanagement of recursion state can lead to incorrect subset generation. * **Optimization Points**: Maintain simplicity in recursion or efficient use of memory with the iterative approach. For extreme cases, consider memoization or iterative approaches. <|Analysis End|> <|Question Begin|> # Problem You are given a set of distinct integers, `nums`. Your task is to implement a function to return all possible subsets (the power set). **Function Signature**: ```python def find_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input - `nums` (List[int]): A list of distinct integers, where (0 leq |nums| leq 10) and (-10 leq nums[i] leq 10). # Output - Returns a list of lists, where each list represents a subset of `nums`. # Constraints 1. The solution set must not contain duplicate subsets. 2. The subsets can be returned in any order. # Example ```python # Example Input nums = [1, 2, 3] # Expected Output [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] ``` # Performance Requirements - Your solution should aim to be efficient in both time and space, keeping in mind the exponential growth of the power set. # Scenario Consider a scenario where you\'re developing an algorithm to generate all combinations of features for a product. Each feature is represented by a distinct integer, and you need to generate every possible combination of these features to evaluate which combinations are feasible for the product. Your task is to design an algorithm that takes the list of feature identifiers and returns all possible combinations of these features in a structured manner. # Additional Notes - Carefully handle base cases, such as an empty list or a list with a single element. - Ensure your function correctly generates all subsets without duplication and maintains clarity in the recursive or iterative approach used.","solution":"from typing import List def find_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of the given list of distinct integers. subsets = [] def backtrack(start, current): subsets.append(list(current)) for i in range(start, len(nums)): current.append(nums[i]) backtrack(i + 1, current) current.pop() backtrack(0, []) return subsets"},{"question":"Context: You are part of a software development team working on an application that needs to efficiently retrieve information. One of your tasks is to efficiently find the first occurrence of a target value in a sorted list of numbers. You decide to use binary search to accomplish this. Problem Statement: Write a function `find_first_occurrence` that takes in two parameters: 1. `array` (List[int]): A list of integers sorted in non-decreasing order. 2. `query` (int): The integer value to search for. Your function should return the index of the first occurrence of the `query` in the `array`. If the `query` is not present in the `array`, return -1. Input: - `array`: A list of integers sorted in non-decreasing order. The length of the array `n` can range from 0 to 10^6. - `query`: An integer value to be searched for. Output: - An integer index representing the first occurrence of the `query` in the `array`. If the `query` is not found, return -1. Constraints: - The function should have a logarithmic time complexity, O(log n). - Avoid using excessive memory beyond a constant space complexity, O(1). Example: ```python def find_first_occurrence(array, query): # Write your code here # Example 1 print(find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2)) # Output: 1 # Example 2 print(find_first_occurrence([5, 7, 7, 8, 8, 10], 8)) # Output: 3 # Example 3 print(find_first_occurrence([1, 2, 3, 4, 5], 0)) # Output: -1 # Example 4 print(find_first_occurrence([], 1)) # Output: -1 ``` **Please implement the `find_first_occurrence` function considering the outlined constraints and edge cases.**","solution":"def find_first_occurrence(array, query): Returns the index of the first occurrence of the query value in the sorted array. If the query is not present, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # search in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Shell Sort Enhanced Version Using principles of the provided Shell Sort algorithm, extend its implementation to optimize its performance using the Knuth sequence for gap sizes. Ensure to handle edge cases and provide a stable sort (if possible). Knuth Sequence The optimal sequence of gaps can be represented as: h = h*3 + 1, where h starts from 1 and grows until it just exceeds the size of the list. # Task Implement the `enhanced_shell_sort` function that sorts an array of integers using an optimized Shell Sort algorithm with Knuth sequence for gaps and ensuring stable sorting where possible. Input - A single list of integers, `arr` where 0 <= len(arr) <= 10^5 and each element -10^6 <= arr[i] <= 10^6. Output - A sorted list in ascending order. # Constraints - The solution should have a better average time complexity than O(n^2). - Implemented function should handle different cases effectively, including an empty array. # Example ```python def enhanced_shell_sort(arr: List[int]) -> List[int]: # Your code here. # Example usage print(enhanced_shell_sort([12, 34, 54, 2, 3])) # Output: [2, 3, 12, 34, 54] print(enhanced_shell_sort([10, -5, 3, 0, 0, 3])) # Output: [-5, 0, 0, 3, 3, 10] ``` # Additional Details - Ensure the solution is efficient and handles large inputs within reasonable time limits. - Properly manage indices to avoid errors.","solution":"def enhanced_shell_sort(arr): Sort an array of integers using an optimized Shell Sort algorithm with Knuth sequence for gaps. n = len(arr) # Generate the Knuth sequence gap = 1 while gap < n // 3: gap = gap * 3 + 1 # Perform the Shell Sort while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"**Question: Implement a Resizable Separate Chaining Hash Table** You are provided with a code snippet of a Separate Chaining Hash Table that stores key-value pairs. This hash table has a fixed size and does not resize itself when the number of elements increases, which can degrade its performance due to increased collisions. Your task is to extend this implementation to support resizing of the hash table when a certain load factor is exceeded. **Requirements**: 1. Implement a method `resize` in the `SeparateChainingHashTable` class, which should be called automatically when the load factor exceeds 0.75. 2. The resizing should double the size of the hash table and rehash all existing keys. 3. Modify the `put` method to check and incite the resizing when necessary. **Input/Output**: - The `SeparateChainingHashTable` class should support the same functionalities as before but should dynamically resize as needed. - The load factor is defined as the ratio of the number of key-value pairs to the size of the hash table. **Constraints**: - The hash table size should always remain a prime number to reduce collisions. Provide a helper method `get_next_prime` to calculate the next prime number greater than the current size. **Performance Requirements**: - Inserting and deleting operations should satisfy the complexity metrics as much as possible. **Example Usage**: ```python table = SeparateChainingHashTable(size=11) table.put(\'a\', 1) table.put(\'b\', 2) # Continues adding entries # Automatically resizes when load factor exceeds 0.75 print(len(table)) # Should adjust size accordingly and rehash elements ``` ```python def get_next_prime(n): # Return the smallest prime number greater than n. def is_prime(x): if x < 2: return False for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return True prime = n + 1 while not is_prime(prime): prime += 1 return prime class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): # Adjusted put method to call resize when necessary load_factor = self._len / self.size if load_factor > 0.75: self.resize() hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next node_.next = Node(key, value) self._len += 1 def resize(self): # Resize the table when the load factor exceeds 0.75 old_table = self._table new_size = get_next_prime(self.size * 2) self.size = new_size self._table = [self._empty] * new_size self._len = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) ```","solution":"def get_next_prime(n): Return the smallest prime number greater than n. def is_prime(x): if x < 2: return False for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return True prime = n + 1 while not is_prime(prime): prime += 1 return prime class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): # Adjusted put method to call resize when necessary load_factor = self._len / self.size if load_factor > 0.75: self.resize() hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while True: if node_.key == key: node_.value = value return if node_.next is None: break node_ = node_.next node_.next = Node(key, value) self._len += 1 def resize(self): # Resize the table when the load factor exceeds 0.75 old_table = self._table new_size = get_next_prime(self.size * 2) self.size = new_size self._table = [self._empty] * new_size self._len = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value)"},{"question":"# Advanced Coding Assessment Question: Background: In resource optimization problems, selecting a minimal cost grouping to cover all needed elements is paramount. For instance, a company wants to choose data packages from various providers, covering all required data points while minimizing cost. Task: Given a universal set `U` and several subsets `S1, S2, ..., Sm` with associated costs, write a Python function that implements a heuristic to find a cost-effective way to cover all elements in `U`. Your solution should: - Use a modified greedy strategy – consider both cost and overlap between subsets to make a more informed choice. Function Signature: ```python def heuristic_set_cover(universe: set, subsets: dict, costs: dict) -> list: pass ``` Input: - `universe (set)`: A set of elements to be covered. - `subsets (dict)`: A dictionary mapping subset names to their sets of elements (e.g., `\'S1\': {1, 2, 3}`). - `costs (dict)`: A dictionary mapping subset names to their costs. Output: - `list`: A list of selected subset names covering all elements in `universe` with an informed heuristic minimizing cost and redundancy. Constraints: - `universe` contains up to 100 elements. - `subsets` contains up to 200 sets. - Costs are positive integers. Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} result = heuristic_set_cover(universe, subsets, costs) print(result) # Expected output can vary, but an ideal solution might include [\'S3\', \'S2\'] or [\'S3\', \'S1\'] ``` Performance: - Aim for a solution that is faster and more scalable than the naive optimal approach, keeping runtime practical for the given constraints. Notes: - Be mindful of edge cases where subsets don\'t fully cover the universe. - Ensure your solution handles overlaps optimally and reduces redundancy in selection.","solution":"def heuristic_set_cover(universe, subsets, costs): Implements a heuristic approach to find a cost-effective way to cover all elements in the universe. Parameters: universe (set): Set of elements that need to be covered. subsets (dict): Dictionary mapping subset names to sets of elements. costs (dict): Dictionary mapping subset names to their respective costs. Returns: list: List of selected subset names covering all elements in the universe. covered = set() selected_subsets = [] # Continue until all elements are covered while covered != universe: best_subset = None best_value = float(\'inf\') # Evaluate each subset for its cost effectiveness for subset in subsets: uncovered_elements = subsets[subset] - covered if uncovered_elements: cost = costs[subset] cost_per_element = cost / len(uncovered_elements) if cost_per_element < best_value: best_value = cost_per_element best_subset = subset # Select the best subset found if best_subset: covered.update(subsets[best_subset]) selected_subsets.append(best_subset) else: raise ValueError(\\"No valid subset to cover the remaining elements in the universe.\\") return selected_subsets"},{"question":"# Bucket Sort Implementation and Optimization Context: You are given an array of non-negative integers. Your task is to implement the bucket sort algorithm to sort the array. Bucket sort works by distributing the elements of an array into several buckets. Each bucket is then sorted individually using another sorting algorithm or recursively using the bucket sort. Challenge: 1. **Implement the Bucket Sort Algorithm**. 2. **Optimize the Individual Bucket Sorting**: Currently, the `next_sort` function uses insertion sort. Modify it to use another efficient sorting algorithm such as Merge Sort or Quick Sort to improve performance. Requirements: * Your function should handle edge cases such as empty arrays and arrays with all similar elements. * Ensure your implementation is optimized for performance. * The input array will contain integers within a fixed range. # Function Signature: ```python def bucket_sort(arr: List[int]) -> List[int]: # Your implementation here ``` # Input * A list of non-negative integers, `arr`, with length `n` (0 ≤ n ≤ 10^5). * The integers are uniformly distributed. # Output * A list of sorted integers. # Constraints * 0 ≤ arr[i] ≤ 10^6 for 0 ≤ i < n * Time complexity should be O(n log n) or better for well-distributed input. Example ```python print(bucket_sort([78, 17, 39, 26, 72, 94, 21, 12, 23, 68])) # Output: [12, 17, 21, 23, 26, 39, 68, 72, 78, 94] ``` # Notes * Consider using a more efficient sorting algorithm for the individual buckets, such as Merge Sort. * Ensure that the bucket strategy works well for the given constraints and the input\'s uniform distribution assumption.","solution":"def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def bucket_sort(arr): if len(arr) == 0: return [] min_value = min(arr) max_value = max(arr) bucket_range = (max_value - min_value) / len(arr) + 1 buckets = [[] for _ in range(len(arr))] for num in arr: index = int((num - min_value) // bucket_range) buckets[index].append(num) sorted_arr = [] for bucket in buckets: sorted_arr.extend(quick_sort(bucket)) return sorted_arr"},{"question":"# Context You are developing a system that involves transmitting and storing binary trees. To facilitate this, you need to implement functions that serialize a binary tree into a string and deserialize a string back into the binary tree. The trees can be binary search trees (BSTs) or arbitrary binary trees. # Task Implement the functions `serialize` and `deserialize` for binary trees. The `serialize` function must create a string representation of the tree using pre-order traversal. The `deserialize` function must rebuild the binary tree from the string. # Function Signatures ```python def serialize(root: TreeNode) -> str: # Your code here def deserialize(data: str) -> TreeNode: # Your code here ``` # Input Format - `serialize` takes input: * `root` (TreeNode): the root node of the binary tree. - `deserialize` takes input: * `data` (str): the string representation of the serialized tree. # Output Format - `serialize` returns a string representing the tree structure. - `deserialize` returns the root TreeNode of the reconstructed tree. # Constraints - The number of nodes in the tree is at most 10^4. - Node values are integers within the range [-10^5, 10^5]. - The string representation might include spaces and special characters but will follow the consistent format from the `serialize` function. - You may assume the implemented functions follow a consistent format without additional input validation for simplicity. # Example Example 1 Input to `serialize`: ``` 1 / 2 3 / 4 5 ``` Output of `serialize`: ``` \\"1 2 # # 3 4 # # 5 # #\\" ``` Input to `deserialize`: ``` \\"1 2 # # 3 4 # # 5 # #\\" ``` Output of `deserialize`: ``` 1 / 2 3 / 4 5 ``` # Notes - Ensure that the deserialized tree matches the structure and values of the original tree after serialization. - The `serialize` and `deserialize` functions must handle edge cases like empty trees and single node trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if not node: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root) def deserialize(data): Decodes your encoded data to tree. def helper(nodes): value = nodes.pop(0) if value == \\"#\\": return None node = TreeNode(int(value)) node.left = helper(nodes) node.right = helper(nodes) return node node_list = data.split() root = helper(node_list) return root"},{"question":"# Red-Black Tree: Implement a Specific Function Context: You are working on a database project where data needs to be stored efficiently using a Red-Black Tree. The Red-Black Tree balances itself keeping the operations (insertion, deletion, and search) efficient. The Red-Black Tree structure has been provided to you. Task: Complete the `delete_min_node` function which deletes the minimum node (node with the smallest value) from the Red-Black Tree and ensures that the Red-Black Tree properties are maintained after deletion. Function Signature: ```python def delete_min_node(self): pass ``` Requirements: - The function `delete_min_node` should locate and remove the smallest element in the tree. - After removal, ensure the tree maintains all the Red-Black Tree properties. - Use the provided helper functions if required (`minimum`, `transplant`, and `delete`). Input: - No direct input to the function; however, the function operates on the existing state of the tree object (`self`). Output: - No direct output; the function will modify the tree in place. Constraints: - The function should execute in O(log n) time complexity. - The tree may be empty, in which case the function should handle it gracefully. Example: Assume we have a Red-Black Tree with the following nodes in order: [1, 4, 5, 7, 8, 11, 14, 15]. Calling `delete_min_node` should result in the smallest node (1) being removed. Next smallest node being 4 should be adjusted to maintain the Red-Black properties. Starter Code: ```python class RBTree: # [... existing methods ...] def delete_min_node(self): # Locate the minimum node min_node = self.minimum(self.root) # Delete the minimum node self.delete(min_node) # Example Usage: if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) rb.delete_min_node() print(rb.inorder()) # Should not contain the smallest node anymore ``` Provide the implementation for the `delete_min_node` function ensuring you preserve the Red-Black Tree properties after deletion.","solution":"class RBNode: def __init__(self, key, color=\'red\'): self.key = key self.color = color self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = RBNode(0) self.TNULL.color = \'black\' self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def delete_min_node(self): if self.root == self.TNULL: return min_node = self.minimum(self.root) self.delete(min_node) def minimum(self, node): while node.left != self.TNULL: node = node.left return node def transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v if v != self.TNULL: v.parent = u.parent def delete(self, node): z = node y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.transplant(y, y.right) y.right = z.right y.right.parent = y self.transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \'black\': self._delete_fix(x) def _delete_fix(self, x): while x != self.root and x.color == \'black\': if x == x.parent.left: w = x.parent.right if w.color == \'red\': w.color = \'black\' x.parent.color = \'red\' self.left_rotate(x.parent) w = x.parent.right if w.left.color == \'black\' and w.right.color == \'black\': w.color = \'red\' x = x.parent else: if w.right.color == \'black\': w.left.color = \'black\' w.color = \'red\' self.right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = \'black\' w.right.color = \'black\' self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == \'red\': w.color = \'black\' x.parent.color = \'red\' self.right_rotate(x.parent) w = x.parent.left if w.right.color == \'black\' and w.right.color == \'black\': w.color = \'red\' x = x.parent else: if w.left.color == \'black\': w.right.color = \'black\' w.color = \'red\' self.left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = \'black\' w.left.color = \'black\' self.right_rotate(x.parent) x = self.root x.color = \'black\' def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def insert(self, key): node = RBNode(key) node.parent = None node.key = key node.left = self.TNULL node.right = self.TNULL node.color = \'red\' y = None x = self.root while x != self.TNULL: y = x if node.key < x.key: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.key < y.key: y.left = node else: y.right = node if node.parent == None: node.color = \'black\' return if node.parent.parent == None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == \'red\': if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \'black\' def inorder(self): def _inorder_helper(n): nonlocal result if n != self.TNULL: _inorder_helper(n.left) result.append(n.key) _inorder_helper(n.right) result = [] _inorder_helper(self.root) return result"},{"question":"# Wiggle Sort Algorithm Implementation Challenge Context You are given an unsorted array of integers, and your task is to reorder the array such that it satisfies the wiggle sort condition. In wiggle sort, for each index `i`, we must have: * If `i` is even, `nums[i]` should be less than or equal to `nums[i + 1]`, if `i + 1` is within bounds. * If `i` is odd, `nums[i]` should be greater than or equal to `nums[i + 1]`, if `i + 1` is within bounds. Your goal is to implement the wiggle sort algorithm, ensuring that the array is modified in place. Input * An array `nums` of integers, where `1 <= len(nums) <= 10^5` and `-10^9 <= nums[i] <= 10^9`. Output * The array `nums` modified in place to meet the wiggle sort condition. Constraints * The function should perform the sort in one pass through the array to achieve linear-time complexity. * The algorithm should operate in constant space, i.e., O(1) auxiliary space. Example ```python def wiggle_sort(nums): # Your code here, utilize the algorithm analysis provided if __name__ == \\"__main__\\": array = [3, 5, 2, 1, 6, 4] print(\\"Original array:\\", array) wiggle_sort(array) print(\\"Wiggle sorted array:\\", array) ``` **Example Run:** ``` Original array: [3, 5, 2, 1, 6, 4] Wiggle sorted array: [3, 5, 1, 6, 2, 4] ``` Notes * Test your code with various edge cases, including arrays with one element or identical elements. * Ensure robust implementation to handle huge inputs efficiently.","solution":"def wiggle_sort(nums): This function reorders the array \'nums\' such that it satisfies the wiggle sort condition. That is, nums[0] <= nums[1] >= nums[2] <= nums[3] >= ... for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 != 0 and nums[i] < nums[i + 1]): # Swap elements if they do not satisfy the wiggle condition nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"**Primality Checker** Your task is to implement a function that checks if a given number is prime. A prime number is a number greater than 1 that has no divisors other than 1 and itself. **Function Signature**: ```python def prime_check(n: int) -> bool: Args: n: int - The number to check for primality. Returns: bool - Returns True if n is a prime number, otherwise returns False. ``` # Input * A single integer `n` where `0 <= n <= 10^18`. # Output * Return `True` if the given number `n` is prime, otherwise return `False`. # Constraints * The input will always be a non-negative integer. * Your function should aim to be efficient in both time and space complexities. * Do not use any imported libraries; implement the logic within the given function. # Examples 1. **Input**: `n = 2` **Output**: `True` **Explanation**: 2 is a prime number. 2. **Input**: `n = 4` **Output**: `False` **Explanation**: 4 is divisible by 2. 3. **Input**: `n = 19` **Output**: `True` **Explanation**: 19 is not divisible by any numbers other than 1 and 19. # Notes 1. Pay attention to edge cases such as small numbers (0, 1, 2, 3). 2. The function should gracefully handle very large inputs up to `10^18`.","solution":"def prime_check(n: int) -> bool: Returns True if n is a prime number, otherwise returns False. Args: n: int - The number to check for primality. Returns: bool - Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are provided with a `DirectedGraph` class which allows you to manage a directed graph by handling nodes and edges. However, this class does not have functionality to check if the graph contains cycles. Your task is to extend this `DirectedGraph` class to include a method `has_cycle` which returns `True` if the graph contains at least one cycle and `False` otherwise. # Task: - Implement the method `has_cycle`. * Input: None * Output: Boolean (`True` or `False`) # Constraints: - The graph may have up to 10,000 nodes. - The graph may have up to 50,000 edges. # Examples: Example 1: - Input graph: ``` A -> B B -> C C -> A ``` - Output: `True` Example 2: - Input graph: ``` A -> B B -> C ``` - Output: `False` # Implementation: Write your solution by extending the provided `DirectedGraph` class. Ensure that your code handles large graphs efficiently given the constraints.","solution":"class DirectedGraph: def __init__(self): self.adjacency_list = {} def add_node(self, node): if node not in self.adjacency_list: self.adjacency_list[node] = [] def add_edge(self, from_node, to_node): if from_node in self.adjacency_list: self.adjacency_list[from_node].append(to_node) else: self.adjacency_list[from_node] = [to_node] def has_cycle(self): visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbour in self.adjacency_list.get(node, []): if dfs(neighbour): return True rec_stack.remove(node) return False for node in self.adjacency_list: if node not in visited: if dfs(node): return True return False"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification - **Algorithm/Data Structure**: - **Algorithm 1**: GCD (Greatest Common Divisor) using Euclid’s Algorithm. - **Algorithm 2**: LCM (Least Common Multiple). - **Algorithm 3**: Counting Trailing Zeroes in Integer’s Binary Representation. - **Algorithm 4**: GCD using Bitwise Operations (Binary GCD Algorithm). - **Complexity**: - **GCD (Euclid’s Algorithm)**: - Time Complexity: O(log(min(a, b))) - Space Complexity: O(1) - **LCM**: - Time Complexity: O(log(min(a, b))) (assuming GCD computation is the bottleneck) - Space Complexity: O(1) - **Trailing Zeroes Count**: - Time Complexity: O(log(x)) - Space Complexity: O(1) - **GCD (Binary GCD)**: - Time Complexity: O(log(a + b)) - Space Complexity: O(1) - **Principles**: - **Euclid’s Algorithm for GCD** uses the principle that `gcd(a, b) = gcd(b, a % b)` until `b` becomes zero. - **Binary GCD Algorithm** leverages bitwise operations to find the GCD, exploiting properties of powers of 2. - **Finding Trailing Zeroes** involves counting consecutive zeroes starting from the least significant bit. Characteristics & Applications - **Properties**: - **GCD (Euclid’s Algorithm)**: Robust, simple iteration. - **Binary GCD**: Eliminates overhead associated with division, replacing with quicker bit-shifting operations. - **LCM**: Dependent on GCD, and works to find a multiple commonly shared by two integers. - **Trailing Zeroes Count**: Efficient in binary manipulation, useful in determining divisibility by powers of 2. - **Common Use Cases**: - **GCD**: Simplifying fractions, number theory problems. - **LCM**: Synchronizing periods, problem-solving in scheduling. - **Trailing Zeroes Count**: Used in compression algorithms, optimizing power of 2 operations. - **Binary GCD**: Useful in hardware implementations, optimization problems. - **Strengths/Limitations**: - **GCD (Euclid’s Algorithm)**: Strength - simplicity and robustness; Limitation - relatively slower than Binary GCD for large numbers. - **Binary GCD**: Strength - faster for large numbers due to lack of division; Limitation - less intuitive, more complex. - **LCM**: Strength - straightforward use of GCD; Limitation - still leads to large number multiplications. - **Trailing Zeroes**: Strength - very efficient; Limitation - only specific to binary properties. Implementation Challenges - **Edge Cases**: - GCD with zero or negative numbers. - LCM where one or both numbers are zero. - Trailing Zeroes where input is zero. - Handling integers\' limits and avoiding overflow. - **Performance Bottlenecks**: - Multiplications in LCM can cause overflows. - Recursive depth in Euclid’s Algorithm if implemented recursively. - **Error Scenarios**: - Input validation, especially handling non-integer or zero inputs. - **Optimization Points**: - Using binary operations for GCD as in Binary GCD. - Avoiding recomputation of GCD within LCM. <|Analysis End|> <|Question Begin|> # Coding Assessment Question **Context**: When dealing with extremely large integers in computational problems, finding common divisors and managing their properties become pivotal. A key task is finding the Least Common Multiple (LCM) of two integers which is crucial in timing cycles, computational math, and organizing periodic events. **Task**: Implement a function `efficient_lcm(a: int, b: int) -> int` that calculates and returns the Least Common Multiple (LCM) of two non-zero integers `a` and `b`. Use a method that optimizes the computation by incorporating the principle of Greatest Common Divisor (GCD). Consider the implementation challenges and be aware of potential integer overflows. # Function Signature ```python def efficient_lcm(a: int, b: int) -> int: ``` # Input - Two non-zero integers `a` and `b`. # Output - Return an integer representing the smallest positive integer that is a multiple of both `a` and `b`. # Constraints - (1 leq |a|, |b| leq 10^{12}) - Inputs are non-zero integers. # Example ```plaintext efficient_lcm(12, 18) Output: 36 efficient_lcm(-4, 5) Output: 20 ``` # Performance Requirements - Efficiently handle large integer values and avoid overflow. - Ensure the solution runs within a reasonable time for upper constraint limits. *Consider edge cases, such as both values being negative, to ensure the function returns a positive LCM using absolute values during calculations.*","solution":"def gcd(a, b): Helper function to calculate the greatest common divisor (GCD) using Euclid\'s Algorithm. while b: a, b = b, a % b return abs(a) def efficient_lcm(a, b): Calculate and return the Least Common Multiple (LCM) of two non-zero integers a and b. # Calculation of LCM using the relationship between GCD and LCM # The absolute is taken to ensure the result is positive even if inputs are negative return abs(a * b) // gcd(a, b)"},{"question":"# Problem Description Given an unsorted array of integers, write a function that finds the length of the longest increasing subsequence (LIS). # Input & Output Formats - **Input**: A single list of integers `sequence` of length `n` (1 <= n <= 10^5) and each element is between -10^5 and 10^5. - **Output**: An integer representing the length of the longest increasing subsequence. # Constraints & Performance Requirements - The solution should work efficiently with time and space complexity approximating O(n log n). - You are not allowed to use any standardized libraries that implement LIS directly. # Example ```python Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. ``` # Function Signature ```python def longest_increasing_subsequence_optimized2(sequence: List[int]) -> int: # Your code here ``` # Scenario Your function will be used in analyzing various transactional datasets to identify trends involving increasing values. Reliability in handling very large datasets efficiently is crucial. # Additional Notes Your implementation should effectively handle the constraints and edge cases discussed. Make sure to test your function with various inputs.","solution":"from typing import List import bisect def longest_increasing_subsequence_optimized2(sequence: List[int]) -> int: Finds the length of the longest increasing subsequence in the given list of integers. Args: sequence (List[int]): A list of integers. Returns: int: The length of the longest increasing subsequence. if not sequence: return 0 lis = [] # This will store the current longest increasing subsequence for num in sequence: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Question: Graph Connectivity Checker Given an undirected graph, determine whether the graph is connected. A graph is connected if there is a path between any pair of vertices. **Input**: - The function `is_graph_connected(graph, start)` should take in: - `graph`: A dictionary representing an undirected graph where keys are node labels and the values are lists of adjacent nodes. - `start`: The starting node for traversal. **Output**: - Returns `True` if the graph is connected, `False` otherwise. **Constraints**: - The graph will contain at least one node. - The graph is undirected, i.e., if there is an edge between nodes `a` and `b`, both `graph[a]` and `graph[b]` will contain each other in their adjacency lists. **Example**: ```python def is_graph_connected(graph, start): pass ``` ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\', \'D\'], \'D\': [\'B\', \'C\', \'E\'], \'E\': [\'D\'] } assert is_graph_connected(graph1, \'A\') == True graph2 = { \'A\': [\'B\'], \'B\': [\'A\', \'C\'], \'C\': [\'B\'], \'D\': [\'E\'], \'E\': [\'D\'] } assert is_graph_connected(graph2, \'A\') == False ``` # Constraints and Performance: - Your solution must handle graphs with up to 10^5 nodes efficiently. - Provide a solution that executes within O(V + E) time complexity.","solution":"def is_graph_connected(graph, start): def dfs(node, visited): visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, visited) visited = set() dfs(start, visited) return len(visited) == len(graph)"},{"question":"# Context You are tasked with implementing and extending a B-tree data structure used to manage the storage of keys with efficient insertion, search, and removal operations. The provided code already implements the core functionalities: insertion and deletion with balancing, and searching. # Problem Statement You must extend the B-tree\'s functionality to include a method that finds the k-th smallest element in the tree. The k-th smallest element is the element that would appear in position k if the elements were sorted. # Requirements 1. Implement the method `find_kth_smallest(self, k: int) -> int` in the `BTree` class. 2. This method should: * Traverse the tree efficiently. * Return the k-th smallest element (1-based index), or raise an `IndexError` if `k` is out of bounds (i.e., `k` <= 0 or `k` > number of elements in the tree). # Input Format - A sequence of `insert_key` operations to populate the B-tree. - An integer `k` representing the position of the element to retrieve. # Output Format - The value of the k-th smallest element in the B-tree. - Raise `IndexError` for invalid `k`. # Constraints - `t` (degree of the B-tree) will always be ≥ 2. - 0 < number of elements in the B-tree < 10^4. - 1 <= k <= number of elements (i.e., you must handle valid range checks). # Example 1. Insert the keys `[20, 10, 30, 50, 40, 70, 80, 60]` in the B-tree. 2. Call `find_kth_smallest(5)` should return `50` as it will be the 5th smallest element in a sorted order. # Implementation Here is the partial starter B-tree: ```python class Node: Class representing a Node in the B-tree def __init__(self): self.keys = [] self.children = [] def __repr__(self): return \\"<Node: {}>\\".format(self.keys) @property def is_leaf(self): return len(self.children) == 0 class BTree: Class representing a B-tree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() def insert_key(self, key): # (insertion logic already provided) def find(self, key) -> bool: # (search logic already provided) def remove_key(self, key): # (remove logic already provided) # Your task is to implement this method def find_kth_smallest(self, k: int) -> int: pass # Example usage: b_tree = BTree(3) keys_to_insert = [20, 10, 30, 50, 40, 70, 80, 60] for key in keys_to_insert: b_tree.insert_key(key) print(b_tree.find_kth_smallest(5)) # Should output 50 ```","solution":"class Node: Class representing a Node in the B-tree def __init__(self): self.keys = [] self.children = [] def __repr__(self): return \\"<Node: {}>\\".format(self.keys) @property def is_leaf(self): return len(self.children) == 0 class BTree: Class representing a B-tree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() def insert_key(self, key): if len(self.root.keys) == self.max_number_of_keys: new_root = Node() new_root.children.append(self.root) self.split_child(new_root, 0) self.root = new_root self.insert_non_full(self.root, key) def split_child(self, parent, index): t = self.max_number_of_keys // 2 new_node = Node() existing_node = parent.children[index] parent.children.insert(index + 1, new_node) parent.keys.insert(index, existing_node.keys[t]) new_node.keys = existing_node.keys[t + 1:] existing_node.keys = existing_node.keys[:t] if not existing_node.is_leaf: new_node.children = existing_node.children[t + 1:] existing_node.children = existing_node.children[:t + 1] def insert_non_full(self, node, key): if node.is_leaf: node.keys.append(key) node.keys.sort() else: index = len(node.keys) - 1 while index >= 0 and key < node.keys[index]: index -= 1 index += 1 if len(node.children[index].keys) == self.max_number_of_keys: self.split_child(node, index) if key > node.keys[index]: index += 1 self.insert_non_full(node.children[index], key) def find(self, key) -> bool: def search_node(node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.is_leaf: return False return search_node(node.children[i], key) return search_node(self.root, key) def remove_key(self, key): # Remove logic (Not required for this task) pass def find_kth_smallest(self, k: int) -> int: def inorder_traversal(node): if node.is_leaf: for key in node.keys: yield key else: for i in range(len(node.keys)): yield from inorder_traversal(node.children[i]) yield node.keys[i] yield from inorder_traversal(node.children[len(node.keys)]) if k <= 0: raise IndexError(\\"k must be a positive integer\\") count = 0 for element in inorder_traversal(self.root): count += 1 if count == k: return element raise IndexError(\\"k exceeds the number of elements in the tree\\") # Example usage: # b_tree = BTree(3) # keys_to_insert = [20, 10, 30, 50, 40, 70, 80, 60] # for key in keys_to_insert: # b_tree.insert_key(key) # print(b_tree.find_kth_smallest(5)) # Should output 50"},{"question":"# Next Bigger Number with Same Digits You are given a positive integer `num`. The task is to find the next higher number that can be formed using the exact same set of digits as the original number. If no such number exists, return `-1`. Function Signature ```python def next_bigger(num: int) -> int: ``` Input - An integer `num` with `1 <= num <= 10^18`. Output - An integer representing the next higher number with the same digits if possible, else `-1`. Constraints - You must handle edge cases such as when the digits of the number form a descending sequence, and single-digit inputs. Performance Requirements - The solution should be efficient with a time complexity of O(n), where n is the number of digits in the number. Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(99999) == -1 ``` Scenario Imagine you are playing a number puzzle game where you\'re given a number, and your task is to rearrange its digits to get the next larger number. If no larger number is possible, you lose the round. Implement this logic programmatically.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Find the right-most digit which is smaller than the digit next to it for i in range(n-2, -1, -1): if digits[i] < digits[i + 1]: break else: # No such digit is found, which means the digits are sorted in descending order return -1 # Find the smallest digit on right side of the (i-th) which is larger than digits[i] for j in range(n-1, i, -1): if digits[j] > digits[i]: break # Swap the found digits digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after the (i-th) position digits = digits[:i+1] + digits[i+1:][::-1] next_bigger_num = int(\\"\\".join(digits)) return next_bigger_num"},{"question":"Find if Path Exists Between Nodes in a Directed Graph Context: You are working on a navigation program that requires determining if there is a path between two places (nodes) on a map represented as a directed graph. You have been provided with a class `Graph` that represents the graph structure. Your task is to implement a method to determine if there is a path between two given nodes in the graph using Depth First Search (DFS). Function to Implement: ```python def is_path(graph, source, target): Determine if there is a path between source and target nodes in the given graph :param graph: Graph object that includes vertex_count and adjacency list :param source: Source node (integer) :param target: Target node (integer) :return: True if there is a path from source to target, False otherwise pass ``` Inputs: * `graph`: Instance of Graph class with methods `add_edge` and attributes `vertex_count` and `graph` (represented as adjacency list). * `source`: Start node index (integer). * `target`: Target node index (integer). Outputs: * Return `True` if there is a path from `source` to `target`. * Return `False` if no such path exists. Constraints: * `1 <= graph.vertex_count <= 10^5` * Nodes are labeled from `0` to `graph.vertex_count - 1`. Example: ```python # Create a graph with 4 vertices g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) # Determine if there is a path from node 1 to node 3 print(is_path(g, 1, 3)) # Output: True # Determine if there is a path from node 3 to node 1 print(is_path(g, 3, 1)) # Output: False ``` Notes: * Make sure your implementation handles large graphs efficiently. * Consider edge cases such as disconnected nodes or cycles within the graph. Good luck!","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = [[] for _ in range(vertex_count)] def add_edge(self, src, dest): self.graph[src].append(dest) def is_path(graph, source, target): def dfs(v, visited): visited[v] = True if v == target: return True for neighbor in graph.graph[v]: if not visited[neighbor]: if dfs(neighbor, visited): return True return False visited = [False] * graph.vertex_count return dfs(source, visited)"},{"question":"You are provided with the implementation of a Separate Chaining Hash Table. Your task is to extend this implementation to automatically resize and rehash the table when the load factor exceeds a given threshold. # Requirements 1. Implement an `rehash` method: * This method should double the size of the existing bucket array and rehash all the existing key-value pairs into the new bucket array. 2. Modify the `put` method to call the `rehash` method when the load factor exceeds a threshold of 0.75. 3. Ensure that the hash table maintains its correct functionality during and after resizing. # Function Signatures: * `def rehash(self):` * Modify `put` method to include a call to `rehash` if load factor exceeds 0.75. # Expected Input and Output Formats: * All inputs will be handled through the methods provided. * The class should maintain its general functionality for insertion, deletion, and lookup after rehashing. # Constraints: * The initial size of the hash table will always be a positive integer and greater than 1. * You need to ensure that the resizing operation is efficient and maintains the average-case time complexity. # Example: ```python # Create a new hash table with default size table = SeparateChainingHashTable() # Inserting multiple elements table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') table.put(\'key3\', \'value3\') table.put(\'key4\', \'value4\') table.put(\'key5\', \'value5\') table.put(\'key6\', \'value6\') table.put(\'key7\', \'value7\') table.put(\'key8\', \'value8\') table.put(\'key9\', \'value9\') # Assuming rehashing happens after inserting the 8th key due to threshold table._table # This table should be resized and rehashed maintaining the existing values ``` # Additional Notes: * Be sure to test edge cases including rehashing an empty table, rehashing with many collisions, and inserting more keys after rehashing to check consistency.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=8): self._initial_size = initial_size self._table = [[] for _ in range(self._initial_size)] self._size = 0 def _hash(self, key): return hash(key) % len(self._table) def put(self, key, value): if self._size / len(self._table) > 0.75: self.rehash() hashed_key = self._hash(key) bucket = self._table[hashed_key] for k, v in bucket: if k == key: bucket.remove((k, v)) break bucket.append((key, value)) self._size += 1 def get(self, key): hashed_key = self._hash(key) bucket = self._table[hashed_key] for k, v in bucket: if k == key: return v return None def remove(self, key): hashed_key = self._hash(key) bucket = self._table[hashed_key] for k, v in bucket: if k == key: bucket.remove((k, v)) self._size -= 1 return True return False def rehash(self): old_table = self._table new_size = len(self._table) * 2 self._table = [[] for _ in range(new_size)] self._size = 0 for bucket in old_table: for key, value in bucket: self.put(key, value)"},{"question":"Implement an Optimized Sorting Algorithm **Context**: You are tasked with improving the performance of an existing sorting system which uses an inefficient sorting algorithm for large datasets. The system currently employs Exchange Sort which results in slow performance for big arrays. **Task**: Implement a more efficient sorting algorithm in Python. You can choose any efficient algorithm (like Quick Sort, Merge Sort, or Heap Sort). Ensure your implementation handles all possible edge cases and provides a correct, stable sort. **Function Signature**: `def optimized_sort(arr: List[int]) -> List[int]:` **Input**: - A list of integers `arr` where 0 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. **Output**: - A list of integers sorted in non-decreasing order. **Constraints**: - The function should handle large arrays efficiently. - Aim for a time complexity better than O(n^2), preferably O(n log n). - Ensure the sorting is stable. **Example**: ```python # Example usage: input_array = [64, 34, 25, 12, 22, 11, 90] sorted_array = optimized_sort(input_array) print(sorted_array) # Output: [11, 12, 22, 25, 34, 64, 90] input_array = [] sorted_array = optimized_sort(input_array) print(sorted_array) # Output: [] ``` **Evaluation Criteria**: - Correctness: The function should return a sorted array for any valid input. - Efficiency: The function should run within optimal time for large inputs. - Handling Edge Cases: The function should gracefully handle edge cases like empty arrays and arrays with single elements.","solution":"from typing import List def optimized_sort(arr: List[int]) -> List[int]: Uses Merge Sort to sort the input list in non-decreasing order. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append remaining elements (if any) sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr middle = len(arr) // 2 left_half = merge_sort(arr[:middle]) right_half = merge_sort(arr[middle:]) return merge(left_half, right_half) return merge_sort(arr)"},{"question":"# Matrix Multiplication Function Implementation **Objective**: You are tasked with implementing a matrix multiplication function in Python. Your function will take two matrices (represented as lists of lists) and return their product. **Function Signature**: ```python def multiply(multiplicand: list, multiplier: list) -> list: ``` **Input**: - `multiplicand`: A list of lists of integers representing the first matrix. The dimensions of this matrix are ( text{m} times text{n} ). - `multiplier`: A list of lists of integers representing the second matrix. The dimensions of this matrix are ( text{p} times text{q} ). - The number of columns in `multiplicand` must be equal to the number of rows in `multiplier`, i.e., ( text{n} = text{p} ). **Output**: - A list of lists of integers representing the product matrix, which will have dimensions ( text{m} times text{q} ). **Constraints**: - You may assume that the input matrices contain only integer values and are well-formed rectangular matrices. - You must handle incompatible matrix dimensions by raising an exception with an appropriate error message. **Example**: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] multiply(multiplicand, multiplier) # Output: [ # [58, 64], # [139, 154] # ] ``` **Performance Requirements**: - The function should run efficiently within the constraints of common matrix dimensions. **Guidelines**: - Initialize the result matrix with zeros. - Use three nested loops to iterate through rows of the multiplicand, columns of the multiplier, and the common dimension for multiplication. - Validate matrix dimensions before performing multiplication. - Address edge cases where dimensions do not match by raising an exception. **Additional Context**: Matrix multiplication is widely used in various fields including scientific computing, data analysis, and machine learning. Ensuring an efficient and correct implementation is crucial for handling large datasets and complex computations.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: # Validate dimensions if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible matrix dimensions for multiplication.\\") # Initialize the result matrix with zeros m, n, q = len(multiplicand), len(multiplicand[0]), len(multiplier[0]) result = [[0 for _ in range(q)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(q): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Scenario You are working on a financial application where you\'re frequently looking up stock prices from a large, uniformly distributed dataset. To optimize the search process, you decide to implement the Interpolation Search algorithm as it is particularly efficient for large, uniformly distributed datasets. Given a sorted list of stock prices and a target price, you want to quickly find the index of the target price if it exists in the list, or return -1 if it does not. # Task Write a function `interpolation_search(array: List[int], search_key: int) -> int` to find the index of `search_key` in `array` using the Interpolation Search algorithm. # Function Signature ```python from typing import List def interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Input * `array`: List of sorted integers representing stock prices. * `search_key`: An integer representing the target price to search for. # Output * Return the index of `search_key` in `array` if found. * Return -1 if `search_key` is not found. # Examples ```python >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 ``` # Constraints * The array is guaranteed to be sorted in increasing order. * The array may contain duplicate elements. * `search_key` can be any integer, including negative numbers. * The length of the array can be up to 10^6. # Performance Requirements * The solution should aim for average-case time complexity of O(log(log n)). * Handle edge cases such as an empty array, and ensure robustness against non-uniformly distributed data where possible.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Performs interpolation search on a sorted array to find the index of search_key. :param array: List[int] - A list of sorted integers. :param search_key: int - The target integer to search for. :return: int - The index of search_key in the array if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: # Avoid division by zero in calculating position probe if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Probing position pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Condition of target found if array[pos] == search_key: return pos # If search_key is larger, search in the right subarray if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the left subarray else: high = pos - 1 return -1"},{"question":"**Bit Manipulation and Arithmetic Operations:** The following task requires implementing functions to perform bit manipulations for an array of integers. Specifically, you must provide implementations for getting, setting, clearing, and updating bits. Additionally, you need to compute the sum of all \'1\' bits in a given range of elements. This will test your comprehension of both bit manipulation and array traversal. **Function Specifications:** 1. `get_bit(num, i)`: - **Input**: `num` (an integer), `i` (index of the bit). - **Output**: The bit at index `i` of the binary representation of `num`. - **Constraints**: `0 <= i < 32` (assuming 32-bit integers). 2. `set_bit(num, i)`: - **Input**: `num` (an integer), `i` (index of the bit to set). - **Output**: An integer with the bit at index `i` set to `1`. - **Constraints**: `0 <= i < 32`. 3. `clear_bit(num, i)`: - **Input**: `num` (an integer), `i` (index of the bit to clear). - **Output**: An integer with the bit at index `i` set to `0`. - **Constraints**: `0 <= i < 32`. 4. `update_bit(num, i, bit)`: - **Input**: `num` (an integer), `i` (index of the bit to update), `bit` (bit value to set, either 0 or 1). - **Output**: An integer with the bit at index `i` updated to the given `bit` value. - **Constraints**: `0 <= i < 32`. 5. `sum_of_set_bits(arr, start, end)`: - **Input**: `arr` (an array of integers), `start` (starting index), `end` (ending index). - **Output**: The sum of all \'1\' bits in the binary representation of elements from `arr[start]` to `arr[end]` inclusive. - **Constraints**: `0 <= start <= end < len(arr)`. **Example:** ```python arr = [5, 7, 15] print(get_bit(5, 0)) # Output: 1 print(set_bit(5, 1)) # Output: 7 print(clear_bit(15, 3)) # Output: 7 print(update_bit(5, 2, 1)) # Output: 5 (since 5 | 100) print(sum_of_set_bits(arr, 0, 2)) # Output: 6 (binary: 101, 111, 1111 => 1+0+1+1+1+1) ``` Implement these functions considering the constraints and be mindful of performance, especially in the `sum_of_set_bits` function when dealing with larger arrays. Good luck!","solution":"def get_bit(num, i): Returns the bit at index i of the binary representation of num. return (num >> i) & 1 def set_bit(num, i): Returns an integer with the bit at index i set to 1. return num | (1 << i) def clear_bit(num, i): Returns an integer with the bit at index i set to 0. return num & ~(1 << i) def update_bit(num, i, bit): Returns an integer with the bit at index i updated to the given bit value. mask = ~(1 << i) return (num & mask) | (bit << i) def sum_of_set_bits(arr, start, end): Returns the sum of all \'1\' bits in the binary representation of elements from arr[start] to arr[end] inclusive. sum_bits = 0 for i in range(start, end + 1): num = arr[i] while num: sum_bits += num & 1 num >>= 1 return sum_bits"},{"question":"You are given an array of integers, and you must implement a sorting algorithm using heap sort in Python. You need to implement both Max Heap Sort and Min Heap Sort functions that sort the array in ascending order. # Function Signature: ```python def max_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: pass def min_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` # Input: - `arr`: A list of integers `arr` representing the array to be sorted. - `simulation`: A boolean flag `simulation`. If `True`, the function should output the array after each operation involving a change in the heap structure. # Output: - Returns the sorted array in ascending order. # Constraints: - The length of the array (`n`) will be between 0 and 10^5. - Each integer `arr[i]` will be between -10^6 and 10^6. # Example: ```python # Max Heap Sort print(max_heap_sort([3, 2, 1, 5, 4], simulation=True)) # Output: # iteration 0 : 3 2 1 5 4 # iteration 1 : 5 2 3 1 4 # iteration 2 : 5 4 3 2 1 # iteration 3 : 5 4 1 2 3 # iteration 4 : 4 3 1 2 5 # iteration 5 : 3 2 1 4 5 # iteration 6 : 4 3 1 2 5 # iteration 7 : 3 2 1 4 5 # iteration 8 : 4 3 1 2 5 # iteration 9 : 3 2 1 4 5 # iteration 10: 3 2 1 4 5 # Min Heap Sort print(min_heap_sort([3, 2, 1, 5, 4], simulation=True)) # Output: # iteration 0 : 3 2 1 5 4 # iteration 1 : 1 2 3 5 4 # iteration 2 : 1 2 3 4 5 # iteration 3 : 2 4 3 1 5 # iteration 4 : 1 2 3 4 5 # iteration 5 : 1 2 3 4 5 # iteration 6 : 2 1 3 4 5 # iteration 7 : 1 2 3 4 5 # iteration 8 : 2 1 3 4 5 # iteration 9 : 1 2 3 4 5 # iteration 10: 2 1 3 4 5 ``` # Notes: 1. Ensure that your functions work for edge cases such as an empty array or an array with a single element. 2. In `simulation` mode, print the array state after every operation that results in a swap or a change in heap structure.","solution":"from typing import List def max_heapify(arr, n, i, simulation): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"heapify: {arr}\\") max_heapify(arr, n, largest, simulation) def max_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"swap: {arr}\\") max_heapify(arr, i, 0, simulation) return arr def min_heapify(arr, n, i, simulation): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\\"heapify: {arr}\\") min_heapify(arr, n, smallest, simulation) def min_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"swap: {arr}\\") min_heapify(arr, i, 0, simulation) arr.reverse() return arr"},{"question":"# Question Description You are given two binary trees, s and t, represented as instances of a TreeNode class. Your task is to implement a function `is_subtree(s: TreeNode, t: TreeNode) -> bool` that checks if t is a subtree of s. A subtree of a tree t is defined as a tree consisting of a node in t and all of its descendants. # Example ```plaintext Input: Tree s: 3 / 4 5 / 1 2 Tree t: 4 / 1 2 Output: true Input: Tree s: 3 / 4 5 / 1 2 / 0 Tree t: 4 / 1 2 Output: false ``` # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: pass ``` # Constraints - Both `s` and `t` can have at most `10^4` nodes. - Node values are unique integers within range `-10^9` to `10^9`. - Handle cases where one or both trees are empty. # Performance Requirements - The solution should be as efficient as possible, ideally better than O(N * M). - Consider memory usage and optimize for it where applicable.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not t: return True # An empty tree t is always a subtree if not s: return False # If s is empty, t cannot be a subtree of s if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"# Maximum Subarray Sum with Indices Given an array of `n` integers, write a function `find_max_subarray` to find the contiguous subarray (containing at least one number) which has the largest sum and return the sum along with the start and end indices of that subarray. Function Signature ```python def find_max_subarray(arr: List[int]) -> Tuple[int, int, int]: pass ``` # Input - `arr`: A list of `n` integers where `1 <= n <= 10^5` and `-10^4 <= arr[i] <= 10^4`. # Output - A tuple containing: - An integer representing the maximum sum of the contiguous subarray. - Two integers representing the start and end indices (0-based) of the subarray yielding the maximum sum. # Constraints - The solution should have a time complexity of `O(n)`. - If multiple subarrays have the maximum sum, return any of them. Example **Input** ```python arr = [1, 2, -3, 4, 5, -7, 23] ``` **Output** ```python (25, 3, 6) ``` **Explanation**: The subarray `[4, 5, -7, 23]` starting at index 3 and ending at index 6 has the largest sum of 25. # Edge cases to consider: - An array with only one element. - An array with all negative elements.","solution":"from typing import List, Tuple def find_max_subarray(arr: List[int]) -> Tuple[int, int, int]: max_sum = float(\'-inf\') current_sum = 0 start = end = temp_start = 0 for i in range(len(arr)): if current_sum <= 0: current_sum = arr[i] temp_start = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, start, end"},{"question":"# Question: Balanced Binary Tree Traversal Given a binary tree, your task is to write a function that returns the in-order traversal of its nodes\' values. You should implement both an iterative version and a recursive version of this in-order traversal. # Function Signature ```python def inorder_iterative(root: Node) -> List[int]: pass def inorder_recursive(root: Node) -> List[int]: pass ``` # Input * `root` (Node): The root node of a binary tree. # Output * (List[int]): List containing the in-order traversal of the tree\'s node values. # Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-1000 <= Node.val <= 1000` # Requirements * Your iterative function should not use recursion. * Your recursive function should not use explicit data structures like lists for traversal. * Both implementations should have a time complexity of O(n). # Example ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 # Tree structure: # 1 # / # 2 3 # / # 4 5 assert inorder_iterative(n1) == [4, 2, 5, 1, 3] assert inorder_recursive(n1) == [4, 2, 5, 1, 3] ``` # Notes * Carefully handle an empty tree input. * Ensure your function caters to trees with nodes only in left or right subtrees.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list: Perform in-order traversal of a binary tree using an iterative approach. if not root: return [] stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list: Perform in-order traversal of a binary tree using a recursive approach. def inorder(node: Node, result: list): if node: inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"You are given a string representing an encoded message where \'A\' -> \'1\', \'B\' -> \'2\', ..., \'Z\' -> \'26\'. Your task is to determine the total number of ways to decode this message. The decoding can only be performed if the encoded sequence falls within the valid range of 1 to 26 and does not contain invalid sequences such as \'0\' as a standalone character. # Function Signature ```python def count_decoding_ways(encoded_message: str) -> int: :param encoded_message: str, a string representing the encoded message. :return: int, the total number of ways to decode the message. ``` # Input * `encoded_message`: A non-empty string containing only digits \'0\'-\'9\'. # Output * Return the total number of ways to decode the message as an integer. # Constraints * The input string will only contain non-negative digits (0-9). * Edge cases include strings starting with \'0\', strings containing consecutive \'0\'s, and various valid/invalid two-digit combinations. # Examples 1. For `encoded_message = \\"12\\"`, the output should be `2` because it can be decoded as \\"AB\\" or \\"L\\". 2. For `encoded_message = \\"226\\"`, the output should be `3` because it can be decoded as \\"BZ\\", \\"VF\\", or \\"BBF\\". 3. For `encoded_message = \\"0\\"`, the output should be `0` because there is no valid decoding. # Additional Remarks Your algorithm should efficiently handle large strings up to the length of 10^4 characters.","solution":"def count_decoding_ways(encoded_message: str) -> int: # Edge case: If the message starts with \'0\', it\'s not decodable. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) # dp[i] will hold the number of ways to decode the message up to the i-th position. dp = [0] * (n + 1) dp[0] = 1 # Base case: empty string has one way to be decoded dp[1] = 1 # Base case: single character string is decoded in one way if it\'s not \'0\' for i in range(2, n + 1): # Check for single-digit decode (1-9) if 1 <= int(encoded_message[i-1:i]) <= 9: dp[i] += dp[i-1] # Check for two-digit decode (10-26) if 10 <= int(encoded_message[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Efficient Contact Directory You are implementing a contact directory that allows efficient storage and lookup of names and phone numbers. The directory can handle collisions using separate chaining. Implement a `ContactDirectory` class with the following methods: 1. **add_contact**(self, name: str, phone_number: str) -> None: - Adds a contact to the directory. If the contact already exists, update the phone number. 2. **get_phone_number**(self, name: str) -> str or None: - Retrieves the phone number for the given contact name. If the contact does not exist, return `None`. 3. **delete_contact**(self, name: str) -> None: - Deletes the contact from the directory. 4. **load_factor**(self) -> float: - Calculates and returns the load factor of the directory (number of contacts / size of the directory). Use a hash table with separate chaining, similar to the implementation provided in the SeparateChainingHashTable class. Your hash table should have an initial size of 11 and should handle collisions appropriately. **Input**: - Strings for `name` and `phone_number`. **Output**: - `add_contact` and `delete_contact` methods do not return anything. - `get_phone_number` method returns a string or `None`. - `load_factor` method returns a float. **Constraints**: - Names and phone numbers are non-empty strings. - Assume that a good-quality hash function is used within Python\'s `hash` function. Example ```python directory = ContactDirectory() directory.add_contact(\'Alice\', \'123-456-7890\') print(directory.get_phone_number(\'Alice\')) # Output: \'123-456-7890\' directory.add_contact(\'Alice\', \'987-654-3210\') print(directory.get_phone_number(\'Alice\')) # Output: \'987-654-3210\' directory.add_contact(\'Bob\', \'555-555-5555\') print(directory.load_factor()) # Output: 0.18181818181818182 (2/11) directory.delete_contact(\'Alice\') print(directory.get_phone_number(\'Alice\')) # Output: None ``` Implement the `ContactDirectory` class below: ```python class ContactDirectory: _empty = None def __init__(self, size=11): # Initialize the contact directory with the specified size self.size = size self._len = 0 self._table = [self._empty] * size def add_contact(self, name, phone_number): # Add code here to add or update contact def get_phone_number(self, name): # Add code here to get contact phone number def delete_contact(self, name): # Add code here to delete a contact def load_factor(self): # Add code here to compute load factor def hash(self, key): return hash(key) % self.size # Write your implementation here ```","solution":"class ContactDirectory: _empty = [] def __init__(self, size=11): # Initialize the contact directory with the specified size self.size = size self._len = 0 self._table = [self._empty.copy() for _ in range(size)] def hash(self, key): return hash(key) % self.size def add_contact(self, name, phone_number): index = self.hash(name) # Look for existing entry and update for item in self._table[index]: if item[0] == name: item[1] = phone_number return # Insert new entry self._table[index].append([name, phone_number]) self._len += 1 def get_phone_number(self, name): index = self.hash(name) for item in self._table[index]: if item[0] == name: return item[1] return None def delete_contact(self, name): index = self.hash(name) for item in self._table[index]: if item[0] == name: self._table[index].remove(item) self._len -= 1 return def load_factor(self): return self._len / self.size"},{"question":"# Merging Intervals and Finding Non-overlapping Intervals **Objective:** Design a Python function to merge overlapping intervals and another to find intervals that do not overlap with any in a given list of intervals. **Background:** In calendar systems, reservation platforms, or any scheduling software, overlapping intervals need to be merged. Additionally, sometimes it is necessary to identify intervals that do not overlap with any in a predefined list. **Steps:** 1. Implement an `interval_merge` function that accepts a list of intervals and merges overlapping ones. 2. Implement a `non_overlapping_intervals` function that accepts two lists: one of intervals and another of candidate intervals, and returns the candidate intervals that do not overlap with any of the main intervals. **Function Specifications:** 1. **interval_merge(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]** - **Input:** A list of tuples representing intervals as start and end points. - **Output:** A list of merged intervals. - **Constraints:** Each interval is represented as a tuple (start, end) where start < end. - **Example:** ```python intervals = [(1, 3), (2, 4), (5, 7)] merged_intervals = interval_merge(intervals) # [(1, 4), (5, 7)] ``` 2. **non_overlapping_intervals(main_intervals: List[Tuple[int, int]], candidates: List[Tuple[int, int]]) -> List[Tuple[int, int]]** - **Input:** Two lists of tuples representing intervals. - **Output:** A list of candidate intervals that do not overlap with any interval in the main intervals. - **Constraints:** Each interval is represented as a tuple (start, end) where start < end. - **Example:** ```python main_intervals = [(1, 3), (2, 4), (5, 7)] candidates = [(0, 1), (3, 5), (7, 8)] results = non_overlapping_intervals(main_intervals, candidates) # [(0, 1), (7, 8)] ``` **Performance Requirements:** 1. Functions should efficiently handle lists with up to 10^5 intervals. 2. Aim for solutions with `O(n log n)` time complexity for sorting steps and `O(n)` for linear traversals. **Edge Cases to Consider:** - Empty lists. - Single interval in the list. - Fully overlapping intervals. - Adjacent but non-overlapping intervals. Implement these functions and ensure they are handling edge cases effectively.","solution":"def interval_merge(intervals): Merges overlapping intervals. if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if merged list is empty or last interval in merged does not overlap with current if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Merge the current interval merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged def non_overlapping_intervals(main_intervals, candidates): Finds candidate intervals that do not overlap with any of the main intervals. if not main_intervals: return candidates # If there\'s no main intervals, all candidates are non-overlapping if they exist if not candidates: return [] # No candidates to check # Merge the main intervals first merged_intervals = interval_merge(main_intervals) non_overlapping = [] def is_overlapping(interval, merged_intervals): for merged in merged_intervals: if interval[0] < merged[1] and merged[0] < interval[1]: return True return False for candidate in candidates: if not is_overlapping(candidate, merged_intervals): non_overlapping.append(candidate) return non_overlapping"},{"question":"# Question: Efficient Text Comparison **Description**: Given two strings `word1` and `word2`, write a function `minDistance(word1, word2)` that calculates the minimum number of steps required to make `word1` and `word2` the same. In each step, you can delete one character in either string. **Input**: - Two strings `word1` and `word2` consisting of lowercase English letters (1 <= len(word1), len(word2) <= 1000). **Output**: - An integer representing the minimum number of steps required. **Constraints**: - Both input strings are non-empty and consist solely of lowercase letters. **Performance Requirements**: - Your solution should have a time complexity of O(n * m) and a space complexity of O(n * m), where n and m are the lengths of `word1` and `word2` respectively. # Example: ```python # Example 1 word1: \\"sea\\" word2: \\"eat\\" # Output: 2 # Explanation: You need one step to delete \'s\' from \\"sea\\" to get \\"ea\\" and another step to delete \'t\' from \\"eat\\" to get \\"ea\\". # Example 2 word1: \\"intention\\" word2: \\"execution\\" # Output: 8 # Example 3 word1: \\"a\\" word2: \\"a\\" # Output: 0 ``` # Implementation Implement the function `minDistance(word1, word2)` in a dynamic programming manner. ```python def minDistance(word1, word2): # Write your code here.to use dynamic programming ```","solution":"def minDistance(word1, word2): Calculates the minimum number of steps required to make word1 and word2 the same by deleting characters from either string. n, m = len(word1), len(word2) # Create a DP table with (n+1) x (m+1) dimensions, initialized to 0 dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the base cases where one of the strings is empty for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 return dp[n][m]"},{"question":"# Connected Components in Graph **Problem Statement**: You are given an undirected graph represented as a list of edges, where each edge is a tuple (u, v), indicating an edge between vertices u and v. You need to implement a function to determine the number of connected components in this graph. **Function Signature**: ```python def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: ``` **Input**: * `n` (int): The number of nodes in the graph. * `edges` (List[Tuple[int, int]]): A list of `edges`, where an edge is represented by a tuple `(u, v)`. **Output**: * An integer representing the number of connected components in the graph. **Constraints**: * `1 ≤ n ≤ 10^5` * `0 ≤ len(edges) ≤ 2 * 10^5` * `0 ≤ u, v < n` * There will be no self-loops (i.e., u ≠ v). **Example**: ```python assert count_connected_components(5, [(0, 1), (1, 2), (3, 4)]) == 2 # Two connected components: {0,1,2} and {3,4} assert count_connected_components(5, [(0, 1), (1, 2), (2, 0), (3, 4)]) == 2 # Two connected components: {0,1,2} and {3,4} assert count_connected_components(4, [(0, 1), (1, 2), (2, 3), (3, 0)]) == 1 # One connected component: {0,1,2,3} ``` # Guidelines: 1. Implement the Union-Find data structure with path compression and union by size. 2. Utilize the Union-Find to determine the number of connected components.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.size = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.size[root_u] < self.size[root_v]: root_u, root_v = root_v, root_u self.parent[root_v] = root_u self.size[root_u] += self.size[root_v] def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: uf = UnionFind(n) for u, v in edges: uf.union(u, v) root_set = set(uf.find(i) for i in range(n)) return len(root_set)"},{"question":"**Context**: You are tasked with building a new text prediction system for a search engine. To efficiently support operations such as fast lookup and predictions based on user input, you decide to use a data structure that stores words in a way that allows you to quickly find all words starting with a given prefix. **Task**: Implement the `SuggestionTrie` class with methods to insert words, search for exact matches, and suggest words based on a given prefix. # Function Specifications Implement the following methods: 1. **`insert(word: str) -> None`**: - Inserts the word into the trie. - **Input**: A word, which consists of lowercase letters (\'a\' to \'z\'). 2. **`search(word: str) -> bool`**: - Returns True if the word is in the trie, else False. - **Input**: The word to be searched. 3. **`suggest(prefix: str) -> List[str]`**: - Returns all words in the trie that start with the given prefix. - **Input**: A prefix string, which consists of lowercase letters (\'a\' to \'z\'). - **Output**: A list of words that start with the given prefix. - **Note**: If no words start with the given prefix, return an empty list. # Constraints: - The maximum length of any word or prefix is 100. - The number of unique words inserted will not exceed 10^4. # Example: ```python trie = SuggestionTrie() trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"healthy\\") trie.insert(\\"heart\\") trie.insert(\\"heat\\") assert trie.search(\\"hell\\") == True assert trie.search(\\"he\\") == False assert trie.suggest(\\"he\\") == [\\"hello\\", \\"hell\\", \\"healthy\\", \\"heart\\", \\"heat\\"] assert trie.suggest(\\"hea\\") == [\\"healthy\\", \\"heart\\", \\"heat\\"] assert trie.suggest(\\"hell\\") == [\\"hello\\", \\"hell\\"] ``` **Note**: - Ensure that the returned lists of words are in lexicographical order. - Your implementation should be optimized for both time and space complexity.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class SuggestionTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._find_node(word) return node is not None and node.is_end_of_word def suggest(self, prefix: str) -> list: node = self._find_node(prefix) suggestions = [] if node: self._collect_words(node, prefix, suggestions) return sorted(suggestions) def _find_node(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def _collect_words(self, node: TrieNode, prefix: str, suggestions: list): if node.is_end_of_word: suggestions.append(prefix) for char, next_node in node.children.items(): self._collect_words(next_node, prefix + char, suggestions)"},{"question":"You are given two integers `a` and `b`. Your task is to implement the extended Euclidean algorithm to find integers `s` and `t` such that `a * s + b * t = GCD(a, b)`, and also to find the modular inverse of `a` under modulus `b` when they are co-prime. # Function Signature ```python def extended_gcd(a: int, b: int) -> (int, int, int): pass def modular_inverse(a: int, b: int) -> int: pass ``` # Input - Two integers `a` and `b` (1 ≤ |a|, |b| ≤ 10^9). # Output - For `extended_gcd(a, b)`: Return a tuple `(s, t, g)` where: - `s` and `t` are the coefficients. - `g` is the GCD of `a` and `b`. - For `modular_inverse(a, b)`: Return the modular inverse, an integer `x` such that `(a * x) % b == 1`. # Constraints - In `modular_inverse`, `a` and `b` must be co-prime. # Examples Example 1 Input: ```python extended_gcd(30, 20) ``` Output: ```python (1, -1, 10) ``` Explanation: - GCD(30, 20) is 10; 30*1 + 20*(-1) = 10. Example 2 Input: ```python modular_inverse(3, 11) ``` Output: ```python 4 ``` Explanation: - The inverse of 3 modulo 11 is 4 since (3 * 4) % 11 = 1. # Notes - Ensure to handle edge cases like when `a` or `b` is zero. - Raise a `ValueError` with an appropriate message if `a` and `b` are not co-prime in the `modular_inverse` function.","solution":"def extended_gcd(a: int, b: int) -> (int, int, int): Extended Euclidean Algorithm to find integers s and t such that: a * s + b * t = gcd(a, b) if b == 0: return (1, 0, a) else: x1, y1, g = extended_gcd(b, a % b) return (y1, x1 - (a // b) * y1, g) def modular_inverse(a: int, b: int) -> int: Find the modular inverse of a under modulus b, assuming a and b are co-prime. s, t, g = extended_gcd(a, b) if g != 1: raise ValueError(f\\"No modular inverse exists for {a} and {b} as they are not co-prime.\\") return s % b"},{"question":"Scenario You are an engineer working on a firmware update for a smart device, which uses flash memory with limited write cycles. To sort the device\'s logs, you need to minimize the number of write operations to the memory. You have been instructed to implement a sorting algorithm that optimizes for minimal write operations. Task Write a function `cycle_sort_min_writes(arr)` in Python that sorts an array of integers using the Cycle Sort algorithm. Ensure that your implementation minimizes the number of write operations, making it optimal for memory with limited write cycles. Function Signature ```python def cycle_sort_min_writes(arr: List[int]) -> List[int]: Sorts the array using cycle sort to minimize the number of write operations. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. pass ``` Input Format * An unsorted list of integers `arr` with length (1 leq len(arr) leq 10^5). Output Format * A sorted list with the same integers, minimizing the number of write operations. Constraints * The elements of the array are integers within the range (-10^9) to (10^9). * The array may contain duplicate elements. * Sorting should be done in-place (no additional memory allowed beyond a constant amount). Performance Requirements * Time complexity should be (O(N^2)) in the worst case. * Space complexity must be (O(1)). Example ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5] print(cycle_sort_min_writes(arr)) # Output: [1, 1, 2, 3, 4, 5, 5, 6, 9] ``` Additional Information While implementing the algorithm, pay attention to handling duplicate values correctly and ensure the process minimization of write operations to memory.","solution":"from typing import List def cycle_sort_min_writes(arr: List[int]) -> List[int]: Sorts the array using cycle sort to minimize the number of write operations. # Function for cycle sort n = len(arr) # Traversing the entire array to find cycles to sort for cycle_start in range(n-1): item = arr[cycle_start] # Find position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If item is already in the correct position if pos == cycle_start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Swap the item with the right position if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start # Find a position to place the element for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Swap the item with the right position if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"**Problem Statement:** You are given two strings `s` and `t` where string `t` is generated by shuffling the string `s` and then adding one additional letter at a random position. Your task is to find the additional letter that was added to string `t`. **Function Signature:** ```python def find_difference(s: str, t: str) -> str: pass ``` **Input:** - `s`: A string consisting of only lowercase letters (1 ≤ len(s) ≤ 10^5). - `t`: A string consisting of only lowercase letters and `t` is of length `len(s) + 1`. **Output:** - Return a single character which is the extra letter added to `t`. **Examples:** ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"xyz\\", \\"xyaz\\") == \'a\' assert find_difference(\\"a\\", \\"aa\\") == \'a\' ``` **Constraints:** - Strings `s` and `t` contain only lowercase English letters. - The difference between `s` and `t` is exactly one character. - Your solution should have an optimal time complexity of O(n) and a constant space complexity. **Context:** Imagine you are working on a text processing application where you need to track changes in strings. In this scenario, being able to quickly identify what has changed is crucial for synchronizing text data in collaborative editing environments. **Performance Requirements:** Your implementation should handle large input sizes efficiently. Considering the constraints, aim for a linear-time solution with minimal space overhead.","solution":"def find_difference(s: str, t: str) -> str: Finds the letter that was added to t which is not in s. # Initialize a variable to store the XOR result result = 0 # Iterate over both strings and perform XOR operation on every character for char in s: result ^= ord(char) for char in t: result ^= ord(char) # The result will be the ASCII value of the added letter return chr(result)"},{"question":"# Context You are working on a project that requires dynamically modifying a list of data entries for a real-time system. Given the dynamic nature of the data, you have opted to use a linked list. Implement a Doubly Linked List (DLL) to efficiently manage reverse traversals and node deletions/insertions at both ends. # Task Implement the `DoublyLinkedList` data structure which supports the following operations efficiently: 1. **Adding a node at the front**. 2. **Adding a node at the end**. 3. **Deleting a node from the front**. 4. **Deleting a node from the end**. 5. **Traversing the list in both forward and backward directions**. # Requirements 1. **Class Definitions**: * `DoublyLinkedListNode` to define a node of the doubly linked list. * `DoublyLinkedList` to manage the linked list. 2. **Expected Functionality**: * `add_first(value)`: Add a node with the specified value at the front. * `add_last(value)`: Add a node with the specified value at the end. * `remove_first()`: Remove the node at the front. * `remove_last()`: Remove the node at the end. * `traverse_forward()`: Return a list of the elements by traversing from head to tail. * `traverse_backward()`: Return a list of the elements by traversing from tail to head. 3. **Input and Output Formats**: * `add_first(value)`: takes an integer value as input. No return value. * `add_last(value)`: takes an integer value as input. No return value. * `remove_first()`: No input. Returns the value of the removed node or `None` if the list is empty. * `remove_last()`: No input. Returns the value of the removed node or `None` if the list is empty. * `traverse_forward()`: No input. Returns a list of node values in order. * `traverse_backward()`: No input. Returns a list of node values in reverse order. # Constraints * Each `DoublyLinkedList` should handle at most `10^6` operations efficiently. * Values in the list are integers within the range of `-10^9` to `10^9`. # Example ```python dll = DoublyLinkedList() dll.add_first(10) dll.add_last(20) dll.add_first(5) print(dll.traverse_forward()) # Output: [5, 10, 20] print(dll.traverse_backward()) # Output: [20, 10, 5] print(dll.remove_first()) # Output: 5 print(dll.traverse_forward()) # Output: [10, 20] print(dll.remove_last()) # Output: 20 print(dll.traverse_forward()) # Output: [10] ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_first(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_last(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def remove_first(self): if not self.head: return None value = self.head.value if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None return value def remove_last(self): if not self.tail: return None value = self.tail.value if self.head == self.tail: self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None return value def traverse_forward(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def traverse_backward(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"Problem Statement: You are provided with a class named `BSTIterator` designed for iterating over a Binary Search Tree (BST) in an in-order manner. The class is partially implemented with its constructor (`__init__`), `has_next()`, and `next()` methods. Your task is to complete the `BSTIterator` class to correctly implement in-order traversal using the provided methods. # Class Definition: ```python class BSTIterator: def __init__(self, root): # Initialize the stack and start the traversal from the root. self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self): # Return whether there is a next smallest number. return bool(self.stack) def next(self): # Return the next smallest number and update the iterator state. node = self.stack.pop() tmp = node if tmp.right: tmp = tmp.right while tmp: self.stack.append(tmp) tmp = tmp.left return node.val ``` # Input: - An instance of `BSTIterator` will be initialized with the root of the BST. - Methods `has_next()` and `next()` will be called to navigate through the BST. # Output: - `has_next()` should return a boolean indicating if the next smallest number is available. - `next()` should return the next smallest number in the BST. # Constraints: - The number of nodes in the tree is at most 10^4. - The values of the nodes are integer and are unique. # Example: ```python # Example Usage: # Consider the following BST: # 7 # / # 3 15 # / # 9 20 # Sample Input: # root = [7, 3, 15, null, null, 9, 20] # You can build the corresponding BST and then: iterator = BSTIterator(root) iterator.next() # return 3 iterator.next() # return 7 iterator.has_next() # return True iterator.next() # return 9 iterator.has_next() # return True iterator.next() # return 15 iterator.has_next() # return True iterator.next() # return 20 iterator.has_next() # return False # The order is consistent with in-order traversal: 3 -> 7 -> 9 -> 15 -> 20 ``` # Requirements: - Implement the methods `__init__(self, root)`, `has_next(self)`, and `next(self)` properly. - Ensure that your solution handles edge cases such as empty trees, trees with single nodes, and balanced as well as skewed trees efficiently.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BSTIterator: def __init__(self, root): Initialize the stack and start the traversal from the root. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to populate the stack with the leftmost nodes. while root: self.stack.append(root) root = root.left def has_next(self): Return whether there is a next smallest number. return len(self.stack) > 0 def next(self): Return the next smallest number and update the iterator state. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"You are given a singly linked list where each node contains a string value. Your task is to implement two different methods for removing duplicates from this list. Method 1: Using an additional data structure Implement a function `remove_duplicates_with_set(head: Node) -> None:` which will remove duplicates using a set to track seen values. The function should maintain the order of the linked list and have a time complexity of O(N) and space complexity of O(N). Method 2: Without using any additional data structure Implement a function `remove_duplicates_without_set(head: Node) -> None:` which will remove duplicates without using any additional data structure. The function should also maintain the order of the linked list but should have a time complexity of O(N^2) and space complexity of O(1). # Input Format - `head` is the head node of a singly linked list where each node contains a string value. # Output Format - Both functions should modify the linked list in-place and return `None`. # Constraints - The values in the nodes are string values with a maximum length of 100 characters. - The length of the linked list will not exceed 10^4 nodes. # Example ```python class Node(): def __init__(self, val=None): self.val = val self.next = None # Linked List: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates_with_set(a1) # The linked list will be modified to: A -> B -> C -> D -> F -> G remove_duplicates_without_set(a1) # The linked list will be modified to: A -> B -> C -> D -> F -> G ``` Write both functions: ```python def remove_duplicates_with_set(head: Node) -> None: # Implement this function pass def remove_duplicates_without_set(head: Node) -> None: # Implement this function pass ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: seen = set() current = head previous = None while current: if current.val in seen: previous.next = current.next else: seen.add(current.val) previous = current current = current.next def remove_duplicates_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are given a string `s` and an integer `k`. Your task is to write a function `caesar_cipher_optimized(s, k)` that: * Encrypts the string `s` by shifting each letter by `k` places in the alphabet. * Non-alphabetic characters in the string should remain unchanged. * The encryption should handle both uppercase and lowercase letters separately. **Function Signature:** ```python def caesar_cipher_optimized(s: str, k: int) -> str: # your code here ``` # Input Format * A string `s` (1 ≤ len(s) ≤ 10^5), consisting of printable ASCII characters. * An integer `k` (0 ≤ k ≤ 10^9). # Output Format * A single string representing the encrypted message. # Constraints * The input string will contain only printable ASCII characters. * The integer `k` can be large, but the resultant shift should always be taken modulo 26. # Performance Requirements * Your solution should be efficient in both time and space. # Examples 1. Input: ```python s = \\"middle-Outz\\" k = 2 ``` Output: ```python \\"okffng-Qwvb\\" ``` 2. Input: ```python s = \\"Hello, World!\\" k = 5 ``` Output: ```python \\"Mjqqt, Btwqi!\\" ``` 3. Input: ```python s = \\"xyz\\" k = 25 ``` Output: ```python \\"wxy\\" ``` # Explanation * In the first example, each letter in \\"middle-Outz\\" is shifted by 2 positions resulting in \\"okffng-Qwvb\\". * In the second example, \\"Hello, World!\\" with a shift of 5 transforms to \\"Mjqqt, Btwqi!\\" while preserving the non-alphabetic characters. * In the third example, the shift wraps around the alphabet due to a value of 25, resulting in \\"wxy\\". Implement your function to adhere to the specified requirements.","solution":"def caesar_cipher_optimized(s: str, k: int) -> str: result = [] k = k % 26 # Reduce the effective shift to within 0-25 for char in s: if \'a\' <= char <= \'z\': new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) result.append(new_char) elif \'A\' <= char <= \'Z\': new_char = chr((ord(char) - ord(\'A\') + k) % 26 + ord(\'A\')) result.append(new_char) else: result.append(char) return \'\'.join(result)"},{"question":"# Red-Black Tree Implementation: Find All Paths # Context Given the full implementation of the Red-Black Tree (RBT) provided in the code snippets, you are expected to extend its functionality. In particular, you need to find and return all paths from the root to all leaves within the RBT. # Task Implement the function `find_all_paths(self)` within the `RBTree` class that finds all paths from the root to every leaf in the tree and returns them as a list of paths. Each path should be represented as a list of node values from the root to the leaf. # Example For a Red-Black Tree with elements inserted in this order: [11, 2, 14, 1, 7, 15, 5, 8, 4], the `find_all_paths` function should output: ```python [ [11, 2, 1], [11, 2, 7, 5, 4], [11, 2, 7, 8], [11, 14, 15] ] ``` # Input * No input parameters. # Output * A list of lists where each inner list is a path from root to a leaf in the Red-Black Tree. # Constraints * The tree could be empty. * Duplicates should not be inserted into the tree. # Performance Requirements * The implemented function should run in O(n) time complexity where n is the number of nodes in the tree. * The space complexity should be O(h) where h is the height of the tree due to the recursion stack. # Implementation You need to implement the `find_all_paths` function within the provided `RBTree` class. ```python class RBTree: # ... [other functions from the provided snippets] def find_all_paths(self): Find and return all paths from root to each leaf node as a list of lists. all_paths = [] # Helper function to traverse the tree and collect paths def dfs(node, current_path): if not node: return # Append current node\'s value to the path current_path.append(node.val) # If it\'s a leaf node, add the current path to all_paths if not node.left and not node.right: all_paths.append(list(current_path)) else: # Continue to traverse the left and right children dfs(node.left, current_path) dfs(node.right, current_path) # Pop the current node from the path as we backtrack current_path.pop() # Start the DFS traversal from the root if root is not None if self.root: dfs(self.root, []) return all_paths # Example usage: if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) print(rb.find_all_paths()) ```","solution":"class Node: def __init__(self, key, color): self.key = key self.color = color self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = Node(0, 0) self.root = self.TNULL def insert(self, key): # Insert the new node into the tree node = Node(key, 1) node.parent = None node.key = key node.left = self.TNULL node.right = self.TNULL node.color = 1 y = None x = self.root while x != self.TNULL: y = x if node.key < x.key: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.key < y.key: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self._fix_insert(node) def _fix_insert(self, k): # Fix the tree colors and rotations after insertion pass def find_all_paths(self): Find and return all paths from root to each leaf node as a list of lists. all_paths = [] def dfs(node, current_path): if node == self.TNULL: return current_path.append(node.key) if node.left == self.TNULL and node.right == self.TNULL: all_paths.append(list(current_path)) else: dfs(node.left, current_path) dfs(node.right, current_path) current_path.pop() if self.root != self.TNULL: dfs(self.root, []) return all_paths"},{"question":"# Fibonacci Sequence Optimization Objective Given a number `n`, write a function that returns the `n`-th Fibonacci number using an efficient approach to handle large inputs, leveraging iterative or any other optimal method. Function Signature ```python def optimized_fibonacci(n: int) -> int: pass ``` Input - `n`: A non-negative integer representing the Fibonacci sequence index (0 ≤ `n` ≤ 10^8). Output - An integer representing the `n`-th Fibonacci number. Constraints - The function should handle very large numbers efficiently without using excessive memory. Requirements 1. **Correctness**: Ensure that the function calculates the correct Fibonacci number. 2. **Performance**: The function should be optimized for large values of `n` with appropriate time and space complexity. 3. **Input Validation**: Include necessary checks and raise appropriate exceptions for invalid inputs. Example ```python print(optimized_fibonacci(10)) # Output: 55 print(optimized_fibonacci(50)) # Output: 12586269025 ``` You should consider varying the implementation to make it both time and space efficient. Discuss the method chosen and justify its selection based on the principles of the algorithm, its complexity, and use case.","solution":"def optimized_fibonacci(n: int) -> int: if not isinstance(n, int) or n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 fib0, fib1 = 0, 1 for _ in range(2, n+1): fib0, fib1 = fib1, fib0 + fib1 return fib1"},{"question":"# Coding Assessment Jump Search Implementation **Scenario**: You\'re a developer for a digital library service that allows users to search for books by their unique ID numbers from a sorted list. You need to efficiently locate a given book ID in this sorted list using a specialized search algorithm known as \\"Jump Search\\". **Task**: You are required to implement a function `jump_search` that takes a sorted list of book IDs and a target book ID, and returns the index of the target book ID if it is present in the list. If the book ID is not present, the function should return -1. **Function Signature**: ```python def jump_search(arr: List[int], target: int) -> int: ``` **Input**: - `arr` (List of ints): A sorted list of book IDs (can be empty). - `target` (int): The book ID to search for. **Output**: - Returns the index (int) of the `target` in the list if found, otherwise -1. **Constraints**: - The length of the array (n) is in the range [0, 10^6]. - The array elements and target are positive integers. **Example**: ```python assert jump_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 15) == 7 assert jump_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 20) == -1 assert jump_search([], 3) == -1 assert jump_search([5], 5) == 0 ``` **Performance Requirements**: - The solution should have a time complexity of O(√n) and a space complexity of O(1).","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: Performs jump search to find the target in the sorted list arr. :param arr: List of sorted integers. :param target: The integer value to search for in arr. :return: The index of target if found, otherwise -1. n = len(arr) if n == 0: return -1 # Finding block size to jump step = int(math.sqrt(n)) # Finding the block where element is present prev = 0 while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in block beginning with prev for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Implementing the Red-Black Tree Data Structure You are provided with the essential skeleton of a Red-Black Tree data structure. This self-balancing binary search tree maintains balance through rotations and recoloring, ensuring efficient search times even after multiple insertions and deletions. Your task is to implement a specific function for the Red-Black Tree. Task Implement the `find` function for the `RBTree` class. The `find` function should search for a node with a given value and return the node if it exists, otherwise return `None`. Function Signature ```python def find(self, value: int) -> RBNode: # implementation here ``` Input - An integer `value` representing the value to search for in the tree. Output - Return the `RBNode` object containing the value if it exists, otherwise return `None`. Constraints - You can assume that the `RBTree` and `RBNode` classes along with other member methods and variables are correctly implemented and available for use. - The tree does not contain duplicate values. Example ```python # Given the following code: rb = RBTree() values = [20, 15, 25, 10, 5, 1] for val in values: node = RBNode(val, 1) rb.insert(node) # Example usage: node = rb.find(10) print(node.val if node else \\"Node not found\\") # Output should be 10 node = rb.find(99) print(node.val if node else \\"Node not found\\") # Output should be \\"Node not found\\" ``` Hints - Use the inherent properties of the binary search tree to navigate through the tree. - Remember that the Red-Black Tree is a binary search tree with extra properties for balancing.","solution":"class RBNode: def __init__(self, val, color=1): self.val = val self.color = color # 1 for Red, 0 for Black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL = RBNode(val=None, color=0) self.root = self.NIL def find(self, value: int) -> RBNode: Find a node with the given value in the Red-Black Tree. Return the node if found, otherwise return None. def search_tree(node, value): if node == self.NIL or node.val == value: return node if value < node.val: return search_tree(node.left, value) else: return search_tree(node.right, value) result = search_tree(self.root, value) return result if result != self.NIL else None"},{"question":"Prime Sequence Analysis In this coding challenge, you will implement a function that checks a sequence of numbers and identifies ranges where all the numbers are prime. This test assesses your ability to work with the prime checking algorithm and apply it to sequences of numbers. # Problem Statement Write a function `find_prime_ranges(seq: List[int]) -> List[Tuple[int, int]]` that takes a list of integers as input and returns a list of tuples representing ranges `[start, end)` where all numbers between `start` and `end-1` (inclusive) are prime. # Input Format - `seq`: A list of integers (length up to 10^5), not necessarily sorted, where each element is between 1 and 10^6. # Output Format - A list of tuples, where each tuple `(start, end)` indicates a range [start, end) of consecutive prime numbers in `seq`. - Ranges must be maximal, i.e., cannot be extended by adding one more element from `seq` to either side without breaking the all-prime property. # Constraints - The length of `seq` may be up to 10^5. - Each number in `seq` is between 1 and 10^6. # Examples Example 1: ```python seq = [11, 7, 3, 2, 5, 4, 13] Output: [(11, 12), (7, 8), (3, 4), (2, 3), (5, 6), (13, 14)] ``` Example 2: ```python seq = [14, 15, 23, 29, 31, 35, 37, 41] Output: [(23, 24), (29, 32), (37, 38), (41, 42)] ``` # Notes - You need to implement an efficient prime checking helper function if you need one, or you can use the provided `prime_check` function code. - Performance is key; consider optimizing your approach for prime checking and iterating over the sequence.","solution":"from typing import List, Tuple def is_prime(n: int) -> bool: Determines if a given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_prime_ranges(seq: List[int]) -> List[Tuple[int, int]]: Finds and returns ranges of consecutive prime numbers in the given sequence. prime_ranges = [] for num in seq: if is_prime(num): prime_ranges.append((num, num + 1)) return prime_ranges"},{"question":"Substring Search Enhancement In this task, you are required to enhance the performance of the given substring search algorithm. The existing algorithm uses a simple linear search that results in an O(n*m) time complexity, which can be inefficient for larger texts and patterns. Your objective is to implement the Knuth-Morris-Pratt (KMP) algorithm to improve the search efficiency. Background The **Knuth-Morris-Pratt (KMP) algorithm** is a string searching (or substring searching) algorithm that searches for occurrences of a \\"word\\" (pattern) within a main \\"text\\" (haystack) by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters. Steps to Implement 1. **Prefix Function**: Create a partial match table (also known as \\"prefix function\\") for the pattern `needle` which indicates the longest prefix which is also a suffix. 2. **KMP Search Function**: Use the prefix function to search the `needle` within the `haystack` efficiently. Expected Input and Output Formats * **Input**: * `haystack`: A string within which the search is performed. * `needle`: A string pattern to search for. * **Output**: * Returns the index of the first occurrence of the `needle` in the `haystack`, or -1 if the `needle` is not found. Constraints * The function should handle cases where `haystack` or `needle` can be empty strings. * Function should adhere to an improved time complexity of O(n+m). Function Signature ```python def contain_string_kmp(haystack: str, needle: str) -> int: pass ``` Example ```python # Example 1 assert contain_string_kmp(\\"hello\\", \\"ll\\") == 2 # Example 2 assert contain_string_kmp(\\"aaaaa\\", \\"bba\\") == -1 # Example 3 assert contain_string_kmp(\\"\\", \\"\\") == 0 # Example 4 assert contain_string_kmp(\\"a\\", \\"a\\") == 0 # Example 5: assert contain_string_kmp(\\"abcdef\\", \\"def\\") == 3 ``` Notes * Consider edge cases where the `needle` is empty or longer than the `haystack`. * Optimize for performance and ensure that your solution is more efficient than the naive approach.","solution":"def compute_prefix_function(needle): m = len(needle) lps = [0] * m length = 0 i = 1 while i < m: if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def contain_string_kmp(haystack, needle): n = len(haystack) m = len(needle) if m == 0: return 0 if n == 0 or m > n: return -1 lps = compute_prefix_function(needle) i = j = 0 while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"Problem Statement: You\'re tasked with developing a library for working with various numerical bases. The library will include two main functions: one to convert from a base-10 integer to a different base, and another to convert from a string representation in a specific base back to a base-10 integer. Your job is to implement these two functions accurately and efficiently. **Function 1: `int_to_base(num, base)`** - **Input**: - `num` (int): A base-10 integer which can be positive, zero, or negative. - `base` (int): The base to convert the number to. This value will be between 2 and 36 (inclusive). - **Output**: - A string representing the number in the specified base. **Function 2: `base_to_int(str_to_convert, base)`** - **Input**: - `str_to_convert` (str): A string representing a number in the specified base. - `base` (int): The base in which the number is represented. This value will be between 2 and 36 (inclusive). - **Output**: - An integer representing the base-10 value of the input string. **Constraints**: - For `int_to_base`, handle all integers, including negative values. - For `base_to_int`, ensure the input string only contains valid characters for the specified base. - Do not use Python\'s built-in `int()` function for `base_to_int`. **Example**: ```python assert int_to_base(5, 2) == \'101\' assert base_to_int(\'101\', 2) == 5 assert int_to_base(15, 16) == \'F\' assert base_to_int(\'F\', 16) == 15 ``` Your implementations should handle edge cases gracefully and efficiently.","solution":"def int_to_base(num, base): Convert a base-10 integer to a string representation in the specified base. :param num: int, the integer to be converted :param base: int, the base to convert to (between 2 and 36) :return: str, the number represented in the specified base if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \'-\' if num < 0 else \'\' num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base return sign + \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string representation of a number in the specified base to a base-10 integer. :param str_to_convert: str, the string to be converted :param base: int, the base of the number (between 2 and 36) :return: int, the base-10 integer value of the input string if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {char: index for index, char in enumerate(digits[:base])} sign = -1 if str_to_convert[0] == \'-\' else 1 if str_to_convert[0] in \'-+\': str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: if char not in digit_map: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") result = result * base + digit_map[char] return sign * result"},{"question":"You are given a list of integers and two optional integer limits: `min_lim` and `max_lim`. Your task is to write a function `limit(arr, min_lim=None, max_lim=None)` that returns a new list containing only the values that are within the specified range, inclusive. If `min_lim` is not provided (`None`), the function should consider the minimum possible value as -infinity. Similarly, if `max_lim` is not provided (`None`), the function should consider the maximum possible value as infinity. # Input Format - `arr`: A list of integers. - `min_lim`: An optional integer representing the lower bound (inclusive) of the values to be included in the result. Default is `None`. - `max_lim`: An optional integer representing the upper bound (inclusive) of the values to be included in the result. Default is `None`. # Output Format - The function should return a list of integers that fall within the specified range. # Constraints - The length of `arr` (n) could be up to 10^6. - Each integer in `arr` could be up to 10^9 or as low as -10^9. # Performance Requirements - The function should operate within O(n) time complexity. - The space complexity should be O(n) for storing the output list. # Example ```python # Example 1 print(limit([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] # Example 2 print(limit([10, 20, 30, 40, 50], 15, 45)) # Output: [20, 30, 40] # Example 3 print(limit([-5, -10, -15, 0, 5, 10], -10, 10)) # Output: [-5, -10, 0, 5, 10] # Example 4 print(limit([1, 5, 10, 15, 20], 25, 30)) # Output: [] # Example 5 print(limit([1, 2], 0, None)) # Output: [1, 2] # Example 6 print(limit([], 0, 5)) # Output: [] ``` # Additional Information - Ensure your function correct handles edge cases, including when provided `None` for one or both limits and when the input list is empty. - Optimize your function to handle very large lists with millions of integers efficiently.","solution":"def limit(arr, min_lim=None, max_lim=None): Returns a list of integers within the specified range, inclusive. Parameters: arr (list): List of integers. min_lim (int, optional): Minimum limit (inclusive). Defaults to None. max_lim (int, optional): Maximum limit (inclusive). Defaults to None. Returns: list: A list of integers within the specified range. # Handle the case when min_lim or max_lim is not provided if min_lim is None: min_lim = float(\'-inf\') if max_lim is None: max_lim = float(\'inf\') return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are provided with functions `max_heap_sort` and `min_heap_sort` that sort an array in ascending order using heap sort with a max-heap and min-heap, respectively. You need to implement a function `smart_heap_sort` that dynamically selects between `max_heap_sort` and `min_heap_sort` based on the characteristics of the input array. The selection criteria are as follows: - Use `max_heap_sort` if the median of the array is greater than its mean. - Use `min_heap_sort` otherwise. # Objective Implement the function `smart_heap_sort(arr, simulation=False)` that sorts the array `arr` using either `max_heap_sort` or `min_heap_sort` depending on the median and mean values of the array. # Function Signature ```python def smart_heap_sort(arr: list[int], simulation: bool=False) -> list[int]: ``` # Input - `arr`: A list of integers `arr` (0 ≤ len(arr) ≤ 10^6). Note that the array can be empty. - `simulation`: A boolean indicating whether to print each iteration of the sorting process (for testing/debugging purposes). # Output - Returns the sorted array in ascending order. # Constraints - The time complexity should be O(n log(n)), maintaining the efficiency of heap sort. - Memory usage should be O(1). # Example ```python print(smart_heap_sort([4, 1, 7, 8, 3])) # Output should be [1, 3, 4, 7, 8] print(smart_heap_sort([10, -1, 3, 15, 7, 8])) # Output should be [-1, 3, 7, 8, 10, 15] ``` # Notes - You do not need to implement `max_heap_sort` and `min_heap_sort` as they are already provided. - For simplicity, use built-in functions to calculate mean and median. - Ensure your selection process between `max_heap_sort` and `min_heap_sort` is efficient.","solution":"import statistics def max_heap_sort(arr: list[int]) -> list[int]: Sorts a list in ascending order using heap sort with a max-heap. Placeholder function. import heapq # Convert array to a max heap by negating all values and using heapq which is a min-heap. neg_arr = [-a for a in arr] heapq.heapify(neg_arr) sorted_arr = [-heapq.heappop(neg_arr) for _ in range(len(neg_arr))] sorted_arr.reverse() # Since we want ascending order, we reverse the descending order list. return sorted_arr def min_heap_sort(arr: list[int]) -> list[int]: Sorts a list in ascending order using heap sort with a min-heap. Placeholder function. import heapq heapq.heapify(arr) return [heapq.heappop(arr) for _ in range(len(arr))] def smart_heap_sort(arr: list[int], simulation: bool = False) -> list[int]: Sorts the list in ascending order using either max_heap_sort or min_heap_sort based on the median and mean of the array. if len(arr) == 0: return [] median = statistics.median(arr) mean = sum(arr) / len(arr) if simulation: print(f\\"Array: {arr}, Median: {median}, Mean: {mean}\\") if median > mean: return max_heap_sort(arr) else: return min_heap_sort(arr)"},{"question":"# Question: Implement and Optimize an Advanced Word Storage and Search System **Context** You are tasked with implementing a system that efficiently supports adding words and searching for words with support for wildcard-like pattern searches. This is ideally suited for applications such as autocomplete systems, dictionary-based searches, and spell-checkers. You will implement two structures: - A Trie-based word dictionary. - A Hash Map + List-based word dictionary. **Requirements** 1. Implement a class `WordDictionary` using Tries that supports: - `add_word(word: str) -> None`: Adds a word to the dictionary. - `search(word: str) -> bool`: Searches for the word in the dictionary. `word` may contain the `\'.\'` character, which can match any letter. 2. Implement a class `WordDictionary2` using Hash Map + List that supports: - `add_word(word: str) -> None`: Adds a word to the dictionary. - `search(word: str) -> bool`: Searches for the word in the dictionary. `word` may contain the `\'.\'` character, which can match any letter. **Input/Output Format**: For `WordDictionary` and `WordDictionary2`, implement: - `def add_word(self, word: str) -> None:` - `def search(self, word: str) -> bool:` - `add_word(\'bad\')` should store \\"bad\\". - `search(\'bad\')` should return `True`. - `search(\'b..\')` should return `True`. - `search(\'b...\')` should return `False`. - `search(\'.ad\')` should return `True`. **Constraints**: - The words added will only consist of lowercase English letters. - Each added or searched word\'s length will be in the range [1, 1000]. - The number of operations (add + search) will not exceed 10^4. **Performance**: - Ensure your solutions handle up to 10^4 operations efficiently. - Time complexity analysis and possible optimizations should be considered. Here\'s the skeleton for your classes: ```python class WordDictionary: def __init__(self): # Initialize your data structure here pass def add_word(self, word: str) -> None: # Implements add word functionality pass def search(self, word: str) -> bool: # Implements search functionality pass class WordDictionary2: def __init__(self): # Initialize your data structure here pass def add_word(self, word: str) -> None: # Implements add word functionality pass def search(self, word: str) -> bool: # Implements search functionality pass ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root) class WordDictionary2: def __init__(self): self.words_by_length = {} def add_word(self, word: str) -> None: length = len(word) if length not in self.words_by_length: self.words_by_length[length] = [] self.words_by_length[length].append(word) def search(self, word: str) -> bool: length = len(word) if length not in self.words_by_length: return False for candidate in self.words_by_length[length]: if all(char == cand_char or char == \'.\' for char, cand_char in zip(word, candidate)): return True return False"},{"question":"You are given a non-negative integer represented as an array of digits, arranged in big-endian format such that the most significant digit is at index 0. You need to implement a function that adds one to this integer and returns the result as an array of digits in the same format. # Function Signature ```python def add_one(digits: List[int]) -> List[int]: pass ``` # Input - `digits` (List[int]): A list of digits where each digit is an integer from 0 to 9, representing a non-negative integer in big-endian format. # Output - Returns a list of integers representing the original number incremented by one, keeping the same format. # Constraints - The input list is non-empty and contains no leading zeros (except for the number \'0\'). - The input number represented by the list does not have a predefined length (it can be very large). # Example ```python add_one([1, 2, 3]) # Output: [1, 2, 4] add_one([9, 9, 9]) # Output: [1, 0, 0, 0] add_one([0]) # Output: [1] ``` # Requirements - Your solution should handle cases efficiently with large inputs. - Ensure that space usage is minimal. - Think through edge cases and common pitfalls when dealing with carry propagation through the digits. # Description Implement the function `add_one` to accurately increase the integer represented by the list of digits by one and return the new list of digits. Focus on in-place modifications and optimal time complexity.","solution":"from typing import List def add_one(digits: List[int]) -> List[int]: Adds one to the number represented by the list of digits. n = len(digits) # Traverse the list in reverse order for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If all the digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# Question: Given a binary tree, find its maximum depth using an iterative approach. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Function Signature: ```python def max_depth(root: Optional[TreeNode]) -> int: ``` Input: * `root` (TreeNode): The root node of the binary tree. A `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: * Returns `int`: The maximum depth of the binary tree. Constraints: * The number of nodes in the tree is between `0` and `10^4`. * The depth of the tree is between `0` and `10^4`. Performance Requirement: * The solution should operate in O(N) time complexity since every node is visited once. * The algorithm should utilize O(N) space complexity. Example: ```python # Example 1: # Input: # 3 # / # 9 20 # / # 15 7 # Output: 3 # Example 2: # Input: # 1 # / # 2 # Output: 2 # Example 3: # Input: # None # Output: 0 ``` Scenario/Context: Suppose you are building an application that needs to analyze hierarchical data structures such as file systems, organizational charts, or gameplay states. Accurately determining the depth of these structures can be critical for effectively managing and optimizing their use. Implement the function `max_depth` so that it accurately computes the maximum depth of any binary tree provided.","solution":"from typing import Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: Optional[TreeNode]) -> int: if root is None: return 0 queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"# Morse Code Transformation Counting In this problem, you will write a function to handle the transformation of words to Morse code and count the number of unique Morse code transformations. Problem Statement International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: * \\"a\\" maps to \\".-\\", \\"b\\" maps to \\"-...\\", \\"c\\" maps to \\"-.-.\\", and so on. For convenience, here is the Morse code table for the 26 letters of the English alphabet: ```python morse_code = { \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\': \\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" } ``` Given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \\"cab\\" can be written as \\"-.-.-....-\\", which is the concatenation \\"-.-.\\" + \\"-...\\" + \\".-\\". We\'ll call such a concatenation the transformation of a word. Write a function `unique_morse(words: List[str]) -> int` that returns the number of different transformations among all words we have. Input: * A list of words, `words`, where each element is a string. Output: * Return an integer representing the number of unique Morse code transformations. Constraints: * All words are lowercase letters. * 1 ≤ length of words ≤ 100 * 1 ≤ length of each word ≤ 12 Example: ```python def unique_morse(words): # Your code here # Example usage: words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] print(unique_morse(words)) # Output: 2 ``` # Notes: * Use the provided Morse code dictionary for the Morse transformation. * Optimize your solution for efficiency.","solution":"def unique_morse(words): Returns the number of unique Morse code transformations among all words. morse_code = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } transformations = set() for word in words: morse_str = \'\'.join(morse_code[char] for char in word) transformations.add(morse_str) return len(transformations)"},{"question":"# Cloning an Undirected Graph As a software developer, you are tasked with implementing a function to clone an undirected graph. The graph is represented using nodes of a custom class `UndirectedGraphNode`, each having a label and a list of neighbors. Function Signature ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Description - Implement a function `clone_graph` that takes a node of an undirected graph and returns a new graph that is a clone. - Each graph node should be cloned exactly once. - The function should correctly handle graphs with self-cycles and disconnected components. # Constraints: - The graph is connected, meaning any node is accessible from any other node. - Each node\'s label is unique. - The number of nodes (N) in the graph is between 1 and 100. - Node labels are integers between 0 and 100. # Input - A graph node of type `UndirectedGraphNode`. # Output - A new node that is the entry point to the cloned undirected graph. # Example ```python # Define the graph nodes node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) # Connect the nodes node0.neighbors.extend([node1, node2]) node1.neighbors.append(node2) node2.neighbors.append(node2) # Self cycle # Clone the graph cloned_node = clone_graph(node0) # The cloned node should have the same structure as the original graph # Validate the cloned structure as needed ``` # Hints 1. You may use breadth-first search (BFS) or depth-first search (DFS) to traverse the node connections. 2. Use a dictionary to maintain a mapping from original nodes to their clones. 3. Handle nodes with no neighbors properly. 4. Carefully manage self-referencing nodes to avoid infinite loops. # Note: Your solution should focus on implementing the `clone_graph` function. You can assume that the class `UndirectedGraphNode` is defined as follows: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) ```","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None mapping = {} def clone(node): if node in mapping: return mapping[node] copy = UndirectedGraphNode(node.label) mapping[node] = copy for neighbor in node.neighbors: copy.neighbors.append(clone(neighbor)) return copy return clone(node)"},{"question":"Scenario: Imagine you\'re developing software for a specialized memory storage device where the number of write operations significantly impacts the device\'s lifespan. Your task is to implement a sorting function that sorts an array in-place with minimal write operations. Task: Implement the Cycle Sort algorithm. The function should sort an array of integers in ascending order. Focus on writing a robust solution that avoids unnecessary memory writes. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` Input: - `arr` (List[int]): A list of integers, where 1 ≤ len(arr) ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9. Output: - Returns the sorted list of integers. Constraints: - The solution should perform in-place sorting with minimal write operations. - The time complexity should be O(N^2) for the worst case. Examples: 1. **Input**: `arr = [4, 3, 2, 1]` - **Output**: `[1, 2, 3, 4]` 2. **Input**: `arr = [10, -1, 3, 7]` - **Output**: `[-1, 3, 7, 10]` 3. **Input**: `arr = [1, 2, 3, 4]` - **Output**: `[1, 2, 3, 4]` Notes: - Ensure the implementation handles edge cases such as empty arrays, arrays with one element, and arrays with duplicate elements. - Describe your approach and considerations in handling the write operations and cycles.","solution":"def cycle_sort(arr): writes = 0 # Cycle through each element and place it to its correct position for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] # Find proper position for element pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 # Skip moving when it\'s already in the correct position if pos == cycleStart: continue # When there are duplicates, skip all duplicate elements while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Problem: Implement Enhanced Queue You have learned about the Queue abstract data type and its implementation using arrays (ArrayQueue) and linked lists (LinkedListQueue). Now, it\'s time to put your knowledge to the test by implementing a Limited Queue that enforces a maximum size, a frequent requirement in memory-constrained environments. Task: Implement a `LimitedQueue` class that inherits from `AbstractQueue` and ensures a maximum size. When the queue reaches its limit, new enqueues should overwrite the oldest elements (circular buffer approach). Required Methods: 1. `__init__(self, max_size)`: Initializes the queue with a fixed capacity `max_size`. 2. `enqueue(self, value)`: Adds a new item to the queue. If the queue is full, this should overwrite the oldest element. 3. `dequeue(self)`: Removes the front item from the queue and returns it. 4. `peek(self)`: Returns the front element without removing it. 5. `__iter__(self)`: Iterator to traverse the queue from front to rear. Input and Output: - `LimitedQueue(max_size)`: Creates a queue with maximum size `max_size`. - `enqueue(value)`: Adds `value` to the queue. If the queue is full, overwrite the oldest element. - `dequeue() -> value`: Removes and returns the front value. Raises `IndexError` if the queue is empty. - `peek() -> value`: Returns the front element without removing it. Raises `IndexError` if the queue is empty. Constraints: - Do not use any libraries for queue implementations; your solution must employ basic data structures like lists. - The maximum size `max_size` will be a positive integer (1 ≤ max_size ≤ 10^4). Example: ```python queue = LimitedQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) # Overwrites the oldest element (1) print(queue.dequeue()) # Output: 2 print(queue.peek()) # Output: 3 queue.enqueue(5) print(list(queue)) # Output: [3, 4, 5] ``` Optimal Performance: Your implementation should ensure efficient enqueue and dequeue operations with amortized O(1) complexity due to the circular buffer approach.","solution":"class LimitedQueue: def __init__(self, max_size): Initializes the queue with a fixed capacity max_size. self.max_size = max_size self.queue = [None] * max_size self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, value): Adds a new item to the queue. If the queue is full, this should overwrite the oldest element. self.rear = (self.rear + 1) % self.max_size self.queue[self.rear] = value if self.count == self.max_size: self.front = (self.front + 1) % self.max_size else: self.count += 1 def dequeue(self): Removes the front item from the queue and returns it. Raises IndexError if the queue is empty. if self.count == 0: raise IndexError(\\"dequeue from empty queue\\") value = self.queue[self.front] self.front = (self.front + 1) % self.max_size self.count -= 1 return value def peek(self): Returns the front element without removing it. Raises IndexError if the queue is empty. if self.count == 0: raise IndexError(\\"peek from empty queue\\") return self.queue[self.front] def __iter__(self): Iterator to traverse the queue from front to rear. for i in range(self.count): yield self.queue[(self.front + i) % self.max_size]"},{"question":"You are given two algorithms: one that computes the Euler\'s Totient Function (ϕ(n)) and another that finds all primitive roots of a given integer ( n ). Your task is to extend this functionality by writing a function that integrates both algorithms to solve the following problem: Problem Statement Write a function, `is_primitive_root(a, n)`, that checks if a given number `a` is a primitive root of a positive integer `n`. The function should return `True` if `a` is a primitive root of `n`, and `False` otherwise. Input/Output * **Input**: Two integers `a` and `n` where: - (1 leq a < n) - ( n ) is a positive integer. * **Output**: A boolean value indicating whether `a` is a primitive root of `n`. Constraints * You must use the provided snippets for the Euler\'s Totient function and order finding logic. * Your implementation should be optimized to handle values of ( n ) up to 100,000 efficiently. Function Signature ```python def is_primitive_root(a: int, n: int) -> bool: pass ``` Example ```python # Example 1 print(is_primitive_root(2, 5)) # Output: True # Example 2 print(is_primitive_root(3, 7)) # Output: True # Example 3 print(is_primitive_root(2, 8)) # Output: False ``` Scenario/Context This problem is crucial in the context of cryptographic systems where certain systems like Diffie-Hellman key exchange depend on the generation of primitive roots. Verifying if a number is a primitive root helps ensure the secure generation of cryptographic keys.","solution":"def gcd(a, b): Helper function to calculate the greatest common divisor (GCD) of two numbers. while b: a, b = b, a % b return a def euler_totient(n): Function to compute Euler\'s Totient function, φ(n). result = n # Initialize result as n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def is_primitive_root(a, n): Function to check if a given number a is a primitive root of n. if gcd(a, n) != 1: return False # a and n must be coprime # Find Euler\'s totient function value for n phi = euler_totient(n) factors = set() d = 2 while d * d <= phi: if phi % d == 0: factors.add(d) while phi % d == 0: phi //= d d += 1 if phi > 1: factors.add(phi) # Check if any power divides the modulus n for factor in factors: if pow(a, euler_totient(n) // factor, n) == 1: return False return True"},{"question":"# Red-Black Tree Operations You are tasked with implementing a Red-Black Tree, a self-balancing binary search tree, using the provided class skeleton. You need to complete several methods for this data structure. Specifically, you need to develop a clear and efficient solution for the core operations: insertion, deletion, and an inorder traversal to validate the tree\'s structure. # Objective - Implement the insertion operation, ensuring the tree remains balanced and follows the Red-Black properties. - Implement the deletion operation, maintaining the tree’s balance. - Implement an inorder traversal method that returns nodes in a sorted list, showing their values and colors (0 for black, 1 for red). # Method Specifications 1. **insert(value: int) -> None**: - Insert a node with `value` into the tree while maintaining the Red-Black properties. 2. **delete(value: int) -> None**: - Delete the node with `value` from the tree while maintaining the Red-Black properties. 3. **inorder() -> List[dict]**: - Return a list of dictionaries representing the nodes in inorder traversal, with each dictionary containing `val` (int) for the node\'s value and `color` (int) for the node\'s color. # Constraints - Values are unique integers. - Provided template should be used without modifying method signatures and provided core logic. - Ensure your solution handles edge cases such as inserting or deleting the root node, and nodes with only one child. # Example ```python if __name__ == \\"__main__\\": rb = RBTree() nodes = [10, 20, 30, 15, 25, 5] for node in nodes: rb.insert(rb.root, node, 1) print(rb.inorder()) # [{\'val\': 5, \'color\': 0}, {\'val\': 10, \'color\': 0}, {\'val\': 15, \'color\': 1}, {\'val\': 20, \'color\': 0}, {\'val\': 25, \'color\': 1}, {\'val\': 30, \'color\': 0}] rb.delete(rb.root, 20) print(rb.inorder()) # [{\'val\': 5, \'color\': 0}, {\'val\': 10, \'color\': 0}, {\'val\': 15, \'color\': 1}, {\'val\': 25, \'color\': 0}, {\'val\': 30, \'color\': 0}] ``` Implement the required methods ensuring correctness and efficiency.","solution":"class Node: def __init__(self, data, color=1): self.data = data self.color = color # 1 for Red, 0 for Black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = 0 self.root = self.TNULL def insert(self, key): new_node = Node(key) new_node.left = self.TNULL new_node.right = self.TNULL new_node.color = 1 # New node must be red if self.root == self.TNULL: self.root = new_node new_node.color = 0 new_node.parent = None else: current = self.root while current != self.TNULL: parent = current if new_node.data < current.data: current = current.left else: current = current.right new_node.parent = parent if new_node.data < parent.data: parent.left = new_node else: parent.right = new_node self.fix_insert(new_node) def fix_insert(self, k): while k != self.root and k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left # Uncle node if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right # Uncle node if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) self.root.color = 0 def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def inorder(self): res = [] self.__inorder_helper(self.root, res) return res def __inorder_helper(self, node, res): if node != self.TNULL: self.__inorder_helper(node.left, res) res.append({\'val\': node.data, \'color\': node.color}) self.__inorder_helper(node.right, res) # Helper functions for deletion def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.data == key: z = node if node.data <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.rb_transplant(z, z.right) elif (z.right == self.TNULL): x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.fix_delete(x) def minimum(self, node): while node.left != self.TNULL: node = node.left return node def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.left.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def delete(self, data): self.delete_node_helper(self.root, data)"},{"question":"# Anagram Checker for Extended Character Set **Context**: In text processing applications, it\'s often necessary to determine if two strings are anagrams of each other, including cases involving a larger character set. **Task**: Write a function `is_anagram` that determines if one string is an anagram of another. Unlike the previous constraints of lower-case alphabets, the strings may contain any visible ASCII characters. # Function Specification ```python def is_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. Args: s (str): First string to be compared. t (str): Second string to be compared. Returns: bool: True if t is an anagram of s, False otherwise. ``` # Input - `s` (string): The first input string. - `t` (string): The second input string. # Output - A boolean value: `True` if `t` is an anagram of `s`, otherwise `False`. # Constraints - String lengths are between 0 and 10^5. - Strings can contain any visible ASCII characters. # Requirements - Time Complexity: O(n), where n is the length of the strings. - Space Complexity: Must consider efficient usage due to larger potential character set beyond lowercase letters. # Examples ```python is_anagram(\\"anagram\\", \\"nagaram\\") -> True is_anagram(\\"rat\\", \\"car\\") -> False is_anagram(\\"a! b@c#\\", \\"#@c! ba\\") -> True is_anagram(\\"Hello!@\\", \\"Ole!h@ \\") -> False ``` **Notes**: 1. Ensure your solution handles the entire visible ASCII character set efficiently. 2. Consider the constraints and optimize space usage appropriately.","solution":"def is_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. Args: s (str): First string to be compared. t (str): Second string to be compared. Returns: bool: True if t is an anagram of s, False otherwise. from collections import Counter # Anagrams must be of the same length if len(s) != len(t): return False # Use Counter to tally up characters in each string return Counter(s) == Counter(t)"},{"question":"You are tasked with implementing two versions of an algorithm to perform fast exponentiation of a number. Given a base `a`, an exponent `n`, and an optional modulus `mod`, your task is to compute ( a^n ) using a technique called \'Binary Exponentiation\'. Your implementation should efficiently compute the result using both an iterative and a recursive approach. Requirements 1. **Iterative Method**: Implement the function `power(a: int, n: int, mod: int = None) -> int` to compute the power iteratively. 2. **Recursive Method**: Implement the function `power_recur(a: int, n: int, mod: int = None) -> int` to compute the power recursively. 3. If the `mod` parameter is provided, return the result modulo `mod`. If not provided, return the result as is. Input - An integer `a` (1 ≤ ( |a| ) ≤ 10^5): the base. - An integer `n` (0 ≤ n ≤ 10^9): the exponent. - An optional integer `mod` (1 ≤ mod ≤ 10^9): the modulus. Output - An integer representing ( a^n ) computed with or without the modulus as specified. Constraints - Ensure your solution has time complexity O(log(n)). - Ensure your recursive solution handles the call stack efficiently for large values of `n`. Examples *Example 1*: ```python power(2, 10) ``` - **Output**: 1024 *Example 2*: ```python power(2, 10, 1000) ``` - **Output**: 24 *Example 3*: ```python power_recur(2, 10) ``` - **Output**: 1024 *Example 4*: ```python power_recur(2, 10, 1000) ``` - **Output**: 24 Notes - Carefully consider edge cases such as n = 0 and large values of n. - Ensure the correctness of your modulus handling by running extensive test cases.","solution":"def power(a: int, n: int, mod: int = None) -> int: Compute a^n using an iterative method with optional modulus. result = 1 base = a while n > 0: if n % 2 == 1: result = result * base if mod: result = result % mod base = base * base if mod: base = base % mod n = n // 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Compute a^n using a recursive method with optional modulus. if n == 0: return 1 half = power_recur(a, n // 2, mod) if mod: half = half % mod half = (half * half) if mod: half %= mod if n % 2 != 0: half = half * a if mod: half = half % mod return half"},{"question":"# Matrix Chain Multiplication Optimization You are given a sequence of matrices, and you need to determine the most efficient way to multiply these matrices together. The goal is to minimize the number of scalar multiplications needed to compute the product of the matrices. Write a function `matrix_chain_order` to find the minimum number of multiplications needed to multiply the given sequence of matrices. You also need to write a helper function `print_optimal_solution` to display the optimal parenthesization of the matrix product. # Function Signature ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: \'\'\' Finds optimal order to multiply matrices. Input: * array: List[int] - an array where the ith matrix has dimension array[i-1] x array[i]. Output: * returns a tuple of two 2D lists (matrix, sol), where matrix holds the minimum number of multiplications needed and sol stores the optimal split points. \'\'\' def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: \'\'\' Prints the optimal parenthesization. Input: * optimal_solution: List[List[int]] - the table storing optimal split points. * i: int - the starting matrix index. * j: int - the ending matrix index. \'\'\' # Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) # Example Output: # No. of Operations required: 15125 # Optimal Parenthesization: ((A1 (A2 A3)) ((A4 A5) A6)) print(\\"No. of Operations required:\\", matrix[1][len(array)-1]) print_optimal_solution(optimal_solution, 1, len(array)-1) ``` # Constraints * 2 <= len(array) <= 100 * 1 <= array[i] <= 1000 # Performance Requirements * Ensure that your solution runs efficiently with a time complexity of O(n^3) and uses O(n^2) space.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 # Number of matrices # m[i][j] is the minimum number of multiplications needed to compute the product of matrices A[i]...A[j] m = [[0 for _ in range(n+1)] for _ in range(n+1)] # s[i][j] is the index of the matrix after which the optimal split occurs s = [[0 for _ in range(n+1)] for _ in range(n+1)] for length in range(2, n+1): # length is the chain length for i in range(1, n-length+2): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + array[i-1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# Heap Sort Immersion You are tasked with implementing a variation of the Heap Sort algorithm. Unlike traditional heap sort, which always sorts in ascending order using either a max heap or a min heap, your implementation should handle both ascending and descending orders based on the specified sorting order. **Function Signature**: ```python def adaptable_heap_sort(arr, ascending=True): ``` **Input**: - `arr`: A list of integers that need to be sorted. - `ascending`: A boolean flag indicating whether to sort in ascending (`True`) or descending (`False`) order. **Output**: - Returns a new sorted list based on the specified order. **Constraints**: - Do not use any built-in sorting functions. - The solution must run in O(n log n) time complexity and O(1) space complexity (in-place sorting). - Handle edge cases such as empty lists and lists with duplicate elements. **Examples**: 1. `adaptable_heap_sort([4, 10, 3, 5, 1], ascending=True)` should return `[1, 3, 4, 5, 10]` 2. `adaptable_heap_sort([4, 10, 3, 5, 1], ascending=False)` should return `[10, 5, 4, 3, 1]` **Guidelines**: - Implement the necessary helper functions to maintain either a max-heap or a min-heap based on the `ascending` flag. - Ensure that the function handles all edge cases appropriately and maintains the desired time and space complexity.","solution":"def adaptable_heap_sort(arr, ascending=True): def heapify(arr, n, i, compare): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and compare(arr[left], arr[largest]): largest = left if right < n and compare(arr[right], arr[largest]): largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, compare) def build_heap(arr, n, compare): for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, compare) def heap_sort(arr, n, compare): build_heap(arr, n, compare) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, compare) n = len(arr) if ascending: compare = lambda x, y: x > y else: compare = lambda x, y: x < y heap_sort(arr, n, compare) return arr"},{"question":"You are required to implement a min heap data structure. The heap should support the following operations: 1. **Insert**: Insert an element into the heap. 2. **Remove_Min**: Remove and return the minimum element from the heap. 3. **Min**: Return the minimum element without removing it. 4. **Size**: Return the size of the heap. # Function Signatures ```python class MinHeap: def insert(self, val: int) -> None: pass def remove_min(self) -> int: pass def min(self) -> int: pass def size(self) -> int: pass ``` # Constraints * All elements inserted into the heap will be positive integers. * Operations will be performed in order: multiple insertions, followed by multiple min or remove_min operations. # Example ```python heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(8) heap.insert(1) print(heap.min()) # Output: 1 print(heap.remove_min()) # Output: 1 print(heap.remove_min()) # Output: 3 print(heap.size()) # Output: 2 ``` # Notes 1. You must not use any built-in heap library. 2. You should maintain the heap property after each operation. 3. Aim to achieve an optimal time complexity for each method.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"remove_min from an empty heap\\") if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_val def min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"min from an empty heap\\") return self.heap[0] def size(self) -> int: return len(self.heap) def _heapify_up(self, index): parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"You’re tasked to develop an upgraded and detailed version of the 1-Sparse Recovery Algorithm. Implement a function named `one_sparse_recovery` which takes an input list of tuples. Each tuple will consist of an integer and a sign (`+` or `-`). Your function should return the unique number if the stream is 1-sparse (meaning every number except the unique number has been canceled out perfectly). If the stream is not 1-sparse, return `None`. # Input: - A list of tuples where each tuple `(x, sign)` contains: * An integer `x` (0 <= x <= 10^9) * A string `sign`: either `\'+\'` or `\'-\'` # Output: - An integer representing the unique number if the stream is 1-sparse; otherwise, `None`. # Constraints: - The input list length will not exceed (10^5). - Each number in the tuple is non-negative. # Examples: 1. **Example 1:** ``` Input: [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] Output: 4 ``` 2. **Example 2:** ``` Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] Output: 2 ``` 3. **Example 3:** ``` Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] Output: None ``` # Function Signature: ```python def one_sparse_recovery(array: list[tuple[int, str]]) -> int: pass ``` # Constraints: - You must handle edge cases like streams containing only positive or negative instances. - Performance constraints must be met considering input size might go as high as (10^5). Using this problem, demonstrate your understanding of algorithmic techniques to solve real-time streaming data using bit-manipulation and linear pass techniques. You should ensure correctness and efficiency in your provided solution.","solution":"def one_sparse_recovery(array): This function takes an input list of tuples. Each tuple consists of an integer and a sign (\'+\' or \'-\') and returns the unique number if the stream is 1-sparse; otherwise, it returns None. counter = {} for number, sign in array: if sign == \'+\': counter[number] = counter.get(number, 0) + 1 elif sign == \'-\': counter[number] = counter.get(number, 0) - 1 unique_number = None for num, count in counter.items(): if count != 0: if unique_number is None: unique_number = num else: return None return unique_number"},{"question":"# Rabin-Karp Algorithm String Search You are given a Python implementation of the Rabin-Karp Algorithm. Your task is to extend the functionality of this implementation to handle multiple pattern search within a given text. # Task Write a function `rabin_karp_multi(patterns, text)` that takes in a list of patterns and a text string, and returns a dictionary where each key is the pattern and the value is a list of starting indices where the pattern occurs in the text. # Input - `patterns`: A list of strings where `1 <= len(pattern) <= 100 for each pattern and total number of patterns is <= 10^3`. - `text`: A string with `1 <= len(text) <= 10^5`. # Output - A dictionary `{pattern: [indices]}` where: - `pattern` is a string from the list `patterns`. - `[indices]` is a list of starting indices (0-based) where the `pattern` occurs in the `text`. # Constraints - The text, and each pattern will only contain lowercase English letters. # Performance Requirements - The function should efficiently handle the multiple pattern search in the text and strive to keep time complexity close to O(N * K) where N is length of text and K is average length of patterns. # Example ```python def rabin_karp_multi(patterns, text): # Your implementation here pass # Example usage patterns = [\\"abc\\", \\"bcd\\", \\"bca\\"] text = \\"abcdbcabc\\" print(rabin_karp_multi(patterns, text)) # Output: {\'abc\': [0, 6], \'bcd\': [1], \'bca\': [5]} ``` **Note:** 1. Ensure to handle cases where patterns are of different lengths. 2. Optimize the hash function to minimize collisions. 3. Discuss any assumptions you make during the implementation in comment sections.","solution":"def rabin_karp_multi(patterns, text): Implements the Rabin-Karp algorithm to search for multiple patterns in a given text. Args: patterns (list): A list of patterns to search for in the text. text (string): The text in which to search for the patterns. Returns: dict: A dictionary where keys are patterns and values are lists of starting indices where each pattern occurs in the text. def rabin_karp_single(pattern, text): Helper function to find all starting indices of a single pattern in the text using Rabin-Karp algorithm. n, m = len(text), len(pattern) if m > n: return [] # Prime number for modulo operations prime = 101 base = 256 # Calculate the hash value of the pattern and first window of text pattern_hash = 0 text_hash = 0 h = 1 # The value of (base^(m-1)) % prime for i in range(m-1): h = (h * base) % prime for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Find matches using the rolling hash technique indices = [] for i in range(n - m + 1): if pattern_hash == text_hash: # Check characters one by one if hashes match if text[i:i+m] == pattern: indices.append(i) # Calculate hash for the next window of text if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # Convert to positive hash if text_hash < 0: text_hash += prime return indices # Dictionary to hold the result result = {} # Use the helper function to search for each pattern for pattern in patterns: result[pattern] = rabin_karp_single(pattern, text) return result"},{"question":"You are given an array of integers and a binary associative function (like addition, max, min etc). Your task is to implement a class called `SegmentTree` which supports two main functionalities efficiently: 1. **Construction of the segment tree** from the given array and function. 2. **Range Query** operation that returns the result of applying the function to elements across a specified range. # Class Definition: Implement a class `SegmentTree` with the following methods: - **`__init__(self, arr, function)`:** Constructor that builds the segment tree from the list `arr` using the binary associative function `function`. - **`query(self, L, R)`:** Method to query the function result on the subarray ranging from index `L` to `R` inclusive. # Input: * The initial array (`arr`) and a binary function (`function`) during the instantiation of the `SegmentTree` class. * For `query` method: * Two integers `L` and `R` representing the start and end indices of the range (0-based). # Output: * For `query` method: * The result of the function applied to the range `[L, R]`. # Constraints: * The length of array `arr` will be at most `10^5`. * The values in the array `arr` will be integers. * The function will be a binary associative function like addition, maximum, minimum, etc. * 0 ≤ L ≤ R < len(arr). # Example: ```python # Example 1 # Given array: [2, 4, 5, 3, 4] # Function: max segment_tree = SegmentTree([2, 4, 5, 3, 4], max) print(segment_tree.query(2, 4)) # Output: 5 print(segment_tree.query(0, 3)) # Output: 5 # Example 2 # Given array: [4, 5, 2, 3, 4, 43, 3] # Function: sum segment_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) print(segment_tree.query(1, 5)) # Output: 57 ``` Note: You are NOT allowed to reference example code directly in your solution.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [None] * (2 * self.n) self.function = function # Build the tree # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): L += self.n R += self.n + 1 res = None while L < R: if L % 2 == 1: if res is None: res = self.tree[L] else: res = self.function(res, self.tree[L]) L += 1 if R % 2 == 1: R -= 1 if res is None: res = self.tree[R] else: res = self.function(res, self.tree[R]) L //= 2 R //= 2 return res"},{"question":"# Prime Number Checker Function Implementation Context In the world of cryptography and number theory, efficient prime number checking plays a crucial role, especially dealing with encryption algorithms and prime generation. One classic problem is to check if a given number is prime, optimizing the process for performance. Problem Statement Design and implement a function in Python that accurately determines whether a given integer `n` is a prime number. Function Signature ```python def prime_check(n: int) -> bool: Determine if a number n is prime. Arguments: n -- integer to be checked (n >= 0) Returns: True if n is a prime number, False otherwise. ``` Input * An integer `n` where (0 leq n leq 10^9). Output * Returns a boolean `True` if `n` is a prime number, `False` otherwise. Constraints * You cannot use built-in prime checking functions. * The solution should be optimized for time complexity since `n` can be very large. Examples ```python assert prime_check(1) == False assert prime_check(2) == True assert prime_check(4) == False assert prime_check(13) == True assert prime_check(1000000007) == True # Large prime number ``` Notes * Handle edge cases like 0 and 1 within the function. * Ensure the function runs efficiently for the upper limit of `n`.","solution":"def prime_check(n: int) -> bool: Determine if a number n is prime. Arguments: n -- integer to be checked (n >= 0) Returns: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"**Scenario**: You are working on an application that needs to process customer transaction data. To avoid spamming, you need to limit the number of times a single customer’s transaction can appear in a reported list. Your task is to implement a function that manages this. **Task**: Write a Python function `limit_transactions(transactions: List[int], max_count: int) -> List[int]` that takes in two parameters: 1. `transactions`: A list of integers where each integer represents a customer transaction ID. 2. `max_count`: An integer representing the maximum allowable number of appearances for any transaction ID in the resultant list. The function should return a new list containing the transaction IDs but each ID should appear no more than `max_count` times, while preserving the order of first appearance. **Input Format**: - `transactions` is a list of integers (0 ≤ len(transactions) ≤ 10^5, 0 ≤ transactions[i] ≤ 10^5). - `max_count` is a positive integer (1 ≤ max_count ≤ 10^5). **Output Format**: - A list of integers. **Examples**: ```python assert limit_transactions([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_transactions([4, 4, 4, 4], 1) == [4] assert limit_transactions([], 3) == [] assert limit_transactions([5, 3, 4, 5, 5, 5, 3, 3, 2], 2) == [5, 3, 4, 5, 3, 2] ``` **Constraints**: - The resultant list should maintain the order in which transaction IDs appear. - Each transaction ID should not appear more than `max_count` times.","solution":"def limit_transactions(transactions, max_count): Limits the number of times a transaction ID can appear in the list. Parameters: transactions (list of int): List of transaction IDs. max_count (int): Maximum allowable number of appearances for any transaction ID. Returns: list of int: New list with transaction IDs, each appearing no more than max_count times. from collections import defaultdict transaction_count = defaultdict(int) limited_transactions = [] for transaction in transactions: if transaction_count[transaction] < max_count: limited_transactions.append(transaction) transaction_count[transaction] += 1 return limited_transactions"},{"question":"# Problem: Implement an Efficient Range Lookup using a Red-Black Tree Given the implementation details of the Red-Black Tree, your task is to extend its functionality to implement an efficient range lookup operation. Specifically, you need to write a function `range_lookup(start, end)` that returns all the values within the given range [start, end]. # Function Signature ```python def range_lookup(self, start: int, end: int) -> list: Return all values in the Red-Black Tree that fall into the range [start, end]. :param start: Starting value of the range (inclusive). :param end: Ending value of the range (inclusive). :return: A list of all values in the specified range. ``` # Input: * `start` and `end` are integers with start <= end. # Output: * Return a list of integers representing the nodes within the given range, sorted in ascending order. # Constraints: * The tree is non-empty. * The values in the tree are integers. * The range may potentially include values that are not present in the tree. # Example Usage ```python rb = RBTree() values = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in values: node = RBNode(value, 1) # Insert nodes with default color red rb.insert(node) # We want to find all values between 5 and 14 (inclusive) result = rb.range_lookup(5, 14) print(result) # Expected output: [5, 7, 8, 11, 14] ``` # Challenge: * Ensure the function operates efficiently within log-time complexity for tree traversals. * Handle edge cases such as nodes with no children or subtrees. * Validate your solution with multiple test cases to ensure robustness.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) # Our NULL node is black by default self.root = self.TNULL def insert_fix(self, k): # Fixing methods for balancing Red-Black Tree would be here post insertion. pass def insert(self, key): node = RBNode(key, 1) node.left = self.TNULL node.right = self.TNULL node.parent = None parent = None current = self.root while current != self.TNULL: parent = current if node.key < current.key: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.key < parent.key: parent.left = node else: parent.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.insert_fix(node) def inorder_helper(self, node, start, end, result): if node != self.TNULL: if node.key > start: self.inorder_helper(node.left, start, end, result) if start <= node.key <= end: result.append(node.key) if node.key < end: self.inorder_helper(node.right, start, end, result) def range_lookup(self, start: int, end: int) -> list: result = [] self.inorder_helper(self.root, start, end, result) return result"},{"question":"# AVL Tree Implementation and Testing You are provided with a partially implemented AVL Tree class. Your task is to complete the function `delete(self, key)` which will delete a node with the given key from the AVL tree while maintaining its properties. Function Signature ```python def delete(self, key): Delete the node with the specified key from the AVL tree. Parameters: key (int): The key to be deleted from the tree. Returns: None: The function should modify the tree in place. ``` # Constraints 1. You must not use any extra memory except the space required for the tree nodes and their attributes. 2. The function should handle all edge cases such as deleting a node that does not exist and deleting from an empty tree. 3. You should ensure that after deletion, the AVL tree remains balanced. # Input and Output Format The function `delete` does not have any return value and modifies the tree in place. # Performance Requirements 1. The average time complexity of `delete` should be O(log n). 2. The space complexity should not exceed O(n). # Scenario Consider you are designing a self-managing software for an in-memory database. One of the crucial data structures you are using is an AVL tree to keep entries sorted and allow for quick updates and lookups. You need to ensure that the tree maintains its balanced state even after deletions, as unbalanced trees could severely degrade the performance of your database operations. # Example ```python # Sample usage of the AVL tree with delete functionality avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(4) print(avl.in_order_traverse()) # Output: [4, 5, 10, 20] avl.delete(5) print(avl.in_order_traverse()) # Output: [4, 10, 20] avl.delete(10) print(avl.in_order_traverse()) # Output: [4, 20] ``` Ensure your implementation passes this and other corner cases like deleting a non-existent node or deleting the root node followed by tree re-balancing.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return TreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_min_value_node(self, root): if root is None or root.left is None: return root return self.get_min_value_node(root.left) def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def in_order_traverse(self, root, result=None): if result is None: result = [] if root is not None: self.in_order_traverse(root.left, result) result.append(root.key) self.in_order_traverse(root.right, result) return result"},{"question":"You are given two binary trees and tasked with writing a function to determine if they are structurally identical and all corresponding nodes have the same value. # Requirements 1. Write a function `is_equal_tree(tree1, tree2)` that takes two binary tree roots `tree1` and `tree2`. 2. The function should return `True` if the trees are structurally identical and the node values are the same for all corresponding nodes. 3. If the trees are not identical in structure or node values, the function should return `False`. # Input and Output Format * **Input**: * `tree1` and `tree2`: Roots of the binary trees. Each tree node has the structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: * A boolean value, `True` if the trees are identical, otherwise `False`. # Constraints * Tree nodes will have integer values. * The number of nodes in each tree will be at most `1000`. * Trees can be empty (i.e., root can be `None`). # Example *Example 1:* ```python tree1: 1 / 2 3 tree2: 1 / 2 3 Output: True ``` *Example 2:* ```python tree1: 1 / 2 1 tree2: 1 / 1 2 Output: False ``` # Scenario Imagine you are developing a synchronization service for distributed databases where each server holds a tree-like configuration of the data. To ensure consistency, you need to verify if two tree-like configurations are identical across different servers. Implement the `is_equal_tree` function to facilitate this verification process.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_equal_tree(tree1, tree2): Determine if two binary trees are structurally identical and all corresponding nodes have the same value. Args: tree1 (TreeNode): Root of the first binary tree. tree2 (TreeNode): Root of the second binary tree. Returns: bool: True if the trees are identical, otherwise False. # If both trees are empty, they are identical if not tree1 and not tree2: return True # If one of the trees is empty and the other is not, they are not identical if not tree1 or not tree2: return False # If the values of the current nodes are different, they are not identical if tree1.val != tree2.val: return False # Recursively check left and right subtrees return is_equal_tree(tree1.left, tree2.left) and is_equal_tree(tree1.right, tree2.right)"},{"question":"# Stooge Sort Implementation You are provided with an ancient sorting algorithm called Stooge Sort. The task is to implement a similar but slightly modified version of it with given constraints. Objectives: 1. Implement a function `modified_stoogesort(arr)` which sorts an array of integers in ascending order. 2. Ensure the algorithm follows these modified principles: - Instead of recursively sorting only the first 2/3 and the last 2/3 of the array, sort them in segments of the first 1/2 and the last 1/2. - Maintain the \\"swap if first is greater than last\\" logic. Function Signature: ```python def modified_stoogesort(arr: list) -> None: # your code here ``` Input: - `arr`: A list of integers (0 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6) Output: - The function modifies the input list `arr` to be sorted. Example: ```python arr = [10, 9, -1, 20, 5] modified_stoogesort(arr) print(arr) # Output should be sorted array: [-1, 5, 9, 10, 20] ``` Constraints: - The algorithm should work within O(n^2.709) constraints similar to the original Stooge Sort. - Avoid using built-in sort functions. - You should handle small arrays (0, 1, 2 elements) appropriately within your modified version. Performance: - Your implementation should handle the performance aspects within the provided constraints as efficiently as possible.","solution":"def modified_stoogesort(arr): def stoogesort(start, end): if start >= end: return if arr[start] > arr[end]: arr[start], arr[end] = arr[end], arr[start] if (end - start + 1) > 2: third = (end - start + 1) // 2 stoogesort(start, end - third) stoogesort(start + third, end) stoogesort(start, end - third) stoogesort(0, len(arr) - 1)"},{"question":"**Title**: Stack Element Duplication **Background**: You are given a stack of integers. Your task is to write a function `stutter` that duplicates every value in the stack, so every value appears twice in sequence, without altering the original order of elements. **Function Signature**: ```python def stutter(stack: List[int]) -> List[int]: pass ``` **Input**: - `stack`: A list of integers. The top of the stack is the last element of the list (i.e., `stack[-1]`). **Output**: - The modified stack, where every integer from the original stack appears twice in sequence while preserving the order from the bottom to the top. **Constraints**: - You must implement the solution using a single auxiliary stack (a list) or a queue (from `collections.deque`). - Consider edge cases and ensure robust handling. **Performance Requirements**: - The solution should run in O(n) time complexity. - Space complexity should be O(n) due to the usage of auxiliary storage. **Example**: ```python assert stutter([3, 7, 1, 14, 9]) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert stutter([]) == [] assert stutter([5]) == [5, 5] ``` **Detailed Requirements**: - You should provide a single function called `stutter` that performs the given task. - Both auxiliary stack and queue-based solutions are acceptable. - Do not use any other built-in functions or classes other than a list or `collections.deque`. **Testing**: Ensure you test your solution against various test cases including: 1. An empty stack. 2. A stack with one element. 3. A stack with a large number of elements. 4. The largest and smallest possible integer values. **Notes**: - If multiple approaches are attempted, comment out the non-final solution for clarity.","solution":"from typing import List from collections import deque def stutter(stack: List[int]) -> List[int]: Duplicates every value in the stack such that every value appears twice in sequence without altering the original order of elements. Args: stack (List[int]): The original stack of integers. Returns: List[int]: The modified stack with duplicated values. # Using a deque as an auxiliary queue aux_queue = deque() # Process each element in the stack while stack: value = stack.pop() aux_queue.appendleft(value) aux_queue.appendleft(value) # Now, build the final stack by adding back values from the auxiliary queue while aux_queue: stack.append(aux_queue.popleft()) return stack"},{"question":"Implement a modified version of the Insertion Sort algorithm that counts the number of comparisons made while sorting. # Function Signature ```python def modified_insertion_sort(arr: list) -> tuple: ``` # Input - `arr` (list of integers): The list of integers that needs to be sorted. # Output - A tuple where: - The first element is a sorted list of integers. - The second element is an integer representing the number of comparisons made during the sorting process. # Constraints - The elements of the array can be any integer (both positive and negative). - The length of the array is between 0 and 1000. # Example 1. Input: `arr = [9, 3, 1, 5]` Output: `([1, 3, 5, 9], 5)` 2. Input: `arr = [1, 2, 3, 4, 5]` Output: `([1, 2, 3, 4, 5], 4)` # Notes - The function should count comparisons at each step where it checks if one element is greater than or less than another element. # Explanation For the first example, 1. Comparisons made: `3 > 9`, `1 < 9`, `1 < 3`, `5 < 9`, `5 > 3` — total of 5 comparisons. 2. The array is sorted into `[1, 3, 5, 9]`.","solution":"def modified_insertion_sort(arr: list) -> tuple: Perform insertion sort on the provided list and count the number of comparisons made. Parameters: arr (list of int): The list of integers to sort. Returns: tuple: A tuple containing the sorted list and the number of comparisons made. comparisons = 0 n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: comparisons += 1 # Comparison is made here arr[j + 1] = arr[j] j -= 1 # A comparison is made to exit the while loop if `j` becomes -1 or `arr[j] <= key` if j >= 0: comparisons += 1 arr[j + 1] = key return arr, comparisons"},{"question":"# Scenario You are working on a system that needs to quickly detect discrepancies in document versions. Suppose you have two versions of an ASCII-encoded document. The second version is generated by shuffling the first version\'s characters and appending exactly one new character. Your task is to identify this newly added character. # Task Write a function `find_difference(s: str, t: str) -> str` that takes two strings, `s` and `t`, where `t` is generated by random shuffling of `s` with an additional character added at a random position. The function should return this added character. # Input and Output Formats - **Input**: - `s`: A string of length `n` consisting of only lowercase letters, where ( 0 leq n leq 10^5 ). - `t`: A string of length `n + 1` consisting of only lowercase letters. - **Output**: - A single character that was added to create `t` from `s`. # Constraints - The strings `s` and `t` will always be valid per the input specifications. - The input strings will be provided in any order. # Example ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" # Expected Output: \'e\' # Example 2 s = \\"xyz\\" t = \\"xyaz\\" # Expected Output: \'a\' ``` # Performance Requirements - Your solution should run in linear time O(n). - The space complexity of your solution should be O(1). Implement the function `find_difference` based on the above requirements.","solution":"def find_difference(s: str, t: str) -> str: Finds the single character that was added to create string t from string s. # Initialize a variable to store the result using XOR result = 0 # XOR all characters from both strings s and t for char in s: result ^= ord(char) for char in t: result ^= ord(char) # The result now contains the ASCII value of the added character return chr(result)"},{"question":"# String Multiplication Algorithm **Objective**: Implement a function `multiply_strings(num1: str, num2: str) -> str` that multiplies two non-negative integers represented as strings without converting them to integers directly or using any built-in BigInteger library. Guidelines * You are given two non-negative integers `num1` and `num2` as input strings. * Length of both `num1` and `num2` is less than 110. * Both `num1` and `num2` will contain only digits (0-9) and will not contain any leading zeros. Expected Input and Output Formats * **Input**: - `num1`: a string representing the first non-negative integer. - `num2`: a string representing the second non-negative integer. * **Output**: - A string representing the product of the two input integers. Constraints * You must not use any built-in BigInteger library. * You must not convert the input strings directly to integers. * The solution should handle cases where any of the numbers has one or more zeros appropriately. Performance Requirements * The solution must be efficient with regards to both time and space complexity, adhering to the constraints provided. # Example ``` Input: num1 = \\"123\\" num2 = \\"456\\" Output: \\"56088\\" ``` **Explanation**: 123 * 456 = 56088, and the output matches this product. # Implementation Requirements - Function name: `multiply_strings` - Input: Two strings, `num1` and `num2`. - Output: One string representing their product. # Your Task Write a Python function as described above. ```python def multiply_strings(num1: str, num2: str) -> str: # Your code goes here pass ```","solution":"def multiply_strings(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize the result array to store the product digits result = [0] * (len(num1) + len(num2)) # Reverse the strings to multiply from least significant digit to most num1, num2 = num1[::-1], num2[::-1] # Multiply each digit and add to the result array for i in range(len(num1)): for j in range(len(num2)): mult = int(num1[i]) * int(num2[j]) result[i + j] += mult # Carry over to the next place value if result[i + j] >= 10: result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Reverse result and convert to string, remove any leading zeros result = result[::-1] result_str = \'\'.join(map(str, result)).lstrip(\'0\') return result_str"},{"question":"# Shell Sort Enhancement and Application Shell Sort is an efficient sorting algorithm for medium-sized arrays and improves over Insertion Sort by initially considering elements that are far apart. This problem requires you to enhance the Shell Sort algorithm to work with a dynamically chosen gap sequence and to apply the same. Task Description Implement the `enhanced_shell_sort` function that sorts an array using Shell Sort algorithm but with an optimized and parameterized gap sequence instead of the standard one. __Function Signature:__ ```python def enhanced_shell_sort(arr: List[int], gap_sequence: List[int]) -> List[int]: pass ``` __Input:__ - `arr`: A list of integers (0 leq text{len(arr)} leq 10^4) where ( -10^9 leq text{arr[i]} leq 10^9 ). - `gap_sequence`: A list of integers representing the gaps in decreasing order to be used for sorting. __Output:__ - A list of integers sorted in non-decreasing order. __Constraints:__ - You may assume that the gap sequence list provided will always start with a value less than or equal to the length of the array and end with a 1. Requirements - Optimize the function to ensure it handles up to the input constraints efficiently. - The function should handle arrays including negative numbers, large integers, and edge cases gracefully. Example: ```python print(enhanced_shell_sort([5, 3, -1, 8, 0, -2], [5, 3, 1])) # Output: [-2, -1, 0, 3, 5, 8] print(enhanced_shell_sort([], [1])) # Output: [] print(enhanced_shell_sort([1, 2, 3, 4, 5], [3, 2, 1])) # Output: [1, 2, 3, 4, 5] ```","solution":"from typing import List def enhanced_shell_sort(arr: List[int], gap_sequence: List[int]) -> List[int]: Sorts an array using the Shell Sort algorithm with a given gap sequence. n = len(arr) for gap in gap_sequence: # Perform gapped insertion sort for this gap size. for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Scenario You are tasked with creating a function for a text editor application that reverses the order of words in a given string. Each input sentence should have its words reversed while maintaining the order of characters within each word. Task Write a function `reverse_sentence_words` that takes a string `sentence` as input and returns the sentence with the order of words reversed. # Function Signature ```python def reverse_sentence_words(sentence: str) -> str: ``` # Input - A single string `sentence` (1 ≤ len(sentence) ≤ 1000) that may contain multiple words separated by single spaces. # Output - Returns a string with words in reversed order. # Constraints - Words are separated by single spaces. There will be no leading or trailing spaces. # Examples ```python assert reverse_sentence_words(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_sentence_words(\\"Hello World\\") == \\"World Hello\\" assert reverse_sentence_words(\\"single\\") == \\"single\\" assert reverse_sentence_words(\\"\\") == \\"\\" ``` # Guidelines - Do not use any library function that can reverse the string or array directly. - Ensure the solution handles edge cases such as: * Single-word strings. * Empty strings. * Strings with punctuation and special characters. This task tests your understanding of string manipulation, array operations, and edge case handling. Your implementation will be evaluated based on correctness, efficiency, and adherence to the constraints.","solution":"def reverse_sentence_words(sentence: str) -> str: Reverses the order of words in a given sentence. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"Sparse Vector Representation and Operations Scenario You are given a large dataset represented by high-dimensional vectors. Most elements in these vectors are zeros, making direct computation costly in terms of space and time. To optimize performance, you would use sparse representations. Task Write a Python function that efficiently computes the cosine similarity between two sparse vectors. The cosine similarity is defined as the dot product of the vectors divided by the product of their magnitudes. To achieve this, implement the following steps: 1. Convert full vectors to their sparse representation using an index-value list. 2. Compute the dot product between two sparse vectors. 3. Compute the magnitude of a sparse vector. 4. Compute the cosine similarity using the dot product and magnitudes of the vectors. Function Signatures Implement the following four functions: 1. `vector_to_index_value_list(vector: list) -> list` 2. `dot_product(iv_list1: list, iv_list2: list) -> float` 3. `magnitude(iv_list: list) -> float` 4. `cosine_similarity(vector1: list, vector2: list) -> float` Input and Output - **Input**: - Each `vector` is a list of floats representing a high-dimensional vector. - `vector1` and `vector2` are two such lists. - **Output**: - `vector_to_index_value_list` returns a list of tuples representing the index and value of non-zero elements. - `dot_product` returns a float, the dot product of the two sparse vectors. - `magnitude` returns a float, the magnitude of the sparse vector. - `cosine_similarity` returns a float between 0 and 1 representing the cosine similarity between two vectors. Constraints - Vector lengths can be very large (up to 10^6 elements). - Non-zero elements are significantly fewer (< 1% of the total length). Example ```python vector1 = [1.0, 0.0, 0.0, 2.0, 0.0] vector2 = [0.0, 2.0, 0.0, 2.0, 1.0] iv_list1 = vector_to_index_value_list(vector1) iv_list2 = vector_to_index_value_list(vector2) print(iv_list1) # [(0, 1.0), (3, 2.0)] print(iv_list2) # [(1, 2.0), (3, 2.0), (4, 1.0)] dot = dot_product(iv_list1, iv_list2) print(dot) # 4.0 mag1 = magnitude(iv_list1) mag2 = magnitude(iv_list2) print(mag1) # 2.23606797749979 print(mag2) # 3.0 similarity = cosine_similarity(vector1, vector2) print(similarity) # 0.5962847939999439 ``` Note Ensure to handle edge cases such as entirely zero vectors and vectors of different lengths.","solution":"import math def vector_to_index_value_list(vector): Convert a full vector to its sparse representation using an index-value list. return [(index, value) for index, value in enumerate(vector) if value != 0] def dot_product(iv_list1, iv_list2): Compute the dot product between two sparse vectors. index_value_map2 = dict(iv_list2) return sum(value1 * index_value_map2.get(index1, 0) for index1, value1 in iv_list1) def magnitude(iv_list): Compute the magnitude of a sparse vector. return math.sqrt(sum(value ** 2 for _, value in iv_list)) def cosine_similarity(vector1, vector2): Compute the cosine similarity between two sparse vectors. iv_list1 = vector_to_index_value_list(vector1) iv_list2 = vector_to_index_value_list(vector2) dot = dot_product(iv_list1, iv_list2) mag1 = magnitude(iv_list1) mag2 = magnitude(iv_list2) if mag1 == 0 or mag2 == 0: return 0.0 return dot / (mag1 * mag2)"},{"question":"# Scenario: You are working on a communication protocol that requires sending multiple strings over a network in a compact and robust format. To achieve this, you need to encode the list of strings into a single string and then decode it back to the original list upon receipt. This will ensure minimal data loss and efficient transmission. # Problem: Write two functions, `encode` and `decode`. Function 1: `encode` Encode a list of strings into a single concatenated string that preserves all information and can be decoded back to the original list. ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to be encoded. :rtype: str pass ``` Function 2: `decode` Decode a single concatenated string back into the original list of strings. ```python def decode(s): Decodes a single string to a list of strings. :param s: str - The encoded string. :rtype: List[str] pass ``` Input: - For `encode`: a list of strings, `strs`, where each string contains 0 or more characters, and the list contains 0 or more such strings. - For `decode`: a single string `s` that represents the encoded list of strings. Output: - For `encode`: a single string that represents the encoded list of strings. - For `decode`: a list of strings that represents the decoded strings. Constraints: - Strings may include any ASCII characters. - Efficient handling of edge cases (e.g., empty strings, special characters). - The delimiter `:` is used as a separator between the length of a string and its contents. Examples: ```python # Example 1 input_list = [\\"hello\\", \\"world\\"] encoded_string = encode(input_list) # encoded_string might be \\"5:hello5:world\\" decoded_list = decode(encoded_string) # decoded_list should be [\\"hello\\", \\"world\\"] # Example 2 input_list = [\\"foo\\", \\"\\", \\"bar\\"] encoded_string = encode(input_list) # encoded_string might be \\"3:foo0:3:bar\\" decoded_list = decode(encoded_string) # decoded_list should be [\\"foo\\", \\"\\", \\"bar\\"] # Example 3 input_list = [] encoded_string = encode(input_list) # encoded_string might be \\"\\" decoded_list = decode(encoded_string) # decoded_list should be [] ``` Implement the `encode` and `decode` functions as described, ensuring they handle all edge cases efficiently.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to be encoded. :rtype: str encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string to a list of strings. :param s: str - The encoded string. :rtype: List[str] strs = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length strs.append(s[j + 1:i]) return strs"},{"question":"You are tasked with determining path availability between nodes in a directed graph. Implement the method `is_path_exist(graph, source, destination)` using Depth-First Search (DFS), which takes the graph representation and two nodes, the source and the destination, as input and returns a boolean indicating whether a path exists from the source node to the destination node. # Input * `graph`: A dictionary where keys are node identifiers and values are lists of nodes to which there is a directed edge from the key node. * `source`: An integer representing the source node. * `destination`: An integer representing the destination node. # Output * Return `True` if there is a path from `source` to `destination`. * Return `False` otherwise. # Constraints * The number of nodes (V) and number of edges (E) in the graph satisfies: `1 <= V, E <= 10^4`. * Node identifiers are non-negative integers. # Example ```python graph = { 0: [1, 3], 1: [2], 2: [3], 3: [] } print(is_path_exist(graph, 0, 3)) # Output: True print(is_path_exist(graph, 1, 0)) # Output: False ``` # Notes * Ensure the code handles edge cases such as disconnected graphs, graphs with cycles, and invalid paths gracefully. * Optimize for both time and space complexity where feasible. # Solution Template ```python def is_path_exist(graph, source, destination): def dfs(current, visited): if current == destination: return True visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: if dfs(neighbor, visited): return True return False return dfs(source, set()) ```","solution":"def is_path_exist(graph, source, destination): def dfs(current, visited): if current == destination: return True visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: if dfs(neighbor, visited): return True return False return dfs(source, set())"},{"question":"Context: You are tasked with handling specialized stack operations in a legacy system where the stack is being utilized in complex calculations inside various functions. One specific task involves removing the smallest value from the stack while maintaining the integrity of the remaining elements performing according to LIFO principle. Problem Description: Write a function `remove_min` that accepts a stack (implemented as a list) and removes the smallest element from the stack. The stack will not be empty and can contain duplicate values. You are expected to return the modified stack after removing the smallest value. Function Signature: ```python def remove_min(stack: list) -> list: ``` Inputs: - `stack`: A list of integers representing the stack where the bottom of the stack is the first element (index 0) and the top of the stack is the last element (last index). Outputs: - A list representing the stack with the smallest element removed. Constraints: - The function should run in O(n) time complexity. - The function should use O(n) additional space. Example: ```python stack = [2, 8, 3, -6, 7, 3] remove_min(stack) # returns [2, 8, 3, 7, 3] ``` Notes: - Ensure you handle the case where there are multiple instances of the smallest value correctly (only one instance should be removed). - The stack should retain its LIFO structure with the remaining elements.","solution":"def remove_min(stack: list) -> list: Removes the smallest element from the stack while maintaining the order of the other elements. if not stack: return stack # If stack is empty, return it as is min_val = min(stack) # Find the smallest value in the stack count = stack.count(min_val) # Find the occurrence of the smallest value # Remove just one instance of the smallest value for i in range(count): stack.remove(min_val) break return stack"},{"question":"# Full Binary Tree Reconstruction Given two arrays representing the preorder and postorder traversal of a full binary tree, your task is to construct the full binary tree and print the inorder traversal of that tree. Instructions: 1. You should implement a function `construct_tree(pre: List[int], post: List[int], size: int) -> List[int]` that constructs a binary tree from the given preorder and postorder traversal and returns the inorder traversal of the constructed tree. 2. To assist you, a class `TreeNode` and various utility functions have been provided as part of the solution scaffold. 3. Ensure your code handles edge cases, such as empty arrays or arrays with unmatched traversal orders. Function Signature: ```python def construct_tree(pre: List[int], post: List[int], size: int) -> List[int]: ``` Input: - `pre`: List of integers representing the preorder traversal of the full binary tree. - `post`: List of integers representing the postorder traversal of the full binary tree. - `size`: An integer representing the size of traverse arrays. Output: - Returns a list of integers representing the inorder traversal of the constructed full binary tree. Example: ```python pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] size = 7 assert construct_tree(pre, post, size) == [4, 2, 5, 1, 6, 3, 7] ``` Constraints: - Since the tree is full, theorem ensures consistent traversal arrays. - No mismatched elements within `pre` and `post` arrays. Use the provided `TreeNode` class and `print_inorder` utility function to facilitate your logic: ```python class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def print_inorder(root, result=None): if root is None: return [] if result is None: result = [] print_inorder(root.left, result) result.append(root.val) print_inorder(root.right, result) return result ``` **Note**: You can only utilize the provided recursion-utility to construct the subtree arrays division.","solution":"from typing import List class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(pre, pre_start, post, post_start, size): if size == 0: return None root = TreeNode(pre[pre_start]) if size == 1: return root # The next value in preorder (pre[pre_start + 1]) is the left child left_child = pre[pre_start + 1] # Find the left child in postorder array to determine the size of left subtree left_subtree_size = post.index(left_child) - post_start + 1 root.left = build_tree(pre, pre_start + 1, post, post_start, left_subtree_size) root.right = build_tree(pre, pre_start + left_subtree_size + 1, post, post_start + left_subtree_size, size - left_subtree_size - 1) return root def print_inorder(root, result=None): if root is None: return [] if result is None: result = [] print_inorder(root.left, result) result.append(root.val) print_inorder(root.right, result) return result def construct_tree(pre: List[int], post: List[int], size: int) -> List[int]: if size == 0: return [] root = build_tree(pre, 0, post, 0, size) return print_inorder(root)"},{"question":"Question # Context: You are provided with a helper function, `search_insert`, which performs binary search to find the correct position to insert an element into a sorted list. Your task is to use this helper function to implement the full Insertion Sort algorithm. # Task: Implement a function `insertion_sort_with_binary_search(array)` that receives a list of integers and sorts it in non-decreasing order using Insertion Sort with the optimization of binary search to find the position for insertion. # Function Signature: ```python def insertion_sort_with_binary_search(array: list) -> list: pass ``` # Input: * `array` - A list of integers, where (1 leq text{len(array)} leq 10^4). # Output: * Return a list of integers sorted in non-decreasing order. # Constraints: * The list can contain both positive and negative integers. * The helper function `search_insert(array, val)` is pre-defined and can be used directly. # Examples: ```python insertion_sort_with_binary_search([3, 4, 2, 1]) -> [1, 2, 3, 4] insertion_sort_with_binary_search([10, -1, 2, 5, 20, -5]) -> [-5, -1, 2, 5, 10, 20] insertion_sort_with_binary_search([1, 1, 1]) -> [1, 1, 1] ``` # Notes: * The function should be efficient enough to handle the upper constraints. * Make use of the provided binary search helper function to find the correct position of each element to be inserted.","solution":"def search_insert(array, val): Helper function that performs a binary search to find the correct insertion index for val in array. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left def insertion_sort_with_binary_search(array): Sorts an array using insertion sort, with binary search to find the correct position for each insertion. sorted_array = [] for val in array: insert_position = search_insert(sorted_array, val) sorted_array.insert(insert_position, val) return sorted_array"},{"question":"# Question: Minimum Deletion Steps to Make Two Strings Same You are given two strings, `word1` and `word2`. Your task is to find the minimum number of steps required to make both strings the same by only deleting characters from either string. Function Signature ```python def min_deletion_steps(word1: str, word2: str) -> int: # your code here ``` Input - `word1`: A string of length n (1 ≤ n ≤ 500). - `word2`: A string of length m (1 ≤ m ≤ 500). Output - An integer representing the minimum number of deletion steps required to make the two strings the same. Example ```python # Example 1: word1 = \\"sea\\" word2 = \\"eat\\" # Expected Output: 2 # Explanation: You need one step to delete \'s\' from \\"sea\\" to make \\"ea\\" and another step to delete \'t\' from \\"eat\\" to make \\"ea\\". print(min_deletion_steps(word1, word2)) # Output: 2 # Example 2: word1 = \\"leetcode\\" word2 = \\"etco\\" # Expected Output: 4 # Explanation: You need to delete \'l\', \'e\', \'d\', \'e\' from \\"leetcode\\" and \'e\', \'t\', \'t\' from \\"etco\\" to make both strings \\"etco\\". print(min_deletion_steps(word1, word2)) # Output: 4 ``` Constraints - Both strings only contain lowercase English characters. - Both strings are non-empty. Requirements - Your implementation should be efficient with a time complexity of O(n * m) and a space complexity of O(n * m). - Consider edge cases such as completely identical strings, strings with no common characters, and strings where one is empty. Use a dynamic programming approach to achieve the desired performance. Define a 2D array where each entry `dp[i][j]` represents the minimum number of deletions required to equalize the substrings `word1[0:i]` and `word2[0:j]`.","solution":"def min_deletion_steps(word1: str, word2: str) -> int: n = len(word1) m = len(word2) # dp[i][j] will be the length of the longest common subsequence of word1[:i] and word2[:j] dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) longest_common_subsequence_length = dp[n][m] return n + m - 2 * longest_common_subsequence_length"},{"question":"Extended Shell Sort **Context**: You\'ve been hired by a data analytics company that needs to sort datasets efficiently. Their datasets typically contain real numbers with varying degrees of prior sorting. Your goal is to implement an optimized version of Shell Sort to sort these datasets. The company uses custom gap sequences to enhance sorting performance for their specific data patterns. **Task**: Your task is to implement the Shell Sort algorithm with a custom gap sequence. Additionally, your implementation should handle certain edge cases gracefully and provide stability checks. **Requirements**: 1. Implement the Shell Sort algorithm with a Hibbard gap sequence. 2. Handle and sort an array containing real numbers (floating points). 3. Write a function `stable_shell_sort(arr)` that returns a sorted array. 4. Analyze the worst-case time complexity of your implementation. **Function Signature**: ```python def stable_shell_sort(arr: List[float]) -> List[float]: pass ``` **Input Format**: * A list of floating-point numbers, which may be unsorted or partially sorted. * The length of the list will be between 1 and 10^5. **Output Format**: * A sorted list of floating-point numbers in ascending order. **Constraints**: * The algorithm should have a worst-case time complexity better than or equal to O(n^2). **Performance Requirements**: * Aim to achieve a time complexity close to O(n log n). * Optimize for minimal swap operations. **Edge Cases**: * An empty list should return an empty list. * Lists with a single element should be handled correctly. * Handle lists that already come sorted (or reverse sorted). **Scenario**: Here is an example of how the function should work: ```python # Example 1: arr = [3.1, 2.2, 1.5, 4.8, 5.0] print(stable_shell_sort(arr)) # Output: [1.5, 2.2, 3.1, 4.8, 5.0] # Example 2: arr = [5.5, 4.4, 3.3, 2.2, 1.1] print(stable_shell_sort(arr)) # Output: [1.1, 2.2, 3.3, 4.4, 5.5] # Example 3: arr = [1.1] print(stable_shell_sort(arr)) # Output: [1.1] # Example 4: arr = [] print(stable_shell_sort(arr)) # Output: [] ``` **Note**: Ensure your implementation is tested on large datasets for performance validation.","solution":"def stable_shell_sort(arr): Sorts an array of floating-point numbers using the Shell Sort algorithm with a Hibbard gap sequence. Parameters: arr (list of float): The list of floating-point numbers to be sorted. Returns: list of float: The sorted list. n = len(arr) if n <= 1: return arr # Generate the Hibbard gap sequence (1, 3, 7, 15, ...) gaps = [] k = 1 while (2**k - 1) < n: gaps.append(2**k - 1) k += 1 # Reverse to start with the largest gap gaps.reverse() for gap in gaps: for i in range(gap, n): temp = arr[i] j = i # Stable insertion sort using gap while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Question You are given a B-Tree data structure implementation that supports insertion, deletion, searching, and traversal. Your task is to implement a function that merges two B-Trees of the same degree into one B-Tree, maintaining the B-Tree properties. The merged B-Tree should contain all the elements from both input B-Trees in sorted order. Expected Input and Output * **Input**: * Two B-Tree objects `btree1` and `btree2`, both of degree t. * **Output**: * A new B-Tree object containing all elements from both `btree1` and `btree2`. Constraints * Both `btree1` and `btree2` have the same degree **t**. * Elements in the B-Trees are unique within each tree but may overlap between `btree1` and `btree2`. Function Signature ```python def merge_btrees(btree1: BTree, btree2: BTree) -> BTree: pass ``` # Detailed Directions 1. **Merge Sorted Lists**: Implement helper functions to merge the keys and children of nodes from both B-Trees. 2. **Reconstruction**: Reconstruct the merged B-Tree from the combined keys and children of both input B-Trees. 3. **Handling Full Nodes**: Ensure that the new B-Tree maintains its properties by appropriately splitting nodes that exceed the allowed maximum number of keys. Evaluation Criteria Your implementation will be evaluated based on: * Correctness: Does your merged tree contain all elements from both input trees in sorted order? * Efficiency: Does your implementation maintain the O(log n) complexity for insertions, deletions, and searches? * Robustness: Does your code handle edge cases such as empty trees, trees with only one node, etc.?","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node self.keys = [] # List of keys in the node self.children = [] # List of child BTreeNode objects class BTree: def __init__(self, t): self.t = t # Minimum degree of B-tree self.root = BTreeNode(t, leaf=True) # Method to traverse the tree in-order def traverse(self, node=None): node = node or self.root result = [] for i in range(len(node.keys)): if not node.leaf: result.extend(self.traverse(node.children[i])) result.append(node.keys[i]) if not node.leaf: result.extend(self.traverse(node.children[-1])) return result # Insert a new key into the B-tree def insert(self, k): root = self.root if len(root.keys) == (2 * self.t - 1): new_root = BTreeNode(self.t, leaf=False) new_root.children.append(self.root) self.split_child(new_root, 0, self.root) self.root = new_root self._insert_non_full(self.root, k) # Split the child function def split_child(self, parent, i, child): t = self.t new_child = BTreeNode(t, leaf=child.leaf) parent.children.insert(i + 1, new_child) parent.keys.insert(i, child.keys[t - 1]) new_child.keys = child.keys[t:(2 * t - 1)] child.keys = child.keys[0:(t - 1)] if not child.leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[0:t] # Insert non full function to support insertion def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t - 1): self.split_child(node, i, node.children[i]) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def merge_sorted_lists(list1, list2): result = [] while list1 and list2: if list1[0] < list2[0]: result.append(list1.pop(0)) else: result.append(list2.pop(0)) result.extend(list1 or list2) return result def merge_btrees(btree1, btree2): elements1 = btree1.traverse() elements2 = btree2.traverse() merged_elements = merge_sorted_lists(elements1, elements2) merged_btree = BTree(btree1.t) for elem in merged_elements: merged_btree.insert(elem) return merged_btree"},{"question":"Given a set of distinct integers, write a function `subsets` that returns all possible subsets (the power set) of the given set. The solution set should contain subsets only as unique tuples. # Function Signature ```python def subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` # Input - A list of distinct integers `nums` such that `0 <= len(nums) <= 20`. # Output - A set of tuples, where each tuple represents a unique subset of the given integers. # Constraints - The input list `nums` contains only distinct integers. # Example ```python nums = [1, 2, 3] Output: { (1, 2), (1, 3), (1,), (2,), (3,), (1, 2, 3), (), (2, 3) } ``` # Description 1. **Core Requirement**: Implement the function `subsets` to generate all subsets of the given list of integers. 2. **Algorithm Support**: Use the concept of bitwise manipulation to determine the inclusion/exclusion of each element when forming subsets. 3. **Edge Cases**: Handle cases with empty lists and lists of varying lengths up to 20 elements. # Performance Requirement - Ensure that your function completes execution efficiently for the input constraints provided. **Note**: The implementation should consider all subsets based on binary combinations of inclusion or exclusion.","solution":"from typing import List, Set, Tuple def subsets(nums: List[int]) -> Set[Tuple[int]]: Returns all possible subsets of the given list of distinct integers as unique tuples. def get_subsets(nums): if not nums: return [[]] first = nums[0] rest_subsets = get_subsets(nums[1:]) with_first = [[first] + subset for subset in rest_subsets] return with_first + rest_subsets all_subsets = get_subsets(nums) return {tuple(sorted(subset)) for subset in all_subsets}"},{"question":"Scenario You are tasked with developing a packing algorithm for an e-commerce warehouse. The warehouse uses dynamic programming to maximize the value of items that can be packed into a shipment container. Each item has a certain value and weight, and the container has a maximum weight capacity it can carry. Problem Description Write a function `maximize_container_value` that takes in a list of items, where each item is represented as a tuple (value, weight), and an integer representing the container\'s weight capacity. Your function should return the maximum total value of items that can be packed into the container without exceeding its weight capacity. Function Signature ```python def maximize_container_value(items: List[Tuple[int, int]], capacity: int) -> int: # Your code here ``` Input and Output * **Input**: * `items`: A list of tuples, where each tuple contains two integers, `value` and `weight`. 1 ≤ len(items) ≤ 1000. * `capacity`: An integer, representing the maximum allowed weight of the container. 1 ≤ capacity ≤ 10^4. * **Output**: * Return an integer representing the maximum summarized value of the items that can be packed in the container. Constraints * Each item\'s value and weight are positive integers. * There is no limit to the value of each item. Examples Example 1: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert maximize_container_value(items, capacity) == 80 # We pick items with (50, 3) and (30, 2), total value = 80 ``` Example 2: ```python items = [(100, 10), (200, 20), (300, 30)] capacity = 50 assert maximize_container_value(items, capacity) == 500 # We pick items with (200, 20) and (300, 30), total value = 500 ``` Requirements 1. Implement the dynamic programming approach efficiently with a focus on both time and space complexity. 2. Handle edge cases such as an empty item list or minimal capacity gracefully.","solution":"from typing import List, Tuple def maximize_container_value(items: List[Tuple[int, int]], capacity: int) -> int: Returns the maximum value of items that can be packed into the container without exceeding the weight capacity. n = len(items) dp = [0] * (capacity + 1) for value, weight in items: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + value) return dp[capacity]"},{"question":"You are tasked with implementing a custom data structure that supports insertion, removal, and retrieving random elements while maintaining O(1) average time complexity for these operations. Implement the `RandomizedSet` class with the following methods: 1. **`__init__(self) -> None`**: Constructor to initialize your data structure. 2. **`insert(self, val: int) -> bool`**: Inserts an item `val` into the set if not already present. Returns `True` if the item was successfully added, and `False` if it was already present. 3. **`remove(self, val: int) -> bool`**: Removes an item `val` from the set if present. Returns `True` if the item was successfully removed, and `False` if it was not present. 4. **`get_random(self) -> int`**: Returns a random element from the current set of elements, ensuring each element has an equal probability of being returned. If the set is empty, this method should return `None`. Background: - You may assume that `val` is an integer and will fit within the Python integer range. - Your get_random function must return `None` for an empty set. - The randomized selection needs to be uniform, meaning every element should have the same probability of being chosen. Example: ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(3)) # True print(rs.insert(1)) # False print(rs.remove(2)) # True print(rs.remove(2)) # False print(rs.get_random()) # Randomly return 1 or 3 print(rs.get_random()) # Randomly return 1 or 3 print(rs.get_random()) # Randomly return 1 or 3 ``` Constraints: - The input values for `insert` and `remove` are within the range -10^6 to 10^6. - The total number of calls to `insert`, `remove`, and `get_random` functions will not exceed 10^5.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.val_to_index = {} self.values = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.val_to_index: return False self.val_to_index[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.val_to_index: return False index = self.val_to_index[val] last_element = self.values[-1] self.values[index] = last_element self.val_to_index[last_element] = index self.values.pop() del self.val_to_index[val] return True def get_random(self) -> int: Get a random element from the set. if not self.values: return None return random.choice(self.values)"},{"question":"# Cycle Sort Algorithm Implementation **Context:** Cycle Sort is a comparison-based sorting algorithm that is particularly efficient in scenarios where the number of writes to memory needs to be minimized. The algorithm works by identifying cycles in the permutation of the array elements and placing elements in their correct positions with a minimal number of replacements. **Task:** Implement the `cycle_sort` function that sorts an array of integers in ascending order using the Cycle Sort algorithm. **Function Signature:** ```python def cycle_sort(arr: List[int]) -> List[int]: ``` **Input:** * `arr`: A list of integers, `arr`, where (1 leq text{len(arr)} leq 10^4). **Output:** * Returns a sorted list of integers in non-decreasing order. **Constraints:** * The elements in the array can be negative, zero, or positive. * The implementation should sort the array in place and return it. **Performance Requirements:** * The algorithm should have a time complexity of O(N^2). * The space complexity should be O(1), meaning no additional memory other than the input array should be used for sorting. # Example ```python # Example 1 arr = [3, 1, 2, 4] print(cycle_sort(arr)) # Output: [1, 2, 3, 4] # Example 2 arr = [5, 1, 4, 2, -3] print(cycle_sort(arr)) # Output: [-3, 1, 2, 4, 5] # Example 3 arr = [0] print(cycle_sort(arr)) # Output: [0] # Example 4 arr = [] print(cycle_sort(arr)) # Output: [] ``` **Note:** - Students should handle edge cases such as empty arrays or arrays with a single element. - Ensure that the algorithm correctly handles arrays with duplicate values.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) for start in range(n - 1): item = arr[start] pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 if pos == start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# String Reversal Assessment Question **Context:** Reversing a string is a common operation in many programming tasks. Understanding different approaches to this problem helps in recognizing their trade-offs in terms of readability, performance, and memory usage. **Problem Statement:** Write a Python function `reverse_string(s: str) -> str` to reverse a given string using an algorithm of your choice. You must also handle edge cases and ensure that your function is efficient in terms of time and space complexity. **Function Signature:** ```python def reverse_string(s: str) -> str: pass ``` **Input:** * `s` (str): A string of length (leq 10^6). **Output:** * (str): A new string that represents the reverse of the input string `s`. **Constraints:** * The input string may contain any combination of letters, digits, and special characters. * The function should handle very large strings efficiently. **Performance Requirements:** * The time complexity should be (O(n)). * The space complexity should be (O(n)). **Examples:** 1. `reverse_string(\\"hello\\")` should return `\\"olleh\\"`. 2. `reverse_string(\\"A man, a plan, a canal, Panama!\\")` should return `\\"!amanaP ,lanac a ,nalp a ,nam A\\"`. 3. `reverse_string(\\"\\")` should return `\\"\\"` (empty string). 4. `reverse_string(\\"a\\")` should return `\\"a\\"`. **Additional Requirements:** * Include handling of edge cases, such as empty strings. * Optimize for both time and space complexity. **Note:** You are free to decide which method (recursive, iterative, or the Pythonic/Ultra-Pythonic approaches) you wish to implement. Clearly comment on your choice and explain why it is suitable for this task.","solution":"def reverse_string(s: str) -> str: Reverses the input string s. :param s: Input string of length <= 10^6 :return: String with characters in reverse order # Use slicing for a simple and efficient solution return s[::-1]"},{"question":"# Palindrome Checking Problem Statement Write a function to check if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. You are required to implement at least two different methods among the ones listed below: 1. Two-pointer technique (iteratively comparing the characters from both ends). 2. Using stack. 3. Using deque. 4. Comparing the string with its reverse. Function Signatures ```python def is_palindrome_two_pointer(s: str) -> bool: pass def is_palindrome_stack(s: str) -> bool: pass def is_palindrome_deque(s: str) -> bool: pass def is_palindrome_reverse(s: str) -> bool: pass ``` Input * A single string `s`, which may contain alphanumeric characters and punctuation, and may vary in length. Output * Return a boolean value `True` if the input string is a palindrome, `False` otherwise. Constraints * The function should handle strings of arbitrary length. * Alphanumeric characters should be considered, ignoring cases. * Punctuation and spaces should be ignored. * The string may be empty. Examples ```python assert is_palindrome_two_pointer(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_two_pointer(\\"race a car\\") == False assert is_palindrome_stack(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_stack(\\"race a car\\") == False assert is_palindrome_deque(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_deque(\\"race a car\\") == False assert is_palindrome_reverse(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_reverse(\\"race a car\\") == False ``` Submission Requirements * Implement at least two different methods from the outlined techniques. * Ensure all edge cases are handled properly.","solution":"import collections def is_palindrome_two_pointer(s: str) -> bool: Checks if the provided string is a palindrome using the two-pointer technique. left, right = 0, len(s) - 1 while left < right: while left < right and not s[left].isalnum(): left += 1 while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True def is_palindrome_reverse(s: str) -> bool: Checks if the provided string is a palindrome by comparing it to its reversed string. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"Context: You are given the task of analyzing the reachability among a set of tasks represented as a directed graph. Each task can depend on other tasks, forming dependencies. To ensure all dependencies can be managed, we need to determine if there exists a connection (direct or indirect) between any two tasks. Problem Statement: Implement the `find_transitive_closure(graph)` function that takes a dictionary-based graph representation and returns the transitive closure of the graph in the form of a 2D list or matrix. The function should leverage depth-first search (DFS) to compute the reachability matrix. Function Signature: ```python def find_transitive_closure(graph: dict, num_vertices: int) -> list: pass ``` Input: - `graph`: A dictionary where keys are source vertices and values are lists of target vertices. - `num_vertices`: An integer representing the number of vertices in the graph. Output: - A 2D list of size `num_vertices x num_vertices` where `closure[i][j]` is 1 if there is a path from vertex `i` to vertex `j`, otherwise 0. Constraints: - 1 <= num_vertices <= 100 - The graph can have multiple edges and self-loops. - Graph might be disconnected. Example: ```python graph = { 0: [1, 3], 1: [2], 2: [3], 3: [] } num_vertices = 4 expected_output = [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] assert find_transitive_closure(graph, num_vertices) == expected_output ``` Explanation: - From vertex 0, we can reach vertices 1, 2, and 3. - From vertex 1, we can reach vertices 2 and 3. - From vertex 2, we can reach vertex 3. - From vertex 3, we can only reach itself. Note: Ensure to handle edge cases such as disconnected vertices or self-loops correctly.","solution":"def find_transitive_closure(graph, num_vertices): Computes the transitive closure of a directed graph using Depth-First Search (DFS). :param graph: A dictionary representing the graph where keys are source vertices and values are lists of target vertices. :param num_vertices: An integer representing the number of vertices in the graph. :return: A num_vertices x num_vertices 2D list representing the transitive closure of the graph. closure = [[0] * num_vertices for _ in range(num_vertices)] def dfs(v, start): closure[start][v] = 1 for neighbor in graph.get(v, []): if not closure[start][neighbor]: dfs(neighbor, start) for v in range(num_vertices): dfs(v, v) return closure"},{"question":"# Extended Euclidean Algorithm Application You are provided with an implementation of the extended Euclidean algorithm. The goal is to further comprehend the versatility of this fundamental algorithm by applying it to solve a slightly more complex problem. Your task is to use the extended GCD to determine if a Linear Diophantine Equation of the form ( a cdot x + b cdot y = c ) has integer solutions, and if so, find one such pair ((x, y)). Problem Statement Write a function `solve_diophantine(a, b, c)` that determines whether there exist integer solutions to the equation: [ a cdot x + b cdot y = c ] If such solutions exist, return a pair ((x, y)). If no solutions exist, return `None`. Input & Output **Input**: * An integer ( a ) * An integer ( b ) * An integer ( c ) **Output**: * A pair of integers `(x, y)` representing solutions to the equation, or `None` if no solutions exist. Constraints * ( -10^9 leq a, b, c leq 10^9 ) * ( a ) and ( b ) are not both zero Example ```python # Example 1: a = 30 b = 20 c = 10 solve_diophantine(a, b, c) # Result can be any one pair satisfying the equation # Example 2: a = 35 b = 15 c = 1 solve_diophantine(a, b, c) # Returns: None (No solutions exist) ``` Performance Requirements Your solution should be efficient and able to handle the given constraints within a reasonable time. Hints 1. Utilize the Extended Euclidean Algorithm to find one solution for ( a cdot s + b cdot t = text{GCD}(a, b) ). 2. Use the properties of Linear Diophantine equations to adjust for the constant ( c ).","solution":"def extended_gcd(a, b): Computes the extended GCD of a and b. Returns a tuple (g, x, y) where g is the GCD of a and b, and x and y are the coefficients such that a*x + b*y = g. if b == 0: return (a, 1, 0) else: g, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return (g, x, y) def solve_diophantine(a, b, c): Solves the Linear Diophantine Equation a * x + b * y = c. Returns a tuple (x, y) if there are solutions, or None if no solution exists. g, x0, y0 = extended_gcd(a, b) if c % g != 0: return None x = x0 * (c // g) y = y0 * (c // g) return (x, y)"},{"question":"In this coding assessment, you are required to implement a function using bit manipulation techniques to count the number of \'1\' bits in the binary representation of an unsigned integer, also known as the Hamming weight. You should utilize Brian Kernighan\'s Algorithm as demonstrated in the provided code snippets. # Function Requirements: Implement the function `count_ones(n: int) -> int` that: * Takes an unsigned integer `n`. * Returns the number of \'1\' bits in its binary representation. # Input and Output: * **Input**: * An integer `n` (0 ≤ n ≤ 2^32 - 1). * **Output**: * An integer representing the Hamming weight (the number of 1 bits in the binary representation of `n`). # Constraints: * The function must be optimized with a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of `n`. * Implement the function using an **iterative** approach. # Example Scenarios: Example 1: * **Input**: `n = 11` * **Output**: `3` * **Explanation**: The binary representation of 11 is 00000000000000000000000000001011, which contains three \'1\' bits. Example 2: * **Input**: `n = 128` * **Output**: `1` * **Explanation**: The binary representation of 128 is 00000000000000000000000010000000, which contains one \'1\' bit. Example 3: * **Input**: `n = 0` * **Output**: `0` * **Explanation**: The binary representation of 0 has no \'1\' bits. # Note: Include any necessary edge case handling directly in your function.","solution":"def count_ones(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s algorithm. count = 0 while n: n = n & (n - 1) count += 1 return count"},{"question":"Dijkstra\'s Shortest Path in a Graph # Objective: Implement the Dijkstra\'s algorithm to find the shortest path from a given starting vertex to all other vertices in a graph represented as an adjacency matrix. # Input: - An integer `n`, the number of vertices in the graph (1 ≤ n ≤ 1000). - An n x n matrix `edges`, where `edges[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. If there is no direct edge, `edges[i][j]` will be 0. # Output: - An array of integers representing the shortest distances from the source vertex (vertex 0) to each vertex. If a vertex is not reachable, its distance should be represented as infinity. # Constraints: - The graph is directed and edge weights are non-negative. - Ensure the implementation has a complexity suitable for the given constraints. # Example: ```python n = 5 edges = [ [0, 10, 0, 0, 5], [0, 0, 1, 0, 2], [0, 0, 0, 4, 0], [7, 0, 6, 0, 0], [0, 3, 9, 2, 0] ] # Expected output # [0, 8, 9, 7, 5] ``` # Function Signature: ```python def dijkstra(n: int, edges: List[List[int]]) -> List[int]: # Your code here pass ``` # Requirements: - Implement the function `dijkstra(n: int, edges: List[List[int]]) -> List[int]` to return the shortest distances from vertex 0 to all other vertices. - Handle edge cases and optimize for performance where possible.","solution":"import heapq from typing import List def dijkstra(n: int, edges: List[List[int]]) -> List[int]: INF = float(\'inf\') dist = [INF] * n dist[0] = 0 pq = [(0, 0)] # (distance, vertex) while pq: curr_dist, u = heapq.heappop(pq) if curr_dist > dist[u]: continue for v in range(n): if edges[u][v] != 0: new_dist = curr_dist + edges[u][v] if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) return dist"},{"question":"# Graph Traversal Challenge Context: You are working as a software developer and need to analyze a network of connected nodes to find all reachable nodes starting from a given node. Your goal is to implement graph traversal algorithms that can efficiently explore the network either by depth-first search or breadth-first search. Task: Write the following functions to traverse a graph represented as an adjacency list: 1. `dfs_traverse(graph, start)`: Traverse the graph using iterative DFS. 2. `bfs_traverse(graph, start)`: Traverse the graph using BFS. 3. `dfs_traverse_recursive(graph, start)`: Traverse the graph using recursive DFS. Each function should return a set of all nodes that are reachable from the `start` node. Input: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start`: The starting node for the traversal. Output: - A set containing all nodes reachable from the `start` node. Constraints: - Nodes are represented as integers or strings. - The graph may be disconnected, but each traversal function will only consider the connected component containing the `start` node. - The graph does not contain self-loops or duplicate edges. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example calls and expected outputs dfs_traverse(graph, \'A\') # Output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} bfs_traverse(graph, \'A\') # Output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} dfs_traverse_recursive(graph, \'A\') # Output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ``` Notes: - The order of elements in the output set does not matter. - Handle edge cases such as an empty graph or a starting node not present in the graph.","solution":"def dfs_traverse(graph, start): Traverse the graph using iterative Depth-First Search (DFS). if start not in graph: return set() stack = [start] visited = set() while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbour for neighbour in reversed(graph[node]) if neighbour not in visited) return visited def bfs_traverse(graph, start): Traverse the graph using Breadth-First Search (BFS). if start not in graph: return set() queue = [start] visited = set() while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbour for neighbour in graph[node] if neighbour not in visited) return visited def dfs_traverse_recursive(graph, start, visited=None): Traverse the graph using recursive Depth-First Search (DFS). if visited is None: visited = set() if start not in graph: return visited visited.add(start) for neighbour in graph[start]: if neighbour not in visited: dfs_traverse_recursive(graph, neighbour, visited) return visited"},{"question":"# Question: Implement a Range Sum and Update Functionality using Fenwick Tree Background You are given a data structure called a Fenwick Tree (also known as Binary Indexed Tree). This data structure efficiently supports: 1. Updating the value at a given index in the array. 2. Computing prefix sums for subarrays. Your task is to implement a class `RangeSumFenwickTree` with the following methods: Methods 1. **Constructor**: `__init__(self, arr: List[int])` - Initializes the Fenwick Tree with a given list of integers. 2. **update(self, index: int, value: int) -> None**: - Updates the element at `index` to `value` by modifying the corresponding Fenwick Tree structure. 3. **query(self, index: int) -> int**: - Returns the sum of elements from index `0` to `index`. 4. **range_sum(self, left: int, right: int) -> int**: - Returns the sum of elements from `left` to `right` inclusive. Input and Output * The constructor receives an input list `arr` with `n` integers where `1 <= n <= 10^5` and `-10^4 <= arr[i] <= 10^4`. * The `update` method will be called with `index` and `value` such that `0 <= index < n` and `-10^4 <= value <= 10^4`. * The `query` and `range_sum` methods will be called with valid index ranges within the bounds of the array. Example ```python # Suppose we initialize the Fenwick Tree with the array [3, 2, -1, 6, 5, 4, -3]. fenwick_tree = RangeSumFenwickTree([3, 2, -1, 6, 5, 4, -3]) # Compute sum of first 3 elements (indices 0, 1, 2). assert fenwick_tree.query(2) == 4 # Output: 3 + 2 - 1 = 4 # Update the element at index 3 to 4. fenwick_tree.update(3, 4) # Compute the sum from index 0 to 3. assert fenwick_tree.range_sum(0, 3) == 8 # Output: 3 + 2 - 1 + 4 = 8 ``` Implement the class `RangeSumFenwickTree` with the methods described.","solution":"from typing import List class RangeSumFenwickTree: def __init__(self, arr: List[int]): self.n = len(arr) self.arr = arr[:] self.tree = [0] * (self.n + 1) for i in range(self.n): self._add(i + 1, arr[i]) def _add(self, index: int, value: int): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index: int, value: int) -> None: diff = value - self.arr[index] self.arr[index] = value self._add(index + 1, diff) def query(self, index: int) -> int: result = 0 index += 1 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left: int, right: int) -> int: return self.query(right) - self.query(left - 1)"},{"question":"# String Reversal Challenge Scenario You are part of a team developing a text processing library. One essential feature is efficient string reversal due to frequent palindromic checks. Task Write a function called `reverse_string` that reverses a given string using one of the following techniques. Explain your choice. Requirements 1. Your function must be efficient in terms of both time and space. 2. You need to handle edge cases such as empty strings and single character strings. Input * A string `s` consisting of n characters (0 <= n <= 10^6). Output * A string which is the reverse of `s`. Constraints * Do not use in-built methods other than simple indexing or slicing unless you justify performance benefits. * Ensure your solution is optimized for typical scenarios. Performance * Aim for a time complexity of O(n) and space complexity of O(1), if possible. Example ```python reverse_string(\\"hello\\") -> \\"olleh\\" reverse_string(\\"a\\") -> \\"a\\" reverse_string(\\"\\") -> \\"\\" ``` Implement your function in Python: ```python def reverse_string(s): # Your implementation here pass # Example usage print(reverse_string(\\"hello\\")) # Expected: \\"olleh\\" print(reverse_string(\\"a\\")) # Expected: \\"a\\" print(reverse_string(\\"\\")) # Expected: \\"\\" ```","solution":"def reverse_string(s): Reverses the given string s. Args: s (str): The string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"# Question You are given a list of unique integers `nums` where each integer is within the range `[0..n]` (inclusive). The list is supposed to contain all integers in that range, but one integer is missing. Implement the function `find_missing_number_optimized(nums)` that returns the missing integer from the list in O(n) time and O(1) space. **Function Signature**: ```python def find_missing_number_optimized(nums: List[int]) -> int: pass ``` # Input - `nums`: A list of unique integers varying from 0 to n (inclusive of n). - Length of `nums` will be `n`, meaning one number from the range `[0..n]` is missing. # Output - Return an integer representing the missing number in the sequence. # Constraints - All integers in `nums` must be unique. - Only one integer in the range `[0..n]` is missing. - The difference between consecutive elements in list `nums` cannot be more than 1. # Example Example 1: ```python nums = [3, 0, 1] assert find_missing_number_optimized(nums) == 2 ``` Example 2: ```python nums = [9,6,4,2,3,5,7,0,1] assert find_missing_number_optimized(nums) == 8 ``` Example 3: ```python nums = [0] assert find_missing_number_optimized(nums) == 1 ``` # Notes - Ensure to use O(n) time complexity and O(1) space complexity. - Edge cases should be considered, such as empty list, single value list etc.","solution":"def find_missing_number_optimized(nums): Finds the missing number in the array by calculating the expected sum of the first n natural numbers and subtracting the sum of the given numbers. This yields the missing number. Args: nums (List[int]): A list of unique integers where each integer is within the range [0..n]. Returns: int: The missing integer in the list. n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Coding Challenge: Adaptive Heap Sort **Context**: While the typical heap sort algorithm performs well under normal conditions (O(n log(n))), certain input patterns can still cause unnecessary overhead. To improve performance, you are tasked to implement an adaptive heap sort that reduces unnecessary operations for nearly sorted arrays. **Objective**: Implement an adaptive version of the heap sort algorithm that takes advantage of arrays that are already partially sorted. The algorithm should switch between heap sort and insertion sort based on the size of sorted runs detected in the input array. **Function Signature**: ```python def adaptive_heap_sort(arr: List[int]) -> List[int]: Sorts an array in ascending order using an adaptive combination of heap sort and insertion sort. Args: - arr: List[int] : The input array to sort. Returns: - List[int]: The sorted array. pass ``` # Input * `arr` (List[int]): The array of integers to be sorted. # Output * (List[int]): The sorted array in ascending order. # Constraints * The input list `arr` will contain integers. * Array length `n` where 0 <= n <= 10^6. * It is guaranteed that the list will fit into memory. # Performance Requirements * The adaptive sort is expected to handle typical cases in O(n log(n)), but should leverage nearly sorted runs to reduce unnecessary comparisons and swaps. # Hints 1. **Identify Sorted Runs**: Write a helper function to detect sorted runs and segments that are small enough for insertion sort to be efficient. 2. **Switch Heuristically**: Adaptively switch between heap sort and insertion sort based on run sizes. 3. **Simulate Runs**: You might want to simulate or print intermediate states to understand how your algorithm reduces operations on nearly sorted data. # Example ```python assert adaptive_heap_sort([10, 3, 2, 7, 6, 4, 8]) == [2, 3, 4, 6, 7, 8, 10] assert adaptive_heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert adaptive_heap_sort([9, 1, 8, 2, 7, 3, 6, 4, 5]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert adaptive_heap_sort([]) == [] ``` **Note**: Although this problem might sound complex, focusing on detecting sorted runs and efficiently combining insertion and heap sort should greatly help manage input variety and optimize performance.","solution":"from typing import List def insertion_sort(arr: List[int], start: int, end: int) -> None: Utility function to perform insertion sort on subarray arr[start:end+1]. for i in range(start + 1, end + 1): key = arr[i] j = i - 1 while j >= start and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def heapify(arr: List[int], n: int, i: int) -> None: Utility function to heapify a subtree rooted with node i (an index in arr[]). largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[largest] < arr[left]: largest = left # See if right child of root exists and is greater than the largest so far if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(arr: List[int]) -> None: Utility function to perform heap sort. n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) def adaptive_heap_sort(arr: List[int]) -> List[int]: Adaptive heap sort that switches to insertion sort for small runs. if len(arr) <= 1: return arr n = len(arr) run_threshold = 32 # Use insertion sort for runs smaller or equal to this size # First, perform insertion sort on small runs for start in range(0, n, run_threshold): end = min(start + run_threshold - 1, n - 1) insertion_sort(arr, start, end) # Then build a heap using the sorted runs cur_length = run_threshold while cur_length < n: for start in range(0, n, 2 * cur_length): mid = start + cur_length - 1 end = min((start + 2 * cur_length - 1), (n - 1)) left = arr[start:mid + 1] right = arr[mid + 1:end + 1] # Merge two runs using heap arr[start:end + 1] = sorted(left + right) cur_length *= 2 return arr"},{"question":"You need to help a friend who is developing an exercise tracking app. One of the features is to calculate the number of distinct ways a user can climb to the top of a staircase. Consider a staircase with `steps` steps, where each time you can either climb 1 or 2 steps. Your task is to write a function `distinct_ways` that calculates the number of distinct ways to reach the top of the staircase. # Function Signature ```python def distinct_ways(steps: int) -> int: pass ``` # Input * `steps` (integer): Number of steps to reach the top (`1 ≤ steps ≤ 10^5`). # Output * Return an integer representing the number of distinct ways to reach the top. # Constraints * The number of steps (`steps`) will always be a positive integer. * Efficient computation is necessary, i.e., consider both time and space complexity. * Assume integer computations fit within standard integer ranges. # Examples ```python assert distinct_ways(2) == 2 assert distinct_ways(3) == 3 assert distinct_ways(10) == 89 assert distinct_ways(1) == 1 ``` # Explanation 1. `steps = 2`: Possible ways to reach step 2 are (1+1) or (2), thus 2 ways. 2. `steps = 3`: Possible ways to reach step 3 are (1+1+1), (1+2), or (2+1), thus 3 ways. 3. `steps = 10`: You need to derive the 10th term in a sequence closely resembling Fibonacci which results in 89 distinct ways. 4. `steps = 1`: Direct step, only one way. Write the function `distinct_ways` that successfully computes the number of ways to climb to the top of the staircase efficiently.","solution":"def distinct_ways(steps: int) -> int: if steps == 1: return 1 if steps == 2: return 2 prev2 = 1 prev1 = 2 for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Problem Description You are given an array of words and an integer maxWidth. Your task is to format the text such that each line has exactly maxWidth characters, and is fully justified (both left and right). Each word is guaranteed to be non-empty and has a length not exceeding maxWidth. The input array of words contains at least one word. # Specific Requirements 1. **Greedy Approach**: Pack as many words as you can into each line until adding another word would exceed maxWidth. 2. **Padding**: Extra spaces (\' \') should be distributed as evenly as possible between words. If the spaces cannot be evenly distributed, the leftmost slots should be given more spaces. 3. **Last Line**: Should be left-justified, with no extra spaces between words. 4. **Edge Conditions**: Handle cases with one word in the row and a word\'s length exceeding maxWidth by raising exceptions. # Input - An array of strings `words` where `1 <= words.length <= 300` and `1 <= words[i].length <= 20`. - An integer `maxWidth` such that `1 <= maxWidth <= 100`. # Output - An array of strings, where each string represents a justified line of text with `maxWidth` characters. # Example ```python Input: words = [\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"] maxWidth = 16 Output: [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] ``` # Constraints - You must not use any library function for string justification. - Your solution should aim to minimize unnecessary space and time complexity. Implement the function `text_justification(words: List[str], maxWidth: int) -> List[str]` that takes as input an array of words and an integer maxWidth, and returns the justified text as an array of lines.","solution":"def text_justification(words, maxWidth): def justify_line(line, width, is_last=False): if is_last or len(line) == 1: # Left-justify if it is the last line or if the line only has one word return \' \'.join(line).ljust(width) total_characters = sum(len(word) for word in line) total_spaces = width - total_characters spaces_needed = len(line) - 1 even_spaces = total_spaces // spaces_needed extra_spaces = total_spaces % spaces_needed result = [] for i, word in enumerate(line): result.append(word) if i < spaces_needed: result.append(\' \' * (even_spaces + (1 if i < extra_spaces else 0))) return \'\'.join(result) result = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > maxWidth: result.append(justify_line(current_line, maxWidth)) current_line = [] current_length = 0 current_line.append(word) current_length += len(word) if current_line: result.append(justify_line(current_line, maxWidth, is_last=True)) return result"},{"question":"**Scenario**: As a developer at a financial company, you are tasked with creating a system to efficiently manage and retrieve transaction records. It is crucial that the system can handle frequent inserts and deletes while maintaining balanced data for quick access. **Problem Statement**: Implement a Red-Black Tree data structure. Your implementation should support the following operations: 1. **Insert an integer value** ensuring the tree remains balanced and adheres to the red-black properties. 2. **Delete a specified value** from the tree while maintaining the red-black properties. 3. **Inorder Traversal** of the tree, which should return a list of the nodes in ascending order, each node represented as a dictionary with keys `val` and `color` (`0` for black and `1` for red). # Detailed Requirements: 1. **Function `insert(val: int)`**: - Input: An integer `val` to be inserted into the red-black tree. - Output: None 2. **Function `delete(val: int)`**: - Input: An integer `val` to be deleted from the red-black tree if it exists. - Output: None 3. **Function `inorder() -> List[Dict[str, int]]`**: - Input: None - Output: A list of dictionaries representing the inorder traversal of the tree nodes, each dictionary containing `{\'val\': int, \'color\': int}`. # Constraints: - All node values are integers and will be unique. - The tree should handle up to `10^4` insertions and deletions efficiently. - Ensure the red-black properties are preserved after each insert or delete operation. # Example Usage: ```python rb_tree = RBTree() # Insert values rb_tree.insert(10) rb_tree.insert(20) rb_tree.insert(30) # Inorder Traversal output = rb_tree.inorder() # Expected output: [{\'val\': 10, \'color\': 0}, {\'val\': 20, \'color\': 1}, {\'val\': 30, \'color\': 0}] # Delete a value rb_tree.delete(20) # Inorder Traversal output = rb_tree.inorder() # Expected output: [{\'val\': 10, \'color\': 0}, {\'val\': 30, \'color\': 1}] ``` Implement the `RBTree` class and its associated methods for the red-black tree as specified above.","solution":"class RBNode: def __init__(self, val, color=1): self.val = val self.color = color # Red = 1, Black = 0 (New Node must be Red) self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NULL_LEAF = RBNode(val=0, color=0) self.root = self.NULL_LEAF def insert(self, val): new_node = RBNode(val) new_node.left = self.NULL_LEAF new_node.right = self.NULL_LEAF parent = None current = self.root while current != self.NULL_LEAF: parent = current if new_node.val < current.val: current = current.left elif new_node.val > current.val: current = current.right else: return # No duplicate values allowed new_node.parent = parent if parent is None: self.root = new_node elif new_node.val < parent.val: parent.left = new_node else: parent.right = new_node self._fix_insert(new_node) def _fix_insert(self, node): while node != self.root and node.parent.color == 1: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == 1: node.parent.color = 0 uncle.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.color = 0 node.parent.parent.color = 1 self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == 1: node.parent.color = 0 uncle.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.color = 0 node.parent.parent.color = 1 self._rotate_left(node.parent.parent) self.root.color = 0 def _rotate_left(self, node): temp = node.right node.right = temp.left if temp.left != self.NULL_LEAF: temp.left.parent = node temp.parent = node.parent if node.parent is None: self.root = temp else: if node == node.parent.left: node.parent.left = temp else: node.parent.right = temp temp.left = node node.parent = temp def _rotate_right(self, node): temp = node.left node.left = temp.right if temp.right != self.NULL_LEAF: temp.right.parent = node temp.parent = node.parent if node.parent is None: self.root = temp else: if node == node.parent.right: node.parent.right = temp else: node.parent.left = temp temp.right = node node.parent = temp def delete(self, val): def _fix_delete(node): while node != self.root and node.color == 0: if node == node.parent.left: sibling = node.parent.right if sibling.color == 1: sibling.color = 0 node.parent.color = 1 self._rotate_left(node.parent) sibling = node.parent.right if sibling.left.color == 0 and sibling.right.color == 0: sibling.color = 1 node = node.parent else: if sibling.right.color == 0: sibling.left.color = 0 sibling.color = 1 self._rotate_right(sibling) sibling = node.parent.right sibling.color = node.parent.color node.parent.color = 0 sibling.right.color = 0 self._rotate_left(node.parent) node = self.root else: sibling = node.parent.left if sibling.color == 1: sibling.color = 0 node.parent.color = 1 self._rotate_right(node.parent) sibling = node.parent.left if sibling.left.color == 0 and sibling.right.color == 0: sibling.color = 1 node = node.parent else: if sibling.left.color == 0: sibling.right.color = 0 sibling.color = 1 self._rotate_left(sibling) sibling = node.parent.left sibling.color = node.parent.color node.parent.color = 0 sibling.left.color = 0 self._rotate_right(node.parent) node = self.root node.color = 0 def _transplant(u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(node): while node.left != self.NULL_LEAF: node = node.left return node node_to_delete = self.root while node_to_delete != self.NULL_LEAF: if val < node_to_delete.val: node_to_delete = node_to_delete.left elif val > node_to_delete.val: node_to_delete = node_to_delete.right else: break if node_to_delete == self.NULL_LEAF: return original_color = node_to_delete.color if node_to_delete.left == self.NULL_LEAF: successor = node_to_delete.right _transplant(node_to_delete, node_to_delete.right) elif node_to_delete.right == self.NULL_LEAF: successor = node_to_delete.left _transplant(node_to_delete, node_to_delete.left) else: successor = _minimum(node_to_delete.right) original_color = successor.color moved_node = successor.right if successor.parent == node_to_delete: moved_node.parent = successor else: _transplant(successor, successor.right) successor.right = node_to_delete.right successor.right.parent = successor _transplant(node_to_delete, successor) successor.left = node_to_delete.left successor.left.parent = successor successor.color = node_to_delete.color if original_color == 0: _fix_delete(moved_node) def inorder(self): result = [] def _inorder(node): if node != self.NULL_LEAF: _inorder(node.left) result.append({\\"val\\": node.val, \\"color\\": node.color}) _inorder(node.right) _inorder(self.root) return result"},{"question":"# Euler\'s Totient Function Enhancement and Analysis Euler\'s Totient Function, ϕ(n), counts the number of integers from 1 to n that are coprime with n. Your task is to enhance the existing totient function algorithm for multiple queries and analyze its performance when handling arrays of queries. Problem Statement Write a function `enhanced_totient(n, queries)` that computes the Euler\'s Totient function values for multiple integers efficiently given a single integer n and a list of queries. # Specifications Input - `n` (1 ≤ n ≤ 10^6): an integer. - `queries`: List of integers [q1, q2,…,qk] where each qi (1 ≤ qi ≤ n) specifies the input for a ϕ function calculation. Output - A list of integers where the i-th integer is ϕ(queries[i]). # Constraints - Consider efficient ways to handle multiple queries to ensure optimized performance. - Provide time complexity analysis considering both preprocessing and querying phases. - Handle and test for edge cases, including when all queries request ϕ for n or small integers. # Example ```python # Example function call print(enhanced_totient(10**6, [1, 2, 3, 4, 10**6])) # Example output # Output might vary significantly based on actual values of n, but an example might be: # [1, 1, 2, 2, very large number] ``` # Hints - Consider precomputing the Euler Totient function values for all integers up to n using sieve-like techniques. - Use preprocessing results to answer each query in constant time.","solution":"def enhanced_totient(n, queries): Computes Euler\'s Totient function values for given queries efficiently. :param n: Integer upper limit for Euler\'s Totient function (1 ≤ n ≤ 10^6). :param queries: List of integers [q1, q2, ..., qk] where each qi (1 ≤ qi ≤ n). :return: List of integers where the i-th integer is ϕ(queries[i]). # Step 1: Precompute the Euler\'s Totient function for all integers from 1 to n totients = list(range(n + 1)) for i in range(2, n + 1): if totients[i] == i: # i is a prime for j in range(i, n + 1, i): totients[j] *= (i - 1) totients[j] //= i # Step 2: Resolve queries using precomputed totient values result = [totients[q] for q in queries] return result"},{"question":"Objective: Given an array of integers `nums` where exactly two elements appear only once and all other elements appear exactly twice, write a function to find and return the two elements that appear only once. The solution must achieve O(N) time complexity and O(1) space complexity. Function Signature: ```python def find_unique_numbers(nums: list[int]) -> list[int]: pass ``` Input: * `nums`: A list of integers, `nums`, with the constraints: * Length of nums is at least 2, and at most 10^4. * Exactly two elements in nums appear only once. * Every other element appears exactly twice. Output: * A list of two integers that are the unique elements in the array. Example: ```python assert find_unique_numbers([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] ``` Constraints: * The function should run in O(N) time. * The function should use O(1) extra space. Performance Requirements: * Ensure the solution handles large inputs efficiently and adheres to the given time and space complexity constraints. Scenario: Imagine you are given a large dataset where every other element is duplicated except for two outliers. Your task is to identify these outliers efficiently in a real-time system where performance is critical. **Hint**: Utilize the properties of XOR to segregate numbers into groups and isolate the two unique numbers.","solution":"def find_unique_numbers(nums: list[int]) -> list[int]: # Step 1: Perform XOR of all the elements. The result will be the XOR of the two unique numbers. xor_sum = 0 for num in nums: xor_sum ^= num # Step 2: Find any set bit in the xor_sum (we can use the rightmost set bit). rightmost_set_bit = xor_sum & -xor_sum # Step 3: Divide the numbers into two groups based on the rightmost_set_bit and XOR the numbers in each group. unique1, unique2 = 0, 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"You are given a string as input and required to delete any reoccurring character, leaving only the first occurrence of each character in the order they appeared. Write a function `delete_reoccurring_characters` that implements this logic. # Input Format - A single string `s`, consisting of lowercase and/or uppercase alphabets. # Output Format - A single string with duplicate characters removed, preserving the order of first occurrence. # Constraints - The length of the string `s` will not exceed 10^5. - The string will contain only English letters (both lowercase and uppercase). # Performance Requirement - The solution must execute in O(n) time complexity, where n is the length of the input string. - The solution must use at most O(n) extra space. # Example Example 1 **Input**: ``` \\"programming\\" ``` **Output**: ``` \\"progamin\\" ``` Example 2 **Input**: ``` \\"aabbcc\\" ``` **Output**: ``` \\"abc\\" ``` Example 3 **Input**: ``` \\"\\" ``` **Output**: ``` \\"\\" ``` # Implementation Implement the function `delete_reoccurring_characters(s: str) -> str`.","solution":"def delete_reoccurring_characters(s): Deletes reoccurring characters in the input string s. Only the first occurrence of each character is preserved. Parameters: s (str): The input string. Returns: str: A string with duplicate characters removed, preserving the order of first occurrence. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Queue Collision Avoidance in a Multi-Processing Environment Problem Statement You are tasked with designing a robust queue system that can be used in a multi-processing environment to handle tasks arriving at different rates and being processed at different rates. The queue must handle potential collisions, queue overflow, and task prioritization efficiently. Requirements 1. Implement a `PriorityQueue` class that supports the following operations: * `enqueue(item, priority)`: Adds an item with an associated priority to the queue. * `dequeue()`: Removes and returns the highest priority item from the queue. If multiple items have the same priority, it should follow the FIFO order. * `peek()`: Returns the highest priority item without removing it. * `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. * `size()`: Returns the number of items in the queue. 2. Your implementation should be optimized for performance, considering both time and space complexity. 3. Handle the case where the queue is empty gracefully, without throwing exceptions. Input/Output * **Input**: * `enqueue(item, priority)` where `item` is any data and `priority` is an integer (higher value means higher priority). * `dequeue()` and `peek()` come with no inputs. * **Output**: * `enqueue(item, priority)`: Returns nothing. * `dequeue()`: Returns the highest priority item. * `peek()`: Returns the highest priority item without removing it. * `is_empty()`: Returns a boolean indicating whether the queue is empty. * `size()`: Returns an integer indicating the number of items in the queue. Constraints * All items and priorities must be handled efficiently. * The system should be capable of managing up to `10^5` items in the queue at any given time. Example Scenario * Input: * `enqueue(\\"task1\\", 3)` * `enqueue(\\"task2\\", 1)` * `enqueue(\\"task3\\", 2)` * `dequeue()` * Output: * `task1` Task Implement the `PriorityQueue` class with the specified methods and ensure it handles edge cases as specified in the analysis.","solution":"import heapq from collections import deque class PriorityQueue: def __init__(self): self.heap = [] self.item_counter = 0 def enqueue(self, item, priority): Adds an item with an associated priority to the queue. heapq.heappush(self.heap, (-priority, self.item_counter, item)) self.item_counter += 1 def dequeue(self): Removes and returns the highest priority item from the queue. If multiple items have the same priority, it should follow the FIFO order. if self.is_empty(): return None return heapq.heappop(self.heap)[2] def peek(self): Returns the highest priority item without removing it. if self.is_empty(): return None return self.heap[0][2] def is_empty(self): Returns True if the queue is empty, False otherwise. return len(self.heap) == 0 def size(self): Returns the number of items in the queue. return len(self.heap)"},{"question":"# Question You are tasked with implementing a function to flatten nested lists iteratively, given potential complications with recursion depth in certain environments. The goal is to produce a flattened list without utilizing recursive function calls. Specifications: * **Input**: A list of possibly nested lists containing integers and/or other lists. * **Output**: A single-dimensional list with all nested integers. * **Constraints**: * Each nested level can be arbitrarily deep. * The input list may contain non-integer elements such as strings or other types. For the purpose of this task, you only need to flatten the list and preserve non-list elements as they appear. Function Signature: ```python def flatten_iteratively(nested_list: list) -> list: ``` Examples: ```python assert flatten_iteratively([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] assert flatten_iteratively([1, \'a\', [2, [\'b\', 3]], 4]) == [1, \'a\', 2, \'b\', 3, 4] assert flatten_iteratively([[[1, 2, []], 3], [[4]], 5]) == [1, 2, 3, 4, 5] ```","solution":"def flatten_iteratively(nested_list: list) -> list: Flatten a list of possibly nested lists iteratively. Args: nested_list (list): A list which may contain nested lists. Returns: list: A single-dimensional list with all nested integers and other elements. result = [] stack = nested_list[:] while stack: current = stack.pop(0) if isinstance(current, list): # Extend stack to handle the nested list stack = current + stack else: result.append(current) return result"},{"question":"# 2-SAT Solver Implementation You are provided with a code snippet for solving the 2-satisfiability (2-SAT) problem using graph algorithms. Based on the provided algorithm, create a function that verifies the solution correctness and adjusts it to handle input constraints in a more robust manner. Problem Description The 2-SAT problem asks if there exists an assignment of True/False values to variables that satisfies a given set of clauses, each containing exactly two literals. Your goal is to implement a function `solve_2_sat` which: 1. Takes an array of clauses where each clause is a tuple of two literals. 2. Returns a dictionary of variable assignments that satisfy all clauses, or returns `None` if no such assignment exists. Input * An array of tuples, where each tuple contains two literals. Example: `[((\'x\', False), (\'y\', False)), ((\'y\', True), (\'z\', False))]`. Each literal is represented as a tuple `(variable, is_negated)`, where: * `variable` is a string representing the variable name. * `is_negated` is a boolean indicating if the variable is negated. Output * A dictionary where keys are variable names and values are boolean assignments (`True` or `False`) satisfying all clauses, or `None` if no such assignment exists. Constraints * The algorithm should run in (O(V + E)) time, where (V) is the number of variables and (E) is the number of clauses. * Variables are case-sensitive strings without spaces and special characters. * Literals are only boolean negations (`not`). # Function Signature ```python def solve_2_sat(clauses): # Implements solution here ``` # Example ```python clauses = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] result = solve_2_sat(clauses) # Should print: # {\'x\': True, \'y\': True, \'a\': True, \'b\': True, \'c\': False} # or another valid assignment satisfying the formula ``` # Hints * Reuse the provided 2-SAT logic to solve the problem. * Make sure to handle cases where no solution exists.","solution":"def solve_2_sat(clauses): from collections import defaultdict, deque def tarjan_scc(n, adj): index = [-1] * (2 * n) lowlink = [-1] * (2 * n) on_stack = [False] * (2 * n) stack = [] sccs = [] current_index = 0 def strongconnect(v): nonlocal current_index index[v] = lowlink[v] = current_index current_index += 1 stack.append(v) on_stack[v] = True for w in adj[v]: if index[w] == -1: strongconnect(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: lowlink[v] = min(lowlink[v], index[w]) if lowlink[v] == index[v]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) for v in range(2 * n): if index[v] == -1: strongconnect(v) return sccs def variable_to_index(var): if var[1]: return 2 * int(var[0]) + 1 else: return 2 * int(var[0]) variables = set() for clause in clauses: for var in clause: variables.add(var[0]) variable_map = {var: idx for idx, var in enumerate(variables)} n = len(variable_map) adj = [[] for _ in range(2 * n)] for (var1, neg1), (var2, neg2) in clauses: idx1 = variable_map[var1] idx2 = variable_map[var2] adj[variable_to_index((idx1, not neg1))].append(variable_to_index((idx2, neg2))) adj[variable_to_index((idx2, not neg2))].append(variable_to_index((idx1, neg1))) sccs = tarjan_scc(n, adj) scc_id = [0] * (2 * n) for i, scc in enumerate(sccs): for node in scc: scc_id[node] = i assignment = {} for var, idx in variable_map.items(): if scc_id[2 * idx] == scc_id[2 * idx + 1]: return None assignment[var] = scc_id[2 * idx] < scc_id[2 * idx + 1] return assignment"},{"question":"# Question: You are provided with a training dataset represented as a dictionary where keys are tuples representing data points, and their corresponding values are the labels associated with them. Implement the `nearest_neighbor` function that takes a query vector and the training dataset to classify the query point based on the nearest neighbor algorithm. Function Signature: ```python def nearest_neighbor(x: tuple, tSet: dict) -> str: ``` # Input: * `x`: A tuple of floats representing the query vector. * `tSet`: A dictionary where keys are tuples of floats (vectors) and values are strings (class labels). # Output: * A string representing the class label of the nearest neighbor for the query vector. # Constraints: * All vectors (including the query vector) will be of the same non-zero length and contain only numerical values. * The training set will have at least one data point. * The `distance` function is already implemented and can be used within the `nearest_neighbor` function. # Example: ```python tSet = { (1.0, 2.0): \\"ClassA\\", (2.0, 3.0): \\"ClassB\\", (3.0, 4.0): \\"ClassA\\" } query_vector = (2.5, 3.5) print(nearest_neighbor(query_vector, tSet)) # Output: \\"ClassA\\" ``` # Note: Ensure your algorithm handles potential ties by returning the class label of the first found point with minimal distance.","solution":"import math def distance(v1, v2): Computes the Euclidean distance between two vectors v1 and v2. return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def nearest_neighbor(x: tuple, tSet: dict) -> str: Finds the nearest neighbor of the query vector \'x\' in the training set \'tSet\' and returns its associated class label. nearest_label = None min_distance = float(\'inf\') for point, label in tSet.items(): dist = distance(x, point) if dist < min_distance: min_distance = dist nearest_label = label return nearest_label"},{"question":"# Task: You are given a message encoded as a string of digits from \'0\' to \'9\'. The encoding follows the rules where \'A\' = 1, \'B\' = 2, ..., \'Z\' = 26. Your task is to determine the total number of ways to decode this message. # Function Signature: ```python def count_decodings(encoded_message: str) -> int: Determines the total number of ways to decode the given encoded message. :param encoded_message: A string representing the encoded message. :return: An integer representing the total number of ways to decode the message. ``` # Input: * A string `encoded_message` consisting of digits (\'0\'-\'9\') only, with a length of `n` where `1 <= n <= 100`. # Output: * Return an integer that represents the total number of ways to decode the encoded message. # Constraints: * The input string will not contain invalid characters and will be non-empty. # Performance Requirements: * Your solution should work efficiently with a time complexity of O(n) and a space complexity of O(1). # Context and Examples: 1. `encoded_message = \\"12\\"` There are two ways to decode this message: - \\"12\\" -> \\"L\\" - \\"1\\" \\"2\\" -> \\"A\\" \\"B\\" Output: `2` 2. `encoded_message = \\"226\\"` There are three ways to decode this message: - \\"2\\" \\"26\\" -> \\"B\\" \\"Z\\" - \\"2\\" \\"2\\" \\"6\\" -> \\"B\\" \\"B\\" \\"F\\" - \\"22\\" \\"6\\" -> \\"V\\" \\"F\\" Output: `3` 3. `encoded_message = \\"0\\"` There are no valid ways to decode this message since \'0\' is not a valid encoding. Output: `0` 4. `encoded_message = \\"06\\"` There are no valid ways to decode this message since it starts with \'0\'. Output: `0` # Notes: * Pay special attention to cases where \'0\' appears in the encoded message. * Consider using dynamic programming to track decoding counts effectively.","solution":"def count_decodings(encoded_message: str) -> int: Determines the total number of ways to decode the given encoded message. :param encoded_message: A string representing the encoded message. :return: An integer representing the total number of ways to decode the message. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) # Base cases dp[0] = 1 dp[1] = 1 # As long as the first character is not \'0\' for i in range(2, n + 1): # Single digit decode if encoded_message[i - 1] != \'0\': dp[i] += dp[i - 1] # Two digit decode two_digit = int(encoded_message[i - 2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given two one-dimensional lists of floating-point numbers. Your task is to implement a function `calculate_cosine_similarity` that calculates the cosine similarity between the two lists. Ensure that both lists have the same length and do not contain only zeroes in either list to prevent division by zero. # Function Signature ```python def calculate_cosine_similarity(vec1: list[float], vec2: list[float]) -> float: ``` # Input * `vec1`, `vec2`: Two one-dimensional lists of floats, each of the same length `n` (1 ≤ n ≤ 10^6). # Output * A float representing the cosine similarity between the two lists. # Constraints * The lists will have the same length. * The lists will contain at least one non-zero entry each to prevent division by zero errors. # Example ```python assert round(calculate_cosine_similarity([1.0, 1.0, 1.0], [1.0, 2.0, -1.0]), 10) == 0.4714045208 assert round(calculate_cosine_similarity([3.0, 4.0, 0.0], [2.0, 3.0, 1.0]), 10) == 0.9722718241 ``` # Detailed Description * Implement the function by first calculating the L2 distances of the input lists. * Compute the dot product of the two input lists. * Normalize the dot product by dividing it by the product of the L2 distances of both lists. # Notes * Be mindful of floating-point precision. * Consider utilizing libraries for efficient mathematical computations, but ensure to adhere to the constraints provided. * Write comprehensive test cases to cover edge/input cases and validate your implementation effectively.","solution":"import math def calculate_cosine_similarity(vec1: list[float], vec2: list[float]) -> float: Calculate the cosine similarity between two one-dimensional lists of floats. Parameters: vec1 (list of float): First vector vec2 (list of float): Second vector Returns: float: Cosine similarity between vec1 and vec2 if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"Vectors must not be zero vectors\\") return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"Given an array of integers, implement the Cocktail Shaker Sort algorithm to sort the array in ascending order. You should ensure the algorithm handles all possible edge cases efficiently and performs minimal swaps. # Requirements: * Implement the function `cocktail_shaker_sort(arr: List[int]) -> List[int]` * **Input**: A list of integers `arr` where 1 ≤ len(arr) ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9. * **Output**: A list of integers sorted in ascending order. # Constraints: * The solution should maintain O(N^2) time complexity in the worst case. * The algorithm must be implemented in-place without using additional storage. * Consider edge cases such as empty arrays, arrays with one element, and already sorted arrays. # Example: ```python assert cocktail_shaker_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([7]) == [7] assert cocktail_shaker_sort([3, -2, -1, 0, 4, 2, 1]) == [-2, -1, 0, 1, 2, 3, 4] ``` # Performance: * Ensure your code runs efficiently within the provided constraints for varying input sizes. # Notes: * Test your algorithm thoroughly to cover all edge cases, especially large datasets. * You are not allowed to use built-in sort functions.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts an array in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr # Already sorted or empty swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Palindrome Verification Using Deque You are provided multiple variations of palindrome-checking algorithms. Your task is to implement a function that confirms whether a given string is a palindrome, utilizing a deque for optimal time complexity. # Requirements: 1. **Function Name**: `is_palindrome_deque_optimized` 2. **Input**: A string `s` (0 <= len(s) <= 10^5) 3. **Output**: A boolean value indicating whether the input string is a palindrome. # Constraints: - Only alphanumeric characters should be considered. - Ignore case sensitivity. # Function Signature: ```python def is_palindrome_deque_optimized(s: str) -> bool: pass ``` # Example: 1. `is_palindrome_deque_optimized(\\"A man, a plan, a canal: Panama\\")` should return `True`. 2. `is_palindrome_deque_optimized(\\"race a car\\")` should return `False`. # Performance Requirements: - Time Complexity should be O(n), where n is the length of the string. - Space Complexity should be efficient considering the use of an additional data structure like `deque`. You are encouraged to handle edge cases properly (e.g., empty string, string with only non-alphanumeric characters).","solution":"from collections import deque def is_palindrome_deque_optimized(s: str) -> bool: Check if the given string is a palindrome ignoring case and non-alphanumeric characters. # Using deque for efficient popping from both ends d = deque() # Add only alphanumeric characters to the deque, and convert to lower case for char in s: if char.isalnum(): d.append(char.lower()) # Compare characters from both ends while len(d) > 1: if d.popleft() != d.pop(): return False return True"},{"question":"Implement a function that classifies a given input vector `x` by finding the simplest nearest neighbor in a provided training set. The training set is a dictionary where keys are tuples representing feature vectors, and values are the classes associated with these vectors. Function Signature ```python def classify_nearest_neighbor(x: tuple, tSet: dict) -> any: Classifies the input vector `x` using the nearest neighbor algorithm. Arguments: x (tuple): The input vector to be classified. tSet (dict): The training set where keys are feature vectors and values are their corresponding classes. Returns: any: The class of the nearest neighbor. ``` # Input - `x`: A tuple of numerical values representing the feature vector to be classified. - `tSet`: A dictionary where keys are tuples representing training feature vectors and values are their corresponding classes. You may assume all feature vectors (input `x` and keys in `tSet`) are of the same length. # Output - Returns the class (value) of the nearest neighbor (key) from the training set. # Constraints - The length of the feature vectors will not exceed 100. - The number of different feature vectors in the training set will not exceed 10,000. # Scenario and Context You are working on a simple classification problem where you have a set of data points along with their classes. Given a new data point, your task is to classify it based on the class of its nearest neighbor in the training set. # Example ```python tSet = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (4.0, 2.0): \'A\' } x = (3.0, 2.5) print(classify_nearest_neighbor(x, tSet)) # Output: \'B\' ``` # Notes - Ensure your code handles edge cases such as `x` exactly matching a key in `tSet`. - Implement the function using Euclidean distance to determine the nearest neighbor.","solution":"import math def classify_nearest_neighbor(x, tSet): Classifies the input vector `x` using the nearest neighbor algorithm. Arguments: x (tuple): The input vector to be classified. tSet (dict): The training set where keys are feature vectors and values are their corresponding classes. Returns: any: The class of the nearest neighbor. def euclidean_distance(v1, v2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) nearest_neighbor = None min_distance = float(\'inf\') for vector, cls in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_neighbor = cls return nearest_neighbor"},{"question":"# Context Your organization maintains a log of timestamps (in seconds) when events occur on a server. However, you need to identify periods (in seconds) when no events were recorded within a specified time range. # Task Write a function `find_missing_events` that identifies and returns the missing ranges of seconds where no events occurred, based on an input list of event timestamps (sorted in ascending order) and an inclusive time range `[low, high]`. # Input 1. `event_timestamps`: A list of integers representing event timestamps (sorted in ascending order). 2. `low`: An integer representing the start of the time range to be considered (inclusive). 3. `high`: An integer representing the end of the time range to be considered (inclusive). # Output - A list of tuples, each tuple representing a missing range of seconds (start and end, both inclusive) where no events occurred. # Constraints 1. All timestamps in the array are within the range `[low, high]`. 2. `low` <= `high` 3. The array may contain duplicates. # Example ```python def find_missing_events(event_timestamps, low, high): pass # Example 1 event_timestamps = [3, 5, 7, 9] low = 1 high = 10 # Expected output: [(1, 2), (4, 4), (6, 6), (8, 8), (10, 10)] # Example 2 event_timestamps = [1, 2, 3, 50] low = 1 high = 100 # Expected output: [(4, 49), (51, 100)] ``` # Notes - Ensure that the functions handle edge cases such as: - When `event_timestamps` is empty. - When `low` and `high` define a minimal range.","solution":"def find_missing_events(event_timestamps, low, high): Identifies and returns the missing ranges of seconds where no events occurred. Parameters: event_timestamps (list): List of integers representing event timestamps (sorted in ascending order). low (int): Start of the time range to be considered (inclusive). high (int): End of the time range to be considered (inclusive). Returns: list of tuples: List of missing ranges (start and end, both inclusive). missing_ranges = [] if not event_timestamps: return [(low, high)] if low <= high else [] # Check for gaps before the first event if low < event_timestamps[0]: missing_ranges.append((low, event_timestamps[0] - 1)) # Check for gaps between consecutive events for i in range(1, len(event_timestamps)): if event_timestamps[i] > event_timestamps[i - 1] + 1: missing_ranges.append((event_timestamps[i - 1] + 1, event_timestamps[i] - 1)) # Check for gaps after the last event if high > event_timestamps[-1]: missing_ranges.append((event_timestamps[-1] + 1, high)) return missing_ranges"},{"question":"# Flipping a Bit to Maximize 1s Context You are given a non-negative integer. In its binary representation, you can flip exactly one bit from 0 to 1. You need to determine the length of the longest sequence of 1s you could create by doing this single bit flip. Task Write a function `flip_bit_longest_seq(num: int) -> int` that takes a non-negative integer as input and returns the length of the longest sequence of continuous 1s that can be achieved by flipping exactly one bit from 0 to 1. Input * An integer `num` (0 <= num <= 2^31 - 1) which represents the non-negative input number. Output * An integer representing the length of the longest sequence of 1s possible by flipping exactly one bit in the binary representation of `num`. Constraints * The input integer `num` is within the range [0, 2^31 - 1], inclusive. Example * **Input**: `1775` (binary representation: `11011101111`) * **Output**: `8` (flip the 0 between the sequences of 4 and 3 1s to get `11011111111`) Requirements * Your solution should be efficient, ideally with a time complexity of O(b) where b is the number of bits in the input integer. The solution must also manage with O(1) additional space complexity. Implement the function to accurately identify and handle various edge cases, while optimizing performance as much as possible.","solution":"def flip_bit_longest_seq(num: int) -> int: if num == 0: return 1 # Flipping the only zero, we get a single one. current_length = 0 previous_length = 0 max_length = 1 # We can always have at least one \'1\' by flipping one bit while num != 0: if (num & 1) == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 # Update: zero found, flip it and calculate the length sequence previous_length = current_length if (num & 2) != 0 else 0 current_length = 0 # Update max length if needed max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"# Problem Scenario You are tasked with designing a vending machine pricing system. Customers can use coins of various denominations to purchase items, and you need to calculate how many different ways customers can pay for a given price using the available coins. For example, if an item costs 4 cents and the available coin denominations are [1, 2, 3], there are four ways to make the change: [1, 1, 1, 1], [1, 1, 2], [2, 2], and [1, 3]. # Function Signature Implement the following function: ```python def count_ways(coins: List[int], value: int) -> int: Calculate the number of different ways to make `value` using given `coins`. Parameters: coins (List[int]): List of coin denominations. value (int): The target amount to make with the coins. Returns: int: Number of different ways to make `value` using the given coins. ``` # Input 1. `coins` : List of integers representing the available coin denominations. (1 <= len(coins) <= 100, 1 <= coins[i] <= 100) 2. `value` : An integer representing the value for which we need to find the number of combinations. (0 <= value <= 1000) # Output - Returns an integer representing the number of different ways to make the given `value` using the provided coin denominations. # Constraints - Coins can be used multiple times. - All coin denominations are positive integers. - The order in which coins are used does not matter. # Performance Requirements - Ensure your solution is efficient with a time complexity of O(n * m) and space complexity of O(n). # Example ```python assert count_ways([1, 2, 3], 4) == 4 assert count_ways([2, 5, 3, 6], 10) == 5 assert count_ways([1, 2, 5], 0) == 1 # One way to create sum 0 (using no coins) ``` # Notes - Consider edge cases where `value` is 0. - The input list of `coins` will always be non-empty. - Ensure correct handling of smaller values particularly to confirm no off-by-one errors.","solution":"from typing import List def count_ways(coins: List[int], value: int) -> int: Calculate the number of different ways to make `value` using given `coins`. Parameters: coins (List[int]): List of coin denominations. value (int): The target amount to make with the coins. Returns: int: Number of different ways to make `value` using the given coins. # Create a list to store the ways to make change for each amount up to `value` dp = [0] * (value + 1) dp[0] = 1 # There\'s one way to make 0, which is to use no coins # Iterate over each coin to update the dp array for coin in coins: for amount in range(coin, value + 1): dp[amount] += dp[amount - coin] return dp[value]"},{"question":"You have been provided with a partial implementation of a Binary Search Tree (BST). Your task is to enhance this BST by adding a new method `delete(self, data)` for deleting a node with a specific value. Ensure you consider the following requirements and constraints: 1. **Input**: - An integer `data` which represents the value to be deleted from the BST. 2. **Output**: - Return `True` if the node was successfully deleted, `False` if the node with the given value does not exist. 3. **Constraints**: - The tree will contain unique values. - Maintain the order property of the BST after deletion. 4. **Performance Requirements**: - The time complexity should remain O(log N) for balanced trees. # Instructions 1. **Deletion Logic**: - If the node to be deleted is a leaf, simply remove it. - If the node has one child, replace it with its child. - If the node has two children, replace it with its inorder successor (smallest element in the right subtree) and delete the inorder successor. 2. **Edge Cases**: - Deleting a node from an empty tree. - Deleting the root node. - Deleting a node with one child. - Deleting a node with two children. Here is the `BST` class with the given implementations. You need to add the `delete()` method. ```python class BST(object): def __init__(self): self.root = None def get_root(self): return self.root def size(self): return self.recur_size(self.root) def recur_size(self, root): if root is None: return 0 else: return 1 + self.recur_size(root.left) + self.recur_size(root.right) def search(self, data): return self.recur_search(self.root, data) def recur_search(self, root, data): if root is None: return False if root.data == data: return True elif data > root.data: return self.recur_search(root.right, data) else: return self.recur_search(root.left, data) def insert(self, data): if self.root: return self.recur_insert(self.root, data) else: self.root = Node(data) return True def recur_insert(self, root, data): if root.data == data: return False elif data < root.data: if root.left: return self.recur_insert(root.left, data) else: root.left = Node(data) return True else: if root.right: return self.recur_insert(root.right, data) else: root.right = Node(data) return True def preorder(self, root): if root: print(str(root.data), end = \' \') self.preorder(root.left) self.preorder(root.right) def inorder(self, root): if root: self.inorder(root.left) print(str(root.data), end = \' \') self.inorder(root.right) def postorder(self, root): if root: self.postorder(root.left) self.postorder(root.right) print(str(root.data), end = \' \') class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None ``` # Example Given the BST, ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` * `delete(24)` should result in: ``` 10 / 6 15 / / 4 9 12 30 / / 7 20 / 18 ``` * `delete(6)` should result in: ``` 10 / 7 15 / / 4 9 12 30 / 20 / 18 ``` Write the `delete()` method to complete the BST implementation.","solution":"class BST(object): def __init__(self): self.root = None def get_root(self): return self.root def size(self): return self.recur_size(self.root) def recur_size(self, root): if root is None: return 0 else: return 1 + self.recur_size(root.left) + self.recur_size(root.right) def search(self, data): return self.recur_search(self.root, data) def recur_search(self, root, data): if root is None: return False if root.data == data: return True elif data > root.data: return self.recur_search(root.right, data) else: return self.recur_search(root.left, data) def insert(self, data): if self.root: return self.recur_insert(self.root, data) else: self.root = Node(data) return True def recur_insert(self, root, data): if root.data == data: return False elif data < root.data: if root.left: return self.recur_insert(root.left, data) else: root.left = Node(data) return True else: if root.right: return self.recur_insert(root.right, data) else: root.right = Node(data) return True def preorder(self, root): if root: print(str(root.data), end=\' \') self.preorder(root.left) self.preorder(root.right) def inorder(self, root): if root: self.inorder(root.left) print(str(root.data), end=\' \') self.inorder(root.right) def postorder(self, root): if root: self.postorder(root.left) self.postorder(root.right) print(str(root.data), end=\' \') def delete(self, data): self.root, deleted = self.recur_delete(self.root, data) return deleted def recur_delete(self, root, data): if root is None: return root, False if data < root.data: root.left, deleted = self.recur_delete(root.left, data) elif data > root.data: root.right, deleted = self.recur_delete(root.right, data) else: deleted = True if root.left is None: return root.right, deleted elif root.right is None: return root.left, deleted min_larger_node = self.get_min(root.right) root.data = min_larger_node.data root.right, _ = self.recur_delete(root.right, root.data) return root, deleted def get_min(self, root): while root.left is not None: root = root.left return root class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None"},{"question":"# Problem: Optimal Matrix Chain Multiplication You are given a sequence of matrices, and your goal is to determine the most efficient way to multiply these matrices together. The efficiency is measured by the minimum number of scalar multiplications needed. # Function Signature: ```python def optimal_matrix_chain_multiplication(dims: List[int]) -> Tuple[int, List[List[int]]]: ``` # Input: * `dims` (List[int]): A list where the `i-th` matrix has dimensions `dims[i-1] x dims[i]`. # Output: * Returns a tuple where: - The first element is the minimum number of multiplications needed. - The second element is a 2D list representing the optimal parenthesization of the matrix chain. # Constraints: * `2 <= len(dims) <= 100` # Performance Requirements: * Time Complexity: (O(n^3)) * Space Complexity: (O(n^2)) # Examples: Example 1: Input: `dims = [30, 35, 15, 5, 10, 20, 25]` Output: `(15125, [[0, 0, 0, 0, 0, 0, 0], [0, 0, 15750, 7875, 9375, 11875, 15125], [0, 0, 0, 2625, 4375, 7125, 10500], [0, 0, 0, 0, 750, 2500, 5375], [0, 0, 0, 0, 0, 1000, 3500], [0, 0, 0, 0, 0, 0, 5000], [0, 0, 0, 0, 0, 0, 0]])` # Note: *Matrix notation `Ai` implies a matrix with dimensions given by `dims[i-1] x dims[i]`. Write a function `optimal_matrix_chain_multiplication(dims: List[int]) -> Tuple[int, List[List[int]]]` to solve the problem.","solution":"from typing import List, Tuple def optimal_matrix_chain_multiplication(dims: List[int]) -> Tuple[int, List[List[int]]]: n = len(dims) - 1 m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i - 1] * dims[k] * dims[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s"},{"question":"# Binary Tree Inversion Challenge Scenario: You are tasked with inverting a binary tree. Inverting a binary tree involves swapping the left and right children of all nodes in the tree. Given the root of a binary tree, implement a function that inverts the tree and returns the new root. Detailed Requirements: * **Function Name**: `invertBinaryTree` * **Input**: A binary tree represented by its root node. The structure for a tree node is provided below. * **Output**: The root node of the inverted binary tree. Tree Node Structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Constraints: * The number of nodes in the tree is in the range [0, 1000]. * The values of the nodes are unique and are within the integer range. Example: **Input Tree:** ``` 4 / 2 7 / / 1 3 6 9 ``` **Output Tree:** ``` 4 / 7 2 / / 9 6 3 1 ``` Function Signature: ```python def invertBinaryTree(root: TreeNode) -> TreeNode: ``` Important Points: 1. Carefully handle edge cases such as an empty tree. 2. Ensure no nodes are lost during the inversion. 3. Aim for a time complexity of O(n) and a space complexity of O(h).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertBinaryTree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertBinaryTree(root.left) invertBinaryTree(root.right) return root"},{"question":"# Word Search II Given a grid of characters (board) and a list of words, implement a function `find_words` that returns a list of all words that can be formed by characters in the grid. Characters can be adjacent horizontally or vertically, but each cell in the grid can only be used once per word. The function should efficiently search for words using a Trie data structure combined with backtracking. Input * `board` (List[List[str]]): A 2D list representing the character grid (1 <= len(board), len(board[0]) <= 12). * `words` (List[str]): A list of words to search in the grid (1 <= len(words) <= 3 * 10^4 and 1 <= len(words[i]) <= 10). Output * `List[str]`: A list of words found in the grid. Constraints * Each word can only be found once. * The output list should not contain duplicate words. * Each word in the `words` list will only appear once. Performance Requirements * The solution should be efficient in terms of both time and space complexity to handle larger grids and word lists. Example ```python board = [ [\'o\', \'a\', \'a\', \'n\'], [\'e\', \'t\', \'a\', \'e\'], [\'i\', \'h\', \'k\', \'r\'], [\'i\', \'f\', \'l\', \'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # Expected output: [\\"oath\\", \\"eat\\"] ``` Implementation 1. Implement a function `find_words` which creates a Trie from the list of words. 2. Use backtracking to search the grid, checking each possible character path against the Trie. 3. Ensure to manage the used cells and backtrack appropriately to form paths. 4. Return the list of words found. ```python def find_words(board, words): def backtrack(board, i, j, trie, pre, used, result): if \'#\' in trie: result.add(pre) if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return if not used[i][j] and board[i][j] in trie: used[i][j] = True backtrack(board, i+1, j, trie[board[i][j]], pre+board[i][j], used, result) backtrack(board, i, j+1, trie[board[i][j]], pre+board[i][j], used, result) backtrack(board, i-1, j, trie[board[i][j]], pre+board[i][j], used, result) backtrack(board, i, j-1, trie[board[i][j]], pre+board[i][j], used, result) used[i][j] = False trie = {} for word in words: curr_trie = trie for char in word: if char not in curr_trie: curr_trie[char] = {} curr_trie = curr_trie[char] curr_trie[\'#\'] = \'#\' result = set() used = [[False]*len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): backtrack(board, i, j, trie, \'\', used, result) return list(result) ```","solution":"def find_words(board, words): def backtrack(board, i, j, trie, pre, used, result): if \'#\' in trie: result.add(pre) if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return if not used[i][j] and board[i][j] in trie: used[i][j] = True backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result) backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result) backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result) backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result) used[i][j] = False trie = {} for word in words: curr_trie = trie for char in word: if char not in curr_trie: curr_trie[char] = {} curr_trie = curr_trie[char] curr_trie[\'#\'] = \'#\' result = set() used = [[False] * len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): backtrack(board, i, j, trie, \'\', used, result) return list(result)"},{"question":"**Objective**: Implement a B-Tree with collaborative functionalities, handle edge cases, and ensure tree stability. Scenario Imagine you are designing a database management system that uses B-Trees for indexing large amounts of data. Your task is to implement a B-Tree with the following operations: insertion, deletion, search, and traversal. Task 1. Implement the `BTree` class with the following methods: * `insert_key(key: int)`: Insert key into the B-Tree. * `remove_key(key: int)`: Delete the key from the B-Tree. * `find(key: int) -> bool`: Return True if key is found, otherwise False. * `traverse_tree()`: Display all keys in B-Tree in ascending order. Expected Input & Output * Inputs: Positive integers for insertion and deletion. * Outputs: Traversal result, boolean for key search. * Constraints: * Assume all elements to be inserted are unique for simplicity. * The degree, `t` of the B-Tree should be ≥ 2. Performance Requirements Ensure that insertion, deletion, and search operations maintain an average time complexity of O(log n). Example ```python # Sample Usage btree = BTree(t_val=3) # Inserting keys into B-tree btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Traversing the B-tree btree.traverse_tree() # Finding a key assert btree.find(6) == True assert btree.find(15) == False # Removing a key btree.remove_key(6) btree.traverse_tree() ``` Ensure your implementation is robust to handle all edge cases outlined and preserves the integrity of the B-Tree structure.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, otherwise false self.keys = [] # List of keys in the node self.children = [] # List of child nodes class BTree: def __init__(self, t): self.t = t # Minimum degree self.root = BTreeNode(t, True) def traverse_tree(self, node=None, result=None): if node is None: node = self.root if result is None: result = [] for i in range(len(node.keys)): if not node.leaf: self.traverse_tree(node.children[i], result) result.append(node.keys[i]) if not node.leaf: self.traverse_tree(node.children[len(node.keys)], result) return result def find(self, key, node=None): if node is None: node = self.root i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: return True if node.leaf: return False return self.find(key, node.children[i]) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) temp.children.append(self.root) self.split_child(temp, 0) self.root = temp self._insert_non_full(temp, key) else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self.split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def remove_key(self, key): if not self.root: print(\\"The B-Tree is empty\\") return self._remove(self.root, key) if len(self.root.keys) == 0: temp = self.root if len(self.root.children) > 0: self.root = self.root.children[0] else: self.root = None del temp def _remove(self, node, key): t = self.t idx = self._find_key(node, key) if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: self._remove_from_non_leaf(node, idx) else: if node.leaf: return flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], key) else: self._remove(node.children[idx], key) def _remove_from_non_leaf(self, node, idx): key = node.keys[idx] if len(node.children[idx].keys) >= self.t: pred = self._get_pred(node, idx) node.keys[idx] = pred self._remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= self.t: succ = self._get_succ(node, idx) node.keys[idx] = succ self._remove(node.children[idx + 1], succ) else: self._merge(node, idx) self._remove(node.children[idx], key) def _get_pred(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_succ(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, idx): if idx != 0 and len(node.children[idx - 1].keys) >= self.t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= self.t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(idx) node.children.pop(idx + 1) def _find_key(self, node, key): for i, item in enumerate(node.keys): if key <= item: return i return len(node.keys)"},{"question":"Implement a function `insertion_sort_with_helper` that sorts an array of integers using the insertion sort algorithm. The function should use the provided `search_insert` method to determine the correct insertion index for each element effectively. Input - A list of integers `arr`. Output - A list of integers sorted in non-decreasing order. # Constraints - `1 <= len(arr) <= 10^3` - `-10^4 <= arr[i] <= 10^4` # Performance Requirements - The function must demonstrate a time complexity of O(n^2) due to the insertion sort algorithm. - Utilization of the `search_insert` helper ensures sub-arrays insertion operations happen in logarithmic time. # Example ```python input: [5, 2, 9, 1, 5, 6] output: [1, 2, 5, 5, 6, 9] input: [4, 3, 2, 10, 12, 1, 5, 6] output: [1, 2, 3, 4, 5, 6, 10, 12] ``` Scenario Imagine you are creating a library system where you need to organize books (represented by integer IDs) in non-decreasing order as they come in. To effectively sort new books, you decide to use the `insertion_sort_with_helper` method. Write this function to ensure books are always sorted. # Function Signature ```python def insertion_sort_with_helper(arr: List[int]) -> List[int]: # Your code here ```","solution":"from typing import List def search_insert(arr: List[int], target: int) -> int: A helper function that finds the index where the target should be inserted in the sorted subarray. Assuming `arr` is sorted in non-decreasing order up to the point of insertion. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid return left def insertion_sort_with_helper(arr: List[int]) -> List[int]: Sorts an array of integers using insertion sort algorithm with the assistance of search_insert. for i in range(1, len(arr)): current_value = arr[i] insert_pos = search_insert(arr[:i], current_value) arr = arr[:insert_pos] + [current_value] + arr[insert_pos:i] + arr[i+1:] return arr"},{"question":"# Shell Sort Implementation As a part of your data structure and algorithms coursework, you are required to implement the Shell Sort algorithm from scratch. Your implementation should take an unsorted list of integers and return it sorted in ascending order. Shell Sort is a generalized version of Insertion Sort and you need to ensure that your implementation reflects the usage of diminishing increment sorting. Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers which may be unsorted. The list will have no more than 10^4 elements. Output * A list of integers sorted in ascending order. Constraints * You must not use in-built sorting functions. * Optimize the code in terms of performance and memory usage. * Handle edge cases such as an already sorted array, arrays with duplicate numbers, and empty arrays efficiently. Example ```python Input: [12, 34, 54, 2, 3] Output: [2, 3, 12, 34, 54] Input: [5, 1, 4, 2, 8] Output: [1, 2, 4, 5, 8] ``` Use a gap sequence of your choice and explain why you chose that particular gap sequence in your solution commentary.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Performs Shell Sort on the input list and returns the sorted list. Parameters: arr (List[int]): The unsorted list of integers. Returns: List[int]: The sorted list of integers. n = len(arr) gap = n // 2 # Using Shell\'s original sequence: gap is halved each iteration. while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"You are provided with two functions implementing an algorithm to count the number of \'1\' bits in the binary representation of an unsigned integer. Your task is to implement another function that compares the performance (execution time) of these two functions for a series of test cases and reports which one is faster along with its running time. # Function Details * Function Name: `compare_performance` * Input: - `test_cases`: a list of unsigned integers (0 <= integer <= 2^32 - 1). * Output: - A tuple containing: 1. Name of the faster function as a string: `\'count_ones_recur\'` or `\'count_ones_iter\'`. 2. The average running time of that function across all test cases. # Constraints - All integers in the test cases list are non-negative and less than 2^32. - The list of test cases will have at least one integer. # Requirements - You **must** use the `time` module to measure the execution time of each function for the provided test cases. - Ensure that your timing mechanism captures execution time accurately. # Example ```python import time def count_ones_recur(n): if not n: return 0 return 1 + count_ones_recur(n & (n-1)) def count_ones_iter(n): count = 0 while n: n &= (n-1) count += 1 return count def compare_performance(test_cases): # Implement the function here return (\\"<faster_function_name>\\", <average_runtime>) # Example test test_cases = [3, 14, 31, 0, 1023] result = compare_performance(test_cases) print(result) ``` Expected Output A tuple where the first element is the name of the faster function and the second element is its average running time across all test cases. For example: ```python (\\"count_ones_iter\\", 1.23e-06) ``` (Not the actual value, just a format guide).","solution":"import time def count_ones_recur(n): if not n: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n): count = 0 while n: n &= (n - 1) count += 1 return count def compare_performance(test_cases): total_time_recur = 0.0 total_time_iter = 0.0 num_cases = len(test_cases) # Measure performance for count_ones_recur for tc in test_cases: start_time = time.time() count_ones_recur(tc) end_time = time.time() total_time_recur += (end_time - start_time) # Measure performance for count_ones_iter for tc in test_cases: start_time = time.time() count_ones_iter(tc) end_time = time.time() total_time_iter += (end_time - start_time) avg_time_recur = total_time_recur / num_cases avg_time_iter = total_time_iter / num_cases if avg_time_recur < avg_time_iter: return (\'count_ones_recur\', avg_time_recur) else: return (\'count_ones_iter\', avg_time_iter)"},{"question":"# Prime Number Identification Objective Determine if a given number ( n ) is a prime number or not. Primality can be crucial in various applications such as cryptography, numerical analysis, and algorithmic challenges. Function Description Write a function `is_prime(n: int) -> bool` that: 1. Returns **True** if the number ( n ) is a prime number. 2. Returns **False** otherwise. Input - A single integer ( n ) that can range from ( -10^9 ) to ( 10^9 ). Output - A boolean value indicating whether the given number ( n ) is prime. Constraints - The function needs to consider both positive and negative integers. - For negative numbers, 0, and 1, the function should always return False. # Performance Requirements Your solution should efficiently handle input sizes up to ( 10^9 ). Optimize for both time and space complexity where possible. # Example Scenarios ```python assert is_prime(29) == True assert is_prime(-17) == False assert is_prime(1) == False assert is_prime(97) == True assert is_prime(100) == False ``` Implement the function without using library functions that directly provide primality checks.","solution":"def is_prime(n: int) -> bool: Determine if a given number n is a prime number or not. Args: n (int): The number to check for primality. Returns: bool: True if the number is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Scenario You are tasked with implementing a fundamental part of a dynamic data management system that can efficiently handle frequent insertions, deletions, and lookups. This system underpins various high-performance applications, such as managing user sessions, storing hierarchical data, and supporting fast searches on dynamically changing datasets. # Task Design a `BinarySearchTree` class supporting the following operations: 1. **Insertion**: Insert a unique value into the BST. 2. **Search**: Check whether a given value exists in the BST. 3. **Deletion**: Remove a given value from the BST, if it exists. # Requirements 1. **Method Signatures**: ```python class BinarySearchTree: def __init__(self): pass def insert(self, val: int) -> None: pass def search(self, val: int) -> bool: pass def delete(self, val: int) -> None: pass ``` 2. **Input Format**: * For `insert` and `delete`: a single integer `val` (1 <= val <= 10^6). * For `search`: a single integer `val` (1 <= val <= 10^6). 3. **Output Format**: * `insert` and `delete`: No output. * `search`: Return `True` if `val` is found, otherwise `False`. 4. **Constraints**: * No duplicate values should be inserted into the BST. * If `val` to be deleted does not exist, the tree remains unchanged. 5. **Performance**: * Aim for O(log n) time complexity for average cases. # Example ```python bst = BinarySearchTree() # Insert nodes bst.insert(5) bst.insert(3) bst.insert(7) # Search nodes assert bst.search(5) == True assert bst.search(1) == False # Delete nodes bst.delete(5) assert bst.search(5) == False assert bst.search(3) == True ``` **Note**: Your implementation should handle edge cases gracefully, such as performing operations on an empty tree and deleting the root node.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if node.left: self._insert_recursive(node.left, val) else: node.left = TreeNode(val) elif val > node.val: if node.right: self._insert_recursive(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if not node: return False if val == node.val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val) def delete(self, val: int) -> None: self.root = self._delete_recursive(self.root, val) def _delete_recursive(self, node, val): if not node: return node if val < node.val: node.left = self._delete_recursive(node.left, val) elif val > node.val: node.right = self._delete_recursive(node.right, val) else: if not node.left: return node.right if not node.right: return node.left temp_val = self._find_min(node.right) node.val = temp_val node.right = self._delete_recursive(node.right, node.val) return node def _find_min(self, node): current = node while current.left: current = current.left return current.val"},{"question":"**Problem Statement**: You are given an input string `s` consisting of lowercase and uppercase letters. Your task is to write a function `remove_duplicate_characters` that removes any recurring characters and returns a new string, preserving only the first occurrence of each character. The function signature should be: ```python def remove_duplicate_characters(s: str) -> str: ``` # Input * A single string `s` of length `n` (1 ≤ n ≤ 10^5), which may include both lowercase and uppercase letters. # Output * A string containing only the first occurrence of each character from the original string, preserving their order. # Constraints * You should respect the case sensitivity of characters in the string. * The function should be optimized to run in linear time and use extra space proportionate to the input size. # Example ```python assert remove_duplicate_characters(\\"abracadabra\\") == \\"abrcd\\" assert remove_duplicate_characters(\\"google\\") == \\"gole\\" assert remove_duplicate_characters(\\"\\") == \\"\\" assert remove_duplicate_characters(\\"AaBbCc\\") == \\"AaBbCc\\" ``` # Explanation * For input \\"abracadabra\\", the function should return \\"abrcd\\" since the first occurrence of \'a\', \'b\', \'r\', \'c\', and \'d\' are kept and the subsequent occurrences are removed. * For input \\"google\\", the function should return \\"gole\\" as \'g\', \'o\', \'l\', and \'e\' appear first and are kept. * For input \\"AaBbCc\\", since case is respected, it returns the same string.","solution":"def remove_duplicate_characters(s: str) -> str: Removes duplicates characters from the string s, preserving the first occurrence of each character. seen = set() # A set to keep track of seen characters result = [] # A list to store characters of the result string for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Context:** You are given a problem where you need to determine the number of ways to decompose a given positive integer into a sum of non-negative integers in different sequences (where the order of addends matters). **Task:** Write a function `count_decompositions(n)` that computes the number of ways to decompose a given positive integer `n` into a sum of non-negative integers. **Function Signature:** ```python def count_decompositions(n: int) -> int: pass ``` **Input:** * An integer `n` (1 <= `n` <= 100). **Output:** * An integer representing the number of ways to decompose `n`. **Example:** ```python assert count_decompositions(4) == 5 assert count_decompositions(7) == 15 assert count_decompositions(1) == 1 ``` **Constraints:** * The integer `n` will always be positive and within the range given. **Performance Requirements:** * Your solution should run efficiently with a time and space complexity of O(n^2). **Hints:** * Consider using a dynamic programming approach to store intermediate results and build upon them to find the final count.","solution":"def count_decompositions(n: int) -> int: dp = [0] * (n + 1) dp[0] = 1 # There\'s only one way to decompose 0: using no numbers for i in range(1, n + 1): for j in range(i): dp[i] += dp[j] return dp[n]"},{"question":"You are tasked with implementing a function that removes all reoccurring characters from an input string and returns a new string containing only the first occurrence of each character, in the order they first appear. Your implementation should be optimized in terms of time complexity. # Function Signature ```python def remove_reoccurring_characters(s: str) -> str: pass ``` # Input * A string `s` containing a mix of ASCII characters: `s (0 <= len(s) <= 10^5)` # Output * A string that contains only the first occurrence of each character from the input string `s`. # Constraints * You must achieve a time complexity of (O(n)), where (n) is the length of the string `s`. # Examples ```python assert remove_reoccurring_characters(\\"\\") == \\"\\" assert remove_reoccurring_characters(\\"abcabc\\") == \\"abc\\" assert remove_reoccurring_characters(\\"google\\") == \\"gole\\" assert remove_reoccurring_characters(\\"aabbcc\\") == \\"abc\\" ``` # Additional Context This problem is useful for testing understanding of hashing mechanisms to maintain uniqueness and efficiency in processing. Appropriate handling of edge cases and performance considerations will be crucial for an optimal solution.","solution":"def remove_reoccurring_characters(s: str) -> str: seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario You are working as a software engineer in a company that frequently deals with matrix operations for their scientific computing workflows. One of the critical tasks is to invert matrices for various computational problems like solving linear systems. You need to ensure that the provided matrices are valid and invertible. # Task Write a function `invert_matrix(matrix)` that accepts a list of lists representing an n x n matrix and returns its inverse if possible. You should handle edge cases, including non-square matrices, matrices that have a determinant of zero (non-invertible), and trivial cases like empty matrices or single-element matrices. # Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` # Input * `matrix` (List[List[float]]): A 2D list where each sublist represents a row in an n x n matrix. Each element of the sublist is a float. # Output * (List[List[float]]): A 2D list representing the inverted matrix. If the matrix is not invertible, return `None`. # Constraints * The matrix will have at most dimensions of 100 x 100. * Elements of the matrix will be floating-point numbers. * Use fractional arithmetic where necessary to handle precision. # Examples ```python assert invert_matrix([[1, 2], [3, 4]]) == [[-2.0, 1.0], [1.5, -0.5]] assert invert_matrix([[0, 1], [1, 0]]) == [[0.0, 1.0], [1.0, 0.0]] assert invert_matrix([[1, 2, 3], [0, 1, 4], [5, 6, 0]]) == [[-24, 18, 5], [20, -15, -4], [-5, 4, 1]] assert invert_matrix([[1, 0], [0, 0]]) == None ``` # Performance Requirements Your solution should aim to complete within 1 second for the largest matrix size of 100 x 100. # Notes * Consider using helper functions to break down the steps mentioned in the algorithm analysis. * Ensure proper validation and error handling. * Provide additional test cases to comprehensively cover different scenarios, including edge cases and typical use cases.","solution":"from typing import List import copy def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: Inverts a given n x n matrix if it is invertible. :param matrix: List of Lists representing the n x n matrix. :return: The inverted matrix as a List of Lists or None if the matrix is not invertible. n = len(matrix) if n == 0 or n != len(matrix[0]): return None # Create the identity matrix identity = [[float(i == j) for i in range(n)] for j in range(n)] # Copy the matrix to avoid modifying the original mat = copy.deepcopy(matrix) for i in range(n): if mat[i][i] == 0: # Check for a row to swap for j in range(i + 1, n): if mat[j][i] != 0: mat[i], mat[j] = mat[j], mat[i] identity[i], identity[j] = identity[j], identity[i] break else: # No non-zero element found in this column return None # Scale the row to make the diagonal element 1 scale = mat[i][i] for j in range(n): mat[i][j] /= scale identity[i][j] /= scale # Eliminate the current column for all rows except the current one for j in range(n): if j != i: scale = mat[j][i] for k in range(n): mat[j][k] -= scale * mat[i][k] identity[j][k] -= scale * identity[i][k] return identity"},{"question":"**Context:** In a hypothetical sequence formed by concatenating all positive integers (i.e., \\"1234567891011121314...\\"), you are asked to find what the n-th digit in the sequence is. For example, the 1st digit is \'1\', the 10th digit is \'1\' (from the number 10), and the 15th digit is \'2\' (from the number 12). **Problem Statement:** Implement a function `find_nth_digit(n)` that takes a positive integer `n` as input and returns the n-th digit in this sequence. **Function Signature:** ```python def find_nth_digit(n: int) -> int: pass ``` **Input:** - `n` (1 ≤ n ≤ 2 * 10^9): The position of the digit to find. **Output:** - Return the n-th digit as an integer. **Constraints:** - The sequence always starts from 1 and goes through all positive integers in a natural order. - The function should be efficient and handle large values of `n` within reasonable time limits. **Examples:** 1. `find_nth_digit(1)` -> 1 2. `find_nth_digit(10)` -> 1 (The sequence looks like \\"1234567891011...\\", and the 10th digit is the first \'1\' in \\"10\\"). 3. `find_nth_digit(15)` -> 2 (The sequence looks like \\"123456789101112131415...\\", and the 15th digit is \'2\' in \\"12\\"). **Edge Cases to Consider:** - Transitions from single to double-digit numbers (e.g., n = 9, 10). - Transitions from double to triple-digit numbers (e.g., n = 189, 190). - Very large values of n within the allowed range.","solution":"def find_nth_digit(n: int) -> int: Returns the n-th digit in the sequence formed by concatenating all positive integers. # Initialize variables length = 1 # length of the numbers being considered count = 9 # count of numbers with the current length start = 1 # starting number of the current length # Determine the length of the number that contains the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit start += (n - 1) // length s = str(start) # Find the digit within the number return int(s[(n - 1) % length])"},{"question":"# Scenario You are tasked with optimizing sequences in a binary data stream. Specifically, you need to identify the best position in the data to flip a zero to one to maximize the longest consecutive sequence of ones. # Task Write a Python function `max_ones_index(arr: List[int]) -> int` that takes as input a binary array, `arr`, consisting of 0s and 1s and returns the index of the zero that can be replaced to obtain the longest continuous sequence of ones. If there are no zeros in the array, return -1. # Input - `arr`: A list of integers (0s and 1s). # Output - An integer representing the index of the zero to be replaced to achieve the longest sequence of ones. If no zeros are present, return -1. # Constraints - 1 <= len(arr) <= 10^6 # Performance Requirements - Time Complexity: O(n) - Space Complexity: O(1) # Example ```python assert max_ones_index([1, 1, 1, 0, 1, 1, 1]) == 3 assert max_ones_index([1, 1, 1]) == -1 ``` # Notes - Consider edge cases such as no zeroes, a single element in the array, and spread out zeros. - Your function should handle large inputs efficiently within the given constraints.","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: # Return -1 if there are no zeros in the array if 0 not in arr: return -1 max_count = 0 max_index = -1 current_count = 0 previous_zero_index = -1 previous_count = 0 for i in range(len(arr)): if arr[i] == 1: current_count += 1 else: # Calculate total ones by including the zero at index i if previous_zero_index != -1: total_ones = previous_count + current_count + 1 if total_ones > max_count: max_count = total_ones max_index = previous_zero_index # Update counts and previous zero index previous_count = current_count previous_zero_index = i current_count = 0 # Final check after exiting loop in case the best zero is at the last sequence of zero if previous_zero_index != -1: total_ones = previous_count + current_count + 1 if total_ones > max_count: max_index = previous_zero_index return max_index"},{"question":"You are given an array of integers `nums` in which exactly two elements appear only once, and all the other elements appear exactly twice. Write a function to find the two elements that appear only once. # Function Signature ```python def find_single_numbers(nums: List[int]) -> List[int]: pass ``` # Input * `nums`: a list of integers where exactly two elements appear only once, and all other elements appear exactly twice. The length of `nums` will be at least 2. # Output * Return a list containing the two elements that appear only once. The order of the result does not matter. # Constraints * Your algorithm should run in linear time, O(N). * You should use a constant amount of extra space, O(1). # Example ```python assert find_single_numbers([1, 2, 1, 3, 2, 5]) == [3, 5] or find_single_numbers([1, 2, 1, 3, 2, 5]) == [5, 3] assert find_single_numbers([4, 1, 2, 1, 2, 3]) == [3, 4] or find_single_numbers([4, 1, 2, 1, 2, 3]) == [4, 3] ``` # Detailed Explanation 1. XOR all elements in `nums` to isolate the XOR of the two unique numbers, say `a` and `b`, where `x = a ^ b`. 2. Find the rightmost set bit in `x` to use as a pivot to partition the array into two groups. Each group will contain one unique number and pairs. 3. XOR elements in each group. One group will produce `a`, and the other group will produce `b`. # Hints * Remember that XOR of a number with itself is 0 and with 0 is the number itself. * Utilize the properties of XOR and bitwise operations to achieve an efficient solution.","solution":"from typing import List def find_single_numbers(nums: List[int]) -> List[int]: # Step 1: XOR all the elements to get the combined XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find the rightmost set bit in xor_all rightmost_set_bit = xor_all & -xor_all # Step 3: Divide elements into two groups and XOR separately num1, num2 = 0, 0 for num in nums: if (num & rightmost_set_bit) == 0: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Reversing Strings: Algorithm Implementation Scenario: You are tasked with developing a function to reverse a given string. The function should be highly efficient and cater to various scenarios, including handling edge cases, optimizing performance, and avoiding common pitfalls like high memory usage or excessive execution time. Task: Implement a function `reverse_string(s: str) -> str` that reverses the input string `s`. Ensure your function is efficient and handles edge cases effectively. Requirements: - You should avoid using slicing (i.e., `[::-1]`) or the `reversed` function. - Your solution must be optimized for performance, both in terms of time and space complexity. - Consider edge cases such as empty strings and single-character strings. Input/Output: - **Input**: A single string `s` of length `n` (0 ≤ n ≤ 10^5). - **Output**: A new string which is the reverse of `s`. Constraints: - The function should handle very large strings efficiently. - The use of in-place techniques is encouraged to minimize space usage. Example: ```python def reverse_string(s: str) -> str: # Your implementation here pass # Example cases print(reverse_string(\\"hello\\")) # Output: \\"olleh\\" print(reverse_string(\\"\\")) # Output: \\"\\" print(reverse_string(\\"a\\")) # Output: \\"a\\" print(reverse_string(\\"Pythonic\\")) # Output: \\"cinothyP\\" ``` Performance Requirements: - Aim for a time complexity of ( O(n) ). - Aim for a space complexity of ( O(1) ) additional space.","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string s. # Convert the string to a list to enable in-place swap str_list = list(s) left, right = 0, len(str_list) - 1 # Swap characters from both ends of the list moving towards the center while left < right: # Swap characters str_list[left], str_list[right] = str_list[right], str_list[left] left += 1 right -= 1 # Convert the list back to a string and return return \'\'.join(str_list)"},{"question":"Optimal Graph Pathfinding Context You are working on a logistics software that needs to find the most efficient paths for delivery trucks to travel between warehouse nodes. You\'ve been provided with a list of nodes and connections representing routes between them. Objective Implement three distinct functions to find paths between two nodes in a directed graph: 1. `find_path`: Find any path between two nodes. 2. `find_all_paths`: Find all possible paths between two nodes. 3. `find_shortest_path`: Find the shortest path between two nodes using optimization techniques. Requirements * Input: - `graph`: A dictionary where each key is a node, and its value is a list of nodes it connects to. - `start`: The starting node (string). - `end`: The end node (string). * Outputs: - `find_path` returns a list representing a path from start to end (any valid path), or `None` if no path exists. - `find_all_paths` returns a list of lists, where each inner list is a valid path from start to end. - `find_shortest_path` returns a list representing the shortest path, or `None` if no path exists. * Constraints: - The graph is directed and may contain cycles. - Nodes are represented as strings. - Assume all edges have equal weight. * Performance: - Optimize the `find_shortest_path` function to avoid excessive computation time and space usage. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start = \'A\' end = \'F\' print(find_path(graph, start, end)) # Possible Output: [\'A\', \'C\', \'F\'] print(find_all_paths(graph, start, end)) # Expected Output: [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] print(find_shortest_path(graph, start, end)) # Expected Output: [\'A\', \'C\', \'F\'] ``` Implement the functions considering the given guidelines and constraints.","solution":"def find_path(graph, start, end, path=[]): path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths from collections import deque def find_shortest_path(graph, start, end): if start == end: return [start] if start not in graph: return None queue = deque([(start, [start])]) # Stores (current_node, path_to_current) while queue: (node, path) = queue.popleft() for next_node in graph.get(node, []): if next_node not in path: if next_node == end: return path + [next_node] else: queue.append((next_node, path + [next_node])) return None"},{"question":"# Scenario A telecommunication company wants to efficiently maintain and process the transmission data represented in binary format. One task they frequently perform is to determine the number of active signals (represented by \'1\' bits) in the data packets\' binary representation. They need an efficient algorithm to count the number of \'1\' bits in a given unsigned integer. # Problem Statement Write a function `count_active_signals(n: int) -> int` that takes an unsigned integer `n` and returns the number of \'1\' bits it has. Utilize the efficient bit manipulation technique provided by Brian Kernighan\'s Algorithm. # Input * An unsigned integer `n` (0 <= n <= 2^32 - 1). # Output * An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints * You should aim to have the solution with O(k) time complexity where k is the number of \'1\' bits in the binary representation of `n`. * The solution should be implemented using an iterative approach to avoid any potential stack overflow issues with recursion. # Example ```python assert count_active_signals(11) == 3 # binary 00000000000000000000000000001011 assert count_active_signals(128) == 1 # binary 00000000000000000000000010000000 assert count_active_signals(7) == 3 # binary 00000000000000000000000000000111 ``` # Implementation Implement the function using Brian Kernighan\'s Algorithm iteratively.","solution":"def count_active_signals(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given unsigned integer n. count = 0 while n: n &= (n - 1) # This operation reduces the number of \'1\' bits by one in each iteration count += 1 return count"},{"question":"# Binary Heap Operations Given a class `BinaryHeap` that implements a min binary heap, implement the following new methods: 1. **merge_heaps**: Given another binary heap, merge it into the current heap and restore the heap property. 2. **k_smallest_elements**: Given an integer `k`, return the `k` smallest elements from the heap without removing them. Input Formats - For `merge_heaps(heap2)`: `heap2` is an instance of `BinaryHeap` that contains the heap to merge. - For `k_smallest_elements(k)`: `k` is an integer specifying the number of smallest elements to return. Output Formats - `merge_heaps`: None (modifies the heap in place) - `k_smallest_elements`: A list of `k` smallest elements (in ascending order). Constraints - You may assume that: * The `k` value provided will be such that `1 <= k <= current_size`. * Both heaps do not contain duplicate elements. - Expected time complexity should remain efficient (O((M+N) log (M+N)) for merging where M, N are the sizes of the two heaps, and O(k log N) for retrieving k smallest elements). Example ```python heap1 = BinaryHeap() heap1.insert(3) heap1.insert(8) heap1.insert(5) heap2 = BinaryHeap() heap2.insert(4) heap2.insert(10) heap2.insert(6) heap1.merge_heaps(heap2) # The heap1 should be modified to include elements from both heaps `[3, 4, 5, 8, 10, 6]` result = heap1.k_smallest_elements(3) # result should be [3, 4, 5] as these are the 3 smallest elements in the heap ``` *Note*: For simplicity, assume the `BinaryHeap` class and its methods (such as `insert` and `remove_min`) are already implemented and provided.","solution":"class BinaryHeap: def __init__(self): self.heap_list = [] self.current_size = 0 def insert(self, item): self.heap_list.append(item) self.current_size += 1 self._perc_up(self.current_size - 1) def _perc_up(self, i): while (i - 1) // 2 >= 0: parent_idx = (i - 1) // 2 if self.heap_list[i] < self.heap_list[parent_idx]: self.heap_list[i], self.heap_list[parent_idx] = self.heap_list[parent_idx], self.heap_list[i] i = parent_idx def _perc_down(self, i): while (2 * i + 1) < self.current_size: min_child_idx = self._min_child(i) if self.heap_list[i] > self.heap_list[min_child_idx]: self.heap_list[i], self.heap_list[min_child_idx] = self.heap_list[min_child_idx], self.heap_list[i] i = min_child_idx def _min_child(self, i): if (2 * i + 2) >= self.current_size: return 2 * i + 1 else: if self.heap_list[2 * i + 1] < self.heap_list[2 * i + 2]: return 2 * i + 1 else: return 2 * i + 2 def remove_min(self): if len(self.heap_list) == 0: return None min_item = self.heap_list[0] self.heap_list[0] = self.heap_list[self.current_size - 1] self.current_size -= 1 self.heap_list.pop() self._perc_down(0) return min_item def merge_heaps(self, heap2): for item in heap2.heap_list: self.insert(item) def k_smallest_elements(self, k): result = [] copy_heap = BinaryHeap() copy_heap.heap_list = self.heap_list[:] copy_heap.current_size = self.current_size for _ in range(k): result.append(copy_heap.remove_min()) return result"},{"question":"# **Coding Assessment Question** Design a function that converts an integer to its Roman numeral representation. The Roman numerals should follow the standard rules of numeral formation based on the integer\'s place value (units, tens, hundreds, thousands). Function Signature ```python def int_to_roman(num: int) -> str: pass ``` # **Requirements** 1. **Input**: * An integer `num` in the range 1 to 3999 (inclusive). 2. **Output**: * A string representing the Roman numeral equivalent of the integer. # **Constraints** * The integer is guaranteed to be within the range from 1 to 3999. * The Roman numerals should follow standard conventions, where: * 1 -> I * 5 -> V * 10 -> X * 50 -> L * 100 -> C * 500 -> D * 1000 -> M * 4 -> IV (not IIII) * 9 -> IX (not VIIII), etc. Example ```python # Example 1 num = 58 # Output: \\"LVIII\\" # Explanation: L = 50, V = 5, III = 3 thus LVIII # Example 2 num = 1994 # Output: \\"MCMXCIV\\" # Explanation: M = 1000, CM = 900, XC = 90, IV = 4 thus MCMXCIV ``` # **Scenario** Romans developed this numeral system where letters have distinct values and were combined following specific rules. For example, while building a historical application that displays years in Roman format, you need to ensure conversion handles all possible edge cases: 1. Validate if the input falls within the permissible range. 2. Carefully build the Roman numeral string from predefined segments. # **Performance Requirements** * Ensure your function runs efficiently within O(1) complexity for the supported data range (1 to 3999). * Minimal auxiliary space should be used, maintaining O(1) space complexity. Implement the function, ensuring it meets the criteria of correctness, performance, and handle crucial edge cases seamlessly.","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"Efficient Fibonacci Calculation **Objective**: Design and implement an optimized approach to compute the n-th Fibonacci number, leveraging the benefits of both iterative and dynamic programming strategies. # Problem Statement: In mathematics, the Fibonacci sequence is a series where the next term is the sum of the two preceding ones, starting from 0 and 1. Specifically: * F(0) = 0 * F(1) = 1 * F(n) = F(n-1) + F(n-2) Given an integer n (0 <= n <= 10^6), compute the n-th Fibonacci number. Due to the potentially large size of Fibonacci numbers, ensure your solution is both time and space efficient. # Requirements: * Your algorithm must run in O(n) time complexity. * It must use O(1) space complexity. * Handle large values efficiently, optimizing to avoid integer overflow where applicable. # Function Signature: ```python def optimized_fibonacci(n: int) -> int: pass ``` # Examples: ```python assert optimized_fibonacci(0) == 0 assert optimized_fibonacci(1) == 1 assert optimized_fibonacci(10) == 55 assert optimized_fibonacci(50) == 12586269025 # Large value test assert optimized_fibonacci(1000000) # Should run efficiently within time constraints ``` # Constraints: * Time Complexity: O(n) * Space Complexity: O(1) * Input: 0 <= n <= 10^6 * Output: Integer representing the n-th Fibonacci number. Create an efficient algorithm to compute the n-th Fibonacci number that meets the above constraints, and ensure it performs well even for the upper limit of input size.","solution":"def optimized_fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"**Context**: You\'re working on a text processing tool that needs to determine if a given string matches a specific pattern based on unique substring mappings. The tool should assess whether the pattern and string follow the same structure, with each character in the pattern uniquely mapping to a non-empty substring in the string and vice versa. **Objective**: Implement a function `pattern_match(pattern, string)` to determine if the given string follows the same pattern. **Function Signature**: ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` **Input**: * **pattern**: A string containing only lowercase letters (1 <= len(pattern) <= 100). It represents the pattern with each character mapping to a unique substring. * **string**: A string containing only lowercase letters (1 <= len(string) <= 1000). It represents the actual text to be checked against the pattern. **Output**: * A boolean value `True` if the string follows the pattern, otherwise `False`. **Constraints**: * Both `pattern` and `string` are non-empty and composed of lowercase letters. * No two characters in the pattern map to the same substring. * Each character in the pattern must map to exactly one non-empty, unique substring in the string. **Examples**: 1. `pattern = \\"abab\\"`, `string = \\"redblueredblue\\"` should return `True`. 2. `pattern = \\"aaaa\\"`, `string = \\"asdasdasdasd\\"` should return `True`. 3. `pattern = \\"aabb\\"`, `string = \\"xyzabcxzyabc\\"` should return `False`. **Notes**: * Consider edge cases like an empty pattern or string, and ensure the mapping strictly maintains uniqueness and completeness. * Analyze and optimize recursive calls to avoid performance bottlenecks.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(pattern, string, p_to_s, s_to_p): if not pattern: return not string char_p = pattern[0] if char_p in p_to_s: word = p_to_s[char_p] if string.startswith(word): return backtrack(pattern[1:], string[len(word):], p_to_s, s_to_p) else: return False for end in range(1, len(string) - len(pattern) + 2): # substring length can\'t exceed remaining length of string-pattern word = string[:end] if word in s_to_p: continue p_to_s[char_p] = word s_to_p[word] = char_p if backtrack(pattern[1:], string[end:], p_to_s, s_to_p): return True del p_to_s[char_p] del s_to_p[word] return False return backtrack(pattern, string, {}, {})"},{"question":"You are tasked with implementing a custom sorting function for a dataset that frequently contains duplicate values and requires the preservation of the original order of those duplicates. This sorting is critical for maintaining the data\'s integrity in a large-scale distributed system. **Function Definition**: ```python def custom_merge_sort(arr): Sorts an array while maintaining the relative order of equal elements. This function should use the Merge Sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list. ``` # Input: - A list of integers `arr` where 1 ≤ len(arr) ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9. # Output: - A sorted list with the relative order of duplicate elements preserved. # Constraints: - The function should utilize the merge sort algorithm. - The solution should be efficient in terms of time complexity (O(n log n)) and should not exceed the space complexity of O(n). # Example: ```python custom_merge_sort([3,2,1,4,2,3]) ``` Output: ```python [1, 2, 2, 3, 3, 4] ``` # Performance Requirements: Your implementation should handle large inputs efficiently within the specified constraints. Proper attention to edge cases like arrays with one or few elements, and arrays with duplicate and negative values, is necessary.","solution":"def custom_merge_sort(arr): Sorts an array while maintaining the relative order of equal elements. This function uses the Merge Sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list. if len(arr) <= 1: return arr # Divide the array into two halves mid = len(arr) // 2 left_half = custom_merge_sort(arr[:mid]) right_half = custom_merge_sort(arr[mid:]) # Merge the two halves return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list while maintaining the order of equal elements. Args: left (List[int]): The sorted left half. right (List[int]): The sorted right half. Returns: List[int]: Merged and sorted list. merged = [] left_index = 0 right_index = 0 # Merge the lists while maintaining stable sort order while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # If there are remaining elements in the left half, add them to the merged list if left_index < len(left): merged.extend(left[left_index:]) # If there are remaining elements in the right half, add them to the merged list if right_index < len(right): merged.extend(right[right_index:]) return merged"},{"question":"You are required to implement a function to add two integers using bitwise operations. This function should mimic the behavior of the arithmetic \'+\' operator but must not use it. # Function Signature ```python def add_two_numbers(a: int, b: int) -> int: pass ``` # Input * Two integers `a` and `b` (0 ≤ a, b ≤ 10^9). # Output * An integer which is the sum of `a` and `b`. # Constraints * Do not use the \'+\' operator in your implementation. * You may use bitwise and other fundamental operations. # Examples Example 1 ```python a = 2 b = 3 add_two_numbers(a, b) # Output: 5 ``` Example 2 ```python a = 10 b = 25 add_two_numbers(a, b) # Output: 35 ``` # Performance Requirements * Your implementation should handle the edge cases efficiently. * Aim for a time complexity of O(n) where n is the number of bits in the numbers. # Scenario Imagine you are working in a low-level embedded system where using the \'+\' operator is not feasible due to hardware constraints. You need to implement a bitwise addition function to compute the sum of two integers effectively.","solution":"def add_two_numbers(a: int, b: int) -> int: Returns the sum of a and b using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"Constructing and Traversing a Binary Search Tree Context: You have been hired by a company to ensure that its data retrieval process runs efficiently. They store data in a hierarchical format, and you suggest using a Binary Search Tree (BST) to manage this data. Your task is to implement core functionalities of the BST including insertion, searching, size calculation, and different types of tree traversals. Task: Implement a `BinarySearchTree` class with the following methods: 1. **Insert**: Insert a new element into the BST. 2. **Search**: Search for an element in the BST. 3. **Size**: Return the total number of elements in the BST. 4. **Preorder Traversal**: Return a list of elements in preorder traversal. 5. **Inorder Traversal**: Return a list of elements in inorder traversal. 6. **Postorder Traversal**: Return a list of elements in postorder traversal. Example: ```python class BinarySearchTree: # Add your methods here # Example usage: tree = BinarySearchTree() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) assert tree.size() == 11 assert tree.search(24) == True assert tree.search(50) == False assert tree.preorder() == [10, 6, 4, 9, 7, 15, 12, 24, 20, 18, 30] assert tree.inorder() == [4, 6, 7, 9, 10, 12, 15, 18, 20, 24, 30] assert tree.postorder() == [4, 7, 9, 6, 12, 18, 20, 30, 24, 15, 10] ``` Requirements: * You must implement the insert, search, size, and traversal methods from scratch. * Each method should be properly tested to ensure correctness. Constraints: * The input elements for insertions are unique integers for simplicity. * Performance requirement: Ensure search and insert operations can handle up to 10^4 unique elements efficiently.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None self._size = 0 def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) self._size += 1 def _insert(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None or node.key == key: return node is not None if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def size(self): return self._size def preorder(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node: result.append(node.key) self._preorder(node.left, result) self._preorder(node.right, result) def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.key) self._inorder(node.right, result) def postorder(self): result = [] self._postorder(self.root, result) return result def _postorder(self, node, result): if node: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.key)"},{"question":"# Task Write a function to subtract two integers without using the \'-\' operator. Your function should utilize bitwise operations to achieve this. # Objectives Demonstrate your understanding of bitwise operations and binary arithmetic by implementing the subtraction function. # Requirements 1. **Function Signature**: `def subtract_bitwise_operator(a: int, b: int) -> int:` 2. **Input**: - `a` (int): The minuend (can be positive, negative or zero). - `b` (int): The subtrahend (can be positive, negative or zero). 3. **Output**: - Return the result of `a - b`. # Constraints - Do not use the \'-\' operator directly. - Handle edge cases such as zero values, large numbers, and negative results. - Aim for an efficient solution in terms of both time and space complexity. # Example ```python assert subtract_bitwise_operator(10, 5) == 5 assert subtract_bitwise_operator(15, 20) == -5 assert subtract_bitwise_operator(0, 5) == -5 assert subtract_bitwise_operator(10, -5) == 15 assert subtract_bitwise_operator(-10, -5) == -5 ``` # Hints 1. Remember that subtraction can be rephrased as addition by converting the subtrahend to its two’s complement. 2. Use the bitwise addition technique shown in the provided code snippet with a few modifications.","solution":"def subtract_bitwise_operator(a: int, b: int) -> int: Subtracts two integers without using the \'-\' operator. Uses bitwise operations to achieve this. # To subtract b from a, we need to add the two\'s complement of b to a. # Two\'s complement of b: ~b + 1 MAX = 0xFFFFFFFF MIN = 0x80000000 # MSB set for a 32-bit integer MASK = 0x100000000 # Helper for limiting results to 32-bit while b != 0: borrow = (~a) & b a = (a ^ b) & MAX b = (borrow << 1) & MAX if a & MIN: a -= MASK return a"},{"question":"# Strobogrammatic Number Challenge # Objective Write a Python function that generates all strobogrammatic numbers of length `n` and another function that counts how many strobogrammatic numbers exist within a given range `[low, high]`. # Function Specifications 1. `gen_strobogrammatic(n: int) -> List[str]` - **Input**: An integer `n` representing the number length. - **Output**: A list of strings where each string is an `n`-length strobogrammatic number. 2. `strobogrammatic_in_range(low: str, high: str) -> int` - **Input**: Two strings `low` and `high` representing the bounds of the range. - **Output**: An integer count of strobogrammatic numbers within this range (inclusive). # Constraints - `1 <= n <= 14` - `1 <= len(low) <= 14` - `1 <= len(high) <= 14` - Guaranteed that `low` and `high` are valid numerical strings and `low` ≤ `high`. # Example ```python # Example 1 n = 2 # should return [\\"11\\",\\"69\\",\\"88\\",\\"96\\"] print(gen_strobogrammatic(2)) # Example 2 low = \\"50\\" high = \\"100\\" # should return 3 (69, 88, 96) print(strobogrammatic_in_range(\\"50\\", \\"100\\")) ``` # Notes - Ensure your code handles edge cases, including but not limited to single-digit lengths and bounds at the extrema of length constraints. - Consider performance implications, particularly for the `strobogrammatic_in_range` function where you need to handle potentially large ranges.","solution":"def gen_strobogrammatic(n): Generate all strobogrammatic numbers of length n. def helper(n, total_length): if n == 0: return [\\"\\"] if n == 1: return [\\"0\\", \\"1\\", \\"8\\"] middles = helper(n - 2, total_length) result = [] for middle in middles: if n != total_length: result.append(\\"0\\" + middle + \\"0\\") result.append(\\"1\\" + middle + \\"1\\") result.append(\\"6\\" + middle + \\"9\\") result.append(\\"8\\" + middle + \\"8\\") result.append(\\"9\\" + middle + \\"6\\") return result return helper(n, n) def strobogrammatic_in_range(low, high): Count strobogrammatic numbers within the range [low, high]. def is_valid(x, low, high): if len(x) < len(low) or len(x) > len(high): return False if len(x) == len(low) and x < low: return False if len(x) == len(high) and x > high: return False return True result = [] for length in range(len(low), len(high) + 1): result.extend(gen_strobogrammatic(length)) count = 0 for num in result: if is_valid(num, low, high): count += 1 return count"},{"question":"# Most Frequent Elements in an Array You are provided with an input array of integers. Write a function `find_most_frequent` that computes and returns the element(s) which appear most frequently in the array. If there are multiple modes, return all of them as a list in ascending order. Function Signature ```python def find_most_frequent(arr: List[int]) -> List[int]: ``` Input - A list of integers (`arr`) with (1 leq |arr| leq 10^5). Output - A list of integers representing the mode(s) of the array sorted in ascending order. Examples 1. Input: `[1, 1, 2, 2, 3, 4]` Output: `[1, 2]` 2. Input: `[5, 3, 9, 5, 5, 1]` Output: `[5]` 3. Input: `[3, 3, 3]` Output: `[3]` 4. Input: `[]` Output: `[]` Constraints - Elements in the array will be non-negative integers. - Ensure your solution handles arrays efficiently within the given constraints. Your solution should solve the problem with O(n) time complexity and O(n) space complexity.","solution":"from typing import List from collections import Counter def find_most_frequent(arr: List[int]) -> List[int]: if not arr: return [] frequency = Counter(arr) max_freq = max(frequency.values()) most_frequent = [num for num, count in frequency.items() if count == max_freq] return sorted(most_frequent)"},{"question":"# Shell Sort Coding Challenge Problem Description You are tasked with implementing the Shell Sort algorithm for a collection of integers. Shell Sort is an optimization over Insertion Sort that allows the exchange of far apart elements. The idea is to arrange the list of elements so that, starting anywhere, taking every _h-th_ element produces a sorted list. The function should accept an array of integers and return a new array that is sorted. Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr` (List[int]): A list of integers, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. Output * The function returns a new list (List[int]) containing the sorted integers. Constraints * Do not use Python\'s built-in sort functions. * The algorithm should perform efficiently for large lists, aim for a time complexity better than O(n^2) for average scenarios. * Aim to optimize for typical cases without sacrificing too much on the worst-case scenario. Example ```python # Example 1 input_array = [64, 34, 25, 12, 22, 11, 90] output_array = shell_sort(input_array) print(output_array) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 input_array = [37, 45, 29, 8, 12, 88, -3] output_array = shell_sort(input_array) print(output_array) # Output: [-3, 8, 12, 29, 37, 45, 88] ``` Performance Requirements * Your solution should handle lists of size up to (10^5) efficiently. Ensure that your implementation handles typical gaps sequences effectively to minimize the number of comparisons and element moves. Additional Notes * You may research different gap sequences like Hibbard\'s, Sedgewick\'s, or others to achieve better performance, but ensure to document your chosen gap sequence and its rationale in the code comments. * Test thoroughly for edge cases including but not limited to: an empty array, a single-element array, and arrays with repeating elements.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Perform Shell Sort on the input list of integers and return the sorted list. Parameters: arr (List[int]): A list of integers to sort. Returns: List[int]: A new list of sorted integers. n = len(arr) gap = n // 2 # initial gap size # Start with a large gap, then reduce the gap while gap > 0: for i in range(gap, n): # Perform a gapped insertion sort temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 # reduce the gap for next iteration return arr"},{"question":"# Context For many applications, especially those including file management or web development, manipulating and constructing paths or URLs correctly is essential. You have been provided a basic function to join file paths or URL parts. Your task is to enhance this function by addressing additional edge cases and providing robust error handling. # Prompt Enhance the given `join_with_slash` function to ensure it validates input strings, handles special cases for a variety of schemes, and error cases properly. # Requirements 1. **Function Signature**: `def join_with_slash(base: str, suffix: str) -> str:` 2. **Input**: - `base`: A non-empty string representing a base path or URL. - `suffix`: A non-empty string to append to the base. 3. **Output**: A string representing the joined path or URL. 4. **Constraints**: - Do not assume the characters in `base` and `suffix` beyond being valid paths or URLs. - The returned path must handle cases where the `suffix` begins with a scheme like `http://` or `file://`, indicating it should be returned as is. # Task Implement the `join_with_slash` function with the following behavior: - Join `base` and `suffix` ensuring a single slash separator. - If `suffix` starts with a scheme (`http://`, `https://`, `ftp://`, or `file://`), return `suffix` without joining. - Trim unnecessary slashes and whitespaces. - Validate inputs to ensure they are non-empty strings and handle potential errors gracefully. # Examples ```python assert join_with_slash(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert join_with_slash(\\"path/to/dir/\\", \\"/file\\") == \\"path/to/dir/file\\" assert join_with_slash(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_with_slash(\\"http://algorithms.com\\", \\"http://example.com\\") == \\"http://example.com\\" assert join_with_slash(\\"path\\", \\" \\") == \\"path/\\" assert join_with_slash(\\" \\", \\"/file\\") == \\"/file\\" assert join_with_slash(\\"\\", \\"file\\") == \\"file\\" # simplified empty base case handling ``` # Notes - Ensure to handle edge cases such as leading/trailing whitespaces and slashes. - The function should handle invalid input gracefully, providing informative error messages where appropriate.","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins base and suffix ensuring a single slash separator. If suffix starts with a scheme, returns suffix without joining. # Validate inputs if not isinstance(base, str) or not isinstance(suffix, str): raise ValueError(\\"Both base and suffix must be non-empty strings.\\") if base == \\"\\" or suffix == \\"\\": raise ValueError(\\"Both base and suffix must be non-empty strings.\\") # Strip leading/trailing whitespace base = base.strip() suffix = suffix.strip() # If suffix starts with a scheme, return suffix if suffix.startswith((\\"http://\\", \\"https://\\", \\"ftp://\\", \\"file://\\")): return suffix # Join base and suffix ensuring a single slash if base.endswith(\\"/\\") and suffix.startswith(\\"/\\"): return base.rstrip(\\"/\\") + \\"/\\" + suffix.lstrip(\\"/\\") elif not base.endswith(\\"/\\") and not suffix.startswith(\\"/\\"): return base + \\"/\\" + suffix else: return base + suffix"},{"question":"# Context You have been hired by a transportation logistics company to develop software that calculates the minimum cost of travel between stations in a new subway system. The stations are numbered from 0 to N-1, and the cost of a direct link from station i to station j (where i < j) is given in an N x N matrix. # Task Write a function `min_cost_travel(matrix)` which takes in a cost matrix and returns the minimum cost to travel from station 0 to station N-1. # Input - A 2D list `matrix` of size N x N, where matrix[i][j] represents the cost of traveling from station i to station j (0 ≤ i < j < N). - For all i ≥ j, matrix[i][j] is either -1 or a large number representing infinity, indicating no direct path. # Output - An integer representing the minimum cost to travel from station 0 to station N-1. # Constraints - 2 ≤ N ≤ 1000 - All costs are positive integers or set to -1 for non-existing paths. - There is at least one possible path from station 0 to station N-1. # Example ```python def min_cost_travel(matrix): # Your code goes here # Example usage: cost_matrix = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] print(min_cost_travel(cost_matrix)) # Output: 65 ``` # Explanation The minimum cost path in the provided example is from station 0 to station 1, then directly to station 3, with a cost of 15 (from 0 to 1) + 50 (from 1 to 3) = 65. Your task is to implement the function `min_cost_travel(matrix)` that successfully computes this minimum cost. **Note**: Ensure your function runs efficiently within the provided constraints.","solution":"def min_cost_travel(matrix): Returns the minimum cost to travel from station 0 to station N-1. N = len(matrix) inf = float(\'inf\') # Replace -1 with inf for easier calculation for i in range(N): for j in range(N): if matrix[i][j] == -1: matrix[i][j] = inf # Initialize a list to store the minimum cost to reach each station min_cost = [inf] * N min_cost[0] = 0 # Cost to reach the starting station is 0 # Compute minimum costs for i in range(N): for j in range(i + 1, N): if min_cost[i] + matrix[i][j] < min_cost[j]: min_cost[j] = min_cost[i] + matrix[i][j] return min_cost[N - 1]"},{"question":"# Question Given an array of non-negative integers, implement the Radix Sort algorithm to sort the array in ascending order. Your implementation should follow the least significant digit (LSD) radix sort approach. Write a Python function `radix_sort(arr)` which takes an array `arr` as an input and returns the sorted array. # Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of non-negative integers, where `0 <= len(arr) <= 10^6` and `0 <= arr[i] <= 10^9` for i in range(0, len(arr)). # Output * Returns a list of non-negative integers sorted in ascending order. # Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] ``` # Constraints 1. Ensure the algorithm runs efficiently for larger lists up to `10^6` elements and numbers up to `10^9`. 2. Do not use Python\'s built-in sorting functions. # Additional Notes 1. The function should handle empty input lists by returning an empty list. 2. The function should leverage the Radix Sort\'s properties and limitations as described in the analysis. 3. Most efficiency issues should be carefully managed by optimizing the digit processing.","solution":"def counting_sort(arr, exp): Perform a counting sort on arr based on the digit represented by exp. n = len(arr) output = [0] * n count = [0] * 10 # Store the count of occurrences of digits for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Update count[i] to contain the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[] for i in range(n): arr[i] = output[i] def radix_sort(arr): Perform LSD Radix Sort on arr. if not arr: return [] max_val = max(arr) exp = 1 # Perform counting sort for every digit while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Problem Statement You are working on a data serialization library and need to implement functions that convert integers to their byte representations and vice versa, handling both big-endian and little-endian formats. For this purpose, you need to write your own functions without using any built-in library functions like `int.to_bytes()` or `int.from_bytes()`. Specifically, you need to implement the following functions: 1. `int_to_bytes_big_endian(num: int) -> bytes` 2. `int_to_bytes_little_endian(num: int) -> bytes` 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` # Input and Output Formats * `int_to_bytes_big_endian(num: int) -> bytes`: - **Input**: A non-negative integer. - **Output**: Byte representation of the integer in big-endian format. * `int_to_bytes_little_endian(num: int) -> bytes`: - **Input**: A non-negative integer. - **Output**: Byte representation of the integer in little-endian format. * `bytes_big_endian_to_int(bytestr: bytes) -> int`: - **Input**: Byte sequence in big-endian format. - **Output**: Integer representation. * `bytes_little_endian_to_int(bytestr: bytes) -> int`: - **Input**: Byte sequence in little-endian format. - **Output**: Integer representation. # Constraints * The input integer will be in the range [0, 2^64 - 1]. * The byte sequence will be valid and have a length ≤ 8 bytes (64 bits). * Your solution should handle edge cases efficiently. * Functions should be efficient in terms of time complexity and avoid unnecessary memory overhead. # Example ```python # Example for big-endian conversion assert int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert bytes_big_endian_to_int(b\'x00x00x00x00x12x34x56x78\') == 305419896 # Example for little-endian conversion assert int_to_bytes_little_endian(305419896) == b\'xV4x12\' assert bytes_little_endian_to_int(b\'xV4x12x00x00x00x00\') == 305419896 ``` Implement these functions demonstrating a clear understanding of byte-level data manipulation.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts a non-negative integer to its byte representation in big-endian format. result = bytearray() while num > 0: result.append(num & 0xff) num >>= 8 return bytes(result[::-1] or b\'x00\') def int_to_bytes_little_endian(num: int) -> bytes: Converts a non-negative integer to its byte representation in little-endian format. result = bytearray() while num > 0: result.append(num & 0xff) num >>= 8 return bytes(result or b\'x00\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a byte sequence in big-endian format to its integer representation. result = 0 for b in bytestr: result = (result << 8) | b return result def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a byte sequence in little-endian format to its integer representation. result = 0 for i in range(len(bytestr)): result |= bytestr[i] << (i * 8) return result"},{"question":"# Question: Find the nth Digit in a Sequence of Natural Numbers Suppose we create an infinite sequence by concatenating all natural numbers: \\"123456789101112131415...\\". Given a positive integer `n`, your task is to return the nth digit of this sequence. Implementation Function ```python def find_nth_digit(n: int) -> int: pass ``` # Input * An integer `n` (1 <= n <= 10^9): The position of the digit in the sequence. # Output * An integer: The nth digit in the concatenated sequence. # Examples ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 ``` # Constraints * You have to ensure that the solution is efficient and adheres to a time complexity of O(log(n)). * The function should use constant space (O(1)), aside from input-related storage. # Edge Cases * Your function should handle cases when n points to the beginning, middle, or end of any number length (single-digit, double-digit, etc). * Consider explicitly testing near transitions, such as n = 9 (end of single digits) and n = 10 (beginning of double digits). This type of problem assesses your understanding of number manipulation, loops, and efficient computation tactics aligned with integer arithmetic.","solution":"def find_nth_digit(n: int) -> int: length = 1 # Length of numbers we are currently counting (1 for \'1-9\', 2 for \'10-99\', etc.) count = 9 # Count of numbers within the current length (9 for \'1-9\', 90 for \'10-99\', etc.) start = 1 # The first number in the current length (1, 10, 100, etc.) # Find the length of the number containing the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number containing the nth digit start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Context and Objective You are tasked with building a system that analyzes the similarity between customer reviews by transforming the text reviews into numerical vectors using cosine similarity. Given the following code that calculates cosine similarity between two vectors, you are required to implement an optimized function that combines the computation of the dot product and vector magnitudes in a single pass. # Task Implement the function `optimized_cosine_similarity(vec1, vec2)` that computes the cosine similarity between two vectors in a single pass through the data to minimize computational overhead. Function Signature ```python def optimized_cosine_similarity(vec1: list, vec2: list) -> float: pass ``` # Expected Input and Output Input * `vec1`: List of integers/floats, representing the first vector. (Constraints: 1 <= len(vec1) <= 10^6) * `vec2`: List of integers/floats, representing the second vector. (Constraints: vec2 has the same length as vec1) Output * Returns a float representing the cosine similarity between the vectors. # Example ```python # Example usage print(optimized_cosine_similarity([1, 1, 1], [1, 2, -1])) # Output: 0.47140452079103173 ``` # Constraints * The vectors will have non-zero length. * Vectors will contain non-zero elements. # Performance Requirements * The solution should run in O(n) time complexity where n is the number of elements in the vectors. * Space complexity should remain O(1). # Notes * Ensure to handle zero vectors appropriately to avoid division by zero errors. * Assume standard libraries like math can be used.","solution":"import math def optimized_cosine_similarity(vec1, vec2): Computes the cosine similarity between two vectors in a single pass. :param vec1: List of integers/floats, representing the first vector. :param vec2: List of integers/floats, representing the second vector. :return: Float representing the cosine similarity between the vectors. dot_product = 0 magnitude_vec1 = 0 magnitude_vec2 = 0 for v1, v2 in zip(vec1, vec2): dot_product += v1 * v2 magnitude_vec1 += v1 ** 2 magnitude_vec2 += v2 ** 2 magnitude_vec1 = math.sqrt(magnitude_vec1) magnitude_vec2 = math.sqrt(magnitude_vec2) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Prim\'s Algorithm Implementation Challenge Given the description of Prim\'s Algorithm and its implementation in Python, your task is to modify the `prims_minimum_spanning` function to work for any connected, undirected graph represented as a dictionary, where the keys are the nodes, and the values are lists of pairs representing edges with their weights. # Requirements 1. Implement a function `prims_minimum_spanning(graph: Dict[str, List[Tuple[int, str]]]) -> int:` that takes an input dictionary graph and outputs the total weight of the Minimum Spanning Tree (MST). 2. Your function should correctly handle any connected undirected graph, including: * Letters or numerical node representations. * Variable edge weights. 3. Ensure your solution adheres to the performance complexity constraints (Time complexity O(E log V) and Space complexity O(V)). # Example **Input:** ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } ``` **Output:** ``` 14 ``` **Explanation:** The minimum spanning tree for the provided graph can be formed with the edges (a-b with weight 3), (c-d with weight 2), (c-e with weight 4), and (b-d with weight 5). The total weight is 3 + 2 + 4 + 5 = 14. # Constraints * The graph will always be connected. * Nodes will be uniquely identified (no duplicate nodes). * Edge weights will be positive integers. Implement your solution keeping efficiency in mind. Ensure your code is well-documented and readable.","solution":"from typing import Dict, List, Tuple import heapq def prims_minimum_spanning(graph: Dict[str, List[Tuple[int, str]]]) -> int: Function to find the weight of the MST using Prim\'s Algorithm. :param graph: A dictionary representing the graph where the keys are nodes and values are lists of tuples containing the edge weights and the connected nodes. :type graph: Dict[str, List[Tuple[int, str]]] :return: The total weight of the Minimum Spanning Tree (MST). :rtype: int if not graph: return 0 # Start from any node. Here, we pick the first key from the dictionary start_node = next(iter(graph)) # Priority queue to pick the smallest edge weight first min_heap = [(0, start_node)] visited = set() total_weight = 0 while min_heap: weight, current_node = heapq.heappop(min_heap) # If the node has already been visited, skip it if current_node in visited: continue # Add the weight to the total_weight once we visit the node total_weight += weight visited.add(current_node) # Add all edges from the current node to the heap for edge_weight, neighbor in graph[current_node]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, neighbor)) return total_weight"},{"question":"# Jump Search Implementation You\'re assigned a task to implement a search function that leverages the Jump Search algorithm. Your function should be named `jump_search` and adhere to the following specifications: * **Input**: * A sorted list `arr` of unique integers. * An integer `target` representing the value to be searched in the list. * **Output**: * An integer index of the `target` in the list `arr` if found. * `-1` if the `target` is not present in the list. # Guidelines 1. You can use the Python math library to calculate the square root. 2. Consider edge cases such as empty lists and targets out of the array\'s bounds. 3. Ensure your code runs efficiently, keeping the performance characteristics in mind. # Example ```python >>> arr = [1, 3, 5, 7, 9, 11, 13, 15] >>> target = 7 >>> jump_search(arr, target) 3 >>> arr = [1, 3, 5, 7, 9, 11, 13, 15] >>> target = 8 >>> jump_search(arr, target) -1 ``` # Constraints * The length of array `arr` will be between 0 and 10^6. * The elements in `arr` will be integers, and the list will be sorted in ascending order. * The `target` will be an integer within the range, -10^9 to 10^9. Implement the `jump_search` function to complete the task.","solution":"import math def jump_search(arr, target): Jump Search algorithm implementation to find the index of \'target\' in \'arr\'. :param arr: List[int]: A sorted list of unique integers. :param target: int: The integer value to be searched within the list. :return: int: The index of \'target\' if found, otherwise -1. n = len(arr) if n == 0: return -1 # Finding the block size to be jumped step = int(math.sqrt(n)) prev = 0 # Finding the block where the element is present while arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the block beginning with prev for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Reverse Words in a Sentence Problem Description You are tasked with implementing a function that reverses the order of words in a given sentence. Words are sequences of characters separated by spaces. You must preserve the internal order of characters in each word while reversing the order of the words. Do not use any in-built reverse method, and implement the reversal logic yourself. Function Signature ```python def reverse_sentence(sentence: str) -> str: ``` Input - `sentence` (str): A string representing the sentence, which may include multiple spaces, punctuation, or an empty string. Output - Returns a string with the words\' order reversed while the characters in each word remain as is. Constraints - Handle cases with multiple spaces. - Handle punctuation. - Treat punctuation marks as part of the words. - The input string length does not exceed 10^4 characters. Examples ```python assert reverse_sentence(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_sentence(\\" Hello World! \\") == \\"World! Hello\\" assert reverse_sentence(\\"Coding is fun\\") == \\"fun is Coding\\" assert reverse_sentence(\\"\\") == \\"\\" assert reverse_sentence(\\"SingleWord\\") == \\"SingleWord\\" ``` Requirements 1. Do not use Python\'s reverse() method directly on the list of words. 2. Write code that handles edge cases gracefully. 3. Aim for O(n) time complexity. Hints - Use a helper function to reverse the elements of an array in place. - Be mindful about how you handle leading and trailing spaces.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence while preserving the original order of characters within each word. Multiple spaces are handled correctly. Args: - sentence (str): A string representing the sentence. Returns: - str: A string with the words\' order reversed. if not sentence: return sentence # Split the sentence into words based on spaces words = sentence.split() # Reverse the words array manually without using reverse method start, end = 0, len(words) - 1 while start < end: words[start], words[end] = words[end], words[start] start += 1 end -= 1 # Rejoin the reversed words list into a single string with a space separator return \' \'.join(words)"},{"question":"# Unique Binary Search Trees Calculation Context: You are given an integer `n`, representing the number of consecutive integers starting from 1. Your task is to determine how many structurally unique Binary Search Trees (BSTs) can be constructed with these integers. Problem Statement: Write a function `num_trees(n)` that computes the number of structurally unique BSTs that store values from 1 to n. Input: * An integer n (0 <= n <= 19) Output: * An integer representing the number of unique BSTs. Example: ```python num_trees(3) # Output: 5 ``` Explanation: For n = 3, there are a total of 5 unique BSTs as shown in the provided example. Constraints: * The solution should be optimized to handle n up to 19 efficiently. * Time complexity should be O(n^2) and space complexity should be O(n). Implement the function using dynamic programming principles effectively handling edge cases and performance constraints.","solution":"def num_trees(n): Computes the number of unique BSTs that can be formed with values from 1 to n. if n == 0 or n == 1: return 1 # Initialize the dp array; dp[i] will store the number of unique BSTs with i nodes dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Build the dp array using the dynamic programming approach for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"Context: You are tasked with developing part of a software library that handles combinatorial problems. One common problem is finding all possible subsets of a given set of distinct integers. This functionality is crucial for algorithms that need to evaluate all possible combinations, such as certain dynamic programming solutions or the evaluation of decision trees. Problem Statement: Write a function `generate_subsets(nums)` which returns all possible subsets of a given set of distinct integers `nums`. Requirements: - The function should return the subsets as a set of tuples. - The returned set must not contain duplicate subsets. - The function should be efficient in terms of both time and space. Function Signature: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` Input: - `nums`: A list of `n` distinct integers, `1 <= n <= 15`. Output: - A set of tuples where each tuple represents a unique subset of the input list `nums`. Examples: ```python >>> generate_subsets([1,2,3]) {(1, 2), (1, 3), (2,), (3,), (1,), (1, 2, 3), (), (2, 3)} >>> generate_subsets([4,5]) {(4,), (5,), (), (4, 5)} >>> generate_subsets([1]) {(1,), ()} ``` Notes: - The elements within a subset should be listed in the order they appear in `nums`. - The output does not need to be sorted, but should contain all unique subsets.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Returns all possible subsets of a given list of distinct integers as a set of tuples. Arguments: nums -- List of distinct integers Returns: A set containing all subsets represented as tuples. def backtrack(start, path): subsets.add(tuple(path)) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() subsets = set() backtrack(0, []) return subsets"},{"question":"# Bucket Sort Enhancement Challenge Your task is to implement an enhanced version of the provided Bucket Sort algorithm to tackle some of its inefficiencies. **Scenario**: Given an array of positive integers, use the principles of bucket sort to return the sorted array. However, instead of using Insertion Sort for sorting within the buckets, implement a more efficient sorting method that should help balance the sorting time. **Function Signature**: ```python def enhance_bucket_sort(arr: List[int]) -> List[int]: pass ``` **Expected Input and Output**: * Input: A list of positive integers `arr` (1 ≤ length of arr ≤ 10^5, 0 ≤ arr[i] ≤ 10^9) * Output: A sorted list of integers **Constraints**: * You should optimize the sorting of elements within each bucket. * Aim for average-case time complexity better than O(n^2) and justify your choice of inner sort. * Consider edge cases including very small arrays, arrays with all elements the same, arrays with wide range values, and empty arrays. **Performance Requirements**: * Your implementation must efficiently handle arrays up to 100,000 elements. * Memory usage should be optimized to avoid significant overhead. **Example**: ```python assert enhance_bucket_sort([3, 6, 2, 7, 4, 5, 1]) == [1, 2, 3, 4, 5, 6, 7] assert enhance_bucket_sort([15, 13, 11, 14, 12, 10]) == [10, 11, 12, 13, 14, 15] assert enhance_bucket_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert enhance_bucket_sort([]) == [] ```","solution":"from typing import List from bisect import insort import heapq def enhance_bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] min_value, max_value = min(arr), max(arr) bucket_count = len(arr) // 4 # this is a heuristic; adjust as needed for optimal bucket count bucket_count = max(bucket_count, 1) # Create empty buckets buckets = [[] for _ in range(bucket_count)] # Fill the buckets for num in arr: index = (num - min_value) * (bucket_count - 1) // (max_value - min_value) if max_value != min_value else 0 buckets[index].append(num) # Sort each bucket using an efficient sort, e.g., Timsort (Python\'s built-in sorted() function) or heap sort sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) # sorted() uses Timsort which is O(n log n) return sorted_array"},{"question":"# Context: As a senior developer, you are tasked with creating a tool that helps manage and visualize task dependencies in a large software project. Your team is constructing a feature to list all tasks in a sequence such that each task is completed before the tasks that depend on it. # Problem: Implement a function `find_task_order` that performs topological sorting on a given directed acyclic graph (DAG) represented as an adjacency list. # Function Signature: ```python def find_task_order(graph: Dict[int, List[int]]) -> List[int]: pass ``` # Input: * `graph`: A dictionary representing an adjacency list of the directed graph. The keys are task identifiers, and the values are lists of tasks that depend on the key task. # Output: * Returns a list of integers representing the tasks in the required topological order. # Constraints: * The graph will have at most 10^5 nodes and 10^6 edges. * The graph is guaranteed to be a DAG. # Requirements: * Implement both recursive and iterative methods provided. * Ensure the solution handles large graphs efficiently within the provided constraints. # Example: ```python graph = { 0: [1, 2], 1: [3], 2: [3], 3: [] } result = find_task_order(graph) # Expected output: [0, 1, 2, 3] or [0, 2, 1, 3] (both are valid topological orders) ``` # Note: - Raise a `ValueError` with \\"cycle\\" if a cycle is detected. - Ensure to handle edge cases, such as isolated tasks or tasks with no dependencies.","solution":"from typing import List, Dict def find_task_order(graph: Dict[int, List[int]]) -> List[int]: Perform topological sorting on a given directed acyclic graph (DAG) represented as an adjacency list. visited = set() temp = set() result = [] def visit(node: int): if node in temp: raise ValueError(\\"cycle\\") if node not in visited: temp.add(node) for neighbor in graph.get(node, []): visit(neighbor) temp.remove(node) visited.add(node) result.append(node) for node in graph: if node not in visited: visit(node) return result[::-1]"},{"question":"You are required to implement a self-balancing Binary Search Tree (BST) described below. This BST should have methods for insertion, search, size calculation, and tree traversal in Inorder, Preorder, and Postorder manners. You should additionally provide a rebalancing mechanism to ensure that its height remains logarithmic relative to the number of nodes. # Function Specifications Implement the following methods in the `BalancedBST` class: - `insert(data: int) -> bool`: Inserts a new integer into the BST. Returns `True` if the value was inserted, and `False` if it was already present. - `search(data: int) -> bool`: Searches for an integer in the BST. Returns `True` if the value is found, and `False` otherwise. - `size() -> int`: Returns the number of nodes in the BST. - `inorder(root: Node) -> List[int]`: Returns a list of elements in an Inorder manner. - `preorder(root: Node) -> List[int]`: Returns a list of elements in a Preorder manner. - `postorder(root: Node) -> List[int]`: Returns a list of elements in a Postorder manner. - `rebalance() -> None`: Rebalances the tree to ensure that the height remains logarithmic. # Input and Output Formats - **Constraints**: - The value of any BST node can be a signed integer within the range: -10^9 to 10^9. - Assume a maximum of 10^6 nodes for all operations. - **Example Usage**: ```python # Initialize the balanced BST bst = BalancedBST() # Insert elements bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) # Searching elements print(bst.search(15)) # Output: True print(bst.search(7)) # Output: False # Size of the tree print(bst.size()) # Output: 4 # Traversal outputs print(bst.inorder(bst.get_root())) # Output: [4, 6, 10, 15] print(bst.preorder(bst.get_root())) # Output: [10, 6, 4, 15] print(bst.postorder(bst.get_root())) # Output: [4, 6, 15, 10] # Rebalance the tree bst.rebalance() ``` # Additional Notes - Ensure that the rebalance function reorganizes the BST to minimize height. - Use tree rotations (like those in AVL trees) or any other suitable method to achieve balanced trees. - Aim for clear and optimized code to handle large datasets efficiently.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self): self.root = None def insert(self, data): if self.search(data): return False self.root = self._insert(self.root, data) return True def _insert(self, node, data): if node is None: return Node(data) if data < node.key: node.left = self._insert(node.left, data) else: node.right = self._insert(node.right, data) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data == node.key: return True elif data < node.key: return self._search(node.left, data) else: return self._search(node.right, data) def size(self): return self._size(self.root) def _size(self, node): if node is None: return 0 return 1 + self._size(node.left) + self._size(node.right) def inorder(self, node): res = [] self._inorder(node, res) return res def _inorder(self, node, res): if node is not None: self._inorder(node.left, res) res.append(node.key) self._inorder(node.right, res) def preorder(self, node): res = [] self._preorder(node, res) return res def _preorder(self, node, res): if node is not None: res.append(node.key) self._preorder(node.left, res) self._preorder(node.right, res) def postorder(self, node): res = [] self._postorder(node, res) return res def _postorder(self, node, res): if node is not None: self._postorder(node.left, res) self._postorder(node.right, res) res.append(node.key) def rebalance(self): elements = self.inorder(self.root) self.root = self._sorted_array_to_bst(elements) def _sorted_array_to_bst(self, elements): if not elements: return None mid = len(elements) // 2 root = Node(elements[mid]) root.left = self._sorted_array_to_bst(elements[:mid]) root.right = self._sorted_array_to_bst(elements[mid+1:]) return root def get_root(self): return self.root def _rebalance(self, node): balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) elif balance_factor < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right)"},{"question":"# Question: Enhanced Stooge Sort with Early Termination Context You\'ve been given the task of improving the Stooge Sort algorithm. Your objective is to implement an enhanced version that includes an early termination feature: if a subarray is already sorted, the function should exit early without further recursive calls. This optimization aims to potentially reduce the number of comparisons and recursive calls the algorithm makes. # Function Signature ```python def enhanced_stoogesort(arr: list[int], l: int, h: int) -> None: pass ``` # Input * `arr` (list of int): List of integers to be sorted. * `l` (int): The starting index of the subarray. * `h` (int): The ending index of the subarray. # Output * The function should sort the input list `arr` in place without returning anything. # Constraints * 1 <= len(arr) <= 10^3 * -10^3 <= arr[i] <= 10^3 for any valid index `i` # Example ```python array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] n = len(array) enhanced_stoogesort(array, 0, n-1) print(array) # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Performance Requirement Although Stooge Sort is inherently inefficient, adding an early termination feature should significantly enhance its performance for partially sorted arrays or when applied to sorted subarrays. # Notes * Ensure the function handles edge cases such as empty arrays and arrays with one element. * The function should include checks to determine if the subarray is already sorted before proceeding with further recursive calls.","solution":"def enhanced_stoogesort(arr, l, h): if l >= h: return # Check if the subarray is already sorted is_sorted = True for i in range(l, h): if arr[i] > arr[i+1]: is_sorted = False break if is_sorted: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: third = (h - l + 1) // 3 enhanced_stoogesort(arr, l, h - third) enhanced_stoogesort(arr, l + third, h) enhanced_stoogesort(arr, l, h - third) # Example usage: # array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # n = len(array) # enhanced_stoogesort(array, 0, n-1) # print(array) # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]"},{"question":"# Question **Trie (Prefix Tree) Implementation** You are to implement a Trie (Prefix Tree) data structure that supports the following operations: 1. `insert(word)`: Inserts the word into the Trie. 2. `search(word)`: Returns `True` if the word is in the Trie, `False` otherwise. 3. `startsWith(prefix)`: Returns `True` if there is any word in the Trie that starts with the given prefix, `False` otherwise. You will be provided a sequence of operations (`insert`, `search`, and `startsWith`) along with the corresponding words/prefixes. Implement the Trie and ensure it handles these operations efficiently. # Input and Output Formats * **Input**: * A list of operations (e.g., `[\\"insert\\", \\"search\\", \\"startsWith\\", ...]`) * A list of words/prefixes corresponding to each operation (e.g., `[\\"apple\\", \\"apple\\", \\"app\\", ...]`) * **Output**: * A list of results from `search` and `startsWith` operations (e.g., `[None, True, True, ...]`). # Constraints * The input words consist of only lowercase letters `a-z`. * The operations list and words/prefixes list are guaranteed to have the same length. * The total number of operations will not exceed `10^4`. # Scenario Example Consider `operations = [\\"insert\\", \\"search\\", \\"startsWith\\", \\"insert\\", \\"search\\", \\"search\\"]` and `words = [\\"apple\\", \\"apple\\", \\"app\\", \\"app\\", \\"app\\", \\"bat\\"]`. ```python trie = Trie() result = [] for op, word in zip(operations, words): if op == \\"insert\\": trie.insert(word) result.append(None) elif op == \\"search\\": result.append(trie.search(word)) elif op == \\"startsWith\\": result.append(trie.starts_with(word)) print(result) # Output: [None, True, True, None, True, False] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): Inserts a word into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Returns if the word is in the Trie. node = self._find_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix): Returns if there is any word in the Trie that starts with the given prefix. return self._find_node(prefix) is not None def _find_node(self, prefix): Helper function to navigate the Trie and find the node for a given prefix. node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node"},{"question":"# Question: Calculate Distinct Ways to Climb Stairs Scenario You are an engineer tasked with designing the staircase climbing mechanism for a robot. The robot can either climb one step or skip directly to two steps. The staircase of the building has `steps` number of steps. The management wants to know how many distinct ways the robot can reach the top of the staircase. Task Write a function `climb_stairs_robot` that takes an integer `steps` and returns the number of distinct ways to climb to the top. Input * `steps`: A positive integer representing the number of steps in the staircase. Output * An integer representing the distinct possible ways you can climb the stairs to the top. Constraints * The given argument `steps` will always be a positive integer. Performance Requirements * The implementation should run efficiently for large values of `steps`. * Aim for a time complexity of `O(n)` and space complexity of `O(1)`. Example Example 1: ```python Input: steps = 3 Output: 3 Explanation: There are three ways to climb to the top 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step ``` Example 2: ```python Input: steps = 4 Output: 5 Explanation: There are five ways to climb to the top 1. 1 step + 1 step + 1 step + 1 step 2. 1 step + 1 step + 2 steps 3. 1 step + 2 steps + 1 step 4. 2 steps + 1 step + 1 step 5. 2 steps + 2 steps ```","solution":"def climb_stairs_robot(steps): Returns the number of distinct ways to climb to the top of a staircase with the given number of steps, where the robot can either climb one step or skip directly to two steps. if steps == 1: return 1 elif steps == 2: return 2 prev1, prev2 = 2, 1 for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Transitive Closure Calculation of a Directed Graph Given a directed graph, your task is to implement the transitive closure of the graph using Depth-First Search (DFS). The transitive closure of a graph is a binary matrix where the value in row i and column j indicates whether vertex j is reachable from vertex i. Function Signature ```python def transitive_closure(vertices: int, edges: [(int, int)]) -> List[List[int]]: pass ``` Input - **vertices (int)**: The number of vertices in the graph. - **edges (List of Tuples (int, int))**: A list of pairs, where each pair (a, b) represents a directed edge from vertex a to vertex b. Output - **List of Lists (int)**: A 2D binary matrix representing the transitive closure of the graph. The element at matrix[i][j] should be 1 if vertex j is reachable from vertex i, and 0 otherwise. Constraints - Assume that the vertices are 0-indexed and are within the range [0, vertices-1]. - All edges in the input are valid directed edges between valid vertices. Example # Input: ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` # Output: ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Explanation: Starting from each vertex, the algorithm should check all reachable vertices using DFS. For instance, starting from vertex 0, all other vertices (1, 2, 3) are reachable either directly or indirectly, thus matrix[0] will have ones across all columns. Note: - Self-reachability is assumed in the matrix; i.e., each vertex is reachable from itself. - Consider edge cases like a graph with no edges, disconnected vertices, and edges creating cycles. Implement the function `transitive_closure` to solve the problem.","solution":"from typing import List, Tuple def transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize the transitive closure matrix with 0, and set the diagonal to 1s for self-reachability. closure = [[0]*vertices for _ in range(vertices)] for i in range(vertices): closure[i][i] = 1 # Adjacency list representation of the graph graph = [[] for _ in range(vertices)] for u, v in edges: graph[u].append(v) # Helper function to perform DFS def dfs(source: int, v: int): for neighbor in graph[v]: if closure[source][neighbor] == 0: closure[source][neighbor] = 1 dfs(source, neighbor) # Perform DFS for each vertex for i in range(vertices): dfs(i, i) return closure"},{"question":"Question: Implement an Advanced Playlist Manipulation System You are tasked with implementing a system to manage a playlist for a media player. This system should allow adding new songs, removing songs, and playing a random song, all in efficient average time. # Functionality Requirements Your class, `Playlist`, must support the following operations: 1. `add_song(song: str) -> bool`: Add a new song to the playlist if it’s not already present. Returns `True` if the song was successfully added, otherwise returns `False`. 2. `remove_song(song: str) -> bool`: Remove a song from the playlist if it\'s present. Returns `True` if the song was successfully removed, otherwise returns `False`. 3. `play_random_song() -> str`: Play a random song from the current list of songs. Each song should have an equal probability of being played. If the playlist is empty, raise an `IndexError` with the message \\"The playlist is empty\\". # Input and Output Format - The `add_song` method takes a single string argument representing the song name. - The `remove_song` method takes a single string argument representing the song name. - The `play_random_song` method returns a string representing the song name. - The `play_random_song` method should raise an `IndexError` with the message \\"The playlist is empty\\" if there are no songs in the playlist. # Example ```python p = Playlist() print(p.add_song(\\"Song1\\")) # Output: True print(p.add_song(\\"Song2\\")) # Output: True print(p.add_song(\\"Song1\\")) # Output: False print(p.play_random_song()) # Output: Either \\"Song1\\" or \\"Song2\\" print(p.remove_song(\\"Song3\\")) # Output: False print(p.remove_song(\\"Song1\\")) # Output: True print(p.play_random_song()) # Output: \\"Song2\\" print(p.remove_song(\\"Song2\\")) # Output: True try: p.play_random_song() # Raises IndexError except IndexError as e: print(e) # Output: \\"The playlist is empty\\" ``` # Constraints - Song names are unique and are case-sensitive. - The total number of songs will not exceed 10^5. Implement the `Playlist` class with the provided functionality.","solution":"import random class Playlist: def __init__(self): self.songs = {} self.song_list = [] def add_song(self, song: str) -> bool: if song in self.songs: return False self.songs[song] = len(self.song_list) self.song_list.append(song) return True def remove_song(self, song: str) -> bool: if song not in self.songs: return False last_song = self.song_list[-1] song_index = self.songs[song] self.song_list[song_index] = last_song self.songs[last_song] = song_index self.song_list.pop() del self.songs[song] return True def play_random_song(self) -> str: if not self.song_list: raise IndexError(\\"The playlist is empty\\") return random.choice(self.song_list)"},{"question":"You are given a sequence of matrices and you are required to find the most efficient way to multiply these matrices together. Your task is to implement the matrix chain multiplication algorithm using dynamic programming. # Input * An array of integers `arr` of size `n`, where `arr[i]` represents the dimension of the i-th matrix such that matrix `Ai` has dimensions `arr[i-1] x arr[i]`. # Output * Print the minimum number of scalar multiplications needed to multiply the sequence of matrices. * Print the order in which the matrices should be multiplied. # Constraints * 2 <= arr.length <= 100 * Each element in `arr` is a positive integer not exceeding 1000. # Performance Requirements * Your algorithm should work efficiently for n up to 100. # Example ```python Input: arr = [30, 35, 15, 5, 10, 20, 25] Output: 15125 Optimal Parenthesization: (A1(A2(A3(A4A5))A6)) ``` # Function Signature: ```python def matrix_chain_multiplication(arr: List[int]) -> None: pass ``` # Explanation * For the provided input list `[30, 35, 15, 5, 10, 20, 25]`, the minimum number of multiplications needed is `15125`. * The optimal order of multiplication is given as `(A1(A2(A3(A4A5))A6))`. # Notes * You should implement the function `matrix_chain_multiplication` which prints the required number of multiplications and the optimal multiplication order. * Make sure to handle edge cases such as single matrices or invalid dimension arrays.","solution":"from typing import List def matrix_chain_multiplication(arr: List[int]) -> None: n = len(arr) - 1 # Number of matrices m = [[0] * n for _ in range(n)] s = [[0] * n for _ in range(n)] for l in range(2, n + 1): for i in range(0, n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + arr[i] * arr[k + 1] * arr[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k min_cost = m[0][n-1] optimal_order = _get_optimal_parenthesization(s, 0, n-1) print(min_cost) print(optimal_order) def _get_optimal_parenthesization(s, i, j): if i == j: return f\\"A{i+1}\\" else: return f\\"({ _get_optimal_parenthesization(s, i, s[i][j])}\\" f\\"{ _get_optimal_parenthesization(s, s[i][j] + 1, j)})\\""},{"question":"You are tasked with finding all prime numbers less than a given positive integer `n`. Utilize and improve upon the Sieve of Eratosthenes algorithm to achieve this. Your implementation should be efficient for large values of `n` and should handle special cases correctly. # Function Signature ```python def find_primes(n: int) -> List[int]: pass ``` # Input - `n` (int): A positive integer where `1 <= n <= 10^7`. # Output - Returns a list of integers containing all prime numbers less than `n` in ascending order. # Constraints - You must optimize for both time and space complexity. - Proper handling of the edge cases: - For `n <= 2`, return an empty list. - If `n` is not a positive integer, raise a `ValueError`. # Example ```python assert find_primes(10) == [2, 3, 5, 7] assert find_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert find_primes(2) == [] assert find_primes(0) throws ValueError assert find_primes(1) == [] ``` # Explanation - For `n = 10`, primes are {2, 3, 5, 7}. - For `n = 20`, primes are {2, 3, 5, 7, 11, 13, 17, 19}. Use optimizations to reduce both time and space complexity as explained in the algorithm analysis section. # Notes - Consider using an optimized version of the Sieve of Eratosthenes by skipping even numbers and initializing a smaller sieve array. - Aim for a time complexity of O(n log log n) and space complexity of O(n / 2).","solution":"from typing import List def find_primes(n: int) -> List[int]: Returns a list of all prime numbers less than a given positive integer n. Utilizes the Sieve of Eratosthenes for efficient computation. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num in range(2, n) if sieve[num]]"},{"question":"# Scenario In a quest to explore interesting properties of numbers, you are asked to identify numbers that are equal to the sum of their digits each raised to the power of their respective positions when arranged in the number. # Task Write a function `sum_dig_pow(low, high)` that finds such numbers in a given range `[low, high]`. # Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` # Input - `low (int)`: The start of the range, inclusive. - `high (int)`: The end of the range, inclusive. Both values will be positive integers where `1 <= low <= high`. # Output - A list of integers within the range `[low, high]` that match the property where the sum of their digits raised to the power of their positions equals the number itself. # Constraints - Both `low` and `high` are at least 1 and `low` ≤ `high`. - You should aim for an efficient solution that can handle large ranges well. # Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(50, 150) == [89, 135] ``` # Explanation In the first example: - Each single-digit number between 1 and 10 fits the property since raising it to the power of 1 results in the same number. In the second example: - The numbers 1 through 9 are included as above, but 89 also fits since 8**1 + 9**2 = 89.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: Finds all numbers in a given range [low, high] where each number is equal to the sum of its digits each raised to the power of their respective positions. result = [] for num in range(low, high + 1): sum_of_powers = sum(int(digit) ** (index + 1) for index, digit in enumerate(str(num))) if sum_of_powers == num: result.append(num) return result"},{"question":"You are to implement a function that determines the minimum number of moves required to find the critical floor in the worst case with the given number of eggs and floors. The critical floor is the highest floor from which eggs can be dropped without breaking. # Inputs: 1. **n** (integer): The number of floors. 2. **k** (integer): The number of eggs. # Output: An integer representing the minimum number of moves required to determine the critical floor in the worst case. # Constraints: * (1 leq n leq 1000) * (1 leq k leq 100) # Function Signature: ```python def min_trials(n: int, k: int) -> int: pass ``` # Example: Input: ```plaintext n = 6 k = 2 ``` Output: ```plaintext 3 ``` Explanation: With 2 eggs and 6 floors, the minimum number of moves in the worst case to determine the critical floor is 3. # Notes: - Consider edge cases where n or k is 1. - Optimize your solution to handle the upper limits of the constraints efficiently.","solution":"def min_trials(n: int, k: int) -> int: Determine the minimum number of moves required to find the critical floor in the worst case with the given number of eggs and floors. # A 2D list where dp[i][j] will represent minimum number of trials needed for i eggs and j floors dp = [[0 for x in range(n + 1)] for x in range(k + 1)] # We need 1 trial for one floor and zero trials for zero floors for i in range(1, k + 1): dp[i][1] = 1 dp[i][0] = 0 # We always need j trials for one eggs and j floor. for j in range(1, n + 1): dp[1][j] = j # Fill the rest of the table using optimal substructure property for i in range(2, k + 1): for j in range(2, n + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): res = 1 + max(dp[i - 1][x - 1], dp[i][j - x]) if res < dp[i][j]: dp[i][j] = res # dp[k][n] holds the result return dp[k][n]"},{"question":"# Coding Challenge: Custom Sorted Array Objective: You are given an array of integers and you need to write a function that sorts the array using Gnome Sort but with a twist: write a custom comparator function to compare the absolute values of elements (i.e., sort the array based on the absolute values of integers). Function Signature: ```python def custom_gnome_sort(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers (1 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6 for all valid `i`) Output: - A list of integers sorted based on the absolute values. Constraints: - You must sort the array using the Gnome Sort algorithm. - The sorting should be based on the absolute values of the integers. Example: ```python assert custom_gnome_sort([3, -1, 2, -4, 0]) == [0, -1, 2, 3, -4] assert custom_gnome_sort([-2, 1, -3]) == [1, -2, -3] assert custom_gnome_sort([10, -1, -1, -20]) == [-1, -1, 10, -20] ``` Additional Information: 1. **Edge Cases**: Consider the scenario with a single element which should return the element itself; handle duplicates and zeroes correctly. 2. **Performance Requirement**: Aim to keep the solution within the confines of O(n^2) time complexity.","solution":"from typing import List def custom_gnome_sort(arr: List[int]) -> List[int]: index = 0 while index < len(arr): if index == 0 or abs(arr[index]) >= abs(arr[index - 1]): index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"Scenario In a software project, you are tasked with implementing a robot that follows a probabilistic path within a predefined grid. The robot\'s movements are determined by a Markov Chain, where states represent its possible positions, and each transition from one state to another has a predefined probability. Task Implement a function named `simulate_robot_path` that takes in a Markov Chain (`chain`), an initial state (`start_state`), and the number of steps (`steps`) the robot should take. The function should return a list of states representing the path taken by the robot. The Markov Chain is represented as a dictionary, where keys are states and values are dictionaries of neighboring states with their corresponding transition probabilities. The initial state is a string representing the starting position of the robot, and the steps is an integer denoting how many steps the robot should take. # Function Signature ```python def simulate_robot_path(chain: Dict[str, Dict[str, float]], start_state: str, steps: int) -> List[str]: Simulates the path of a robot based on the provided Markov Chain. Parameters: chain (Dict[str, Dict[str, float]]): The Markov Chain defining state transitions. start_state (str): The starting state of the robot. steps (int): The number of steps the robot should take. Returns: List[str]: The list of states representing the path taken by the robot. ``` # Input and Output Input: * `chain`: Dictionary, where each key is a state, and the value is a dictionary of transitions from this state with their respective probabilities. * `start_state`: String, the initial state. * `steps`: Integer, the number of steps the robot should take. Output: * Return a list of strings, each representing the state of the robot at each step. # Constraints * The probabilities for transitions from any state will sum up to 1. * The number of states and transitions will be such that a solution will run within a reasonable time limit. # Performance Requirements * Optimize for time complexity for accessing states and selecting the next state. # Example ```python chain = { \'A\': {\'A\': 0.1, \'B\': 0.6, \'C\': 0.3}, \'B\': {\'A\': 0.3, \'B\': 0.3, \'C\': 0.4}, \'C\': {\'A\': 0.4, \'B\': 0.4, \'C\': 0.2} } start_state = \'A\' steps = 5 assert simulate_robot_path(chain, start_state, steps) == [\'B\', \'C\', \'A\', \'B\', \'C\'] ``` Further Reading For better understanding, you may want to explore more on: * Markov Chains and their applications. * Probabilistic models in computer science and artificial intelligence.","solution":"import random from typing import Dict, List def simulate_robot_path(chain: Dict[str, Dict[str, float]], start_state: str, steps: int) -> List[str]: path = [start_state] current_state = start_state for _ in range(steps): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) next_state = random.choices(next_states, probabilities)[0] path.append(next_state) current_state = next_state return path"},{"question":"# Problem Context You are given two input lists of integers. Your task is to design a data structure that allows iterating through both lists in a zigzag (alternating) manner. You should be able to query the next element and check if there are more elements to iterate. # Problem Statement Implement the class `ZigZagIterator2` which alternates between the elements of two given lists `v1` and `v2`. The class should support the following methods: 1. **`__init__(self, v1: List[int], v2: List[int]) -> None:`** * Initializes the iterator with two lists `v1` and `v2`. 2. **`next(self) -> int:`** * Returns the next element in the zigzag sequence. * It moves cyclically across both lists until all elements are exhausted. * Raises an exception if there are no elements left to return. 3. **`has_next(self) -> bool:`** * Returns `True` if there are more elements to iterate, else returns `False`. # Constraints * The input lists `v1` and `v2` are non-negative integers. * The length of each list is at most (1000). # Input Two lists `v1` and `v2`. # Output Use the methods of the `ZigZagIterator2` class for interaction. # Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator2(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` Ensure your solution handles the edge cases efficiently, e.g., one or both lists being empty, significantly different list lengths, etc.","solution":"from collections import deque from typing import List class ZigZagIterator2: def __init__(self, v1: List[int], v2: List[int]) -> None: Initialize the iterator with two lists. self.queue = deque([(v, 0) for v in (v1, v2) if v]) def next(self) -> int: Return the next element in the zigzag sequence. if not self.has_next(): raise Exception(\\"No more elements\\") v, i = self.queue.popleft() if i + 1 < len(v): self.queue.append((v, i + 1)) return v[i] def has_next(self) -> bool: Returns True if there are more elements to iterate, else returns False. return bool(self.queue)"},{"question":"**Question**: Consider you are given a stack represented as a list in Python, where the last element of the list represents the top of the stack. Your task is to implement a function `is_sorted_alternative(stack)` that validates whether the stack is sorted in ascending order (smallest element at the bottom) without using an additional auxiliary stack or list. # Function Signature ```python def is_sorted_alternative(stack: List[int]) -> bool: pass ``` # Input * `stack`: A list of integers representing the stack, where `stack[-1]` is the top of the stack. # Output * Returns `True` if the stack is sorted in ascending order from bottom to top, otherwise returns `False`. # Constraints * The function should not use any additional stack or list to store elements. * You may use variables to store individual elements if required. * The input stack should remain unaltered after the function execution. # Examples 1. **Input**: `[1, 2, 3, 4, 5, 6]` - **Output**: `True` 2. **Input**: `[6, 3, 5, 1, 2, 4]` - **Output**: `False` 3. **Input**: `[3, 3, 3, 3]` - **Output**: `True` 4. **Input**: `[1]` - **Output**: `True` 5. **Input**: `[]` - **Output**: `True` # Explanation * Example 1: The stack `[1, 2, 3, 4, 5, 6]` is sorted in ascending order. * Example 2: The stack `[6, 3, 5, 1, 2, 4]` is not sorted in ascending order. * Example 3: The stack `[3, 3, 3, 3]` has all elements identical, hence considered sorted. * Example 4: A single element stack is trivially sorted. * Example 5: An empty stack is considered sorted by definition. You should ensure your solution is clear, correct, and does not alter the input stack.","solution":"def is_sorted_alternative(stack): Returns True if the stack is sorted in ascending order from bottom to top, otherwise returns False. for i in range(1, len(stack)): if stack[i-1] > stack[i]: return False return True"},{"question":"Count Left Children in a Binary Search Tree You are given a binary search tree, and your task is to count the number of left children. A left child is defined as a child node that is connected to its parent via the parent’s left pointer. Function Signature ```python def count_left_node(root): pass ``` Input - `root`: The root node of a binary search tree. You can assume `root` is of type `Node`. Output - Return an integer that represents the number of left children in the binary search tree. Constraints - The number of nodes in the binary search tree will be between `0` and `10^5`. Example ```python # Example Binary Search Tree # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 assert count_left_node(root) == 4 ``` Details 1. **Edge Cases**: * Consider an empty tree (`root == None`), which should return 0. * Consider trees with no left children, which should also return 0. 2. **Performance**: * Make sure your solution is able to handle large input sizes within reasonable time limits.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def count_left_node(root): if root is None: return 0 count = 0 if root.left is not None: count += 1 count += count_left_node(root.left) count += count_left_node(root.right) return count"},{"question":"You are provided with a hash table implementation that uses linear probing and supports dynamic resizing. Your task is to enhance the current hash table to support the following additional operations: 1. **`update(key, value)`**: Update the value for the given key if it already exists in the table. If the key does not exist, the method should do nothing. 2. **`keys()`**: Return a list of all the keys currently stored in the hash table. 3. **`values()`**: Return a list of all the values currently stored in the hash table. 4. **`items()`**: Return a list of tuples, where each tuple contains a key-value pair stored in the hash table. # Input and Output Format * **update(key, value) Method**: * Input: An integer `key` and an integer `value`. * Output: This method does not return anything. * **keys() Method**: * Input: None * Output: A list of integers representing keys in the hash table. * **values() Method**: * Input: None * Output: A list of integers representing values in the hash table. * **items() Method**: * Input: None * Output: A list of tuples, each containing two integers (key, value). # Constraints * Assume the keys and values are non-negative integers. * You should ensure that the hash table operates efficiently even after the new methods are added. * Your implementation should be compatible with the existing `HashTable` class and derivable for `ResizableHashTable`. # Example Here\'s how the modified `ResizableHashTable` should function: ```python ht = ResizableHashTable() ht.put(1, 10) ht.put(2, 20) ht.put(3, 30) ht.update(2, 25) print(ht.keys()) # Output: [1, 2, 3] print(ht.values()) # Output: [10, 25, 30] print(ht.items()) # Output: [(1, 10), (2, 25), (3, 30)] ``` # Note Your solution will be evaluated based on correctness, efficiency, and code readability. Ensure that you handle edge cases and think about performance implications of your design.","solution":"class HashTable: def __init__(self): self.size = 8 # Initial capacity of the hash table self.count = 0 # Number of elements in the hash table self.table = [None] * self.size def _hash(self, key): return key % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item: self.put(item[0], item[1]) def put(self, key, value): if self.count / self.size >= 0.7: self._resize() index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size raise KeyError(f\\"Key {key} not found in HashTable\\") def delete(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return index = (index + 1) % self.size raise KeyError(f\\"Key {key} not found in HashTable\\") def update(self, key, value): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size def keys(self): return [item[0] for item in self.table if item] def values(self): return [item[1] for item in self.table if item] def items(self): return [(item[0], item[1]) for item in self.table if item] class ResizableHashTable(HashTable): pass"},{"question":"# Tree Height Calculation In this assessment, you are required to implement a function that calculates the height of a binary tree. The height of a tree is defined as the number of levels it has. Input: * The input will be a reference to the root node of a binary tree. Output: * The function should return an integer representing the height of the tree. Constraints: * The binary tree can have between 0 and 10^4 nodes. * The values within the tree nodes can be any integer. * The node structure and methods for inserting nodes can be assumed to be pre-implemented and provided (you don’t need to implement them from scratch). Performance Requirements: * Time Complexity: O(n), where n is the number of nodes. * Space Complexity: O(h), where h is the height of the tree. Function Signature: ```python def height(root: Node) -> int: # Your code here ``` # Example: Consider the following binary search tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` * The height of this tree is 4. ```python # The tree is pre-created for you: from bst import Node, bst class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, value): self.left = None self.right = None self.value = value def height(root: Node) -> int: Calculate the height of a binary tree. Parameters: root (Node): The root node of the binary tree. Returns: int: The height of the tree. if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return 1 + max(left_height, right_height)"},{"question":"You are given a linked list which might contain a cycle. Your task is to determine the node at which the cycle begins, if any. Implement the function `find_cycle_start_node(head: Node) -> Node` using Floyd’s Cycle-Finding Algorithm. # Function Signature: ```python def find_cycle_start_node(head: Node) -> Node: pass ``` # Input: - `head`: The head node of the linked list (`Node`). # Output: - The node where the cycle begins, if the cycle exists. If there is no cycle, return `None`. # Constraints: - Do not modify the linked list. - Aim for O(n) time complexity and O(1) space complexity. # Scenario: Consider a network where nodes are routers. If there\'s a network loop, it can cause undesirable effects. This algorithm helps to identify where such a loop starts to remedy the issue. # Example: ```python # Create linked list => A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node assert find_cycle_start_node(head).val == \'C\' ``` # Notes: 1. The linked list is composed of `Node` objects, where each node contains a `val` and a `next` pointer to the next node in the list. 2. The function should handle cases where the list is empty or does not contain a cycle. 3. Write thorough test cases to validate your solution.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def find_cycle_start_node(head: Node) -> Node: if head is None or head.next is None: return None slow = head fast = head # Detect the cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle detected return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# URL Domain Name Extraction **Context**: You\'re working on a web analytics tool that processes large volumes of URL data. A critical task involves extracting the core domain name from each URL to aggregate statistics by domain. For simplicity in your tool, assume that URLs are standardized and may or may not include \\"http\\", \\"https\\", or \\"www\\" prefixes. **Objective**: Implement a function `extract_domain_name(url: str) -> str` that takes a URL string as the input and returns the core domain name without any \\"www\\", \\"http\\", \\"https\\" prefixes, and without any subdomains. **Function Signature**: ```python def extract_domain_name(url: str) -> str: pass ``` **Input**: - `url` (str): A standardized URL string (e.g., \\"http://github.com\\", \\"https://www.cnet.com\\"). **Output**: - `str`: The core domain name (e.g., \\"github\\", \\"cnet\\"). **Constraints**: - The URL will contain only ASCII characters. - The URL will be non-empty and will always have at least a top-level domain (e.g., .com, .org). - Do not use any built-in libraries such as `re` (regular expression) or `urlparse`, except the `.split()` built-in function. **Examples**: ```python # Example 1 assert extract_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" # Example 2 assert extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" # Example 3 assert extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" ``` **Performance Requirements**: - Ensure the function executes in constant time and space for typical URL input sizes. Implement the `extract_domain_name` function to meet the specified requirements.","solution":"def extract_domain_name(url: str) -> str: Extracts the core domain name from a given URL. Args: url (str): The standardized URL string. Returns: str: The core domain name. # Remove \'http://\', \'https://\' if url.startswith(\\"http://\\"): url = url[len(\\"http://\\"):] elif url.startswith(\\"https://\\"): url = url[len(\\"https://\\"):] # Remove \'www.\' if url.startswith(\\"www.\\"): url = url[len(\\"www.\\"):] # Split by \'/\' and take the first part which is the domain domain = url.split(\'/\')[0] # Split by \'.\' and return the first part which is the core domain return domain.split(\'.\')[0]"},{"question":"# Combinatorial Calculation with Optimization You are tasked with implementing a function to compute the number of ways to choose `r` items from `n` items (also known as combinations or binomial coefficients, denoted as `nCr`). The number of combinations can be computed using a recursive approach and optimized further using memoization. **Your task:** 1. Write a function `combination(n, r)` that calculates the number of combinations using a pure recursive approach. 2. Write a function `combination_memo(n, r)` that calculates the number of combinations using a memoized recursive approach. Detailed Requirements: 1. **Function:** `combination(n, r)` * **Input:** Two integers `n` and `r` (0 ≤ r ≤ n). * **Output:** An integer representing `nCr`. 2. **Function:** `combination_memo(n, r)` * **Input:** Two integers `n` and `r` (0 ≤ r ≤ n). * **Output:** An integer representing `nCr` using memoization to optimize performance. **Constraints:** - The values of `n` and `r` will be non-negative integers where 0 ≤ r ≤ n ≤ 30. - Aim for an optimized solution with minimal execution time. **Performance Requirements:** - The `combination_memo(n, r)` function should handle the higher limits of input efficiently. Examples: ```python def test_combination_functions(): assert combination(5, 3) == 10, \\"Test case 1 failed\\" assert combination(10, 2) == 45, \\"Test case 2 failed\\" assert combination(20, 0) == 1, \\"Test case 3 failed\\" assert combination_memo(5, 3) == 10, \\"Test case 4 failed\\" assert combination_memo(10, 2) == 45, \\"Test case 5 failed\\" assert combination_memo(20, 0) == 1, \\"Test case 6 failed\\" test_combination_functions() ``` **Hints:** - For `combination(n, r)`, ensure you implement the base cases properly: if `n == r` or `r == 0`, return 1. - For `combination_memo(n, r)`, use a dictionary to store computed results for given n and r pairs.","solution":"def combination(n, r): Returns the number of ways to choose r items from n items using pure recursion. if n == r or r == 0: return 1 return combination(n - 1, r - 1) + combination(n - 1, r) def combination_memo(n, r, memo=None): Returns the number of ways to choose r items from n items using a memoized recursive approach. if memo is None: memo = {} if (n, r) in memo: return memo[(n, r)] if n == r or r == 0: memo[(n, r)] = 1 else: memo[(n, r)] = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) return memo[(n, r)]"},{"question":"# Coding Task: Implementing a Robust Bellman-Ford Algorithm Scenario You are tasked to implement a function to determine the shortest paths from a source vertex to all other vertices in a weighted graph using the Bellman-Ford algorithm. Additionally, your implementation should be able to detect if there are any negative weight cycles reachable from the source vertex. Requirements - Your function should handle graphs with negative weights. - If a negative weight cycle is detected, the function should return `False`. - If no negative weight cycles are detected, the function should return the shortest path distances from the source to all other vertices. Function Signature ```python def robust_bellman_ford(graph: dict, source: str) -> Union[bool, dict]: Parameters: - graph (dict): A dictionary representing the graph where keys are vertices and values are dictionaries showing adjacent vertices and their edge weights. - source (str): The source vertex. Returns: - Union[bool, dict]: Returns False if a negative weight cycle is detected, otherwise returns a dictionary containing the shortest path distances from the source to every vertex. ``` Input 1. `graph`: Dictionary where keys are vertex identifiers (strings) and values are dictionaries with neighbors as keys and edge weights as values. 2. `source`: String representing the source vertex. Output - Returns `False` if a negative weight cycle is detected. - Otherwise, returns a dictionary with the shortest path distances from the `source` to each vertex. Example ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3}, } result = robust_bellman_ford(graph, \'a\') # Expected Output: {\'a\': 0, \'b\': 4, \'e\': 7, \'c\': 9, \'d\': 2} (example distances) ``` Note: In case of a negative weight cycle reachable from the source, the output should be `False`. Constraints - The graph will have at most 500 vertices and 10,000 edges. - Edge weights will be integers. Implement the function efficiently keeping in mind the time and space complexity.","solution":"def robust_bellman_ford(graph, source): Parameters: - graph (dict): A dictionary representing the graph where keys are vertices and values are dictionaries showing adjacent vertices and their edge weights. - source (str): The source vertex. Returns: - Union[bool, dict]: Returns False if a negative weight cycle is detected, otherwise returns a dictionary containing the shortest path distances from the source to every vertex. distances = {vertex: float(\'inf\') for vertex in graph} distances[source] = 0 for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distances[u] + graph[u][v] < distances[v]: distances[v] = distances[u] + graph[u][v] for u in graph: for v in graph[u]: if distances[u] + graph[u][v] < distances[v]: return False return distances"},{"question":"# Problem: Prime Number Verifier Context: You are working on a piece of software that requires checking the primality of multiple numbers efficiently. Prime numbers have significant applications in fields like cryptography, number theory, and hashing algorithms. Your task is to implement a function that verifies whether given numbers are prime. Task: Write a function `is_prime_list(nums)` that takes a list of integers and returns a list of boolean values, each indicating if the respective number in the input list is prime. Input: * `nums`: A list of ( n ) integers ((1 leq n leq 10^5)). Output: * A list of ( n ) boolean values, where each boolean indicates whether the corresponding integer in the input list is a prime number. Constraints: * Elements of the list `nums` can range between 1 and ( 10^9 ). Performance Requirements: * The function must efficiently handle the upper constraint limits using reasonable computational resources. Example: ```python >>> is_prime_list([2, 3, 4, 5, 10, 13, 17, 19, 23, 24]) [True, True, False, True, False, True, True, True, True, False] ``` Function Signature: ```python def is_prime_list(nums: List[int]) -> List[bool]: pass ``` Notes: * You may assume the input list will always be non-empty. * Avoid using naive methods; leverage the discussed principles for an efficient algorithm.","solution":"from typing import List import math def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_prime_list(nums: List[int]) -> List[bool]: return [is_prime(num) for num in nums]"},{"question":"# Comb Sort Optimization Challenge Comb Sort is a fundamental sorting algorithm that enhances Bubble Sort by introducing a gap value, which improves its performance by eliminating turtles (small values near the end of the list) early in the sorting process. Task Implement a more optimized version of the Comb Sort algorithm. 1. **Optimize the shrink factor**: Instead of using the fixed shrink factor of 1.3, allow the shrink factor to be adjusted based on the data distribution. 2. **Early Exit Strategy**: Implement an early exit mechanism that checks for array sorted status dynamically, not just when gap equals 1. Input * An unsorted list of integers `arr` of size `n` (1 ≤ n ≤ 10^5) Output * The sorted list in ascending order. Constraints * Optimize for both time and space complexity. * Must handle edge cases such as: * Already sorted array. * Array with all identical elements. * Empty array (return the same empty array). Function Signature ```python def optimized_comb_sort(arr): pass ``` Example ```python # Example 1 arr = [5, 3, 1, 9, 8, 2, 4, 7, 6] print(optimized_comb_sort(arr)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 arr = [10, -2, 33, 0, -5] print(optimized_comb_sort(arr)) # Output: [-5, -2, 0, 10, 33] ```","solution":"def optimized_comb_sort(arr): if not arr: return arr def get_next_gap(gap): # This shrink factor is a float shrink_factor = 1.247330950103979 new_gap = int(gap / shrink_factor) return max(1, new_gap) n = len(arr) gap = n sorted = False while not sorted: gap = get_next_gap(gap) sorted = gap == 1 for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Objective Implement a specialized queue that supports all the operations of a standard queue, along with an additional feature of \\"reversing\\" all the elements currently in the queue in constant time. # Problem Statement You are tasked with implementing a `ReversibleQueue` class in Python that extends the basic functionality of a queue (either using arrays or linked lists) to also allow reversing the order of elements currently in the queue. # Core Requirements 1. **ReversibleQueue()**: Creates an empty queue. 2. **enqueue(item)**: Adds a new item to the rear of the queue. 3. **dequeue()**: Removes the front item from the queue. 4. **is_empty()**: Tests whether the queue is empty. 5. **size()**: Returns the number of items in the queue. 6. **peek()**: Returns the front element of the queue. 7. **reverse()**: Reverses all the elements currently in the queue in constant time. # Detailed Specification: * Implement the `ReversibleQueue` class that should function as defined. * The `reverse` operation should not utilize additional data structures (e.g., no auxiliary stacks or queues). # Input/Output 1. **enqueue(item)**: * **Input**: Any type. * **Output**: None. 2. **dequeue()**: * **Input**: None. * **Output**: The dequeued item. 3. **is_empty()**: * **Input**: None. * **Output**: Boolean. 4. **size()**: * **Input**: None. * **Output**: Integer. 5. **peek()**: * **Input**: None. * **Output**: The front item. 6. **reverse()**: * **Input**: None. * **Output**: None. # Constraints * Do not use additional auxiliary data structures for the reverse operation. * Focus on efficient time and space complexities. # Example ```python q = ReversibleQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.peek()) # Output: 1 q.reverse() print(q.peek()) # Output: 3 print(q.dequeue()) # Output: 3 print(q.dequeue()) # Output: 2 print(q.dequeue()) # Output: 1 ``` *Note*: Ensure your implementation of `reverse` method works in constant time.","solution":"class ReversibleQueue: def __init__(self): Initialize the queue. We use a list to store the elements. A flag \'reversed\' is used to indicate the state of the queue. self.queue = [] self.reversed = False def enqueue(self, item): Add an item to the rear of the queue. If the queue is in reversed state, we insert at the front. if self.reversed: self.queue.insert(0, item) else: self.queue.append(item) def dequeue(self): Remove and return the item at the front of the queue. If the queue is in reversed state, we remove from the rear. if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") if self.reversed: return self.queue.pop() else: return self.queue.pop(0) def is_empty(self): Check if the queue is empty. return len(self.queue) == 0 def size(self): Return the number of items in the queue. return len(self.queue) def peek(self): Return the item at the front of the queue without removing it. If the queue is in reversed state, we return the last item. if self.is_empty(): raise IndexError(\\"peek from empty queue\\") if self.reversed: return self.queue[-1] else: return self.queue[0] def reverse(self): Reverse the order of elements in the queue in constant time. This is achieved by toggling the \'reversed\' flag. self.reversed = not self.reversed"},{"question":"# Cocktail Shaker Sort Implementation Problem Description You are asked to implement the Cocktail Shaker Sort algorithm. The algorithm should sort a list of integers in ascending order. This algorithm is a variation of Bubble Sort and works by traversing the array in both directions alternately. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers. The list may contain negative or positive integers and can be of any length (including zero). Output * Returns a list of integers sorted in ascending order. Constraints * The list `arr` contains at most 10^4 elements. * The integer elements in the list range from -10^6 to 10^6. Performance Requirements * The implementation should efficiently handle cases where the list is nearly sorted. * Avoid unnecessary swaps to maintain low overhead. Scenario A store manager wishes to sort the daily sales data of products. The data, which consists of both positive and negative sales figures, needs to be sorted to analyze the sales trend easily. Implementing the Cocktail Shaker Sort will help in understanding the importance of sorting algorithms and their practical applications in a real-world scenario. Example Cases ```python # Example 1 assert cocktail_shaker_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 assert cocktail_shaker_sort([10, -1, 2, 8, 6, 7, 3]) == [-1, 2, 3, 6, 7, 8, 10] # Example 3 assert cocktail_shaker_sort([1]) == [1] # Example 4 assert cocktail_shaker_sort([]) == [] ``` Write a function `cocktail_shaker_sort` with the above function signature that sorts the array as described.","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break end -= 1 swapped = False for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"You are given a binary tree and a sum. Your task is to write a function `path_sum` that finds all root-to-leaf paths where each path\'s sum equals the given sum. You should implement this using Depth-First Search (DFS), both with recursion and with an explicit stack. Additionally, implement a solution using Breadth-First Search (BFS) with a queue. # Function Signature ```python def path_sum(root, sum): pass def path_sum_stack(root, sum): pass def path_sum_queue(root, sum): pass ``` # Input and Output * **Input**: * `root`: The root node of the binary tree. * `sum`: An integer representing the target sum. * **Output**: * A list of lists containing all root-to-leaf paths where each path\'s sum equals the given sum. # Example ```python # Given the below binary tree and sum = 22, # 5 # / # 4 8 # / / # 11 13 4 # / / # 7 2 5 1 # The function call should return: # [ # [5,4,11,2], # [5,8,4,5] # ] # Assuming the tree nodes are represented as: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(5) root.left = TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2))) root.right = TreeNode(8, TreeNode(13), TreeNode(4, TreeNode(5), TreeNode(1))) assert path_sum(root, 22) == [[5,4,11,2], [5,8,4,5]] assert path_sum_stack(root, 22) == [[5,4,11,2], [5,8,4,5]] assert path_sum_queue(root, 22) == [[5,4,11,2], [5,8,4,5]] ``` # Constraints * The number of nodes in the binary tree is in the range `[0, 1000]`. * `-1000 <= Node.val <= 1000` * `-1000 <= sum <= 10000` # Notes * Handle edge cases like an empty tree, single node tree, all left children, all right children, etc. * Ensure your solutions are efficient and handle large input sizes within reasonable time and space limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): Returns all root-to-leaf paths where each path\'s sum equals the given sum using DFS. def dfs(node, current_sum, path, paths): if not node: return current_sum += node.val path.append(node.val) # Check if we are at a leaf node and the sum matches if not node.left and not node.right and current_sum == target_sum: paths.append(path.copy()) # Recursive DFS on left and right children dfs(node.left, current_sum, path, paths) dfs(node.right, current_sum, path, paths) # Backtrack path.pop() paths = [] dfs(root, 0, [], paths) return paths def path_sum_stack(root, target_sum): Returns all root-to-leaf paths where each path\'s sum equals the given sum using DFS with an explicit stack. if not root: return [] result = [] stack = [(root, root.val, [root.val])] while stack: node, current_sum, path = stack.pop() if not node.left and not node.right and current_sum == target_sum: result.append(path) if node.right: stack.append((node.right, current_sum + node.right.val, path + [node.right.val])) if node.left: stack.append((node.left, current_sum + node.left.val, path + [node.left.val])) return result def path_sum_queue(root, target_sum): Returns all root-to-leaf paths where each path\'s sum equals the given sum using BFS with a queue. if not root: return [] result = [] queue = [(root, root.val, [root.val])] while queue: node, current_sum, path = queue.pop(0) if not node.left and not node.right and current_sum == target_sum: result.append(path) if node.left: queue.append((node.left, current_sum + node.left.val, path + [node.left.val])) if node.right: queue.append((node.right, current_sum + node.right.val, path + [node.right.val])) return result"},{"question":"You are given a list of strings and need to implement two methods: `encode` and `decode`. The `encode` method should take a list of strings and return an encoded single string. The `decode` method should take an encoded single string and return the original list of strings. Function Specifications: 1. **encode**: - **Input**: A list of strings `strs` (List[str]) where 0 <= len(strs) <= 1000 and the length of each string in the list can be between 0 and 1000 characters. - **Output**: A single encoded string (str). 2. **decode**: - **Input**: A single encoded string `s` (str). - **Output**: The original list of strings (List[str]). Both methods should handle the possibility of empty strings and avoid errors due to malformed input strings. Constraints: * You cannot use any built-in serialization utilities such as `pickle` or `json`. * The encoded string should be able to handle any alphabetical and numerical strings. Example: ```python strs = [\\"Hello\\", \\"World\\"] encoded_str = encode(strs) # encoded_str should be a single string that encodes the list [\\"Hello\\", \\"World\\"] decoded_strs = decode(encoded_str) # decoded_strs should be [\\"Hello\\", \\"World\\"] ``` Additionally, your implementation should handle: * Edge cases of empty lists and strings. * Correct decoding of strings regardless of the content. Write your implementation of `encode` and `decode` below. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str pass def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] pass ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded = [] for string in strs: encoded.append(f\\"{len(string)}:{string}\\") return \'\'.join(encoded) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i = 0 decoded = [] while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) j += 1 decoded.append(s[j:j+length]) i = j + length return decoded"},{"question":"# Comb Sort Implementation Challenge You are required to implement the `comb_sort` algorithm for sorting an array of integers in ascending order. Input: - An array `arr` of integers (0 <= arr[i] <= 10^6) - The length of the array (0 < N <= 10^4) Output: - The array sorted in ascending order. # Constraints: - Your implementation should have a worst-case time complexity of O(N^2). - You should minimize the space complexity; aim for O(1) additional space. # Examples: 1. **Input**: `[8, 4, 1, 56, 3, -44, 23, -6, 28, 0]` **Output**: `[-44, -6, 0, 1, 3, 4, 8, 23, 28, 56]` 2. **Input**: `[5, 3, 1, 2, 4]` **Output**: `[1, 2, 3, 4, 5]` 3. **Input**: `[20, -4, 5, 5, 5, 12]` **Output**: `[-4, 5, 5, 5, 12, 20]` # Instructions: 1. Implement the `comb_sort` function that takes an array as input and returns the sorted array. 2. Consider edge cases, such as an empty array or an array with only one element. 3. Ensure your solution is efficient and adheres to the given constraints. # Function Signature ```python def comb_sort(arr): # Your code here ```","solution":"def comb_sort(arr): Sorts an array of integers in ascending order using the comb sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers in ascending order. def get_next_gap(gap): Calculate the next gap size. gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Scenario You are tasked with optimizing a database application\'s performance by using a hash table to handle key-value pair storage efficiently. The provided code snippet defines a `SeparateChainingHashTable` class for managing such data efficiently in average cases. However, you should improve and justify performance and robustness of critical operations. # Task Implement a new method called `resize` in the `SeparateChainingHashTable` class to handle dynamic resizing and rehashing of the table, which is triggered to improve table performance. # Specifications 1. **Function:** `resize` 2. **Input:** No direct input (implicit by self and triggered by conditions like high load factor) 3. **Output:** None (Modifies the internal table structure to accommodate resizing) 4. **Constraints**: * The resize method should be automatically called when the load factor exceeds 0.7. * The new size should be the next prime number greater than twice the current number of buckets to minimize collision probability. * Ensure that existing key-value pairs are correctly rehashed and repositioned in the new table. Method to be implemented: ```python class SeparateChainingHashTable(object): ... def resize(self): # Your code goes here pass ... # Example Usage: table = SeparateChainingHashTable() for i in range(20): table.put(f\\"key{i}\\", i) print(len(table)) # should output 20 ``` # Additional Constraints * The `hash` function should be modified to work dynamically with the changing table size. * Use a helper function to find the next prime number for the new table size. * Implement robust checks to ensure keys are properly repositioned.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=4): self.capacity = initial_capacity self.size = 0 self.buckets = [[] for _ in range(self.capacity)] def hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity > 0.7: self.resize() bucket_index = self.hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): bucket_index = self.hash(key) bucket = self.buckets[bucket_index] for k, v in bucket: if k == key: return v return None def resize(self): new_capacity = self._next_prime(2 * self.capacity) new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for key, value in bucket: new_bucket_index = hash(key) % new_capacity new_buckets[new_bucket_index].append((key, value)) self.capacity = new_capacity self.buckets = new_buckets def _is_prime(self, n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def _next_prime(self, n): while not self._is_prime(n): n += 1 return n def __len__(self): return self.size"},{"question":"Implement a function that performs an \\"augmented insertion sort\\" on an array but uses binary search (`search_insert`) to find the correct insertion position for each element. Description You are provided with a function `search_insert(array, val)` that, given a sorted array and a target value, returns the index if the target is found. If not, it returns the index where it would be if it were inserted in order. Using this helper function, write a function to sort an unsorted array using insertion sort, but instead of the usual linear search for finding the insertion position, use the `search_insert` function. Function Signature ```python def augmented_insertion_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, where the number of elements `n` is in the range `[0, 10^4]`. Output * The same list of integers, sorted in non-decreasing order. Constraints * You must use the `search_insert` function to determine the position where each element is to be inserted. * Your solution should be performant to handle up to 10,000 elements. Example ```python # Example Input: arr = [64, 34, 25, 12, 22, 11, 90] # Example Output: [11, 12, 22, 25, 34, 64, 90] ```","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left def augmented_insertion_sort(arr: List[int]) -> List[int]: Sorts an array using an augmented insertion sort that uses binary search to find the correct insertion position. for i in range(1, len(arr)): key = arr[i] # Find the position to insert the current element pos = search_insert(arr[:i], key) # Move all elements to the right to make space for the element arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:] return arr"},{"question":"Flatten Nested Arrays Context In modern applications, data often comes in complex nested formats which are difficult to manipulate. Therefore, it is crucial to convert such nested structures into simpler, non-nested formats. One such problem is flattening nested arrays. Task You are required to implement a function that takes a nested list (which may contain further nested lists) and returns a single flattened list. Moreover, you should implement a generator-based version that yields elements one by one without creating the entire list in memory. Function Signature ```python def flatten(input_arr: list) -> list: # Your implementation here def flatten_iter(input_arr: list) -> iter: # Your implementation here ``` Input: * `input_arr`: A list which may contain integers, strings, and nested lists of similar types. Example: `[1, [2, [3, [4, 5]], 6], 7]` Output: * For `flatten()`: A list with all elements from input_arr, flattened. Example: `[1, 2, 3, 4, 5, 6, 7]` * For `flatten_iter()`: An iterator which yields elements one by one from the flattened input_arr. Constraints: - Elements can be nested to any depth. - The array can contain integers, strings, lists, and other basic types (but not objects or unsupported types). - Strings should not be split into characters. Example: ```python # Example function usage print(flatten([1, [2, [3, [4, 5]], 6], 7])) # Output: [1, 2, 3, 4, 5, 6, 7] print(list(flatten_iter([1, [2, [3, [4, 5]], 6], 7]))) # Output: [1, 2, 3, 4, 5, 6, 7] ``` Additional Notes: - Consider edge cases with empty arrays, arrays with single elements, and mixed data types. - Ensure efficient memory usage especially in the generator-based version for large datasets.","solution":"def flatten(input_arr): Flattens a nested list into a single list. result = [] for element in input_arr: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result def flatten_iter(input_arr): Returns an iterator that yields elements from a flattened nested list. for element in input_arr: if isinstance(element, list): yield from flatten_iter(element) else: yield element"},{"question":"# Problem: Enhanced Tree Printer You are provided with a nested dictionary representing a tree structure where each key directly corresponds to a node, and the associated list represents its direct children. Your task is to modify the given `tree_print` function to enhance it in the following ways: 1. **Depth Tracking**: - Indent each level of the tree based on its depth. Use two spaces for each depth level to denote the hierarchy. 2. **Handling Mixed Data Types**: - Print non-string values but indent them similarly based on their depth. 3. **Sorted Output**: - Sort the keys in the dictionary based on alphanumeric ordering before printing, to maintain a tidy representation. # Function Signature ```python def enhanced_tree_print(tree: dict) -> None: # Your code here ``` # Input * `tree` (dict): A nested dictionary representing the tree structure. # Output * None. The function should print the tree structure. # Example ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } enhanced_tree_print(tree) ``` Expected Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Constraints * The dictionary and its nested structure can be of varied depth. * Keys will be alphanumeric. * Values can include strings, integers, or nested dictionaries. **Note**: Your implementation should ensure the output maintains proper readability with correct indentations and ordered output.","solution":"def enhanced_tree_print(tree, level=0): Prints the tree structure, indenting each level based on its depth, handling mixed data types, and sorting the keys alphanumerically. indent = \' \' * level # Indent for current level for key in sorted(tree.keys()): print(f\\"{indent}{key}\\", end=\'\') if isinstance(tree[key], dict): # If the value is a nested dictionary print(\\" ->\\") enhanced_tree_print(tree[key], level + 1) elif isinstance(tree[key], list): # If the value is a list for item in tree[key]: if isinstance(item, (str, int)): print(f\\" -> {item}\\", end=\'\') elif isinstance(item, dict): print(\\" ->\\") enhanced_tree_print(item, level + 1) print() elif isinstance(tree[key], (str, int)): print(f\\" -> {tree[key]}\\") else: print(f\\" -> {tree[key]}\\")"},{"question":"# Problem You are given a node in a singly linked list and your task is to delete that node. The provided method does not handle the tail node directly, and the list must remain connected. The operation should be done in constant time. # Function Signature ```python def delete_node(node: Node) -> None: ``` # Constraints - You may assume the node to be deleted is not the tail node. - The method raises a `ValueError` if the `node` is `None` or its `next` node is `None`. # Input - A node within a singly linked list, but not the last node. # Output - The linked list should have the specified node removed. # Example Suppose the linked list is 1 -> 2 -> 3 -> 4 -> 5 and you are given the third node with value 3, calling your function should modify the linked list to become 1 -> 2 -> 4 -> 5. # Scenario Imagine you are working on a compact memory management system where quick removal of nodes is required without traversing the entire list. This function would be highly beneficial in such scenarios for efficient memory management.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def delete_node(node: Node) -> None: Deletes the given node (except the tail) from the linked list. This function copies the data from the next node into the current node, and then bypasses the next node, effectively deleting it in constant time. if node is None or node.next is None: raise ValueError(\\"Cannot delete the tail or a None node.\\") node.value = node.next.value node.next = node.next.next"},{"question":"# Problem Description: You are working on a project requiring calculation of combinations frequently. Implement both recursive and memoized versions of combination calculation to compare their performance. Input * Two integers, `n` (number of total items) and `r` (number of chosen items such that 0 ≤ r ≤ n). Output * An integer value representing the combination of choosing `r` items out of `n`. Constraints * 1 ≤ n ≤ 50 * 0 ≤ r ≤ n Performance Requirements * Ensure the function is optimized for the given constraints to handle inputs efficiently. # Function Signature * You need to implement the function `combination(n, r)` for recursive computation. * You need to implement the function `combination_memo(n, r)` using the memoization technique. # Example ```python # Basic Test Cases print(combination(5, 2)) # Output: 10 print(combination(10, 5)) # Output: 252 print(combination_memo(5, 2)) # Output: 10 print(combination_memo(10, 5)) # Output: 252 ``` Explanation * For `combination(5, 2)`: You can choose 2 items from 5 in 10 different ways. * For `combination(10, 5)`: You can choose 5 items from 10 in 252 different ways. Hints: 1. Use the property `comb(n, r) = comb(n-1, r-1) + comb(n-1, r)` for recursive calculation. 2. Use a dictionary to store already calculated values for memoization to avoid redundant calculations.","solution":"def combination(n, r): Recursive calculation of combination nCr using Pascal\'s Triangle property. if r == 0 or r == n: return 1 return combination(n-1, r-1) + combination(n-1, r) def combination_memo(n, r, memo=None): Memoized calculation of combination nCr to optimize performance. if memo is None: memo = {} if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = combination_memo(n-1, r-1, memo) + combination_memo(n-1, r, memo) return memo[(n, r)]"},{"question":"# Scenario You are in charge of implementing a schedule merging system for a university. Students have their lecture schedules represented as sorted linked lists where each node contains a lecture start time. You need to merge multiple sorted schedules into a single sorted schedule for better planning and coordination. # Task You need to write a function that merges two sorted linked lists representing students\' lecture schedules into a single sorted linked list. # Function Signature ```python def merge_two_schedules(l1: \'Node\', l2: \'Node\') -> \'Node\': # Your code here ``` # Input - `l1`: The head of the first linked list. - `l2`: The head of the second linked list. # Output - The head of a new merged sorted linked list. # Constraints - The values in the nodes will be integer timestamps representing lecture start times. - The linked lists are already sorted. - The linked lists may vary in length including being empty. # Example ```python # Suppose you have the following linked lists: # l1: 8 -> 10 -> 12 # l2: 9 -> 11 -> 13 # Example Input: l1 = Node(8) l1.next = Node(10) l1.next.next = Node(12) l2 = Node(9) l2.next = Node(11) l2.next.next = Node(13) # Expected Output: # 8 -> 9 -> 10 -> 11 -> 12 -> 13 # The function should return the head of the merged and sorted linked list. ``` # Notes - Ensure that your function handles all potential edge cases, such as one or both lists being empty. - Optimize your solution to handle very large linked lists.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_two_schedules(l1: \'Node\', l2: \'Node\') -> \'Node\': dummy = Node() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # If either list still has nodes, append them tail.next = l1 if l1 else l2 return dummy.next"},{"question":"# Balanced Binary Search Tree Implementation Context A company needs an efficient system to handle dynamic data storage, allowing quick insertions, deletions, and search operations. The current Binary Search Tree implementation sometimes degrades in performance due to lack of balancing, turning the time complexities into O(N). To overcome this, the company wants you to implement an AVL (Adelson-Velsky and Landis) Tree, a type of self-balancing binary search tree. Task Implement an AVL Tree supporting the following methods: 1. **Insert(data)**: Inserts an element into the AVL Tree. Ensure the tree remains balanced after each insertion. 2. **Delete(data)**: Removes an element from the AVL Tree. Ensure the tree remains balanced after each deletion. 3. **Search(data)**: Searches for the element in the AVL Tree. 4. **Size()**: Returns the number of elements in the AVL Tree. 5. **Traversal(order)**: Returns the elements of the AVL Tree in the specified order: `preorder`, `inorder`, or `postorder`. Method Signatures ```python class AVLTree: def __init__(self): # Constructor, initialize your AVL Tree here. def insert(self, data: int) -> None: # Inserts data into the AVL Tree def delete(self, data: int) -> None: # Deletes data from the AVL Tree def search(self, data: int) -> bool: # Searches for data in the AVL Tree def size(self) -> int: # Returns the number of elements in the AVL Tree def traversal(self, order: str) -> List[int]: # Returns the elements of the AVL Tree in the specified traversal order (\'preorder\', \'inorder\', \'postorder\') ``` Constraints: - Each data insertion will be a unique integer. - The traversal method must yield results in a recursive manner. - The AVL Tree must balance itself after every insertion and deletion. Example ```python avl_tree = AVLTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) print(avl_tree.size()) # Output: 3 print(avl_tree.traversal(\'inorder\')) # Output: [5, 10, 20] print(avl_tree.search(15)) # Output: False avl_tree.delete(20) print(avl_tree.traversal(\'inorder\')) # Output: [5, 10] ``` Testing Unit tests will be conducted to test the above methods extensively to ensure correctness and efficiency of the AVL Tree implementation.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None self.node_count = 0 def insert(self, data): self.root = self._insert(self.root, data) self.node_count += 1 def delete(self, data): self.root = self._delete(self.root, data) def search(self, data): return self._search(self.root, data) def size(self): return self.node_count def traversal(self, order): if order == \'preorder\': return self._preorder_traversal(self.root) elif order == \'inorder\': return self._inorder_traversal(self.root) elif order == \'postorder\': return self._postorder_traversal(self.root) else: raise ValueError(f\\"Unknown order: {order}\\") def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _delete(self, root, key): if not root: return root if key < root.key: root.left = self._delete(root.left, key) elif key > root.key: root.right = self._delete(root.right, key) else: if not root.left: temp = root.right root = None self.node_count -= 1 return temp elif not root.right: temp = root.left root = None self.node_count -= 1 return temp temp = self._get_min_value_node(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) if not root: return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and self._get_balance(root.left) >= 0: return self._right_rotate(root) if balance > 1 and self._get_balance(root.left) < 0: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and self._get_balance(root.right) <= 0: return self._left_rotate(root) if balance < -1 and self._get_balance(root.right) > 0: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def _search(self, root, key): if root is None or root.key == key: return root is not None if key < root.key: return self._search(root.left, key) return self._search(root.right, key) def _preorder_traversal(self, root): return [root.key] + self._preorder_traversal(root.left) + self._preorder_traversal(root.right) if root else [] def _inorder_traversal(self, root): return self._inorder_traversal(root.left) + [root.key] + self._inorder_traversal(root.right) if root else [] def _postorder_traversal(self, root): return self._postorder_traversal(root.left) + self._postorder_traversal(root.right) + [root.key] if root else [] def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_min_value_node(self, root): if root is None or root.left is None: return root return self._get_min_value_node(root.left)"},{"question":"# Question Scenario: You are developing a system that dynamically maintains an ordered sequence of elements based on user input. The system should allow users to add new elements, remove the top element, and retrieve the current maximum element efficiently. The elements must always be maintained in ascending order. Challenge: Implement a class `OrderedStack` that maintains an ordered stack as described, supporting the following operations: 1. **push(item)**: Insert an item into the stack while maintaining the sorted order. 2. **pop()**: Remove and return the element from the top of the stack. Raise an IndexError if the stack is empty. 3. **peek()**: Return the current top element without altering the stack. Raise an IndexError if the stack is empty. 4. **is_empty()**: Return a boolean indicating whether the stack is empty. 5. **size()**: Return the number of elements in the stack. Constraints: * `item` will be an integer. * Your implementation should optimize for the `pop` operation to be O(1). * Manage edge cases appropriately, such as handling an empty stack on `pop` and `peek`. Example Interaction: ```python stack = OrderedStack() stack.push(5) stack.push(3) stack.push(8) stack.push(2) print(stack.peek()) # Output: 8 print(stack.pop()) # Output: 8 print(stack.peek()) # Output: 5 stack.push(4) print(stack.peek()) # Output: 5 print(stack.size()) # Output: 4 print(stack.is_empty()) # Output: False ``` Provide code for the class `OrderedStack` that includes these methods.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): Insert an item into the stack while maintaining the sorted order. index = 0 while index < len(self.stack) and self.stack[index] < item: index += 1 self.stack.insert(index, item) def pop(self): Remove and return the element from the top of the stack. Raise an IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): Return the current top element without altering the stack. Raise an IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): Return a boolean indicating whether the stack is empty. return len(self.stack) == 0 def size(self): Return the number of elements in the stack. return len(self.stack)"},{"question":"# Question Scenario You are developing a function to clean up input strings for a software application. The function takes an input string and removes any character that has already appeared in the string, maintaining the order of first occurrence. Task Implement the function `remove_reoccurring_characters` that processes the input string as described above. # Function Signature ```python def remove_reoccurring_characters(input_string: str) -> str: pass ``` # Input * `input_string` (str): a string of alphabetical characters (both uppercase and lowercase) and numbers. It could be empty as well. # Output * (str): A string with all recurring characters removed, having only the first occurrences of each character in their original order. # Constraints * The string will have a maximum length of 10^5 characters. # Example ```python assert remove_reoccurring_characters(\\"apple\\") == \\"aple\\" assert remove_reoccurring_characters(\\"\\") == \\"\\" assert remove_reoccurring_characters(\\"aabbcc\\") == \\"abc\\" assert remove_reoccurring_characters(\\"abcabc\\") == \\"abc\\" ``` # Performance Requirements * Process the string in linear time. * Optimize for minimal use of extra memory where possible.","solution":"def remove_reoccurring_characters(input_string: str) -> str: Removes any reoccurring characters in the input string, keeping only the first occurrence of each character. Parameters: input_string (str): The input string to be processed. Returns: str: A string with all reoccurring characters removed, only the first occurrences are kept in the original order. seen_characters = set() result = [] for char in input_string: if char not in seen_characters: seen_characters.add(char) result.append(char) return \'\'.join(result)"},{"question":"Find Missing Ranges Context You are given a sorted array of integers representing some elements in the range [lo, hi]. Your task is to find the missing ranges in this interval. A missing range is defined as a contiguous sequence of numbers within [lo, hi] that are not present in the array. Function Specification ```python def find_missing_ranges(array, lower, upper): Find missing ranges between lower and upper in the given array. :param array: List[int] - A sorted list of unique integers. :param lower: int - The lower bound of the range. :param upper: int - The upper bound of the range. :return: List[Tuple[int, int]] - A list of tuples representing missing ranges. ``` Input Format * `array`: A sorted list of unique integers `[a1, a2, a3, ..., an]` where `a1 <= a2 <= a3 <= ... <= an`. * `lower`: An integer `lower` representing the lower end of the range `[lower, upper]`. * `upper`: An integer `upper` representing the upper end of the range `[lower, upper]`. Output Format * A list of tuples where each tuple `(start, end)` represents a missing range within `[lower, upper]` that is not covered by the `array`. Constraints * All elements in the `array` are integers within the range `[lower, upper]`. * 0 <= len(array) <= 10^6 * -10^9 <= lower <= upper <= 10^9 Example **Input**: ```python array = [3, 5] lower = 1 upper = 10 ``` **Output**: ```python [(1, 2), (4, 4), (6, 10)] ``` Note Be sure to check for overlapping elements and handle edge cases where the entire interval `[lower, upper]` might be missing if `array` is empty.","solution":"def find_missing_ranges(array, lower, upper): Find missing ranges between lower and upper in the given array. :param array: List[int] - A sorted list of unique integers. :param lower: int - The lower bound of the range. :param upper: int - The upper bound of the range. :return: List[Tuple[int, int]] - A list of tuples representing missing ranges. if not array: return [(lower, upper)] if lower <= upper else [] missing_ranges = [] prev = lower - 1 for num in array: if num > prev + 1: missing_ranges.append((prev + 1, num - 1)) prev = num if upper > prev: missing_ranges.append((prev + 1, upper)) return missing_ranges"},{"question":"Unique Binary Search Trees Count # Context In a software project involving data structuring, you are required to compute the number of structurally unique Binary Search Trees (BST) that can be constructed using distinct values from 1 to \'n\'. This count helps in understanding the possible arrangement flexibility and permutations available for data management and retrieval. # Task Write a function `num_trees(n)` that calculates the number of distinct Binary Search Trees that can be formed with \'n\' distinct integers. The integers are taken from 1 to \'n\' and each value must participate exactly once in the structure. # Function Signature ```python def num_trees(n: int) -> int: pass ``` # Input * **n (integer)**: Represents the number of distinct integers to be used in forming BSTs. (1 ≤ n ≤ 20) # Output * **integer**: The total number of structurally unique BSTs that can be formed using \'n\' distinct integers. # Examples 1. **Input**: `3` **Output**: `5` **Explanation**: There are 5 unique BSTs that can be formed. ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` 2. **Input**: `4` **Output**: `14` **Explanation**: There are 14 unique BSTs that can be formed using 4 integers. # Constraints * `1 ≤ n ≤ 20` # Performance Requirements The solution should ideally work efficiently for all values within the given range. # Notes * Consider using dynamic programming to optimize the computation. * Be mindful of off-by-one errors while evaluating range boundaries.","solution":"def num_trees(n: int) -> int: Calculates the number of structurally unique BSTs that can be formed with \'n\' distinct integers. Args: n (int): The number of distinct integers. Returns: int: The number of unique BSTs. if n == 0 or n == 1: return 1 # dp[i] will store the number of unique BSTs that can be formed with \'i\' distinct numbers dp = [0] * (n + 1) dp[0] = 1 # Base case: empty tree # Calculate dp[i] for i = 1 to n for i in range(1, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"Context: You\'ve been hired by a data cleanup company to help with preprocessing strings before they are fed into a summarization algorithm. As part of this preprocessing, you need to remove any reoccurring characters from the string input while retaining the order of first occurrences. Task: Create a function `clean_up_string()` that takes a single string argument and returns a new string with all duplicate characters removed, preserving the order of their first appearance. Function Signature: ```python def clean_up_string(input_string: str) -> str: pass ``` Input: * `input_string` (str): A non-empty string containing alphanumeric characters and possibly spaces. Output: * str: A new string with duplicates removed. Constraints: * The input string will be between 1 and 10^6 characters in length. * The function should aim for O(n) time complexity and use no more than O(n) additional space. Examples: ```python assert clean_up_string(\\"Google\\") == \\"Gogle\\" assert clean_up_string(\\"AAABBBCCCA\\") == \\"ABC\\" assert clean_up_string(\\"abcABCabcABC\\") == \\"abcABC\\" assert clean_up_string(\\"\\") == \\"\\" ``` Note: Consider performance efficiency due to the potential length of the input string, and aim for a solution that handles edge cases gracefully.","solution":"def clean_up_string(input_string: str) -> str: This function takes a string input and returns a new string with all duplicate characters removed while preserving the order of their first occurrence. seen = set() result = [] for char in input_string: if char not in seen: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"# Question: Implement an Optimized Comb Sort In order to test your understanding of sorting algorithms and ensure efficiency, you are required to implement an optimized version of Comb Sort. Your task is to create a Python function that sorts an array of integers using the Comb Sort algorithm, incorporating an additional step to handle already sorted segments earlier. Function Signature ```python def optimized_comb_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): A list of integers to be sorted. Output - Returns a new list containing the elements from `arr` sorted in non-decreasing order. Constraints - The length of `arr` will not exceed 10^6. - Elements of `arr` can be negative or positive integers. Performance requirements - The solution should optimize the gap reduction process and terminate as early as possible when the array is detected to be sorted. Example ```python >>> optimized_comb_sort([34, 8, 64, 51, 32, 21]) [8, 21, 32, 34, 51, 64] >>> optimized_comb_sort([-5, -1, -12, 10, 0, 3, 2]) [-12, -5, -1, 0, 2, 3, 10] ``` # Additional Information: In the provided implementation of comb sort, additional optimizations might include: - Using a different shrink factor if necessary. - Incorporating a check to detect sorted subarrays early and skip unnecessary passes. You are expected to think about these considerations and integrate them into your final solution.","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: Optimized Comb Sort implementation n = len(arr) gap = n shrink = 1.3 sorted = False while gap > 1 or not sorted: gap = int(gap / shrink) if gap < 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"**Question**: Implement a \'road network optimizer\' that, given a city\'s road infrastructure represented as a graph, calculates the minimum travel distance from the city\'s main square to all other important locations in the city using Dijkstra\'s algorithm. The roads can only have non-negative weights representing the travel time. Specifications: 1. **Input**: * An integer `n` (1 ≤ n ≤ 1000) representing the number of nodes (locations). * An integer `m` (1 ≤ m ≤ 10000) representing the number of edges (roads). * A matrix `edges` with `m` rows, where each row contains three integers `u`, `v`, and `w` (1 ≤ w ≤ 1000), indicating a road from location `u` to location `v` with travel time `w`. * An integer `main_square` (1 ≤ main_square ≤ n) representing the main city square location. 2. **Output**: * A list of `n` integers, where the i-th value represents the minimum travel distance from the main city square to location `i`. If a location is unreachable, return -1 for that location. Function Signature: ```python def road_network_optimizer(n: int, m: int, edges: List[Tuple[int, int, int]], main_square: int) -> List[int]: pass ``` Example: ```python Input: n = 5 m = 6 edges = [ (1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 4, 9), (4, 5, 1), (1, 5, 20) ] main_square = 1 Output: [0, 10, 5, 14, 15] ``` **Explanation**: - Travel distance from 1 to 1 is 0. - Travel distance from 1 to 2 is 10. - Travel distance from 1 to 3 is 5. - Travel distance from 1 to 4 is obtained via 1 → 3 → 4, totalling 14. - Travel distance from 1 to 5 is obtained via 1 → 3 → 4 → 5, totalling 15. Note: - Ensure efficiency as the largest constraints can cause performance issues if not appropriately handled. - Consider edge cases such as isolated nodes and unreachable locations.","solution":"import heapq from typing import List, Tuple def road_network_optimizer(n: int, m: int, edges: List[Tuple[int, int, int]], main_square: int) -> List[int]: def dijkstra(source: int) -> List[int]: dist = [float(\'inf\')] * (n + 1) dist[source] = 0 priority_queue = [(0, source)] # (distance, node) visited = [False] * (n + 1) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if visited[u]: continue visited[u] = True for neighbor, weight in graph[u]: if dist[u] + weight < dist[neighbor]: dist[neighbor] = dist[u] + weight heapq.heappush(priority_queue, (dist[neighbor], neighbor)) return dist # Create the graph representation graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) # Get the shortest paths from the main square shortest_paths_from_main_square = dijkstra(main_square) # Convert \'inf\' distances to -1 and ignore the 0-th index as nodes are 1-indexed result = [] for i in range(1, n + 1): if shortest_paths_from_main_square[i] == float(\'inf\'): result.append(-1) else: result.append(shortest_paths_from_main_square[i]) return result"},{"question":"# Scenario You are tasked with enhancing the capabilities of a HashTable by implementing a delete operation that allows efficient removal of an element while maintaining the integrity of the table under heavy load. # Task Extend the provided `HashTable` class by adding an `undel(key)` function that can restore a key-value pair deleted by a `del_(key)` operation. Additionally, optimize the hash table such that it triggers a shrinking operation to half its size when its load factor falls below 1/3 after a deletion. # Specifications 1. Implement the `undel(key)` function to recover the most recent deletion. 2. Implement resizing logic to shrink the table size when the load factor drops below 1/3. 3. Validate the deletion and undeletion to maintain integrity. # Function Signature Implement the following function: ```python class HashTable(object): # Existing methods... def undel(self, key): Restores a key-value pair that was removed by the last del_ operation. pass def __resize(self, new_size): Resize the hash table to the given new_size. pass ``` # Example ```python ht = ResizableHashTable() # Inserting elements ht.put(1, \\"one\\") ht.put(2, \\"two\\") ht.put(3, \\"three\\") # Deleting an element ht.del_(2) # Table should adapt its size if downsized # Restoring deleted element ht.undel(2) assert ht.get(2) == \\"two\\" # Ensuring no other elements are affected assert ht.get(1) == \\"one\\" assert ht.get(3) == \\"three\\" ``` # Additional Constraints * Handle error when the key to `undel` does not exist. * Provide O(1) complexity for `undel` by maintaining a history of deletions. * Ensure robust resizing logic with consideration of data integrity during shrinking. Test your implementation rigorously to ensure it handles edge cases effectively, such as table resizing up and down, consistent lookups, and proper undeletion function.","solution":"class HashTable: def __init__(self): self.capacity = 4 self.size = 0 self.table = [None] * self.capacity self.deleted = None def hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity >= 0.7: self.__resize(2 * self.capacity) index = self.hash(key) original_index = index while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.capacity if index == original_index: raise Exception(\\"Hash table is full\\") if self.table[index] is None: self.size += 1 self.table[index] = (key, value) def get(self, key): index = self.hash(key) original_index = index while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity if index == original_index: break return None def del_(self, key): index = self.hash(key) original_index = index while self.table[index] is not None: if self.table[index][0] == key: self.deleted = self.table[index] self.table[index] = None self.size -= 1 self.__rehash(index) if self.size / self.capacity < 1/3: self.__resize(self.capacity // 2) return index = (index + 1) % self.capacity if index == original_index: break def undel(self, key): if self.deleted and self.deleted[0] == key: self.put(*self.deleted) self.deleted = None def __resize(self, new_size): old_table = self.table self.capacity = new_size self.size = 0 self.table = [None] * self.capacity for item in old_table: if item is not None: self.put(item[0], item[1]) def __rehash(self, start_index): index = (start_index + 1) % self.capacity while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.size -= 1 self.put(key, value) index = (index + 1) % self.capacity"},{"question":"# Question You are tasked with implementing a priority queue using a binary min-heap. Your implementation should support the following operations efficiently: 1. **Insert**: Adds a new integer element to the heap. 2. **Remove Minimum**: Removes and returns the smallest element from the heap. 3. **Get Minimum**: Retrieves (without removing) the smallest element from the heap. Function signatures: ```python class MinHeap: def __init__(self): # Initialize your heap here pass def insert(self, val: int): # Insert a new integer element into the heap pass def remove_min(self) -> int: # Remove and return the smallest element from the heap pass def get_min(self) -> int: # Retrieve the minimum element without removing it from the heap pass ``` # Input/Output Formats Keep the following constraints and formats in mind: * The heap will only contain non-negative integers. * The `insert` function should add a new element to the heap. * The `remove_min` function should remove and return the smallest element from the heap and raise an exception if the heap is empty. * The `get_min` function should return the smallest element without removing it and raise an exception if the heap is empty. Example Initialize the heap: ```python h = MinHeap() h.insert(10) h.insert(4) h.insert(15) print(h.get_min()) # Output: 4 print(h.remove_min()) # Output: 4 print(h.remove_min()) # Output: 10 h.insert(1) print(h.get_min()) # Output: 1 print(h.remove_min()) # Output: 1 print(h.remove_min()) # Output: 15 print(h.remove_min()) # Output: Exception (heap is empty) ``` # Performance Ensure that the `insert` and `remove_min` operations have a logarithmic time complexity.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val: int): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self) -> int: if not self.heap: raise Exception(\\"Heap is empty\\") if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_val def get_min(self) -> int: if not self.heap: raise Exception(\\"Heap is empty\\") return self.heap[0] def _heapify_up(self, index): parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"One of the fundamental tasks in file system management is to simplify absolute paths. Given a Unix-style absolute path, students are tasked to write a function that simplifies the path. Problem Statement: Write a function `simplify_path(path: str) -> str` that simplifies the given Unix-style absolute path. Input: * A string `path` which represents a Unix-style absolute path. The path always starts with a slash \'/\' and contains alphanumeric characters, dots, underscores, and slashes. Output: * Return a simplified version of the absolute path as a string. The simplified path must remove dot (\'.\') directories, resolve double dots (\'..\') to go up one directory, and reduce multiple slashes to a single slash. Constraints: * The length of `path` will be at most 3000 characters. * The path will always be a valid Unix-style path, starting with \'/\'. * The simplified path should be the shortest possible version of the original. Performance: * The solution must have a time complexity of O(n) and space complexity of O(n), where n is the length of the path. Example Scenarios: 1. Input: `\\"/home/\\"` Output: `\\"/home\\"` 2. Input: `\\"/a/./b/../../c/\\"` Output: `\\"/c\\"` 3. Input: `\\"/../\\"` Output: `\\"/\\"` 4. Input: `\\"/home//foo/\\"` Output: `\\"/home/foo\\"` 5. Input: `\\"/a//b////c/d//././/..\\"` Output: `\\"/a/b/c\\"` Function Signature: ```python def simplify_path(path: str) -> str: pass ``` Explanation: The function will use a stack to process the path components iteratively: 1. Split the path by slashes. 2. Traverse each component; append non-special components to the stack. 3. Handle \'..\' by popping from the stack if not empty. 4. Ignore \'.\' and empty components. 5. Finally, join the stack components with \'/\' to form the simplified path. Remind students to account for various edge cases as highlighted above.","solution":"def simplify_path(path: str) -> str: parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"**Question**: You have been provided with the task of determining whether a given integer is a power of two. An integer `n` is a power of two if there exists an integer `x` such that `n == 2^x`. Write a function `is_power_of_two` that takes in an integer `n` and returns a boolean indicating whether `n` is a power of two. # Function Signature ```python def is_power_of_two(n: int) -> bool: pass ``` # Input - An integer `n` where -2^31 <= n <= 2^31 - 1. # Output - A boolean: `True` if `n` is a power of two, `False` otherwise. # Example ```python assert is_power_of_two(1) == True # 2^0 == 1 assert is_power_of_two(16) == True # 2^4 == 16 assert is_power_of_two(218) == False # ``` # Constraints & Notes - The solution should have a time complexity of O(1). - Consider edge cases like `n` being negative or zero which cannot be a power of two. - Avoid unnecessary loops or recursion. # Context Scenario You are working on a system that requires dynamically adjusting the size of buffers to fit powers of two for optimal performance. Implementing this function allows the system to quickly verify whether the current buffer size meets the necessary condition.","solution":"def is_power_of_two(n: int) -> bool: Determine if a given integer is a power of two. :param n: An integer :return: True if n is a power of two, otherwise False if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Radix Sort Implementation and Simulation Context: Imagine you are building a data processing system that needs to handle large sets of integer data efficiently. Radix Sort is particularly well-suited for this task as it sorts integers in linear time for small ranges of digit lengths, providing a feasible solution for your needs. Task: Write a `radix_sort` function that sorts an array of non-negative integers using radix sort algorithm. Additionally, implement a simulation feature within the function to display the array at each stage of sorting. Function Signature: ```python def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` Input: 1. `arr` (List[int]): A list of non-negative integers that needs to be sorted. 2. `simulation` (bool, optional): A boolean flag that if set to `True`, outputs the state of the list after each digit sorting iteration. Default is `False`. Output: - The function returns a sorted list of integers. Constraints: - All integers in `arr` are non-negative. - The length of `arr` will be between 1 and 10^5. - Each integer in `arr` will be between 0 and 10^9. Example: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr, simulation=True)) # Expected output (with simulation flag on): # iteration 0: 170 45 75 90 802 24 2 66 # iteration 1: 170 90 802 2 24 45 75 66 # iteration 2: 2 24 45 66 75 170 802 90 # iteration 3: 2 24 45 66 75 90 170 802 ``` Edge Cases to Consider: 1. An array with a single element: `[10]` 2. An already sorted array: `[1, 2, 3, 4, 5, 6]` 3. An array with all duplicate values: `[7, 7, 7, 7, 7]` 4. Mixed range arrays: `[5, 200000, 3, 6000, 15]` Performance Requirements: - Implement an efficient solution with the given constraints. - Ensure your solution utilizes appropriate data structures to maintain stability and minimize memory overhead.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {exp}: {\' \'.join(map(str, arr))}\\") def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: if not arr: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"**Problem Statement**: You are tasked with implementing enhancements to an existing `HashTable` implementation that already supports basic operations like insertion, deletion, and retrieval using linear probing for collision resolution. Your task is to implement a more collision-resistant rehashing function. Additionally, handle edge cases more gracefully and make the table resizable. # Requirements: 1. **Rehashing Strategy**: Modify the `_rehash` function to use quadratic probing instead of linear probing. 2. **Edge Cases Handling**: Enhance edge case handling for insertion, retrieval, and deletion operations. 3. **Resizing**: Implement resizing capabilities to ensure the hash table maintains optimal performance. # Method Specifications: - Modify the `ResizableHashTable` class: - Replace the linear probing in the `_rehash` method with quadratic probing. - Handle edge cases in `put`, `get`, and `del_` methods. - Ensure the hash table resizes efficiently while maintaining correctness of the hash table operations. # Constraints: - All elements (keys and values) will be non-negative integers. - Initial size of the hash table will be a prime number. - Allow for at least 8 elements before resizing starts. - Handle up to (10^5) elements. # Example: ```python ht = ResizableHashTable() ht.put(1, \'a\') ht.put(12, \'b\') ht.put(23, \'c\') print(ht.get(1)) # Output: \'a\' print(ht.get(12)) # Output: \'b\' print(ht.del_(23)) # Output: None print(ht.get(23)) # Output: None ``` # Expected Input/Output: - **Input**: Series of operations (`put`, `get`, `del_`), and each operation\'s arguments. - **Output**: Result of `get` and `del_` operations. Suppress the resizing output/logging in the final implementation to ensure clean functionality.","solution":"class ResizableHashTable: def __init__(self, initial_size=11): self.size = initial_size self.table = [None] * self.size self.count = 0 self.load_factor_threshold = 0.75 def _hash(self, key): return key % self.size def _rehash(self, old_hash, i): return (old_hash + i**2) % self.size def _resize(self): old_table = self.table self.size = self._next_prime(self.size * 2) self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def _next_prime(self, n): def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime = n while not is_prime(prime): prime += 1 return prime def put(self, key, value): if self.count / self.size > self.load_factor_threshold: self._resize() original_hash = self._hash(key) i = 0 hash_index = original_hash while self.table[hash_index] is not None and self.table[hash_index][0] != key: i += 1 hash_index = self._rehash(original_hash, i) if self.table[hash_index] is None: self.count += 1 self.table[hash_index] = (key, value) def get(self, key): original_hash = self._hash(key) i = 0 hash_index = original_hash while self.table[hash_index] is not None: if self.table[hash_index][0] == key: return self.table[hash_index][1] i += 1 hash_index = self._rehash(original_hash, i) return None def del_(self, key): original_hash = self._hash(key) i = 0 hash_index = original_hash while self.table[hash_index] is not None: if self.table[hash_index][0] == key: self.table[hash_index] = None self.count -= 1 return i += 1 hash_index = self._rehash(original_hash, i)"},{"question":"# Ternary Search Implementation Question **Objective**: You are given an array of integers sorted in non-decreasing order and a target value. Your task is to write a function that uses the ternary search algorithm to find the index of the target value in the array. If the target value does not exist in the array, return -1. The function must efficiently handle edge cases and ensure correctness under given constraints. **Function Signature**: ```python def ternary_search(arr: List[int], left: int, right: int, key: int) -> int: pass ``` **Input**: * `arr`: List of integers sorted in non-decreasing order (1 ≤ length of `arr` ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) * `left`: Integer representing the starting index of the search range (initially 0) * `right`: Integer representing the ending index of the search range (initially len(arr) - 1) * `key`: Integer representing the target value to search for (-10^9 ≤ key ≤ 10^9) **Output**: * Return the index of the target value if found, otherwise return -1. **Constraints**: * Implement the ternary search algorithm as described. * The overall solution should run in logarithmic time complexity O(log3(N)). **Example**: ```python assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0, 9, 5) == 4 assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0, 9, 11) == -1 assert ternary_search([2, 4, 5, 7, 12, 15, 18], 0, 6, 7) == 3 assert ternary_search([2, 4, 5, 7, 12, 15, 18], 0, 6, 1) == -1 ```","solution":"from typing import List def ternary_search(arr: List[int], left: int, right: int, key: int) -> int: Perform a ternary search on a sorted array to find the target value. Parameters: arr (List[int]): The sorted list of integers. left (int): The starting index of the search range. right (int): The ending index of the search range. key (int): The target value to search for. Returns: int: The index of the target value if found, otherwise -1. while right >= left: third_length = (right - left) // 3 mid1 = left + third_length mid2 = right - third_length if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Matrix Chain Multiplication is an optimization problem to find the most efficient way to multiply a sequence of matrices. Given a sequence of matrices, the problem is to find the most efficient way to multiply these matrices together. The input is an array where the `i`th matrix has dimensions `array[i-1] x array[i]`. **Function Signature:** ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: Finds the optimal order to multiply matrices. Parameters: array (List[int]): A list of integers representing the dimensions of matrices in sequence. Returns: Tuple[List[List[int]], List[List[int]]]: A tuple containing two 2D lists: - matrix (List[List[int]]): A table that holds the minimum number of operations needed to compute the product of matrices. - sol (List[List[int]]): A table that holds split points that achieve the minimum cost of multiplications. pass ``` **Additional Function:** Implement a helper function to print the optimal order of multiplication: ```python def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None: Prints optimal parenthesization of matrix multiplication. Parameters: sol (List[List[int]]): A table that holds split points computed from `matrix_chain_order`. i (int): Starting index of the matrix chain. j (int): Ending index of the matrix chain. pass ``` # Input * A list `array` of `n` integers where `array[i]` represents the dimensions of matrices. # Output * The matrix order cost and solutions. * Printing the optimal matrix multiplication order. # Constraints * `2 <= len(array) <= 100` * `1 <= array[i] <= 1000` # Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, sol = matrix_chain_order(array) print(f\\"No. of Operation required: {matrix[1][len(array)-1]}\\") print_optimal_solution(sol, 1, len(array)-1) ``` **Expected Output:** ``` No. of Operation required: 15125 ((A1 (A2 A3)) ((A4 A5) A6)) ``` # Explanation The function `matrix_chain_order` calculates the minimum number of scalar multiplications required and helps determine the optimal way to parenthesize the product. The function `print_optimal_solution` recursively prints out this optimal parenthesization.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: # Number of matrices n = len(array) - 1 # m will store the minimum multiplication costs m = [[0 for _ in range(n+1)] for _ in range(n+1)] # s will store the k value where we split the product s = [[0 for _ in range(n+1)] for _ in range(n+1)] # cost is zero when multiplying one matrix for length in range(2, n+1): # length is the chain length for i in range(1, n-length+2): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + array[i-1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i-1}\\" return f\\"({print_optimal_solution(sol, i, sol[i][j])} {print_optimal_solution(sol, sol[i][j] + 1, j)})\\""},{"question":"# Problem: Subtree Verification Given two binary trees `s` and `t`, write a function `is_subtree(s: TreeNode, t: TreeNode) -> bool` to check if t is a subtree of s. A subtree of a tree `s` is a tree consisting of a node in `s` and all of its descendants in `s`. # Input: 1. `TreeNode s`: The root of the potential larger tree. 2. `TreeNode t`: The root of the subtree to check. # Output: - `bool`: Return `True` if `t` is a subtree of `s`, otherwise return `False`. # Constraints: 1. Tree nodes can have integer values. 2. The number of nodes in both trees can be up to 10,000. 3. TreeNode class definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Examples: Example 1: - **Input**: - s: ``` 3 / 4 5 / 1 2 ``` - t: ``` 4 / 1 2 ``` - **Output**: `True` Example 2: - **Input**: - s: ``` 3 / 4 5 / 1 2 / 0 ``` - t: ``` 3 / 4 / 1 2 ``` - **Output**: `False` # Implementation Guidance: - Use BFS to locate a node in `s` that matches the root node of `t`. - Once a node is found, use a recursive function to compare the subtree rooted at this node with `t`. - Consider edge cases such as null trees and trees with a single node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not s: return not t def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False return s.val == t.val and is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) return is_same_tree(s, t) or is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"# Longest Common Subsequence and Minimum Deletions Given two words, `word1` and `word2`, your task is to compute the minimum number of steps required to make both words the same by only deleting characters. Implement two functions: one that computes this using a dynamic programming approach and another using a recursive approach with memoization. Function Signature: ```python def min_distance(word1: str, word2: str) -> int: def min_distance_dp(word1: str, word2: str) -> int: ``` Input: * `word1`: A non-empty string consisting of lowercase English letters. * `word2`: A non-empty string consisting of lowercase English letters. Output: * An integer representing the minimum number of steps required to make both words the same by deleting characters. Constraints: * Length of `word1` and `word2` will be in the range [1, 1000]. * You can delete characters only. No insertion or substitution is allowed. # Example: ```python assert min_distance(\\"sea\\", \\"eat\\") == 2 assert min_distance_dp(\\"sea\\", \\"eat\\") == 2 ``` Explanation: - After deleting \'s\' from \\"sea\\", you get \\"ea\\". - After deleting \'t\' from \\"eat\\", you get \\"ea\\". - The minimum number of steps needed is 2. # Note: - Your solution should handle edge cases efficiently and must be optimized for performance. - Ensure to write test cases to validate your implementation, considering various edge cases. # Guidelines: 1. **Recursive Approach with Memoization**: - Implement the recursive approach to find the longest common subsequence and compute the minimum steps required. 2. **Dynamic Programming Approach**: - Implement an iterative DP approach to find the minimum steps efficiently.","solution":"def min_distance(word1: str, word2: str) -> int: Computes the minimum number of steps required to make both words the same by deleting characters, using a recursive approach with memoization. from functools import lru_cache @lru_cache(None) def lcs(i: int, j: int) -> int: if i == len(word1) or j == len(word2): return 0 if word1[i] == word2[j]: return 1 + lcs(i + 1, j + 1) return max(lcs(i + 1, j), lcs(i, j + 1)) lcs_length = lcs(0, 0) return (len(word1) - lcs_length) + (len(word2) - lcs_length) def min_distance_dp(word1: str, word2: str) -> int: Computes the minimum number of steps required to make both words the same by deleting characters, using a dynamic programming approach. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] return (m - lcs_length) + (n - lcs_length)"},{"question":"# Maximum Flow in a Network You are given a directed graph represented by an `n x n` adjacency matrix. Each cell in the matrix represents the capacity of a direct path from node `i` to node `j`. **Objective:** Write a function that determines the maximum flow from the source node to the sink node using the Depth First Search (DFS) algorithm. **Function Signature:** ```python def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: ``` **Input:** * `adjacency_matrix`: A list of lists of integers where `adjacency_matrix[i][j]` denotes the capacity of edge from node `i` to node `j`. It\'s guaranteed that the matrix is square. **Output:** * Returns an integer, representing the maximum flow from the source (first node) to the sink (last node). **Constraints:** * `1 <= n <= 100` * `0 <= adjacency_matrix[i][j] <= 1000` * Adjacency matrix will be non-negative and can contain zero capacities, representing no direct path. **Scenario:** Consider a network where you are trying to send data from a central server (source, node 0) to multiple client machines (sink, last node). The capacities between these nodes represent the bandwidth available over network connections. Your task is to find out the maximum bandwidth (flow) that can be channeled from the server to the clients without exceeding the available capacities. **Example:** ```python # Example Input graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] # Example Output assert maximum_flow_dfs(graph) == 23 ``` **Explanation:** In the given example, the maximum flow obtained from the central server to the clients is 23 units, utilizing the paths and capacities efficiently. Ensure to handle edge cases, including disconnected graphs and paths where capacities may be zero.","solution":"from typing import List def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: Returns the maximum flow from source (node 0) to sink (last node) using DFS algorithm. n = len(adjacency_matrix) source, sink = 0, n - 1 # Residual graph residual = [row[:] for row in adjacency_matrix] def dfs(flow: int, path: List[int]) -> int: visited = [False] * n stack = [(source, float(\'inf\'))] # (current node, path flow) parent = [-1] * n # To store the path while stack: node, path_flow = stack.pop() if not visited[node]: visited[node] = True for neighbor in range(n): if residual[node][neighbor] > 0 and not visited[neighbor]: parent[neighbor] = node new_flow = min(path_flow, residual[node][neighbor]) if neighbor == sink: current = neighbor while current != source: previous = parent[current] residual[previous][current] -= new_flow residual[current][previous] += new_flow current = previous return new_flow stack.append((neighbor, new_flow)) return 0 max_flow = 0 flow = 0 while True: flow = dfs(float(\'inf\'), []) if flow == 0: break max_flow += flow return max_flow"},{"question":"Background A common task in file management and scripting is to convert file paths provided by users into absolute paths that can be reliably used by the program. An absolute path gives the complete reference from the root directory, removing any ambiguity associated with relative paths or user-specific shortcuts. Task Description Implement a Python function `my_full_path(file: str) -> str` that takes a string representing a file path and returns its absolute equivalent by: 1. Expanding user-specific shortcuts (e.g., `~`). 2. Converting any relative paths to absolute paths with respect to the current working directory. The function should efficiently handle typical edge cases such as symbols misplaced in paths or nonexistent paths while ensuring that valid paths are correctly expanded. Input * `file` (str): A relative or user-specific file path. Output * (str): The absolute path representation of the input file path. Constraints * Assume input is given as a string but include checks or error handling for non-string inputs. * The function should be able to handle both valid and invalid paths gracefully. Example Usage ```python assert my_full_path(\\"~/documents/file.txt\\") == \\"/home/user/documents/file.txt\\" assert my_full_path(\\"./docs/report.docx\\") == \\"/current/working/directory/docs/report.docx\\" assert my_full_path(\\"/etc/config/settings.conf\\") == \\"/etc/config/settings.conf\\" assert my_full_path(\\"\\") == \\"/current/working/directory/\\" ```","solution":"import os def my_full_path(file: str) -> str: Convert a relative or user-specific file path to its absolute path. Parameters: file (str): A relative or user-specific file path. Returns: str: The absolute file path. if not isinstance(file, str): raise ValueError(\\"Input should be a string\\") # Expand user-specific shortcuts like ~ expanded_user_path = os.path.expanduser(file) # Convert to absolute path absolute_path = os.path.abspath(expanded_user_path) return absolute_path"},{"question":"# String Reversal Challenge Context You are developing a text processing tool and need efficient algorithms to reverse strings. Various approaches to this problem exist, each with its own strengths and weaknesses. Our goal is to implement these approaches and understand their differences. Task Implement four functions that reverse a given string using different methods described in the analysis. Your implementations should match the given prototypes and adhere to constraints. Function Specifications 1. **Recursive Approach**: ```python def reverse_recursive(s: str) -> str: pass ``` 2. **Iterative Approach**: ```python def reverse_iterative(s: str) -> str: pass ``` 3. **Pythonic Approach**: ```python def reverse_pythonic(s: str) -> str: pass ``` 4. **Ultra Pythonic Approach**: ```python def reverse_ultra_pythonic(s: str) -> str: pass ``` Input and Output * **Input**: A single string `s` with a maximum length of 1000 characters. * **Output**: The reversed string. Constraints * The input string may be empty or contain a single character. Performance Requirements * Ensure optimal performance and correct handling of edge cases. Examples ```python # Example 1 input_str = \\"hello\\" print(reverse_recursive(input_str)) # Expected Output: \\"olleh\\" print(reverse_iterative(input_str)) # Expected Output: \\"olleh\\" print(reverse_pythonic(input_str)) # Expected Output: \\"olleh\\" print(reverse_ultra_pythonic(input_str)) # Expected Output: \\"olleh\\" # Example 2 input_str = \\"A\\" print(reverse_recursive(input_str)) # Expected Output: \\"A\\" print(reverse_iterative(input_str)) # Expected Output: \\"A\\" print(reverse_pythonic(input_str)) # Expected Output: \\"A\\" print(reverse_ultra_pythonic(input_str)) # Expected Output: \\"A\\" ```","solution":"def reverse_recursive(s: str) -> str: Reverse the string using a recursive approach. if len(s) == 0: return s return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverse the string using an iterative approach. result = [] for char in s: result.insert(0, char) return \'\'.join(result) def reverse_pythonic(s: str) -> str: Reverse the string using Python\'s slicing feature. return s[::-1] def reverse_ultra_pythonic(s: str) -> str: Reverse the string using Python\'s built-in reversed() function and join. return \'\'.join(reversed(s))"},{"question":"**Title**: Filter Array Values Based on Min and Max Constraints **Description**: You are given an array of integers and two optional limits (minimum and maximum). Your task is to filter the array such that it only contains elements that are between the given minimum and maximum values, inclusive. If a limit is not provided (`None`), you should use the minimum or maximum value within the array as the limit. **Function Signature**: ```python def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: pass ``` # Input - `arr` (list): A list of integers with a length between 0 and 10^5. - `min_lim` (int, optional): The minimum value an element should have to be included in the result, or `None` if there\'s no minimum constraint. - `max_lim` (int, optional): The maximum value an element should have to be included in the result, or `None` if there\'s no maximum constraint. # Output - A list of integers that contains elements from `arr` that lie between `min_lim` and `max_lim` inclusive. # Constraints - The elements of the array are not sorted and can contain both positive and negative integers. - If both `min_lim` and `max_lim` are specified, `min_lim` ≤ `max_lim`. # Example ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] assert limit([1, 2, 3, 4, 5], 1, 5) == [1, 2, 3, 4, 5] assert limit([1, 2, 3, 4, 5], 2, 3) == [2, 3] assert limit([1, 2, 3, 4, 5], None, None) == [1, 2, 3, 4, 5] assert limit([], 1, 5) == [] assert limit([10, 20, 30, 40, 50], 25, 35) == [30] ``` # Notes - Ensure your implementation handles edge cases like empty arrays and `None` values for limits. - The solution should be efficient with an overall time complexity of O(n).","solution":"def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: Filters the array based on the provided min_lim and max_lim. If any of the limits is None, it will consider the minimum or maximum value of the array itself for that limit. :param arr: List of integers to filter. :param min_lim: Minimum limit (inclusive). If None, will use the minimum value from the array. :param max_lim: Maximum limit (inclusive). If None, will use the maximum value from the array. :return: List of integers that are between min_lim and max_lim inclusive. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Scenario Alice and Bob want to securely share a secret key over an insecure communication network using the Diffie-Hellman key exchange method. The security relies on choosing a large prime number and its primitive root. # Task Implement a function `secure_key_exchange(p: int, a: int, verbose: bool = False) -> int` which determines if a given prime number `p` and primitive root `a` can be used for a secure Diffie-Hellman key exchange between Alice and Bob. # Input 1. `p` (int): A large prime number. 2. `a` (int): An integer supposed to be the primitive root of `p`. 3. `verbose` (bool, optional): When True, prints detailed steps of the key exchange process. Defaults to False. # Output * Return `True` if the shared keys calculated by Alice and Bob match. * Otherwise, return `False`. # Constraints * Assume `p` is up to 2^31 - 1 (a commonly used upper bound for prime numbers). * The function `prime_check()` works correctly. * The function `find_primitive_root()` is available and returns correct results. # Performance Requirements - Efficient execution for large primes up to 2^31 - 1. - Ensure minimal additional memory usage. # Example ```python secure_key_exchange(23, 5, verbose=True) ``` Expected output: ``` Alice\'s private key: x Alice\'s public key: y Bob\'s private key: z Bob\'s public key: w Shared key calculated by Alice = s Shared key calculated by Bob = s True ``` # Important Points * **Do not use randomness in private key generation, for testing consider fixed keys testing function.** * Ensure that `a` is indeed a primitive root of `p`. * Handle invalid primes gracefully. * Include comments in the code for clarity.","solution":"def secure_key_exchange(p: int, a: int, verbose: bool = False) -> bool: Determines if the given prime number `p` and primitive root `a` can be used for a secure Diffie-Hellman key exchange between Alice and Bob. Parameters: - p (int): A large prime number. - a (int): An integer supposed to be the primitive root of `p`. - verbose (bool, optional): When True, prints detailed steps of the key exchange process. Returns: - bool: True if the shared keys calculated by Alice and Bob match, else False. # Validate p and a (this step assumes correctness of prime_check and find_primitive_root) def prime_check(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): if p == 2: return [1] # Find all prime factors of p-1 def prime_factors(n): factors = set() while n % 2 == 0: factors.add(2) n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.add(i) n //= i if n > 2: factors.add(n) return factors # Check if a number is a primitive root of p def is_primitive_root(a, p): required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set # Main logic for finding the primitive root phi = p - 1 factors = prime_factors(phi) for r in range(2, phi + 1): flag = True for factor in factors: if pow(r, phi // factor, p) == 1: flag = False break if flag: return r return None if not prime_check(p): if verbose: print(f\\"{p} is not a prime number.\\") return False if find_primitive_root(p) is None: if verbose: print(f\\"No primitive root found for {p}.\\") return False # Check if a is a primitive root (this can be optimized further) if not find_primitive_root(p) == a: if verbose: print(f\\"{a} is not a primitive root of {p}.\\") return False # Simulate private keys (fixed values for Alice and Bob for consistency) x = 6 # Alice\'s private key y = pow(a, x, p) # Alice\'s public key z = 15 # Bob\'s private key w = pow(a, z, p) # Bob\'s public key # Alice calculates the shared key alice_shared_key = pow(w, x, p) # Bob calculates the shared key bob_shared_key = pow(y, z, p) if verbose: print(f\\"Alice\'s private key: {x}\\") print(f\\"Alice\'s public key: {y}\\") print(f\\"Bob\'s private key: {z}\\") print(f\\"Bob\'s public key: {w}\\") print(f\\"Shared key calculated by Alice = {alice_shared_key}\\") print(f\\"Shared key calculated by Bob = {bob_shared_key}\\") return alice_shared_key == bob_shared_key"},{"question":"# Question: Frequency Control in a List You are given a list of integers and a number N. Your task is to write a function that returns a new list containing each number of the given list at most N times without reordering the elements. Implement the function `delete_nth(array, n)` which takes two arguments: - `array`: A list of integers. - `n`: An integer specifying the maximum number of occurrences for each element. # Input - `array` can contain between 0 and 10^4 integers, where each integer is in the range from -10^9 to 10^9. - `n` is a non-negative integer. # Output - A list of integers containing each number from the original list at most `n` times without reordering them. # Constraints - The resulting list should preserve the order of the original list. - Use a linear time algorithm ((O(n))) to ensure efficiency for large inputs. # Example ```python delete_nth([1, 2, 3, 1, 2, 1, 2, 3], 2) # Output: [1, 2, 3, 1, 2, 3] delete_nth([20, 37, 20, 21], 1) # Output: [20, 37, 21] delete_nth([], 2) # Output: [] delete_nth([1, 2, 3], 0) # Output: [] ``` # Additional Notes: - Carefully handle edge cases such as when `n` is 0 or the input list is empty. - Ensure that your solution operates efficiently even for large input lists.","solution":"def delete_nth(array, n): Returns a new list containing each number of the given list at most N times without reordering the elements. result = [] counts = {} for num in array: if counts.get(num, 0) < n: result.append(num) counts[num] = counts.get(num, 0) + 1 return result"},{"question":"# Context You are tasked with building a spell checker that suggests words which are a single edit distance apart from the input word. # Task Write a Python function `is_one_edit` that takes two strings `s` and `t`, and returns `True` if they are one edit distance apart (one insertion, deletion, or substitution away), otherwise returns `False`. # Function Signature ```python def is_one_edit(s: str, t: str) -> bool: pass ``` # Input - `s` (string): A string of maximum length 10^4. - `t` (string): Another string of maximum length 10^4. # Output - Return a boolean `True` if strings `s` and `t` are one edit distance apart; otherwise, return `False`. # Constraints - The input strings only contain lowercase English letters. - Ensure the function operates within O(n) time complexity and uses O(1) additional space. # Examples ```python assert is_one_edit(\\"abc\\", \\"ab\\") == True assert is_one_edit(\\"abc\\", \\"adc\\") == True assert is_one_edit(\\"abc\\", \\"abcd\\") == True assert is_one_edit(\\"abc\\", \\"abcde\\") == False assert is_one_edit(\\"\\", \\"a\\") == True ``` # Explanation 1. The strings `\\"abc\\"` and `\\"ab\\"` are one edit apart by deleting `\'c\'`. 2. The strings `\\"abc\\"` and `\\"adc\\"` are one edit apart by substituting `\'b\'` with `\'d\'`. 3. The strings `\\"abc\\"` and `\\"abcd\\"` are one edit apart by inserting `\'d\'`. 4. The strings `\\"abc\\"` and `\\"abcde\\"` are not one edit apart because they require more than one insertion. 5. The strings `\\"\\"` and `\\"a\\"` are one edit apart by inserting `\'a\'`.","solution":"def is_one_edit(s: str, t: str) -> bool: len_s, len_t = len(s), len(t) # If the length difference is more than 1, they can\'t be one edit away if abs(len_s - len_t) > 1: return False # Ensure s is the shorter or equal length string for easier handling if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s # Flag to check if we have already found one difference found_difference = False i, j = 0, 0 while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True # If lengths are different, move pointer of the longer string if len_s != len_t: j += 1 continue i += 1 j += 1 # If we haven\'t found a difference so far, they could be one edit away if there\'s one extra char in t return found_difference or len_s < len_t"},{"question":"# Task: Implement a B-tree with Enhanced Features # Context A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insert, and delete operations in logarithmic time. It\'s extensively used in databases and file systems due to its admirable performance in handling large datasets with disk storage efficiency in mind. # Problem Statement You are required to implement a B-tree structure and ensure it supports efficient insertion, deletion, and search operations. Additionally, provide a method to count the total number of keys in the B-tree. You\'re given the skeleton code with the basic structure laid out and need to complete the missing parts to achieve a fully functional B-tree. # Requirements 1. **Complete the `insert_key` function** to handle the key insertion efficiently. 2. **Complete the `remove_key` function** ensuring balance is maintained after deletion. 3. **Implement a `count_keys` function** to return the number of keys currently in the B-tree. # Function Specifications 1. `insert_key(key: int) -> None`: Inserts a key into the B-tree. 2. `remove_key(key: int) -> bool`: Removes a key from the B-tree and returns `True` if the key was found and removed, `False` otherwise. 3. `find(key: int) -> bool`: Returns `True` if the key is found in the B-tree, `False` otherwise. 4. `count_keys() -> int`: Returns the total number of keys in the B-tree. # Input and Output * You will not be required to handle input/output in your functions. Use instance methods for inserting, deleting, and query keys. * Ensure your implementation can handle generic cases, edge cases, and performs within acceptable time limits for large datasets. # Constraints * The degree ( t ) of the B-tree is ( 2 le t le 4 ). * Keys are integers within the range ( -10^6 le text{key} le 10^6 ). * You should aim for a solution that works efficiently even with operations on thousands of keys. # Example ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) print(btree.find(10)) # Output: True print(btree.count_keys()) # Output: 2 btree.remove_key(20) print(btree.count_keys()) # Output: 1 ``` # Notes * Carefully handle all edge cases and ensure the tree remains balanced after every operation. * Make sure your implementation does not lose or misplace any keys during operations.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, False otherwise self.keys = [] # List of keys self.children = [] # List of child BTreeNode nodes class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def traverse(self): self._traverse(self.root) print() def _traverse(self, node): for i in range(len(node.keys)): if not node.leaf: self._traverse(node.children[i]) print(node.keys[i], end=\' \') if not node.leaf: self._traverse(node.children[len(node.keys)]) def find(self, key): return self._find(self.root, key) def _find(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return self._find(node.children[i], key) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.children.insert(0, root) self._split_child(temp, 0) self._insert_non_full(temp, key) else: self._insert_non_full(root, key) def _split_child(self, parent, i): t = self.t node = parent.children[i] new_node = BTreeNode(t, node.leaf) parent.keys.insert(i, node.keys[t - 1]) parent.children.insert(i + 1, new_node) new_node.keys = node.keys[t: (2 * t) - 1] node.keys = node.keys[0: t - 1] if not node.leaf: new_node.children = node.children[t: 2 * t] node.children = node.children[0: t] def _insert_non_full(self, node, key): if node.leaf: i = len(node.keys) - 1 node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: i = len(node.keys) - 1 while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key): if self.root is None: return False self._remove_key(self.root, key) if len(self.root.keys) == 0: if len(self.root.children) > 0: self.root = self.root.children[0] else: self.root = None return True def _remove_key(self, node, key): t = self.t if node.leaf: if key in node.keys: node.keys.remove(key) return True return False idx = self._find_key(node, key) if idx < len(node.keys) and node.keys[idx] == key: if len(node.children[idx].keys) >= t: pred = self._get_predecessor(node, idx) node.keys[idx] = pred self._remove_key(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_successor(node, idx) node.keys[idx] = succ self._remove_key(node.children[idx + 1], succ) else: self._merge(node, idx) self._remove_key(node.children[idx], key) else: if len(node.children[idx].keys) < t: if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) if idx <= len(node.keys): self._remove_key(node.children[idx], key) def _find_key(self, node, key): idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 return idx def _get_predecessor(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[- 1] return current.keys[- 1] def _get_successor(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children[-1]) node.keys[idx - 1] = sibling.keys.pop() if not sibling.leaf: sibling.children.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children[0]) node.keys[idx] = sibling.keys.pop(0) if not sibling.leaf: sibling.children.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(idx) node.children.pop(idx + 1) def count_keys(self): return self._count_keys(self.root) def _count_keys(self, node): if node is None: return 0 count = len(node.keys) for child in node.children: count += self._count_keys(child) return count"},{"question":"# Task: Implement Efficient Substring Search Given two strings, `haystack` and `needle`, write a function `find_substring(haystack, needle)` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Input - `haystack`: A string with length up to 10^6. - `needle`: A string with length up to 10^5. # Output - An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not in `haystack`. # Constraints - The function should handle all edge cases efficiently. - Aim for a time complexity better than O(N*M), where N is the length of `haystack` and M is the length of `needle`. # Example ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" find_substring(haystack, needle) # Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" find_substring(haystack, needle) # Output: -1 # Example 3 haystack = \\"mississippi\\" needle = \\"issip\\" find_substring(haystack, needle) # Output: 4 # Example 4 haystack = \\"\\" needle = \\"\\" find_substring(haystack, needle) # Output: 0 # Example 5 haystack = \\"abcdef\\" needle = \\"\\" find_substring(haystack, needle) # Output: 0 ``` # Additional Notes Consider using the Knuth-Morris-Pratt (KMP) or Rabin-Karp algorithm for better efficiency. Implementing such algorithms will require understanding of prefix functions or rolling hash methods.","solution":"def find_substring(haystack, needle): Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Utilizes the Knuth-Morris-Pratt (KMP) algorithm for efficient searching. if not needle: # Special case when needle is empty return 0 # Helper function to generate the \'longest prefix suffix\' (LPS) array for KMP def compute_lps(pattern): lps = [0] * len(pattern) length = 0 # Length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps # KMP search algorithm lps = compute_lps(needle) i = 0 # Index for haystack j = 0 # Index for needle while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j # Found needle in haystack elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1 # Needle not found in haystack"},{"question":"# Question: Implement an Optimized FFT with Decimation in Time **Context**: You are working on a signal processing project where you need to efficiently compute the Discrete Fourier Transform (DFT) of a signal represented as an array of complex numbers. Given the importance of efficient computation for real-time processing, you decide to use the Fast Fourier Transform (FFT) algorithm. **Task**: Implement an optimized version of the Cooley-Tukey FFT algorithm that operates without recursion and is based on decimation in time. Your function should handle arrays whose sizes are powers of two. The input will be an array of complex numbers, and your output should be the DFT of the input array. **Function Signature**: ```python def optimized_fft(x): Optimized FFT implementation using decimation in time. :param x: List[complex] - Input array of complex numbers (size is a power of 2) :return: List[complex] - Transformed array (DFT of input) ``` **Input Format**: * A list of complex numbers `x` where the length N of the list is a power of 2 (i.e., N = 2^k for some integer k). **Output Format**: * A list of complex numbers representing the DFT of the input array. **Constraints**: * The size of the input list will always be a power of two, ranging from 2 to 2^16. **Example**: ```python input_signal = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output_signal = optimized_fft(input_signal) print(output_signal) # Output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` **Notes**: * Aim for an implementation that avoids recursive calls. * Ensure your implementation effectively utilizes the decimation in time strategy. * You may use the cmath library for complex number operations.","solution":"import cmath def optimized_fft(x): Optimized FFT implementation using decimation in time. :param x: List[complex] - Input array of complex numbers (size is a power of 2) :return: List[complex] - Transformed array (DFT of input) n = len(x) if n <= 1: return x # Bit-reversal permutation indices = list(range(n)) indices = sorted(indices, key=lambda i: bin(i)[2:].zfill(len(bin(n)) - 2)[::-1]) # Perform bit-reversal permutation on input array x = [x[i] for i in indices] # Main FFT loop step = 2 while step <= n: half_step = step // 2 w_m = cmath.exp(-2j * cmath.pi / step) for k in range(0, n, step): w = 1 for j in range(half_step): t = w * x[k + j + half_step] u = x[k + j] x[k + j] = u + t x[k + j + half_step] = u - t w *= w_m step *= 2 return x"},{"question":"You are required to implement a `SegmentTree` class for solving range queries and point updates on an array, utilizing any commutative binary function of your choice. The SegmentTree should efficiently support queries for any given segment and updates on individual elements. # Detailed Requirements 1. **Class Structure**: - `__init__(self, arr, function)`: Initialize the Segment Tree with the array `arr` and a commutative function `function`. - `build_tree(self)`: Method to build the tree from the array. - `update(self, p, v)`: Update element at index `p` to new value `v`. - `query(self, l, r)`: Query the result of commutative function over the range [l, r]. 2. **Input**: - `arr` (list): Initial array of elements. - `function` (callable): A commutative binary function applied to elements. - `p` (integer): Index in array to update. - `v` (any): New value for update. - `l`, `r` (integers): Indices to define query range inclusive. 3. **Output**: - For `query(l, r)`: Return result of the commutative function application over specified range. - For `update(p, v)`: Adjust Segment Tree and confirm internally. 4. **Constraints**: - Function should be associative and commutative. - Support multiple data types: integers, tuples, custom objects supporting `function`. - Efficient within constraints: 1 ≤ `len(arr)` ≤ 10^5, supporting multiple updates and queries. # Example ```python mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Implement the class ensuring correct performance and handling of edge cases explicitly. You may assume function passed is always valid within the defined constraints.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) self._build_tree(arr) def _build_tree(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Update the leaf node pos = p + self.n self.tree[pos] = v # Move upwards and update parents while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l, r): # Query in the range [l, r] res = None l += self.n r += self.n + 1 while l < r: if l % 2 == 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Ternary Search Implementation Given a sorted array `arr` and a target value `key`, implement the Ternary Search Algorithm to find the index of `key` within the array. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: list) -> int: ``` Input - `left` (int): The starting index of the search interval. - `right` (int): The ending index of the search interval. - `key` (int): The value to search for. - `arr` (list): A list of integers sorted in non-decreasing order. Output - (int): The index of `key` in `arr` if found. Returns `-1` if `key` is not found in the array. Constraints - The length of the `arr` is in the range [0, (10^6)]. - Each element in the `arr` fits within the limits of a signed 32-bit integer. Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: 4 arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] key = 15 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: -1 ``` Performance Requirements - Implement the search algorithm with (O(log_3 N)) time complexity and (O(1)) additional space complexity. Notes - You must handle empty arrays and ensure the function returns `-1` when the `key` is not present. - Ensure that the function correctly identifies elements at the boundaries and within sections defined by `mid1` and `mid2`.","solution":"def ternary_search(left: int, right: int, key: int, arr: list) -> int: Implements the ternary search algorithm to find the index of `key` in `arr`. Args: left (int): The starting index of the search interval. right (int): The ending index of the search interval. key (int): The value to search for. arr (list): A list of integers sorted in non-decreasing order. Returns: int: The index of `key` in `arr` if found; otherwise, returns -1. while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Question: You are required to implement a function `has_negative_cycle(graph: Dict[str, Dict[str, int]], source: str) -> bool` which determines if the graph contains any negative weight cycles reachable from the given source vertex. The input graph is represented as a dictionary of dictionaries, where the keys are the vertex names (strings), and the values are dictionaries mapping adjacent vertices to edge weights (integers). Input: * `graph`: A dictionary representing the graph. * `source`: The source vertex (string) from which the check starts. Output: * `True` if there is a negative weight cycle reachable from the source. * `False` otherwise. Constraints: 1. The number of vertices (|V|) and edges (|E|) in the graph can each be up to 1000. 2. Edge weights are integers. Example: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } source = \'a\' print(has_negative_cycle(graph, source)) # Output: False ``` Write the function `has_negative_cycle` to help detect if the graph contains a negative weight cycle reachable from the specified source vertex.","solution":"def has_negative_cycle(graph, source): Determines if the graph contains any negative weight cycles reachable from the given source vertex. # Initialize distances from the source to all vertices as infinity and source to itself as 0 dist = {vertex: float(\'inf\') for vertex in graph} dist[source] = 0 # Relax edges |V| - 1 times for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if dist[u] != float(\'inf\') and dist[u] + graph[u][v] < dist[v]: dist[v] = dist[u] + graph[u][v] # Check for negative-weight cycles for u in graph: for v in graph[u]: if dist[u] != float(\'inf\') and dist[u] + graph[u][v] < dist[v]: return True return False"},{"question":"# Binary Search Tree Operations and Properties Problem Statement Implement a Binary Search Tree (BST) with the following functionalities: 1. **Insertion**: Insert a new integer into the BST. 2. **Search**: Determine if an integer exists in the BST. 3. **Get Size**: Return the number of nodes in the BST. 4. **Traversals**: Perform and print the Preorder, Inorder, and Postorder traversals of the BST. Requirements * **Input Format**: * For insertion: A list of integers to be inserted into the BST. * For search: An integer to be searched in the BST. * **Output Format**: * For search: Boolean indicating whether the integer exists in the BST. * For size: An integer representing the number of nodes. * For traversals: List of integers representing the traversal sequence. * **Constraints**: * The tree will be composed of integers. * Duplicate integers should not be inserted into the BST. * **Performance**: * Aim to achieve average case O(log N) complexity for insertion and search. Task You need to implement a class `BST` with the following methods: 1. **insert(data: int) -> bool**: Inserts `data` into the BST. Returns `True` if inserted and `False` if `data` already exists. 2. **search(data: int) -> bool**: Returns `True` if `data` exists in the BST, otherwise `False`. 3. **size() -> int**: Returns the number of nodes in the BST. 4. **preorder() -> List[int]**: Returns the list of elements in Preorder traversal of the BST. 5. **inorder() -> List[int]**: Returns the list of elements in Inorder traversal of the BST. 6. **postorder() -> List[int]**: Returns the list of elements in Postorder traversal of the BST. Example Create a BST and perform the following operations: - Insert elements: `[10, 15, 6, 4, 9, 12, 24, 7, 20, 30, 18]` - Search for the element `24`: Returns `True` - Search for the element `50`: Returns `False` - Get size of the tree: Returns `11` - Perform Inorder traversal: Returns `[4, 6, 7, 9, 10, 12, 15, 18, 20, 24, 30]` Function Definitions ```python class BST: def insert(self, data: int) -> bool: pass def search(self, data: int) -> bool: pass def size(self) -> int: pass def preorder(self) -> List[int]: pass def inorder(self) -> List[int]: pass def postorder(self) -> List[int]: pass ``` Complete the `BST` class to provide the required functionalities as described.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self._size = 0 def insert(self, data: int) -> bool: if self.root is None: self.root = Node(data) self._size += 1 return True else: return self._insert_rec(self.root, data) def _insert_rec(self, node, data): if data == node.data: return False elif data < node.data: if node.left is None: node.left = Node(data) self._size += 1 return True else: return self._insert_rec(node.left, data) else: if node.right is None: node.right = Node(data) self._size += 1 return True else: return self._insert_rec(node.right, data) def search(self, data: int) -> bool: return self._search_rec(self.root, data) def _search_rec(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search_rec(node.left, data) else: return self._search_rec(node.right, data) def size(self) -> int: return self._size def preorder(self) -> list: result = [] self._preorder_traversal(self.root, result) return result def _preorder_traversal(self, node, result): if node: result.append(node.data) self._preorder_traversal(node.left, result) self._preorder_traversal(node.right, result) def inorder(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.data) self._inorder_traversal(node.right, result) def postorder(self) -> list: result = [] self._postorder_traversal(self.root, result) return result def _postorder_traversal(self, node, result): if node: self._postorder_traversal(node.left, result) self._postorder_traversal(node.right, result) result.append(node.data)"},{"question":"# Question: Increment Number Array You\'ve been provided with three versions of an algorithm designed to increment an array of digits that represent a non-negative integer by one. Task: Implement a new function `efficient_plus_one(digits: List[int]) -> List[int]` to achieve the same goal, applying best practices from the given snippets and incorporating the following improvements: 1. **Optimize Space Complexity**: Use in-place updates wherever possible. 2. **Improve Readability and Maintainability**: Ensure the code is clean, concise, and well-commented. Input: - `digits`: A list of non-negative single-digit integers (`0 <= digits[i] <= 9`). It is guaranteed that this list will not be empty and will not contain leading zeros unless the input is `[0]`. Output: - A list of integers representing the number incremented by one. Constraints: - The algorithm should run in O(n) time, where n is the number of digits. - The space complexity should be O(1) for in-place updates. Example: ```python assert efficient_plus_one([1, 2, 3]) == [1, 2, 4] assert efficient_plus_one([4, 3, 2, 1]) == [4, 3, 2, 2] assert efficient_plus_one([9, 9, 9]) == [1, 0, 0, 0] ``` Performance Requirements: - Handle arrays with up to 10^4 digits efficiently. Create and test your function to ensure it meets the requirements.","solution":"from typing import List def efficient_plus_one(digits: List[int]) -> List[int]: Efficiently increments an array of digits representing a non-negative integer by one. Parameters: digits (List[int]): List of single digit integers representing the number. Returns: List[int]: List of single digit integers representing the incremented number. n = len(digits) # Traverse the list from the last digit for i in range(n - 1, -1, -1): if digits[i] < 9: # If the current digit is not 9, increment it by 1 digits[i] += 1 return digits digits[i] = 0 # If the current digit is 9, set it to 0 # If all digits are 9, we need an additional digit at the beginning return [1] + [0] * n"},{"question":"# Question: Check Strongly Connected Components in a Directed Graph You are given a directed graph with `n` vertices. Write a function to determine if the directed graph is strongly connected. A directed graph is strongly connected if there is a path between any pair of vertices in both directions. Implement the following python function: ```python def is_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool: Determine if the directed graph is strongly connected. :param n: The number of vertices in the graph. :param edges: A list of tuples (source, target) representing the directed edges in the graph. :return: True if the graph is strongly connected, False otherwise. pass ``` # Input - `n`: An integer representing the number of vertices in the graph. - `edges`: A list of tuples. Each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. # Output - Return `True` if the graph is strongly connected, `False` otherwise. # Constraints - The number of vertices `n` will be in the range [1, 1000]. - The number of edges will be in the range [0, 10000]. # Example Example 1: ```python n = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (1, 3), (2, 4)] print(is_strongly_connected(n, edges)) # Output: True ``` Example 2: ```python n = 4 edges = [(0, 1), (1, 2), (2, 3)] print(is_strongly_connected(n, edges)) # Output: False ``` # Explanation 1. **Example 1**: All vertices can reach every other vertex directly or indirectly, hence the graph is strongly connected. 2. **Example 2**: There\'s no way to get back from vertex `3` to others, hence the graph is not strongly connected. # Detailed Requirements - Implement the `Graph` class and its methods as necessary (similar to provided code snippets). - Use the properties of DFS and reverse DFS as mentioned in the analysis to check for strong connectivity. - Ensure robust handling of edge cases such as isolated nodes or empty edge lists.","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def is_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool: def build_graph(n: int, edges: List[Tuple[int, int]]) -> Dict[int, List[int]]: graph = defaultdict(list) for u, v in edges: graph[u].append(v) return graph def bfs(start: int, graph: Dict[int, List[int]]) -> bool: visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n graph = build_graph(n, edges) reverse_graph = build_graph(n, [(v, u) for u, v in edges]) # Check the graph is reachable from any node if not bfs(0, graph): return False # Check if the reverse graph is reachable from any node if not bfs(0, reverse_graph): return False return True"},{"question":"**Scenario**: You are hired as a software engineer at a company managing transaction logs. Each transaction log is stored in a stack where each element represents a transaction ID. The operations team needs to verify if the transaction IDs are consecutive starting from the bottom of the stack. Your task is to implement a function that checks if the transaction IDs are consecutive. Use Python to implement this. You have access to two auxiliary storage mechanisms: a stack and a queue. You will need to demonstrate your solution using both. # Requirements: Implement two functions in Python: 1. `first_is_consecutive(stack: list) -> bool`: Uses an auxiliary stack to verify if the original stack has consecutive integers. 2. `second_is_consecutive(stack: list) -> bool`: Uses a queue to verify if the original stack has consecutive integers. # Function Signatures: ```python def first_is_consecutive(stack: list) -> bool: pass def second_is_consecutive(stack: list) -> bool: pass ``` # Input: - `stack` (list of integers): A list of integers representing the stack. The bottom of the stack is the first element of the list. # Output: - `bool`: Returns True if stack contains consecutive integers, otherwise returns False. # Constraints: - Each element in the stack will represent a positive integer. - The stack may contain up to 10^5 elements. # Example: ```python # Example input stack1 = [3, 4, 5, 6, 7] assert first_is_consecutive(stack1) == True assert second_is_consecutive(stack1) == True stack2 = [3, 4, 6, 7] assert first_is_consecutive(stack2) == False assert second_is_consecutive(stack2) == False stack3 = [3, 2, 1] assert first_is_consecutive(stack3) == False assert second_is_consecutive(stack3) == False ``` # Notes: - Ensure your solution restores the original stack after checking for consecutiveness. - Optimize the solutions for large stacks within the provided constraints.","solution":"def first_is_consecutive(stack: list) -> bool: Verify if the stack has consecutive integers using an auxiliary stack. The function restores the original stack after the check. if not stack: return True # An empty stack is trivially consecutive auxiliary_stack = [] is_consecutive = True while stack: auxiliary_stack.append(stack.pop()) previous = auxiliary_stack.pop() stack.append(previous) while auxiliary_stack: current = auxiliary_stack.pop() stack.append(current) if current != previous + 1: is_consecutive = False previous = current return is_consecutive def second_is_consecutive(stack: list) -> bool: Verify if the stack has consecutive integers using a queue. The function restores the original stack after the check. if not stack: return True # An empty stack is trivially consecutive from collections import deque queue = deque() is_consecutive = True while stack: queue.append(stack.pop()) previous = queue.pop() stack.append(previous) while queue: current = queue.pop() stack.append(current) if current != previous + 1: is_consecutive = False previous = current return is_consecutive"},{"question":"# Graph Clone Assessment **Objective**: Implement a function that clones an undirected graph using recursive DFS. This task will assess your understanding of graph traversal and deep copying. Function Description ```python def clone_graph_recursive_dfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': Returns a deep copy of the given undirected graph starting from `node` using a recursive depth first search (DFS). Parameters: - node (UndirectedGraphNode): The starting node of the graph. Returns: - UndirectedGraphNode: The starting node of the cloned graph. pass ``` Input & Output * **Input**: The function receives a node of an undirected graph (`UndirectedGraphNode`), where each node contains: - A label (unique identifier). - A list of neighbors (adjacent nodes). * **Output**: The function returns a `UndirectedGraphNode` representing the starting node of the cloned graph, which should be an exact deep copy of the original graph. Constraints 1. The number of nodes in the graph is in the range [0, 100]. 2. Node labels are unique and represented as integers starting from 0. 3. The graph may contain cycles and self-loops. Example Given a graph with the following structure: ``` 1 - 2 / 0 3 ``` *Serialization*: {0,1,3#1,0,2#2,1#3,0} *Function Call Example*: ```python node_0 = UndirectedGraphNode(0) node_1 = UndirectedGraphNode(1) node_2 = UndirectedGraphNode(2) node_3 = UndirectedGraphNode(3) node_0.neighbors = [node_1, node_3] node_1.neighbors = [node_0, node_2] node_2.neighbors = [node_1] node_3.neighbors = [node_0] cloned_node = clone_graph_recursive_dfs(node_0) ``` Requirements - Use a recursive depth-first search (DFS) approach to clone the graph. - Ensure that each node and its connections are correctly replicated. - Handle edge cases including an empty graph and self-loops.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph_recursive_dfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': def dfs(node, visited): if node in visited: return visited[node] clone = UndirectedGraphNode(node.label) visited[node] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor, visited)) return clone if not node: return None return dfs(node, {})"},{"question":"# Coding Challenge: Enhanced Stack Manipulation Problem Statement You are provided with two implementations of a function `stutter` that duplicates each element in the given stack. Your task is to implement a new method called `optimized_stutter` which achieves the same objective more efficiently. Function Signature ```python def optimized_stutter(stack: list) -> list: pass ``` Input * A list `stack` representing a stack in LIFO order. Each element in `stack` can be any type. Output * Return a list where each element in the original stack is duplicated and retains the same order as the input stack. Constraints * Do not use any additional data structure (like another stack or a queue) explicitly. * The function should be optimized for both time and space. * Ensure that edge cases (e.g., empty stacks, stacks with identical elements) are handled properly. Example ```python stack = [3, 7, 1, 14, 9] print(optimized_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [] print(optimized_stutter(stack)) # Output: [] stack = [5] print(optimized_stutter(stack)) # Output: [5, 5] ``` Notes * Think about how you can avoid using additional data structures while still achieving the same objective. * Consider in-place modifications and additional techniques that can help optimize the performance.","solution":"def optimized_stutter(stack: list) -> list: n = len(stack) for i in range(n): stack.insert(2 * i, stack[2 * i]) return stack"},{"question":"Context: You are given a directed graph, and your task is to determine if there is a path between two specified nodes using a depth-first search (DFS) approach. Problem Statement: Implement the DFS algorithm to determine if there exists a path between two nodes in a marked directed graph. Consider optimizing for early exits when the target is found. Function Signature: Implement the function `is_reachable(graph: List[Tuple[int, int]], vertex_count: int, source: int, target: int) -> bool`. # Parameters: - `graph` (List[Tuple[int, int]]): A list of edges represented as tuples `(source, target)`. - `vertex_count` (int): The number of vertices in the graph. - `source` (int): The starting node for the pathfinding. - `target` (int): The destination node for the pathfinding. # Returns: - `bool`: Return `True` if there is a path from `source` to `target`, otherwise `False`. # Constraints: - 1 <= vertex_count <= 10^3 - 0 <= source, target < vertex_count - 0 <= len(graph) <= vertex_count * (vertex_count - 1) # Example: ```plaintext Input: graph = [(0, 1), (1, 2), (2, 3), (3, 4)] vertex_count = 5 source = 0 target = 4 Output: True Input: graph = [(0, 1), (1, 2), (2, 3), (3, 4)] vertex_count = 5 source = 0 target = 5 Output: False ``` Notes: - Ensure you mark nodes as visited to avoid cycles and infinite loops. - Optimize for performance to handle the upper limit constraints effectively. - Consider edge cases where source equals target, or the graph is empty.","solution":"from typing import List, Tuple def is_reachable(graph: List[Tuple[int, int]], vertex_count: int, source: int, target: int) -> bool: if source == target: return True adjacency_list = {i: [] for i in range(vertex_count)} for (src, tgt) in graph: adjacency_list[src].append(tgt) visited = [False] * vertex_count def dfs(node: int) -> bool: if node == target: return True visited[node] = True for neighbor in adjacency_list[node]: if not visited[neighbor]: if dfs(neighbor): return True return False return dfs(source)"},{"question":"# Permutation Generation **Background**: You are part of a team developing a sophisticated testing system that requires generating all possible permutations of a given list of distinct numbers. This system will be used to simulate different input configurations for various scenarios to ensure robust testing. **Task**: Write a function `generate_permutations(nums)` that takes a list of distinct integers `nums` and returns a list containing all possible permutations of `nums`. The function should handle lists of varying lengths efficiently. Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass ``` Input * A list of distinct integers `nums` (1 ≤ len(nums) ≤ 8) Output * A list of lists, where each inner list is a unique permutation of `nums`. Constraints * The input list will have a length between 1 and 8, inclusive. * The elements of the list will be distinct. Performance Requirements * While the maximum length is limited to 8, ensure your function is efficient and can handle edge cases gracefully. Examples ```python assert generate_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([0, -1, 1]) == [ [0, -1, 1], [0, 1, -1], [-1, 0, 1], [-1, 1, 0], [1, 0, -1], [1, -1, 0] ] assert generate_permutations([5]) == [[5]] assert generate_permutations([]) == [[]] ``` **Note**: Pay attention to edge cases, such as empty lists or single-element lists. Ensure that your solution is both correct and performant, given the constraints and expected inputs. You may use either recursive, iterative, or a combination of both strategies to solve this problem.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all permutations of a list of distinct integers. if len(nums) == 0: return [[]] # Helper function to generate permutations def backtrack(first = 0): # if all integers are used up if first == n: output.append(nums[:]) for i in range(first, n): # place i-th integer first in the current permutation nums[first], nums[i] = nums[i], nums[first] # use next integers to complete the permutations backtrack(first + 1) # backtrack nums[first], nums[i] = nums[i], nums[first] n = len(nums) output = [] backtrack() return output"},{"question":"You are building a financial application that processes various financial records. One specific requirement is to analyze the lengths of account numbers, which are always positive integers. To ensure data integrity, you need to implement an optimized function to determine the number of digits in these account numbers efficiently. Task Write a function `count_digits(number: int) -> int` that computes the number of digits in a given positive integer. Input - A single integer `number` (1 ≤ number ≤ 10^18). Output - An integer representing the number of digits in the given number. Constraints - You must not use string conversion methods to count the digits. - The function must perform in constant time, O(1). Example Input: ``` number = 12345 ``` Output: ``` 5 ``` Input: ``` number = 1000000000000000000 ``` Output: ``` 19 ``` Note You must handle the input such that it adheres to the given constraints and ensure the function meets the performance requirements. Implement the function `count_digits` accordingly: ```python import math def count_digits(number: int) -> int: Compute the number of digits in a given positive integer. Args: number (int): The input positive integer. Returns: int: The number of digits in the input number. # Your implementation here ```","solution":"import math def count_digits(number: int) -> int: Compute the number of digits in a given positive integer. Args: number (int): The input positive integer. Returns: int: The number of digits in the input number. if number <= 0: raise ValueError(\\"The input number must be positive.\\") return math.floor(math.log10(number)) + 1"},{"question":"# Coding Problem: Implement a Resizable Separate Chaining Hash Table Scenario A software system designed for managing a large set of user data requires a robust data structure capable of efficiently handling frequent inserts, deletes, and lookups. As an experienced developer, you are tasked with enhancing the functionality of a basic hash table that uses separate chaining to handle collisions. Currently, the hash table has a fixed size which might lead to performance degradation as more elements are added. Problem Statement Extend the `SeparateChainingHashTable` class to support automatic resizing when the load factor exceeds a given threshold. Implement the following methods: 1. **resize**: This method should double the size of the hash table and rehash all the existing entries. 2. **resize_if_necessary**: This method checks the current load factor and calls the `resize` method if it exceeds a specified threshold. 3. Update the existing `put` and `del_` methods to call `resize_if_necessary`. Constraints - Threshold for resizing should be set to `0.75` (i.e., when the load factor exceeds 75%). - The `resize` method should ensure that all entries are rehashed and correctly placed in the new larger table. - The hash table size should always be a prime number to reduce the likelihood of collisions. Expected Input and Output - **resize**: No input parameters. - **resize_if_necessary**: No input parameters. - Methods should update the internal table and maintain the integrity of all entries. - The size change should be reflected in subsequent operations. Example: ```python # Initialize the hash table table = SeparateChainingHashTable() # Add multiple key-value pairs for i in range(20): table.put(f\'key{i}\', f\'value{i}\') # Check the internal size of the array to confirm resizing print(len(table._table)) # Should reflect a new larger size (prime number) # Check that all previously added elements are correctly accessible print(table.get(\'key10\')) # Should output \'value10\' print(table.get(\'key5\')) # Should output \'value5\' ``` Your Task Implement the `resize` and `resize_if_necessary` methods in the `SeparateChainingHashTable` class, and ensure the existing methods (`put`, `del_`, etc.) are updated as necessary to support seamless resizing of the hash table.","solution":"import sympy class SeparateChainingHashTable: def __init__(self, initial_capacity=11): self._table = [[] for _ in range(initial_capacity)] self._n_items = 0 self._load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % len(self._table) def put(self, key, value): self.resize_if_necessary() bucket = self._table[self._hash(key)] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self._n_items += 1 def get(self, key): bucket = self._table[self._hash(key)] for (k, v) in bucket: if k == key: return v return None def del_(self, key): self.resize_if_necessary() bucket = self._table[self._hash(key)] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self._n_items -= 1 return def resize(self): old_table = self._table new_size = sympy.nextprime(2 * len(old_table)) self._table = [[] for _ in range(new_size)] self._n_items = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def resize_if_necessary(self): load_factor = self._n_items / len(self._table) if load_factor > self._load_factor_threshold: self.resize()"},{"question":"# Missing Ranges Identification Challenge Context You are working as a software engineer responsible for maintaining a sequence generator validation tool. Your task is to identify gaps within sequences of numbers to ensure all expected values are present. Task Write a function `find_missing_ranges(arr, lo, hi)` that finds the missing ranges between a lower bound (`lo`) and upper bound (`hi`) in the given sorted array `arr`. Input - `arr`: A sorted list of unique integers. - `lo`: An integer representing the lower bound. - `hi`: An integer representing the upper bound. Output - A list of tuples representing the inclusive ranges of missing numbers between `lo` and `hi`. Constraints - The array `arr` is guaranteed to have unique integers in a sorted order. - `lo` and `hi` are inclusive bounds such that `lo <= hi`. - The bounds (`lo` and `hi`) and elements in `arr` are all integers within the range of 32-bit signed integers. Example ```python # Example 1 arr = [3, 5] lo = 1 hi = 10 # Missing ranges are [(1, 2), (4, 4), (6, 10)] print(find_missing_ranges(arr, lo, hi)) # Example 2 arr = [1, 3, 50, 75] lo = 0 hi = 99 # Missing ranges are [(0, 0), (2, 2), (4, 49), (51, 74), (76, 99)] print(find_missing_ranges(arr, lo, hi)) # Example 3 arr = [] lo = 10 hi = 15 # Missing ranges are [(10, 15)] print(find_missing_ranges(arr, lo, hi)) ``` Notes - Ensure you handle the edge cases correctly including empty arrays and arrays with no missing numbers. - Optimize for performance with linear time complexity, if possible.","solution":"def find_missing_ranges(arr, lo, hi): Finds the missing ranges between lo and hi in the given sorted array arr. Parameters: arr (list[int]): A sorted list of unique integers. lo (int): Lower bound (inclusive). hi (int): Upper bound (inclusive). Returns: list[tuple[int, int]]: A list of tuples representing the inclusive ranges of missing numbers. missing_ranges = [] prev = lo - 1 for num in arr: if num == prev + 2: missing_ranges.append((prev + 1, prev + 1)) elif num > prev + 2: missing_ranges.append((prev + 1, num - 1)) prev = num if hi == prev + 1: missing_ranges.append((prev + 1, prev + 1)) elif hi > prev + 1: missing_ranges.append((prev + 1, hi)) return missing_ranges"},{"question":"# Question You are required to implement a **Heap Sort** function that sorts an array in ascending order using a **max heap** approach. To assess your understanding of the algorithm and its properties, you should provide a detailed implementation of the core functions and handle various edge cases effectively. Implement the function `heap_sort(arr: List[int], simulation: bool=False) -> List[int]` to sort an array of integers in ascending order. Requirements: 1. **Input**: - `arr`: List of integers, `1 <= len(arr) <= 1000`. - `simulation`: Boolean flag, if `True`, you need to print the array status after each significant operation (iteration). 2. **Output**: - Sorted list of integers in ascending order. 3. **Constraints**: - The algorithm should run in O(n log(n)) time complexity. - Sorting should be done in-place (space complexity O(1)). - Handle edge cases correctly. 4. **Edge Cases to Consider**: - Empty list (`[]`). - List with one element ([single integer]). - List with all identical elements. - Already sorted list. 5. **Performance Requirements**: - Your implementation should efficiently sort the array adhering to the mentioned constraints and complexity requirements. # Example: ```python # Example test case arr = [4, 10, 3, 5, 1] simulation = True print(heap_sort(arr, simulation)) # Expected Output # Simulated output after each iteration step by max_heapify and heap_sort # followed by final sorted array [1, 3, 4, 5, 10] ```","solution":"from typing import List def heapify(arr: List[int], n: int, i: int, simulation: bool) -> None: largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"heapify: {arr}\\") heapify(arr, n, largest, simulation) def heap_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) if simulation: print(f\\"initial array: {arr}\\") # Build max heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, simulation) if simulation: print(f\\"max heap: {arr}\\") # Extract elements one by one for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"extract max: {arr}\\") heapify(arr, i, 0, simulation) if simulation: print(f\\"sorted array: {arr}\\") return arr"},{"question":"In a logistics company, there are several delivery routes represented as sorted linked lists, where each node holds a delivery timestamp. The company wants to merge these routes into a single sorted linked list to generate a global delivery schedule. Implement a function `merge_k_routes` that takes an array of k sorted linked list routes and returns a single sorted linked list representing the merged delivery schedule. # Function Signature ```python def merge_k_routes(routes): Merge multiple sorted linked list routes into a single sorted list. :param routes: List[ListNode], a list of ListNode where each ListNode represents the head of a sorted linked list. :return: ListNode, the head of the merged sorted linked list. ``` # Input * `routes`: A list of `ListNode` objects, representing the heads of k sorted linked lists. # Output * A `ListNode` object representing the head of the merged sorted linked list. # Constraints * `0 <= len(routes) <= 10^4` * `0 <= number of nodes in each linked list <= 500` * `-10^4 <= ListNode.val <= 10^4` * The linked lists are sorted in non-decreasing order. # Example ```python # Example list nodes creation node1 = ListNode(1) node1.next = ListNode(4) node1.next.next = ListNode(5) node2 = ListNode(1) node2.next = ListNode(3) node2.next.next = ListNode(4) node3 = ListNode(2) node3.next = ListNode(6) routes = [node1, node2, node3] # Call to merge the routes merged_head = merge_k_routes(routes) # Expected merged result: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 ``` Implement the function with optimal time complexity and space complexity considerations as described in the analysis. Ensure your implementation is efficient for the provided constraints.","solution":"from heapq import heappop, heappush class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_routes(routes): Merge multiple sorted linked list routes into a single sorted list. :param routes: List[ListNode], a list of ListNode where each ListNode represents the head of a sorted linked list. :return: ListNode, the head of the merged sorted linked list. min_heap = [] # Initialize the heap with the head of each linked list for i, route in enumerate(routes): if route: heappush(min_heap, (route.val, i, route)) dummy = ListNode() # Dummy node to facilitate the merge process current = dummy while min_heap: val, idx, node = heappop(min_heap) current.next = node current = current.next if node.next: heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"# Minimum Spanning Tree with Edge Constraints You are given an undirected, connected, weighted graph represented by (V) vertices and (E) edges. Your task is to find the Minimum Spanning Tree (MST) for this graph using the Kruskal\'s algorithm. However, you need to implement a feature that allows you to exclude specific edges from being considered in the MST. Input: * An integer (V) (number of vertices) and (E) (number of edges). * Next (E) lines each containing three integers (u), (v) (vertices connected by the edge), and (w) (weight of the edge). * An integer (K) representing the number of edges that should be excluded. * Next (K) lines each containing two integers (a) and (b) which describe the edges to be excluded. Output: * An integer representing the weight sum of the MST or -1 if no MST can be formed with the given constraints. Constraints: * (1 leq V leq 1000) * (1 leq E leq 10000) * (1 leq w leq 1000) * Vertices are 1-indexed. * If no MST can be formed with the given constraints, return -1. # Example Input: ```plaintext 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 1 1 3 ``` # Example Output: ```plaintext 14 ``` # Explanation: In the given example, the edge (1,3) with weight 8 is excluded from consideration. The MST constructed from the remaining edges is {[1,2,3], [2,4,5], [3,4,2], [3,5,4]} with a total weight of 14. # Additional Notes: * Ensure that you correctly handle the exclusion of edges. * Consider edge cases where input graphs are particularly small or constraints make MST formation impossible. * Optimize the performance of the union-find operations using path compression and union by rank.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 def kruskal_mst_with_exclusions(V, edges, K, exclusions): exclude_set = set((a - 1, b - 1) if a < b else (b - 1, a - 1) for a, b in exclusions) # Filter edges to exclude specified ones filtered_edges = [(w, u - 1, v - 1) for u, v, w in edges if (u - 1, v - 1) not in exclude_set and (v - 1, u - 1) not in exclude_set] # Sort edges based on their weights filtered_edges.sort() uf = UnionFind(V) mst_weight = 0 edge_count = 0 for w, u, v in filtered_edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += w edge_count += 1 if edge_count == V - 1: return mst_weight return -1 # Example Usage: # V = 5 # edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] # K = 1 # exclusions = [(1, 3)] # result = kruskal_mst_with_exclusions(V, edges, K, exclusions) # print(result) # Output should be 14"},{"question":"Coding Assessment Question # Scenario You\'re hired by a telecommunications company to design an optimal networking infrastructure that minimizes the total cost of cable required to connect multiple cities. The company has provided the distances (in kilometers) between various pairs of cities, and your task is to determine the minimum total length of cable that connects all the cities. # Problem Statement Given a number of cities and a list of bids where each bid consists of a pair of cities and the distance between them, write a function to calculate the minimum total length of cable required to connect all the cities. You should use Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) of this graph. # Function Signature ```python def minimum_cable_length(city_count: int, bids: List[Tuple[int, int, int]]) -> int: pass ``` # Input * **city_count**: An integer (n) representing the number of cities (1 ≤ (n) ≤ 10^4). * **bids**: A list of tuples where each tuple consists of three integers (u), (v), and (w) representing a bid between city (u) and city (v) with the distance (w) (1 ≤ (u, v) ≤ (n), 1 ≤ (w) ≤ 10^5). # Output * **int**: Return the minimum total length of cable required to connect all cities. If it is not possible to connect all cities, return -1. # Constraints * Ensure that the input graph is undirected. * Multiple bids may exist for the same pair of cities with different distances. * At least (n-1) bids are required to connect (n) cities. # Examples Example 1 **Input**: ```python city_count = 4 bids = [ (1, 2, 3), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 4, 1) ] ``` **Output**: ```python 6 ``` Example 2 **Input**: ```python city_count = 3 bids = [ (1, 2, 2), (2, 3, 3) ] ``` **Output**: ```python 5 ``` Example 3 **Input**: ```python city_count = 5 bids = [ (1, 2, 4), (1, 3, 8), (2, 3, 3), (3, 4, 5), (4, 5, 6) ] ``` **Output**: ```python 18 ``` # Notes * Ensure that your implementation handles large inputs efficiently. * The cities are indexed from 1 to (n).","solution":"def minimum_cable_length(city_count: int, bids: list) -> int: Calculate the minimum total length of cable required to connect all cities using Kruskal\'s algorithm. Parameters: city_count (int): The number of cities. bids (List[Tuple[int, int, int]]): A list of tuples where each tuple consists of three integers representing a bid between two cities with the distance between them. Returns: int: The minimum total length of cable required to connect all cities, or -1 if not possible. # Helper function to find the root of a node def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to union two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Step 1: Sort all the edges in non-decreasing order of their weights sorted_bids = sorted(bids, key=lambda x: x[2]) parent = [i for i in range(city_count + 1)] rank = [0] * (city_count + 1) mst = [] # This will store the resultant MST total_length = 0 # To store the total length of cable # Step 2: Iterate through sorted bids and apply Kruskal\'s algorithm for u, v, w in sorted_bids: root_u = find(parent, u) root_v = find(parent, v) # If including this edge doesn\'t cause a cycle if root_u != root_v: mst.append((u, v, w)) total_length += w union(parent, rank, root_u, root_v) # Check if we have included exactly (city_count - 1) edges in our MST if len(mst) == city_count - 1: return total_length else: return -1"},{"question":"# Question: Implement Optimized Exchange Sort Given the simple Exchange Sort algorithm, you are tasked with optimizing it. The optimized version should handle some of the performance drawbacks by reducing unnecessary swaps and comparisons. Additionally, the implementation must be robust and handle edge cases effectively. Function Signature ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: pass ``` Input * A single list of integers, `arr`, where 0 ≤ len(arr) ≤ 1000. Output * A sorted list of integers in ascending order. Constraints * Ensure that the function runs with improved efficiency over the basic Exchange Sort algorithm. * Incorporate checks for edge cases like empty lists and lists with a single element. * Avoid unnecessary swaps wherever possible. # Example ```python assert optimized_exchange_sort([3, 2, 1]) == [1, 2, 3] assert optimized_exchange_sort([]) == [] assert optimized_exchange_sort([1, 1, 1]) == [1, 1, 1] assert optimized_exchange_sort([-2, 5, 3, 0]) == [-2, 0, 3, 5] ``` # Performance Requirements * The implementation must show significant performance improvement over the naive Exchange Sort. * Stay mindful of edge cases and optimize for the best average case performance. * Use Python\'s List data structure and basic operators. Good luck, and may your code be both elegant and efficient!","solution":"from typing import List def optimized_exchange_sort(arr: List[int]) -> List[int]: Optimized version of Exchange Sort. n = len(arr) if n <= 1: return arr # Initialize a variable to track if a swap happened swapped = True for i in range(n-1): if not swapped: break # Assume no swaps initially swapped = False for j in range(n-1-i): if arr[j] > arr[j+1]: # Swap elements arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # A swap has happened return arr"},{"question":"# Filter an Array by Value Range Consider you are developing a software that analyzes sensor data. You often need to filter the data to exclude readings that are too low or too high, based on certain threshold values. To facilitate this, you need to implement a function that filters a list of numerical readings based on provided minimum and maximum values. **Task:** Write a function `filter_by_range` that takes in three parameters: - `arr` (list of int or float): the list of sensor readings. - `min_val` (int or float or None): the minimum threshold value to include in the result. If `None`, treat as no minimum limit. - `max_val` (int or float or None): the maximum threshold value to include in the result. If `None`, treat as no maximum limit. The function should return a list of readings from `arr` filtered to include only those within the inclusive range `[min_val, max_val]`. If both `min_val` and `max_val` are `None`, the result should be the original array. **Function Signature:** ```python def filter_by_range(arr: List[Union[int, float]], min_val: Optional[Union[int, float]] = None, max_val: Optional[Union[int, float]] = None) -> List[Union[int, float]]: ``` **Input:** * `arr`: A list of integers or floats (0 <= len(arr) <= 10^6). * `min_val`: An integer or float or None representing the minimum value (If `None`, no minimum limit is applied). * `max_val`: An integer or float or None representing the maximum value (If `None`, no maximum limit is applied). **Output:** * A list of integers or floats containing only those elements within the inclusive range `[min_val, max_val]`. **Constraints:** * The list can be empty. * The values in the list and the min/max values can be both positive and negative. **Example:** ```python assert filter_by_range([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_by_range([10, 20, 30, 40, 50], 15, None) == [20, 30, 40, 50] assert filter_by_range([5, -1, 7.5, 3.5, 0], -2, 2) == [-1, 0] assert filter_by_range([], 10, 20) == [] assert filter_by_range([1, 2, 3], None, None) == [1, 2, 3] ``` **Note:** - Ensure the function correctly handles edge cases such as empty input lists and `None` values for `min_val` and `max_val`.","solution":"from typing import List, Union, Optional def filter_by_range(arr: List[Union[int, float]], min_val: Optional[Union[int, float]] = None, max_val: Optional[Union[int, float]] = None) -> List[Union[int, float]]: Filters elements in the array based on the provided minimum and maximum values. Parameters: arr (list): List of numerical readings (int or float). min_val (int, float or None): Minimum threshold value to include in the result. If None, no lower limit. max_val (int, float or None): Maximum threshold value to include in the result. If None, no upper limit. Returns: list: A list of readings within the inclusive range [min_val, max_val]. if min_val is None and max_val is None: return arr return [x for x in arr if (min_val is None or x >= min_val) and (max_val is None or x <= max_val)]"},{"question":"# Anagram Checker Using HashMap **Context**: In a text-based application, it\'s crucial to identify if two words are anagrams of each other in various scenarios such as spell checking, and word game validations. **Task**: Write a Python function `anagram_checker` that determines if two input strings are anagrams of each other without assuming the strings are limited to lowercase English letters. Your solution must handle any alphanumeric characters and must be case-insensitive. # Specifications * **Function Name**: anagram_checker * **Input**: * `str1`: a string (1 <= len(str1) <= 10^6) * `str2`: a string (1 <= len(str2) <= 10^6) * **Output**: * Return `True` if the strings are anagrams, otherwise return `False`. * **Constraints**: * Two strings are anagrams if they contain the same characters with the same frequencies. * The function should be case-insensitive. * Ignore spaces within the strings. # Example ```python assert anagram_checker(\\"Listen\\", \\"Silent\\") == True assert anagram_checker(\\"This is fun\\", \\"Fun is this\\") == True assert anagram_checker(\\"apple\\", \\"cherry\\") == False assert anagram_checker(\\"Hello\\", \\"Olelh\\") == True assert anagram_checker(\\"Dormitory\\", \\"Dirty room\\") == True ``` # Instructions Please implement the function below: ```python def anagram_checker(str1, str2): # Your code here pass ``` # Note * You may use any common data structure (such as dictionaries) to implement the solution. * Ensure that your implementation handles large input sizes within reasonable time limits.","solution":"def anagram_checker(str1, str2): Determines if two strings are anagrams of each other, ignoring case and spaces. Parameters: str1 (str): The first input string. str2 (str): The second input string. Returns: bool: True if the strings are anagrams, False otherwise. from collections import Counter # Convert strings to lower case to make the check case-insensitive # Remove spaces from both strings clean_str1 = \'\'.join(str1.lower().split()) clean_str2 = \'\'.join(str2.lower().split()) # Use Counter to count the frequencies of each character return Counter(clean_str1) == Counter(clean_str2)"},{"question":"You are given a mathematical utility function to count the number of digits in an integer. Your task is to extend this function to handle more complex scenarios while maintaining performance efficiency. # Objective: Write a function `extended_num_digits(n)` that: 1. Takes an integer or a floating-point number as input. 2. Returns the count of digits in the integer part for positive and negative numbers. 3. Handles non-numerical inputs gracefully by raising a ValueError with an appropriate message. 4. Ensures performance remains within constant time complexity for valid inputs. # Input: * An integer or a floating-point number `n`. # Output: * An integer representing the count of digits in the integer part of `n`. * Raise a `ValueError` if input is not a valid number. # Constraints: * You cannot use string conversion methods to count digits. * Handle edge cases such as zero and very large numbers correctly. # Example: ```python extended_num_digits(12345) # Output: 5 extended_num_digits(-987.654) # Output: 3 extended_num_digits(0) # Output: 1 extended_num_digits(\'hello\') # Raises ValueError: \\"Input must be a number!\\" ``` # Notes: * Pay close attention to handling negative numbers and zero. * Ensure the function performs efficiently even for very large numbers.","solution":"def extended_num_digits(n): Returns the count of digits in the integer part of the input number `n`. Raises ValueError for non-numeric inputs. if not isinstance(n, (int, float)): raise ValueError(\\"Input must be a number!\\") # Handle for the float numbers: isolating integer part if isinstance(n, float): n = int(n) # Get absolute value and initialize digit count abs_n = abs(n) # Handle zero case directly if abs_n == 0: return 1 # Count digits in logarithmic time count = 0 while abs_n > 0: abs_n //= 10 count += 1 return count"},{"question":"Generate Abbreviations You are given a word, and your task is to write a function that generates all possible abbreviations for the word. An abbreviation replaces some letters in the word with their count (number of letters being replaced). For example, `word` can be abbreviated as `word`, `wor1`, `wo1d`, `wo2`, `w1rd`, `w1r1`, `w2d`, `w3`, `1ord`, `1or1`, `1o1d`, `1o2`, `2rd`, `2r1`, `3d`, `4`. Function Signature: ```python def generate_abbreviations(word: str) -> list: ``` Input: - `word` : a string of length n (1 <= n <= 50), consisting of lowercase English letters only. Output: - A list with all possible abbreviations of the given `word`. Constraints: - The length of the string `word` will not exceed 50. Examples: 1. `generate_abbreviations(\\"word\\")` should return: - `[\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\']` 2. `generate_abbreviations(\\"a\\")` should return: - `[\'a\', \'1\']` Performance Requirements: - Your solution should handle inputs up to 50 characters efficiently within the constraints. Additional Notes: - Ensure your function handles edge cases such as empty strings or single character strings appropriately. - You should consider both time and space complexities to ensure the solution is efficient and scalable. Implement the function to correctly generate all possible abbreviations of the given word.","solution":"def generate_abbreviations(word): Generates all possible abbreviations for a given word. results = [] def backtrack(pos, current, count): if pos == len(word): # If we have reached the end of the word, add the current abbreviation to the results if count > 0: current += str(count) results.append(current) else: # Continue with the next character in the word backtrack(pos + 1, current, count + 1) backtrack(pos + 1, current + (str(count) if count > 0 else \'\') + word[pos], 0) # Start the backtracking with initial position 0, an empty current abbreviation, and count 0 backtrack(0, \\"\\", 0) return results"},{"question":"In-Order Successor in a Binary Search Tree **Scenario**: You are given a Binary Search Tree (BST) and a node within that tree. The BST has unique values and adheres to the property where the left child contains values less than the parent node and the right child contains values greater than the parent node. Your task is to find the in-order successor of this given node in the BST. **Function Signature**: ```python def successor(root: Optional[TreeNode], node: TreeNode) -> Optional[TreeNode]: pass ``` # Input * `root`: The root of the binary search tree of type `Optional[TreeNode]`. A value of `None` indicates an empty tree. * `node`: The node whose in-order successor we need to find. This node is guaranteed to be present in the tree, of type `TreeNode`. # Output * Returns the in-order successor of given `node` if it exists, otherwise return `None`. # Constraints 1. All elements in the BST are unique. 2. The number of nodes in the BST is in the range [1, 10^4]. 3. -10^5 <= Node.val <= 10^5 # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 20 # / # 9 25 # / # 5 12 # / # 11 14 root = TreeNode(20) root.left = TreeNode(9) root.right = TreeNode(25) root.left.left = TreeNode(5) root.left.right = TreeNode(12) root.left.right.left = TreeNode(11) root.left.right.right = TreeNode(14) node = root.left.right.left # Node with value 11 result = successor(root, node) print(result.val) # Output should be 12 ``` # Explanation * In the example tree, the in-order traversal would be [5, 9, 11, 12, 14, 20, 25]. The in-order successor of `11` is `12`. # Notes * Be careful to handle cases where the node has no right child. * Ensure your function can correctly traverse the tree and handle the edge cases as described.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def successor(root: TreeNode, node: TreeNode) -> TreeNode: # Helper function to find the minimum value node in a subtree def find_min(node): current = node while current.left: current = current.left return current next_larger = None current = root # Traverse the tree to find the in-order successor while current: if node.val < current.val: next_larger = current current = current.left elif node.val > current.val: current = current.right else: break # If the node has a right subtree, find the smallest value in the right subtree if node.right: next_larger = find_min(node.right) return next_larger"},{"question":"Scenario You are working as a software engineer tasked with implementing a feature for a text editor that automatically suggests text corrections by aligning text strings through minimum deletions. Your job is to write a function that computes the minimum number of step-by-step character deletions required to make two given strings identical. Problem Statement Given two input strings `word1` and `word2`, write a function `min_operations_deletion` to find the minimum number of deletion steps required to make the two strings equal to each other. Function Signature ```python def min_operations_deletion(word1: str, word2: str) -> int: ``` Input Format - `word1`: A string of length `1 <= len(word1) <= 1000`. - `word2`: A string of length `1 <= len(word2) <= 1000`. Output Format - Return a single integer representing the minimum number of deletions needed. Constraints - The function should handle all edge cases efficiently. - Optimize the solution for both time and space complexity. Example ```python assert min_operations_deletion(\\"sea\\", \\"eat\\") == 2 assert min_operations_deletion(\\"a\\", \\"b\\") == 2 assert min_operations_deletion(\\"\\", \\"b\\") == 1 assert min_operations_deletion(\\"a\\", \\"ab\\") == 1 ``` Notes - Ensure handling of different lengths and edge cases. - Utilize dynamic programming for optimal implementation. - Avoid unnecessary recomputation of results to improve performance.","solution":"def min_operations_deletion(word1: str, word2: str) -> int: Returns the minimum number of deletion steps required to make the two strings identical. # Lengths of the two strings m, n = len(word1), len(word2) # Create a DP table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # length of longest common subsequence lcs_length = dp[m][n] # The minimum deletions required return m + n - 2 * lcs_length"},{"question":"Scenario You are required to implement a function that takes a stack of numbers and replaces every value in the stack with two occurrences of that value. The purpose is to familiarize you with the use of auxiliary data structures while manipulating stacks. Ensure your implementation handles edge cases and performs efficiently. Task Implement the function `stutter_stack` that doubles each element in the stack using a single auxiliary structure of your choice (stack or queue). Function Signature: ``` def stutter_stack(stack: List[int]) -> List[int]: ``` Input * `stack`: A list of integers representing a stack, where the last element is the top of the stack. (`1 <= len(stack) <= 10^4`) Output * Returns a list of integers representing the modified stack after stuttering operation. Constraints * You must use either a stack or queue as auxiliary storage. * Your solution should aim for O(n) time complexity and O(n) space complexity. Example ```python # Example usage: input_stack = [3, 7, 1, 14, 9] output_stack = stutter_stack(input_stack) print(output_stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Notes * Be sure to handle edge cases such as an empty stack or a stack with one element. * Consider which method (stack or queue) would be more efficient or simpler to implement for your auxiliary structure.","solution":"from collections import deque from typing import List def stutter_stack(stack: List[int]) -> List[int]: Given a stack of integers, replaces every value in the stack with two occurrences of that value using an auxiliary queue. Args: stack (List[int]): A list of integers representing a stack, where the last element is the top of the stack. Returns: List[int]: A list of integers representing the modified stack after stuttering. if not stack: return [] auxiliary_queue = deque() # Transfer elements from stack to auxiliary queue, doubling each element while stack: element = stack.pop() auxiliary_queue.appendleft(element) auxiliary_queue.appendleft(element) # Transfer elements back to stack from auxiliary queue while auxiliary_queue: stack.append(auxiliary_queue.popleft()) return stack"},{"question":"# FizzBuzz with Additional Constraints Write a function `fizzbuzz_custom_replacements(n, replacements)` that returns a list containing the numbers from 1 to n, where each number is replaced based on the following rules: * If the number is divisible by any key in the `replacements` dictionary, then it should be replaced with the corresponding value(s) from the dictionary. * If the number matches multiple keys, append all values in the order they appear in the dictionary. * If no replacements occur, the number itself is added as a string. # Function Signature ```python def fizzbuzz_custom_replacements(n: int, replacements: dict) -> list: ``` # Input * `n`: An integer (1 <= n <= 10^5) * `replacements`: A dictionary where the keys are integers and the values are strings. # Output * A list containing strings where each element is either the original number or replaced according to the rules. # Example ```python replacements = { 3: \\"Fizz\\", 5: \\"Buzz\\" } fizzbuzz_custom_replacements(15, replacements) # Output: [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] ``` # Constraints * `n` will always be a positive integer, ≥ 1. * The `replacements` dictionary can have 1 to 100 key-value pairs. * The keys of `replacements` are distinct positive integers. # Notes * Ensure your function handles invalid inputs gracefully. * Consider optimizing for performance and clarity. * Think about maintaining the order of multiple replacements as per their appearance in the dictionary.","solution":"def fizzbuzz_custom_replacements(n, replacements): result = [] for i in range(1, n+1): replacement_string = \'\' for key in replacements.keys(): if i % key == 0: replacement_string += replacements[key] if replacement_string == \'\': replacement_string = str(i) result.append(replacement_string) return result"},{"question":"# Atbash Cipher Implementation Objective: You are asked to implement the Atbash cipher encryption algorithm that encrypts an input string by mirroring its alphabetical characters. Non-alphabetic characters should remain unchanged. Function Signature: ```python def atbash(s: str) -> str: ``` Input: - A single string `s` (1 <= len(s) <= 10^4), containing uppercase and lowercase English letters, digits, punctuation, and spaces. Output: - A string that is the Atbash cipher equivalent of the input string `s`. Constraints: - Preserve the case of each letter. - Only alphabetic characters should be converted. Non-alphabetic characters remain unchanged. Examples: 1. `atbash(\\"Attack at dawn\\")` should return `\\"Zggzxp zg wzdm\\"` 2. `atbash(\\"Hello, World!\\")` should return `\\"Svool, Dliow!\\"` 3. `atbash(\\"Python 3.8\\")` should return `\\"Kbgslm 3.8\\"` Context: You work in a cybersecurity lab, creating tools for classical cipher education. One of the modules requires an implementation of the Atbash cipher to demonstrate its workings to students. Ensure that the function handles various edge cases and performs efficiently for longer texts.","solution":"def atbash(s: str) -> str: Encrypts the input string using the Atbash cipher. Only alphabetical characters are converted, while the remaining characters stay unchanged. result = [] for char in s: if char.isupper(): result.append(chr(155 - ord(char))) elif char.islower(): result.append(chr(219 - ord(char))) else: result.append(char) return \'\'.join(result)"},{"question":"# Context Imagine you are working on an app that provides several classic puzzles to users, including Sudoku. Your task is to implement a function that can solve a given 9x9 Sudoku puzzle efficiently and accurately. # Question Implement a function `solve_sudoku(board: List[List[str]]) -> bool` to solve the Sudoku puzzle represented by the 2D list `board`. The board contains the digits \'1\' to \'9\' and the empty cells are represented by the character \'.\'. The function should modify the input board in place and return True if the board is solvable, otherwise False. # Function Signature ```python def solve_sudoku(board: List[List[str]]) -> bool: ``` # Input * `board`: A 9x9 2D list containing digits \'1\' to \'9\' representing the Sudoku puzzle. The empty cells are represented by the character \'.\'. # Output * A boolean value indicating whether the puzzle is solvable. The board should be modified in-place to reflect the solution if it exists. # Constraints * The input board is always a 9x9 grid. * The digits are represented as strings. # Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solve_sudoku(board) ``` # Expected Output After calling `solve_sudoku(board)`, `board` should be modified to: ``` [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` # Additional Notes * Make sure to handle cases where the board is already solved. * Optimize to handle cases with high initial constraints efficiently. * Consider different strategies for a more optimal solution if the basic implementation is too slow on some edge cases.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> bool: def is_valid(board, row, col, num): for i in range(9): if board[i][col] == num or board[row][i] == num: return False if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = \'.\' return False return True return solve() # Example usage: # board = [ # [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], # [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], # [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], # [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], # [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], # [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], # [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], # [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], # [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] # ] # print(solve_sudoku(board)) # print(board)"},{"question":"# Programming Question: Trie and Dictionary-based Word Search As part of a library management system, you\'re tasked with implementing a search feature for book titles that supports both exact match and pattern match queries. The pattern may include the wildcard character `.` which can match any single letter. Task Construct the data structure that supports the following two operations: 1. **addWord(word)**: Adds a word to the data structure. 2. **search(word)**: Returns `True` if `word` is in the data structure, allowing for `.` as a wildcard, otherwise `False`. Implementation You must implement the `WordDictionary` class with the given methods. You may choose the data structure (Trie or Dictionary-based) you prefer and explain why. Input/Output - `addWord(word: str) -> None`: Adds the word to the data structure. - `search(word: str) -> bool`: Searches for the word (with wildcard support), returns `True` if found, otherwise `False`. Constraints - All words are lowercase English letters. - Assume lengths of words and number of words are reasonably constrained such that your program should run efficiently. Example ```python # Initialize your WordDictionary object word_dictionary = WordDictionary() # Add words word_dictionary.add_word(\\"bad\\") word_dictionary.add_word(\\"dad\\") word_dictionary.add_word(\\"mad\\") # Search words print(word_dictionary.search(\\"pad\\")) # Output: False print(word_dictionary.search(\\"bad\\")) # Output: True print(word_dictionary.search(\\".ad\\")) # Output: True print(word_dictionary.search(\\"b..\\")) # Output: True ``` # Note Explain the approach you used and why you selected the Trie or Dictionary-based approach. Discuss any trade-offs or considerations you took into account.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_word return search_in_node(word, self.root)"},{"question":"Scenario: In file management systems and web development, it\'s often necessary to manipulate file paths or URLs to extract the directory path and file name. This is crucial for tasks such as organizing files, generating file trees, or handling URLs for routing in web applications. Problem Statement: Write a function `split_path` that takes a string representing a path and returns a list containing two elements: 1. The directory path (everything before the last \'/\') 2. The file name (everything after the last \'/\') The function should handle the following: - Paths that are URLs or file paths - Paths that do not contain any \'/\' character - Empty paths Input: * A string `path` representing a file path or URL. Output: * A list of two strings where the first element is the directory path and the second element is the file name. Constraints: * The given path will always be a valid string but can be empty. * Do not use any built-in or third-party libraries specifically for manipulating URLs or paths apart from those provided by the standard library. Examples: ```python assert split_path(\\"https://algorithms/unix/test.py\\") == [\\"https://algorithms/unix\\", \\"test.py\\"] assert split_path(\\"algorithms/unix/test.py\\") == [\\"algorithms/unix\\", \\"test.py\\"] assert split_path(\\"test.py\\") == [\\"\\", \\"test.py\\"] assert split_path(\\"\\") == [\\"\\", \\"\\"] assert split_path(\\"/test.py\\") == [\\"\\", \\"test.py\\"] assert split_path(\\"folder/\\") == [\\"folder\\", \\"\\"] ``` Function Signature: ```python def split_path(path: str) -> list: # Your code here pass ``` Consider all edge cases and ensure your function runs efficiently for any given valid path.","solution":"def split_path(path: str) -> list: Splits a given path into the directory path and file name. Parameters: path (str): The input path string. Returns: list: A list containing two elements: [directory path, file name] if \'/\' not in path: # If there\'s no \'/\', the entire path is considered as the file name. return [\'\', path] # Find the last occurrence of \'/\' last_slash_index = path.rfind(\'/\') # Get directory and file name using the last occurrence of \'/\' directory = path[:last_slash_index] file_name = path[last_slash_index+1:] return [directory, file_name]"},{"question":"Scenario You are developing a feature for a text editor where users can only type words using keys from a single row of the American QWERTY keyboard. Implement an algorithm that identifies words which can be typed using letters from just one row of the keyboard. Task Write a Python function `find_keyboard_row(words)` which processes a list of words and returns the words that can be typed using letters from only one row of the American QWERTY keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: # Your implementation here ``` Input * `words`: a list of strings where 1 ≤ len(words) ≤ 100 and all strings have length between 1 and 100, comprising only alphabetic characters. Output * Returns a list of strings, each string can be typed using letters from only one row of the American QWERTY keyboard. Example ```python # Input words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] # Output [\\"Alaska\\", \\"Dad\\"] ``` Constraints * The solution should efficiently handle the input size within the given constraints. * Input strings should be treated case-insensitively (i.e., \'A\' and \'a\' are considered the same).","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"# Question: Implement and Optimize Matrix Operations You are required to write a Python function that efficiently performs matrix exponentiation for large powers. While the provided snippets of the matrix multiplication, identity matrix generation, and matrix exponentiation do the job, they have substantial scope for optimization, especially for large datasets. Requirements: 1. **Function Name**: `optimized_matrix_exponentiation` 2. **Input**: * `mat` (list of list of int): a 2D list representing a square matrix with dimensions (d times d). * `n` (int): a non-negative integer which represents the exponent. 3. **Output**: * `result` (list of list of int): a 2D list representing the matrix raised to the power (n). Constraints: 1. (d leq 100) 2. (0 leq n leq 10^9) 3. All elements in `mat` are integers within the range ([-10^4, 10^4]). Performance Requirement: - Your solution should have a time complexity of (O(d^3 log(n))). # Hints: - Leverage the identity matrix as the base case for (n = 0). - Use efficient matrix multiplication techniques. - Consider edge cases such as zero matrices and exceptionally large exponents. # Example: ```python mat = [ [1, 2], [3, 4] ] n = 3 # Call the function result = optimized_matrix_exponentiation(mat, n) # Expected Output # [ # [37, 54], # [81, 118] # ] ``` Implementation: ```python def optimized_matrix_exponentiation(mat: list, n: int) -> list: # [Your optimized implementation here] pass ```","solution":"def matrix_multiply(A, B): Multiplies two square matrices A and B. size = len(A) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size): Creates an identity matrix of given size. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_power(mat, n): Exponentiates matrix mat to the power of n using binary exponentiation. size = len(mat) result = identity_matrix(size) base = mat[:] while n: if n % 2: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result def optimized_matrix_exponentiation(mat, n): Exponentiates a matrix mat to the power n efficiently. Parameters: mat (list of list of int): a 2D list representing a square matrix. n (int): a non-negative integer which represents the exponent. Returns: list of list of int: The matrix mat raised to the power n. if n == 0: return identity_matrix(len(mat)) return matrix_power(mat, n)"},{"question":"**Problem Statement**: You are implementing a machine learning pipeline, and one of the requirements is to compute the cosine similarity between pairs of document vectors. Given the importance of this measure in evaluating the similarity between documents, your task is to write a function that computes the cosine similarity between two given vectors. # Requirements: - Implement a function named `cosine_similarity` that: - Takes two input lists `vec1` and `vec2` of equal length. - Raises a `ValueError` if the input lists are not of the same length. - Returns a float representing the cosine similarity between the two vectors. - You are also provided with a helper function `_l2_distance` which computes the L2 norm (Euclidean norm) of a given vector. # Input Format: - Two lists of integers or floats `vec1` and `vec2`. For example, `vec1 = [1, 0, -1]` and `vec2 = [2, 1, 0]`. # Output Format: - A single float value representing the cosine similarity between the two vectors. # Example: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Expected output: 0.47140452079103173 cosine_similarity([1, 0, 0], [0, 1, 0]) # Expected output: 0.0 cosine_similarity([1, 1, 1], [1, 1, 1]) # Expected output: 1.0 ``` # Constraints: - Ensure the vectors are of non-zero length and have consistent lengths. - The values in the vectors can be either positive, negative, or zero. - Handle any edge cases such as vectors with zeros appropriately. - Perform the calculations with precise floating-point arithmetic to ensure accuracy of the result. You can use the following python function template to start with: ```python import math def _l2_distance(vec): Helper function to calculate the L2 norm of a vector. :param vec: list of integers/floats :return: float norm = 0. for element in vec: norm += element * element return math.sqrt(norm) def cosine_similarity(vec1, vec2): Function to calculate cosine similarity between two vectors. :param vec1: list of integers/floats :param vec2: list of integers/floats :return: float if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must have the same length.\\") norm_a = _l2_distance(vec1) norm_b = _l2_distance(vec2) similarity = 0. for a, b in zip(vec1, vec2): similarity += a * b return similarity / (norm_a * norm_b) ```","solution":"import math def _l2_distance(vec): Helper function to calculate the L2 norm of a vector. :param vec: list of integers/floats :return: float norm = 0. for element in vec: norm += element * element return math.sqrt(norm) def cosine_similarity(vec1, vec2): Function to calculate cosine similarity between two vectors. :param vec1: list of integers/floats :param vec2: list of integers/floats :return: float if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must have the same length.\\") norm_a = _l2_distance(vec1) norm_b = _l2_distance(vec2) if norm_a == 0 or norm_b == 0: raise ValueError(\\"One of the vectors is zero, cannot compute cosine similarity.\\") similarity = 0. for a, b in zip(vec1, vec2): similarity += a * b return similarity / (norm_a * norm_b)"},{"question":"# Context You have been hired by a company that deals with communication protocols where data is often transmitted as a sequence of bytes. Ensuring the correct conversion between integer values and their byte representations is paramount to avoid misinterpretation of transmitted information. # Task Implement a Python function that normalizes the data transmission process by converting an integer to a bytearray and then back to an integer. Your implementation must support both big-endian and little-endian formats. # Function Signature ```python def normalize_transmission(num: int, endian: str) -> int: pass ``` # Input * `num`: A non-negative integer that you need to convert. * `endian`: A string that can be either \\"big\\" or \\"little\\", indicating the endianness format for conversion. # Output * Return the integer obtained after converting `num` to a bytearray in the specified endianness and then back to an integer. # Constraints * 0 <= num <= 2^64 - 1 * `endian` is guaranteed to be either \\"big\\" or \\"little\\". # Examples ```python assert normalize_transmission(305419896, \\"big\\") == 305419896 assert normalize_transmission(305419896, \\"little\\") == 305419896 assert normalize_transmission(1, \\"big\\") == 1 assert normalize_transmission(1, \\"little\\") == 1 assert normalize_transmission(0, \\"big\\") == 0 assert normalize_transmission(0, \\"little\\") == 0 ``` # Explanation 1. For the first example: - `num` is 305419896 and `endian` is \\"big\\": * `num` is converted to bytes as `b\'x12x34x56x78\'` * `b\'x12x34x56x78\'` is then converted back to integer resulting in 305419896. - The same steps apply when `endian` is \\"little\\" but with byteorder reversed. 2. Ensure your solution handles edge cases such as 0 and very large integers up to 2^64-1 efficiently and correctly.","solution":"def normalize_transmission(num: int, endian: str) -> int: Converts an integer to a bytearray in the specified endianness and then back to an integer. :param num: A non-negative integer to be converted. :param endian: Either \\"big\\" or \\"little\\" indicating the endianness format for conversion. :return: The integer obtained after converting `num` to a bytearray and back to an integer. byte_length = (num.bit_length() + 7) // 8 # Calculate the required byte length for the integer. byte_representation = num.to_bytes(byte_length, byteorder=endian) return int.from_bytes(byte_representation, byteorder=endian)"},{"question":"# Coding Assessment: Secure Communication Key Exchange In this task, you are to implement a function that simulates a secure key exchange mechanism between two parties, Alice and Bob, using the Diffie-Hellman key exchange protocol. Given large prime number `p` and its primitive root `a`, your task is to ensure both parties agree on a shared secret key. # Function Signature ```python def secure_key_exchange(prime_p: int, primitive_root_a: int) -> int: Simulates the Diffie-Hellman key exchange to derive a shared secret key. Parameters: prime_p (int): A large prime number. primitive_root_a (int): A primitive root of the prime number. Returns: int: The shared secret key agreed upon by both Alice and Bob. pass ``` # Input - `prime_p`: An integer `p` where 2 <= p <= 10^9, representing a large prime number. - `primitive_root_a`: An integer `a` where 1 <= a < p, representing the primitive root of the prime number. # Output - Returns an integer representing the shared secret key agreed upon by both Alice and Bob. # Constraints - Ensure `p` is a valid large prime number. - Ensure `a` is a valid primitive root of `p`. # Requirements - Use the provided `prime_check`, `euler_totient`, `find_order`, and `find_primitive_root` functions where appropriate to validate inputs. - Outputs the same shared key if calculated correctly by both Alice and Bob. # Example ```python # Example Inputs p = 23 a = 5 # Example Output shared_key = secure_key_exchange(p, a) print(shared_key) # Output could be 2, 8, etc., depending on random keys chosen by Alice and Bob ``` # Notes - You don\'t need to handle input/output operations. Just implement the function. - Randomness in key generation (both Alice and Bob) should be simulated using appropriate methods (as shown in the code snippet).","solution":"import random def secure_key_exchange(prime_p: int, primitive_root_a: int) -> int: Simulates the Diffie-Hellman key exchange to derive a shared secret key. Parameters: prime_p (int): A large prime number. primitive_root_a (int): A primitive root of the prime number. Returns: int: The shared secret key agreed upon by both Alice and Bob. # Alice selects a private key, a (1 < private_key_a < prime_p) private_key_a = random.randint(2, prime_p - 2) # Bob selects a private key, b (1 < private_key_b < prime_p) private_key_b = random.randint(2, prime_p - 2) # Alice computes A = (a^private_key_a) % prime_p A = pow(primitive_root_a, private_key_a, prime_p) # Bob computes B = (a^private_key_b) % prime_p B = pow(primitive_root_a, private_key_b, prime_p) # Alice and Bob exchange A and B and computes the shared secret key shared_secret_key_alice = pow(B, private_key_a, prime_p) shared_secret_key_bob = pow(A, private_key_b, prime_p) # Ensure both computed the same shared secret key assert shared_secret_key_alice == shared_secret_key_bob, \\"Secret keys do not match!\\" return shared_secret_key_alice"},{"question":"You are given an unsorted list of integers. Your task is to implement the `comb_sort` algorithm which sorts the list. Write the function `comb_sort(arr)` that takes a list of integers, `arr`, and returns the sorted list. Input Format: * A list of integers, `arr`, with length `n` (1 <= n <= 10^5). Output Format: * Return a sorted list of integers. Constraints: * You are allowed to use basic list operations and conditional statements. * The sorting algorithm must be implemented as described. Example: ```python Input: [34, 8, 50, 5, 60] Output: [5, 8, 34, 50, 60] Input: [20, 15, 30, 1, 4] Output: [1, 4, 15, 20, 30] ``` Performance Requirements: * Your solution should handle large lists effectively, though an exact time constraint is not enforced for this specific task since Comb Sort is not optimal for very large datasets. Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: # implementation here ``` Notes: * Ensure you handle edge cases such as already sorted arrays and arrays with duplicate numbers. * Consider optimizing the shrink factor based on the input size to ensure better average performance.","solution":"def comb_sort(arr): Sorts a list of integers using the comb sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Bipartite Graph Verification You are given an undirected graph represented by an adjacency list, and your task is to determine if the graph is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets such that no two graph vertices within the same set are adjacent. Function Signature: ```python def is_bipartite(graph: List[List[int]]) -> bool: pass ``` # Input: - `graph` (List[List[int]]): A list of lists where `graph[i]` contains all vertices that vertex `i` is connected to. The graph is undirected and does not contain multiple edges or self-loops. # Output: - `bool`: Return `True` if the graph is bipartite, `False` otherwise. # Constraints: - The number of vertices `0 <= V <= 1000` - The number of edges `0 <= E <= 2000` # Example: ```python # Example 1 graph = [[1, 3], [0, 2], [1, 3], [0, 2]] print(is_bipartite(graph)) # Output: True (Graph is bipartite) # Example 2 graph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]] print(is_bipartite(graph)) # Output: False (Graph is not bipartite) ``` # Clarifications: - Think about how you would use a BFS approach to color the graph using two colors and determine if it is bipartite. - Consider edge cases including graphs with isolated vertices or multiple disconnected components. **Your task is to implement the `is_bipartite` function.**","solution":"def is_bipartite(graph): Determines if the given graph is bipartite. :param graph: List[List[int]], adjacency list of the graph. :return: bool, True if the graph is bipartite, False otherwise. color = {} for node in range(len(graph)): if node not in color: stack = [node] color[node] = 0 while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in color: stack.append(neighbor) color[neighbor] = 1 - color[current] elif color[neighbor] == color[current]: return False return True"},{"question":"Given a string `s`, determine whether it is a palindrome, considering only alphanumeric characters and ignoring cases. Your function should have a time complexity of O(n) and use the most space-efficient method possible for string comparison. # Input Format A single line containing the string `s`. # Output Format Output `True` if the string `s` is a palindrome, otherwise `False`. # Constraints - The string `s` can be empty, in which case it is considered a valid palindrome. - The function should handle up to (10^6) characters efficiently. # Example **Input:** ``` A man, a plan, a canal: Panama ``` **Output:** ``` True ``` **Input:** ``` race a car ``` **Output:** ``` False ``` # Implementation Guidelines Write a function `is_palindrome_optimized(s: str) -> bool:` that implements the most space-efficient palindrome check using the two-pointer approach. Requirements: - Only consider alphanumeric characters. - Ignore cases. - Time Complexity should be O(n). - Space Complexity should be O(1) (excluding input string space).","solution":"def is_palindrome_optimized(s: str) -> bool: Determines if the given string is a palindrome considering only alphanumeric characters and ignoring cases. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: # Increment left pointer if not alphanumeric while left < right and not s[left].isalnum(): left += 1 # Decrement right pointer if not alphanumeric while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"Context You are working on a search feature for a text editor. The search feature should be able to quickly locate all occurrences of a search term (pattern) within a large document (text). To achieve this, you decide to implement the Knuth-Morris-Pratt string matching algorithm. Problem Statement Write a Python function that implements the Knuth-Morris-Pratt algorithm to find all occurrences of a pattern string within a text string. Function Signature ```python def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Given two strings, text and pattern, return a list of starting indices where the pattern is found in the text. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for within the text. Returns: List[int]: A list of starting indices of the pattern in the text. If the pattern is not found, return an empty list. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] Constraints: * The pattern and text consist of only lowercase English letters. * 1 <= len(text), len(pattern) <= 10^5 * If the pattern is longer than the text, return an empty list. ``` Notes: - Your solution should have a time complexity of O(N + M). - Ensure to handle edge cases, such as empty pattern or text, and pattern longer than text. - The implementation must use the Knuth-Morris-Pratt algorithm as the underlying algorithm for searching.","solution":"from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Given two strings, text and pattern, return a list of starting indices where the pattern is found in the text using the Knuth-Morris-Pratt string matching algorithm. def build_lps(pattern: str) -> List[int]: Build the Longest Prefix which is also Suffix (LPS) array used in KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not pattern or not text or len(pattern) > len(text): return [] lps = build_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Problem: Combination Sum with Constraints You are given an integer array `nums` consisting of all positive numbers and no duplicates. Your task is to find the number of possible combinations that add up to a positive integer `target`. Different sequences are counted as different combinations. Function Signature ```python def combination_sum_topdown(nums: List[int], target: int) -> int: ``` ```python def combination_sum_bottom_up(nums: List[int], target: int) -> int: ``` Input - `nums`: List of distinct positive integers. - `target`: A positive integer. Output - Returns the number of possible combinations that add up to `target`. Example ```python nums = [1, 2, 3] target = 4 combination_sum_topdown(nums, 4) # Output: 7 combination_sum_bottom_up(nums, 4) # Output: 7 ``` The possible combination ways are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) Performance Requirements - The solution must handle targets up to 1,000 optimally. Follow-up 1. What if negative numbers are allowed in the given array? 2. How does it change the problem? 3. What limitation do we need to add to the question to allow negative numbers? Constraints - `1 <= nums.length <= 100` - `1 <= nums[i] <= 1,000` - `1 <= target <= 1,000` Implement the functions `combination_sum_topdown` and `combination_sum_bottom_up`. Your implementation should demonstrate proficiency in dynamic programming techniques and be able to handle large inputs efficiently.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: Returns the number of possible combinations that add up to the target using top-down DP approach. memo = {} def dfs(remain): if remain == 0: return 1 if remain in memo: return memo[remain] count = 0 for num in nums: if remain - num >= 0: count += dfs(remain - num) memo[remain] = count return count return dfs(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: Returns the number of possible combinations that add up to the target using bottom-up DP approach. dp = [0] * (target + 1) dp[0] = 1 for t in range(1, target + 1): for num in nums: if t - num >= 0: dp[t] += dp[t - num] return dp[target]"},{"question":"# Insertion Sort with Efficient Insertion Point Search **Problem Statement**: Using the provided `search_insert` helper function, implement an insertion sort algorithm that sorts an array of integers in ascending order. Your implementation should efficiently find the insertion point for each element using the `search_insert` function to minimize unnecessary comparisons. **Input**: - A list of integers `arr` (0 ≤ length ≤ 1000). **Output**: - The list sorted in ascending order. **Constraints**: - You may not use any built-in sort functions. - Your implementation should handle empty lists and single-element lists gracefully. **Examples**: ```python insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) -> [1, 2, 3, 4, 5, 6, 10, 12] insertion_sort([12, 11, 13, 5, 6]) -> [5, 6, 11, 12, 13] insertion_sort([1, 3, 5, 7]) -> [1, 3, 5, 7] insertion_sort([]) -> [] ``` **Function Signature**: ```python def insertion_sort(arr: List[int]) -> List[int]: # Your code here pass ```","solution":"from typing import List def search_insert(sorted_sublist: List[int], x: int) -> int: Helper function to find the index where x should be inserted in sorted_sublist to maintain sorted order. low, high = 0, len(sorted_sublist) while low < high: mid = (low + high) // 2 if sorted_sublist[mid] < x: low = mid + 1 else: high = mid return low def insertion_sort(arr: List[int]) -> List[int]: Sorts the array `arr` using the insertion sort algorithm, utilizing the search_insert function for efficient insertion point search. sorted_arr = [] for x in arr: pos = search_insert(sorted_arr, x) sorted_arr.insert(pos, x) return sorted_arr"},{"question":"# Cycle Detection in Directed Graph Scenario: You are working on a resource management system where processes are represented by a directed graph. Each process can \\"wait\\" on another process, represented by directed edges. You need to determine if there is a possibility of a deadlock (cycle) within the system. Task: Write a function `detect_deadlock(graph: Dict[str, List[str]]) -> bool` that detects if there is a cycle within the directed graph representation of the processes. Input: * `graph` (Dict[str, List[str]]): A directed graph represented as an adjacency list. - Vertices are strings representing process IDs. - Edges are lists of strings representing the processes a given process is waiting for. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` Output: * `bool`: Returns `True` if there is a cycle; otherwise, returns `False`. Constraints: * The graph can be large, but you should aim to use an efficient approach both in terms of time and space. * Your solution should handle edge cases, such as empty graphs and graphs with isolated vertices. Notes: * The graph is directed. * Think about potential recursion limits in languages and how to handle deep graphs. # Example: ```python >>> detect_deadlock({ \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] }) True >>> detect_deadlock({ \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [] }) True >>> detect_deadlock({ \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] }) False ``` Function Signature: ```python from typing import Dict, List def detect_deadlock(graph: Dict[str, List[str]]) -> bool: # Your code here ```","solution":"from typing import Dict, List def detect_deadlock(graph: Dict[str, List[str]]) -> bool: def has_cycle(v, visited, rec_stack): visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if has_cycle(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if has_cycle(node, visited, rec_stack): return True return False"},{"question":"# Sorting Colors Challenge You have a list of integers representing colors. The integers in the list can only be 0, 1, or 2, where: - 0 represents red. - 1 represents white. - 2 represents blue. Your task is to sort this list in place such that all occurrences of the color red come first, followed by all occurrences of the color white, and then all occurrences of the color blue. You must **not** use the library\'s built-in sort function for this problem. Instead, write your own sorting function that sorts the colors in a single pass. # Function Signature ```python def sort_colors(nums: List[int]) -> None: # Your code here ``` # Input * `nums: List[int]` - A list of integers where each integer is either 0, 1, or 2. # Output * The function does not return anything. It should sort the `nums` list in place. # Constraints * The length of the list, `len(nums)`, can be up to 10^5. * Each element in `nums` is guaranteed to be 0, 1, or 2. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Expected Output: [0, 0, 1, 1, 2, 2] ``` # Performance Requirements * The algorithm should run in linear time, O(n). * The algorithm should use constant space, O(1).","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the list nums in-place so that all 0s come first, followed by all 1s, then all 2s. red, white, blue = 0, 0, len(nums) - 1 while white <= blue: if nums[white] == 0: nums[red], nums[white] = nums[white], nums[red] red += 1 white += 1 elif nums[white] == 1: white += 1 else: nums[white], nums[blue] = nums[blue], nums[white] blue -= 1"},{"question":"# Binary Tree Path Sum Check **Objective**: Develop a function to determine if there exists a root-to-leaf path in a binary tree such that the sum of the values along that path equals a given sum. Input - `root`: The root node of a binary tree where each node contains an integer value. - `sum`: An integer representing the target sum to check for. Output - Return `True` if such a path exists, `False` otherwise. Constraints 1. The tree nodes can have any integer value (both positive and negative). 2. Time complexity should be O(N), where N is the number of nodes in the binary tree. 3. Space usage should respect the constraints of the traversal method used. Performance Requirements Ensure that your solution is efficient in both time and space, especially considering deep or wide tree structures. # Examples Example 1 ```plaintext Input: root = [5,4,8,11,None,13,4,7,2,None,None,None,1], sum = 22 Output: True Explanation: The root-to-leaf path: 5 -> 4 -> 11 -> 2 sums to 22. ``` Example 2 ```plaintext Input: root = [1,2,3], sum = 5 Output: False Explanation: There is no root-to-leaf path that sums to 5. ``` Example 3 ```plaintext Input: root = [1,2], sum = 1 Output: False Explanation: The root-to-leaf paths are: 1->2, and neither sums to 1. ``` # Given Implementations You can implement in three ways, and you are free to choose one or several: 1. **Recursive DFS**. 2. **Iterative DFS using stack**. 3. **Iterative BFS using queue**. Function Signature ```python def has_path_sum(root, sum): # Implement the method here pass ``` # Notes - Ensure to handle edge cases like an empty tree and trees with negative values. - Optimize wherever possible to handle large and unbalanced trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, sum): Determines if there exists a root-to-leaf path in a binary tree such that the sum of the values along that path equals a given sum. Args: root (TreeNode): The root node of the binary tree. sum (int): The target sum to check for. Returns: bool: True if such a path exists, False otherwise. if not root: return False # If it\'s a leaf node, check the sum if not root.left and not root.right: return sum == root.val # Recur for the left and right subtrees with the updated sum sum -= root.val return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)"},{"question":"# Question: Implement and Enhance Bucket Sort Given a list of integer values, implement the bucket sort algorithm as described. To demonstrate your understanding and skills in optimizing the given algorithm, you are required to enhance the bucket sort by using a more efficient sorting algorithm than insertion sort for sorting the individual buckets. Function Signature ```python def enhanced_bucket_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers `arr` with 1 <= len(arr) <= 10^5. - Each value in the list is >= 0 and <= 10^6. Output - A list of integers, sorted in ascending order. Constraints - Optimize the algorithm to perform efficiently even for the upper limits of the input constraints. - The sorting algorithm used within each bucket should be a more efficient algorithm like quicksort or mergesort. Example ```python assert enhanced_bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) == [3, 9, 21, 25, 29, 37, 43, 49] ``` Additional Notes - Ensure to handle the edge cases: - An empty list. - A list with all identical elements. - A list with one element.","solution":"from typing import List def enhanced_bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the maximum value to determine the range of the input data max_value = max(arr) # Number of buckets bucket_count = len(arr) # Create buckets buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for num in arr: index = bucket_count * num // (max_value + 1) buckets[index].append(num) # Sort each bucket using built-in Timsort (which is highly efficient) for i in range(bucket_count): buckets[i].sort() # Concatenate all sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"Scenario: You are developing a software for a graphical user interface that supports image transformations by rotating and inverting images represented as 2D matrices. To achieve this, you need to implement several matrix transformation functions. Task: Write a function to transform a matrix in-place, without creating a new matrix. You need to implement only the `rotate_clockwise` function described as follows: ```python def rotate_clockwise_inplace(matrix: List[List[int]]) -> None: Rotate the given n x n matrix 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: None: The function should modify the matrix in-place. # Your code goes here. ``` Input: - A 2D square matrix of integers (List of List of integers). Output: - The function should modify the input matrix in-place and should not return anything. Constraints: - The matrix will have the same number of rows and columns. - The matrix will contain only integers. - Matrix dimensions will be between 1 and 1000 (inclusive). Example: **Input:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise_inplace(matrix) ``` **Output (modified matrix in-place):** ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` In your implementation, ensure efficiency and consider handling possible edge cases like very small matrices (e.g., 1x1).","solution":"from typing import List def rotate_clockwise_inplace(matrix: List[List[int]]) -> None: Rotate the given n x n matrix 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: None: The function should modify the matrix in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Reverse a String using Various Approaches You are tasked with implementing four different methods to reverse a given string. Each method has its unique constraints and performance characteristics. You need to implement and understand these differences. Method 1: Recursive Approach Implement a function `reverse_recursive(s: str) -> str` that reverses the input string `s` using recursion. **Constraints and Requirements**: * Base case and recursive case must be clearly defined. * Must handle empty strings and single character strings as edge cases. Method 2: Iterative Approach Implement a function `reverse_iterative(s: str) -> str` that reverses the input string `s` iteratively. **Constraints and Requirements**: * Utilize a loop to swap characters from the start and end moving towards the center. * Must handle string immutability constraints, i.e., cannot modify original string directly. Method 3: Using Built-in Python Functions Implement a function `reverse_pythonic(s: str) -> str` that reverses the input string `s` using Python\'s built-in functions. **Constraints and Requirements**: * Should utilize `reversed()` and `join()` functions. Method 4: Simplified Pythonic Approach Implement a function `reverse_ultra_pythonic(s: str) -> str` that reverses the input string `s` using Python\'s slicing feature. **Constraints and Requirements**: * Should utilize slicing to achieve the reversal in the simplest possible manner. # Input and Output Format * **Input**: A single string `s` (0 ≤ len(s) ≤ 10^6). * **Output**: The reversed string. # Example ```python assert reverse_recursive(\\"example\\") == \\"elpmaxe\\" assert reverse_iterative(\\"example\\") == \\"elpmaxe\\" assert reverse_pythonic(\\"example\\") == \\"elpmaxe\\" assert reverse_ultra_pythonic(\\"example\\") == \\"elpmaxe\\" ``` Ensure each method is optimized and tested for performance and corner cases.","solution":"def reverse_recursive(s: str) -> str: Reverse a string using recursion. # Base case: if the string is empty or a single character, it\'s already reversed if len(s) <= 1: return s # Recursive case: reverse the substring except the first character, and add the first character at the end return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverse a string using an iterative approach. # Convert the string to a list to allow mutable operations str_list = list(s) # Initialize pointers for start and end of the list start, end = 0, len(str_list) - 1 # Swap characters towards the center while start < end: str_list[start], str_list[end] = str_list[end], str_list[start] start += 1 end -= 1 # Convert the list back to a string and return return \'\'.join(str_list) def reverse_pythonic(s: str) -> str: Reverse a string using built-in Python functions. # Use reversed() to get an iterator that yields characters in reverse order, then join them into a string return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: Reverse a string using Python slicing. # Use slicing to reverse the string return s[::-1]"},{"question":"# Coding Problem: Implementing Efficient Red-Black Tree with Custom Operations You are tasked with implementing a custom Red-Black Tree with some additional operations beyond the basic insert and delete. Your goal is to expand the functionality, ensuring the tree maintains its balancing properties and offers efficient retrieval of highest and lowest values, alongside a range query. Requirements: 1. **Insert a Node**: Insert a node into the Red-Black Tree while maintaining the Red-Black properties. 2. **Delete a Node**: Delete a node from the Red-Black Tree while maintaining the Red-Black properties. 3. **Find Maximum/Minimum Node**: Retrieve the maximum or minimum value from the Red-Black Tree. 4. **Range Query**: Return a list of nodes within a specified range [min_value, max_value]. Methods to Implement: ```python class RBTree: def insert(self, val: int) -> None: pass def delete(self, val: int) -> None: pass def find_maximum(self) -> int: pass def find_minimum(self) -> int: pass def range_query(self, min_value: int, max_value: int) -> List[int]: pass ``` Functionality: * **insert(val: int)**: Insert a new node with the given value `val` into the tree. * **delete(val: int)**: Remove the node with the given value `val` from the tree. * **find_maximum()**: Return the maximum value in the tree. * **find_minimum()**: Return the minimum value in the tree. * **range_query(min_value: int, max_value: int)**: Return a list of values in the tree falling within the specified range `[min_value, max_value]`. Example: ```python rb = RBTree() rb.insert(10) rb.insert(20) rb.insert(5) rb.insert(7) rb.insert(15) print(rb.find_maximum()) # Output: 20 print(rb.find_minimum()) # Output: 5 print(rb.range_query(5, 15)) # Output: [5, 7, 10, 15] rb.delete(10) print(rb.find_maximum()) # Output: 20 print(rb.range_query(5, 15)) # Output: [5, 7, 15] ``` Constraints: * All values will be unique integers. * The tree will not exceed 10^4 nodes. * Range query `[min_value, max_value]` will always have `min_value <= max_value`. Make sure your implementation maintains the Red-Black Tree properties and is efficient in terms of both time and space complexity.","solution":"class RBTreeNode: def __init__(self, key, color=\\"red\\", parent=None, left=None, right=None): self.key = key self.color = color self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.nil = RBTreeNode(None, color=\'black\') # The sentinel node for nil self.root = self.nil def insert(self, val: int) -> None: new_node = RBTreeNode(val, color=\\"red\\", left=self.nil, right=self.nil) parent = None current = self.root while current != self.nil: parent = current if val < current.key: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif val < parent.key: parent.left = new_node else: parent.right = new_node self.insert_fixup(new_node) def insert_fixup(self, node): while node.parent and node.parent.color == \\"red\\": if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" node.parent.parent.color = \\"red\\" node = node.parent.parent else: if node == node.parent.right: node = node.parent self.left_rotate(node) node.parent.color = \\"black\\" node.parent.parent.color = \\"red\\" self.right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" node.parent.parent.color = \\"red\\" node = node.parent.parent else: if node == node.parent.left: node = node.parent self.right_rotate(node) node.parent.color = \\"black\\" node.parent.parent.color = \\"red\\" self.left_rotate(node.parent.parent) self.root.color = \\"black\\" def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.nil: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.nil: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def delete(self, val: int) -> None: node_to_delete = self.find_node(val) if node_to_delete is None: return y_original_color = node_to_delete.color if node_to_delete.left == self.nil: x = node_to_delete.right self.transplant(node_to_delete, node_to_delete.right) elif node_to_delete.right == self.nil: x = node_to_delete.left self.transplant(node_to_delete, node_to_delete.left) else: y = self.minimum_node(node_to_delete.right) y_original_color = y.color x = y.right if y.parent == node_to_delete: x.parent = y else: self.transplant(y, y.right) y.right = node_to_delete.right y.right.parent = y self.transplant(node_to_delete, y) y.left = node_to_delete.left y.left.parent = y y.color = node_to_delete.color if y_original_color == \\"black\\": self.delete_fixup(x) def find_node(self, val: int): current = self.root while current != self.nil and val != current.key: if val < current.key: current = current.left else: current = current.right return current if current != self.nil else None def minimum_node(self, node): while node.left != self.nil: node = node.left return node def delete_fixup(self, x): while x != self.root and x.color == \\"black\\": if x == x.parent.left: w = x.parent.right if w.color == \\"red\\": w.color = \\"black\\" x.parent.color = \\"red\\" self.left_rotate(x.parent) w = x.parent.right if w.left.color == \\"black\\" and w.right.color == \\"black\\": w.color = \\"red\\" x = x.parent else: if w.right.color == \\"black\\": w.left.color = \\"black\\" w.color = \\"red\\" self.right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = \\"black\\" w.right.color = \\"black\\" self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == \\"red\\": w.color = \\"black\\" x.parent.color = \\"red\\" self.right_rotate(x.parent) w = x.parent.left if w.right.color == \\"black\\" and w.left.color == \\"black\\": w.color = \\"red\\" x = x.parent else: if w.left.color == \\"black\\": w.right.color = \\"black\\" w.color = \\"red\\" self.left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = \\"black\\" w.left.color = \\"black\\" self.right_rotate(x.parent) x = self.root x.color = \\"black\\" def transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def find_maximum(self) -> int: current = self.root while current.right != self.nil: current = current.right return current.key def find_minimum(self) -> int: current = self.root while current.left != self.nil: current = current.left return current.key def range_query(self, min_value: int, max_value: int) -> list: result = [] self._inorder_range(self.root, min_value, max_value, result) return result def _inorder_range(self, node, min_value, max_value, result): if node is None or node == self.nil: return if node.key > min_value: self._inorder_range(node.left, min_value, max_value, result) if min_value <= node.key <= max_value: result.append(node.key) if node.key < max_value: self._inorder_range(node.right, min_value, max_value, result)"},{"question":"# Binary Tree Deepest Node Value You are given a binary tree and your task is to find the value of the deepest node in the tree. If there are multiple nodes at the same depth, return the leftmost node\'s value at that depth. # Input: * A binary tree where each node contains an integer value. # Output: * An integer which is the value of the deepest node (leftmost if multiple nodes share the same depth). # Constraints: * The number of nodes in the tree is between 0 and 10^5 (inclusive). * Node values are unique integers. * You may assume that the tree is well-formed based on the provided sample code. * Must handle both large balanced and unbalanced trees efficiently. # Performance Requirements: * Time Complexity: O(N), where N is the number of nodes in the tree. * Space Complexity: O(N) in the worst case due to the storage of nodes. # Example: Consider the following binary tree: ``` 10 / 12 15 / / 25 30 36 100 ``` * The deepest node is 100 which is at depth 4. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root: TreeNode) -> int: # function implementation here pass ``` # Task: Implement the `find_deepest_node` function that accepts a TreeNode as input and returns an integer value of the deepest node. # Additional Notes: * You can assume the provided sample class TreeNode is already implemented for you. * Remember to handle edge cases mentioned in the analysis section to ensure the function operates correctly in all scenarios.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root: TreeNode) -> int: if not root: return None # or you can raise an error if you expect a tree to always have at least one node from collections import deque queue = deque([(root, 0)]) current = root max_depth = 0 while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth current = node if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return current.val"},{"question":"You are provided with a linked list. Implement a function `is_sorted(head)` that determines whether the linked list is sorted in non-decreasing order. An empty list is considered sorted. **Function Signature**: ```python def is_sorted(head: ListNode) -> bool: ``` **Input**: - `head`: The head of the linked list. Each node in the linked list has the following structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Output**: - `True` if the linked list is in non-decreasing order. - `False` otherwise. **Constraints**: 1. The number of nodes in the linked list is in the range `[0, 10^6]`. 2. The value of each node is in the range `[-10^6, 10^6]`. **Examples**: ```python # Example 1: # Input: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) # Output: True # Example 2: # Input: head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))) # Output: False # Example 3: # Input: head = None # Output: True ``` **Context**: Imagine you are working on a versioning system where each version is stored in a linked list, and you need to verify that the version numbers are in non-decreasing order to ensure there are no accidental downgrades. Your task is to implement the function `is_sorted` to help ensure the versioning integrity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: if head is None: return True current = head while current.next is not None: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Josephus Problem You have been hired to work on a simulation project where people are sitting in a circle. According to the rules, every third person is eliminated until no one remains. Implement a function that takes a list of participants and a number `k` denoting every k-th person to be eliminated. The function should return a list representing the order in which the participants are eliminated. Function Signature ```python def josephus_participants(participants: List[int], k: int) -> List[int]: ``` Input * `participants` (List[int]): A list of integers where each integer represents a participant. * `k` (int): The step count to eliminate a participant. Output * List[int]: A list representing the order of elimination of participants. Constraints * `1 <= len(participants) <= 10^5` * `1 <= k <= 10^5` Scenario Given the input list `[1, 2, 3, 4, 5, 6, 7, 8, 9]` and the step count `3`, the elimination order should be `[3, 6, 9, 4, 8, 5, 2, 7, 1]`. Example ```python assert josephus_participants([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert josephus_participants([1, 2, 3], 2) == [2, 1, 3] ``` Implement the function in a way that optimizes both runtime and memory efficiency to handle the constraints provided.","solution":"from typing import List def josephus_participants(participants: List[int], k: int) -> List[int]: Returns the order in which participants are eliminated in the Josephus problem. elimination_order = [] idx = 0 while participants: idx = (idx + k - 1) % len(participants) elimination_order.append(participants.pop(idx)) return elimination_order"},{"question":"Optimized Cocktail Shaker Sort You are required to implement an optimized version of the Cocktail Shaker Sort. The optimizations you need to achieve are: 1. **Early Exit**: The algorithm should terminate as soon as it detects that the array is sorted. 2. **Bidirectional Implementation**: Ensure that the algorithm correctly traverses the list in both forward and backward directions. 3. **Efficient Swaps**: Minimize the number of swaps, making execution as efficient as possible. Write a function `optimized_cocktail_shaker_sort` that takes a list of integers as input and returns a sorted list. # Input - A list of integers `arr` (1 ≤ len(arr) ≤ 10^5), where each integer is in the range -10^9 to 10^9. # Output - A new list of integers sorted in non-decreasing order. # Constraints - You should not use any additional libraries for sorting. - Optimize for both time and space complexity where possible. # Example ```python def optimized_cocktail_shaker_sort(arr): # Your code here # Example usage: input_list = [3, 0, 2, 5, -1, 4, 1] sorted_list = optimized_cocktail_shaker_sort(input_list) print(sorted_list) # Output: [-1, 0, 1, 2, 3, 4, 5] ```","solution":"def optimized_cocktail_shaker_sort(arr): Perform an optimized cocktail shaker sort on the input list. n = len(arr) start = 0 end = n - 1 while True: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the list is sorted if not swapped: break # Otherwise, reset the swapped flag swapped = False end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # If no elements were swapped, the list is sorted if not swapped: break start += 1 return arr"},{"question":"# B-Tree Implementation and Operation You are tasked with creating and managing a B-Tree for a database indexing system. A B-Tree is a balanced tree data structure designed to efficiently handle insertions, deletions, and searches. Objective Implement a B-Tree class supporting the following operations: 1. **Insertion**: Add a key to the B-Tree, keeping it balanced. 2. **Deletion**: Remove a key from the B-Tree, maintaining its properties. 3. **Search**: Check whether a key exists in the B-Tree. 4. **Traversal**: Print all keys in sorted order. # Requirements 1. **Node Class**: Represents nodes in the B-Tree. 2. **BTree Class**: Implements the B-Tree structure and operations. # Function Requirements 1. **Insert Function** * **Function Signature**: `def insert_key(self, key: int) -> None` * **Description**: Adds a key to the B-Tree. * **Complexity Requirements**: O(log n) 2. **Delete Function** * **Function Signature**: `def remove_key(self, key: int) -> None` * **Description**: Removes a key from the B-Tree if it exists. * **Complexity Requirements**: O(log n) 3. **Search Function** * **Function Signature**: `def find(self, key: int) -> bool` * **Description**: Returns `True` if the key exists, else `False`. * **Complexity Requirements**: O(log n) 4. **Traversal Function** * **Function Signature**: `def traverse_tree(self) -> None` * **Description**: Prints all keys in sorted order. * **Complexity Requirements**: O(n) # Constraints * All keys are integers. * The degree of the B-Tree (t) will be at least 2. * Handle cases where the B-Tree needs re-balancing (splitting on insertions and merging on deletions). # Example ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) btree.traverse_tree() # Expected Output: # 5 6 7 10 12 17 20 30 btree.remove_key(6) btree.traverse_tree() # Expected Output: # 5 7 10 12 17 20 30 print(btree.find(12)) # Expected Output: # True print(btree.find(6)) # Expected Output: # False ``` # Notes * Ensure the B-Tree maintains its properties after every insertion and deletion. * Handle edge cases where nodes are full or underflow after operation.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.t = t_val self.root = BTreeNode(t_val, leaf=True) def traverse_tree(self): def _traverse(node): # Print all nodes in a subtree rooted with this node i = 0 for i in range(len(node.keys)): if not node.leaf: _traverse(node.children[i]) print(node.keys[i], end=\' \') if not node.leaf: _traverse(node.children[i+1]) _traverse(self.root) print() def find(self, key): def _find(node, key): # Find the first key greater than or equal to key i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 # If the found key is equal to key, return this node if i < len(node.keys) and node.keys[i] == key: return True # If the key is not found here and this is a leaf node if node.leaf: return False # Go to the appropriate child return _find(node.children[i], key) return _find(self.root, key) def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: new_root = BTreeNode(self.t, leaf=False) new_root.children.append(self.root) self._split_child(new_root, 0) self._insert_non_full(new_root, key) self.root = new_root else: self._insert_non_full(root, key) def remove_key(self, key): if not self.root: print(\\"The tree is empty\\") self._remove(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None def _split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, y.leaf) for j in range(t - 1): z.keys.append(y.keys[j + t]) if not y.leaf: for j in range(t): z.children.append(y.children[j + t]) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) y.keys = y.keys[:t-1] y.children = y.children[:t] def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _remove(self, node, key): t = self.t def get_pred(node, idx): curr = node.children[idx] while not curr.leaf: curr = curr.children[len(curr.keys)] return curr.keys[len(curr.keys) - 1] def get_succ(node, idx): curr = node.children[idx + 1] while not curr.leaf: curr = curr.children[0] return curr.keys[0] def merge(node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) for k in sibling.keys: child.keys.append(k) if not child.leaf: for k in sibling.children: child.children.append(k) node.children.pop(idx + 1) node.keys.pop(idx) idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: if len(node.children[idx].keys) >= t: pred = get_pred(node, idx) node.keys[idx] = pred self._remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = get_succ(node, idx) node.keys[idx] = succ self._remove(node.children[idx + 1], succ) else: merge(node, idx) self._remove(node.children[idx], key) else: if node.leaf: return flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: if idx != 0 and len(node.children[idx - 1].keys) >= t: sibling = node.children[idx - 1] node.children[idx].keys.insert(0, node.keys[idx - 1]) if not node.children[idx].leaf: node.children[idx].children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: sibling = node.children[idx + 1] node.children[idx].keys.append(node.keys[idx]) node.keys[idx] = sibling.keys.pop(0) if not node.children[idx].leaf: node.children[idx].children.append(sibling.children.pop(0)) else: if idx != len(node.keys): merge(node, idx) else: merge(node, idx - 1) idx -= 1 if flag and idx > len(node.keys): self._remove(node.children[idx - 1], key) else: self._remove(node.children[idx], key)"},{"question":"# Remove k-th Node From End in a Linked List In a linked list, nodes are arranged in a sequence, where each node points to the next node in the list. We often need to perform operations such as insertion, deletion, and traversal on linked lists. Problem Statement Write a function `remove_kth_from_end(head, k)` that removes the k-th node from the end of a given singly linked list and returns the modified linked list. Specifications - **Input**: - `head`: The head node of the linked list. Note that the linked list is constructed from instances of the `Node` class. - `k`: An integer representing the position from the end of the list. It is guaranteed that `1 <= k <= N` where `N` is the length of the list. - **Output**: - The head of the modified linked list after removing the k-th node from the end. - **Constraints**: - The linked list will have at least one node. - Your solution should run in O(N) time complexity using O(1) extra space. Example ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Example Usage # Constructing linked list: 1 -> 2 -> 3 -> 4 -> 5 n1 = Node(\\"1\\") n2 = Node(\\"2\\") n3 = Node(\\"3\\") n4 = Node(\\"4\\") n5 = Node(\\"5\\") n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 # Removing 2nd node from end: Resulting list should be 1 -> 2 -> 3 -> 5 head = remove_kth_from_end(n1, 2) print_linked_list(head) ``` Function Signature ```python def remove_kth_from_end(head: Node, k: int) -> Node: # your code here ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_kth_from_end(head, k): Removes the k-th node from the end of the list and returns the head of the modified list. # Create a dummy node that points to the head dummy = Node(0) dummy.next = head fast = slow = dummy # Move the fast pointer k steps ahead for _ in range(k): fast = fast.next # Move both the slow and the fast pointers until fast reaches the end of the list while fast.next: fast = fast.next slow = slow.next # Remove the k-th node slow.next = slow.next.next # Return the head of the modified list return dummy.next"},{"question":"# Matrix Multiplication Assessment Introduction You are tasked with implementing a function to multiply two matrices. The function should validate the dimensions of the input matrices and return the resulting product matrix. Function Signature ```python def matrix_multiply(A: list, B: list) -> list: ``` Input - `A`: A list of lists where each sublist represents a row in the multiplicand matrix. * Example: [[1, 2], [3, 4]] * Constraints: 1 <= len(A), len(A[0]) <= 100 - `B`: A list of lists where each sublist represents a row in the multiplier matrix. * Example: [[5, 6], [7, 8]] * Constraints: 1 <= len(B), len(B[0]) <= 100 Output - A list of lists representing the product matrix. * Example: [[19, 22], [43, 50]] Constraints - The number of columns in `A` must equal the number of rows in `B`. - The function should raise an exception with a descriptive message if the input dimensions are not compatible for multiplication. Example ```python >>> A = [[1, 2], [3, 4]] >>> B = [[5, 6], [7, 8]] >>> matrix_multiply(A, B) [[19, 22], [43, 50]] ``` Prompt Write the `matrix_multiply` function that takes in two matrices and returns their product matrix. Ensure that you handle edge cases such as incompatible matrix dimensions by raising appropriate exceptions. Performance Ensure that your solution is efficient and handles matrices up to 100x100 in a reasonable time frame.","solution":"def matrix_multiply(A: list, B: list) -> list: Multiplies two matrices A and B. Parameters: A (list): A list of lists where each sublist represents a row in the multiplicand matrix. B (list): A list of lists where each sublist represents a row in the multiplier matrix. Returns: list: A list of lists representing the product matrix. Raises: ValueError: If the number of columns in A does not match the number of rows in B. # Validate matrix dimensions if len(A[0]) != len(B): raise ValueError(\\"The number of columns in A must equal the number of rows in B\\") # Initialize the result matrix with zeros result = [[0] * len(B[0]) for _ in range(len(A))] # Perform matrix multiplication for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Question: Implement an Enhanced Searchable Word Dictionary Scenario You are building a new word puzzle game. The game requires a data structure that allows players to add words and search for them. The search can be either an exact match or can have wildcards represented by the dot (\'.\') character, which can match any single letter. You have analyzed two methods for implementing this: a Trie-based approach and a dictionary-based approach. Now, you are to implement your own solution using the approach you find most suitable. Task Implement a class `SearchableWordDictionary` with the following methods: 1. `add_word(word: str) -> None`: Adds the provided word to the dictionary. 2. `search(word: str) -> bool`: Returns `True` if the word is in the dictionary or if any sequence of characters matching the pattern (using \'.\') is found. Expected Input and Output * `add_word(word: str) -> None` - **Input**: a non-empty string `word` composed of lowercase English letters. - **Output**: none. * `search(word: str) -> bool` - **Input**: a non-empty string `word` composed of lowercase English letters and/or \'.\' characters. - **Output**: returns `True` if the word is found, otherwise returns `False`. Constraints * The added words and search patterns can have lengths ranging from 1 to 1000 characters. * The total number of words added can be up to 100,000. * The search operation should be optimized to handle wildcards efficiently. Performance Requirements * Your implementation should aim to have a balanced trade-off between memory usage and speed. Example ```python # Your implementation dict = SearchableWordDictionary() dict.add_word(\\"bad\\") dict.add_word(\\"dad\\") dict.add_word(\\"mad\\") print(dict.search(\\"pad\\")) # -> False print(dict.search(\\"bad\\")) # -> True print(dict.search(\\".ad\\")) # -> True print(dict.search(\\"b..\\")) # -> True ``` **Note**: Ensure to handle edge cases such as empty strings and words with consecutive wildcards gracefully.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class SearchableWordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"# Problem: Maximum Value in Knapsack **Scenario**: You are hired as a software developer by an e-commerce company to build solutions for maximizing their warehouse storage packing efficiency. Given a set of items, each with a value and a weight, you need to maximize the total value of items placed in a limited capacity knapsack. **Objective**: Write a function `maximize_knapsack_value(items, capacity)` that determines the maximum value of items that can fit into a knapsack of specified capacity. Function Signature ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight def maximize_knapsack_value(items: List[Item], capacity: int) -> int: pass ``` Input and Output * **Input**: * `items`: A list of `Item` objects, each having an integer `value` and an integer `weight`. * `capacity`: An integer, representing the knapsack\'s maximum weight capacity. * **Output**: * Return an integer representing the maximum total value that can be obtained by placing items into the knapsack. Constraints * `0 <= len(items) <= 1000` * `0 <= capacity <= 1000` * `1 <= value, weight <= 1000` Example ```python items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 print(maximize_knapsack_value(items, capacity)) # Output: 80 ``` **Performance Requirements**: * The solution must efficiently handle up to 1000 items and a knapsack capacity of up to 1000. # Detailed Explanation: The function should use a dynamic programming approach, where it maintains an array `dp` to track the highest value achievable for each capacity up to the given capacity. Iteratively update this array based on each item\'s weight and value, ensuring to maximize the achievable value at every step.","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def maximize_knapsack_value(items: List[Item], capacity: int) -> int: # Create a list to store the maximum value that can be obtained for each weight from 0 to capacity dp = [0] * (capacity + 1) for item in items: # Traverse the dp array from right to left for w in range(capacity, item.weight - 1, -1): # Update dp[w] to the maximum value considering the current item dp[w] = max(dp[w], dp[w - item.weight] + item.value) return dp[capacity]"},{"question":"# Pigeonhole Sort Assessment You are provided with an unsorted list of integers. Your task is to implement the `pigeonhole_sort` function, which sorts the list using the pigeonhole sorting algorithm. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input * A list `arr` of `n` integers, where `0 <= n <= 10^6`. Output * The function should return a list of integers sorted in ascending order. Constraints * The values in the array can range as widely as reasonably possible based on system limitations, but you should consider an expected range difference about `max(arr) - min(arr) <= 10^6`. Example ```python Input: [8, 3, 2, 7, 4, 6, 8] Output: [2, 3, 4, 6, 7, 8, 8] Input: [] Output: [] Input: [3] Output: [3] ``` Scenario Given a scenario where you have to sort transaction timestamps recorded in seconds within a single day, ranging from `0` to `86,400`. The transactions are not numerous but the timestamps cover the wide range. Ensure the list is efficiently sorted maintaining performance. Use your understanding of pigeonhole sort to develop and test your solution while managing edge cases and performance considerations.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for x in arr: holes[x - min_val] += 1 sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([min_val + index] * count) return sorted_arr"},{"question":"# Jump Search Algorithm Implementation Given a sorted list of integers, write a function `jump_search` that implements the Jump Search algorithm to find the position of a target integer in the list. If the target integer is not present in the list, the function should return -1. Function Signature ```python def jump_search(arr: List[int], target: int) -> int: pass ``` Parameters - **arr** (List[int]): A sorted list of integers where you need to search for the target. - **target** (int): The integer value to search for in the array. Returns - **int**: The index of the target if found, otherwise -1. Constraints - The list `arr` will have at most (10^6) elements. - The integers in `arr` and `target` will be between (-10^9) and (10^9). Performance Requirement - The function should have an average time complexity of O(√n), where n is the number of elements in the list. Scenario Imagine you maintain a collection of sorted data points and frequently need to perform search operations. Traditional linear search is too slow, and maintaining various indices for binary search is complex and impractical. Implementing Jump Search offers a balanced solution, streamlining your search operations more efficiently. # Example ```python arr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] target = 19 assert jump_search(arr, target) == 7 arr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] target = 4 assert jump_search(arr, target) == -1 ``` # Notes - Ensure that your implementation handles edge cases, such as the target being smaller than the smallest element or greater than the largest element in the list. - Optimize your code to handle lists near the upper constraint efficiently.","solution":"import math from typing import List def jump_search(arr: List[int], target: int) -> int: length = len(arr) if length == 0: return -1 # Finding the optimal jump size jump = int(math.sqrt(length)) # Finding the block where the target might be prev = 0 while prev < length and arr[min(jump, length) - 1] < target: prev = jump jump += int(math.sqrt(length)) if prev >= length: return -1 # Linear search within the found block for idx in range(prev, min(jump, length)): if arr[idx] == target: return idx return -1"},{"question":"You are given a hash table implementation with linear probing and dynamic resizing capabilities. Your task is to extend this hash table to include a new method `merge` which takes another hash table as input and merges it into the current hash table. If any keys are duplicated, the value from the input hash table should overwrite the value in the current hash table. # Function Signature ```python def merge(self, other_hash_table: ResizableHashTable) -> None: Merges another hash table into the current hash table. :param other_hash_table: A ResizableHashTable instance to be merged into self. :return: None ``` # Input * An instance of `ResizableHashTable` representing the current hash table. * An instance of `ResizableHashTable` representing the other hash table to be merged. # Output * Modify the current hash table to include key-value pairs from the other hash table. # Constraints * Both hash tables may contain up to 10^4 key-value pairs. * Keys are integers, and values are strings. All keys are unique within each hash table but may overlap between hash tables. # Example ```python # Create two hash tables ht1 = ResizableHashTable() ht1.put(1, \'one\') ht1.put(2, \'two\') ht1.put(3, \'three\') ht2 = ResizableHashTable() ht2.put(3, \'THREE\') ht2.put(4, \'four\') # Perform merge ht1.merge(ht2) # Expected content of ht1 # 1: \'one\' # 2: \'two\' # 3: \'THREE\' (value from ht2 overwrites value from ht1) # 4: \'four\' ``` Your solution should use the existing `put` method of the hash table to ensure that any resizing logic is preserved.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=10): Initialize the hash table with a given initial capacity. self.table = [None] * initial_capacity self.size = 0 self.capacity = initial_capacity def hash_function(self, key): Simple hash function to compute the hash value for a given key. return key % self.capacity def put(self, key, value): Insert or update the key-value pair in the hash table. index = self.hash_function(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.capacity # If the key is new, increase the size if self.table[index] is None: self.size += 1 self.table[index] = (key, value) # Resize if the table is 70% full if self.size > 0.7 * self.capacity: self._resize() def get(self, key): Retrieve the value associated with the given key. index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def _resize(self): Resize the hash table when load factor exceeds 0.7. old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def merge(self, other_hash_table): Merges another hash table into the current hash table. for item in other_hash_table.table: if item is not None: self.put(item[0], item[1])"},{"question":"Context You are tasked with developing a system for an online word game where players can group words that are anagrams of each other dynamically. Problem Statement Write a function `group_anagrams(words)` that takes a list of strings and groups the anagrams together. Two words are anagrams if they can be formed by rearranging the letters of each other. Function Signature ```python def group_anagrams(words: List[str]) -> List[List[str]]: pass ``` Input and Output Format **Input**: * `words`: A list of strings (1 <= len(words) <= 10^4, 1 <= len(words[i]) <= 100). **Output**: * Return a list of lists of anagrams. Each list contains words that are anagrams of each other. The order of the words in the output does not matter. Each word in the input list must appear exactly once in the output. Constraints * Each string only contains lower-case letters. Performance Requirements * The solution should efficiently handle up to 10,000 words with varying lengths, within reasonable time and space limits. Example * Input: [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] * Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] Edge Cases to Consider 1. **Empty list**: Ensure the function can handle and return expected output for empty input. 2. **Identical strings**: Multiple identical strings should be treated as anagrams. 3. **Varying lengths**: Ensure proper grouping despite different string lengths. Use hashmaps/dictionaries to map sorted versions of the strings to their originals to optimize anagram grouping.","solution":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: Groups the list of words into anagrams. Args: words (List[str]): List of words to be grouped Returns: List[List[str]]: List of lists containing grouped anagrams anagram_map = defaultdict(list) for word in words: # Sorting the word to get the key key = \'\'.join(sorted(word)) anagram_map[key].append(word) # Returning the grouped anagrams return list(anagram_map.values())"},{"question":"# Question: Serialize and Deserialize a Binary Tree **Context**: You\'ve been tasked with implementing a system that allows binary trees to be stored and transmitted efficiently as strings. This involves two main functions: `serialize`, which converts a binary tree into a string, and `deserialize`, which reconstructs the binary tree from the string. # Task: Implement the `serialize` and `deserialize` functions to allow conversion between a binary tree and a string representation. # Specifications: 1. **Serialize Function**: - **Input**: `root` of a binary tree (`TreeNode`). - **Output**: A string that represents the tree in a pre-order traversal format where `None` nodes are denoted by \\"#\\". 2. **Deserialize Function**: - **Input**: A string representing the serialized tree. - **Output**: The root node of the reconstructed binary tree (`TreeNode`). **Constraints**: - Each node\'s value in the binary tree is an integer. - The binary tree can have zero or more nodes. - Ensure that both functions handle edge cases such as empty trees and very large trees efficiently. **Performance**: - Target O(n) time complexity for both `serialize` and `deserialize` functions. - Ensure space complexity is proportional to the number of nodes, considering additional space for the serialized string and the recursive call stack. **Edge Cases to Consider**: - Empty tree (root is `None`). - Trees with only left or only right subtrees. - Balanced and unbalanced trees. Example: ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 # Serialize root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized_tree = serialize(root) print(serialized_tree) # Expected Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize new_root = deserialize(serialized_tree) print(new_root.val) # Expected Output: 1 print(new_root.left.val) # Expected Output: 2 print(new_root.right.val) # Expected Output: 3 print(new_root.right.left.val) # Expected Output: 4 print(new_root.right.right.val) # Expected Output: 5 ``` # Notes: - Do not use any built-in libraries for tree serialization/deserialization. - Ensure the solution is robust and well-tested for various tree structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. :param root: TreeNode :return: str def helper(node): if node is None: return \\"#,\\" return str(node.val) + \\",\\" + helper(node.left) + helper(node.right) return helper(root).rstrip(\',\') def deserialize(data): Decodes your encoded data to tree. :param data: str :return: TreeNode def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node node_iter = iter(data.split(\\",\\")) return helper(node_iter)"},{"question":"Scenario You are analyzing survey results collected from numerous respondents, each providing their favorite number. To better understand the popular choices, you need to determine the modes of the survey results. Your task is to implement an algorithm that identifies the most frequently occurring numbers in the survey. Task Implement the function `find_modes(arr)` that accepts an array of integers representing survey responses and returns a list of integers representing the modes (most frequent values). If multiple modes exist, the function should return all of them. Input and Output Formats * **Input**: A list of integers `arr`, where `1 <= len(arr) <= 10^6` and each integer `1 <= arr[i] <= 10^6`. * **Output**: A list of integers containing the mode(s). The order of integers in the returned list does not matter. Constraints * The algorithm should efficiently handle large inputs up to the upper constraints mentioned. * You need to appropriately handle edge cases, such as an empty array or an array where all elements are the same. Example ```python def find_modes(arr): # Your implementation here # Example Usage print(find_modes([1, 1, 2, 2, 3, 4])) # Output: [1, 2] print(find_modes([5, 5, 5, 6, 6])) # Output: [5] print(find_modes([7, 8, 9, 10])) # Output: [7, 8, 9, 10] ``` Notes * Your implementation should run in O(n) time complexity and O(n) space complexity. * Carefully handle the case where the input array is empty and return an appropriate result (e.g., an empty list).","solution":"from collections import Counter def find_modes(arr): Finds the modes (most frequent elements) in the given list of integers. :param arr: List[int] - List of integers representing survey results. :return: List[int] - List of integers representing the modes. if not arr: return [] # Count the frequency of each element in the array frequency = Counter(arr) # Find the highest frequency max_frequency = max(frequency.values()) # Extract all elements that have the highest frequency modes = [key for key, value in frequency.items() if value == max_frequency] return modes"},{"question":"You are given a sorted array of integers and a search key. Your task is to implement and extend the Interpolation Search Algorithm to handle potential edge cases more robustly and improve its functionality. # Specifically: 1. The array is always sorted in non-decreasing order. 2. Return the index of the search key if it is present in the array. 3. Return `-1` if the search key is not found. 4. Handle edge cases such as: - The array contains repeated elements. - The search key is outside the range of array elements. - The array may be empty. # Function Signature: ```python def robust_interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Input: * `array` (List[int]): A list of integers sorted in non-decreasing order, which can contain zero or more elements. * `search_key` (int): An integer representing the value to search for. # Output: * Returns the index (int) of `search_key` if present, otherwise returns `-1`. # Constraints: * The array length `n` is in the range [0, 10^6]. * The elements within the array can be any integer within the range of [-10^9, 10^9]. * Assume reasonable uniformity in the distribution of array elements for typical cases but also consider and handle non-uniform distributions. # Example: ```python assert robust_interpolation_search([1, 2, 3, 4, 5, 6], 3) == 2 assert robust_interpolation_search([10, 20, 30, 40, 50], 35) == -1 assert robust_interpolation_search([], 5) == -1 assert robust_interpolation_search([1, 2, 2, 2, 3], 2) == 1 assert robust_interpolation_search([100, 100, 100, 100], 100) == 0 ``` # Explanation: - The first example finds `3` at index `2`. - The second example does not find `35`, returning `-1`. - The third example handles an empty array, returning `-1`. - The fourth example finds `2` which can be at any index from `1` to `3` due to repetition and consistently returns the smallest index of the key. - The fifth example finds multiple occurrences of `100`, returning `0`. Now, write robust implementation of the described Interpolation Search Algorithm.","solution":"from typing import List def robust_interpolation_search(array: List[int], search_key: int) -> int: Perform a robust interpolation search to find the index of search_key in a sorted array. Returns the smallest index of search_key if present, otherwise returns -1. Parameters: array (List[int]): A list of sorted integers. search_key (int): The integer value to search for in the array. Returns: int: The index of search_key if present; otherwise, -1. n = len(array) if n == 0: return -1 low = 0 high = n - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if array[high] == array[low]: if array[low] == search_key: return low else: break pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if pos < low or pos > high: return -1 if array[pos] == search_key: while pos > low and array[pos - 1] == search_key: pos -= 1 return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"**Question**: Implement a function `find_element(arr, target, simulation=False)` that uses Bubble Sort to sort the input array, then performs a binary search to find a target element. # Input: - `arr`: A list of integers that may be unsorted. - `target`: An integer to find in the sorted array. - `simulation (optional)`: A boolean indicating whether to print the Bubble Sort simulation steps (default is `False`). # Output: - Return the index of the `target` element in the sorted array. - If the `target` is not found, return `-1`. # Constraints: - The function should only use iterable and numeric types for `arr`. - The `arr` length will be at most `10^4`. - The elements in `arr` will be between `-10^6` to `10^6`. # Performance Requirements: - The Bubble Sort must complete within reasonable time, given its O(n^2) complexity. - Binary search must run in O(log n) time complexity on the sorted array. # Example: ```python arr = [5, 2, 9, 1, 5, 6] target = 5 print(find_element(arr, target)) # Output: Index of 5 in the sorted array, should return 3 OR 4, array [1, 2, 5, 5, 6, 9] ``` # Note: - You cannot use Python\'s built-in sorting algorithms. - Make sure to handle edge cases such as an empty array or an array where all elements are the same. - Use the provided `bubble_sort` function as part of your solution.","solution":"def bubble_sort(arr, simulation): n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] if simulation: print(f\\"Step {i * n + j + 1}: {arr}\\") def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def find_element(arr, target, simulation=False): bubble_sort(arr, simulation) return binary_search(arr, target)"},{"question":"# Context You are a software engineer tasked with creating a text editor application. The editor should support basic typing operations and also provide \\"undo\\" functionality, allowing the user to revert their actions step-by-step. # Problem Statement You need to implement an `UndoStack` class based on the provided `Stack ADT` design. This `UndoStack` will manage the history of text edits. Specifically, the `UndoStack` should support the following operations: 1. `add_operation(operation: str)`: Adds a text operation (a string representing an edit action) to the stack. 2. `undo()`: Reverts the most recent edit action from the stack, returning the undone action. 3. `peek_operation()`: Returns the most recent edit action without removing it from the stack. 4. `is_empty()`: Checks if there are any operations to undo. # Requirements - Implement this using either the `ArrayStack` or `LinkedListStack` provided earlier. - Ensure that the `undo` and `peek_operation` methods handle empty stacks gracefully by raising an appropriate exception. - The stack should initially support storing up to 10 operations. For `ArrayStack`, it should expand dynamically if needed. # Input and Output Formats **No direct input/output formats** are required as the task focuses on class implementation. # Constraints - The operations added will be strings with a maximum length of 100 characters. - You should ensure that the stack performs optimally and handles edge cases like attempting to undo or peek when no operations exist. # Example ```python # Usage Example undo_stack = UndoStack() # Performing operations undo_stack.add_operation(\\"Insert \'Hello\'\\") undo_stack.add_operation(\\"Delete \'o\'\\") undo_stack.add_operation(\\"Insert \'World\'\\") # Undo last operation print(undo_stack.undo()) # Output: Insert \'World\' # Peek the last operation without undoing print(undo_stack.peek_operation()) # Output: Delete \'o\' # Undo all operations print(undo_stack.undo()) # Output: Delete \'o\' print(undo_stack.undo()) # Output: Insert \'Hello\' # Check if there are any more operations to undo print(undo_stack.is_empty()) # Output: True ```","solution":"class UndoStack: def __init__(self): self._stack = [] self._capacity = 10 def add_operation(self, operation: str): if len(self._stack) == self._capacity: self._expand_capacity() self._stack.append(operation) def undo(self): if self.is_empty(): raise Exception(\\"No operations to undo.\\") return self._stack.pop() def peek_operation(self): if self.is_empty(): raise Exception(\\"No operations to peek.\\") return self._stack[-1] def is_empty(self): return len(self._stack) == 0 def _expand_capacity(self): self._capacity *= 2"},{"question":"Scenario You have been hired by a fintech startup to develop a system that detects pairs of transactions adding up to a specific target value. This will help in underwriting processes where specific transaction pairs are required to validate operations. Task Implement the function `find_transaction_pairs(transactions, target)` that takes in a list of integers representing transaction values and a single integer `target` which is the sum we aim to find pairs for. Function Signature ```python def find_transaction_pairs(transactions: List[int], target: int) -> Tuple[int, int]: pass ``` Input 1. `transactions` (List[int]): An array of integers representing transaction values. 2. `target` (int): The target sum for which we need to find a pair. Output - A tuple containing the indices of the two numbers in the `transactions` array such that they add up to the `target`. - Return `None` if no such pair exists. Constraints * The input list will contain at most 10^6 elements. * Each input list will have exactly one pair of integers that sum up to the `target`. * Elements in the list are not guaranteed to be unique. Example ```python transactions = [2, 7, 11, 15] target = 9 # Expected Output: (0, 1) (since 2 + 7 = 9) ``` Additional Details - Optimize for both time and space complexity. - Consider edge cases such as minimum input sizes and negative numbers. Note Do not use the same element from the list twice to form the pair.","solution":"from typing import List, Tuple, Optional def find_transaction_pairs(transactions: List[int], target: int) -> Optional[Tuple[int, int]]: This function finds a pair of indices in the transactions list such that the numbers at these indices add up to the target value. :param transactions: List of integers representing transaction values. :param target: Integer representing the target sum. :return: A tuple of indices if a pair is found, else None. # Create a dictionary to store the difference of the target and each transaction value. # The key will be the transaction value and the value will be its index. seen = {} for index, value in enumerate(transactions): # Calculate the required value to form the target sum remaining = target - value # If the remaining value is found in the seen dictionary, we return the pair of indices if remaining in seen: return (seen[remaining], index) # Store the current value with its index in the seen dictionary seen[value] = index # Return None if no pair is found return None"},{"question":"**Scenario**: You work as a software developer, and you have integrated a new logging system that tracks requests received by the server. Occasionally, the logs from two servers must be analyzed to identify discrepancies where a request logged by one server but not the other has been tampered with by adding a single character. Given two strings `s` and `t`, where string `t` is generated by random shuffling string `s` and then adding one more letter at a random position, write a function: ```python def find_difference(s: str, t: str) -> str: pass ``` # Input * `s`: A string consisting of only lowercase letters (1 ≤ len(s) ≤ 10^5). * `t`: A string consisting of only lowercase letters (1 ≤ len(t) ≤ 10^5 and len(t) = len(s) + 1). # Output * Returns the character that was added to `t`. # Constraints * Only lowercase alphabetical characters are present in the strings. * Besides the additional character, both strings are comprised of the same characters in some order. # Example ```python s = \\"abcd\\" t = \\"abcde\\" # Output: \'e\' ``` Explanation: \'e\' is the letter that was added. # Note Your implementation should efficiently handle large input sizes.","solution":"def find_difference(s: str, t: str) -> str: Finds the character that was added to t. Args: s (str): Original string. t (str): String generated by shuffling s and adding one extra character. Returns: str: The character that was added to t. char_count = {} # Count characters in s for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Subtract character counts from t for char in t: if char not in char_count or char_count[char] == 0: return char char_count[char] -= 1 # This line should theoretically never be reached because there must be exactly one extra character raise ValueError(\\"No additional character found\\")"},{"question":"Context: You are tasked with building a word matcher that surrounds matched symbols within words with square brackets. The challenge is to handle a scenario where multiple symbols can match the same word, ensuring that the longest matching symbol is chosen. Problem Statement: **Function Signature**: ```python def match_longest_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` **Input**: * `words` (List[str]): An array of words. * `symbols` (List[str]): An array of symbols to match. **Output**: * List[str]: A list of words with matched symbols surrounded by square brackets. **Constraints**: * 1 <= len(words), len(symbols) <= 10^3 * 1 <= len(word), len(symbol) <= 100 * Words and symbols contain only lowercase and uppercase English alphabet letters. **Performance Requirements**: * Your solution should be efficient, aiming for O(N * L + M * L) complexity, where N is the number of words, L is the average length of words, and M is the number of symbols. Detailed Instructions: 1. **Trie Construction**: * Construct a Trie from the given symbols. 2. **Symbol Matching**: * For each word, traverse character by character to find all possible symbol matches. * Ensure the longest match is selected if multiple matches are found. 3. **Replacement**: * Surround the matched symbol with square brackets in the word. 4. **Edge Cases Handling**: * Handle words with no matching symbols by returning them unchanged. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] assert match_longest_symbols(words, symbols) == [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Hints: * Use a Trie to store symbols efficiently and facilitate prefix-based matching. * Traverse the word to identify all potential matches, picking the longest match. * Consider edge cases where words do not contain any symbols or where symbols overlap. Implementation: Complete the `match_longest_symbols` function to solve the given problem based on the detailed instructions provided.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_symbol = False self.symbol = \\"\\" class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_symbol = True node.symbol = word def search_longest_prefix(self, word: str) -> str: node = self.root longest = \\"\\" current = \\"\\" for char in word: if char in node.children: node = node.children[char] current += char if node.is_end_of_symbol: longest = current else: break return longest def match_longest_symbols(words: List[str], symbols: List[str]) -> List[str]: trie = Trie() for symbol in symbols: trie.insert(symbol) result = [] for word in words: max_len = 0 longest_symbol = \\"\\" start_index = -1 for i in range(len(word)): sub_word = word[i:] matched_symbol = trie.search_longest_prefix(sub_word) if len(matched_symbol) > max_len: max_len = len(matched_symbol) longest_symbol = matched_symbol start_index = i if longest_symbol: formatted = word[:start_index] + \\"[\\" + longest_symbol + \\"]\\" + word[start_index + max_len:] result.append(formatted) else: result.append(word) return result"},{"question":"# Question You are assigned to develop a function that evaluates if a given non-empty string can be constructed by repeatedly appending copies of a substring. Function Signature ```python def repeated_substring_pattern(s: str) -> bool: ``` Input * `s` (str): A non-empty string of lowercase alphabets with a length between 1 and 10,000. Output * (bool): Return `True` if the input string can be constructed by taking a substring of it and appending multiple copies of the substring together, or `False` otherwise. # Examples ```python assert repeated_substring_pattern(\\"abab\\") == True assert repeated_substring_pattern(\\"aba\\") == False assert repeated_substring_pattern(\\"abcabcabcabc\\") == True ``` # Constraints & Considerations * The function should handle string lengths efficiently. * Pay attention to edge cases such as single-character strings, very large strings, and strings with no repeating pattern. * Verify that your implementation has a linear time complexity and uses linear space effectively. # Scenario Imagine you are a data scientist working with genetic sequences. You need to identify if a genomic sequence is formed by repeating a certain pattern of nucleotides. This function helps in identifying those repetitive patterns efficiently. # Implementation Tip To get an understanding of the pattern, consider concatenating the string with itself and removing the first and last characters. Then check if the original string appears within this new string.","solution":"def repeated_substring_pattern(s: str) -> bool: Evaluates if a given non-empty string can be constructed by repeatedly appending copies of a substring. Parameters: s (str): The input string. Returns: bool: True if the string can be made by repeating a substring, False otherwise. if not s: return False # Concatenate the string with itself and remove the first and last character ss = (s + s)[1:-1] # Check if the original string exists within this new string return s in ss"},{"question":"Scenario You are developing a stack-based application where data integrity is paramount. Specifically, you need to ensure that certain data stored in stacks follow specific ordering rules. For this task, your team needs to verify whether the integers in the stack are consecutive. Problem Write a function `is_consecutive(stack: List[int]) -> bool` that determines whether a given stack of integers contains consecutive integers starting from the bottom. Function Specification * **Input:** * A list of integers representing a stack, (`List[int]`) where the end of the list represents the top of the stack and the start of the list represents the bottom. * **Output:** * Returns `True` if the integers form a sequence of consecutive integers from the bottom to the top, otherwise returns `False`. Requirements * The function should **not** alter the original stack order. * Utilize either an auxiliary stack or queue to restore the initial state of the stack. * Ensure the function runs efficiently with a time complexity of O(n) and a space complexity of O(n). Constraints * The stack will contain between 1 and 10^5 integers. * All integers in the stack will be unique. Example ```python assert is_consecutive([3, 4, 5, 6, 7]) == True assert is_consecutive([3, 4, 6, 7]) == False assert is_consecutive([3, 2, 1]) == False assert is_consecutive([1, 2]) == True assert is_consecutive([10]) == True ``` Note Make sure the function handles edge cases gracefully and efficiently restores the stack\'s initial state after processing. Also, optimize for both time and space complexity.","solution":"def is_consecutive(stack): Determine if the integers in the stack are consecutive starting from the bottom. :param stack: List[int] - the stack of integers :return: bool - True if the integers in the stack are consecutive, False otherwise n = len(stack) if n < 2: return True # Utilize an auxiliary stack to keep track of the order auxiliary_stack = [] last_element = stack[0] for elem in stack[1:]: if elem != last_element + 1: return False last_element = elem return True"},{"question":"**Problem Statement**: You are given the root of a binary tree where each node contains an integer value. Your goal is to generate all root-to-leaf paths in the binary tree. Each path should be represented as a string in the format \'root->node1->node2->...->leaf\'. **Function Signature**: ```python def binary_tree_paths(root) -> List[str]: ``` # Input: * `root`: The root node of a binary tree. Each node in the tree contains two pointers/references (`left` and `right`) and an integer value (`val`). # Output: * A list of strings, each representing a path from the root to a leaf node. # Constraints: * All node values are unique. * The number of nodes in the tree is between 1 and 1000. * Each node can have at most two children. # Example: ```plaintext Input: 1 / 2 3 5 Output: [\\"1->2->5\\", \\"1->3\\"] ``` # Notes: * A leaf is a node with no children. * All root-to-leaf paths in the output list should be strings formatted as described. **Task**: Implement the function `binary_tree_paths` to find all the paths from the root to the leaf nodes in the binary tree.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def dfs(node, path, paths): if node: path += str(node.val) # Check if it\'s a leaf node if not node.left and not node.right: paths.append(path) # Append the path to the result else: path += \\"->\\" # Add arrow notation dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"You are given a sorted (increasing order) array and a query number. Your task is to find the index of the first occurrence of the query number using an efficient algorithm tailored for this purpose. If the query number is not present in the array, the function should return `-1`. # Your Task Write a function `first_occurrence(array, query)` that takes in two parameters: * `array`: a list of integers, sorted in increasing order. * `query`: an integer representing the number whose first occurrence index we need to find. # Input * `array`: A list of integers `[-10^5 <= array[i] <= 10^5]`, `1 <= len(array) <= 10^6` * `query`: An integer `[-10^5 <= query <= 10^5]` # Output * Return the zero-based index of the first occurrence of the `query`. If the `query` is not present in the `array`, return `-1`. # Constraints * The given array is always sorted in increasing order but may contain duplicate elements. * Perform the search in O(log n) time complexity. # Example ```python # Example 1: array = [1, 2, 2, 4, 5, 5, 5, 6] query = 5 Output: 4 # Example 2: array = [1, 2, 3, 4, 5] query = 6 Output: -1 # Example 3: array = [2, 2, 2, 2, 2, 2] query = 2 Output: 0 ``` # Notes 1. Remember to handle edge cases such as an empty array, or where the query does not exist in the array. 2. Ensure your solution efficiently handles the given constraints.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of \'query\' in the sorted list \'array\'. If \'query\' is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Coding Assessment: Implementing and Enhancing a Trie In this task, you are required to implement a Trie (prefix tree) with additional functionality. You need to demonstrate a strong understanding of data structures, particularly how tries work and are used in real-world applications, such as an autocomplete system. Along with basic operations like insertion and search, you need to implement a method that suggests words based on a given prefix. Objectives 1. Implement the Trie with basic methods: `insert(word)`, `search(word)`, and `starts_with(prefix)`. 2. Add a method `suggest(prefix)` that returns a list of all words in the trie that start with the given prefix. # Input and Output Formats - **insert(word)**: - **Input**: A string `word` containing lowercase letters (1 <= `len(word)` <= 100). - **Output**: None. - **search(word)**: - **Input**: A string `word` containing lowercase letters. - **Output**: Boolean `True` if the word is in the trie, else `False`. - **starts_with(prefix)**: - **Input**: A string `prefix` containing lowercase letters. - **Output**: Boolean `True` if there is any word in the trie that starts with the given prefix, else `False`. - **suggest(prefix)**: - **Input**: A string `prefix` containing lowercase letters. - **Output**: A list of strings, each representing a word that starts with `prefix`. The words should be in lexicographical order. # Constraints - Words are made up of lowercase English letters. - You may assume the maximum number of words does not exceed 10,000. - The maximum length of any word does not exceed 100 characters. # Performance Requirements: - The insert, search, and starts_with operations should efficiently handle the specified limits. - The suggest method should return results in a reasonable time for common use cases. # Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True trie.insert(\\"application\\") print(trie.suggest(\\"app\\")) # Output: [\\"app\\", \\"apple\\", \\"application\\"] ``` Implement the `suggest` method alongside the basic Trie operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self._search_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix): node = self._search_node(prefix) return node is not None def suggest(self, prefix): node = self._search_node(prefix) if not node: return [] words = [] self._collect_words(node, prefix, words) return sorted(words) def _search_node(self, word): node = self.root for char in word: if char not in node.children: return None node = node.children[char] return node def _collect_words(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): self._collect_words(next_node, prefix + char, words)"},{"question":"# Quick Sort Algorithm Implementation and Analysis **Objective**: Implement and analyze the Quick Sort algorithm. **Scenario**: You are given an unsorted list of distinct integers. Your task is to sort the list using the Quick Sort algorithm. You are asked to analyze the performance of your implementation and optimize the pivot selection to avoid the worst-case scenario. # Function Signature ```python def optimized_quick_sort(arr): Sorts an array using the Quick Sort algorithm. Args: arr (list): A list of distinct integers. Returns: list: A new list of integers sorted in ascending order. pass ``` # Requirements 1. Implement the `optimized_quick_sort` function. 2. Optimize the pivot selection using the median-of-three rule. 3. Ensure the algorithm handles edge cases including empty list, single-element list, and already sorted or reverse-sorted lists. 4. Your solution should not print anything, and it should work efficiently for lists with up to 10^6 elements. 5. Analyze the time and space complexity of your implementation in the comments. # Input Format Your function will be called with a single argument: * `arr`: List of distinct integers. (0 <= len(arr) <= 10^6, -10^9 <= arr[i] <= 10^9) # Output Format Your function should return a new list of integers sorted in ascending order. # Constraints * Focus on optimizing pivot selection to avoid the worst-case time complexity. * Implement in-place sorting to minimize space usage. * Maintain the time complexity close to O(n log n) in average scenarios. # Example ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([1]) == [1] assert optimized_quick_sort([]) == [] assert optimized_quick_sort([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10] assert optimized_quick_sort([1, -2, 3, 4, -5, 6, 7, 8, 9, 10, 0]) == [-5, -2, 0, 1, 3, 4, 6, 7, 8, 9, 10] ```","solution":"def optimized_quick_sort(arr): Sorts an array using the Quick Sort algorithm with the median-of-three pivot selection. Args: arr (list): A list of distinct integers. Returns: list: A new list of integers sorted in ascending order. if not arr: return [] def median_of_three(a, low, high): mid = (low + high) // 2 if a[low] < a[mid]: if a[mid] < a[high]: return mid elif a[low] < a[high]: return high else: return low else: if a[low] < a[high]: return low elif a[mid] < a[high]: return high else: return mid def partition(a, low, high): pivot_index = median_of_three(a, low, high) a[pivot_index], a[high] = a[high], a[pivot_index] pivot = a[high] i = low - 1 for j in range(low, high): if a[j] <= pivot: i = i + 1 a[i], a[j] = a[j], a[i] a[i + 1], a[high] = a[high], a[i + 1] return i + 1 def quick_sort_recursive(a, low, high): if low < high: pivot_index = partition(a, low, high) quick_sort_recursive(a, low, pivot_index - 1) quick_sort_recursive(a, pivot_index + 1, high) arr_copy = arr[:] # Create a copy to avoid modifying the original list quick_sort_recursive(arr_copy, 0, len(arr_copy) - 1) return arr_copy # Analyzing the time and space complexity: # - Time Complexity: O(n log n) on average, O(n^2) in the worst case (rare with optimized pivot) # - Space Complexity: O(log n) due to recursion stack space"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure * **Name**: Longest Consecutive Sequence in a Binary Tree * **Type**: Depth-First Search (DFS) in a Tree * **Main Purpose**: Find the length of the longest consecutive sequence of nodes from parent to child in a binary tree. # Complexity * **Time Complexity**: O(N), where N is the number of nodes in the tree, because each node is visited once. * **Space Complexity**: O(H), where H is the height of the tree, which accounts for the system stack during DFS. # Principles * The algorithm utilizes Depth-First Search to traverse the tree. * It keeps track of the current length of the consecutive path and updates the maximum length found. * Each node is checked if it continues the consecutive sequence from its parent. # Characteristics & Applications * **Properties**: * Traversal order follows pre-order DFS. * It ensures that sequences are strictly increasing from parent to child. * **Common Use Cases**: * Problems involving paths in tree structures. * Applications requiring sequence consistency checks. * **Strengths**: * Linear time complexity makes it efficient for large trees. * Useful for hierarchical data analysis. * **Limitations**: * Recursive approach might lead to stack overflow for extremely deep trees. * Not suitable for non-tree graphs without modification. # Implementation Challenges * **Edge Cases**: * Single node tree. * Trees where no two consecutive nodes have values differing by exactly one. * **Performance Bottlenecks**: * Deep trees might cause stack overflow due to deep recursion. * **Error Scenarios**: * Incorrectly handling base cases, like null nodes, can lead to errors. * Failing to update the maximum length correctly can yield incorrect results. * **Optimization Points**: * Use iterative DFS with an explicit stack to avoid system stack overflow in extremely deep trees. * Pass the maximum length as a mutable reference to reduce overhead. <|Analysis End|> <|Question Begin|> # Problem Statement Given a binary tree, write a function to find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse). # Input and Output Format **Input:** * `root`: The root node of the binary tree (`TreeNode`). **Output:** * An integer representing the length of the longest consecutive sequence path. # Constraints * The number of nodes in the binary tree can be up to 10,000. * Node values are between `-10^9` and `10^9`. * The consecutive sequence must strictly increment by 1 at each step. # Example For the following binary tree: ``` 1 3 / 2 4 5 ``` The longest consecutive sequence path is `3-4-5`, thus the function should return `3`. For the following binary tree: ``` 2 3 / 2 / 1 ``` The longest consecutive sequence path is `2-3`, thus the function should return `2`. # Implementation Define the function `longest_consecutive(root: TreeNode) -> int`. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive(root: TreeNode) -> int: # Your code here ``` **Note**: You need to account for edge cases like an empty tree, a single node tree, and cases where no consecutive path exists. Think about the best way to handle deep trees to avoid potential stack overflow.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive(root: TreeNode) -> int: Returns the length of the longest consecutive sequence path in the binary tree. def dfs(node, parent_val, length): if not node: return length current_length = length + 1 if node.val == parent_val + 1 else 1 left_length = dfs(node.left, node.val, current_length) right_length = dfs(node.right, node.val, current_length) return max(current_length, left_length, right_length) if not root: return 0 return dfs(root, root.val - 1, 0)"},{"question":"# Binary Search Implementation and Variants Scenario You\'re given a sorted array of integers in ascending order. Your task is to implement the Binary Search algorithm to efficiently find the position of a given target value in the array. If the target value is not present, return -1. Additionally, you need to implement a variant of Binary Search that finds the first occurrence of a target value if there are duplicates. This will demonstrate your understanding of modifying classic algorithms to handle specific requirements. Task 1. Write a function `binary_search(array, query)` that finds the position of the `query` in the `array` using an iterative approach. 2. Write a function `binary_search_first_occurrence(array, query)` that finds the first occurrence of the `query` in the `array` using a modified Binary Search. Function Specifications **Function 1**: `binary_search(array, query)` * **Input**: * `array`: List[int] - A sorted array of integers. * `query`: int - The target value to search for. * **Output**: * Index (int) of `query` in `array`, or -1 if not present. **Function 2**: `binary_search_first_occurrence(array, query)` * **Input**: * `array`: List[int] - A sorted array of integers. * `query`: int - The target value to search for. * **Output**: * Index (int) of the first occurrence of `query` in `array`, or -1 if not present. Constraints * The length of the array will be at most (10^5). * The elements in the array will range from (-10^9) to (10^9). * The array is guaranteed to be sorted in ascending order. Performance Requirements * Both functions should have a time complexity of (O(log(n))). Example ``` python binary_search([1, 2, 3, 4, 5], 3) => 2 binary_search([1, 2, 3, 4, 5], 6) => -1 binary_search_first_occurrence([1, 2, 3, 3, 3, 4, 5], 3) => 2 binary_search_first_occurrence([1, 2, 3, 3, 3, 4, 5], 1) => 0 ```","solution":"def binary_search(array, query): This function uses an iterative approach to find the position of the \'query\' within the \'array\'. If the target value is not present, it returns -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1 def binary_search_first_occurrence(array, query): This function uses a modified binary search to find the first occurrence of the \'query\' within the \'array\'. If the target value is not present, it returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # continue searching in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Repeated Substring Pattern Check **Objective**: Write a function that determines whether a given non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together. **Function Signature**: ```python def repeat_substring(s: str) -> bool: pass ``` **Input**: A single non-empty string `s`. **Output**: A boolean value (`True` or `False`): - Return `True` if the string can be constructed by repeating a substring. - Return `False` if it cannot. **Examples**: ```python assert repeat_substring(\\"abab\\") == True assert repeat_substring(\\"aba\\") == False assert repeat_substring(\\"abcabcabcabc\\") == True ``` **Constraints**: - The function should operate within O(n) time complexity, where n is the length of the string. - Consider edge cases like: - Single character strings. - Strings with no repetition. - Long strings with complex repetition patterns. **Scenario**: As a software engineer, you are given a task to validate that the strings used for generating automated test sequences conform to expected repeating patterns. This ensures that any anomaly in the string forming algorithm is caught early and corrected. **Notes**: - Focus on implementing an efficient solution. - Avoid using any auxiliary data structures if possible. **Performance Requirements**: The solution should efficiently handle strings up to the length of 10^4.","solution":"def repeat_substring(s: str) -> bool: Determines if the given string can be constructed by repeating a substring. Parameters: s (str): Input string Returns: bool: True if the string can be constructed by repeating a substring, False otherwise n = len(s) # Loop to check each possible length of the substring for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] # Check if repeating the substring enough times gives the original string if substring * (n // i) == s: return True return False"},{"question":"# Question Given a list of integers, implement the Gnome Sort algorithm to sort the list in non-decreasing order. Your function should be named `gnome_sort`. **Input:** * A list of integers `arr`. **Output:** * A sorted list of integers. Constraints: * 1 <= len(arr) <= 10^4 * -10^6 <= arr[i] <= 10^6, where `arr[i]` is an element of `arr`. Requirements: * Implement the sorting function `gnome_sort`. * The function should return the sorted list. * Your implementation should be efficient enough to handle the given constraints. Example: ```python # Input arr = [34, 2, 10, -9] # Output result = [-9, 2, 10, 34] ``` You are required to implement the function `gnome_sort`, which sorts the list using the Gnome Sort algorithm as described.","solution":"def gnome_sort(arr): Sorts a list of integers in non-decreasing order using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Given an integer `a` and a positive integer `m`, you are required to determine if the modular multiplicative inverse of `a` exists under modulo `m`. If it exists, return the inverse. Otherwise, return -1. Input Format: - A single integer `a` followed by a positive integer `m`. Output Format: - An integer, the modular multiplicative inverse of `a` under modulo `m`, if it exists. - If no modular inverse exists, return -1. Constraints: - `a` can be any integer. - `m` is a positive integer (1 ≤ m ≤ 10^6). Example: - **Input**: ``` 3 11 ``` **Output**: ``` 4 ``` - **Input**: ``` 10 20 ``` **Output**: ``` -1 ``` Note: - For the first example, 3 * 4 % 11 = 1, making 4 the modular multiplicative inverse of 3 modulo 11. - For the second example, there is no integer x such that 10 * x % 20 = 1 since 10 and 20 are not coprime.","solution":"def modular_inverse(a, m): Returns the modular multiplicative inverse of a under modulo m if it exists, otherwise -1. def gcd_extended(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = gcd_extended(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y gcd, x, y = gcd_extended(a, m) if gcd != 1: return -1 else: return x % m"},{"question":"# Preorder Traversal of a Binary Tree **Scenario**: You are given a binary tree data structure. You need to efficiently traverse it in preorder without using the built-in Python functions for tree traversal. This problem tests your understanding of tree traversal and ability to handle edge cases in the implementation. **Function Definition**: Implement the function `preorder_traversal(root)` that takes a single argument: - `root` (Node): The root node of a binary tree. The function should return a list of integers representing the preorder traversal of the tree nodes. **Input**: - The tree is non-empty and can have up to `10^4` nodes. - Node values are unique integers. **Output**: - List of integers in preorder traversal order. **Example**: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert preorder_traversal(root) == [1, 2, 4, 5, 3] ``` **Constraints**: - You must implement both iterative and recursive versions of the traversal. - Consider performance implications for deep trees. - Handle edge cases like an empty tree or skewed trees. **Bonus**: - Include a discussion about which approach you would choose in practice for different tree depths and why.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal_recursive(root): def helper(node): if not node: return [] # Preorder: Node -> Left -> Right return [node.val] + helper(node.left) + helper(node.right) return helper(root) def preorder_traversal_iterative(root): if not root: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) # Push right child first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"# Question **Problem Statement:** Given two strings `s1` and `s2`, write a function `is_rotation(s1: str, s2: str) -> bool` to determine if `s2` is a rotated version of `s1`. A rotated version means that `s2` can be obtained by shifting the characters in `s1` circularly one or more times. **Function Signature:** ```python def is_rotation(s1: str, s2: str) -> bool: ``` **Input:** - `s1`: A string of length N (1 <= N <= 1000) - `s2`: A string of length N **Output:** - Returns `True` if `s2` is a rotated version of `s1`, `False` otherwise. **Constraints:** - Both strings consist of lowercase Latin letters only. **Examples:** ```python assert is_rotation(\\"hello\\", \\"llohe\\") == True assert is_rotation(\\"hello\\", \\"helol\\") == False assert is_rotation(\\"abcde\\", \\"cdeab\\") == True assert is_rotation(\\"abcde\\", \\"abced\\") == False assert is_rotation(\\"\\", \\"\\") == True ``` **Scenario:** In a digital communication system, a sequence of characters is transmitted in a circular buffer. To verify the integrity of the data, the receiving end needs to check if the received string is a rotated version of the original string sent by the transmitter. **Note:** You should handle the case where the input strings are empty, and ensure your solution runs efficiently with the given constraints.","solution":"def is_rotation(s1: str, s2: str) -> bool: Determine if s2 is a rotated version of s1. A rotated version means that s2 can be obtained by shifting the characters in s1 circularly one or more times. Args: s1 (str): The original string. s2 (str): The string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"# Scenario: You\'ve been hired as a developer for a memory-constrained application. The system you\'re working on has very limited write operations allowed, and you need a sorting algorithm that minimizes memory writes. # Task: Write a Python function named `custom_cycle_sort` that behaves similarly to the provided `cycle_sort` function, but includes additional checks to handle arrays containing duplicate items, ensuring the smallest possible number of memory writes. # Function Signature: ```python def custom_cycle_sort(arr: list) -> list: ``` # Input: * **arr (list)**: A list of integers that needs to be sorted. # Output: * **(list)**: The function should return the sorted list. # Constraints: * The input array `arr` will have a length of up to 10^5. * Elements of `arr` will be integers, and can be positive, negative, or zero. # Requirements: 1. Ensure the array is sorted with the minimum number of write operations. 2. Handle arrays with duplicate items properly. 3. Maintain the functional in-place nature (no use of extra significant memory). # Example: ```python # Example 1: input_arr = [4, 3, 2, 1] sorted_arr = custom_cycle_sort(input_arr) print(sorted_arr) # Output: [1, 2, 3, 4] # Example 2: input_arr = [4, 2, 2, 8, 3, 3, 1] sorted_arr = custom_cycle_sort(input_arr) print(sorted_arr) # Output: [1, 2, 2, 3, 3, 4, 8] ``` Remember, the primary goal is to ensure correctness while minimizing memory writes.","solution":"def custom_cycle_sort(arr: list) -> list: Sorts the given list using Cycle Sort which minimizes memory writes. writes = 0 for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 if pos == cycleStart: continue while item == arr[pos]: pos += 1 if pos != cycleStart: arr[pos], item = item, arr[pos] writes += 1 while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"You are tasked with verifying the validity of a sequence of parentheses in a given expression. The expression contains only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Your goal is to implement a function `check_parentheses_validity(expression: str) -> bool` which returns `True` if the parentheses in the input string are valid and `False` otherwise. A valid expression is defined as: 1. Opening brackets must be closed by the same type of brackets. 2. Opening brackets must be closed in the correct order. 3. Every closing bracket must have a corresponding opening bracket of the same type. Input - `expression: str` - A string containing only characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. The length of the string does not exceed 10^4. Output - A boolean value: `True` if the expression is valid, `False` otherwise. Constraints 1. The input string will only contain the characters mentioned and no other types. 2. You must ensure that the solution is efficient and can handle the upper limit of string length within reasonable time. Example Scenarios 1. **Example 1**: - Input: expression = \\"()[]{}\\" - Output: `True` - Explanation: The input string contains all bracket types in correctly matched pairs. 2. **Example 2**: - Input: expression = \\"(]\\" - Output: `False` - Explanation: The input string has mismatched brackets. 3. **Example 3**: - Input: expression = \\"([)]\\" - Output: `False` - Explanation: Despite having an equal number of opening and closing brackets, the order is incorrect. 4. **Example 4**: - Input: expression = \\"{[]}\\" - Output: `True` - Explanation: The expression has nested brackets correctly matched. Performance Requirements Make sure your solution runs in O(n) time complexity and uses O(n) space complexity.","solution":"def check_parentheses_validity(expression: str) -> bool: Returns True if the parentheses in the input string are valid, otherwise False. # Stack to keep track of opening brackets stack = [] # Matching pairs dictionary matching_pairs = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in matching_pairs.values(): # It\'s an opening bracket, push to stack stack.append(char) elif char in matching_pairs.keys(): # It\'s a closing bracket, check for matching with top of stack if stack and stack[-1] == matching_pairs[char]: stack.pop() else: return False # Stack should be empty if all brackets matched properly return len(stack) == 0"},{"question":"# Scenario You have been hired by a large organization to assist in processing significant amounts of data related to their inventory system. A crucial part of this system is determining optimal batch sizes for manufacturing. To achieve this, you need to compute the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of product quantities. These computations need to be optimum due to large data size and need operations to be efficient. Additionally, the system makes extensive use of binary representations to store data, and you will frequently need to determine the number of trailing zeros in these binary representations. # Task **Part 1:** Write a function `gcd_optimal(a, b)` that computes the GCD of two non-negative integers using bitwise operations. **Part 2:** Write a function `lcm_using_gcd(a, b)` that computes the LCM of two non-negative integers by using the GCD calculated from `gcd_optimal`. **Part 3:** Write a function `trailing_zero_bits(x)` that computes the number of trailing zero bits in the binary representation of a positive integer. # Input and Output Formats * **Input:** - `gcd_optimal(a, b)`: Two non-negative integers `a` and `b` (0 <= a, b <= 10^9). - `lcm_using_gcd(a, b)`: Two non-negative integers `a` and `b` (0 <= a, b <= 10^9). - `trailing_zero_bits(x)`: A positive integer `x` (1 <= x <= 10^9). * **Output:** - `gcd_optimal(a, b)`: An integer representing the GCD of `a` and `b`. - `lcm_using_gcd(a, b)`: An integer representing the LCM of `a` and `b`. - `trailing_zero_bits(x)`: An integer representing the number of trailing zero bits in the binary representation of `x`. # Constraints * Ensure that your functions handle and return reasonable outputs for edge cases such as zero inputs or very large numbers. * Optimize for performance considering the upper limit of input size. # Example ```python # Example input and output for gcd_optimal function print(gcd_optimal(48, 18)) # Output: 6 # Example input and output for lcm_using_gcd function print(lcm_using_gcd(48, 18)) # Output: 144 # Example input and output for trailing_zero_bits function print(trailing_zero_bits(40)) # Output: 3 ``` Your solution should correctly implement these functions considering the constraints and performance requirements mentioned. Good luck!","solution":"def gcd_optimal(a, b): Computes the GCD of two non-negative integers using bitwise operations. if a == 0: return b if b == 0: return a # Both a and b are even if (a & 1) == 0 and (b & 1) == 0: return gcd_optimal(a >> 1, b >> 1) << 1 # a is even, b is odd if (a & 1) == 0: return gcd_optimal(a >> 1, b) # a is odd, b is even if (b & 1) == 0: return gcd_optimal(a, b >> 1) # Both a and b are odd, a >= b if a >= b: return gcd_optimal((a - b) >> 1, b) # Both a and b are odd, b > a return gcd_optimal((b - a) >> 1, a) def lcm_using_gcd(a, b): Computes the LCM of two non-negative integers using the GCD calculated from gcd_optimal. if a == 0 or b == 0: return 0 return (a * b) // gcd_optimal(a, b) def trailing_zero_bits(x): Computes the number of trailing zero bits in the binary representation of a positive integer. count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count"},{"question":"# AVL Tree Implementation Challenge In order to assess your understanding of self-balancing binary search trees, you are required to implement additional functionalities for an AVL Tree class. Your task is to enhance the AVL Tree class with the following additional features: 1. **Deletion of Keys**: Implement a `delete(key)` method to remove a specified key from the AVL tree while maintaining its balance. 2. **Level-Order Traversal**: Implement a `level_order_traverse()` method that returns a list of keys in level-order (breadth-first) traversal of the AVL tree. # Function Specifications Function 1: `delete(self, key)` - **Input**: `self` (the AVL Tree instance) and `key` (integer to be deleted). - **Output**: None (the tree is modified in place). - **Constraint**: If the key does not exist in the tree, the method should return without modifying the tree. - **Performance Requirement**: O(log n) average time complexity. Function 2: `level_order_traverse(self)` - **Input**: `self` (the AVL Tree instance). - **Output**: List of integer keys representing the level-order traversal of the tree. - **Performance Requirement**: The method should run efficiently for large tree sizes (O(n) time complexity). # Example Usage ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(6) print(avl.level_order_traverse()) # Output: [10, 5, 20, 6] avl.delete(5) print(avl.level_order_traverse()) # Output: [10, 6, 20] ``` # Edge Cases to Consider - Deleting a key not present in the tree. - Deleting the root node. - Tree with a single node. - Balanced and unbalanced states of the tree. Remember to maintain the AVL tree characteristics throughout your implementation. Ensure all heights and balance factors are correctly updated after each insertion and deletion.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): if not root: return Node(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def level_order_traverse(self, root): levels = [] if root is None: return levels queue = [root] while queue: current_level = [] next_queue = [] for node in queue: current_level.append(node.key) if node.left: next_queue.append(node.left) if node.right: next_queue.append(node.right) levels.extend(current_level) queue = next_queue return levels def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_min_value_node(self, root): if root is None or root.left is None: return root return self.get_min_value_node(root.left) def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right)"},{"question":"Problem Statement You are given a binary tree where each node contains an integer value. Your task is to determine if this tree satisfies the properties of a Binary Search Tree (BST). For a tree to be considered a BST, it must satisfy the following conditions: 1. The left subtree of any node contains only nodes with keys smaller than the node\'s key. 2. The right subtree of any node contains only nodes with keys greater than the node\'s key. 3. Both the left and right subtrees must also be binary search trees. Write a function `is_bst(root)` that takes the root of a binary tree and returns `True` if the tree is a valid BST, and `False` otherwise. # Input - The input is the root node of a binary tree. # Output - The function should return a boolean value `True` or `False`. # Constraints - The number of nodes in the tree is between `0` and `10^4`. - Each node\'s value is an integer within the range of `[-10^4, 10^4]`. # Example 1: Input: ``` 2 / 1 3 ``` Output: ``` True ``` # Example 2: Input: ``` 2 / 2 3 ``` Output: ``` False ``` # Example 3: Input: ``` 5 / 1 4 / 3 6 ``` Output: ``` False ``` **Explanation**: - In example 2, the left child of the root has a value equal to the root, violating the BST property. - In example 3, the right subtree of the root contains a node with a value less than the root\'s value. The function should consider edge cases such as: - An empty tree. - Very large trees. - Trees with duplicate values. Use an iterative approach to traverse the tree in an in-order manner and utilize auxiliary structures as needed. Ensure input validation and handle typical edge cases. Aim for an optimized solution in terms of time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst_helper(node, lower=float(\'-inf\'), upper=float(\'inf\')): if not node: return True val = node.val if val <= lower or val >= upper: return False if not is_bst_helper(node.right, val, upper): return False if not is_bst_helper(node.left, lower, val): return False return True def is_bst(root): return is_bst_helper(root)"},{"question":"**Background**: You are creating a new search feature for a text editor. As a part of this feature, you need to implement a function that searches for a specific substring in a given text. This basic substring search is crucial for providing functionalities such as \\"find and replace.\\" **Objective**: Implement a function that returns the index of the first occurrence of the substring (needle) in the main string (haystack) or -1 if the substring is not found. This function should efficiently handle edge cases and provide accurate results. # Function Signature ```python def strStr(haystack: str, needle: str) -> int: ``` # Input - `haystack` (str): The main string where the search is carried out. It can be of length 0 to 10^5. - `needle` (str): The substring to search for. It can also be of length 0 to 10^3. # Output - An integer: The index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints 1. If `needle` is an empty string, return 0 as it is a trivial case. 2. If `needle` is longer than `haystack`, return -1 as it cannot be a substring. # Performance Requirements - Must handle input strings of considerable lengths efficiently. - Aim for clear and maintainable code. # Example ```python haystack = \\"hello\\" needle = \\"ll\\" Output: 2 haystack = \\"aaaaa\\" needle = \\"bba\\" Output: -1 haystack = \\"\\" needle = \\"\\" Output: 0 haystack = \\"abc\\" needle = \\"\\" Output: 0 haystack = \\"abc\\" needle = \\"d\\" Output: -1 ``` # Extra Challenge For those looking for an extra challenge, implement an optimized version using the Knuth-Morris-Pratt (KMP) algorithm, which improves time complexity to O(N+M).","solution":"def strStr(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. # Edge case when needle is an empty string if not needle: return 0 # Lengths of haystack and needle len_haystack = len(haystack) len_needle = len(needle) # If needle is longer than haystack, it cannot be a substring if len_needle > len_haystack: return -1 # Iterate through haystack to find the first occurrence of needle for i in range(len_haystack - len_needle + 1): if haystack[i:i + len_needle] == needle: return i return -1"},{"question":"# Question: Counting Set Bits in an Unsigned Integer Context: In computer science, Bitwise operations and manipulation form a core part of efficient algorithm design, particularly in scenarios involving low-level data processing, cryptography, and error detection/correction. One common operation is to count the number of set bits (or \'1\' bits) in the binary representation of a number, a task widely known as computing the Hamming weight. Objective: You are to write a function that takes an unsigned integer and returns the count of \'1\' bits in its binary representation using an efficient algorithm. Requirements: * Implement two functions to achieve this, one using a recursive approach and another using an iterative approach based on Brian Kernighan\'s Algorithm. ```python def count_ones_recur(n: int) -> int: Using Brian Kernighan\'s Algorithm (Recursive Approach). Parameters: n (int): An unsigned integer Returns: int: The number of \'1\' bits in the binary representation of the input number pass def count_ones_iter(n: int) -> int: Using Brian Kernighan\'s Algorithm (Iterative Approach). Parameters: n (int): An unsigned integer Returns: int: The number of \'1\' bits in the binary representation of the input number pass ``` Input: * An unsigned integer `n` where `0 <= n <= 2^32 - 1`. Output: * An integer representing the number of \'1\' bits in the binary representation of `n`. Performance Requirements: The algorithm should perform the counting efficiently with a time complexity of O(k), where k is the number of \'1\' bits present in the binary representation of the number. Constraints: 1. You should not use any built-in functions that directly perform the population count/task. 2. Consider edge cases like the minimum value (0) and maximum value within the range. Example: ```python # Example 1: # Input: n = 11 # Binary Representation: 00000000000000000000000000001011 # Output: 3 # Example 2: # Input: n = 128 # Binary Representation: 00000000000000000000000010000000 # Output: 1 print(count_ones_iter(11)) # Output: 3 print(count_ones_recur(128)) # Output: 1 ```","solution":"def count_ones_recur(n: int) -> int: Using Brian Kernighan\'s Algorithm (Recursive Approach). Parameters: n (int): An unsigned integer Returns: int: The number of \'1\' bits in the binary representation of the input number if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Using Brian Kernighan\'s Algorithm (Iterative Approach). Parameters: n (int): An unsigned integer Returns: int: The number of \'1\' bits in the binary representation of the input number count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Linked List manipulation algorithms for removing duplicates. * **Complexity**: * `remove_dups`: Time Complexity O(N), Space Complexity O(N) due to additional set storage. * `remove_dups_without_set`: Time Complexity O(N^2), Space Complexity O(1) with no additional storage. * **Principles**: * `remove_dups`: Utilizes a set to track seen values for O(1) average time complexity checks. * `remove_dups_without_set`: Uses a runner pointer for nested iteration to compare each element to all subsequent elements. # Characteristics & Applications * **Properties**: * Detects and removes duplicate nodes in a singly linked list. * Traverses nodes in a straightforward sequential manner. * **Common Use Cases**: * Cleaning up linked lists for unique data sets. * Ensuring data integrity by removing redundancies in sequential collections. * **Strengths/Limitations**: * `remove_dups`: Fast with additional space for seen values. * `remove_dups_without_set`: Inefficient for very large lists due to nested iterations but saves space. # Implementation Challenges * **Edge Cases**: * Empty linked lists. * Lists where all elements are duplicates. * Lists with no duplicates. * **Performance Bottlenecks**: * `remove_dups_without_set`: Nested loops can slow down significantly with the increase in list size. * **Error Scenarios**: * Handling pointers correctly to avoid broken links or infinite loops. * Ensuring the list remains properly linked after deletions. * **Optimization Points**: * Using additional data structures like hash sets or hash maps to improve time complexity in `remove_dups_without_set`. <|Analysis End|> <|Question Begin|> # Coding Task: Removing Duplicates from a Linked List You are required to implement functions to remove duplicate values from a singly linked list. Objective: - Implement the function `remove_dups` to remove duplicates efficiently using additional space. - Implement the function `remove_dups_without_set` without using extra space. Input: - A singly linked list head node object (e.g., `Node(\\"A\\")`). Output: - The modified linked list with all duplicate values removed. The linked list should preserve the original order of nodes (first occurrence of each value). # Example Usage ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Sample linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Removing duplicates using additional space remove_dups(a1) print_linked_list(a1) # Expected output: A -> B -> C -> D -> F -> G # Removing duplicates without using additional space remove_dups_without_set(a1) print_linked_list(a1) # Expected output: Should be the same as remove_dups. ``` Constraints: - Assume each node\'s value is a non-null string. - The list can potentially be very large. uleiro","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Removes duplicates from the linked list using a set to track seen values. Arguments: head -- the head node of the linked list Returns: None (modifies the linked list in place) if not head: return current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head): Removes duplicates from the linked list without using additional space. Arguments: head -- the head node of the linked list Returns: None (modifies the linked list in place) current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Huffman Coding Assessment Context Huffman coding is a widely used algorithm for lossless data compression. The algorithm relies on the frequency of symbols to create an optimal binary tree where frequently occurring symbols have shorter codes. Your task is to implement a part of the Huffman coding algorithm: encoding and decoding text data. Objectives 1. Implement functions to count the frequency of characters in the input data. 2. Build the Huffman tree based on character frequencies. 3. Generate the Huffman codes for each character by traversing the tree. 4. Encode the data using the generated Huffman codes. 5. Decode the encoded data using the Huffman tree. Function Specifications 1. `build_frequency_table(data: str) -> dict`: Given a string of input data, return a dictionary with the frequency of each character. 2. `build_huffman_tree(frequency_table: dict) -> Node`: Given a frequency table, return the root of the Huffman tree. 3. `generate_huffman_codes(tree: Node) -> dict`: Given the root of a Huffman tree, return a dictionary where keys are characters and values are their corresponding Huffman codes. 4. `encode_data(data: str, huffman_codes: dict) -> str`: Given the input data and Huffman codes, return the encoded string. 5. `decode_data(encoded_data: str, tree: Node) -> str`: Given the encoded string and the Huffman tree, return the original decoded string. Constraints - Assume input data will only contain ASCII characters. - The input data will be non-empty. Example ```python input_data = \\"this is an example for huffman encoding\\" # Step 1: Build Frequency Table freq_table = build_frequency_table(input_data) # Step 2: Build Huffman Tree huffman_tree = build_huffman_tree(freq_table) # Step 3: Generate Huffman Codes huffman_codes = generate_huffman_codes(huffman_tree) # Step 4: Encode Data encoded_data = encode_data(input_data, huffman_codes) # Step 5: Decode Data decoded_data = decode_data(encoded_data, huffman_tree) assert decoded_data == input_data # The decoded data should match the input data ``` Notes - You may define additional helper functions if necessary. - Pay attention to edge cases such as data with single unique characters or repetitive sequences. - Ensure that your implementation is efficient in terms of both time and space complexity.","solution":"class Node: def __init__(self, char: str = None, freq: int = 0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq import heapq def build_frequency_table(data: str) -> dict: freq_table = {} for char in data: if char in freq_table: freq_table[char] += 1 else: freq_table[char] = 1 return freq_table def build_huffman_tree(frequency_table: dict) -> Node: heap = [Node(char, freq) for char, freq in frequency_table.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(freq=left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(heap, merged) return heap[0] def generate_huffman_codes(tree: Node) -> dict: codes = {} def generate_codes_helper(node, current_code): if node is None: return if node.char is not None: codes[node.char] = current_code generate_codes_helper(node.left, current_code + \\"0\\") generate_codes_helper(node.right, current_code + \\"1\\") generate_codes_helper(tree, \\"\\") return codes def encode_data(data: str, huffman_codes: dict) -> str: encoded_data = \\"\\" for char in data: encoded_data += huffman_codes[char] return encoded_data def decode_data(encoded_data: str, tree: Node) -> str: decoded_data = \\"\\" current_node = tree for bit in encoded_data: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.left is None and current_node.right is None: decoded_data += current_node.char current_node = tree return decoded_data"},{"question":"Reverse Each Word in a Sentence Individually **Context:** You are tasked with writing a function that will reverse each word in an input sentence individually while keeping the original word order intact. This type of text manipulation can be useful in various domains, including cryptography, text processing, and natural language processing. **Problem Description:** Write a function `reverse_individual_words(sentence: str) -> str` that takes a string as input and returns a new string where each word in the original string is reversed, but the order of words remains the same. For example: * Input: \\"I am keon kim and I like pizza\\" * Output: \\"I ma noek mik dna I ekil azzip\\" **Function Signature:** ```python def reverse_individual_words(sentence: str) -> str: pass ``` # Input Format: * The input is a single string containing words separated by spaces. * You can assume that the input will not have leading or trailing spaces. # Output Format: * The output should be a single string with each word reversed but the word order unchanged. # Constraints: * The input string can have words with varying lengths. * The total length of the input string should not exceed 10,000 characters. * The input string will contain only printable ASCII characters. # Performance Requirements: * The solution should aim for O(n) time complexity, where n is the number of characters in the input string. * The space complexity should be minimized where possible, ideally O(n). # Example: ```python print(reverse_individual_words(\\"I am keon kim and I like pizza\\")) # Output: \\"I ma noek mik dna I ekil azzip\\" ``` # Tips: * Consider splitting the string based on spaces to isolate individual words. * Use efficient string manipulation techniques to achieve the desired outcome.","solution":"def reverse_individual_words(sentence: str) -> str: Reverses each word in the input sentence individually while keeping the original word order intact. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The sentence with each word reversed keeping the word order same. # Split the sentence into words words = sentence.split(\\" \\") # Reverse each word and join them with a space reversed_words = [word[::-1] for word in words] # Join the reversed words with a space to form the resultant sentence return \\" \\".join(reversed_words)"},{"question":"# Permutation Task Given a collection of distinct numbers, write a function that returns all possible permutations of those numbers. Your implementation should explore all unique configurations and return them as a list of lists. Requirements: * **Function Signature**: ```python def generate_permutations(nums: List[int]) -> List[List[int]]: ``` * **Input**: - A list of distinct integers, `nums` (1 ≤ len(nums) ≤ 7). * **Output**: - A list of lists, where each inner list is a distinct permutation of `nums`. * **Constraints**: - The input set will always contain distinct integers. - The length of the set will not exceed 7 to manage time complexity. * **Performance Requirements**: - The solution should efficiently handle all permutations for up to 7 distinct numbers, given the constraints. Example: ```python assert generate_permutations([1,2,3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([0, 1]) == [ [0, 1], [1, 0] ] assert generate_permutations([1]) == [ [1] ] ``` Context: You are a software engineer developing a testing framework that requires generating all possible test cases for a given configuration. One essential utility you need to develop is a function to generate all possible permutations of a list of test setup parameters. Write a robust implementation to achieve this that can be easily integrated into your framework!","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generates all possible permutations of a list of distinct integers. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all permutations of the input list. res = [] def backtrack(path, options): if not options: res.append(path) for i in range(len(options)): backtrack(path + [options[i]], options[:i] + options[i+1:]) backtrack([], nums) return res"},{"question":"# Question **Context**: You are managing a collection of resources that need to cover all required tasks. Each resource covers a subset of tasks and has an associated cost. Your goal is to minimize the total cost while ensuring all tasks are covered. # Problem Implement a function `approx_set_cover` that takes the following inputs: * `universe` (List[int]): The list of tasks to be covered. * `subsets` (Dict[str, Set[int]]): A dictionary where each key is a subset name and each value is a set containing the tasks that subset covers. * `costs` (Dict[str, int]): A dictionary where each key is a subset name and each value is the cost associated with that subset. Your task is to find an approximate minimum cost subcollection of subsets that covers all elements of the `universe`. # Constraints * Every element in the universe must be unique. * Subsets must have unique names. * Costs must be positive integers. # Input ```python universe = [1, 2, 3, 4, 5] subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} ``` # Output ```python approx_set_cover(universe, subsets, costs) => [\'S2\', \'S3\'] ``` # Function Signature ```python def approx_set_cover(universe: List[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: ``` # Performance Requirements Your solution should aim to run in polynomial time, ideally O(n*m), where n is the number of tasks in the universe, and m is the number of subsets. # Example **Input**: ```python universe = [1, 2, 3, 4, 5, 6, 7, 8] subsets = { \'A\': {1, 4, 5}, \'B\': {2, 3, 6}, \'C\': {7}, \'D\': {8, 5, 6}, } costs = {\'A\': 4, \'B\': 7, \'C\': 3, \'D\': 6} ``` **Output**: ```python approx_set_cover(universe, subsets, costs) => [\'A\', \'B\', \'C\', \'D\'] ```","solution":"from typing import List, Dict, Set def approx_set_cover(universe: List[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: covered = set() result = [] while covered != set(universe): best_subset = None min_cost_per_new_element = float(\'inf\') for subset, elements in subsets.items(): new_elements = elements - covered if new_elements: cost_per_new_element = costs[subset] / len(new_elements) if cost_per_new_element < min_cost_per_new_element: min_cost_per_new_element = cost_per_new_element best_subset = subset if best_subset: covered.update(subsets[best_subset]) result.append(best_subset) return result"},{"question":"# Scenario You are developing a software library that includes functions for performing various mathematical computations. Leveraging your understanding of algorithms and bitwise operations, you need to implement an optimized function to calculate the greatest common divisor (GCD) of a list of integers using the provided bitwise GCD method. # Task Write a function `list_gcd_bitwise` that calculates the GCD for a list of non-negative integers using the provided `gcd_bit` function. # Function Signature ```python def list_gcd_bitwise(numbers: list) -> int: Given a list of non-negative integers, return their greatest common divisor using the bitwise method. Parameters ---------- numbers : list of int A list containing non-negative integers. Returns ------- int The greatest common divisor of the list of numbers. ``` # Input * A list of non-negative integers `[a1, a2, a3, ..., an]` where `1 <= n <= 10^4` and `0 <= ai <= 10^6`. # Output * The GCD of the list of numbers. # Example ```plaintext Input: list_gcd_bitwise([24, 36, 60]) Output: 12 Input: list_gcd_bitwise([16, 32, 96]) Output: 16 Input: list_gcd_bitwise([7, 14, 21]) Output: 7 ``` # Constraints * Ensure your solution can handle large lists up to the given constraints efficiently. * Consider edge cases such as when the list contains a zero. # Notes * You can use the provided `gcd_bit` function within your solution. * Ensure to handle all necessary validations and constraints properly within your implementation.","solution":"def gcd_bit(a, b): # Base cases for the bitwise GCD algorithm if a == 0: return b if b == 0: return a # Finding common factors of 2 if a == b: return a if a == 1 or b == 1: return 1 # Reducing both a and b while both are even if ~a & 1: # a is even if ~b & 1: # b is even return gcd_bit(a >> 1, b >> 1) << 1 else: return gcd_bit(a >> 1, b) if ~b & 1: # b is even and a is odd return gcd_bit(a, b >> 1) # Reduce larger argument if a > b: return gcd_bit((a - b) >> 1, b) return gcd_bit((b - a) >> 1, a) def list_gcd_bitwise(numbers): Given a list of non-negative integers, return their greatest common divisor using the bitwise method. if not numbers: # In case the list is empty return 0 gcd_result = numbers[0] for number in numbers[1:]: gcd_result = gcd_bit(gcd_result, number) if gcd_result == 1: # Early termination if gcd becomes 1 break return gcd_result"},{"question":"**Scenario:** You are working on an inventory management system that handles a large amount of product data. Each product has a unique integer ID. To efficiently sort the product IDs for better access and retrieval, you decided to implement a radix sort. # Task: **Function to implement:** Implement the function `radix_sort(arr: List[int], simulation: bool=False) -> List[int]` that sorts a given list of non-negative integers using the radix sort algorithm. **Input:** * `arr`: A list of non-negative integer IDs (0 ≤ ID ≤ 1,000,000) * `simulation`: A boolean flag which, if set to `True`, will print the state of the list after each digit-level sorting for debugging purposes. **Output:** * A list of integers sorted in ascending order. **Constraints:** * The list `arr` can be empty. * All integers in the list are non-negative. * The maximum integer value can be up to 1,000,000. * Space is a consideration but ensure the implementation is stable. **Performance Requirement:** * Ensure the solution runs efficiently with a time complexity of O(nk), where n is the size of the list and k is the digit length of the largest number. **Example:** ```python >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : 2 24 45 66 75 170 802 90 iteration 3 : 2 24 45 66 75 90 170 802 >>> radix_sort([432, 8, 530, 90, 88, 231, 11, 45, 677, 199], True) iteration 0 : 432 8 530 90 88 231 11 45 677 199 iteration 1 : 11 231 432 530 8 677 88 90 45 199 iteration 2 : 8 11 45 88 90 199 231 432 530 677 iteration 3 : 8 11 45 88 90 199 231 432 530 677 ``` **Note:** Implement the function without using any built-in sort functions. Clearly comment your code to elucidate each step of the algorithm.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool=False) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] now contains the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[] so that arr now contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: # Get the maximum number to know the number of digits if len(arr) == 0: return [] max1 = max(arr) # Apply counting sort to sort elements based on place value exp = 1 iteration = 0 while max1 // exp > 0: counting_sort(arr, exp, simulation) if simulation: print(f\'iteration {iteration} : {\\" \\".join(map(str, arr))}\') exp *= 10 iteration += 1 return arr"},{"question":"# Scenario You are working on a project to analyze and visualize data stored in a binary search tree (BST). A common requirement is to iterate through the data in sorted order without using excessive memory. To achieve this, you need to implement an iterator that allows in-order traversal of the BST. # Task Write a class `BSTIterator` which allows iterations over a given BST in in-order fashion. You should implement two primary methods: - `has_next()`: Returns a boolean indicating whether there is a next smallest number in the BST. - `next()`: Returns the next smallest number in the BST. # Input Format - The initialization of the BSTIterator will be done with a reference to the root of the BST (`root`). The structure of the BST node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `has_next()` and `next()` do not take any parameters besides the implicit `self`. # Output Format - `has_next()`: Should return `True` if there is a next smallest number in the BST, `False` otherwise. - `next()`: Should return the next smallest number in the BST. # Constraints - The number of nodes in the BST is in the range `[1, 1000000]`. - `-1000000 <= Node.val <= 1000000` - All Node values are unique. - The iterator should run efficiently with both time and space complexity considerations. Aim for O(h) space complexity where h is the height of the tree. # Example ```python # Example Binary Search Tree # 7 # / # 3 15 # / # 9 20 # Initialization root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) print(iterator.has_next()) # --> True print(iterator.next()) # --> 3 print(iterator.has_next()) # --> True print(iterator.next()) # --> 7 print(iterator.has_next()) # --> True print(iterator.next()) # --> 9 print(iterator.has_next()) # --> True print(iterator.next()) # --> 15 print(iterator.has_next()) # --> True print(iterator.next()) # --> 20 print(iterator.has_next()) # --> False ``` # Note - Ensure to handle edge cases such as an empty tree and a tree with only one node properly. - You must implement the `BSTIterator` class and the methods `has_next` and `next` efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Ternary Search vs Binary Search: Performance Comparison Objective Implement a function to perform ternary search and compare its performance with binary search on large sorted arrays. Your task is to write effective search functions for both algorithms and determine which is faster for various array sizes. Instructions 1. **Ternary Search Function**: You will implement a `ternary_search` function as described in the analysis section. 2. **Binary Search Function**: You will also implement a `binary_search` function for comparison. 3. **Performance Measurement**: * Create large sorted arrays with varying sizes (e.g., 10^3, 10^4, 10^5, 10^6). * Measure and print the time taken by each search function to find elements in different arrays. * Ensure the functions are valid and return correct indices or -1 if the element is not found. Function Signatures ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass def binary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass def compare_search_performance(): pass ``` Expected Inputs and Outputs * For `ternary_search` and `binary_search` functions: * **Input**: [left, right, key, arr] - `left` (int): The left index of the search range. - `right` (int): The right index of the search range. - `key` (int): The value to search for. - `arr` (List[int]): The sorted array. * **Output**: Index (int) of the key if found in the array, -1 otherwise. * For `compare_search_performance` function: * **Output**: Print comparison results showing time taken for each algorithm on arrays of different sizes. Constraints * All arrays given are sorted in non-decreasing order. * Array sizes will be within reasonable limits as specified in the performance measurement task. * Ensure functions handle edge cases effectively. Scenario Sally is a software engineer who often needs to search for bug identifiers in sorted logs. She\'s interested in knowing whether ternary search is faster than binary search for her logs that grow in size over time. Help Sally understand which algorithm she should prefer based on various log sizes. Performance Notes * Ensure to use efficient libraries such as `time` for measuring execution time. * Test with predetermined random values as keys present and not present in the arrays.","solution":"from typing import List import time def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: if right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(left, mid1 - 1, key, arr) elif key > arr[mid2]: return ternary_search(mid2 + 1, right, key, arr) else: return ternary_search(mid1 + 1, mid2 - 1, key, arr) return -1 def binary_search(left: int, right: int, key: int, arr: List[int]) -> int: while left <= right: mid = left + (right - left) // 2 if arr[mid] == key: return mid elif arr[mid] < key: left = mid + 1 else: right = mid - 1 return -1 def compare_search_performance(): import random sizes = [10**3, 10**4, 10**5, 10**6] search_results = {} for size in sizes: arr = sorted(random.sample(range(1, 10**7), size)) key = random.choice(arr) start_time = time.time() ternary_search(0, size - 1, key, arr) ternary_time = time.time() - start_time start_time = time.time() binary_search(0, size - 1, key, arr) binary_time = time.time() - start_time search_results[size] = { \\"ternary_time\\": ternary_time, \\"binary_time\\": binary_time } print(f\\"{\'Array Size\':<10} {\'Ternary Time (s)\':<20} {\'Binary Time (s)\':<20}\\") for size in sizes: print(f\\"{size:<10} {search_results[size][\'ternary_time\']:<20} {search_results[size][\'binary_time\']:<20}\\") compare_search_performance()"},{"question":"# Invert a Matrix **Context**: You are asked to implement a function to invert a matrix using the detailed steps provided by the algorithm. The process involves calculating the matrix of minors, creating the cofactor matrix, adjugating it, and finally scaling by the inverse of the original matrix\'s determinant. This method requires careful handling of the matrix operations to ensure accurate computations. # Task **Objective**: Write a function `invert_matrix(m)` that takes an n x n matrix `m` and returns its inverse. If the matrix is non-invertible, your function should return an appropriate error code. # Requirements - The input `m` will be a list of lists representing an n x n matrix. - If the matrix is not invertible (singular matrix, determinant = 0) or not square, your function should return an error code as a matrix with one element, i.e., `[[error_code]]`. - Your implementation should handle edge cases such as non-square matrices and small matrices (e.g., 0x0 and 1x1). # Error Codes - `[-1]`: The array is not a matrix - `[-2]`: The matrix is not square - `[-3]`: The matrix is too small (0x0, 1x1) - `[-4]`: The matrix is singular (determinant = 0) # Function Signature ```python def invert_matrix(m): pass ``` # Constraints - The matrix can have integer or floating point numbers. - The input matrix will have at least 0 rows and columns and at most 20 rows and columns. # Input - `m`: List of lists representing an n x n matrix. # Output - An inverted matrix of the same dimensions if the matrix is invertible, otherwise a matrix with one element `[[error_code]]`. # Examples ```python # Example 1 m = [ [4, 7], [2, 6] ] print(invert_matrix(m)) # Output: [[0.6, -0.7], [-0.2, 0.4]] # Example 2 m = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] print(invert_matrix(m)) # Output: [[-24, 18, 5], [20, -15, -4], [-5, 4, 1]] # Example 3 m = [ [1, 2], [2, 4] ] print(invert_matrix(m)) # Output: [[-4]] (Determinant is 0, hence singular matrix) # Example 4 m = [ [1, 2] ] print(invert_matrix(m)) # Output: [[-2]] (Not a square matrix) # Example 5 m = [] print(invert_matrix(m)) # Output: [[-1]] (Array is not a matrix) ``` **Notes**: - Utilize helper functions to modularize the determinant calculation and matrix manipulations. - Consider using recursion efficiently to minimize redundant computations. Implement the function ensuring it adheres to the provided constraints and handles all outlined edge cases.","solution":"def invert_matrix(m): def is_square(matrix): return all(len(row) == len(matrix) for row in matrix) def determinant(matrix): n = len(matrix) if n == 1: return matrix[0][0] elif n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(n): sub_matrix = [[matrix[r][cc] for cc in range(n) if cc != c] for r in range(1, n)] det += ((-1) ** c) * matrix[0][c] * determinant(sub_matrix) return det def minor(matrix, i, j): return [[matrix[ii][jj] for jj in range(len(matrix)) if jj != j] for ii in range(len(matrix)) if ii != i] if not m: return [[-1]] if not is_square(m): return [[-2]] n = len(m) if n == 0 or n == 1: return [[-3]] if any(len(row) != n for row in m): return [[-2]] det = determinant(m) if det == 0: return [[-4]] minors_matrix = [[determinant(minor(m, i, j)) for j in range(n)] for i in range(n)] cofactors_matrix = [[(-1)**(i+j) * minors_matrix[i][j] for j in range(n)] for i in range(n)] adjugate_matrix = [[cofactors_matrix[j][i] for j in range(n)] for i in range(n)] inverse_matrix = [[adjugate_matrix[i][j] / det for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"# Background You work at a software company, and your team is developing a system that should efficiently handle massive datasets. One of the tasks you have is to identify a unique transaction ID among millions, where every other transaction ID appears exactly three times. # Problem Given an array of integers, where every integer appears exactly three times except one integer which appears exactly once, write a function `find_unique_element(nums)` to find and return the integer that appears only once. # Requirements - **Function Signature**: `def find_unique_element(nums: List[int]) -> int:` - **Input**: A list of integers `nums` where the list follows the constraint described above. - **Output**: Return the single integer that appears only once. - **Constraints**: - The length of the list `nums` will be in the range [1, (10^6)]. - You should aim for O(n) time complexity. - Memory usage should be O(1), i.e., you cannot use extra space for another array or list. # Example ```python >>> find_unique_element([2, 2, 3, 2]) 3 >>> find_unique_element([0, 1, 0, 1, 0, 1, 99]) 99 >>> find_unique_element([-2, -2, -3, -2]) -3 ``` # Evaluation Criteria Your solution will be evaluated based on: 1. Correctness: The function must return the correct unique element for all possible test cases within constraints. 2. Efficiency: The function should execute within time and space constraints. 3. Code Quality: Code readability and following best practices are important.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: # `ones & num` gives bits that are there in both `ones` and new element from `nums` # We add these bits to `twos` using bitwise OR twos |= ones & num # XOR the new bits obtained in current iteration with `ones` ones ^= num # Bits that appear third time will get removed from both `ones` and `twos` common_mask = ~(ones & twos) ones &= common_mask twos &= common_mask return ones"},{"question":"**Problem Statement: Word Search with Optimization** You are given a 2D board of characters and a list of words. Your task is to implement a function that returns a list of words that can be constructed from the characters on the board by moving up, down, left, or right. Each character must be used at most once per word. **Function Signature:** ```python def find_words_optimized(board: List[List[str]], words: List[str]) -> List[str]: ``` **Input:** * `board`: A 2D list of characters representing the board. `1 <= board.length <= 12` and `1 <= board[i].length <= 12`. * `words`: A list of strings representing the words to be searched. `1 <= words.length <= 3 * 10^4`, and `1 <= words[i].length <= 10`. **Output:** * Return a list of strings representing words that can be found on the board. **Constraints:** * Each letter in the board must be used at most once per word. * Words are only formed by sequentially adjacent cells (horizontally or vertically). # Scenario: Imagine you are constructing a crossword puzzle solver. You are given a complex crossword board and a dictionary of valid words. Your task is to write a function `find_words_optimized` that efficiently finds all valid words present in the grid. # Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] print(find_words_optimized(board, words)) ``` **Expected Output:** ```python [\'oath\', \'eat\'] ``` **Hint:** - Optimize using a Trie to handle prefixes efficiently. - Implement a backtracking approach to explore all board paths. - Use a set or similar structure to avoid duplicate word entries in the result.","solution":"class TrieNode: def __init__(self): self.children = {} self.isEndOfWord = False self.word = None class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.isEndOfWord = True node.word = word def find_words_optimized(board, words): def dfs(board, node, x, y, result): if node.isEndOfWord: result.add(node.word) node.isEndOfWord = False # Avoid duplicate words if x < 0 or y < 0 or x >= len(board) or y >= len(board[0]) or board[x][y] not in node.children: return temp = board[x][y] board[x][y] = \'#\' for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(board, node.children[temp], x + dx, y + dy, result) board[x][y] = temp trie = Trie() for word in words: trie.insert(word) result = set() for i in range(len(board)): for j in range(len(board[0])): if board[i][j] in trie.root.children: dfs(board, trie.root, i, j, result) return list(result)"},{"question":"Enhanced Nearest Neighbor Classification You are provided with an implementation of the nearest neighbor classification algorithm. The existing implementation computes the nearest neighbor based on Euclidean distance between vectors. Your task is to extend and optimize this implementation by adding a few vital features. # Objectives: 1. Implement the enhanced nearest neighbor function `enhanced_nearest_neighbor` which includes: - Handling variable distance metrics (`euclidean`, `manhattan`, `chebyshev`). - Efficiently handling large datasets by incorporating spatial partitioning using KD-Trees. 2. Implement a helper function to construct a KD-Tree from the given training set. 3. Implement a helper function to query the nearest neighbor using the KD-Tree. # Function Signatures: 1. `def enhanced_nearest_neighbor(x: tuple, tSet: dict, metric: str = \\"euclidean\\") -> any:` 2. `def build_kd_tree(tSet: dict, depth: int = 0) -> any:` 3. `def kd_tree_search(tree: any, x: tuple, depth: int = 0) -> tuple:` # Input: - `x`: A tuple representing the input vector. - `tSet`: A dictionary where keys are tuples representing vectors, and values are the associated labels. - `metric`: A string indicating the distance metric to be used (`\\"euclidean\\"`, `\\"manhattan\\"`, or `\\"chebyshev\\"`). # Output: - The label of the nearest neighbor according to the specified distance metric and KD-Tree optimization. # Constraints: - Vectors are guaranteed to be of the same length. - Distance metrics supported are Euclidean, Manhattan, and Chebyshev. - KD-Tree depth is based on vector dimensions (k-dimensions). # Performance Requirements: - Efficient handling of large datasets up to 10^6 vectors. - Optimized searching using KD-Tree based partitioning. # Examples: ```python # Using Euclidean Distance tSet = { (2, 3): \\"Class A\\", (5, 4): \\"Class B\\", (9, 6): \\"Class C\\", (4, 7): \\"Class A\\", (8, 1): \\"Class B\\", (7, 2): \\"Class C\\" } x = (7, 2) assert enhanced_nearest_neighbor(x, tSet, metric=\\"euclidean\\") == \\"Class C\\" # Using Manhattan Distance assert enhanced_nearest_neighbor(x, tSet, metric=\\"manhattan\\") == \\"Class C\\" ``` # Notes: 1. Implementations must handle edge cases such as: - An empty training set. - Single-element training set. - Various distance metrics. 2. Focus on optimizing the distance calculation and nearest neighbor search using KD-Tree to achieve the performance requirements.","solution":"import numpy as np from sklearn.neighbors import KDTree def enhanced_nearest_neighbor(x: tuple, tSet: dict, metric: str = \\"euclidean\\") -> any: Returns the label of the nearest neighbor of the input vector x according to the specified distance metric. if not tSet: return None if len(tSet) == 1: return list(tSet.values())[0] # Convert the training set to necessary formats for KDTree points = np.array(list(tSet.keys())) labels = list(tSet.values()) # Build the KD-Tree tree = build_kd_tree(points) # Query the KD-Tree for the nearest neighbor index = kd_tree_search(tree, np.array(x), metric) return labels[index] def build_kd_tree(tSet_points: np.ndarray): Constructs a KD-Tree from the training set points. tree = KDTree(tSet_points) return tree def kd_tree_search(tree: KDTree, x: np.ndarray, metric: str) -> int: Queries the KD-Tree for the nearest neighbor of vector x, according to the specified distance metric. Returns the index of the nearest neighbor. metric_map = { \\"euclidean\\": \\"euclidean\\", \\"manhattan\\": \\"manhattan\\", \\"chebyshev\\": \\"chebyshev\\" } distance_metric = metric_map.get(metric, \\"euclidean\\") dist, ind = tree.query([x], k=1, return_distance=True, sort_results=True) return ind[0][0]"},{"question":"# Selection Sort with Edge Case Handling You have been tasked to implement and extend the `selection_sort` function with additional edge case handling and performance checks based on its analysis. Task: 1. Implement the function `enhanced_selection_sort(arr: list[int], simulation: bool = False) -> list[int]` which: - Sorts the array `arr` using an enhanced version of the selection sort algorithm. - Prints intermediate steps if `simulation` is `True`. 2. Ensure your implementation: - Handles cases with duplicate elements correctly without errors. - Optimizes by breaking early if the array is already sorted during any iteration. - Considers and avoids unnecessary swaps. 3. Your function should attempt to minimize the number of operations and handle the provided edge cases efficiently. Function Signature ```python def enhanced_selection_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` Input - `arr`: A list of integers that need to be sorted. - `simulation`: A boolean that triggers the printing of intermediate steps if `True`. Output - Returns the sorted list as an array of integers in non-decreasing order. Example ```python # Example 1 input: [64, 25, 12, 22, 11], simulation=True output: iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 # Example 2 input: [1, 2, 3, 4, 5], simulation=True output: iteration 0 : 1 2 3 4 5 (breaks early as the array is already sorted) ``` **Constraints:** - Your solution should not use built-in sort functions. - The function should maintain O(n^2) time complexity with any possible optimizations.","solution":"def enhanced_selection_sort(arr: list[int], simulation: bool = False) -> list[int]: n = len(arr) for i in range(n): min_index = i # Find the minimum element in remaining unsorted array for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") # Check if the array is already sorted if i > 0 and arr[i-1] <= arr[i]: if all(arr[k] <= arr[k+1] for k in range(i, n-1)): if simulation: print(\\"Array is already sorted. Exiting early.\\") break return arr"},{"question":"Scenario: You are given the task to solve the set cover problem, where you need to cover all elements of a universe using the minimum cost subsets from a given collection. You have both an optimal algorithm, suitable for small inputs, and a greedy algorithm, suitable for large inputs. Your task is to implement a more efficient approximation algorithm that improves the greedy algorithm\'s performance by incorporating elements from the dynamic programming approach. Task: Implement the function `enhanced_greedy_set_cover` that improves the performance of the given greedy algorithm by reducing redundant checks and optimizing the subset selection process. ```python def enhanced_greedy_set_cover(universe, subsets, costs): Args: universe (set): A set of elements representing the universe {1, 2, 3, ...} subsets (dict): Subsets of the universe with identifiers as keys and sets of elements as values Example: {\'S1\': {1, 2}, \'S2\': {2, 3, 4}, ...} costs (dict): Costs associated with each subset in subsets with identifiers as keys and costs as values Example: {\'S1\': 10, \'S2\': 5, ...} Returns: list: A list of subset identifiers that collectively cover the universe with minimum cost # Implement your solution here return selected_subsets ``` Input: * `universe`: A set of elements representing the universe {1, 2, 3, ...} * `subsets`: A dictionary where keys are subset identifiers and values are sets of elements contained in the subsets. * `costs`: A dictionary where keys are subset identifiers and values are the costs associated with each subset. Output: * A list of subset identifiers that together cover all elements of the universe with minimized cost. Constraints: * The input `universe` will contain between 1 and 50 elements. * Each subset and its associated cost will be provided with unique identifiers. * Total number of subsets will be between 1 and 100. * Costs will be positive integers between 1 and 100. Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} result = enhanced_greedy_set_cover(universe, subsets, costs) print(result) # Output could be: [\'S2\', \'S3\'] or equivalent covering set ``` Evaluation Criteria: * Correctness: The solution must return a valid cover of the universe with minimized cost. * Efficiency: The solution must improve upon the basic greedy algorithm in performance. * Readability: The code should be well-structured and easy to read. * Edge Cases: Proper handling of edge cases such as no available subsets or invalid inputs.","solution":"def enhanced_greedy_set_cover(universe, subsets, costs): Args: universe (set): A set of elements representing the universe {1, 2, 3, ...} subsets (dict): Subsets of the universe with identifiers as keys and sets of elements as values Example: {\'S1\': {1, 2}, \'S2\': {2, 3, 4}, ...} costs (dict): Costs associated with each subset in subsets with identifiers as keys and costs as values Example: {\'S1\': 10, \'S2\': 5, ...} Returns: list: A list of subset identifiers that collectively cover the universe with minimum cost # Initialize an empty list to store the selected subset identifiers selected_subsets = [] # Track the elements that have been covered so far covered = set() # While we haven\'t covered the whole universe while covered != universe: # Track the best subset in this iteration best_subset = None best_subset_cost_effectiveness = float(\'inf\') # Loop through each subset to determine the most cost-effective addition for subset_id, subset_elements in subsets.items(): # Determine remaining uncovered elements in the subset remaining_elements = subset_elements - covered if remaining_elements: # Calculate cost-effectiveness (cost per element covered) cost_effectiveness = costs[subset_id] / len(remaining_elements) if cost_effectiveness < best_subset_cost_effectiveness: best_subset_cost_effectiveness = cost_effectiveness best_subset = subset_id if best_subset: # Add the selected subset to the list of selected subset identifiers selected_subsets.append(best_subset) # Update the covered elements covered.update(subsets[best_subset]) else: # If no best subset is found and universe is still uncovered, we have an issue raise ValueError(\\"It is impossible to cover the entire universe with the given subsets.\\") return selected_subsets"},{"question":"Design and implement an efficient algorithm for calculating the maximum flow in a given flow network using the Ford-Fulkerson, Edmonds-Karp, or Dinic\'s algorithm. The input will consist of the capacity matrix, source node, and sink node. You are required to handle edge cases, optimize for performance, and ensure correctness. Your solution should choose the optimal algorithm based on the network properties. # Input Format * A two-dimensional list `capacity` where `capacity[i][j]` indicates the capacity of the edge from node `i` to node `j`. * An integer `source` representing the source node. * An integer `sink` representing the sink node. # Output Format * An integer representing the maximum flow from the source node to the sink node. # Constraints * (1 leq text{number of nodes} leq 500) * (0 leq text{capacity[i][j]} leq 10^9) * The graph is directed and may have multiple edges between the same nodes. # Example Scenario Example Input ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 ``` Example Output ```python 23 ``` # Guidelines 1. Implement a function `max_flow(capacity, source, sink)` which selects the optimal algorithm based on the network\'s characteristics. 2. Ensure that your implementation handles various edge cases, including cycles and disconnected nodes. 3. Optimize for performance by choosing the most suitable algorithm and reducing unnecessary computations. # Evaluation Criteria * Correctness and Robustness: The output should be correct for all possible test cases. * Performance: Efficient handling of large inputs will be evaluated. * Code Quality: The solution should be clean, readable, and well-documented.","solution":"from collections import deque def bfs(capacity, source, sink, parent): Breadth-First Search to find an augmenting path in the residual graph. visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(capacity[u]): if not visited[v] and cap > 0: # if not visited and there is available capacity queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def max_flow(capacity, source, sink): Function to calculate maximum flow in a given flow network using Edmonds-Karp algorithm. # Initialize residual capacities with the original capacities residual_capacity = [list(row) for row in capacity] parent = [-1] * len(capacity) # To store the path max_flow = 0 # Augment the flow while there is a path from source to sink while bfs(residual_capacity, source, sink, parent): # Find the maximum flow through the path found path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] # Update the residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question **Context** You work for a telecommunication company, where the goal is to lay down the least-costly network of fiber optic cables between cities. To achieve this with minimal cost, you need to form a Minimum Spanning Tree (MST) of the city network graph. **Task** Given a connected graph represented as a dictionary, where keys are node identifiers, and the values are lists of [weight, node] pairs representing the edges and their weights from the key node to other nodes, implement a function that returns the total weight of the MST created using Prim\'s Algorithm. **Function Signature** ```python def prims_minimum_spanning(graph: Dict[Any, List[List[int]]]) -> int: pass ``` **Input** * `graph` - A dictionary representing the graph. The key is a node and the value is a list of [weight, node] pairs. **Output** * `int` - The total weight of the MST. **Constraints** * The graph is connected. * The weights of the edges are positive integers. * All nodes have unique identifiers. * The graph contains no self-loops. **Example** ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } assert prims_minimum_spanning(graph) == 14 ``` **Explanation** In the provided example, the MST would include the edges with weights 3, 2, 4, and 5, resulting in a total weight of 14. Notes Make sure your function handles edge cases such as having nodes with no connections (though in this task such nodes should not be present since the graph is connected).","solution":"import heapq from typing import Dict, Any, List def prims_minimum_spanning(graph: Dict[Any, List[List[int]]]) -> int: Returns the total weight of the Minimum Spanning Tree (MST) created using Prim\'s Algorithm. Parameters: graph (dict): A dictionary representing the graph. The key is a node and the value is a list of [weight, node] pairs. Returns: int: The total weight of the MST. # Start with an arbitrary node, say the first node in the dictionary start_node = next(iter(graph)) # Use a priority queue to store the edges, initialized with the edges of the start node pq = [(weight, start_node, to) for weight, to in graph[start_node]] heapq.heapify(pq) # Set to keep track of nodes included in the MST in_mst = set([start_node]) total_weight = 0 while pq: weight, frm, to = heapq.heappop(pq) if to not in in_mst: in_mst.add(to) total_weight += weight # Add all edges from the newly added node to the priority queue for next_weight, next_to in graph[to]: if next_to not in in_mst: heapq.heappush(pq, (next_weight, to, next_to)) return total_weight"},{"question":"# Probabilistic Primality Test You are given an implementation of the Rabin-Miller primality test, a probabilistic algorithm to determine whether a given number ( n ) is prime or composite. Your task is to implement a similar probabilistic primality test with a few modifications to enhance its flexibility and reliability. # Objectives 1. Refactor the existing code to handle cases where ( n < 5 ) more elegantly. 2. Implement a mechanism to increase the number of iterations ( k ) dynamically based on the size of ( n ). 3. Improve the performance by optimizing the modular exponentiation steps. 4. Ensure your implementation remains probabilistic, with a configurable error probability. # Function Specification **Function Name**: `primality_test(n: int, t: int = 5) -> bool` **Inputs**: - `n` (int): The number to test for primality. - `t` (int): Optional; the initial number of iterations (default is 5). **Outputs**: - (bool): Returns `True` if ( n ) is probably prime; `False` if ( n ) is guaranteed composite. # Example ```python assert primality_test(17) == True assert primality_test(4) == False assert primality_test(18, 10) == False assert primality_test(19, 10) == True ``` # Constraints - ( 1 leq n leq 10^{18} ) - ( 1 leq t leq 100 ) # Requirements - Optimize handling of edge cases (e.g., very small ( n )). - Dynamic adjustment of iteration count ( t ) based on the size of ( n ). - Ensure the algorithm remains efficient in terms of both time and space complexity. - Adapt the power calculation within the algorithm for enhanced performance. # Notes - You may use internal/helper functions within your implementation. - Python\'s built-in `pow` function should be leveraged for modular exponentiation due to its efficiency. **You\'re assessed on**: Code correctness, optimization, edge case handling, and efficient use of resources.","solution":"import random def primality_test(n: int, t: int = 5) -> bool: if n < 2: return False if n in (2, 3): return True if n % 2 == 0: return False def miller_rabin_witness(a, n): # Write (n - 1) as 2^s * d d = n - 1 s = 0 while d % 2 == 0: d //= 2 s += 1 # compute a^d % n x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: return False return True # Dynamic adjustment of iteration count based on size of n t = min(t, max(1, (len(str(n)) // 3))) for _ in range(t): a = random.randint(2, n - 2) if miller_rabin_witness(a, n): return False return True"},{"question":"# Consecutive Stack Sequence Validation Given a stack of integers, your task is to implement a function that checks whether the integers form a consecutive sequence from the bottom of the stack to the top. You are required to write two versions of this function: 1. `first_is_consecutive(stack)`: This function should use an additional stack as auxiliary storage. 2. `second_is_consecutive(stack)`: This function should use a queue as auxiliary storage. # Function Signatures ```python def first_is_consecutive(stack: list[int]) -> bool: pass def second_is_consecutive(stack: list[int]) -> bool: pass ``` # Input and Output Formats * **Input**: A list of integers representing a stack, where the first element is the bottom of the stack, and the last element is the top of the stack. * **Output**: A boolean value: * `True` if the elements form a consecutive sequence. * `False` otherwise. # Constraints * The length of the stack `n` is in the range [1, 10^5]. * The integers can be any valid 32-bit integers. # Examples *Example 1:* ```python stack = [3, 4, 5, 6, 7] print(first_is_consecutive(stack)) # Output: True print(second_is_consecutive(stack)) # Output: True ``` *Example 2:* ```python stack = [3, 4, 6, 7] print(first_is_consecutive(stack)) # Output: False print(second_is_consecutive(stack)) # Output: False ``` *Example 3:* ```python stack = [1] print(first_is_consecutive(stack)) # Output: True print(second_is_consecutive(stack)) # Output: True ``` # Performance Requirements * Both functions should run in O(n) time and use O(n) additional space. # Instructions Implement the two required functions considering the constraints stated above. Ensure your implementation handles edge cases appropriately, maintains the original stack order, and optimized for performance.","solution":"def first_is_consecutive(stack): if not stack: return True aux_stack = [] previous_element = stack.pop(0) aux_stack.append(previous_element) while stack: current_element = stack.pop(0) if current_element != previous_element + 1: return False previous_element = current_element aux_stack.append(current_element) while aux_stack: stack.insert(0, aux_stack.pop()) return True def second_is_consecutive(stack): if not stack: return True from collections import deque queue = deque() previous_element = stack.pop(0) queue.append(previous_element) while stack: current_element = stack.pop(0) if current_element != previous_element + 1: return False previous_element = current_element queue.append(current_element) while queue: stack.insert(0, queue.popleft()) return True"},{"question":"Implement a function `custom_reverse` that takes a string `s` as input and returns it reversed. You are required to implement the function using an **iterative approach** without using Python’s built-in reverse methods or slicing. # Function Signature ```python def custom_reverse(s: str) -> str: ``` # Input * A single string `s` where `0 <= len(s) <= 10^6`. # Output * A string `s` in reversed order. # Constraints * You must use an iterative approach. * Do not use built-in Python functions for reversing a string (`reversed()`, slicing, etc.). # Example Input `s = \\"hello\\"` Output `\\"olleh\\"` Input `s = \\"abcd\\"` Output `\\"dcba\\"` Input `s = \\"\\"` Output `\\"\\"` # Scenario Here\'s the scenario to help contextualize the problem: Imagine you are developing a text-processing program which includes various utilities for manipulating strings. One required component is the ability to reverse given strings efficiently, especially when dealing with very large inputs. The goal is to implement a performant solution using basic string manipulation techniques. # Performance Considerations Your solution should exhibit a time complexity of O(n) and a space complexity of O(n), where n is the length of the string.","solution":"def custom_reverse(s: str) -> str: Returns the reversed string of s using an iterative approach. if len(s) == 0: return s reversed_string = [] for char in s: reversed_string.insert(0, char) return \'\'.join(reversed_string)"},{"question":"# Context Merge Sort is a fundamental sorting algorithm commonly used in computer science due to its guarantees in time complexity and sorting stability. Your task is to demonstrate your understanding of this algorithm by implementing it with particular attention to efficient merging and handling of edge cases. # Task **Function Implementation**: Implement a function `merge_sort_in_place(arr)` that sorts an array in place using the Merge Sort algorithm. This function should utilize efficient memory management to avoid unnecessary copying of arrays. Requirements - **Input Format**: - A list `arr` of integers of length `n` where `0 <= n <= 10^5`. - **Output Format**: - The function should sort the array in place and return the sorted array. - **Constraints**: - You may assume that the integers in the list can be both negative and positive. - Aim for a space complexity which is as close to O(1) as possible aside from the input array itself. - Ensure to handle edge cases efficiently, including empty arrays and arrays with one element. - **Performance**: - Your implementation should aim to run with an average time complexity of O(n log n). # Example ```python # Example 1 arr = [38, 27, 43, 3, 9, 82, 10] merge_sort_in_place(arr) # Should return [3, 9, 10, 27, 38, 43, 82] # Example 2 arr = [] merge_sort_in_place(arr) # Should return [] # Example 3 arr = [1] merge_sort_in_place(arr) # Should return [1] # Example 4 arr = [-1, -2, -3, -4, -5] merge_sort_in_place(arr) # Should return [-5, -4, -3, -2, -1] ```","solution":"def merge_sort_in_place(arr): Sorts the array in place using merge sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list. if len(arr) > 1: merge_sort_helper(arr, 0, len(arr) - 1) return arr def merge_sort_helper(arr, left, right): if left < right: middle = (left + right) // 2 merge_sort_helper(arr, left, middle) merge_sort_helper(arr, middle + 1, right) merge(arr, left, middle, right) def merge(arr, left, middle, right): n1 = middle - left + 1 n2 = right - middle # Create temp arrays left_arr = arr[left:middle + 1] right_arr = arr[middle + 1:right + 1] i = j = 0 k = left while i < n1 and j < n2: if left_arr[i] <= right_arr[j]: arr[k] = left_arr[i] i += 1 else: arr[k] = right_arr[j] j += 1 k += 1 while i < n1: arr[k] = left_arr[i] i += 1 k += 1 while j < n2: arr[k] = right_arr[j] j += 1 k += 1"},{"question":"# Next Higher Number with Same Set of Digits You are tasked with writing a function `next_bigger(num)` that returns the next higher number that can be formed using the same set of digits as those in `num`. If no such number exists, the function should return `-1`. We define \\"next higher number\\" as the number that follows the given number in lexicographical (dictionary) order when all its digits are considered. Function Signature ```python def next_bigger(num: int) -> int: ``` Input * `num`: An integer `1 <= num <= 10^18` Output * An integer representing the next higher number that can be formed using the digits of `num`. If no such higher number exists, return `-1`. Constraints * The number should only include positive integer digits. * The function should handle leading zeros correctly in reversed segments. Example Test Cases You can run the following test cases to validate your solution. Implement the solution within given constraints: ```python assert next_bigger(38276) == 38627 assert next_bigger(99999) == -1 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(1528452) == 1528524 assert next_bigger(5) == -1 assert next_bigger(138654) == 143568 ``` Additional Notes Make sure to handle edge cases such as where all digits are the same (e.g., `999`) or where only one digit is present. Your solution should be efficient with at most linear time complexity for the length of the number\'s digits. Implement your solution below:","solution":"def next_bigger(num: int) -> int: Returns the next higher number that can be formed using the same set of digits as those in num. If no such number exists, returns -1. digits = list(str(num)) length = len(digits) # Step 1: Find the first digit that is smaller than the digit next to it from right to left i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, that means the number is the highest permutation of its digits if i == -1: return -1 # Step 2: Find the smallest digit on the right side of digits[i] which is larger than digits[i] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found smallest digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after index i digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"Implement a **Doubly Linked List** with the following functionality: 1. **Initialization** *(constructor)*: Initialize the list to be empty. 2. **Insert at Head**: Insert a new node with a given value at the head of the list. 3. **Insert at Tail**: Insert a new node with a given value at the tail of the list. 4. **Delete**: Delete a node with a given value from the list. 5. **Find**: Search for a node with a given value and return it (or `None` if not found). 6. **Display**: Return a list of values representing the current state of the list, in order from head to tail. Constraints - Assume all values are integers. - Operations should be implemented with optimal efficiency, considering the given constraints. - The list should handle edge cases such as operations on an empty list or with a single element gracefully. # Example ```python dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_tail(20) dll.insert_at_tail(30) print(dll.display()) # Output: [10, 20, 30] dll.delete(20) print(dll.display()) # Output: [10, 30] node = dll.find(10) print(node.value) # Output: 10 node = dll.find(99) print(node) # Output: None ``` # Implementation Complete the following class with the described methods: ```python class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): # Implement this method def insert_at_tail(self, value): # Implement this method def delete(self, value): # Implement this method def find(self, value): # Implement this method def display(self): # Implement this method ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def display(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"You are asked to simplify Unix-style file paths. Your task is to implement a function `def simplify_path(path: str) -> str` that simplifies a given absolute path for a file (Unix-style). Input - `path`: a string representing an absolute Unix-style path (from `/` to `/home//foo/`). The path will be valid with characters limited to lowercase English letters, \'/\', \'.\' and \'..\'. Output - Returns a string that is the simplified canonical path. Constraints - The input path is always rooted, i.e., it starts with a \'/\'. - The path does not have any invalid characters. Example Scenarios 1. simplify_path(\\"/home/\\") should return `\\"/home\\"` 2. simplify_path(\\"/a/./b/../../c/\\") should return `\\"/c\\"` 3. simplify_path(\\"/../\\") should return `\\"/\\"` 4. simplify_path(\\"/home//foo/\\") should return `\\"/home/foo\\"` Guidelines - You must ignore single dots (`.`) which represent the current directory. - You must resolve double dots (`..`) which represent going up a directory. - Ensure to handle cases with multiple slashes by consolidating them into one. Performance - The function should have a linear time complexity O(n), where n is the length of the input path. **Note**: Direct usage of operating system libraries or functions that perform path simplification is not allowed. ```python def simplify_path(path: str) -> str: # Implement the simplified path function ``` Test your implementation with various cases to validate correctness especially with edge scenarios presented.","solution":"def simplify_path(path: str) -> str: Simplifies a given Unix-style file path to its canonical form. # Split the path by \'/\' parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) # Create the final simplified path simplified_path = \'/\' + \'/\'.join(stack) return simplified_path"},{"question":"# Objective You are tasked with implementing a key functionality for a Red-Black Tree data structure. Specifically, you\'ll focus on adding a feature to find the kth smallest element in the tree. # Problem Description Implement the method `find_kth_smallest(tree: RBTree, k: int) -> int` which accepts an instance of `RBTree` and an integer `k`, and returns the value of the kth smallest element in the Red-Black Tree. # Input * `tree`: An instance of `RBTree` that maintains properties of a Red-Black Tree. * `k`: An integer indicating the position (1-based) of the smallest element you need to find in the tree. # Output * Returns the value of the kth smallest element in the Red-Black Tree. # Constraints * Assume that 1 ≤ k ≤ total number of nodes in the tree. * You are encouraged to use an in-order traversal to solve this problem, utilizing the properties of Binary Search Tree. # Example ```python rb = RBTree() nodes = [7, 3, 18, 10, 22, 8, 11, 26] for val in nodes: rb.insert(RBNode(val, 1)) print(find_kth_smallest(rb, 3)) # Output should be 8 ``` # Performance Requirements * The solution should ensure O(k) time complexity for finding the kth smallest element using in-order traversal.","solution":"class RBNode: def __init__(self, value, color, left=None, right=None, parent=None): self.value = value self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): node = RBNode(key, 1, self.TNULL, self.TNULL, None) y = None x = self.root while x != self.TNULL: y = x if node.value < x.value: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.value < y.value: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.fix_insert(node) def fix_insert(self, k): # Insert fix algorithm (excluded for brevity) pass def inorder_traversal(node, TNULL, result): if node != TNULL: inorder_traversal(node.left, TNULL, result) result.append(node.value) inorder_traversal(node.right, TNULL, result) def find_kth_smallest(tree, k): Function to find kth smallest element in the Red-Black Tree. result = [] inorder_traversal(tree.root, tree.TNULL, result) return result[k - 1]"},{"question":"You are tasked with implementing a function that splits a given file path or URL into its directory and file components. This function is critical for a file management application that needs to accurately parse and manipulate both local file paths and web URLs. # Function Specification: Implement the function `split_path(path: str) -> (str, str)` which takes a string `path` as input and returns a tuple containing two strings. The first string in the tuple should be the directory component of the path, and the second string should be the file name. # Input: * `path` - A string representing a file path or URL. The path will be a valid path containing at least one \'/\' character. # Output: * A tuple with two elements: 1. The directory path as a string. 2. The file name as a string. # Constraints: * Paths will use \'/\' as the separator. * Input `path` will always contain at least one \'/\' character. * The function must handle both file and URL paths. # Examples: 1. **Input**: `https://algorithms/unix/test.py` **Output**: (`https://algorithms/unix`, `test.py`) 2. **Input**: `algorithms/unix/test.py` **Output**: (`algorithms/unix`, `test.py`) 3. **Input**: `home/user/documents/report.pdf` **Output**: (`home/user/documents`, `report.pdf`) 4. **Input**: `example.com/index.html` **Output**: (`example.com`, `index.html`) # Notes: * Consider edge cases such as paths without a trailing file name separator. * Don\'t use any non-standard libraries; stick to Python\'s standard library.","solution":"def split_path(path: str) -> (str, str): Split the given path into directory and file name components. Parameters: path (str): The file path or URL to split. Returns: (str, str): A tuple containing the directory path and the file name. # Finding the last \'/\' character in the path last_slash_index = path.rfind(\'/\') # Splitting the path into directory and filename directory = path[:last_slash_index] filename = path[last_slash_index + 1:] return (directory, filename)"},{"question":"# License Key Formatting **Context**: Suppose you are an engineer working on a system where users need to input license keys that are often very long and contain hyphens and alphanumeric characters. For easy readability, you are tasked with writing code to reformat these license keys into segments of a specified length. **Problem Statement**: You are given a string `key` that represents a license key to be formatted. The string contains alphanumeric characters and possibly hyphens. The goal is to return the key formatted such that each segment contains exactly `k` characters, except potentially the first segment which can be shorter. Characters in the key should be grouped from the end, with hyphens inserted between segments. **Function Signature**: ```python def license_number(key: str, k: int) -> str: pass ``` **Input**: * `key` (str): A string that represents the license key. 1 <= len(key) <= 10^5. * `k` (int): The desired length of each group after formatting. 1 <= k <= len(key). **Output**: * Returns a string representing the reformatted license key. **Constraints**: * The input string `key` may contain alphanumeric characters and hyphens. * Your solution should efficiently handle the input size within the given constraints. **Example**: 1. `license_number(\\"2-4A0r7-4k\\", 4)` should return `\\"24A0-R74K\\"`. 2. `license_number(\\"2-4A0r7-4k\\", 3)` should return `\\"24-A0R-74K\\"`. **Notes**: * Ensure all characters (except inserted hyphens) are presented in uppercase in the final result. * The input may contain multiple or no hyphens; these should be ignored in the final formatted output. * The reformatting should only consider alphanumeric characters. Write a function to solve the stated problem.","solution":"def license_number(key: str, k: int) -> str: Reformats the license key such that each segment contains exactly `k` characters, except potentially the first segment which can be shorter. Characters in the key are grouped from the end, with hyphens inserted between segments. Parameters: key (str): The input license key string containing alphanumeric characters and hyphens. k (int): The desired length of each segment after formatting. Returns: str: The reformatted license key. # Remove all existing hyphens and convert to uppercase key = key.replace(\'-\', \'\').upper() # Result list to store segments result = [] # Start from the end of the string and add segments of size `k` for i in range(len(key), 0, -k): result.append(key[max(0, i - k):i]) # Join the segments with hyphens and return return \'-\'.join(reversed(result))"},{"question":"# Linked List Reversal Coding Challenge **Scenario**: You are given a singly linked list and asked to reverse it. Considering both iterative and recursive approaches are common and each has its own advantages, you\'ll be implementing both of these methods. The aim is to ensure you understand the nuances of pointer manipulation and recursion depth handling. Implement two functions: 1. `reverse_list_iterative(head)` 2. `reverse_list_recursive(head)` **Function Specifications**: 1. **reverse_list_iterative(head)**: * **Input**: `head` - The head node of a singly linked list *(ListNode)* * **Output**: The head node of the reversed linked list *(ListNode)* * **Example**: ```python # Input: 1 -> 2 -> 3 -> 4 # Output: 4 -> 3 -> 2 -> 1 ``` 2. **reverse_list_recursive(head)**: * **Input**: `head` - The head node of a singly linked list *(ListNode)* * **Output**: The head node of the reversed linked list *(ListNode)* * **Example**: ```python # Input: 1 -> 2 -> 3 -> 4 # Output: 4 -> 3 -> 2 -> 1 ``` # Constraints: * The number of nodes in the list is in the range `[0, 5000]`. * `-1000 <= Node.val <= 1000` * The list is of considerable length and large test cases should reflect this. * Handle edge cases like empty lists and singleton lists correctly. # Performance Expectations: * Iterative solution should be done in O(n) time and O(1) space. * Recursive solution should be done in O(n) time and O(n) space due to recursion stack. # ListNode Definition: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Important**: Do not modify the ListNode class. The solution should work with the provided implementation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list_iterative(head): Reverse a singly linked list iteratively. :param head: ListNode - The head node of the singly linked list :return: ListNode - The head node of the reversed singly linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head): Reverse a singly linked list recursively. :param head: ListNode - The head node of the singly linked list :return: ListNode - The head node of the reversed singly linked list if not head or not head.next: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"# String List Encoder/Decoder In some applications, it is necessary to encode a list of strings into a single string to facilitate easy transmission or storage, and later decode it back to the original list of strings. Your task is to create a robust encoder and decoder that achieves this. Requirements: 1. **Encode Method**: - Function signature: `def encode(strs: List[str]) -> str` - Input: A list of strings. - Output: A single encoded string representing the input list. 2. **Decode Method**: - Function signature: `def decode(s: str) -> List[str]` - Input: An encoded string. - Output: The original list of strings. 3. Handle edge cases like: - An empty list of strings. - Strings containing the delimiters used in the encoding process. 4. Ensure the solution is efficient in terms of both time and space complexity. Example # Input: ``` python strs = [\\"hello\\", \\"world\\"] ``` # Output: ``` python s = \\"5:hello5:world\\" decoded_strs = [\\"hello\\", \\"world\\"] ``` **Note**: The encoded string format uses length-prefix encoding, where each string is preceded by its length and a delimiter `\':\'`. Write your implementations for the `encode` and `decode` methods. Ensure to test your solution with diverse input scenarios to cover edge cases and performance constraints. ```python def encode(strs: List[str]) -> str: # Implement your encode method here pass def decode(s: str) -> List[str]: # Implement your decode method here pass ```","solution":"def encode(strs): Encodes a list of strings to a single string. return \'\'.join(\'{}:{}\'.format(len(s), s) for s in strs) def decode(s): Decodes a single string back to a list of strings. i = 0 decoded = [] while i < len(s): # Find the delimiter \':\' j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded.append(s[j+1:j+1+length]) i = j + 1 + length return decoded"},{"question":"# Question: Advanced Pathfinding on Weighted Graphs In the given code snippets, the functions provided can find paths between nodes in an unweighted graph. However, real-world applications often involve graphs where edges have different weights (e.g., distances, costs). Adapt the given algorithms to work with weighted graphs and find the shortest path based on the total weight of the path. # Requirements 1. Implement a function `find_shortest_weighted_path(graph, start, end)` that returns the shortest path between `start` and `end` based on the sum of edge weights. 2. Assume the graph is represented as a dictionary where keys are nodes, and values are lists of tuples representing the adjacent nodes and their respective edge weights. 3. You can assume that the graph does not contain negative weight cycles. # Input Format - `graph`: A dictionary where each key is a node, and the value is a list of tuples `(neighbour_node, edge_weight)`. - `start`: The starting node for the path. - `end`: The ending node for the path. # Output Format - A list of nodes representing the shortest path from `start` to `end` based on the total weight of the path. Return `None` if no path exists. # Constraints - All edge weights are positive integers. - The graph is guaranteed to have at least one node. - Nodes in graph are represented as unique strings. # Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' # Expected Output: [\'A\', \'B\', \'C\', \'D\'] print(find_shortest_weighted_path(graph, start, end)) ```","solution":"import heapq def find_shortest_weighted_path(graph, start, end): Returns the shortest path between `start` and `end` based on the sum of edge weights. # Priority queue to manage the exploration of nodes queue = [(0, start, [])] # Dictionary to track the shortest paths to each node seen = {start: 0} while queue: (cost, node, path) = heapq.heappop(queue) if node in seen and cost > seen[node]: continue path = path + [node] if node == end: return path for neighbor, weight in graph.get(node, []): new_cost = cost + weight if neighbor not in seen or new_cost < seen[neighbor]: seen[neighbor] = new_cost heapq.heappush(queue, (new_cost, neighbor, path)) return None"},{"question":"Implement a function `is_one_sparse(stream)` that determines if a given stream of tuples represents a 1-sparse recovery. The stream consists of tuples containing a non-negative number and a sign (\'+\' or \'-\'). The function should return the unique value if the stream is 1-sparse or `None` if it is not. # Function Signature ```python def is_one_sparse(stream: list) -> int: ``` # Input Format - `stream`: A list of tuples `[(int, str)]` where each tuple contains a non-negative integer and a sign (\'+\' or \'-\'). # Output Format - If the input stream is 1-sparse, return the unique element `int`. - If the input stream is not 1-sparse, return `None`. # Performance Requirements - The implementation should have a time complexity of O(n) and space complexity O(1). # Example Example 1 ```python stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] print(is_one_sparse(stream)) # Output: 4 ``` Example 2 ```python stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] print(is_one_sparse(stream)) # Output: 2 ``` Example 3 ```python stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] print(is_one_sparse(stream)) # Output: None ``` # Constraints - Each integer in the tuples is non-negative (>= 0). - The stream may contain from 0 to 10^6 tuples. - The signs in the tuples are guaranteed to be either \'+\' or \'-\'. Use efficient data structures and algorithms to ensure your solution scales well with the input size.","solution":"def is_one_sparse(stream): Determines if a given stream of tuples represents a 1-sparse recovery. The stream consists of tuples containing a non-negative number and a sign (\'+\' or \'-\'). Returns the unique value if the stream is 1-sparse, None otherwise. value_counts = {} for num, sign in stream: if sign == \'+\': value_counts[num] = value_counts.get(num, 0) + 1 elif sign == \'-\': value_counts[num] = value_counts.get(num, 0) - 1 unique_number = None for num, count in value_counts.items(): if count > 0: if unique_number is None: unique_number = num else: return None return unique_number"},{"question":"Switch Successive Pairs in a Stack You are given the task of switching successive pairs of elements in a stack. Specifically, you will create a function that takes a stack as input and rearranges its elements to switch each pair of elements starting from the bottom of the stack. If the stack has an odd number of elements, the topmost element should remain in its original position. There are two approaches provided: one using an additional stack and the other using a queue. Your task is to implement both approaches. # Functional Requirements 1. **Function Name**: `first_switch_pairs` * **Input**: A list `stack` representing the stack where `stack[0]` is the bottom of the stack and `stack[-1]` is the top. * **Output**: The modified stack after switching successive pairs using an auxiliary stack. 2. **Function Name**: `second_switch_pairs` * **Input**: A list `stack` representing the stack where `stack[0]` is the bottom of the stack and `stack[-1]` is the top. * **Output**: The modified stack after switching successive pairs using a queue. # Example ```python stack1 = [3, 8, 17, 9, 1, 10] output1 = [8, 3, 9, 17, 10, 1] assert first_switch_pairs(stack1) == output1 # Using auxiliary stack assert second_switch_pairs(stack1) == output1 # Using auxiliary queue stack2 = [3, 8, 17, 9, 1] output2 = [8, 3, 9, 17, 1] assert first_switch_pairs(stack2) == output2 # Using auxiliary stack assert second_switch_pairs(stack2) == output2 # Using auxiliary queue ``` # Constraints * The input stack may have at most 10^3 elements. * Elements in the stack are integers. * Modify the input stack in place, but extra space equal to the stack size is permitted. # Performance Requirements Ensure that your implementation runs efficiently for the given constraints, with a time complexity of O(n) and a space complexity of O(n).","solution":"def first_switch_pairs(stack): Returns the stack after switching successive pairs using an auxiliary stack. if len(stack) < 2: return stack aux_stack = [] while stack: aux_stack.append(stack.pop()) result = [] while aux_stack: if len(aux_stack) > 1: a = aux_stack.pop() b = aux_stack.pop() result.append(b) result.append(a) else: result.append(aux_stack.pop()) while result: stack.append(result.pop(0)) return stack def second_switch_pairs(stack): Returns the stack after switching successive pairs using a queue. if len(stack) < 2: return stack from collections import deque queue = deque() while stack: queue.appendleft(stack.pop()) result = deque() while queue: if len(queue) > 1: a = queue.popleft() b = queue.popleft() result.append(b) result.append(a) else: result.append(queue.popleft()) while result: stack.append(result.popleft()) return stack"},{"question":"# Question: Implement an Optimized Binomial Coefficient Calculator **Context**: The binomial coefficient, denoted as ( C(n, k) ), reflects the number of combinations of ( n ) items taken ( k ) at a time. It is widely used in statistics, combinatorics, and probability theory. The recursive formula can be inefficient for large inputs due to repeated calculations and deep recursion depth. **Objective**: Your task is to implement an optimized version of the binomial coefficient calculator which uses a dynamic programming approach to store intermediate results and avoid redundant calculations. # Input and Output Formats - **Input**: Two non-negative integers, ( n ) and ( k ) with ( n ge k ). - **Output**: A single integer representing ( C(n, k) ). # Constraints - ( 0 leq k leq n leq 1000 ) - Your solution should run efficiently within these constraints. # Performance Requirements - Your implementation should aim for ( O(n cdot k) ) time complexity and ( O(k) ) space complexity using iterative dynamic programming. # Function Signature Provide the implementation within the following function signature: ```python def optimized_binomial_coefficient(n: int, k: int) -> int: pass ``` # Example - Input: `optimized_binomial_coefficient(5, 2)` Output: `10` - Input: `optimized_binomial_coefficient(8, 3)` Output: `56` **Additional Notes**: You are not to use the recursive function provided, but instead, rewrite the calculation using dynamic programming. Handle edge cases and base conditions carefully.","solution":"def optimized_binomial_coefficient(n: int, k: int) -> int: Calculate binomial coefficient C(n, k) using dynamic programming. # Special case for when k is 0 or k is n if k == 0 or k == n: return 1 # Initialize an array to store intermediate results C = [0] * (k + 1) C[0] = 1 # Base case: C(n, 0) = 1 for i in range(1, n + 1): # Compute next row of Pascal\'s triangle using the previous row # Compute from right to left to ensure we are using the previous row\'s values for j in range(min(i, k), 0, -1): C[j] += C[j - 1] return C[k]"},{"question":"# Island Counter Using Union-Find You are given a 2D grid initially filled with water, represented by `0`. Each position can be added as land (`1`) one at a time. After each addition, count the number of separate islands formed on the grid. An island is formed by connecting adjacent lands horizontally or vertically. You need to implement the function `num_islands(positions: List[List[int]]) -> List[int]`. Input * `positions`: A list of lists of integers, where each sublist represents the coordinates [row, column] of land to be added sequentially. Output * A list of integers where the ith element is the number of islands after ith operation. Constraints * Assume the grid size and number of positions are reasonable to avoid memory overflow. * You need to use the Union-Find data structure to manage sets of connected lands. Example Given a 3x3 grid, `positions = [[0, 0], [0, 1], [1, 2], [2, 1]]`. 1. Initially: ``` 0 0 0 0 0 0 0 0 0 ``` 2. `addLand(0, 0)`: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 3. `addLand(0, 1)`: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 4. `addLand(1, 2)`: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 5. `addLand(2, 1)`: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 **Function Signature**: ```python def num_islands(positions: List[List[int]]) -> List[int]: pass ``` Implement the function `num_islands` using the provided `Union` class from the Union-Find data structure.","solution":"from typing import List class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = 0 # Number of connected components def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def increment_count(self): self.count += 1 def get_count(self): return self.count def num_islands(positions: List[List[int]]) -> List[int]: if not positions: return [] m, n = max(x[0] for x in positions) + 1, max(x[1] for x in positions) + 1 uf = UnionFind(m * n) grid = [[0] * n for _ in range(m)] res = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: if grid[x][y] == 1: res.append(uf.get_count()) continue grid[x][y] = 1 uf.increment_count() index = x * n + y for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: uf.union(index, nx * n + ny) res.append(uf.get_count()) return res"},{"question":"**Connecting Cities with Minimum Cost** Suppose you are tasked with connecting a series of cities through pipes to provide them with water. The goal is to connect all the cities with the minimum total pipe length. Each city is connected directly to at most one other city via a pipe, but two cities can also be connected indirectly through a network of pipes. You are given the number of cities `n` and a list of possible pipes with their lengths. Each pipe is represented as a tuple `(city1, city2, length)`, denoting a bidirectional pipe between `city1` and `city2` with a certain `length`. Write a function `minimum_cost` to determine the minimum cost to connect all cities. If it\'s not possible to connect all cities, return `-1`. # Function Signature: ```python def minimum_cost(n: int, pipes: List[Tuple[int, int, int]]) -> int: pass ``` # Input: - `n`: An integer representing the number of cities. - `pipes`: A list of tuples `(city1, city2, length)` where `1 <= length <= 1000` and `1 <= city1, city2 <= n`. # Output: - An integer representing the minimum cost to connect all cities, or `-1` if it is impossible to connect all cities. # Constraints: - `1 <= n <= 1000` - The number of pipes does not exceed `n * (n - 1) / 2`. # Example: ```python # Example 1 n = 3 pipes = [(1, 2, 1), (2, 3, 2), (1, 3, 3)] print(minimum_cost(n, pipes)) # Output: 3 # Example 2 n = 4 pipes = [(1, 2, 1), (2, 3, 2)] print(minimum_cost(n, pipes)) # Output: -1 (It\'s not possible to connect all cities) ``` # Clarifications: - You can assume that all city indices are unique and they are 1-based. - The function should handle large inputs efficiently and ensure the solution runs within a reasonable time limit. # Notes: - Use the Union-Find data structure to determine connectivity between cities. - Sort pipes by length and use Kruskal\'s Minimum Spanning Tree algorithm to ensure the minimum cost for connecting the cities.","solution":"def minimum_cost(n, pipes): Returns the minimum cost to connect all cities or -1 if it\'s not possible. def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 parent = [i for i in range(n)] rank = [0] * n pipes.sort(key=lambda x: x[2]) result = 0 edges_used = 0 for u, v, weight in pipes: u = u - 1 v = v - 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) result += weight edges_used += 1 return result if edges_used == n - 1 else -1"},{"question":"# Problem: Pattern Matching with Backtracking **Scenario**: You are working on a text processing system that needs to verify if a given string follows a specific pattern like bijection mapping between pattern characters and substrings of a string. **Objective**: Implement the function `pattern_match(pattern, string)` to determine if the given string follows the pattern. **Function Signature**: ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` **Input**: - `pattern` (str): A non-empty string containing only lowercase letters. - `string` (str): A non-empty string containing only lowercase letters. **Output**: - Returns `True` if the string follows the pattern, else `False`. **Constraints**: - The length of both `pattern` and `string` will not exceed 1000 characters. - You may assume both pattern and string contain only lowercase letters. **Examples**: 1. `pattern = \\"abab\\"`, `string = \\"redblueredblue\\"` should return `True`. 2. `pattern = \\"aaaa\\"`, `string = \\"asdasdasdasd\\"` should return `True`. 3. `pattern = \\"aabb\\"`, `string = \\"xyzabcxzyabc\\"` should return `False`. **Performance Requirements**: - Ensure the solution handles the worst-case scenarios efficiently. - Minimize redundant recursive calls and unnecessary checks to save execution time. **Problem Description**: The function should use a backtracking approach to determine if there\'s a way to map each character in the pattern to a non-empty substring of the string such that the entire string matches the sequence defined by the pattern uniquely. Hints: - Utilize a dictionary to store and manage current mappings. - Use recursion to explore possible mappings and backtrack if a mapping doesn\'t lead to a solution. - Consider backtracking conditions carefully to prevent infinite loops and excess computations.","solution":"def pattern_match(pattern, string): def backtrack(p_idx, s_idx, pat_map, used_strs): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] for i in range(s_idx, len(string)): sub_str = string[s_idx:i+1] # If pattern_char is already mapped to some string if pattern_char in pat_map: if pat_map[pattern_char] != sub_str: continue if backtrack(p_idx + 1, i + 1, pat_map, used_strs): return True else: # If the substring is already used for some other pattern character if sub_str in used_strs: continue # Create a new mapping pat_map[pattern_char] = sub_str used_strs.add(sub_str) if backtrack(p_idx + 1, i + 1, pat_map, used_strs): return True # Backtrack del pat_map[pattern_char] used_strs.remove(sub_str) return False return backtrack(0, 0, {}, set())"},{"question":"You are given two strings, `str1` and `str2`. Your task is to write a function that finds the minimum number of deletions required to make the two strings identical. You must use the dynamic programming approach to ensure your solution is efficient. Function Signature: ```python def min_deletions_to_make_identical(str1: str, str2: str) -> int: pass ``` Input - `str1` (0 <= len(str1) <= 1000): A string consisting of lowercase alphabets. - `str2` (0 <= len(str2) <= 1000): Another string consisting of lowercase alphabets. Output - Return an integer that represents the minimum number of deletions required to make both strings identical. Examples 1. min_deletions_to_make_identical(\\"sea\\", \\"eat\\") - Output: 2 - Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". 2. min_deletions_to_make_identical(\\"abcd\\", \\"abc\\") - Output: 1 - Explanation: You need to delete \'d\' from \\"abcd\\" to make it \\"abc\\". 3. min_deletions_to_make_identical(\\"\\", \\"abc\\") - Output: 3 - Explanation: You need to delete all characters from \\"abc\\" to make both strings empty. 4. min_deletions_to_make_identical(\\"xyz\\", \\"xyz\\") - Output: 0 - Explanation: Both strings are already identical. Constraints - The function should run efficiently for strings up to 1000 characters long. - Handle edge cases where one or both strings are empty.","solution":"def min_deletions_to_make_identical(str1: str, str2: str) -> int: Function to find the minimum number of deletions required to make two strings identical. This is done using dynamic programming to calculate the length of the longest common subsequence (LCS). The result is derived from the differences in lengths of the two strings from the LCS. m, n = len(str1), len(str2) # Create a DP table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of the longest common subsequence lcs_length = dp[m][n] # Minimum deletions needed to make the strings identical return (m - lcs_length) + (n - lcs_length)"},{"question":"Custom Stooge Sort Implementation Despite its inefficiency, Stooge Sort is an interesting study in recursion and sorting algorithms. Your task is to implement a modified Stooge Sort algorithm with additional constraints. Task You need to write a function `custom_stoogesort(arr, l, h)` that sorts a subarray from index `l` to `h` (inclusive) in ascending order. Additionally, you are required to: 1. Swap elements only if the element at the starting index is even. 2. Perform stooge sort steps, increasing efficiency by checking if the array is already sorted before making recursive calls. Function Signature ```python def custom_stoogesort(arr: List[int], l: int, h: int) -> None: pass ``` Input Format * `arr` - a list of integers. * `l` - starting index of the subarray. * `h` - ending index of the subarray. Output Format * The function should modify the input list `arr` in-place, sorting the elements in the range `[l, h]`. Constraints * All elements of the array are integers. * 0 <= l <= h < len(arr). Example ```python # Example usage: array = [10, 3, 5, 2, 7, 8] custom_stoogesort(array, 0, len(array) - 1) print(array) # Output should be a sorted list following the custom stooge sort rules. # Another example: array = [8, 12, 1, 14, 6, 5] custom_stoogesort(array, 1, 4) print(array) # Output should be: [8, 1, 6, 12, 5] ``` Considerations 1. Make sure to perform swaps only when the starting element is even. 2. Check if the subarray is already sorted before making recursive calls to optimize the algorithm slightly.","solution":"def custom_stoogesort(arr, l, h): Stooge sort for a subarray [l, h] with a custom rule: - Swap elements only if the element at the starting index is even. - Perform stooge sort steps, checking if the array is already sorted before making recursive calls. if l >= h: return # If the starting element is even and the element at index l is greater than element at index h, swap them if arr[l] > arr[h] and arr[l] % 2 == 0: arr[l], arr[h] = arr[h], arr[l] # If the array is already sorted, return already_sorted = True for i in range(l, h): if arr[i] > arr[i+1]: already_sorted = False break if already_sorted: return # If the range has more than two elements, use stooge sort if h - l + 1 > 2: t = (h - l + 1) // 3 custom_stoogesort(arr, l, h - t) # First two-thirds custom_stoogesort(arr, l + t, h) # Last two-thirds custom_stoogesort(arr, l, h - t) # First two-thirds again"},{"question":"# Fibonacci Sequence Coding Challenge Problem Statement As part of your programming assignment, you are required to implement a function that efficiently computes the n-th Fibonacci number. You have learned multiple ways to achieve this, and now you need to demonstrate your understanding by implementing an optimized solution. Task Write a function `optimized_fibonacci(n)` that returns the n-th Fibonacci number. The function should use an iterative approach to ensure optimal time and space complexity. Input * An integer `n` (0 <= n <= 10^6) Output * The n-th Fibonacci number. Constraints * Your implementation should run in O(n) time complexity. * The space complexity should be O(1), i.e., it should not use extra space for storing all Fibonacci numbers. Example Input: ``` 10 ``` Output: ``` 55 ``` Detailed Description * The function should handle large values of n efficiently. * You should check for invalid input and handle them accordingly (e.g., negative integers). * You can assume that the input will be a non-negative integer within the specified range. Prompt Implement the `optimized_fibonacci(n)` function below: ```python def optimized_fibonacci(n): # Your code here # Example usage print(optimized_fibonacci(10)) # Expected output: 55 ```","solution":"def optimized_fibonacci(n): Returns the n-th Fibonacci number using an iterative approach. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b # Example usage print(optimized_fibonacci(10)) # Expected output: 55"},{"question":"**Interpolation Search for Real World Data** You are working on a data processing application that frequently needs to look up values in a large, sorted list of integers. Given how critical this operation is, it needs to be performed both efficiently and reliably. To accomplish this, you will implement the Interpolation Search algorithm which is particularly effective for uniformly distributed data. Task Implement a function `interpolation_search(array: List[int], search_key: int) -> int` that searches for a `search_key` in a sorted `array` of integers. If `search_key` is found, return its index. If not, return -1. Input Format - A sorted array of integers, `array`. - An integer `search_key` which is the target value to search for in the array. Output Format - An integer denoting the index of `search_key` in `array` if it exists, otherwise -1. Constraints - The array is sorted in increasing order. - The array may contain negative numbers, zero, and positive numbers. - Avoid using built-in search functions. - Handle edge cases such as empty arrays or single-element arrays. - Your implementation must handle very large arrays efficiently. Examples ```python assert interpolation_search([10, 20, 30, 40], 10) == 0 assert interpolation_search([10, 20, 30, 40], 25) == -1 assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], 20) == 6 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 50) == -1 assert interpolation_search([3], 3) == 0 assert interpolation_search([], 10) == -1 ``` Performance Requirements - Your solution should be efficient and optimized to handle large datasets. - Aim for O(log log n) time complexity for uniformly distributed arrays.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on a sorted list of integers. Parameters: array (List[int]): The sorted list of integers to search in. search_key (int): The value to search for in the array. Returns: int: The index of the search_key in the array if found, else -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[high] == array[low]: if array[low] == search_key: return low else: return -1 # Estimate the position of the search_key pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Target value found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"# Graph Cloning with Custom Conditions You are helping a social network platform to create a backup of their current connectivity graph. Each user is represented as a node in an undirected graph, with edges representing friendships. Due to the dynamic nature of friendships, it is essential to periodically clone the graph to create a snapshot of the current state without disturbing the original connections. However, you need to implement both BFS and DFS approaches to clone the graph, ensuring your solution handles large-scale networks efficiently. Requirements 1. Implement two functions, `clone_graph_bfs` and `clone_graph_dfs`, to clone a graph using breadth-first search (BFS) and depth-first search (DFS), respectively. 2. Ensure the cloned graph maintains the same structure as the original one. Input and Output - **Function signature**: ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': def clone_graph_dfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` - **Input**: - `node`: An `UndirectedGraphNode` representing the starting node of the graph to be cloned. This node may have multiple neighbors, and those neighbors may each have their own neighbors, forming a network. - **Output**: - A newly cloned graph starting with the node corresponding to the input node. Constraints 1. Nodes are uniquely labeled integers. 2. The function should handle graphs with up to 10^4 nodes and 2 * 10^4 edges. 3. There can be self-loops and cycles in the graph. Example Consider the graph: 1 - 2 | | 3 - 4 - Calling `clone_graph_bfs(node1)` or `clone_graph_dfs(node1)` should both return a deep copy of the original graph, preserving all connections. Performance - Aim for O(V + E) time complexity. - Ensure memory usage is within O(V). # Additional Notes - You are advised to use the provided `UndirectedGraphNode` class for representing nodes. - Include error handling for edge cases such as the null node or disconnected nodes.","solution":"from collections import deque class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_bfs(node): if not node: return None # Dict to store the mapping of original node to their clone. clones = {node: UndirectedGraphNode(node.label)} # Queue for BFS traversal. queue = deque([node]) while queue: current_node = queue.popleft() for neighbor in current_node.neighbors: if neighbor not in clones: # Clone the neighbor if it hasn\'t been cloned already. clones[neighbor] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) # Add the cloned neighbor to the current node\'s clone\'s neighbors. clones[current_node].neighbors.append(clones[neighbor]) return clones[node] def clone_graph_dfs(node): if not node: return None # Dict to store the mapping of original node to their clone. clones = {} def dfs(current_node): if current_node in clones: return clones[current_node] # Clone the current node. clone_node = UndirectedGraphNode(current_node.label) clones[current_node] = clone_node for neighbor in current_node.neighbors: clone_node.neighbors.append(dfs(neighbor)) return clone_node return dfs(node)"},{"question":"You are tasked with implementing a function that identifies the most frequently occurring value(s) in a given array of integers. This function should return a list of the mode(s). If there are multiple modes, the function should return all of them. Ensure your implementation handles edge cases gracefully, such as an empty array input. Your solution should aim for optimal performance. **Function Signature:** ```python def find_modes(arr: List[int]) -> List[int]: pass ``` # Input * A list `arr` of integers where (1 leq len(arr) leq 10^5). # Output * A list of integers containing the most frequently occurring elements (mode(s)). If there are multiple modes, return all of them. # Constraints * All elements in `arr` are integers and can be negative, zero, or positive. * The elements may have multiple modes. In such cases, the function should return multiple values. * The function should return an empty list if the input array is empty. # Example ```python # Example 1 arr = [1, 1, 2, 2, 3, 4] print(find_modes(arr)) # Output: [1, 2] # Example 2 arr = [7, 1, 7, 3, 2] print(find_modes(arr)) # Output: [7] # Example 3 arr = [] print(find_modes(arr)) # Output: [] ``` # Notes * Ensure your implementation is efficient and handles large inputs within the constraint limits. * You may assume that there will not be more than `1e5` unique integer values in the array.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: Returns the most frequently occurring value(s) in the given array. If there are multiple modes, returns all of them. if not arr: return [] count = Counter(arr) max_count = max(count.values()) modes = [key for key, value in count.items() if value == max_count] return modes"},{"question":"You are tasked with finding the missing number in a list of unique integers from the range [0..n]. If no number is missing, the function should return the next number in the sequence. Implement this functionality efficiently. # Requirements: - **Input**: A list of unique integers `nums` of length n-1, representing the range [0..n] with one missing number. - **Output**: The missing number, or the next number after the last element if no number is missing. # Function Signature: ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Constraints: - The input list will contain unique integers within the range 0 to n. - The list is of size `n-1`. - The difference between consecutive integers cannot be more than 1. # Examples: Example 1: ```python Input: nums = [4, 0, 3, 1, 2] Output: 5 Explanation: The numbers 0 through 4 are present. Hence, the missing number is 5. ``` Example 2: ```python Input: nums = [0, 1, 3] Output: 2 Explanation: The number 2 is missing from the sequence. ``` Example 3: ```python Input: nums = [1, 2, 0] Output: 3 Explanation: The numbers 0 through 2 are present. Hence, the missing number is 3. ``` # Implementation: Write your solution using either an XOR approach or an arithmetic sum approach to achieve the desired results efficiently.","solution":"def find_missing_number(nums): Finds the missing number in the list of integers from 0 to n or returns the next number if no number is missing. nums: List[int] - a list of unique integers return: int - the missing number or the next number in the sequence n = len(nums) + 1 # Calculate the total sum of numbers from 0 to n expected_sum = n * (n - 1) // 2 actual_sum = sum(nums) # The missing number is the difference between expected sum and actual sum missing_number = expected_sum - actual_sum return missing_number"},{"question":"You are tasked with designing a function to count the number of digits in a given integer. This function must be efficient and handle both positive and negative integers correctly. # Function Signature: ```python def count_digits(n: int) -> int: pass ``` # Input/Output: * **Input**: A single integer `n`, which can be positive, negative, or zero. - Constraints: -10^{18} leq n leq 10^{18} * **Output**: An integer representing the number of digits in the absolute value of `n`. # Example: ```python assert count_digits(0) == 1 assert count_digits(123) == 3 assert count_digits(-12345) == 5 assert count_digits(999999999999) == 12 ``` # Requirements: 1. The solution should run in constant time, O(1). 2. Ensure correctness for edge cases, including zero and negative numbers. 3. Avoid unnecessary conversions or loops. # Scenario: You are working as a software engineer yourself and frequently encounter scenarios where you need to quickly determine the number of digits in various numbers for formatting output, validating entries, or numerical operations. For example, given a large dataset of numbers, efficient and quick verification of digit length might be crucial. Write the function `count_digits` adhering to the requirements and ensuring it performs well under the constraints provided.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the absolute value of the given integer n. return len(str(abs(n)))"},{"question":"# Cycle Detection in Directed Graph Context: You are working on a project that ensures a system with multiple processes does not enter a deadlock state. Each process is represented as a vertex and there exists a directed edge from process A to process B if process A is waiting for process B to release a resource. Your task is to determine if the system has any cycles, as cycles represent potential deadlocks. Task: Implement a function named `detect_cycle` that determines if a directed graph contains any cycles. The function should use cycle detection via Depth-First Search (DFS) and utilize state marking (WHITE, GRAY, BLACK) to efficiently track traversal progress and detect cycles. Update the function `contains_cycle(graph)` and ensure it adheres to the following criteria: Function Description: * **Function Name**: `contains_cycle` * **Input**: A dictionary `graph` representing the directed graph. Example format: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` * **Output**: Boolean value `True` if the graph contains a cycle, `False` otherwise. * **Constraints**: - Each vertex in the graph is a unique string identifier. - The graph can have up to 10^4 vertices and 10^4 edges. Examples: 1. **Example 1**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True ``` 2. **Example 2**: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(contains_cycle(graph)) # Output: False ``` Your implementation should ensure it handles edge cases and performs efficiently for larger graphs.","solution":"def contains_cycle(graph): Detects if there is a cycle in the directed graph. :param graph: Dictionary representing the directed graph :return: Boolean value indicating the presence of a cycle WHITE, GRAY, BLACK = 0, 1, 2 def dfs(node): state[node] = GRAY for neighbor in graph.get(node, []): if state[neighbor] == GRAY: return True if state[neighbor] == WHITE and dfs(neighbor): return True state[node] = BLACK return False state = {node: WHITE for node in graph} for node in graph: if state[node] == WHITE: if dfs(node): return True return False"},{"question":"# Question: Implement Enhanced Rabin-Miller Primality Test You are tasked with implementing an enhanced version of the Rabin-Miller Primality Test. The enhanced version will include more flexibility and some error handling for odd cases. Write a function `enhanced_is_prime(n: int, k: int = 5) -> str` that determines if a given integer ( n ) is a prime number using the Rabin-Miller Primality Test with improved accuracy. # Function Signature ```python def enhanced_is_prime(n: int, k: int = 5) -> str: pass ``` # Input - `n` (int): The integer to test for primality. - `k` (int, optional): The number of iterations for the test\'s accuracy (default is 5). # Output - `str`: Return `\'Prime\'` if the input integer ( n ) is a probable prime, otherwise return `\'Composite\'`. # Constraints - ( n ) must be a non-negative integer (( n geq 0 )). - The algorithm should handle large values up to ( 10^{18} ). # Examples ```python print(enhanced_is_prime(29)) # Output: \'Prime\' print(enhanced_is_prime(15)) # Output: \'Composite\' print(enhanced_is_prime(2)) # Output: \'Prime\' print(enhanced_is_prime(0)) # Output: \'Composite\' print(enhanced_is_prime(1)) # Output: \'Composite\' print(enhanced_is_prime(104729, 10)) # Output: \'Prime\' ``` # Hints & Considerations 1. Extend the base implementation to handle edge cases like ( n = 0 ) or ( n = 1 ). 2. Use appropriate checks and balances to avoid large computation errors. 3. Ensure efficient handling of modular operations to maintain performance. 4. Consider the provided default value of `k` for typical scenarios.","solution":"import random def enhanced_is_prime(n: int, k: int = 5) -> str: Enhanced Rabin-Miller Primality Test with error handling. Determines if a given integer is a prime number. Parameters: n (int): The integer to test for primality. k (int, optional): The number of iterations for the test\'s accuracy (default is 5). Returns: str: \'Prime\' if n is a probable prime, otherwise \'Composite\'. if n <= 1: return \'Composite\' if n <= 3: return \'Prime\' if n % 2 == 0: return \'Composite\' # Find d such that d * 2^r = n-1 with d odd d = n - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 # Check compositeness using the Rabin-Miller primality test def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return \'Composite\' return \'Prime\'"},{"question":"# Question Context A traditional stack is useful for various computational tasks that require reversal, backtracking, and nested structures. However, many new systems handle concurrent operations that still need a stack-like structure but can handle multiple threads pushing and popping concurrently. The implementation for such a concurrent stack can be significantly different to handle synchronization between threads efficiently. # Task Implement a Concurrent Stack (Thread-Safe Stack) using a Linked List in Python. Here is the interface you need to implement: ```python class ConcurrentLinkedListStack: def __init__(self): Initializes a new instance of ConcurrentLinkedListStack. pass def push(self, item): Adds a new item to the top of the stack. This method should be thread-safe. Args: item: The item to be added to the stack. pass def pop(self): Removes the top item from the stack and returns it. This method should be thread-safe. Raises IndexError if the stack is empty. Returns: The top item. pass def peek(self): Returns the top item from the stack without removing it. This method should be thread-safe. Raises IndexError if the stack is empty. Returns: The top item. pass def is_empty(self): Returns True if the stack is empty, else False. This method should be thread-safe. Returns: bool: indicating whether the stack is empty. pass ``` # Constraints and Requirements * You must make sure that the stack operations are thread-safe. * You should handle synchronization issues using appropriate synchronization mechanisms (locks). * Python\'s built-in `threading` module is allowed and encouraged. * Assume that the stack will be used with multiple threads calling push and pop concurrently. # Example Usage ```python import threading stack = ConcurrentLinkedListStack() def worker_push(stack, item): stack.push(item) def worker_pop(stack): try: return stack.pop() except IndexError: return None threads = [] for i in range(5): thread = threading.Thread(target=worker_push, args=(stack, i,)) threads.append(thread) thread.start() for thread in threads: thread.join() # Stack should have 5 items while not stack.is_empty(): print(stack.pop()) ``` # Notes - Ensure that synchronization is minimal to avoid performance bottlenecks. - Test your implementation thoroughly with multiple threads to identify potential concurrency issues.","solution":"import threading class Node: def __init__(self, value, next_node=None): self.value = value self.next = next_node class ConcurrentLinkedListStack: def __init__(self): self.head = None self.lock = threading.Lock() def push(self, item): with self.lock: new_node = Node(item) new_node.next = self.head self.head = new_node def pop(self): with self.lock: if self.head is None: raise IndexError(\\"Pop from an empty stack\\") popped_value = self.head.value self.head = self.head.next return popped_value def peek(self): with self.lock: if self.head is None: raise IndexError(\\"Peek from an empty stack\\") return self.head.value def is_empty(self): with self.lock: return self.head is None"},{"question":"Minimum Deletions to Match Strings Problem Statement You are given two strings, word1 and word2. You need to compute the minimum number of steps required to make the two strings identical. In each step, you can delete one character from either string. Write a function to accomplish this. Function Signature ```python def min_steps_to_match(word1: str, word2: str) -> int: ``` Input * word1 (string): The first input string (1 ≤ length ≤ 500). * word2 (string): The second input string (1 ≤ length ≤ 500). Output * An integer representing the minimum number of steps to make both strings identical by only deleting characters. Constraints * The strings consist only of lowercase English letters. Example * Example 1: - Input: `\\"sea\\"`, `\\"eat\\"` - Output: `2` - Explanation: To make \'sea\' and \'eat\' the same, delete \'s\' from \\"sea\\" and \'t\' from \\"eat\\". * Example 2: - Input: `\\"ABCDE\\"`, `\\"BDE\\"` - Output: `2` - Explanation: Deleting \'A\' and \'C\' from \\"ABCDE\\" makes both strings identical. Notes * Consider edge cases such as one or both strings being empty. * Ensure that your function handles strings of large lengths efficiently. Solution Approach 1. **Initialization**: Use dynamic programming to build a matrix where `dp[i][j]` represents the minimum steps to make the substrings `word1[:i]` and `word2[:j]` identical. 2. **Base Cases**: Initialize the matrix considering boundary conditions (empty substrings). 3. **Matrix Population**: - If characters match, inherit the diagonal value. - If characters do not match, take the minimum from the left and top, and add one for the deletion. 4. **Result Extraction**: The value at the bottom-right cell of the matrix gives the required result. Good luck!","solution":"def min_steps_to_match(word1: str, word2: str) -> int: len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): for j in range(len2 + 1): if i == 0: dp[i][j] = j # If first string is empty, remove all from second elif j == 0: dp[i][j] = i # If second string is empty, remove all from first elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) return dp[len1][len2]"},{"question":"Context You are working as a software developer and need to implement a function to rotate a linked list. This operation is common in scenarios where list data needs to be re-ordered based on certain periodic operations or patterns. Problem Statement Given a singly-linked list, rotate the list to the right by k places, where k is a non-negative integer. The list should rotate such that the end of the list connects back to the front, essentially moving elements to the right by k places while maintaining the relative order of elements. Function Signature ```python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode pass ``` Input and Output * **Input**: * `head` (ListNode): The head of the singly-linked list. * `k` (int): The number of positions to rotate the list. * **Output**: * Returns the head of the rotated linked list. Examples ```python Given 1->2->3->4->5->NULL and k = 2, the function should return 4->5->1->2->3->NULL. Given 0->1->2->NULL and k = 4, the function should return 2->0->1->NULL. ``` Constraints and Considerations 1. k is a non-negative integer. 2. The length of the list is a non-negative integer. 3. You must handle cases where the list is empty or has only one node. 4. If k is greater than or equal to the length of the list, consider `k = k % length` to reduce unnecessary cycles. Performance Requirements - Ensure the solution has an O(n) time complexity. - Ensure the solution has an O(1) space complexity by rotating the list in-place.","solution":"class ListNode(object): def __init__(self, x): self.val = x self.next = None def rotate_right(head, k): if not head or k == 0: return head # Compute the length of the linked list length = 1 tail = head while tail.next: tail = tail.next length += 1 # If k is larger than length, compute effective rotations needed k = k % length if k == 0: return head # Find the new tail of the rotated list new_tail_position = length - k - 1 new_tail = head for i in range(new_tail_position): new_tail = new_tail.next # The new head is the next node of the new tail new_head = new_tail.next new_tail.next = None tail.next = head return new_head"},{"question":"**Objective**: To assess the understanding of hashing, sorting, and manipulation of strings in Python. **Scenario**: You are working on a system that needs to group similar items together based on their content. This is common in scenarios like text processing, search engines, and data clustering. **Task**: Given an array of strings, write a function `group_anagrams` that will group the anagrams together. **Function Signature**: ``` def group_anagrams(strs: List[str]) -> List[List[str]]: ``` **Input**: - `strs` (List[str]): A list of strings (1 ≤ len(strs) ≤ 10^4, 1 ≤ len(str) ≤ 1000). **Output**: - A list of lists, where each sublist contains strings that are anagrams of each other. **Constraints**: - The input strings only contain lowercase English letters. - Each string in the input is unique in terms of memory reference, though strings might be anagrams of each other. **Example**: ```python # Input: group_anagrams([\'eat\', \'tea\', \'tan\', \'ate\', \'nat\', \'bat\']) # Output: [ [\'ate\', \'eat\', \'tea\'], [\'nat\', \'tan\'], [\'bat\'] ] ``` # Detailed Requirements - Ensure the function has a time complexity of O(N*KlogK) or better. - Handle edge cases such as empty input and single string input. - Do not modify the input list. - The output order of the sublists and the order of strings within each sublist does not matter. **Additional Challenge**: - Optimize for space where possible. - Consider the character counting method as an alternative approach and analyze its advantages.","solution":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from a list of strings. Args: strs (List[str]): A list of strings Returns: List[List[str]]: A list of lists containing grouped anagrams anagrams = defaultdict(list) for s in strs: # Sort the string and use it as the key key = \'\'.join(sorted(s)) anagrams[key].append(s) return list(anagrams.values())"},{"question":"Scenario: You are a software developer tasked with implementing a function that reverses a singly linked list. This functionality is critical for processes that require operations on data in a reversed order, such as undo functionality in text editors or converting queue operations into stack operations. To ensure the robustness of your function, consider handling edge cases like empty lists and single-node lists. Your implementation should maintain efficiency in terms of both time and space complexity. Task: Write a function `reverse_singly_linked_list` using an iterative approach to reverse a singly linked list. Requirements: * **Input**: The head of a singly linked list. * **Output**: The head of the reversed singly linked list. Function Signature: ```python def reverse_singly_linked_list(head: ListNode) -> ListNode: pass ``` Constraints: * The list can contain up to (10^5) nodes. * Each node\'s value is an integer. Example: ```python # Definition for a singly linked list node. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Helper function to create a list from array def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list to array def linked_list_to_array(head): arr = [] while head: arr.append(head.val) head = head.next return arr # Example usage: head = create_linked_list([1, 2, 3, 4]) reversed_head = reverse_singly_linked_list(head) assert linked_list_to_array(reversed_head) == [4, 3, 2, 1] ``` Note: - Clearly comment your code. - Ensure you handle edge cases as specified. - Aim for O(n) time complexity and O(1) space complexity.","solution":"# Definition for a singly linked list node. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_singly_linked_list(head: ListNode) -> ListNode: Reverse a singly linked list. Args: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed singly linked list. prev = None # Initialize previous node as None current = head # Start with the head of the list while current: next_node = current.next # Store the next node current.next = prev # Reverse the link prev = current # Move prev to current node current = next_node # Move to the next node in the list return prev # prev will be the new head of the reversed list"},{"question":"# Question: Implement a Custom HashTable with Key-Tracking Context: Imagine you are developing a new feature for a memory-optimized caching system which requires direct access to keys inserted in a hash table. You need to implement a specialized HashTable that supports regular operations (`put`, `get`, `del_`), but also allows you to retrieve all keys without duplicates in the same order they were inserted. Task: Implement a class `TrackingHashTable` that extends the given `HashTable` class. This class should: 1. Maintain insertion order of keys. 2. Provide a method `keys()` that returns a list of keys in the order they were inserted. Requirements: * **Input**: - `put(key, value)`: Inserts or updates the key-value pair. - `get(key)`: Returns the value associated with the key. - `del_(key)`: Deletes the key-value pair. * **Output**: - `keys()`: Returns a list of keys in the order they were inserted. * **Constraints**: - `TrackingHashTable` should handle resizing as efficiently as the `ResizableHashTable`. Example: ```python ht = TrackingHashTable() ht.put(1, \'A\') ht.put(2, \'B\') ht.put(1, \'C\') ht.del_(2) ht.put(3, \'D\') print(ht.keys()) # Output: [1, 3] (1 was overwritten, 2 was deleted) ``` Note: * Your implementation should ensure minimal overhead in tracking keys, and maintain efficiency as the number of operations grows.","solution":"class TrackingHashTable: def __init__(self): self.table = {} self.order = [] def put(self, key, value): if key not in self.table: self.order.append(key) self.table[key] = value def get(self, key): return self.table.get(key, None) def del_(self, key): if key in self.table: del self.table[key] self.order.remove(key) def keys(self): return self.order"},{"question":"# Graph Traversal Challenge You are required to implement functions to perform graph traversal using DFS and BFS. Graphs will be represented as adjacency lists. Task 1. Implement a function `dfs(graph: Dict[int, List[int]], start: int) -> List[int]` that performs a depth-first traversal of a graph. 2. Implement a function `bfs(graph: Dict[int, List[int]], start: int) -> List[int]` that performs a breadth-first traversal of a graph. Input * `graph`: A dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes. * `start`: The starting node for the traversal. Output * The functions should return a list of nodes in the order they were visited. Example Given the graph: ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [] } ``` And starting node `start = 1`: * For `dfs(graph, start)`, the expected output could be `[1, 3, 4, 2]` (or any valid DFS order starting from 1). * For `bfs(graph, start)`, the expected output is `[1, 2, 3, 4]`. Constraints * Assume the graph is a directed graph. * The graph does not contain any weights on edges. * Node identifiers are positive integers. * The graph can have up to 1000 nodes. ```python # Write your implementations here. def dfs(graph: Dict[int, List[int]], start: int) -> List[int]: # Your implementation for DFS (iterative or recursive) pass def bfs(graph: Dict[int, List[int]], start: int) -> List[int]: # Your implementation for BFS pass ``` Your implementation should handle edge cases such as: * Graph with cycles. * Disconnected nodes. * Graph with a single node. * Ensuring no infinite loops in the presence of cycles.","solution":"from typing import List, Dict def dfs(graph: Dict[int, List[int]], start: int) -> List[int]: Perform a depth-first traversal of a graph. visited = set() result = [] def dfs_util(node): if node not in visited: visited.add(node) result.append(node) for neighbor in graph.get(node, []): dfs_util(neighbor) dfs_util(start) return result def bfs(graph: Dict[int, List[int]], start: int) -> List[int]: Perform a breadth-first traversal of a graph. visited = set() result = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) result.append(node) queue.extend([neighbor for neighbor in graph.get(node, []) if neighbor not in visited]) return result"},{"question":"Shell Sort with Optimized Gap Sequence Background Shell Sort is a generalized version of insertion sort that allows the exchange of items that are far apart. The idea is to arrange the list of elements so that starting anywhere, taking every (k)th element produces a sorted list. Then, a smaller value of (k) is chosen and the process is repeated. Once (k) equals 1, the list is fully sorted in a final pass. Task Implement the Shell Sort algorithm using Sedgewick\'s gap sequence. The Sedgewick sequence is a predefined sequence known to provide better average-case performance than the simple (n/2, n/4, ldots, 1) sequence. Sedgewick\'s sequence starts as follows: 1, 5, 19, 41, 109, ... Function Signature ```python def shell_sort_sedgewick(arr: List[int]) -> List[int]: ``` Input and Output * **Input**: A list of integers `arr` (1 ≤ `len(arr)` ≤ 100_000), containing positive or negative integers. * **Output**: The list sorted in non-decreasing order. Constraints * Implement the sorting algorithm using the Sedgewick gap sequence. * Aim for optimal performance in both typical and edge cases. Example ```python >>> shell_sort_sedgewick([23, -1, 45, 21, 87, 3, -2]) [-2, -1, 3, 21, 23, 45, 87] >>> shell_sort_sedgewick([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] ``` Requirements * Do not use Python\'s built-in sorting functions. * Ensure the solution handles edge cases such as single-element arrays and already sorted arrays effectively. * Provide comprehensive comments within the code for clarity. Good luck! Your implementation should be efficient and make good use of the provided gap sequence for optimal performance.","solution":"from typing import List def shell_sort_sedgewick(arr: List[int]) -> List[int]: Sort the array using Shell Sort with Sedgewick\'s gap sequence. :param arr: List of integers to be sorted :return: Sorted list of integers n = len(arr) # Sedgewick\'s gap sequence starts: 1, 5, 19, 41, 109, ... gaps = [] k = 0 while True: gap1 = 9 * (4**k - 2**k) + 1 gap2 = 4**(k + 2) - 3 * 2**(k + 2) + 1 if gap1 < n: gaps.append(gap1) if gap2 < n: gaps.append(gap2) if gap1 >= n and gap2 >= n: break k += 1 gaps.sort(reverse=True) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"You are given an array that may contain duplicates. Your task is to remove the duplicates from the array and return a new array that contains only unique elements, while preserving the order of their first occurrence. # Function Signature ```python def remove_duplicates(array: list) -> list: # Your code here ``` # Input * The function receives a single parameter: - `array` (list) - An array of elements (Can include multiple types like integers, strings, booleans, etc.) # Output * The function should return: - A new list containing only the unique elements, preserving the order as they first appeared in the input array. # Example ```python assert remove_duplicates([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \'hey\', \'hello\'] assert remove_duplicates([]) == [] assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4] ``` # Constraints * Your solution should aim for a better time complexity than O(n^2). * The array can contain elements of mixed types (i.e., int, str, bool, etc.). * You must preserve the original order of elements in the array. # Hints - Consider using a data structure that provides efficient membership testing.","solution":"def remove_duplicates(array: list) -> list: Remove duplicates from the given array while preserving the order of their first occurrence. seen = set() unique_array = [] for item in array: if item not in seen: unique_array.append(item) seen.add(item) return unique_array"},{"question":"# Question: Extended Insertion Sort for Intervals You are given an array of integers and a list of intervals. Your task is to implement a function that sorts only the specified intervals in the array using the Insertion Sort algorithm while keeping the other parts of the array unchanged. Function Signature ```python def sort_intervals(arr: List[int], intervals: List[Tuple[int, int]]) -> List[int]: pass ``` # Input - `arr` : A list of integers `[-10^6, 10^6]`. - `intervals` : A list of tuple intervals `[(start1, end1), (start2, end2), ...]` and each interval `[start, end]` specifies the start and end indices (inclusive) in `arr` to sort using Insertion Sort. # Output - A new list where each specified interval has been sorted using Insertion Sort, and the other parts of the list remain unchanged. # Constraints - The intervals are non-overlapping and within the bounds of the list. - The length of the intervals list will be up to `10^4`. # Example ```python arr = [9, 7, 5, 3, 8, 6, 1, 4] intervals = [(0, 3), (4, 7)] sort_intervals(arr, intervals) # Output: [3, 5, 7, 9, 1, 4, 6, 8] ``` **Explanation**: - The interval from index 0 to 3 is sorted: [3, 5, 7, 9, 8, 6, 1, 4] - The interval from index 4 to 7 is sorted: [3, 5, 7, 9, 1, 4, 6, 8] # Notes 1. Consider edge cases such as empty intervals, intervals at the boundaries of the list, and lists that already meet sorting criteria within the interval. 2. Aim to maintain the time complexity close to O(n*m) where n is the length of the array and m is the number of intervals.","solution":"from typing import List, Tuple def sort_intervals(arr: List[int], intervals: List[Tuple[int, int]]) -> List[int]: def insertion_sort(sub_arr: List[int]) -> List[int]: for i in range(1, len(sub_arr)): key = sub_arr[i] j = i - 1 while j >= 0 and key < sub_arr[j]: sub_arr[j + 1] = sub_arr[j] j -= 1 sub_arr[j + 1] = key return sub_arr arr_copy = arr[:] for start, end in intervals: sub_arr = arr_copy[start:end+1] sorted_sub_arr = insertion_sort(sub_arr) arr_copy[start:end+1] = sorted_sub_arr return arr_copy"},{"question":"# Problem Scenario You are developing a scientific calculator application that requires precise computation of square roots for various mathematical calculations. To ensure accuracy and performance, you are to implement a function that will approximate the square root of a given positive integer using Newton\'s Method with a specified precision. # Question Write a function `compute_square_root(N: int, epsilon: float=0.001) -> float` that computes the square root of a given positive integer ( N ) such that the absolute error is no more than ( epsilon ). Function Signature ```python def compute_square_root(N: int, epsilon: float=0.001) -> float: # Your code here ``` Input * `N` (1 ≤ N ≤ 10^9): A positive integer whose square root needs to be approximated. * `epsilon` (0 < epsilon ≤ 1): A floating-point number representing the maximum allowable error in the result. Output * Returns a floating-point number `x` such that ( |x^2 - N| < epsilon ). Constraints - The function should handle large values of ( N ) efficiently. - All calculations should be done using floating-point arithmetic. Example ```python assert 2.235 < compute_square_root(5, 0.001) < 2.237 assert 3.160 < compute_square_root(10, 0.001) < 3.162 assert 1.999 < compute_square_root(4, 0.001) < 2.001 ``` Implement the `compute_square_root` function ensuring the criteria of precision and efficiency are met.","solution":"def compute_square_root(N: int, epsilon: float=0.001) -> float: Computes the square root of a given positive integer N using Newton\'s method, with a specified precision epsilon. Parameters: N (int): The positive integer whose square root needs to be computed. epsilon (float): The maximum allowable error in the result. Returns: float: The approximate square root value of N. # Initial guess will be half of N or 1 if N is 1. x = N / 2 if N > 1 else 1.0 while True: # Compute a better approximation of the root. root = 0.5 * (x + N / x) # If the difference is within the desired precision, return the root. if abs(root - x) < epsilon: return root x = root"},{"question":"# Coding Problem: Graph Cloning with BFS and DFS Objective: You are provided with a class representing an undirected graph node, and two initial functions: `clone_graph_bfs` and `clone_graph_dfs`. Your task is to complete the implementation of these two functions to correctly clone an undirected graph using BFS and DFS strategies respectively. Class Definitions: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def add_neighbor(self, node): self.neighbors.append(node) ``` Function Definitions: * `clone_graph_bfs`: Clone the graph using Breadth-First Search (BFS). * `clone_graph_dfs`: Clone the graph using Depth-First Search (DFS). Input: * The input will be a single node of an undirected graph `node`. The node labels are unique. Output: * The output should be the cloned graph\'s corresponding node. Constraints: * The graph can have up to `10^4` nodes. * Each node can have up to `10^4` neighbors. * Node labels are nonnegative integers. * The graph may contain cycles and self-loops. Example: Consider the serialized graph {0,1,2#1,2#2,2}: ```python # Visual graph representation: # 1 # / # / # 0 --- 2 # / # _/ # Here is the graph\'s code form node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.add_neighbor(node1) node0.add_neighbor(node2) node1.add_neighbor(node2) node2.add_neighbor(node2) cloned_graph_bfs = clone_graph_bfs(node0) cloned_graph_dfs = clone_graph_dfs(node0) ``` Requirements: 1. Implement `clone_graph_bfs` using BFS algorithm. 2. Implement `clone_graph_dfs` using DFS algorithm, either iteratively or recursively. # Template: ```python import collections class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def add_neighbor(self, node): self.neighbors.append(node) def clone_graph_bfs(node): if not node: return None # Implement your BFS graph cloning here def clone_graph_dfs(node): if not node: return None # Implement your DFS graph cloning here ``` Implement your solution within the given template ensuring that both BFS and DFS versions are correctly handling the graph cloning.","solution":"import collections class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def add_neighbor(self, node): self.neighbors.append(node) def clone_graph_bfs(node): if not node: return None cloned_nodes = {} queue = collections.deque([node]) cloned_nodes[node.label] = UndirectedGraphNode(node.label) while queue: current_node = queue.popleft() for neighbor in current_node.neighbors: if neighbor.label not in cloned_nodes: cloned_nodes[neighbor.label] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) cloned_nodes[current_node.label].add_neighbor(cloned_nodes[neighbor.label]) return cloned_nodes[node.label] def clone_graph_dfs(node): if not node: return None cloned_nodes = {} def dfs(current_node): if current_node.label in cloned_nodes: return cloned_nodes[current_node.label] cloned_node = UndirectedGraphNode(current_node.label) cloned_nodes[current_node.label] = cloned_node for neighbor in current_node.neighbors: cloned_node.add_neighbor(dfs(neighbor)) return cloned_node return dfs(node)"},{"question":"You are given a singly linked list with possible duplicate values. Your task is to write a function to remove all duplicates from the list without using any auxiliary space (other than pointers). Specifically, you should implement the function: ```python def remove_duplicates_without_extra_space(head): pass ``` # Input - The function will receive as its input the head of a singly linked list. - Each node in the list contains an integer value. # Output - The function should return the modified linked list\'s head with all duplicates removed. # Example ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head: string += str(head.val) + \\" -> \\" head = head.next string = string.rstrip(\\" -> \\") print(string) # Input Linked List: 3 -> 5 -> 3 -> 5 -> 8 -> 10 -> 8 a = Node(3) b = Node(5) c = Node(3) d = Node(5) e = Node(8) f = Node(10) g = Node(8) a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g new_head = remove_duplicates_without_extra_space(a) print_linked_list(new_head) # Expected Output: 3 -> 5 -> 8 -> 10 ``` # Constraints - Do not use any additional space for data structures such as arrays, lists, etc. - The solution should be efficient enough to handle up to 10^5 nodes in the list. # Notes - Pay attention to edge cases like an empty list or lists with all unique elements. - Carefully handle pointer updates to maintain the integrity of the linked list.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_without_extra_space(head): if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: # Bypass the duplicate node runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Prime Number Identification and List Generation Given an integer `M`, write a function `generate_primes(M)` that generates a list of prime numbers up to a given number `M` (inclusive). # Function Signature ```python def generate_primes(M: int) -> list: pass ``` # Input * An integer `M` where `M >= 0`. # Output * A list of all prime numbers up to `M` (inclusive). # Constraints * The function should efficiently generate prime numbers up to any number `M` within a reasonable upper limit (for instance, M <= 10^6). * The implementation should leverage the `prime_check` function provided to ensure clarity and modularity. # Example ```python generate_primes(10) # Returns: [2, 3, 5, 7] generate_primes(20) # Returns: [2, 3, 5, 7, 11, 13, 17, 19] generate_primes(1) # Returns: [] generate_primes(0) # Returns: [] generate_primes(2) # Returns: [2] ``` # Requirements * Utilize the given `prime_check` function within your implementation. * The solution must handle edge cases such as `M = 0`, `M = 1`, and negative `M`. # Scenario This function could be used in various algorithmic challenges requiring prime number lists, such as in cryptographic key generation, mathematical research, or competitive programming contests.","solution":"def is_prime(n): Check if a number is prime. Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_primes(M): Generate a list of all prime numbers up to a given number M (inclusive). primes = [] for num in range(2, M + 1): if is_prime(num): primes.append(num) return primes"},{"question":"# Code Challenge Problem Statement You are given a text `text` and a pattern `pattern`. Your task is to implement the Knuth-Morris-Pratt (KMP) string matching algorithm to find all occurrences of the pattern in the text and return a list of starting indices where the pattern is found. Function Signature ```python from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: pass ``` Input * `text` (Sequence[str]): A non-empty string representing the text in which the pattern is to be searched. * `pattern` (Sequence[str]): A string representing the pattern to be searched in the `text`. Output * `List[int]`: A list of non-negative integers representing the starting indices where the pattern is found. Constraint * The length of the `text` and `pattern` will not exceed 10^5. Example ```python text = \\"abcabcabcd\\" pattern = \\"abcab\\" output = knuth_morris_pratt(text, pattern) print(output) # Expected output: [0, 3] ``` Guidelines 1. Implement the prefix table (pi array) to store the length of the longest proper prefix which is also a suffix for each prefix of the pattern. 2. Utilize the prefix table to perform the pattern search efficiently by avoiding redundant comparisons. 3. Ensure your implementation handles the edge cases like zero-length pattern or text and patterns not existing in the text. 4. Aim for a time complexity of O(N+M) and space complexity of O(M). Additional Context (if necessary) Consider edge cases such as overlapping patterns and patterns that match at the beginning or end of the text.","solution":"from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: if not pattern: return [] # Preprocess pattern to create the longest prefix suffix (LPS) array lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 # Building the LPS array while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 result = [] i = 0 # index for text j = 0 # index for pattern # Perform the actual pattern matching using the LPS array while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Question You are given a class, `SeparateChainingHashTable`, which implements a hash table using separate chaining for collision resolution. Complete the implementation by adding the following functionality: 1. **Resizing**: Implement a method to resize the hash table when the load factor exceeds a certain threshold (e.g., 0.75). The new table should be twice the size of the current one. 2. **Iterator**: Implement an iterator to iterate over all key-value pairs in the hash table. 3. **Clear**: Implement a method to clear all entries in the hash table. # Requirements * **Function Specifications**: * `resize(self)`: Should resize the hash table when the load factor exceeds 0.75. * `__iter__(self)`: Should return an iterator over all key-value pairs. * `clear(self)`: Should clear the hash table. * **Input/Output Formats**: * No inputs required for the functions. * `resize` and `clear` methods return `None`. * `__iter__` method should return an iterator of key-value pairs (tuple). # Input Constraints * Keys are strings. * Values can be of any type. * The hash table size should initially be a prime number (e.g., 11). # Example ```python # Create a hash table table = SeparateChainingHashTable() # Adding key-value pairs table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) # Resize when load factor exceeds 0.75 table.resize() # Iterating over the table for key, value in table: print(key, value) # Clear the table table.clear() print(len(table)) # Output should be 0 ``` # Implementation You need to add the following methods to the `SeparateChainingHashTable` class: ```python class SeparateChainingHashTable(object): # Existing methods ... def resize(self): # Implement this method pass def __iter__(self): # Implement this method pass def clear(self): # Implement this method pass # Existing methods ... ``` Use the provided class template and complete the missing parts.","solution":"class SeparateChainingHashTable(object): def __init__(self, initial_size=11): self.table = [[] for _ in range(initial_size)] self.size = 0 self.threshold = 0.75 def hash_function(self, key): return hash(key) % len(self.table) def put(self, key, value): index = self.hash_function(key) for item in self.table[index]: if item[0] == key: item[1] = value return self.table[index].append([key, value]) self.size += 1 if self.size / len(self.table) > self.threshold: self.resize() def get(self, key): index = self.hash_function(key) for item in self.table[index]: if item[0] == key: return item[1] return None def remove(self, key): index = self.hash_function(key) for item in self.table[index]: if item[0] == key: self.table[index].remove(item) self.size -= 1 return True return False def resize(self): new_size = len(self.table) * 2 new_table = [[] for _ in range(new_size)] for chain in self.table: for key, value in chain: index = hash(key) % new_size new_table[index].append([key, value]) self.table = new_table def __iter__(self): for chain in self.table: for key, value in chain: yield key, value def clear(self): self.table = [[] for _ in range(len(self.table))] self.size = 0"},{"question":"Problem Statement You are asked to write a function `full_path` that converts a potentially user-tilded or relative file path into its absolute path. Your function should handle normal user paths, expand user-tilded paths, and ensure the use of consistent absolute paths for all file or directory checks. # Input * A single string `file` representing the relative or user-tilded path to a file or directory. The string may be empty or `None`. # Output * A single string that is the absolute path of the given file or directory. # Constraints * You cannot use any external libraries, other than the standard `os` library. * Assume the input is always a valid string or `None`. # Performance Requirements * The solution should run efficiently given the constraints of typical file system paths in terms of length. # Example ```python import os def full_path(file): if file is None or file == \\"\\": return None return os.path.abspath(os.path.expanduser(file)) # Test Cases print(full_path(\\"~/Desktop\\")) # Example output on Unix: \\"/Users/username/Desktop\\" print(full_path(\\"../Documents\\")) # Example output given current directory path: \\"/full_path_to/../Documents\\" print(full_path(\\"file.txt\\")) # Example output given current directory path: \\"/full_path_to/file.txt\\" print(full_path(\\"\\")) # Output: None print(full_path(None)) # Output: None ``` # Additional Notes * Consider adding relevant error handling and invalid path checks to robustly handle various input scenarios.","solution":"import os def full_path(file): Converts a potentially user-tilded or relative file path into its absolute path. Parameters: - file (str): The relative or user-tilded path to a file or directory. Returns: - str: The absolute path of the given file or directory, or None if input is empty or None. if file is None or file == \\"\\": return None return os.path.abspath(os.path.expanduser(file))"},{"question":"# Pigeonhole Sort Implementation You are tasked with implementing the Pigeonhole Sort algorithm in Python. Your implementation should effectively sort an input list of integers where the number of elements and the range of the elements are close. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - A list of integers `arr` with the following constraints: - `1 <= len(arr) <= 10^5` - Each integer in the list will be between `-10^4` and `10^4`. Output - A list with the integers sorted in non-decreasing order. Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4, 6, 8]) == [2, 3, 4, 6, 7, 8, 8] assert pigeonhole_sort([-5, 2, -10, 7, -2, -3, 1, 0]) == [-10, -5, -3, -2, 0, 1, 2, 7] ``` Constraints - Your solution should handle edge cases such as an empty list, lists with identical elements, and lists with a single element. - Aim for an efficient solution in terms of both time and space complexity. - Ensure your function handles large inputs within the provided constraints effectively. Your task is to write a function `pigeonhole_sort` that fulfills the above requirements. Additionally, consider performance optimizations and edge case handling.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 holes = [[] for _ in range(range_size)] for num in arr: holes[num - min_val].append(num) sorted_arr = [] for hole in holes: sorted_arr.extend(hole) return sorted_arr"},{"question":"# File Path Resolver Function Context: You are developing a script that deals with various file operations. To avoid potential file path errors and ensure all paths are fully qualified, you need to resolve file paths to their absolute forms. This requirement is common in environments where users can input paths, and where scripts may use relative paths extensively. Problem Statement: Create a function named `resolve_path` that takes a single file path string and returns its absolute path. Your function should handle potential user home directory shortcuts (`~`) and ensure the final path is absolute. Function Signature: ```python def resolve_path(file_path: str) -> str: ``` Input: * `file_path` (str): A string representing the file path, which may be a relative path or use the `~` symbol for the user\'s home directory. Output: * Returns the absolute path as a string. Constraints: 1. The function should handle empty strings gracefully by returning an empty string. 2. The function should handle invalid path strings by raising a `ValueError` with the message \\"Invalid path\\". 3. Performance should be efficient enough for real-time applications. Example: ```python assert resolve_path(\\"~/documents/file.txt\\") == \\"/home/username/documents/file.txt\\" # Example for a Linux environment with user \'username\' assert resolve_path(\\"docs/readme.md\\") == \\"/current/directory/docs/readme.md\\" # Example assuming the script is run from /current/directory assert resolve_path(\\"\\") == \\"\\" assert resolve_path(\\"/absolute/path/to/file.txt\\") == \\"/absolute/path/to/file.txt\\" assert resolve_path(\\"??invalidpath/file.txt\\") # Should raise ValueError ``` Additional Notes: - You may use Python\'s built-in libraries to simplify path handling. - Consider the portability of your solution when handling different operating systems.","solution":"import os def resolve_path(file_path: str) -> str: Resolves a file path to its absolute path, handling user home directories and ensuring the path is fully qualified. Args: file_path (str): The input file path. Returns: str: The resolved absolute path. Raises: ValueError: If the file path is invalid. if file_path == \\"\\": return \\"\\" if not isinstance(file_path, str) or any(char in file_path for char in [\'?\', \'*\', \':\', \'<\', \'>\', \'|\']): raise ValueError(\\"Invalid path\\") return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# RSA Encryption Implementation and Analysis Problem Statement You are tasked with implementing a secure messaging system using the RSA encryption algorithm. Your program will include key generation, encryption, and decryption mechanisms. You must also write tests verifying the correctness of your implementation. Requirements 1. **Key Generation**: Implement the `generate_key(k, seed=None)` function to produce a public-private key pair with `k` bits. 2. **Encryption**: Implement the `encrypt(data, e, n)` function that encrypts a given integer `data` using public key components `(e, n)`. 3. **Decryption**: Implement the `decrypt(data, d, n)` function that decrypts the encrypted integer using private key component `(d)`. 4. **Testing**: Write tests to verify that an encrypted message can be correctly decrypted to the original message. Input and Output Formats - **generate_key(k, seed=None)**: - **Input**: `k` (int) - number of bits for the keys, `seed` (int, optional) - random seed for reproducibility. - **Output**: `(n, e, d)` (tuple of ints) - public key `(n, e)` and private key `(d)`. - **encrypt(data, e, n)**: - **Input**: `data` (int) - message to encrypt, `e` (int) - public exponent, `n` (int) - modulus. - **Output**: `encrypted_data` (int) - encrypted message. - **decrypt(data, d, n)**: - **Input**: `data` (int) - encrypted message, `d` (int) - private exponent, `n` (int) - modulus. - **Output**: `decrypted_data` (int) - original message. Constraints - k should be a positive integer that allows secure prime generation (commonly 1024 or 2048 bits for robust security). - data must be an integer within the range of the modulus `n`. - Ensure that the inverses and the modular exponentiation are computed efficiently. Sample Usage ```python # Generating RSA keys n, e, d = generate_key(16) # Encrypting data data = 42 encrypted = encrypt(data, e, n) # Decrypting data decrypted = decrypt(encrypted, d, n) # Verification assert decrypted == data, \\"Error: Decryption did not return the original data\\" ``` Implement the functions according to the problem statement and ensure that they handle edge cases appropriately. Your final implementation should securely encrypt and decrypt messages while verifying the correctness through testing.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits, seed=None): if seed is not None: random.seed(seed) while True: p = random.getrandbits(bits) if isprime(p): return p def generate_key(k, seed=None): p = generate_prime(k // 2, seed) q = generate_prime(k // 2, seed + 1 if seed is not None else None) n = p * q phi = (p - 1) * (q - 1) e = 65537 # commonly used prime exponent d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Question: Find nth Digit in Concatenated Sequence As a proficient programmer, you are tasked with implementing a function to determine the nth digit in an infinitely long sequence formed by concatenating positive integers. The sequence would be \\"123456789101112...\\" **Function Specification**: * Implement the following function: ```python def find_nth_digit(n: int) -> int: Find the nth digit in the infinite sequence of concatenated positive integers. Args: n (int): The position of the digit to find (1-indexed). Returns: int: The nth digit in the sequence. ``` **Input Format**: - An integer `n` representing the position of the digit in the sequence (1-indexed, 1 ≤ n ≤ 2^31 - 1). **Output Format**: - Return a single integer which is the nth digit of the infinite sequence. **Constraints**: - You must solve the problem without creating an infinite sequence explicitly. - The solution should be efficient with respect to time and space complexities. **Examples**: 1. For `n = 3`, the output should be `3`. Sequence: `123456789...` (3rd digit is `3`) 2. For `n = 11`, the output should be `0`. Sequence: `12345678910...` (11th digit is `0`) 3. For `n = 15`, the output should be `2`. Sequence: `1234567891011121314...` (15th digit is `2`) **Scenarios**: Imagine a scenario where you are building a digital billboard that dynamically highlights particular numeric characters based on their position in this endless concatenation of numbers. The function you\'re writing will help optimize how the billboard\'s software fetches and highlights the required digit without generating the entire sequence.","solution":"def find_nth_digit(n: int) -> int: Find the nth digit in the infinite sequence of concatenated positive integers. Args: n (int): The position of the digit to find (1-indexed). Returns: int: The nth digit in the sequence. # Initial values for current digit length, number of digits in this length, and the starting number of this length current_length = 1 current_count = 9 start = 1 # Determine which group of numbers (1-9, 10-99, 100-999...) contains the nth digit while n > current_length * current_count: n -= current_length * current_count current_length += 1 current_count *= 10 start *= 10 # Find the exact number within the determined group start += (n - 1) // current_length # Find the exact digit within the number s = str(start) return int(s[(n - 1) % current_length])"},{"question":"You are given a class representing a binary search tree (BST) node: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` # Task: Write a Python class `BST` with the following methods: 1. `insert(self, val: int) -> None`: Inserts a value into the BST. 2. `delete(self, val: int) -> None`: Deletes a value from the BST. 3. `search(self, val: int) -> bool`: Searches for a value in the BST and returns `True` if it exists, otherwise `False`. # Constraints: - Values inserted into the BST are unique. - The `delete` method must correctly handle all three cases: deleting a leaf node, deleting a node with one child, and deleting a node with two children. - The BST should maintain its properties (left child < parent < right child). # Example: ```python # Create an instance of BST bst = BST() # Insert elements bst.insert(5) bst.insert(3) bst.insert(7) # Search elements print(bst.search(3)) # Output: True print(bst.search(8)) # Output: False # Delete element bst.delete(3) print(bst.search(3)) # Output: False ``` # Additional Information: - You should not use any external libraries or frameworks. - Ensure efficiency, as the solution should handle large inputs efficiently. Implement the BST class with the above specifications.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node: TreeNode, val: int) -> None: if val < node.val: if not node.left: node.left = TreeNode(val) else: self._insert(node.left, val) else: if not node.right: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node: TreeNode, val: int) -> bool: if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node: TreeNode, val: int) -> TreeNode: if not node: return None if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: # node with the value found if not node.left: return node.right elif not node.right: return node.left temp_val = self._minValueNode(node.right) node.val = temp_val node.right = self._delete(node.right, temp_val) return node def _minValueNode(self, node: TreeNode) -> int: current = node while current.left: current = current.left return current.val"},{"question":"You are tasked with implementing a function that accurately splits a given path (be it a file path or a URL) into its directory and file components. The function should correctly handle the last occurrence of the `/` character to separate these two components. Function Signature ```python def split_path(path: str) -> List[str]: ``` Input - A single string `path` (1 ≤ |path| ≤ 10^4) representing a file path or URL. Output - A list of two strings: - The first string should contain the directory path. - The second string should contain the file name. Constraints - The input path will always be a valid path or URL. - The path will always contain at least one `/` character. Examples # Example 1 **Input**: `\\"https://algorithms/unix/test.py\\"` **Output**: `[\\"https://algorithms/unix\\", \\"test.py\\"]` # Example 2 **Input**: `\\"algorithms/unix/test.py\\"` **Output**: `[\\"algorithms/unix\\", \\"test.py\\"]` # Example 3 **Input**: `\\"/usr/local/bin/bash\\"` **Output**: `[\\"/usr/local/bin\\", \\"bash\\"]` # Example 4 **Input**: `\\"singlefile.txt\\"` **Output**: `[\\"\\", \\"singlefile.txt\\"]` # Example 5 **Input**: `\\"/onlydir/\\"` **Output**: `[\\"/onlydir\\", \\"\\"]` # Additional Directions - You must use Python\'s in-built functionalities to achieve the task. - Consider edge cases and validate your solution with multiple test cases. - Aim to write clean and readable code, providing comments where necessary.","solution":"def split_path(path: str) -> list: Splits the given path into directory and file components such that the last occurrence of the \\"/\\" character separates them. Parameters: path (str): The path to be split Returns: List[str]: A list containing the directory path and the file name. last_slash = path.rfind(\'/\') if last_slash == -1: return [\\"\\", path] directory = path[:last_slash] file = path[last_slash + 1:] return [directory, file]"},{"question":"# Question: Removing Duplicates from Unsorted Linked List You are given a singly linked list where each node contains an integer value. Your task is to write a function that removes all duplicate values from the linked list such that each value appears only once. You need to implement both of the following functions: 1. `remove_dups(head: Node) -> None`: * Removes duplicates from the linked list using additional memory for space efficiency. 2. `remove_dups_without_set(head: Node) -> None`: * Removes duplicates from the linked list without using any extra space, focusing on in-place operations. # Input and Output Formats Input: * `head`: A reference to the head of the linked list. Output: * None. The functions should modify the linked list in place. # Constraints * The length of the linked list will be between 0 and (10^4). * The values of the nodes will be integers within the range (-10^5) to (10^5). # Performance Requirements * `remove_dups` should run in (O(N)) time complexity. * `remove_dups_without_set` should run in (O(N^2)) time complexity and (O(1)) space complexity (in-place). # Example: Consider the linked list: ``` 3 -> 1 -> 3 -> 2 -> 2 -> 4 -> 1 ``` After calling `remove_dups`, the modified linked list should be: ``` 3 -> 1 -> 2 -> 4 ``` After calling `remove_dups_without_set`, the modified linked list should be: ``` 3 -> 1 -> 2 -> 4 ``` You may use the following definition of a node in your implementation: ```python class Node(): def __init__(self, val = None): self.val = val self.next = None ``` # Implementation Note Ensure your functions handle edge cases, such as an empty list and lists with all duplicate elements efficiently.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using additional memory for space efficiency. if not head: return current = head seen = set() prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any extra space. if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are given an unsigned integer and an index position of a bit you need to remove from its binary representation. Implement a function `remove_bit(num, i)` that removes the bit at the specified position `i` and returns the resulting integer. Be mindful of edge cases and input constraints. # Function Signature ```python def remove_bit(num: int, i: int) -> int: ``` # Input * `num`: A non-negative integer (0 <= num <= 2^31 - 1). * `i`: An integer specifying the bit position to remove (0 <= i < 31). # Output * Returns an integer representing the value after removing the specified bit in the binary representation of `num`. # Constraints * Ensure that `i` is a valid index within the bit-length of `num`. * Input constraints guarantee that `num` will be within the allowable range of non-negative integers. # Example ```python assert remove_bit(21, 2) == 9 assert remove_bit(21, 4) == 5 assert remove_bit(21, 0) == 10 assert remove_bit(0, 0) == 0 assert remove_bit(1, 0) == 0 ``` # Performance Requirements The solution should operate in constant time, O(1), using only constant additional space.","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at position i from the binary representation of num, and returns the resulting integer. Parameters: num (int): A non-negative integer. i (int): The bit position to remove. Returns: int: The resulting integer after removing the specified bit. # Split the number by removing the bit at position i lower_mask = (1 << i) - 1 higher_mask = ~((1 << (i+1)) - 1) lower_bits = num & lower_mask higher_bits = (num & higher_mask) >> 1 return higher_bits | lower_bits"},{"question":"Given two strings `s` and `t` which consist of only lowercase letters, where string `t` is generated by random shuffling string `s` and then adding one more letter at a random position, write a function `find_added_letter(s, t)` that finds the letter that was added in `t`. Function signature ```python def find_added_letter(s: str, t: str) -> str: pass ``` # Inputs * `s`: A string consisting of lowercase letters with length n. * `t`: A string consisting of lowercase letters with length n+1, formed by shuffling `s` and adding one additional letter. # Output * Return the additional letter in `t`. # Constraints * `0 <= n <= 10^5` * Both strings will contain only lowercase English letters. # Performance Requirements * The solution should work efficiently with a time complexity of O(n) and a space complexity of O(1). # Example ```python # Example 1 s = \\"abcd\\" t = \\"abcde\\" assert find_added_letter(s, t) == \'e\' # Example 2 s = \\"xyz\\" t = \\"xxyz\\" assert find_added_letter(s, t) == \'x\' # Example 3 s = \\"\\" t = \\"z\\" assert find_added_letter(s, t) == \'z\' ```","solution":"def find_added_letter(s: str, t: str) -> str: Finds the additional letter in t that is not present in s. Both strings consist of lowercase letters. result = 0 for ch in s: result ^= ord(ch) for ch in t: result ^= ord(ch) return chr(result)"}]'),O={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const P=c(O,[["render",j],["__scopeId","data-v-a593fce8"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/43.md","filePath":"guide/43.md"}'),B={name:"guide/43.md"},U=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
