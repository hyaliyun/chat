import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-157efaf5"]]),S=JSON.parse('[{"question":"# Coding Question Problem Statement You are given a list of `n` integers, `nums`, that represents the maximum number of steps you can take forward from that position. Your task is to implement a function `canReachEnd(nums: List[int]) -> bool` to determine if you are able to reach the last index from the first index. You can assume that you always start at the first index. # Input and Output Formats * **Input Format**: * `nums`: A List of integers where `n` is the length of the list. * **Output Format**: * Return `True` if you can reach the last index, otherwise return `False`. # Constraints * `1 ≤ n ≤ 10^4` * `0 ≤ nums[i] ≤ 10^5` # Performance Requirements * Your solution should be efficient and complete in linear time complexity, ( O(n) ). # Example Input ```python nums = [2, 3, 1, 1, 4] ``` Output ```python True ``` Input ```python nums = [3, 2, 1, 0, 4] ``` Output ```python False ``` # Hints * Consider keeping track of the maximum index you can reach while iterating through the list. Here\'s the function signature: ```python from typing import List def canReachEnd(nums: List[int]) -> bool: pass ```","solution":"from typing import List def canReachEnd(nums: List[int]) -> bool: Determines if you can reach the last index starting from the first index in the given list of integers. Args: nums (List[int]): List of integers representing the maximum number of steps you can take from each position. Returns: bool: True if you can reach the last index, otherwise False. max_reach = 0 n = len(nums) for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) if max_reach >= n - 1: return True return False"},{"question":"# Coding Assessment: Implement a Custom Image Filter Context: As part of a digital image processing project, you are tasked with applying a custom filter to a grayscale image. The filter should be implemented using a convolution operation, which is a fundamental process in image processing. Task: Write a function named `apply_custom_filter` that applies a given kernel filter to a grayscale image. The function should efficiently handle convolutions and display both the original and filtered images side-by-side for comparison. Function Signature: ```python def apply_custom_filter( gray_image: np.ndarray, kernel: np.ndarray ) -> None: pass ``` Input: 1. **gray_image** (np.ndarray): A 2D numpy array representing the grayscale image. 2. **kernel** (np.ndarray): A 2D numpy array representing the convolution kernel/filter. Output: * The function does not return anything. It displays the original and filtered images side-by-side using a plotting library such as matplotlib. Constraints: * You can assume the image is in grayscale format. * The kernel provided will be of odd size (e.g., 3x3, 5x5) for simplicity. * The convolution should be implemented using manual numpy operations without relying on advanced libraries like OpenCV for the convolution itself. Performance Requirements: * The function should efficiently handle convolutions on images up to 1000x1000 in size. * Ensure the convolution operation is applied correctly, considering edge handling (e.g., zero-padding). Example: ```python if __name__ == \\"__main__\\": import numpy as np import matplotlib.pyplot as plt # Sample input gray_image = np.random.randint(0, 256, (512, 512), dtype=np.uint8) kernel = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]]) def apply_custom_filter(gray_image: np.ndarray, kernel: np.ndarray) -> None: # Get image dimensions img_height, img_width = gray_image.shape # Get kernel dimensions k_height, k_width = kernel.shape pad_height = k_height // 2 pad_width = k_width // 2 # Pad the image with zeros on all sides padded_image = np.pad(gray_image, ((pad_height, pad_height), (pad_width, pad_width)), mode=\'constant\') # Create the output image filtered_image = np.zeros_like(gray_image) # Perform convolution operation for i in range(img_height): for j in range(img_width): # Extract the region of interest roi = padded_image[i:i + k_height, j:j + k_width] # Perform the element-wise multiplication and sum the result filtered_image[i, j] = np.sum(roi * kernel) # Clip the result to be in the range of 0 to 255 filtered_image = np.clip(filtered_image, 0, 255) # Display the original and filtered images fig, axes = plt.subplots(1, 2, figsize=(12, 6)) axes[0].imshow(gray_image, cmap=\'gray\') axes[0].set_title(\\"Original Image\\") axes[1].imshow(filtered_image, cmap=\'gray\') axes[1].set_title(\\"Filtered Image\\") plt.show() # Execute the example apply_custom_filter(gray_image, kernel) ``` Note: Your function should include error handling for scenarios such as incorrect kernel dimensions or non-grayscale images. Aim for clarity and efficiency in your convolution implementation.","solution":"import numpy as np import matplotlib.pyplot as plt def apply_custom_filter(gray_image: np.ndarray, kernel: np.ndarray) -> None: Applies a convolution filter to a grayscale image and displays the original and filtered images side by side. Parameters: gray_image (np.ndarray): 2D numpy array representing the grayscale image. kernel (np.ndarray): 2D numpy array representing the convolution kernel/filter. if len(gray_image.shape) != 2: raise ValueError(\\"The input image must be a 2D array representing a grayscale image.\\") if len(kernel.shape) != 2 or kernel.shape[0] % 2 == 0 or kernel.shape[1] % 2 == 0: raise ValueError(\\"The kernel must be a 2D array with odd dimensions.\\") img_height, img_width = gray_image.shape k_height, k_width = kernel.shape pad_height = k_height // 2 pad_width = k_width // 2 # Pad the image with zeros on all sides padded_image = np.pad(gray_image, ((pad_height, pad_height), (pad_width, pad_width)), mode=\'constant\') # Create the output image filtered_image = np.zeros_like(gray_image) # Perform convolution operation for i in range(img_height): for j in range(img_width): # Extract the region of interest roi = padded_image[i:i + k_height, j:j + k_width] # Perform the element-wise multiplication and sum the result filtered_image[i, j] = np.sum(roi * kernel) # Clip the result to be in the range of 0 to 255 filtered_image = np.clip(filtered_image, 0, 255) # Display the original and filtered images fig, axes = plt.subplots(1, 2, figsize=(12, 6)) axes[0].imshow(gray_image, cmap=\'gray\') axes[0].set_title(\\"Original Image\\") axes[1].imshow(filtered_image, cmap=\'gray\') axes[1].set_title(\\"Filtered Image\\") plt.show()"},{"question":"**Question:** You are given an n x n 2D matrix representing an image, where each element of the matrix represents a pixel\'s color value. Your task is to rotate the image 90 degrees clockwise in-place, which means you have to modify the input 2D matrix directly without using an additional matrix. **Task:** Write a Python function `rotate_image(matrix: List[List[int]]) -> None` that rotates the input matrix 90 degrees clockwise. **Input:** * `matrix`: A 2D list of integers representing an image (1 ≤ len(matrix) ≤ 500, len(matrix[0]) == len(matrix)) **Output:** * This function should modify the input matrix in-place and does not return anything. **Example:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix) ``` Output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Constraints:** * You must modify the input matrix in-place. * The matrix is guaranteed to be a square matrix. **Hint:** To rotate the matrix in-place, first transpose the matrix and then reverse each row.","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> None: Rotates the n x n matrix 90 degrees clockwise in-place. Parameters: - matrix (List[List[int]]): The input 2D list representing the image. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Task You\'ve been tasked with analyzing a large dataset consisting of unique pairs of names and integers. Your goal is to identify the pair with the largest value and return the associated name. Function Signature ```python def find_name_with_largest_value(data_file: str) -> str: Determines which name in the input file is associated with the largest integer value. Args: data_file (str): Path to the text file containing name/integer pairs separated by a comma. Returns: str: The name associated with the largest integer value. ``` # Input * A text file (`data_file`) containing multiple lines, each containing a name/integer pair separated by a comma (i.e., \\"name,integer\\"). # Output * Return the name associated with the largest integer value. # Constraints * The file can contain up to 1000 lines. * Each name is a unique string consisting only of alphabetic characters. * Each integer is a positive integer less than 10 million. * You can assume the file will not be empty. # Example Given a file `name_value.txt` with the following content: ``` Alice,354229 Bob,1423224 ... ``` Calling `find_name_with_largest_value(\\"name_value.txt\\")` should return `Bob`. # Notes * Read through the file line by line and compare the integer values to find the largest one. * Assume the input file is always well formatted, and each line follows the \\"name,integer\\" format.","solution":"def find_name_with_largest_value(data_file: str) -> str: Determines which name in the input file is associated with the largest integer value. Args: data_file (str): Path to the text file containing name/integer pairs separated by a comma. Returns: str: The name associated with the largest integer value. max_value = -1 max_name = \\"\\" with open(data_file, \'r\') as file: for line in file: name, value = line.strip().split(\',\') value = int(value) if value > max_value: max_value = value max_name = name return max_name"},{"question":"# Binary Search Tree (BST): In-order Traversal Given a class to represent a binary search tree (BST), implement the missing method `inorder_traversal` that returns a list of values of the nodes obtained by in-order traversal. # Explanation: The `inorder_traversal` method should traverse the BST in such a way that for any given node, the left subtree is visited first, followed by the node itself, and finally the right subtree. # Function Signature: ```python class BSTNode: ... def inorder_traversal(self): ... ``` # Expected Inputs and Outputs: * **Input**: * Tree: The initial binary search tree. * **Output**: * A list of values representing the in-order traversal of the BST. # Example: ```python # Constructing the Binary Search Tree # 4 # / # 2 5 # / # 1 3 root = BSTNode(4) root.insert(2) root.insert(1) root.insert(3) root.insert(5) result = root.inorder_traversal() # In-order Traversal # [1, 2, 3, 4, 5] # Verifying the result assert result == [1, 2, 3, 4, 5] ``` # Constraints: 1. The number of nodes in the tree will be between 0 and 10000. 2. Each node\'s value will be a unique integer. # Testing: Your solution will be tested with the following scenario: 1. Performing in-order traversal on an empty tree. 2. Performing in-order traversal on a tree with one node. 3. Performing in-order traversal on a tree with multiple nodes. # Notes: Make sure to handle edge cases where the tree is empty or has only one node. Your implementation should return the correct order of elements as per the in-order traversal rules.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(self, value): if value < self.value: if self.left: self.left.insert(value) else: self.left = BSTNode(value) else: if self.right: self.right.insert(value) else: self.right = BSTNode(value) def inorder_traversal(self): Perform an in-order traversal of the BST and return the list of values. elements = [] if self.left: elements += self.left.inorder_traversal() elements.append(self.value) if self.right: elements += self.right.inorder_traversal() return elements"},{"question":"# Problem Statement **Reconstruct the Word** Given a scrambled word with all lowercase letters, you have to implement a function to reconstruct the original word. The original word can be found in a pre-defined dictionary of valid English words. Your task is to implement the function `reconstruct_word(scrambled: str, dictionary: List[str]) -> str` that finds and returns the original word from the dictionary. # Input - `scrambled`: A string consisting of lowercase letters that represents the scrambled word. - `dictionary`: A list of strings, each being a valid English word. # Output - Returns the original word from the dictionary that matches the scrambled word. If there are multiple matches, return any one of them. If no matching word is found, return an empty string. # Constraints - The length of `scrambled` will be between 1 and 100 inclusive. - The dictionary will contain between 1 and 1000 words inclusive. - The words in the dictionary will all have lowercase letters and be between 1 and 100 characters in length. # Example ```python >>> reconstruct_word(\\"etanr\\", [\\"nature\\", \\"nater\\", \\"antenne\\", \\"crane\\"]) \\"nater\\" >>> reconstruct_word(\\"carse\\", [\\"race\\", \\"case\\", \\"ears\\", \\"acres\\"]) \\"acres\\" ``` # Notes - The function should handle different lengths of scrambled words and corresponding words in the dictionary. - Utilize sorting or other efficient methods to compare the scrambled word and dictionary words appropriately.","solution":"from typing import List def reconstruct_word(scrambled: str, dictionary: List[str]) -> str: Reconstruct the original word from the scrambled version by searching within the provided dictionary for a match. :param scrambled: A scrambled string of lowercase letters :param dictionary: A list of valid English words :return: The original word if found; otherwise, an empty string sorted_scrambled = sorted(scrambled) for word in dictionary: if sorted(word) == sorted_scrambled: return word return \\"\\""},{"question":"# Question: Implement a Graph Traversal Algorithm in Python Scenario You are tasked with analyzing connections in a social network graph where users are represented as nodes and friendships as edges. To explore the network, you need to implement a Breadth-First Search (BFS) algorithm to find the shortest path between two users. Task 1. Implement a class `Graph` that represents an undirected graph using an adjacency list. The class should provide methods to add edges (`add_edge`) and to perform a BFS (`bfs_shortest_path`) to find the shortest path between two nodes. 2. Write a function `find_shortest_path(graph: Graph, start_node: int, end_node: int) -> List[int]` which uses the BFS method from the `Graph` class to find and return the shortest path between `start_node` and `end_node`. If no path exists, return an empty list. Input and Output Formats - **Input**: - A list of edges representing the graph, where each edge is a tuple `(node1, node2)`. - Two integer values `start_node` and `end_node` representing the nodes between which the shortest path needs to be found. - **Output**: - A list of integers representing the shortest path from `start_node` to `end_node`, inclusive. If no valid path exists, return an empty list. Constraints - The graph will have at most 10,000 nodes and 50,000 edges. - Node identifiers are non-negative integers. - Edges are undirected. - The `start_node` and `end_node` are guaranteed to be valid nodes in the graph. Implementation Hints - Use a queue to implement BFS. - Use a dictionary or list of lists to represent the adjacency list for the graph. - Keep track of visited nodes to avoid cycles. Sample Input and Output ```python graph_edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)] start_node = 0 end_node = 4 result = find_shortest_path(graph_edges, start_node, end_node) print(result) # Output: [0, 1, 3, 4] ``` ```python from collections import deque, defaultdict class Graph: def __init__(self, edges: List[Tuple[int, int]]): self.adj_list = defaultdict(list) for edge in edges: self.add_edge(*edge) def add_edge(self, node1: int, node2: int): self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def bfs_shortest_path(self, start: int, goal: int) -> List[int]: visited = {start} queue = deque([[start]]) if start == goal: return [start] while queue: path = queue.popleft() node = path[-1] for neighbor in self.adj_list[node]: if neighbor not in visited: new_path = list(path) new_path.append(neighbor) queue.append(new_path) if neighbor == goal: return new_path visited.add(neighbor) return [] def find_shortest_path(edges: List[Tuple[int, int]], start_node: int, end_node: int) -> List[int]: graph = Graph(edges) return graph.bfs_shortest_path(start_node, end_node) # Sample usage: edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)] start_node = 0 end_node = 4 print(find_shortest_path(edges, start_node, end_node)) # Output: [0, 1, 3, 4] ```","solution":"from collections import deque, defaultdict from typing import List, Tuple class Graph: def __init__(self, edges: List[Tuple[int, int]]): self.adj_list = defaultdict(list) for edge in edges: self.add_edge(*edge) def add_edge(self, node1: int, node2: int): self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def bfs_shortest_path(self, start: int, goal: int) -> List[int]: visited = {start} queue = deque([[start]]) if start == goal: return [start] while queue: path = queue.popleft() node = path[-1] for neighbor in self.adj_list[node]: if neighbor not in visited: new_path = list(path) new_path.append(neighbor) queue.append(new_path) if neighbor == goal: return new_path visited.add(neighbor) return [] def find_shortest_path(edges: List[Tuple[int, int]], start_node: int, end_node: int) -> List[int]: graph = Graph(edges) return graph.bfs_shortest_path(start_node, end_node)"},{"question":"**Problem Statement:** You are working on a feature to determine the longest sequence of consecutive integers in an unsorted array. Write a function `longest_consecutive_sequence(array: list[int]) -> int` that: - Receives an array of integers `array`. - Returns the length of the longest sequence of consecutive integers. # Constraints: - The integers in `array` can be positive, negative, and zero. - 1 ≤ length of `array` ≤ 100,000. # Input: - `array`: List of integers. # Output: - An integer denoting the length of the longest sequence of consecutive integers. # Example: Example 1: ``` Input: array = [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest sequence of consecutive integers is 1, 2, 3, 4, so the length is 4. ``` Example 2: ``` Input: array = [0, -1, 1, 2, -2, -3, 3, 4, -4] Output: 9 Explanation: The longest sequence of consecutive integers is -4, -3, -2, -1, 0, 1, 2, 3, 4, so the length is 9. ``` Implement your solution with optimal time complexity, considering the large constraint on the array length.","solution":"def longest_consecutive_sequence(array): Returns the length of the longest sequence of consecutive integers. if not array: return 0 num_set = set(array) max_length = 0 for num in array: if num - 1 not in num_set: # Only check for the beginning of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing functionality for a system that processes user input for configuration keys. These keys need to be cleaned up by removing any leading and trailing whitespace and converting all internal groups of whitespace (spaces, tabs, newlines) into a single underscore (\'_\') character to ensure uniform formatting. Task Write a function `standardize_key` that takes a string as input and returns a new string with the following transformations: 1. Remove any leading and trailing whitespace. 2. Replace any group of one or more whitespace characters within the string with a single underscore (\'_\') character. Input * A single string `key` (1 ≤ |key| ≤ 10^5) where |key| represents the length of the string. Output * A single string where the leading and trailing whitespace of `key` has been removed, and each group of internal whitespace is replaced by a single underscore (\'_\') character. Constraints * The function must handle strings up to 100,000 characters efficiently. * You must not use any regular expression libraries. Example ```python assert standardize_key(\\" config key \\") == \\"config_key\\" assert standardize_key(\\"multi part t key\\") == \\"multi_part_key\\" assert standardize_key(\\"nnewnline key \\") == \\"new_line_key\\" assert standardize_key(\\"singleword\\") == \\"singleword\\" ```","solution":"def standardize_key(key): Standardizes the given key string by trimming leading and trailing whitespace and replacing internal groups of whitespace with a single underscore. trimmed_key = key.strip() standardized_key = [] whitespace_encountered = False for char in trimmed_key: if char.isspace(): if not whitespace_encountered: standardized_key.append(\'_\') whitespace_encountered = True else: standardized_key.append(char) whitespace_encountered = False return \'\'.join(standardized_key) # Examples provided in the problem statement assert standardize_key(\\" config key \\") == \\"config_key\\" assert standardize_key(\\"multi part t key\\") == \\"multi_part_key\\" assert standardize_key(\\"nnewnline key \\") == \\"new_line_key\\" assert standardize_key(\\"singleword\\") == \\"singleword\\""},{"question":"# Question: Analyzing Complex Number Operations You are provided with a class `ComplexNumber` that encapsulates operations for complex numbers. Currently, it supports basic operations such as addition, subtraction, multiplication, and division. Your task is to enhance this class by implementing the following additional operations: 1. **Magnitude Calculation**: Implement a method to calculate and return the magnitude (absolute value) of the complex number. 2. **Argument Calculation**: Implement a method to calculate and return the argument (angle) of the complex number in radians. 3. **Complex Conjugate**: Implement a method to calculate and return the complex conjugate of the complex number. Your enhanced class should adhere to the existing structure and provide a seamless interface for these additional functionalities. # Input * A class `ComplexNumber` with two float attributes `real` and `imag` representing the real and imaginary parts of the complex number. # Output * Methods for magnitude, argument, and complex conjugate calculations. # Constraints * Ensure that your solution handles complex numbers accurately, following mathematical conventions. * The argument should be returned in a range of ([-π, π)). * Implement efficient computation to handle edge cases like purely real or purely imaginary numbers. # Example ```python class ComplexNumber: def __init__(self, real, imag): self.real = real self.imag = imag def add(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag) def multiply(self, other): real_part = (self.real * other.real) - (self.imag * other.imag) imag_part = (self.real * other.imag) + (self.imag * other.real) return ComplexNumber(real_part, imag_part) # Methods to implement def magnitude(self): pass def argument(self): pass def conjugate(self): pass # Create an example complex number z = ComplexNumber(3, 4) print(z.magnitude()) # Expected output: 5.0 print(z.argument()) # Expected output: 0.9273 (approx) print(z.conjugate()) # Expected output: 3 - 4i ``` # Explanation: * `z.magnitude()` should return the magnitude of the complex number, which is √(real² + imag²). * `z.argument()` should return the argument (angle) in radians using atan2(imag, real). * `z.conjugate()` should return a new `ComplexNumber` object with the same real part and the negative of the imaginary part.","solution":"import math class ComplexNumber: def __init__(self, real, imag): self.real = real self.imag = imag def add(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag) def multiply(self, other): real_part = (self.real * other.real) - (self.imag * other.imag) imag_part = (self.real * other.imag) + (self.imag * other.real) return ComplexNumber(real_part, imag_part) def magnitude(self): return math.sqrt(self.real ** 2 + self.imag ** 2) def argument(self): return math.atan2(self.imag, self.real) def conjugate(self): return ComplexNumber(self.real, -self.imag) # Example usage: # Create an example complex number z = ComplexNumber(3, 4) print(z.magnitude()) # Expected output: 5.0 print(z.argument()) # Expected output: 0.9273 (approx) print(z.conjugate()) # Expected output: ComplexNumber(3, -4)"},{"question":"# Problem Description You are given a dictionary `input_dict` where the keys are strings and the values are lists of tuples. Each tuple contains two elements: a string and an integer. Your task is to write a function `flatten_dict` that returns a new dictionary where each key is a string from one of the tuples, and the value is the sum of the integers associated with that string across all lists in the original dictionary. # Input * `input_dict` (dict): A dictionary with keys as strings and values as lists of tuples. Each tuple contains a string and an integer. # Output * The function should return a new dictionary with the strings from the tuples as keys and the sum of their corresponding integers as values. # Constraints * The dictionary can be empty. * The lists of tuples can be empty. * The integers are non-negative. # Example ```python >>> flatten_dict({ ... \\"A\\": [(\\"apple\\", 3), (\\"banana\\", 2)], ... \\"B\\": [(\\"apple\\", 5), (\\"orange\\", 3)], ... \\"C\\": [(\\"banana\\", 1), (\\"grape\\", 4)] ... }) { \'apple\': 8, \'banana\': 3, \'orange\': 3, \'grape\': 4 } >>> flatten_dict({ ... \\"X\\": [(\\"x\\", 1), (\\"y\\", 2)], ... \\"Y\\": [(\\"z\\", 3), (\\"y\\", 1)], ... \\"Z\\": [(\\"x\\", 4)] ... }) { \'x\': 5, \'y\': 3, \'z\': 3 } >>> flatten_dict({ ... \\"A\\": [] ... }) { } >>> flatten_dict({}) { } ``` # Requirements * Implement the function `flatten_dict` to meet the specifications. * Ensure the function handles all edge cases efficiently.","solution":"def flatten_dict(input_dict): Flattens a dictionary where the values are lists of tuples containing a string and an integer, and returns a new dictionary with the strings as keys and the sum of their integers as values. result = {} for key in input_dict: for item in input_dict[key]: str_key, val = item if str_key in result: result[str_key] += val else: result[str_key] = val return result"},{"question":"# Coding Challenge: Implementing an Anagram Checker Objective Write a function that determines if two given strings are anagrams of each other. Two strings are considered anagrams if they contain the same characters with the same frequency, disregarding spaces and capitalization. Detailed Requirements - **Function Signature**: ```python def are_anagrams(string1: str, string2: str) -> bool: ``` - **Input**: - `string1`: A string of any length consisting of alphabetical characters and spaces. - `string2`: A string of any length consisting of alphabetical characters and spaces. - **Output**: - A boolean value `True` or `False` indicating whether the two strings are anagrams. - **Constraints**: - Both `string1` and `string2` must be strings and should contain only alphabetical characters and spaces. - Handle edge cases such as empty strings and strings with different lengths. - **Performance**: - The function should run in O(n) time complexity where \'n\' is the length of the longest input string. - It should use O(1) additional space, excluding the space required for the input strings and auxiliary data structures. Example: ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Hello\\", \\"Olelh\\") True >>> are_anagrams(\\"Dormitory\\", \\"Dirty room\\") True >>> are_anagrams(\\"The Eyes\\", \\"They see\\") True >>> are_anagrams(\\"Hello\\", \\"World\\") False ``` Guidelines: 1. **Normalization**: - Convert both strings to lowercase. - Remove all spaces. 2. **Validation**: - Ensure the function raises appropriate exceptions for invalid inputs: - Raise `ValueError` for `None` inputs. - Raise `TypeError` if any non-string element is passed as input. 3. **Efficiency**: - Consider using a dictionary or `collections.Counter` to count character frequencies. 4. **Testing**: - Include `doctest` to validate your solution. 5. **Edge cases**: - Address cases such as strings with different lengths, completely different characters, and strings that are anagrams with spaces ignored. Here is a potential implementation: ```python def are_anagrams(string1: str, string2: str) -> bool: if string1 is None or string2 is None: raise ValueError(\\"Input strings cannot be None\\") if not isinstance(string1, str) or not isinstance(string2, str): raise TypeError(\\"Both inputs must be strings\\") def sanitize_string(s: str) -> str: return \'\'.join(s.lower().split()) sanitized_str1 = sanitize_string(string1) sanitized_str2 = sanitize_string(string2) if len(sanitized_str1) != len(sanitized_str2): return False from collections import Counter return Counter(sanitized_str1) == Counter(sanitized_str2) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def are_anagrams(string1: str, string2: str) -> bool: if string1 is None or string2 is None: raise ValueError(\\"Input strings cannot be None\\") if not isinstance(string1, str) or not isinstance(string2, str): raise TypeError(\\"Both inputs must be strings\\") def sanitize_string(s: str) -> str: return \'\'.join(s.lower().split()) sanitized_str1 = sanitize_string(string1) sanitized_str2 = sanitize_string(string2) if len(sanitized_str1) != len(sanitized_str2): return False from collections import Counter return Counter(sanitized_str1) == Counter(sanitized_str2)"},{"question":"# Problem Statement You are tasked with creating a function that evaluates the security of a password based on specific criteria. A password is considered strong if it satisfies all the following conditions: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: `!@#%^&*()-+` Write a function that takes a string input and checks if the password meets all the above criteria. If the password is strong, the function should return `True`, otherwise it should return `False`. # Function Signature ```python def is_strong_password(password: str) -> bool: ``` # Input - A string `password` representing the password to evaluate. - Constraints: `1 <= len(password) <= 100` # Output - A boolean value `True` if the password is strong, `False` otherwise. # Example ```python assert is_strong_password(\\"Aa1@strong\\") == True assert is_strong_password(\\"weak\\") == False assert is_strong_password(\\"Aa1@\\") == False assert is_strong_password(\\"Aa1abcdefg@\\") == True ``` # Constraints - The function should run efficiently within the constraints provided. # Edge Cases - Handle cases where the password length is exactly the minimum required length. - Check for presence of at least one of each type of required character. # Notes - Consider implementing checks in a sequence that minimizes computational redundancy.","solution":"def is_strong_password(password: str) -> bool: Evaluates the strength of a password based on given criteria. A password is considered strong if it satisfies all the following conditions: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: !@#%^&*()-+ :param password: str - The password to evaluate. :return: bool - True if the password is strong, False otherwise. if len(password) < 8: return False has_upper = any(char.isupper() for char in password) has_lower = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) has_special = any(char in \\"!@#%^&*()-+\\" for char in password) return has_upper and has_lower and has_digit and has_special"},{"question":"# Scenario You are developing a module for a financial application that must handle and process dates efficiently. You need a function that calculates the difference between two given dates and returns the result in days. Given your understanding of date manipulation, implement this functionality without relying on any built-in date libraries. # Problem Statement Implement a function `days_difference(date1: tuple, date2: tuple) -> int` that takes in two dates as tuples (`date1` and `date2`). Each tuple will contain three integers representing the day, month, and year respectively. The function should return the absolute difference in days between the two dates. # Input and Output Formats - The function will receive two tuples as input parameters, each containing three integers `(day, month, year)`. - The function will return an integer representing the absolute difference in days. # Constraints - The year values will be between (1900) and (2100). - Both dates will be valid dates. - The dates can be in any order, i.e., `date1` could be earlier or later than `date2`. # Performance Requirements - The implementation should have linear time complexity (O(n)), where (n) is the number of days between the two dates. # Example Cases ```python >>> days_difference((1, 1, 2023), (2, 1, 2023)) 1 >>> days_difference((1, 2, 2023), (1, 1, 2023)) 31 >>> days_difference((28, 2, 2020), (1, 3, 2020)) 2 >>> days_difference((1, 1, 1901), (1, 1, 2001)) 36525 >>> days_difference((1, 3, 2023), (1, 3, 2021)) 730 ``` # Additional Notes - The function should account for leap years. - Do not use any built-in date libraries. All date calculations should be done manually.","solution":"def is_leap_year(year): Check if a year is a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False return True return False def days_in_month(month, year): Return the number of days in a given month of a particular year. if month == 2: if is_leap_year(year): return 29 else: return 28 if month in (4, 6, 9, 11): return 30 return 31 def days_in_year_to_date(day, month, year): Calculate the number of days from the start of the year to a given date. days = 0 for m in range(1, month): days += days_in_month(m, year) days += day return days def days_between_years(year1, year2): Calculate the number of days between two years, including leap years. days = 0 for year in range(year1, year2): if is_leap_year(year): days += 366 else: days += 365 return days def days_difference(date1, date2): Calculate the absolute difference in days between two dates. Each date is represented as a tuple (day, month, year). day1, month1, year1 = date1 day2, month2, year2 = date2 if year1 == year2: # When both dates are in the same year days1 = days_in_year_to_date(day1, month1, year1) days2 = days_in_year_to_date(day2, month2, year2) return abs(days2 - days1) else: # When dates are in different years if year1 > year2: # Swap dates so date1 is always the earlier date date1, date2 = date2, date1 day1, month1, year1 = date1 day2, month2, year2 = date2 # Days remaining in the first year from date1 remaining_days_year1 = (365 + int(is_leap_year(year1))) - days_in_year_to_date(day1, month1, year1) # Days passed in the last year to the date2 days_year2_to_date2 = days_in_year_to_date(day2, month2, year2) # Days in the years in between intermediate_days = days_between_years(year1 + 1, year2) total_days = remaining_days_year1 + days_year2_to_date2 + intermediate_days return total_days"},{"question":"# Question: Implement and Test Filesystem Explorer Context: You are tasked with creating a tool that explores a given directory and generates a summary report of its contents. This tool should list all files and directories, categorize them by file type, and provide a count of each file type. Requirements: 1. **Directory Exploration**: Traverse the entire directory structure starting from a given root directory. 2. **File Type Categorization**: Categorize files by their extensions (e.g., `.txt`, `.jpg`). 3. **Summary Report**: Create a summary report that lists the count of each file type and the total number of directories. Main Function Specification: ```python def generate_filesystem_report(root_dir: str) -> Dict[str, Any]: Given a root directory, generate a summary report of its contents. Parameters: root_dir (str): The root directory to start the exploration. Returns: Dict[str, Any]: A dictionary containing the counts of each file type and the total number of directories. pass ``` * **Input**: A string representing the path to the root directory. * **Output**: A dictionary with file types as keys and their counts as values, along with the count of directories. Constraints: - The function should handle large directory structures efficiently. - Proper error handling should be implemented for cases such as invalid directory paths or inaccessible directories. - The function should be designed to run on both Windows and Unix-like operating systems. * **Example**: ```python input_dir = \\"/path/to/test_directory\\" expected_output = { \\"txt\\": 10, \\"jpg\\": 5, \\"pdf\\": 3, \\"directories\\": 4 } assert generate_filesystem_report(input_dir) == expected_output ``` Performance Requirements: - Ensure the function can process a directory containing up to 10,000 files and directories within a reasonable time limit (e.g., < 20 seconds). Note: Provide a well-documented and tested solution showcasing your understanding of file system traversal, file type categorization, and file handling in Python.","solution":"import os from collections import defaultdict from typing import Dict, Any def generate_filesystem_report(root_dir: str) -> Dict[str, Any]: Given a root directory, generate a summary report of its contents. Parameters: root_dir (str): The root directory to start the exploration. Returns: Dict[str, Any]: A dictionary containing the counts of each file type and the total number of directories. report = defaultdict(int) for root, dirs, files in os.walk(root_dir): report[\\"directories\\"] += len(dirs) for file in files: file_extension = os.path.splitext(file)[1][1:] # get file extension without the dot if file_extension: report[file_extension] += 1 else: report[\\"no_extension\\"] += 1 return dict(report)"},{"question":"**Scenario**: As part of a library management system, you need to implement a system to handle book inventories and user borrowing activities. Ensure the system can manage books efficiently and track borrowed books by users accurately. **Task:** Implement a class `LibraryManagement` with the following methods: 1. `add_book(title: str, author: str, isbn: str) -> None`: Add a book to the library collection. Each book should have a unique ISBN. 2. `borrow_book(isbn: str, user_id: str) -> bool`: Allow a user to borrow a book by its ISBN. Ensure a book cannot be borrowed if it\'s already borrowed. 3. `return_book(isbn: str, user_id: str) -> bool`: Allow a user to return a borrowed book. Ensure only the user who borrowed the book can return it. 4. `get_borrowed_books(user_id: str) -> list`: Get a list of all books currently borrowed by a specific user. * Expected input and output formats: * `add_book(title, author, isbn)` -> None * `borrow_book(isbn, user_id)` -> bool * `return_book(isbn, user_id)` -> bool * `get_borrowed_books(user_id)` -> [dict, ...] * Constraints: * Each ISBN is unique and valid. * A book cannot be borrowed if it has already been borrowed by another user. * A book can only be returned by the user who borrowed it. * Optimize for efficient lookup and management of books and borrowing records. Below is the starting code for the class: ```python class LibraryManagement: def __init__(self): self.books = {} self.borrowed_books = {} def add_book(self, title: str, author: str, isbn: str) -> None: # Implement the logic to add a book to the library collection. pass def borrow_book(self, isbn: str, user_id: str) -> bool: # Implement the logic to borrow a book. pass def return_book(self, isbn: str, user_id: str) -> bool: # Implement the logic to return a borrowed book. pass def get_borrowed_books(self, user_id: str) -> list: # Implement the logic to get all books borrowed by the user. pass ```","solution":"class LibraryManagement: def __init__(self): self.books = {} self.borrowed_books = {} def add_book(self, title: str, author: str, isbn: str) -> None: Adds a book to the library collection. if isbn not in self.books: self.books[isbn] = {\'title\': title, \'author\': author, \'is_borrowed\': False, \'borrowed_by\': None} def borrow_book(self, isbn: str, user_id: str) -> bool: Allows a user to borrow a book by its ISBN. if isbn in self.books and not self.books[isbn][\'is_borrowed\']: self.books[isbn][\'is_borrowed\'] = True self.books[isbn][\'borrowed_by\'] = user_id if user_id not in self.borrowed_books: self.borrowed_books[user_id] = [] self.borrowed_books[user_id].append(self.books[isbn]) return True return False def return_book(self, isbn: str, user_id: str) -> bool: Allows a user to return a borrowed book. if isbn in self.books and self.books[isbn][\'is_borrowed\'] and self.books[isbn][\'borrowed_by\'] == user_id: self.books[isbn][\'is_borrowed\'] = False self.books[isbn][\'borrowed_by\'] = None self.borrowed_books[user_id].remove(self.books[isbn]) if not self.borrowed_books[user_id]: del self.borrowed_books[user_id] return True return False def get_borrowed_books(self, user_id: str) -> list: Get a list of all books currently borrowed by a specific user. return self.borrowed_books.get(user_id, [])"},{"question":"# Question: Implement the Kth Largest Element in an Array **Context**: In computational problems, it\'s often necessary to find the Kth largest element in a collection of data. This task focuses on implementing an efficient solution to determine the Kth largest element in an array of integers. **Function**: `find_kth_largest(nums: List[int], k: int) -> int` **Input**: 1. `nums` (List[int]) - An array of integers where the Kth largest element needs to be found. 2. `k` (int) - An integer representing the order of the largest element to be found (1 ≤ k ≤ len(nums)). **Output**: 1. Returns the Kth largest element in the array. **Constraints**: * The input array `nums` will have at least one and at most 10,000 elements. * Each element in the array can be any integer value (positive or negative). * Determining the Kth largest element should be optimized for performance and handle both very small and very large arrays efficiently. **Examples**: 1. `find_kth_largest([3, 2, 1, 5, 6, 4], 2)` returns `5` 2. `find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)` returns `4` 3. `find_kth_largest([1], 1)` returns `1` 4. `find_kth_largest([7, 10, 4, 3, 20, 15], 3)` returns `10` **Performance Requirements**: * Aim for an algorithm with a time complexity of O(n log n) or better. * Utilize efficient sorting or selection algorithms to solve the problem within the constraints.","solution":"import heapq from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the Kth largest element in an array of integers. # Use a min-heap of size k to keep track of the k largest elements # The kth largest element will be at the root of the heap. min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"You are required to build a multi-threaded logging system that ensures thread-safe logging of events in a distributed environment. This system will support creating log entries, retrieving all logs in chronological order, and clearing the log records. # Objectives: 1. Write a class `ThreadSafeLogger` to handle logging of events. 2. Implement the `log_event` method to add an event log with timestamp. 3. Implement the `get_logs` method to retrieve all logs sorted by timestamp. 4. Implement the `clear_logs` method to clear all log entries. # Class and Method Definitions: - `ThreadSafeLogger` class - `log_event(event: str) -> None` - **Input**: - event: A string representing the event to be logged. - **Output**: None - **Functionality**: Adds the event to the log with the current timestamp. - `get_logs() -> List[Tuple[str, datetime]]` - **Output**: - A list of tuples where each tuple contains the event string and its corresponding timestamp, sorted by timestamp. - `clear_logs() -> None` - **Output**: None # Constraints: - Multiple threads may call `log_event`, `get_logs`, and `clear_logs` concurrently. - You must ensure thread safety using synchronization primitives. - Use Python\'s `datetime` module to handle timestamps. # Example Usage: ```python from datetime import datetime from threading import Thread import time class ThreadSafeLogger: def __init__(self): # Initialize necessary data structures and locks pass def log_event(self, event: str) -> None: # Log the event with current timestamp pass def get_logs(self) -> List[Tuple[str, datetime]]: # Return all logs sorted by timestamp pass def clear_logs(self) -> None: # Clear all log entries pass # Example instantiation and multi-threaded logging logger = ThreadSafeLogger() # Simulate concurrent logging def log_events(thread_id): for i in range(5): logger.log_event(f\\"Event from thread {thread_id}, log {i}\\") time.sleep(0.1) threads = [Thread(target=log_events, args=(i,)) for i in range(3)] for thread in threads: thread.start() for thread in threads: thread.join() # Retrieve and print all logs print(logger.get_logs()) # Clear logs logger.clear_logs() ``` Implement the `ThreadSafeLogger` class and its methods in Python, ensuring that multiple threads can safely log, retrieve, and clear events without any data corruption.","solution":"from datetime import datetime from threading import Lock from typing import List, Tuple class ThreadSafeLogger: def __init__(self): self.logs = [] self.lock = Lock() def log_event(self, event: str) -> None: with self.lock: timestamp = datetime.now() self.logs.append((event, timestamp)) def get_logs(self) -> List[Tuple[str, datetime]]: with self.lock: return sorted(self.logs, key=lambda x: x[1]) def clear_logs(self) -> None: with self.lock: self.logs.clear()"},{"question":"# Problem Statement Given an undirected graph with vertices labeled from 0 to n-1 and a list of edges, identify if the graph is a tree. A graph is considered a tree if it is connected (there is a path between any two nodes) and acyclic (it does not contain any cycles). # Requirements Write a function `is_tree(n: int, edges: List[Tuple[int, int]]) -> bool` that: - Takes an integer `n` representing the number of vertices in the graph. - Takes a list of `edges` where each edge is represented as a tuple `(u, v)` indicating an undirected edge between vertices `u` and `v`. - Returns `True` if the graph is a tree, and `False` otherwise. # Constraints - `1 <= n <= 10^4` - `0 <= len(edges) <= min(2 * 10^4, n * (n - 1) // 2)` - Each `u` and `v` in edges is in the range `[0, n-1]`. # Function Signature ```python def is_tree(n: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Example ```python >>> is_tree(5, [(0, 1), (0, 2), (0, 3), (1, 4)]) True >>> is_tree(5, [(0, 1), (0, 2), (1, 2), (1, 3), (1, 4)]) False >>> is_tree(4, [(0, 1), (2, 3)]) False ``` # Explanation - In the first example, there are 5 vertices and 4 edges, which form a tree as it is connected and acyclic. - In the second example, the graph contains a cycle `(0-1-2)` and hence is not a tree. - In the third example, the graph is not connected, as vertices `[0, 1]` and `[2, 3]` are disjoint, so it is not a tree. # Additional Notes: Efficiently determine if a graph is a tree by using graph traversal algorithms like Depth-First Search (DFS) or Breadth-First Search (BFS) to check for connectivity and cycle presence. The graph can be represented using an adjacency list for better performance on large inputs.","solution":"def is_tree(n: int, edges: list[tuple[int, int]]) -> bool: if len(edges) != n - 1: return False from collections import defaultdict, deque adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * n def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) bfs(0) return all(visited)"},{"question":"# Coding Question Problem Statement Create a function to generate all possible permutations of a given string and count the number of unique permutations generated. Implement both recursive and iterative versions of this algorithm. Requirements: 1. **Recursive Version**: - Input: A string `s`. - Output: A list of all unique permutations of `s` and the count of the unique permutations. 2. **Iterative Version**: - Input: A string `s`. - Output: A list of all unique permutations of `s` and the count of the unique permutations. 3. **Constraints**: - The input string can have a length of up to `10`. 4. **Performance**: - Solutions should efficiently handle the maximum input size. Example ```python # Recursive Version assert permute_recursive(\\"abc\\") == ([\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'], 6) assert permute_recursive(\\"aab\\") == ([\'aab\', \'aba\', \'baa\'], 3) # Iterative Version assert permute_iterative(\\"abc\\") == ([\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'], 6) assert permute_iterative(\\"aab\\") == ([\'aab\', \'aba\', \'baa\'], 3) ``` Implementation Details Please implement the following two functions: ```python from typing import List, Tuple def permute_recursive(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using a recursive method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. # Your code here def permute_iterative(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using an iterative method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. # Your code here ```","solution":"from typing import List, Tuple from itertools import permutations def permute_recursive(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using a recursive method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. def permute_helper(remaining: str, path: str, result: set): if not remaining: result.add(path) return for i in range(len(remaining)): permute_helper(remaining[:i] + remaining[i+1:], path + remaining[i], result) result_set = set() permute_helper(s, \\"\\", result_set) result_list = sorted(list(result_set)) return (result_list, len(result_list)) def permute_iterative(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using an iterative method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. perm_set = set(permutations(s)) result_list = sorted([\\"\\".join(p) for p in perm_set]) return (result_list, len(result_list))"},{"question":"# Coding Assessment Question **Title**: Interleaved String Checker **Context**: String manipulation is a fundamental skill in computer science, with applications ranging from simple text processing to complex data parsing. One interesting problem is to determine if a string can be formed by interleaving two other strings in a way that maintains their individual character order. **Objective**: Write a function `is_interleave(s1: str, s2: str, s3: str) -> bool` that checks if `s3` can be formed by interleaving characters from `s1` and `s2`. **Input**: - `s1`: A string containing lowercase letters. - `s2`: A string containing lowercase letters. - `s3`: A string that is the target interleaved string of `s1` and `s2`. **Output**: - A boolean value: `True` if `s3` can be formed by interleaving `s1` and `s2`, otherwise `False`. **Constraints**: - `0 ≤ len(s1), len(s2) ≤ 100` - `0 ≤ len(s3) ≤ 200` - `s3` will only contain lowercase letters. **Requirements**: - The function must maintain the relative order of characters from both `s1` and `s2` in `s3`. **Example**: ```python def is_interleave(s1: str, s2: str, s3: str) -> bool: # Your solution here # Example Usage: print(is_interleave(\\"aabcc\\", \\"dbbca\\", \\"aadbbcbcac\\")) # Expected output: True print(is_interleave(\\"aabcc\\", \\"dbbca\\", \\"aadbbbaccc\\")) # Expected output: False ``` **Hints**: - Consider using dynamic programming or recursion with memoization to keep track of the interleaving process. - Remember to check the length of `s3` which should be equal to the sum length of `s1` and `s2`.","solution":"def is_interleave(s1: str, s2: str, s3: str) -> bool: if len(s1) + len(s2) != len(s3): return False dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] dp[0][0] = True for i in range(len(s1) + 1): for j in range(len(s2) + 1): if i > 0 and dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]: dp[i][j] = True if j > 0 and dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]: dp[i][j] = True return dp[len(s1)][len(s2)]"},{"question":"# Problem Statement You are asked to work with binary search trees (BSTs) and perform two primary operations: inserting new nodes into the BST while maintaining its properties, and finding the k-th smallest element in the BST. Implement the insertion function `insert_into_bst` and the k-th smallest element finder function `find_kth_smallest`, adhering to the specifications and constraints provided below. Function 1: `insert_into_bst` Implement the function `insert_into_bst` that takes the root of a BST and a data value, and inserts the node into the BST while maintaining its properties. ```python def insert_into_bst(root: TreeNode | None, data: int) -> TreeNode: ``` **Parameters**: - `root` (TreeNode | None): The root of the binary search tree. - `data` (int): The data to be inserted into the new node. **Returns**: - `TreeNode`: The new root of the binary search tree. **Example**: ```python root = insert_into_bst(None, 50) root = insert_into_bst(root, 30) root = insert_into_bst(root, 70) root = insert_into_bst(root, 20) root = insert_into_bst(root, 40) root = insert_into_bst(root, 60) root = insert_into_bst(root, 80) print_bst_inorder(root) # Output: 20 30 40 50 60 70 80 ``` Function 2: `find_kth_smallest` Implement the function `find_kth_smallest` that finds the k-th smallest element in the BST. ```python def find_kth_smallest(root: TreeNode, k: int) -> int: ``` **Parameters**: - `root` (TreeNode): The root of the binary search tree. - `k` (int): The position (1-indexed) of the smallest element to find. **Returns**: - `int`: The k-th smallest element\'s value in the binary search tree. **Example**: ```python root = insert_into_bst(None, 50) root = insert_into_bst(root, 30) root = insert_into_bst(root, 70) root = insert_into_bst(root, 20) root = insert_into_bst(root, 40) root = insert_into_bst(root, 60) root = insert_into_bst(root, 80) k = 3 print(find_kth_smallest(root, k)) # Output: 40 ``` Constraints * The binary search tree will not contain duplicate elements. * The value of `k` will always be valid (1 ≤ k ≤ number of nodes in the BST). * Handle edge cases like an empty tree in a sensible manner (although such cases won\'t be tested for the `find_kth_smallest` function). * Note: A TreeNode implementation is provided inside the dataclass below: ```python from dataclasses import dataclass @dataclass class TreeNode: data: int left: TreeNode | None = None right: TreeNode | None = None ``` Additional Requirements 1. Ensure your code handles edge cases effectively. 2. Optimize for efficient traversal to find the k-th smallest element, particularly in large BSTs.","solution":"from typing import Optional from dataclasses import dataclass @dataclass class TreeNode: data: int left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None def insert_into_bst(root: Optional[TreeNode], data: int) -> TreeNode: Insert a new value into the BST and return the root of the tree. if root is None: return TreeNode(data) if data < root.data: root.left = insert_into_bst(root.left, data) else: root.right = insert_into_bst(root.right, data) return root def in_order_traversal(root: Optional[TreeNode], result: list) -> None: Helper function to perform inorder traversal and append node values to the result list. if root: in_order_traversal(root.left, result) result.append(root.data) in_order_traversal(root.right, result) def find_kth_smallest(root: TreeNode, k: int) -> int: Find the k-th smallest element in the BST. result = [] in_order_traversal(root, result) return result[k - 1]"},{"question":"# Problem Statement You are given a list of integers where each integer appears exactly twice, except for one integer which appears only once. Your task is to find the integer that appears only once. Implement a function `find_unique_number` that solves this problem efficiently. # Function Signature ```python def find_unique_number(nums: list[int]) -> int: ``` # Parameters: - `nums` (list of int): A list of integers where all integers except one appear twice. # Returns: - The function should return the integer that appears only once. # Constraints: - The length of `nums` will be an odd number and at least 3. - The list `nums` is not sorted. # Example ```python # Example 1 print(find_unique_number([2, 3, 3, 4, 4, 2, 5])) # Output: 5 # Example 2 print(find_unique_number([10, 14, 10, 22, 22])) # Output: 14 # Example 3 print(find_unique_number([7, 7, 8, 8, 9])) # Output: 9 # Example 4 print(find_unique_number([1, 1, 2, 2, 3])) # Output: 3 # Example 5 print(find_unique_number([4, 5, 5, 4, 6])) # Output: 6 ``` Notes: - Your solution should have a linear time complexity, ideally O(n), where n is the length of the list. - Take advantage of the properties of the XOR bitwise operation to achieve efficient performance.","solution":"def find_unique_number(nums: list[int]) -> int: Returns the integer that appears exactly once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Coding Question: Weather Forecast Application You are required to create a function that fetches the weather forecast data from a given weather API, processes the returned JSON data, and prints out the forecasted weather conditions for the next 3 days. This function should handle various potential errors and edge cases gracefully, like network issues or invalid API responses. Objective Write a function `fetch_weather(api_url: str, api_key: str, city: str)` that takes the following parameters: - `api_url` (str): Base URL of the weather API. - `api_key` (str): Your API key for accessing the weather API. - `city` (str): Name of the city for which to fetch the weather forecast. Function Specifications: * The function should construct the full API URL using the provided `api_url`, `city`, and `api_key`. * Make an HTTP GET request to fetch the weather forecast data. * Parse the JSON response data to extract and print the forecasted weather conditions for the next 3 days. * Include proper error handling for network problems, invalid API responses, and other potential issues. * Return a list of dictionaries where each dictionary contains the date and the forecasted conditions. Input: - `api_url` (str): e.g., \\"https://api.weather.com/v3/wx/forecast/daily\\" - `api_key` (str): e.g., \\"your_api_key_here\\" - `city` (str): e.g., \\"New York\\" Output: - A list of dictionaries where each dictionary contains the date and the forecasted weather conditions. Constraints: - The function should handle common errors gracefully and provide meaningful error messages. - Assume a timeout for network requests of 10 seconds. Example Function Call: ```python api_url = \\"https://api.weather.com/v3/wx/forecast/daily\\" api_key = \\"your_api_key_here\\" city = \\"New York\\" forecast = fetch_weather(api_url, api_key, city) for day in forecast: print(f\\"{day[\'date\']}: {day[\'condition\']}\\") ``` This should produce output similar to: ``` 2023-11-01: Sunny 2023-11-02: Partly cloudy 2023-11-03: Rainy ... ``` # Additional Notes: - You can use the `requests` library to make HTTP requests. - Ensure proper error handling, especially for potential issues like invalid responses or network errors.","solution":"import requests from typing import List, Dict, Any def fetch_weather(api_url: str, api_key: str, city: str) -> List[Dict[str, Any]]: Fetches the weather forecast data for the next 3 days using the given weather API. Args: api_url (str): Base URL of the weather API. api_key (str): API key for accessing the weather API. city (str): Name of the city for which to fetch the weather forecast. Returns: List[Dict[str, Any]]: A list of dictionaries where each dictionary contains the date and the forecasted conditions. try: # Construct the full API URL full_url = f\\"{api_url}?apiKey={api_key}&city={city}&days=3\\" # Make an HTTP GET request to fetch the weather forecast data response = requests.get(full_url, timeout=10) response.raise_for_status() # Parse the JSON response data data = response.json() # Extract the forecasted weather conditions for the next 3 days forecast = [] for day in data[\'forecasts\']: forecast.append({ \'date\': day[\'date\'], \'condition\': day[\'condition\'] }) return forecast except requests.RequestException as e: print(f\\"Network error occurred: {e}\\") return [] except (KeyError, TypeError, ValueError) as e: print(f\\"Error parsing API response: {e}\\") return []"},{"question":"# Question: Merging k Sorted Lists You are given `k` sorted integer lists, each with a potentially different number of elements. Your task is to merge these lists into a single sorted list. Write a function `merge_k_sorted_lists(lists: List[List[int]]) -> List[int]` that takes as input the list of `k` sorted integer lists and returns a single sorted list containing all the elements from the input lists. Constraints: - 1 ≤ k ≤ 100 - Each list will have at most 1000 elements - The total number of elements across all lists will not exceed 10000 Function Signature ```python def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: # Your implementation here ``` Example ```python assert merge_k_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] assert merge_k_sorted_lists([[2, 3, 7], [1, 5, 6], [4], []]) == [1, 2, 3, 4, 5, 6, 7] assert merge_k_sorted_lists([[], [], []]) == [] assert merge_k_sorted_lists([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Explanation For `lists = [[1, 4, 5], [1, 3, 4], [2, 6]]`, the merged result is a single sorted list: - Merging [1, 4, 5] and [1, 3, 4] results in [1, 1, 3, 4, 4, 5] - Merging the above list with [2, 6] results in the final sorted list [1, 1, 2, 3, 4, 4, 5, 6] For `lists = [[2, 3, 7], [1, 5, 6], [4], []]`, the merged result is a single sorted list: - Merging [2, 3, 7] with [1, 5, 6] results in [1, 2, 3, 5, 6, 7] - Merging the above list with [4] results in [1, 2, 3, 4, 5, 6, 7] - Merging the above list with [] keeps it as [1, 2, 3, 4, 5, 6, 7] For the empty lists, the function should return an empty list as there are no elements to merge. Implement the function to pass the provided examples and handle edge cases appropriately.","solution":"from typing import List import heapq def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: Merges k sorted lists into one sorted list. min_heap = [] # Insert the first element of each list into the min heap, along with the index of the list and the index of the element in the list for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, (lists[i][0], i, 0)) result = [] while min_heap: value, list_index, element_index = heapq.heappop(min_heap) result.append(value) # If there is a next element in the same list, push it into the min heap if element_index + 1 < len(lists[list_index]): next_value = lists[list_index][element_index + 1] heapq.heappush(min_heap, (next_value, list_index, element_index + 1)) return result"},{"question":"You need to implement a function that identifies and extracts all unique substrings of a given length from a provided string. This function must be efficient and handle various edge cases, including those involving overlapping substrings. # Task Implement a function that extracts all unique substrings of a given length from a provided string. # Function Signature ```python def unique_substrings(s: str, length: int) -> List[str]: Extracts all unique substrings of a given length from the provided string. Args: s (str): The input string from which substrings will be extracted. length (int): The length of each substring to be extracted. Returns: List[str]: A list of unique substrings of the specified length. pass ``` # Input * `s`: A string containing the input text. * `length`: An integer representing the length of each substring to be extracted. # Output * A list of unique substrings of the specified length. # Constraints * The `length` will be a positive integer. * The `s` will be a non-empty string. * If the `length` is greater than the length of the string `s`, return an empty list. # Examples ```python >>> unique_substrings(\\"hello\\", 2) [\'he\', \'el\', \'ll\', \'lo\'] >>> unique_substrings(\\"banana\\", 3) [\'ban\', \'ana\', \'nan\'] >>> unique_substrings(\\"abcd\\", 2) [\'ab\', \'bc\', \'cd\'] >>> unique_substrings(\\"aaaaa\\", 3) [\'aaa\'] ``` # Additional Notes * The substrings should maintain their order of appearance in the input string. * Ensure that substrings are not repeated in the output list. * Consider edge cases where the length of the substring exceeds the length of the input string, or where the input string contains repeated characters.","solution":"from typing import List def unique_substrings(s: str, length: int) -> List[str]: Extracts all unique substrings of a given length from the provided string. Args: s (str): The input string from which substrings will be extracted. length (int): The length of each substring to be extracted. Returns: List[str]: A list of unique substrings of the specified length. if length > len(s): return [] substrings = set() result = [] for i in range(len(s) - length + 1): substring = s[i:i + length] if substring not in substrings: substrings.add(substring) result.append(substring) return result"},{"question":"# Coding Question Problem Statement You are provided with a function `is_valid_sudoku(board)` intended to verify whether a given 9x9 Sudoku board is valid. Unfortunately, the given implementation is inefficient. Your task is to optimize this function. Write a function `optimized_is_valid_sudoku` that efficiently determines if the provided Sudoku board is valid. A valid Sudoku board (partially filled) shall not contain duplicate numbers in any row, column, or 3x3 sub-grid. A Sudoku board cannot have numbers outside the range 1 to 9. Only the empty cells are represented by the character \'.\'. Input - A list of lists `board` of size 9x9, representing a partially filled Sudoku board. Output - A boolean value `True` if the board is valid, otherwise `False`. Constraints - The input board is always a 9x9 list of lists. - Each element in the board is either a digit from \'1\' to \'9\' or a \'.\' indicating an empty cell. - Your solution should be optimized for efficiency and clarity. Performance Requirement - The expected runtime complexity is O(1), considering the constant size of the board. Examples 1. `optimized_is_valid_sudoku([ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ])` should return `True`. 2. `optimized_is_valid_sudoku([ [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ])` should return `False`. Function Signature ```python def optimized_is_valid_sudoku(board: List[List[str]]) -> bool: Determines if the given 9x9 Sudoku board is valid. pass ``` Additional Notes - Consider using sets to keep track of occurrences of numbers in rows, columns, and 3x3 sub-grids for efficient validation.","solution":"def optimized_is_valid_sudoku(board): Determines if the given 9x9 Sudoku board is valid. rows = [set() for _ in range(9)] columns = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for r in range(9): for c in range(9): num = board[r][c] if num == \'.\': continue box_index = (r // 3) * 3 + (c // 3) if num in rows[r] or num in columns[c] or num in boxes[box_index]: return False rows[r].add(num) columns[c].add(num) boxes[box_index].add(num) return True"},{"question":"# Problem Statement You are given a list of positive integers, representing the heights of students standing in a line. To make the line more interesting, you would like to reorder the students such that each student\'s height is different from the next one (the height difference between any two adjacent students is at least 1). Write a function to determine whether it is possible to reorder the students to achieve the desired height arrangement and to return one possible arrangement if it exists. If it is not possible, return an empty list. # Function Signature ```python def reorder_heights(heights: list[int]) -> list[int]: # Your implementation here ``` # Input and Output Input: * `heights`: A list of integers representing the heights of the students. The length of the list can be between 1 and 1000. Output: * A list of integers representing one possible arrangement if it is possible to achieve the desired height difference condition. If it is not possible, return an empty list. # Constraints - Each height is between 1 and 1000. - The heights list will contain at least one element. # Examples ```python assert reorder_heights([1, 3, 2, 4]) in [[1, 2, 3, 4], [4, 3, 2, 1], [3, 2, 4, 1], [1, 3, 4, 2]] assert reorder_heights([1, 1, 1, 2]) == [] assert reorder_heights([1, 2, 3]) in [[1, 2, 3], [3, 2, 1]] assert reorder_heights([7]) == [7] assert reorder_heights([100, 42, 36]) in [[36, 42, 100], [100, 42, 36]] ``` # Notes - Make sure to handle edge cases where the list might contain repeated heights. - For the output, any valid arrangement that satisfies the condition can be returned.","solution":"def reorder_heights(heights): heights.sort() if len(heights) == 1: return heights result = [] left = 0 right = len(heights) - 1 # Use a two-pointer approach to alternate between the smallest and largest remaining heights while left <= right: if left == right: result.append(heights[left]) else: result.append(heights[left]) result.append(heights[right]) left += 1 right -= 1 # Verify the result to see if it satisfies the conditions for i in range(1, len(result)): if abs(result[i] - result[i-1]) < 1: return [] return result"},{"question":"# Problem Statement You are tasked with implementing a function that given an integer array, will return the length, start index, and end index of the longest subarray with an equal number of even and odd integers. If multiple subarrays exist, return the one which appears first. # Function Signature ```python def longest_even_odd_subarray(arr: list) -> tuple: Finds the longest subarray with equal number of even and odd integers. Args: arr (list of int): The input array of integers. Returns: tuple: (length of the subarray, start index, end index) if such a subarray is found, otherwise (0, -1, -1). ``` # Input Constraints - `arr` is a list of integers provided. - The length of `arr` is between 1 and 5000. - `arr` will contain at least one even and one odd number. # Output Format - Return a tuple representing the length, start index, and end index of the longest subarray. - If no such subarray exists return (0, -1, -1). # Example ```python arr = [1, 2, 3, 6, 5, 4, 6, 5] print(longest_even_odd_subarray(arr)) # Output: (4, 0, 3) print(longest_even_odd_subarray([1, 1, 1, 1])) # Output: (0, -1, -1) as no even numbers print(longest_even_odd_subarray([2, 2, 2, 2])) # Output: (0, -1, -1) as no odd numbers ``` # Evaluation Criteria - Correctness: The function should return the correct length and indices for all test cases. - Efficiency: The function should run efficiently within acceptable time limits for large inputs. - Edge Cases: The function should correctly handle arrays with no eligible subarrays, minimal size arrays, and arrays where the longest subarray is the entire array.","solution":"def longest_even_odd_subarray(arr: list) -> tuple: Finds the longest subarray with equal number of even and odd integers. Args: arr (list of int): The input array of integers. Returns: tuple: (length of the subarray, start index, end index) if such a subarray is found, otherwise (0, -1, -1). n = len(arr) max_length = 0 start_index = -1 end_index = -1 prefix_sum = {0: -1} current_balance = 0 for i in range(n): if arr[i] % 2 == 0: current_balance += 1 else: current_balance -= 1 if current_balance in prefix_sum: length = i - prefix_sum[current_balance] if length > max_length: max_length = length start_index = prefix_sum[current_balance] + 1 end_index = i else: prefix_sum[current_balance] = i return (max_length, start_index, end_index)"},{"question":"# Coding Question Context In many real-world applications, such as network packet processing or game development, you might need to efficiently manage and manipulate sequences of operations or data. One common task is to rotate an array and calculate specific values based on that rotation. Task Implement a function `rotate_and_sum(arr: List[int], k: int) -> int` that first rotates the array `arr` to the right by `k` positions and then returns the sum of the elements from the rotated array at the indices specified by the rotation counts. Requirements 1. **Function Signature**: `rotate_and_sum(arr: List[int], k: int) -> int` 2. **Inputs**: - `arr` (List[int]): The list of integers to rotate and perform sums on. - `k` (int): The number of positions to rotate the array to the right. 3. **Output**: - Returns the sum of the elements of the array at positions that correspond to the rotation values. 4. **Constraints**: - `1 <= len(arr) <= 10^5` - `0 <= k <= len(arr)` Example ```python rotate_and_sum([1, 2, 3, 4, 5], 2) # Rotating [1, 2, 3, 4, 5] two positions to the right results in [4, 5, 1, 2, 3] # The relevant indices to sum are those that benefit from the rotation (i.e., contribute uniquely to the result) # Sum = 1 + 2 + 3 = 6 rotate_and_sum([10, 20, 30, 40, 50], 3) # Rotating [10, 20, 30, 40, 50] three positions to the right results in [30, 40, 50, 10, 20] # Sum = 30 + 40 + 50 + 10 + 20 = 150 ``` Edge Cases - Handling `k = 0`, which means no rotation. - Handling `k` being equal to or greater than the length of the array, which should effectively cycle back through the array. - Handling small and large values for both `k` and the length of `arr`. Write efficient and clean code, focusing on performance and correctness.","solution":"from typing import List def rotate_and_sum(arr: List[int], k: int) -> int: Rotates the array \'arr\' to the right by \'k\' positions and returns the sum of the elements from the rotated array at the indices specified by the rotation counts. n = len(arr) k = k % n # To handle cases where k >= n rotated_array = arr[-k:] + arr[:-k] return sum(rotated_array)"},{"question":"# Array Rotation Challenge You are given a class `RotatableArray` that supports basic operations like retrieving elements and setting elements at given indices. Your task is to enhance this class with a new method that rotates the array to the right by a given number of steps. # Requirements 1. Implement a method `right_rotate` which rotates the array in-place to the right by `k` steps. 2. The array should be rotated efficiently with consideration for large `k` values relative to the array size. # Input - The `right_rotate` method accepts a positive integer `k` representing the number of steps to rotate the array. - The array on which the operation is performed is a property of the `RotatableArray` instance. # Output - The method should modify the array in-place and does not return a value. # Example ```python # RotatableArray instance a a.set_elements([1, 2, 3, 4, 5, 6, 7]) # Calling your right_rotate method with k=3 a.right_rotate(3) # The array after rotation should be: a.get_elements() # Output should be: [5, 6, 7, 1, 2, 3, 4] ``` # Constraints 1. The rotation should be performed in-place, without using extra space for another array. 2. Handle the case where `k` is larger than the length of the array. 3. Optimize for time complexity considering `O(n)` operations where `n` is the length of the array. This question adds complexity by requiring knowledge of array manipulation and understanding of in-place operations, ensuring it fits within the same technical scope as the existing questions.","solution":"class RotatableArray: def __init__(self, elements): self.elements = elements def get_elements(self): return self.elements def set_elements(self, elements): self.elements = elements def right_rotate(self, k): Rotates the array to the right by k steps in-place. Args: k (int): Number of steps to rotate the array. n = len(self.elements) # Normalize k to be within the bounds of the array length k = k % n self.elements[:] = self.elements[-k:] + self.elements[:-k]"},{"question":"# Coding Assessment Question Scenario A software development company is working on a new feature for its todo list application. One of the requirements is to allow users to retrieve tasks that are marked as high priority and sort them based on their due dates. The tasks are represented in a specific format within a list. Task Your task is to implement the `filter_and_sort_tasks` function that processes a list of tasks and returns a list of high-priority tasks, sorted by their due dates. Requirements - The function should take one input, a list of dictionaries, `tasks`. Each dictionary represents a task with the following keys: - `description`: a string representing the task description. - `priority`: a string representing the task priority (\\"high\\", \\"medium\\", \\"low\\"). - `due_date`: a string representing the due date in the format \\"YYYY-MM-DD\\". - The function should filter out tasks that are not marked high priority. - The filtered tasks should be sorted in ascending order based on their due dates. Input Format: - A single list of dictionaries, `tasks`, where each dictionary contains the keys \'description\', \'priority\', and \'due_date\'. Output Format: - A list of dictionaries containing only the high-priority tasks, sorted by their due dates. Constraints: - Assume the list of tasks is not empty. - The dates will always be valid and in the format \\"YYYY-MM-DD\\". - The priority will always be one of \\"high\\", \\"medium\\", \\"low\\". Example: ```python Input: [ {\\"description\\": \\"Task 1\\", \\"priority\\": \\"low\\", \\"due_date\\": \\"2023-12-01\\"}, {\\"description\\": \\"Task 2\\", \\"priority\\": \\"high\\", \\"due_date\\": \\"2023-11-01\\"}, {\\"description\\": \\"Task 3\\", \\"priority\\": \\"medium\\", \\"due_date\\": \\"2023-10-15\\"}, {\\"description\\": \\"Task 4\\", \\"priority\\": \\"high\\", \\"due_date\\": \\"2023-09-30\\"} ] Output: [ {\\"description\\": \\"Task 4\\", \\"priority\\": \\"high\\", \\"due_date\\": \\"2023-09-30\\"}, {\\"description\\": \\"Task 2\\", \\"priority\\": \\"high\\", \\"due_date\\": \\"2023-11-01\\"} ] ``` Function Signature: ```python def filter_and_sort_tasks(tasks: list) -> list: pass ``` Good luck!","solution":"def filter_and_sort_tasks(tasks): Filters high-priority tasks and sorts them by due date. Args: tasks (list): A list of dictionaries, where each dictionary represents a task. Returns: list: A list of high-priority tasks sorted by their due dates. # Filter tasks to keep only high-priority ones high_priority_tasks = [task for task in tasks if task[\'priority\'] == \'high\'] # Sort the high-priority tasks by due date sorted_tasks = sorted(high_priority_tasks, key=lambda x: x[\'due_date\']) return sorted_tasks"},{"question":"# Problem Statement 2. **Function to Implement**: Write a function `find_subarrays_with_sum(arr: Sequence[int], target_sum: int) -> int` that takes two parameters: * `arr` (sequence of integers): An array of integers. * `target_sum` (integer): The target sum value. Expected Output: This function should return the number of contiguous subarrays that sum up to the `target_sum`. # Constraints * 1 <= len(arr) <= 10^5 * -10^3 <= arr[i] <= 10^3 for any valid index `i` * -10^5 <= target_sum <= 10^5 # Example ```python >>> find_subarrays_with_sum([1, 1, 1], 2) 2 >>> find_subarrays_with_sum([10, 2, -2, -20, 10], -10) 3 ``` # Notes * You can assume that the input format is correct. * Optimize your solution to run within practical limits for large input sizes. * Consider edge cases such as arrays with a single element or arrays where no subarrays sum to the `target_sum`. # Task Breakdown 1. Implement an additional helper function, if necessary, to support `find_subarrays_with_sum`. 2. Ensure an efficient algorithm, potentially using cumulative sums or a sliding window approach. 3. Handle edge cases appropriately, including when the array is empty or when the `target_sum` is zero.","solution":"from typing import Sequence from collections import defaultdict def find_subarrays_with_sum(arr: Sequence[int], target_sum: int) -> int: Returns the number of contiguous subarrays that sum up to the target_sum. count = 0 current_sum = 0 prefix_sum_count = defaultdict(int) prefix_sum_count[0] = 1 # For the subarray starting from the beginning for num in arr: current_sum += num if current_sum - target_sum in prefix_sum_count: count += prefix_sum_count[current_sum - target_sum] prefix_sum_count[current_sum] += 1 return count"},{"question":"# Question You are tasked with writing a function to simulate a ternary search tree (TST) for storing and searching strings efficiently. The TST node structure should contain three children (left, equal, and right) and a character value. The function should be capable of inserting new words into the TST and searching for words to return `True` if found and `False` otherwise. Function Signature ```python class TernarySearchTree: def __init__(self): Initialize the TST with the root set as None. pass def insert(self, word: str) -> None: Insert a word into the TST. :param word: A string to be inserted into the TST. pass def search(self, word: str) -> bool: Search for a word in the TST. :param word: A string to search for in the TST. :return: `True` if the word is found in the TST, otherwise `False`. pass ``` Input - `word` for `insert`: A non-empty string consisting of lowercase alphabets. - `word` for `search`: A non-empty string consisting of lowercase alphabets. Output - The `search` function should return `True` if the word is present in the TST, otherwise `False`. Constraints - `word` will contain only lowercase English letters (a-z). - The words to be inserted and searched can have a maximum length of 100 characters. - The number of words may be up to 10^5. Implementation Details 1. Define a `Node` class representing each character node in the TST. 2. Implement the `insert` and `search` methods in the `TernarySearchTree` class. 3. The `insert` method should handle the insertion by recursively determining the correct position (left, equal, or right). 4. The `search` method should traverse the TST similarly to determine whether the word exists within it. Example Usage ```python # Initialize TST tst = TernarySearchTree() # Insert words into TST tst.insert(\\"apple\\") tst.insert(\\"app\\") tst.insert(\\"orange\\") # Search for words print(tst.search(\\"apple\\")) # Expected Output: True print(tst.search(\\"app\\")) # Expected Output: True print(tst.search(\\"orange\\")) # Expected Output: True print(tst.search(\\"banana\\")) # Expected Output: False ``` In this example, \\"apple\\", \\"app\\", and \\"orange\\" are inserted into the TST. The searches for \\"apple\\", \\"app\\", and \\"orange\\" return `True` as those words are present, while the search for \\"banana\\" returns `False` since it has not been inserted.","solution":"class Node: def __init__(self, char): self.char = char self.left = None self.equal = None self.right = None self.is_end_of_word = False class TernarySearchTree: def __init__(self): Initialize the TST with the root set as None. self.root = None def _insert(self, node, word, index): char = word[index] if node is None: node = Node(char) if char < node.char: node.left = self._insert(node.left, word, index) elif char > node.char: node.right = self._insert(node.right, word, index) else: if index + 1 == len(word): node.is_end_of_word = True else: node.equal = self._insert(node.equal, word, index + 1) return node def insert(self, word): Insert a word into the TST. :param word: A string to be inserted into the TST. if word: self.root = self._insert(self.root, word, 0) def _search(self, node, word, index): if node is None: return False char = word[index] if char < node.char: return self._search(node.left, word, index) elif char > node.char: return self._search(node.right, word, index) else: if index + 1 == len(word): return node.is_end_of_word return self._search(node.equal, word, index + 1) def search(self, word): Search for a word in the TST. :param word: A string to search for in the TST. :return: `True` if the word is found in the TST, otherwise `False`. if word: return self._search(self.root, word, 0) return False"},{"question":"# Problem Statement You are required to implement a class `StringAnalyzer` that provides various utility methods for processing strings. The class should implement methods as described below. Ensure thorough testing and handle all possible edge cases. # Method Specifications: 1. **longest_palindrome(s: str) -> int**: - Finds the length of the longest palindrome substring in the given string `s`. - **Input**: A single string `s` (1 <= len(s) <= 1000). - **Output**: An integer representing the length of the longest palindrome substring. - **Constraints**: Raise a ValueError if `len(s)` > 1000 or if `s` contains non-alphabetic characters. 2. **word_frequencies(text: str) -> dict**: - Returns a frequency count of each word in the text. - **Input**: A single string `text` (1 <= len(text) <= 10^4). - **Output**: A dictionary where keys are words and values are their respective counts. - **Constraints**: Raise a ValueError if `len(text)` > 10^4 or if text contains non-space separators. 3. **anagram_groups(words: list) -> dict**: - Groups words that are anagrams of each other. - **Input**: A list of strings `words` (1 <= len(words) <= 1000, 1 <= len(word) <= 100). - **Output**: A dictionary where keys are sorted characters, and values are lists of words that are anagrams of each other. - **Constraints**: Raise a ValueError if `len(words)` > 1000 or any word exceeds 100 characters. 4. **longest_common_substring(s1: str, s2: str) -> str**: - Finds and returns the longest common substring between the two given strings `s1` and `s2`. - **Input**: Two strings `s1` and `s2` (1 <= len(s1), len(s2) <= 1000). - **Output**: A string representing the longest common substring. - **Constraints**: Raise a ValueError if `len(s1)` or `len(s2)` > 1000 or if either string contains non-alphabetic characters. # Implementation Details - The class should efficiently handle the string operations within the given constraints. - Helper functions can be utilized within the class but must be encapsulated appropriately. - Ensure that the methods adhere to input constraints and handle errors gracefully. Here is a suggested structure for the class: ```python class StringAnalyzer: def longest_palindrome(self, s: str) -> int: # Your code here pass def word_frequencies(self, text: str) -> dict: # Your code here pass def anagram_groups(self, words: list) -> dict: # Your code here pass def longest_common_substring(self, s1: str, s2: str) -> str: # Your code here pass ``` # Example Usage ```python sa = StringAnalyzer() print(sa.longest_palindrome(\\"babad\\")) # Output: 3 (either \\"bab\\" or \\"aba\\") print(sa.word_frequencies(\\"This is a test. This test is simple.\\")) # Output: {\'This\': 2, \'is\': 2, \'a\': 1, \'test.\': 1, \'test\': 1, \'simple.\': 1} print(sa.anagram_groups([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"])) # Output: {\'aet\': [\'eat\', \'tea\', \'ate\'], \'ant\': [\'tan\', \'nat\'], \'abt\': [\'bat\']} print(sa.longest_common_substring(\\"ABABC\\", \\"BABCA\\")) # Output: \\"BABC\\" ``` **Note** - Ensure to match the method signatures provided. - Python\'s built-in capabilities for string manipulation may be utilized. - Properly handle edge cases and ensure robustness in the implementation.","solution":"class StringAnalyzer: def longest_palindrome(self, s: str) -> int: if len(s) > 1000 or not s.isalpha(): raise ValueError(\\"Input string length must be <= 1000 and contain only alphabetic characters\\") def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 start = 0 end = 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return end - start + 1 def word_frequencies(self, text: str) -> dict: if len(text) > 10000: raise ValueError(\\"Input text length must be <= 10000\\") import re words = re.findall(r\'bw+b\', text) frequency = {} for word in words: frequency[word] = frequency.get(word, 0) + 1 return frequency def anagram_groups(self, words: list) -> dict: if len(words) > 1000 or any(len(word) > 100 for word in words): raise ValueError(\\"Number of words must be <= 1000 and each word length must be <= 100\\") from collections import defaultdict groups = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) groups[sorted_word].append(word) return dict(groups) def longest_common_substring(self, s1: str, s2: str) -> str: if len(s1) > 1000 or len(s2) > 1000 or not (s1.isalpha() and s2.isalpha()): raise ValueError(\\"Input strings must be <= 1000 characters and contain only alphabetic characters\\") m = len(s1) n = len(s2) longest = 0 ending_index = m length = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: length[i][j] = length[i - 1][j - 1] + 1 if length[i][j] > longest: longest = length[i][j] ending_index = i return s1[ending_index - longest: ending_index]"},{"question":"Scenario Recent advancements in data encoding techniques have led to an increased focus on understanding various representations of numbers and strings. You are tasked with using your skills in bitwise operations and binary manipulations to solve a problem involving the parity of binary numbers. This question evaluates your knowledge of bitwise algorithms, binary number conversions, and efficient data manipulation strategies. Problem Statement Given a positive integer `n`, implement the function `calculate_parity(n: int) -> int`, which calculates and returns the parity of the number `n`. The parity of a number is 1 if the number of 1-bits in its binary representation is odd, and 0 if the number of 1-bits is even. Input - `n` (integer): A positive integer for which the parity needs to be calculated. (1 ≤ n ≤ 1000000) Output - Returns an integer (0 or 1) representing the parity of the input number `n`. Function Signature ```python def calculate_parity(n: int) -> int: pass ``` Example ```python >>> calculate_parity(5) 0 >>> calculate_parity(7) 1 >>> calculate_parity(1023) 0 ``` Constraints - Your solution should handle the upper limit of 1000000 efficiently. - Ensure that the bitwise operations and the parity calculation are optimized for performance. Note Consider different methods for counting the number of 1-bits in the binary representation of `n` and choose the most efficient strategy to determine the parity.","solution":"def calculate_parity(n: int) -> int: Calculate the parity of a number n. The parity is 1 if the number of 1-bits in the binary representation is odd, and 0 if it is even. parity = 0 while n: parity ^= n & 1 n >>= 1 return parity"},{"question":"# Coding Assessment Question Sorting Large Files Split **Scenario**: You are tasked with sorting a very large file that cannot fit entirely into memory. The file contains lines of text, and each line is a record that needs to be sorted based on a specified key. The primary key for sorting will be the first word in each line. Requirements: You need to implement an external sorting algorithm to sort the large file efficiently. The steps to achieve this are as follows: 1. **Splitting and Sorting**: Read the input file in chunks, sort each chunk individually, and then write these sorted chunks to temporary files. 2. **Merging**: Use a multi-way merge to combine the sorted temporary files into a single sorted output file. Implementation Details: 1. **Splitting and Sorting**: - Read chunks of lines from the large file that fit into memory. - Sort each chunk based on the first word in each line. - Write the sorted chunks to temporary files. 2. **Merging**: - Use a priority queue (min-heap) to merge the sorted temporary files. - Ensure that the merge process writes to the output file in a memory-efficient manner. 3. **Temporary Files**: - Name temporary files uniquely to avoid collisions. - Clean up temporary files after the final sorted output is produced. Constraints: - Assume the input file is named `large_input.txt`. - The sorted output should be written to `sorted_output.txt`. - Aim to keep memory usage within a reasonable limit (e.g., chunks read into memory should be around 512MB). Function Signatures: ```python def split_and_sort(input_file: str, chunk_size: int, temp_file_prefix: str) -> list[str]: Splits the large input file into sorted chunks and returns a list of temporary file paths. pass def merge_sorted_files(temp_files: list[str], output_file: str): Merges the sorted temporary files into a single sorted output file. pass def external_sort(input_file: str, output_file: str, chunk_size: int = 512_000_000): Orchestrates the external sorting process by splitting, sorting, and merging the input file. pass ``` You should use `split_and_sort()` within the `external_sort()` function to handle file splitting and initial sorting, and `merge_sorted_files()` to handle merging of sorted chunks into the final sorted file. Example Usage: ```python external_sort(\'large_input.txt\', \'sorted_output.txt\') ``` By following these steps, you will efficiently sort a large file that cannot fit into memory, ensuring a sorted output while maintaining memory constraints.","solution":"import heapq import os import tempfile def split_and_sort(input_file: str, chunk_size: int, temp_file_prefix: str) -> list[str]: temp_files = [] with open(input_file, \'r\') as f: while True: lines = f.readlines(chunk_size) if not lines: break lines.sort(key=lambda x: x.split()[0]) temp_file = tempfile.NamedTemporaryFile(delete=False, prefix=temp_file_prefix, mode=\'w\') temp_file.writelines(lines) temp_files.append(temp_file.name) temp_file.close() return temp_files def merge_sorted_files(temp_files: list[str], output_file: str): streams = [open(file, \'r\') for file in temp_files] with open(output_file, \'w\') as output: min_heap = [] # Initialize the heap with the first line of each file for stream_index, stream in enumerate(streams): line = stream.readline() if line: heapq.heappush(min_heap, (line.split()[0], line, stream_index)) while min_heap: _, line, stream_index = heapq.heappop(min_heap) output.write(line) next_line = streams[stream_index].readline() if next_line: heapq.heappush(min_heap, (next_line.split()[0], next_line, stream_index)) for stream in streams: stream.close() for temp_file in temp_files: os.remove(temp_file) def external_sort(input_file: str, output_file: str, chunk_size: int = 512_000_000): temp_files = split_and_sort(input_file, chunk_size, \'temp_sort_\') merge_sorted_files(temp_files, output_file)"},{"question":"# Matrix Pathfinding with Cost Constraints Task You are tasked with finding the minimum cost path in a weighted grid from the top-left corner to the bottom-right corner. You may only move right or down at each step in the grid. Scenario Given a 2D list (matrix) where each element represents the cost of stepping on that cell, your goal is to create a function that computes the minimum path cost from the top-left corner to the bottom-right corner and returns the path taken. Requirements 1. Implement a function `min_path_cost(grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]` that calculates and returns: - The minimum cost to travel from the top-left corner to the bottom-right corner of the grid. - The path taken as a list of tuples, where each tuple represents the coordinates `(row, col)` of a cell in the grid. Input * A 2D list `grid` with dimensions `m x n` where `1 ≤ m, n ≤ 100` and each element is an integer representing the cost of that cell. Output * A tuple consisting of: - An integer representing the minimum cost to reach the bottom-right corner from the top-left corner. - A list of tuples representing the path taken with the minimum cost. Example ```python def min_path_cost(grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: # Implementation here pass grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_cost(grid)) # Output: # (7, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]) ``` # Constraints - Ensure the implementation handles edge cases, such as grids with only one row or one column. - Consider the time complexity to ensure it runs efficiently for the maximum grid size. Implement the outlined function to solve the problem effectively and test it with the provided example input.","solution":"from typing import List, Tuple def min_path_cost(grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: m, n = len(grid), len(grid[0]) dp = [[float(\'inf\')] * n for _ in range(m)] dp[0][0] = grid[0][0] paths = [[[] for _ in range(n)] for _ in range(m)] paths[0][0] = [(0, 0)] for i in range(m): for j in range(n): if i > 0: if dp[i][j] > dp[i - 1][j] + grid[i][j]: dp[i][j] = dp[i - 1][j] + grid[i][j] paths[i][j] = paths[i - 1][j] + [(i, j)] if j > 0: if dp[i][j] > dp[i][j - 1] + grid[i][j]: dp[i][j] = dp[i][j - 1] + grid[i][j] paths[i][j] = paths[i][j - 1] + [(i, j)] return dp[m - 1][n - 1], paths[m - 1][n - 1]"},{"question":"# Question You are given the task to implement a function to reverse the words in a sentence while maintaining the words\' original capitalization. The words may contain letters, digits, or special characters. The function should take into account the case sensitivity and ensure that the case of every letter remains the same after reversal. Function Specifications: 1. **reverse_words(sentence: str) -> str** * Takes a string `sentence` consisting of one or more words. * Each word in the sentence should be reversed individually while maintaining its original case. * Punctuation marks attached to words should remain at the same positions relative to those words. Input/Output Requirements: * The function should correctly handle sentences with mixed capitalization and various symbols. * The input sentence will be a non-empty string containing at least one word. * Words are separated by single spaces only. Example: ```python assert reverse_words(\\"Hello, World!\\") == \\",olleH !dlroW\\" assert reverse_words(\\"Python3.8 rocks!\\") == \\"nohtyP3.8 skcor!\\" sentence = \\"This is a Test-Sentence.\\" reversed_sentence = reverse_words(sentence) print(reversed_sentence) # \\".secnetneT-sa a si sihT\\" ``` Additional Context: Consider that you are building this function for a text processing module that aims to create humorous text transformations by reversing the words while keeping the style and case intact. You are expected to handle these special cases to ensure the transformed sentence retains its readability and correctness.","solution":"def reverse_words(sentence: str) -> str: This function takes a sentence as input and reverses each word individually while maintaining the original capitalization. def reverse_word(word: str) -> str: return word[::-1] words = sentence.split(\' \') reversed_words = [reverse_word(word) for word in words] return \' \'.join(reversed_words)"},{"question":"# Problem Statement You are tasked with creating a function to determine the length of the Collatz sequence for a given starting number. The Collatz sequence is defined as follows: Start with any positive integer n. Then, each term is obtained from the previous term as follows: - If the previous term is even, the next term is one half the previous term. - If the previous term is odd, the next term is 3 times the previous term plus 1. The sequence ends when it reaches the number 1. # Function Signature ```python def collatz_sequence_length(n: int) -> int: ``` # Input - **n**: A positive integer indicating the starting number of the sequence. # Output - Returns an integer representing the length of the Collatz sequence starting from `n`. # Constraints - The starting number `n` is a positive integer less than `1,000,000`. # Example ```python print(collatz_sequence_length(13)) # Output: 10 ``` # Requirements 1. Implement the function to compute the length of the Collatz sequence starting at `n`. 2. Ensure the function efficiently handles large values of `n` within the given constraint. 3. Utilize caching or memoization techniques to optimize performance, as recalculating sequences for many numbers can be computationally expensive. **Note**: Clear handling of computation and optimization techniques should be evident in your implementation to ensure the function executes efficiently for large inputs.","solution":"def collatz_sequence_length(n: int, memo={1: 1}) -> int: Returns the length of the Collatz sequence starting from n. Uses memoization to store previously computed results for efficiency. if n in memo: return memo[n] if n % 2 == 0: next_n = n // 2 else: next_n = 3 * n + 1 memo[n] = 1 + collatz_sequence_length(next_n) return memo[n]"},{"question":"# Task You need to implement a function that encodes a given string into its Morse code equivalent. Morse code is a method used in telecommunication to encode text characters as standardized sequences of two different signal durations, called dots and dashes. # Function Signature ```python def encode_morse(message: str) -> str: pass ``` # Input * `message (str)`: A string containing the message to be encoded. It consists of English letters (both uppercase and lowercase), digits, and spaces. # Output * A string representing the Morse code equivalent of the input message. Each Morse code letter or digit should be separated by a single space. There should be a triple space between Morse codes of separate words. # Constraints * All inputs will be valid strings containing only letters, digits, and spaces. * Spaces in the input message should be preserved and denoted by a triple space in the output Morse code. # Morse Code Representation ```plaintext A: .- B: -... C: -.-. D: -.. E: . F: ..-. G: --. H: .... I: .. J: .--- K: -.- L: .-.. M: -- N: -. O: --- P: .--. Q: --.- R: .-. S: ... T: - U: ..- V: ...- W: .-- X: -..- Y: -.-- Z: --.. 0: ----- 1: .---- 2: ..--- 3: ...-- 4: ....- 5: ..... 6: -.... 7: --... 8: ---.. 9: ----. ``` # Example ```python message = \\"HELLO WORLD 123\\" encoded_message = encode_morse(message) # Output should be: # \\".... . .-.. .-.. --- .-- --- .-. .-.. -.. .---- ..--- ...--\\" ``` # Notes Your function should correctly handle case insensitivity and convert all characters to uppercase for Morse code encoding as per the standard representation.","solution":"def encode_morse(message: str) -> str: morse_code = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } encoded_message = [] words = message.split(\' \') for word in words: encoded_word = \' \'.join(morse_code[char.upper()] for char in word) encoded_message.append(encoded_word) return \' \'.join(encoded_message)"},{"question":"# Coding Question You are tasked with creating a text editor that supports basic functionality: adding text, deleting text, and retrieving text. Your editor should maintain the correct state of the text document after each operation. Implement a class `TextEditor` with the following methods: 1. `add_text(position: int, text: str) -> None`: Adds the given text at the specified position. 2. `delete_text(position: int, length: int) -> None`: Deletes `length` characters from the specified position. 3. `get_text() -> str`: Retrieves the current state of the text. Function Signature ```python class TextEditor: def __init__(self) -> None: # Initialize your data structure here. pass def add_text(self, position: int, text: str) -> None: # Add text at the given position. pass def delete_text(self, position: int, length: int) -> None: # Delete `length` characters from the given position. pass def get_text(self) -> str: # Return the current state of the text. pass ``` Input - `position`: The position in the document to add or delete text from, 0-based index. - `text`: The string to be added. - `length`: The number of characters to delete. Output - Methods `add_text` and `delete_text` should not return anything. - Method `get_text` should return the current text as a string. Constraints - You can assume that operations will be valid (i.e., position will be within the bounds of the current text length for add and delete operations). - `0 <= position <= len(current_text)`. - When deleting, `0 <= (position + length) <= len(current_text)`. - `text` consists of English letters and perhaps punctuation marks. - Inputs to your functions will not be concurrent; they will be called sequentially. Example ```python editor = TextEditor() editor.add_text(0, \\"hello\\") print(editor.get_text()) # Output: \\"hello\\" editor.add_text(5, \\" world\\") print(editor.get_text()) # Output: \\"hello world\\" editor.delete_text(5, 6) print(editor.get_text()) # Output: \\"hello\\" ```","solution":"class TextEditor: def __init__(self) -> None: # Initialize an empty string to store our text self.text = \\"\\" def add_text(self, position: int, text: str) -> None: # Split the current text at the given position self.text = self.text[:position] + text + self.text[position:] def delete_text(self, position: int, length: int) -> None: # Remove the given length of text starting from the position self.text = self.text[:position] + self.text[position+length:] def get_text(self) -> str: # Return the current state of the text return self.text"},{"question":"Binary Search Tree Traversal Verification Background You are working on a code base that uses Binary Search Trees (BST) extensively for various operations. Your task is to ensure that given tree traversals are correct. Specifically, you need to verify if a given array is a valid InOrder traversal of a BST. Task Write a function `is_valid_inorder` that checks if the given array can be the InOrder traversal of a Binary Search Tree. Implementation Details * **Function Signature**: `def is_valid_inorder(arr: List[int]) -> bool` * **Input**: An array of integers `arr` (with length 0 ≤ |arr| ≤ 10^5). * **Output**: A boolean value `True` if the array is a valid InOrder traversal of a BST, `False` otherwise. Function Specifics 1. An InOrder traversal of a BST yields elements in non-decreasing order because in a BST, the left child is always less than the parent, and the right child is always greater than the parent. 2. Therefore, to verify if an array is a valid InOrder traversal, you need to check if it is sorted in non-decreasing order. Edge Cases * Handle empty arrays by returning `True` (an empty list could be considered a valid traversal of an empty tree). * Handle arrays with only one element by returning `True`. Example ```python def is_valid_inorder(arr: List[int]) -> bool: for i in range(1, len(arr)): if arr[i] < arr[i - 1]: return False return True # Example Usage print(is_valid_inorder([1, 2, 3, 4, 5])) # Output: True print(is_valid_inorder([2, 1, 3, 4, 5])) # Output: False ``` **Constraints**: * Time Complexity: O(n), where n is the length of the input array. * Space Complexity: O(1). Note The function should be efficient and handle large inputs gracefully.","solution":"from typing import List def is_valid_inorder(arr: List[int]) -> bool: Checks if the array can be a valid InOrder traversal of a Binary Search Tree. for i in range(1, len(arr)): if arr[i] < arr[i - 1]: return False return True # Example Usage: # print(is_valid_inorder([1, 2, 3, 4, 5])) # Output: True # print(is_valid_inorder([2, 1, 3, 4, 5])) # Output: False"},{"question":"# Question: Implement and Validate JSON Structure Context Imagine you are working on a data validation tool for a company that processes JSON files. They require a function that checks if a given JSON string conforms to a predefined structure, which includes specific nested keys and value types. Task 1. Implement a function `validate_json_structure(json_str: str, schema: dict) -> bool` that: - Takes a string `json_str` representing a JSON object. - Takes a dictionary `schema` representing the required structure. - Returns a boolean indicating whether the JSON object conforms to the schema. 2. The schema will describe: - Expected keys and their nested structures. - Expected data types (e.g., string, integer, list, dictionary). Implementation Constraints - Handle potential parsing errors for invalid JSON strings. - The validation of nested keys and types should be recursive and efficient. - Ensure linearithmic or better complexity, focusing on clarity and correctness. Input and Output - **Input**: A string `json_str` representing the JSON object and a dictionary `schema` representing the required structure. - **Output**: A boolean indicating whether the JSON object conforms to the schema. Examples ```python schema = { \\"name\\": str, \\"age\\": int, \\"address\\": { \\"street\\": str, \\"city\\": str, \\"zipcode\\": int }, \\"phone_numbers\\": [str] } valid_json_str = \'{\\"name\\": \\"John Doe\\", \\"age\\": 30, \\"address\\": {\\"street\\": \\"123 Elm St\\", \\"city\\": \\"Somewhere\\", \\"zipcode\\": 12345}, \\"phone_numbers\\": [\\"123-456-7890\\", \\"987-654-3210\\"]}\' invalid_json_str1 = \'{\\"name\\": \\"John Doe\\", \\"age\\": \\"30\\", \\"address\\": {\\"street\\": \\"123 Elm St\\", \\"city\\": \\"Somewhere\\", \\"zipcode\\": 12345}, \\"phone_numbers\\": [\\"123-456-7890\\", \\"987-654-3210\\"]}\' # Age is not int invalid_json_str2 = \'{\\"name\\": \\"John Doe\\", \\"age\\": 30, \\"address\\": {\\"street\\": \\"123 Elm St\\", \\"city\\": \\"Somewhere\\", \\"zipcode\\": 12345}, \\"phone_numbers\\": \\"123-456-7890\\"}\' # phone_numbers is not a list assert validate_json_structure(valid_json_str, schema) == True assert validate_json_structure(invalid_json_str1, schema) == False assert validate_json_structure(invalid_json_str2, schema) == False ``` Notes 1. You may use Python\'s built-in `json` module to parse the JSON string. 2. Focus on creating a robust and clear implementation that covers various edge cases. 3. Consider how to handle optional keys or additional fields not specified in the schema; by default, additional fields should be ignored.","solution":"import json def validate_json_structure(json_str, schema): try: json_obj = json.loads(json_str) except json.JSONDecodeError: return False def validate(obj, schema): if isinstance(schema, dict): if not isinstance(obj, dict): return False for key, value_schema in schema.items(): if key not in obj: return False if not validate(obj[key], value_schema): return False elif isinstance(schema, list): if not isinstance(obj, list): return False if len(schema) == 1: for item in obj: if not validate(item, schema[0]): return False else: return isinstance(obj, schema) return True return validate(json_obj, schema)"},{"question":"# Scenario You are aiding a team of engineers who are testing a new water distribution system. The system has various pipes connected in a network, and each pipe has a capacity that determines the amount of water it can hold. Given the volume of water in the system and the capacities of the pipes, the engineers need to determine which pipes are overflowing or underutilized. # Task Write a function `pipe_status(volumes, capacities)` that: 1. Accepts two lists: one with the current volume of water in each pipe and the other with the pipe capacities. 2. Returns a list of strings indicating the status of each pipe: \\"overflow\\" if the water volume exceeds the pipe\'s capacity, \\"underutilized\\" if the volume is less than 50% of the capacity, and \\"normal\\" otherwise. # Input and Output Formats Input * `volumes` (List[int]): A list of integers representing the current volume of water in each pipe. * `capacities` (List[int]): A list of integers representing the capacity of each pipe. Output * A list of strings where each string is \\"overflow\\", \\"underutilized\\", or \\"normal\\". # Function Signature ```python def pipe_status(volumes: list[int], capacities: list[int]) -> list[str]: ``` # Example ```python # Example 1 # Pipes with volumes [30, 80, 50] and capacities [100, 70, 60]. print(pipe_status([30, 80, 50], [100, 70, 60])) # Output: [\'underutilized\', \'overflow\', \'normal\'] # Example 2 # Pipes with volumes [10, 30, 0] and capacities [20, 80, 50]. print(pipe_status([10, 30, 0], [20, 80, 50])) # Output: [\'normal\', \'underutilized\', \'underutilized\'] # Example 3 # Pipes with volumes [101, 50, 50] and capacities [100, 50, 50]. print(pipe_status([101, 50, 50], [100, 50, 50])) # Output: [\'overflow\', \'normal\', \'normal\'] ``` # Constraints * The lengths of `volumes` and `capacities` are equal and both lists contain positive integers. * Each pipe has a positive capacity. **Complete the implementation in Python.**","solution":"def pipe_status(volumes, capacities): Determine the status of each pipe based on their volumes and capacities. Args: volumes (list): List of integers representing the current volume of water in each pipe. capacities (list): List of integers representing the capacity of each pipe. Returns: list: List of strings where each string is \\"overflow\\", \\"underutilized\\", or \\"normal\\". statuses = [] for volume, capacity in zip(volumes, capacities): if volume > capacity: statuses.append(\\"overflow\\") elif volume < 0.5 * capacity: statuses.append(\\"underutilized\\") else: statuses.append(\\"normal\\") return statuses"},{"question":"# Task You are tasked with implementing a function that efficiently finds the k-th smallest element in an unsorted list. The function should utilize the Quickselect algorithm, which is designed for this purpose. # Function Signature ```python def kth_smallest(nums: List[int], k: int) -> int: ... ``` # Input - `nums` (List[int]): A list of integers where the size of the list is `n` and `1 <= n <= 10^5`. - `k` (int): An integer representing the 1-based index of the smallest element you need to find. `1 <= k <= n`. # Output - Returns the k-th smallest element in the given list. # Example ```python >>> kth_smallest([3, 2, 1, 5, 4], 2) 2 >>> kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest([10, 4, 5, 8, 6, 11, 26], 5) 10 ``` # Considerations: - The function should have an average-case time complexity of O(n), which is a key feature of the Quickselect algorithm. - Handle edge cases like when the list might contain duplicates, and `k` is at the extremes (1 or n). - Do not use built-in sorting functions; implement the algorithm manually. # Hint: - Similar to Quicksort, Quickselect involves choosing a pivot element and partitioning the array such that elements less than the pivot are on the left, and elements greater than the pivot are on the right. However, only one half of the partitioned array is processed further, reducing the average computational complexity.","solution":"from typing import List import random def partition(nums, left, right): pivot_index = random.randint(left, right) nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # Swap pivot with right-most element pivot = nums[right] i = left for j in range(left, right): if nums[j] <= pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[right] = nums[right], nums[i] # Swap pivot to its final place return i def quickselect(nums, left, right, k_smallest): if left == right: # If the list contains only one element return nums[left] pivot_index = partition(nums, left, right) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(nums, left, pivot_index - 1, k_smallest) else: return quickselect(nums, pivot_index + 1, right, k_smallest) def kth_smallest(nums: List[int], k: int) -> int: return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"# Problem Statement You are required to implement a phone book that supports the following operations: 1. **Add Contact**: Adds a new contact with a given name and phone number to the phone book. 2. **Find Contact By Name**: Given a name, returns the phone number associated with the name. 3. **List All Contacts**: Returns a list of all contacts in the phone book ordered alphabetically by name. Function Signature ```python class PhoneBook: def __init__(self) -> None: Initialize an empty phone book. self.contacts = {} def add_contact(self, name: str, phone: str) -> None: Add a new contact to the phone book with the given name and phone number. If the name already exists in the phone book, update its phone number. self.contacts[name] = phone def find_contact_by_name(self, name: str) -> str: Find the phone number associated with the given name. If the name does not exist, return \\"Contact not found.\\" return self.contacts.get(name, \\"Contact not found.\\") def list_all_contacts(self) -> list: List all contacts in alphabetical order by name. Returns a list of tuples where each tuple contains (name, phone). return sorted(self.contacts.items()) ``` # Specifications - **Input Format**: A series of calls to the `add_contact`, `find_contact_by_name`, and `list_all_contacts` methods. - **Output Format**: The results of the `find_contact_by_name` and `list_all_contacts` method calls. - **Constraints**: - Contact names and phone numbers are non-empty strings. - Phone numbers may contain digits and common phone number characters such as \'(\', \')\', \'-\', and spaces. # Example ```python # Initialize phone book phone_book = PhoneBook() # Add contacts phone_book.add_contact(\'Alice\', \'555-1234\') phone_book.add_contact(\'Bob\', \'555-5678\') phone_book.add_contact(\'Charlie\', \'(555) 8765\') phone_book.add_contact(\'Alice\', \'555-4321\') # Update Alice\'s number # Find contacts by name print(phone_book.find_contact_by_name(\'Alice\')) # Output: \'555-4321\' print(phone_book.find_contact_by_name(\'Eve\')) # Output: \'Contact not found.\' # List all contacts print(phone_book.list_all_contacts()) # Output: [(\'Alice\', \'555-4321\'), (\'Bob\', \'555-5678\'), (\'Charlie\', \'(555) 8765\')] ``` # Notes 1. Use a dictionary to store contacts for efficient look-up and insertion operations. 2. Ensure the solution handles edge cases such as updating an existing contact\'s phone number or finding a contact that does not exist. 3. Python\'s `sorted` function should be used to order the list of contacts by name.","solution":"class PhoneBook: def __init__(self) -> None: Initialize an empty phone book. self.contacts = {} def add_contact(self, name: str, phone: str) -> None: Add a new contact to the phone book with the given name and phone number. If the name already exists in the phone book, update its phone number. self.contacts[name] = phone def find_contact_by_name(self, name: str) -> str: Find the phone number associated with the given name. If the name does not exist, return \\"Contact not found.\\" return self.contacts.get(name, \\"Contact not found.\\") def list_all_contacts(self) -> list: List all contacts in alphabetical order by name. Returns a list of tuples where each tuple contains (name, phone). return sorted(self.contacts.items())"},{"question":"# Context You are given a problem where you need to determine the length of the longest increasing subsequence in an array of integers. A subsequence is a sequence derived from another array by deleting some or none of the elements without changing the order of the remaining elements. # Task Implement a function `longestIncreasingSubsequence(nums: list[int]) -> int` that computes the length of the longest increasing subsequence using dynamic programming techniques to improve efficiency. # Inputs - `nums` - a list of integers representing the input array. # Outputs - Return an integer representing the length of the longest increasing subsequence. # Constraints 1. 1 <= len(nums) <= 1000 2. -10^4 <= nums[i] <= 10^4 # Performance Requirements - Your solution should have a time complexity of O(n^2) in the worst case. - Use an additional space complexity of O(n). # Example ```python # Input nums = [10, 9, 2, 5, 3, 7, 101, 18] # Expected Output result = 4 # Explanation The longest increasing subsequence is [2, 3, 7, 101], resulting in a length of 4. ``` # Edge Cases 1. If the input list `nums` contains only one element, the result should be 1 since a single element is a subsequence of length 1. 2. If all elements in `nums` are the same, the result should be 1 since any single element forms the longest increasing subsequence. Implement the function `longestIncreasingSubsequence` to solve the problem efficiently.","solution":"def longestIncreasingSubsequence(nums): Returns the length of the longest increasing subsequence in array nums. if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] represents the length of LIS ending at index i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Tree Diameter Calculation You are given a class `TreeNode` that represents a node in a binary tree. Your task is to implement a method in the `TreeDiameter` class that calculates the diameter of the binary tree. The diameter of a tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. # Problem Statement Implement the method `calculate_diameter` in the `TreeDiameter` class to find the diameter of the binary tree. The diameter is defined as the number of nodes on the longest path between two end nodes. # Constraints 1. The binary tree contains at most 10,000 nodes. 2. The tree is not necessarily balanced. 3. The values of the nodes are integers. # Input Format ```plaintext - The `TreeNode` root, the root node of the binary tree. ``` # Output Format ```plaintext - An integer representing the diameter of the tree. ``` # Example ```python # Define the TreeNode class here class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example binary tree # 1 # / # 2 3 # / # 4 5 tree_root = TreeNode(1) tree_root.left = TreeNode(2) tree_root.right = TreeNode(3) tree_root.left.left = TreeNode(4) tree_root.left.right = TreeNode(5) td = TreeDiameter() result = td.calculate_diameter(tree_root) print(result) # Output: 4 ``` # Implementation Implement the `TreeDiameter` class with the `calculate_diameter` method as follows: 1. Define the `calculate_diameter` method to recursively calculate the diameter. 2. Use a helper function to compute the height of subtrees, while keeping track of the maximum diameter found. ```python class TreeDiameter: def calculate_diameter(self, root: TreeNode) -> int: self.diameter = 0 def height(node: TreeNode) -> int: if not node: return 0 left_height = height(node.left) right_height = height(node.right) self.diameter = max(self.diameter, left_height + right_height + 1) return max(left_height, right_height) + 1 height(root) return self.diameter - 1 ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class TreeDiameter: def calculate_diameter(self, root: TreeNode) -> int: self.diameter = 0 def height(node: TreeNode) -> int: if not node: return 0 left_height = height(node.left) right_height = height(node.right) # Update the diameter if the current path is larger self.diameter = max(self.diameter, left_height + right_height + 1) # Return the height of the current node return max(left_height, right_height) + 1 height(root) # Diameter is the number of nodes in the longest path - 1 gives number of edges return self.diameter - 1"},{"question":"# Problem Statement: You are required to demonstrate your understanding and skills in managing and manipulating nested data structures by implementing functions that process a matrix of strings. Each element in the matrix is a string composed of alphabetic characters. # Function Requirements: 1. **`check_vowel_matrix(matrix: List[List[str]]) -> List[List[bool]]`**: - **Input**: - `matrix` (List[List[str]]): A 2D list of strings, where each string consists of alphabetic characters only. - **Output**: - Return a 2D list of booleans of the same dimensions as the input matrix. Each boolean value should be `True` if the corresponding string in the input matrix starts with a vowel (a, e, i, o, u, regardless of case), and `False` otherwise. 2. **`transpose_and_concatenate(matrix: List[List[str]]) -> str`**: - **Input**: - `matrix` (List[List[str]]): A 2D list of strings, with consistent row lengths. - **Output**: - Return a single concatenated string formed by transposing the matrix (i.e., converting rows to columns and vice versa), then concatenating all elements row-wise. # Constraints: - The `matrix` can have any non-zero dimensions but will always be rectangular (all rows have the same length). - All strings in the matrix will contain alphabetic characters only and will not be empty. # Example: ```python matrix = [ [\\"Apple\\", \\"banana\\"], [\\"Orange\\", \\"elderberry\\"] ] # Example 1: Check Vowel Matrix vowel_check = check_vowel_matrix(matrix) assert vowel_check == [ [True, False], [True, True] ] # Example 2: Transpose and Concatenate transposed_concat = transpose_and_concatenate(matrix) assert transposed_concat == \\"AppleOrangebananaelderberry\\" ``` # Additional Requirements: - Focus on readability and modularity of your code. - Ensure your code is efficient in both time and space complexity. - Handle edge cases such as varying matrix dimensions and different character cases properly. - Provide sufficient comments and structure to make your logic easy to understand.","solution":"from typing import List def check_vowel_matrix(matrix: List[List[str]]) -> List[List[bool]]: Returns a 2D list of booleans where each element is True if the corresponding string in the input matrix starts with a vowel, and False otherwise. vowels = set(\'aeiouAEIOU\') return [[word[0] in vowels for word in row] for row in matrix] def transpose_and_concatenate(matrix: List[List[str]]) -> str: Transposes the input matrix and concatenates all elements row-wise into a single string. transposed = list(zip(*matrix)) return \'\'.join(\'\'.join(row) for row in transposed)"},{"question":"# Pathfinding in a Maze You are to design a function that finds whether there is a path from the start to the end in a given maze. The path can only be created by moving horizontally or vertically, not diagonally. Input - `maze`: A list of lists representing the maze (a 2D matrix of integers) where `1` represents a wall and `0` represents an accessible path. - `start`: A tuple `(x, y)` indicating the starting position in the maze. - `end`: A tuple `(x, y)` indicating the ending position in the maze. Output - Return `True` if there is a direct path from the start to the end. Otherwise, return `False`. Example ```python def path_in_maze(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> bool: # Your implementation here maze = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] start = (0, 0) end = (3, 3) print(path_in_maze(maze, start, end)) # True maze = [ [0, 1, 1, 0], [1, 0, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0] ] start = (0, 0) end = (3, 3) print(path_in_maze(maze, start, end)) # False ``` # Constraints - The maze will contain at most 100x100 cells. - Both `start` and `end` will always be within the maze bounds. - The start and end positions will not be walls (`1`). # Performance Requirement - The function should efficiently find the path using a suitable search algorithm, such as Breadth-First Search (BFS) or Depth-First Search (DFS), considering the maze constraints. # Detailed Requirements - Implement helper functions if necessary to support the main pathfinding function. - Ensure proper handling of edge cases like starting or ending at the boundary of the maze. - Optimize the search to avoid revisiting cells and reduce unnecessary computations. Showcase your solution by demonstrating the function\'s ability to find the correct path through the maze. Validate your solution with the provided example tests.","solution":"from collections import deque def path_in_maze(maze, start, end): Determines if there\'s a path from start to end in the given maze. Parameters: maze (list of list of int): The maze represented as a 2D grid. start (tuple of int): The starting position in the maze. end (tuple of int): The ending position in the maze. Returns: bool: True if there\'s a path from start to end, False otherwise. rows, cols = len(maze), len(maze[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and maze[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"# Coding Assessment Question **Title**: Subsets Without Duplicates **Objective**: Implement a function that generates all possible subsets of a given sequence of numbers without any duplicates. **Context**: Given a sequence of unique integers, the task is to generate all possible subsets (also known as the power set). The subsets must be returned in lexicographical order. **Function Signature**: ```python def find_all_subsets(sequence: list[int]) -> list[list[int]]: pass ``` **Input/Output Format**: * **Input**: A list of unique integers (`sequence`). You can assume the sequence will not be empty and will have at most 8 elements. * **Output**: Return a list of lists, where each inner list represents a subset. The subsets must be ordered lexicographically. **Constraints**: * Each number in the input list is unique. * The input list has a maximum length of 8. * The order in the subsets is not considered, a subset `[1, 2]` is the same as `[2, 1]`. **Examples**: Example 1: ```python sequence = [1, 2, 3] print(find_all_subsets(sequence)) ``` Output: ``` [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] ``` Example 2: ```python sequence = [4, 5, 6] print(find_all_subsets(sequence)) ``` Output: ``` [[], [4], [4, 5], [4, 5, 6], [4, 6], [5], [5, 6], [6]] ``` **Hints**: 1. Consider using backtracking or recursion to explore all combinations of subsets. 2. Sort the sequence initially to guarantee lexicographical order without extra sorting. 3. Start from an empty subset and iteratively add remaining elements to form new subsets. **Implementation Note**: Use recursion and tracking of the current subset state to generate all possible subsets efficiently. Ensure your function handles the combination generation correctly and outputs results in the expected order.","solution":"def find_all_subsets(sequence: list[int]) -> list[list[int]]: Function to generate all possible subsets of the given sequence of numbers without any duplicates. The subsets are returned in lexicographical order. def backtrack(start, path): subsets.append(path[:]) # Add the current subset to the list for i in range(start, len(sequence)): path.append(sequence[i]) backtrack(i + 1, path) path.pop() sequence.sort() subsets = [] backtrack(0, []) return subsets"},{"question":"# Coding Question You are asked to implement a function to facilitate the merging and summarization of log files. Each log file contains entries in a specific format, and your task is to merge multiple log files based on a common timestamp. Additionally, you should generate a summary of the number of entries for each unique event type. Your function should take the following parameters: - `log_files` (List[str]): A list of file paths for the log files to be merged. - `output_file` (str): Path to the file where the merged log entries and summary will be saved. Log entries in each file follow the format: ``` timestamp,event_type,event_details ``` Where `timestamp` is a string in ISO 8601 format, `event_type` is a string representing the type of event, and `event_details` is a string with additional information about the event. Your function should produce an output file with all log entries merged and sorted by timestamp. After the merged entries, add a summary section that includes the count of each unique event type. # Function Signature ```python from typing import List def merge_and_summarize_logs(log_files: List[str], output_file: str) -> None: pass ``` # Requirements: 1. Merge log entries from the provided log files, ensuring entries are sorted by timestamp. 2. Ensure no duplicate entries appear in the merged log. 3. Append a summary section at the end of the output file showing the count of each event type. 4. Use efficient file reading/writing techniques to handle potentially large log files. # Example Consider two log files with the following content: **log1.txt** ``` 2023-10-01T12:00:00Z,login,UserA 2023-10-01T12:05:00Z,logout,UserA 2023-10-01T12:10:00Z,login,UserB ``` **log2.txt** ``` 2023-10-01T12:02:00Z,login,UserC 2023-10-01T12:05:00Z,login,UserD ``` Applying the function should merge and summarize these logs into the output file: **output_log.txt** ``` 2023-10-01T12:00:00Z,login,UserA 2023-10-01T12:02:00Z,login,UserC 2023-10-01T12:05:00Z,logout,UserA 2023-10-01T12:05:00Z,login,UserD 2023-10-01T12:10:00Z,login,UserB Summary: login: 4 logout: 1 ``` This function should handle multiple log files, ensuring accurate merging by timestamp and proper event type summarization at the end.","solution":"from typing import List from collections import defaultdict import os def merge_and_summarize_logs(log_files: List[str], output_file: str) -> None: # Dictionary to store the merged log entries merged_logs = {} # Dictionary to store event counts event_counts = defaultdict(int) # Read all log files for log_file in log_files: with open(log_file, \'r\') as f: for line in f: timestamp, event_type, event_details = line.strip().split(\',\') if (timestamp, event_type, event_details) not in merged_logs: merged_logs[(timestamp, event_type, event_details)] = line.strip() event_counts[event_type] += 1 # Sort log entries by timestamp sorted_logs = sorted(merged_logs.keys(), key=lambda x: x[0]) # Write merged log entries to the output file with open(output_file, \'w\') as out: for log_key in sorted_logs: out.write(merged_logs[log_key] + \'n\') # Write the summary section out.write(\\"nSummary:n\\") for event_type, count in event_counts.items(): out.write(f\\"{event_type}: {count}n\\")"},{"question":"# Question: Generate and Analyze Weather Data You are tasked with creating a program that retrieves and analyzes weather data using the OpenWeatherMap API. Your program should have the following functionalities: 1. **Fetch current weather data** for a given city. 2. **Analyze temperature trends** for a list of cities by calculating the average temperature from the fetched data. Functional Requirements: - **Function 1**: `get_current_weather(city: str) -> dict` - `city`: A string specifying the city name. - Returns a dictionary containing: ```python { \\"temperature\\": \\"Current temperature in Celsius\\", \\"humidity\\": \\"Current humidity in percentage\\", \\"description\\": \\"Weather description\\" } ``` - **Function 2**: `get_average_temperature(cities: list) -> float` - `cities`: A list of city names as strings. - Returns the average temperature of the given cities. Input and Output - **Input**: The `get_current_weather` function takes a city name as input, whereas `get_average_temperature` takes a list of city names. - **Output**: The functions should return the expected data structures as outlined above. Constraints: - Your implementation should handle network errors gracefully, returning `None` or `0` in case of failures. - You must use the `requests` library. - Ensure your API key for OpenWeatherMap is hidden and secure. - Set a timeout value of 10 seconds for your API calls. Example ```python weather = get_current_weather(\\"London\\") # Expected output: {\'temperature\': 15.34, \'humidity\': 78, \'description\': \'light rain\'} average_temp = get_average_temperature([\\"London\\", \\"Berlin\\", \\"Paris\\"]) # Expected output: 14.56 ``` Write the function implementations for `get_current_weather(city: str)` and `get_average_temperature(cities: list)`.","solution":"import requests API_KEY = \'YOUR_API_KEY_HERE\' # You should replace this with your actual API key BASE_URL = \'http://api.openweathermap.org/data/2.5/weather\' def get_current_weather(city: str) -> dict: Fetches the current weather data for a given city. Args: - city (str): The name of the city for which to fetch weather data. Returns: - dict: A dictionary containing temperature, humidity, and weather description. try: response = requests.get(BASE_URL, params={ \'q\': city, \'appid\': API_KEY, \'units\': \'metric\' }, timeout=10) response.raise_for_status() data = response.json() weather_data = { \'temperature\': data[\'main\'][\'temp\'], \'humidity\': data[\'main\'][\'humidity\'], \'description\': data[\'weather\'][0][\'description\'] } return weather_data except (requests.exceptions.RequestException, KeyError): return None def get_average_temperature(cities: list) -> float: Calculates the average temperature for a list of cities. Args: - cities (list): A list of city names. Returns: - float: The average temperature of the provided cities. temperatures = [] for city in cities: weather = get_current_weather(city) if weather: temperatures.append(weather[\'temperature\']) if not temperatures: return 0.0 return sum(temperatures) / len(temperatures)"},{"question":"# Question: Unique Powers Function You need to implement a function that returns a generator, which will produce powers of a given base starting from the given exponent up to a certain limit. The function should yield each power one by one, efficiently managing memory and avoiding computation of all powers upfront. Function Signature ```python def power_generator(base: int, start_exponent: int, limit: int) -> iter: # Your code here ``` # Input - `base` (int): The base number to be raised to successive powers. - `start_exponent` (int): The starting exponent. - `limit` (int): The upper limit of the value of the exponent. # Output - Returns a generator that yields each power of the base from `base^start_exponent` to `base^limit`. # Example ```python gen = power_generator(2, 0, 5) assert list(gen) == [1, 2, 4, 8, 16, 32] gen = power_generator(3, 1, 3) assert list(gen) == [3, 9, 27] # Testing generator behavior gen = power_generator(2, 2, 4) assert next(gen) == 4 assert next(gen) == 8 assert next(gen) == 16 try: next(gen) except StopIteration: pass ``` # Notes - Ensure that the generator handles large numbers smoothly. - The generator should yield each power one by one in an incremental manner. - Validate the inputs to ensure `base` is a positive integer and `start_exponent` and `limit` are non-negative integers.","solution":"def power_generator(base: int, start_exponent: int, limit: int) -> iter: Generates powers of a given base from base^start_exponent to base^limit. :param base: The base number to be raised to successive powers. Must be a positive integer. :param start_exponent: The starting exponent. Must be a non-negative integer. :param limit: The upper limit of the value of the exponent. Must be a non-negative integer. :return: A generator that yields each power of the base from base^start_exponent to base^limit. if base < 1 or start_exponent < 0 or limit < 0: raise ValueError(\\"Invalid input: base must be a positive integer and start_exponent and limit must be non-negative integers.\\") for exponent in range(start_exponent, limit + 1): yield base ** exponent"},{"question":"# Problem Statement You need to implement a function that calculates the time taken for a car to cover a certain distance given the speed of the car and the distance. The relation between time, speed, and distance is given by: [ text{time} = frac{text{distance}}{text{speed}} ] # Function Signature ```python def calculate_travel_time(speed: float, distance: float) -> float: ``` # Input * `speed` (float): The speed of the car in units per hour. Must be a positive number. * `distance` (float): The distance to be covered in units. Must be a positive number. # Output * `float`: The calculated travel time in hours. # Constraints * Both speed and distance must be positive and non-zero. * The function should raise a `ValueError` with the message \\"Speed and distance must be positive\\" if either of the inputs are not positive. # Performance Requirements * The solution must execute in constant time (O(1)). # Examples 1. **Example 1**: Input: `speed=60`, `distance=180` Output: `3.0` Explanation: ( text{time} = frac{180}{60} = 3 ) 2. **Example 2**: Input: `speed=50`, `distance=100` Output: `2.0` Explanation: ( text{time} = frac{100}{50} = 2 ) 3. **Example 3**: Input: `speed=-80`, `distance=160` Output: Raises a `ValueError` with message \\"Speed and distance must be positive\\".","solution":"def calculate_travel_time(speed: float, distance: float) -> float: Calculate the time taken to travel a certain distance given the speed. Parameters: speed (float): The speed of the car in units per hour. Must be a positive number. distance (float): The distance to be covered in units. Must be a positive number. Returns: float: The calculated travel time in hours. Raises: ValueError: If either speed or distance is not positive. if speed <= 0 or distance <= 0: raise ValueError(\\"Speed and distance must be positive\\") return distance / speed"},{"question":"# Road Network Shortest Path Calculation Objective: Implement a function that takes a road network represented as a graph and computes the shortest path between two nodes using Dijkstra\'s algorithm. Description: Given a road network represented as a weighted, directed graph, you need to find the shortest path between a given source node and a target node. The graph is represented using an adjacency list where each node has a list of tuples representing its neighbors and the respective weights (distances). Function Definition: ```python def shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int, target: int) -> List[int]: Calculate the shortest path in a graph using Dijkstra\'s algorithm. Args: graph (Dict[int, List[Tuple[int, int]]]): A dictionary representing the adjacency list of the graph. Keys are node identifiers and values are lists of tuples (neighbor, weight). source (int): The starting node identifier. target (int): The destination node identifier. Returns: List[int]: A list of node identifiers representing the shortest path from source to target. If no path exists, return an empty list. ``` Constraints: 1. The graph nodes are non-negative integers. 2. The weights are positive integers. 3. There may be multiple paths between nodes, but you must find the shortest one. 4. Handle graphs with potential cycles. Input: - `graph`: A dictionary representing the adjacency list of the graph. - `source`: An integer representing the starting node. - `target`: An integer representing the target node. Output: - A list of integers representing the sequence of nodes in the shortest path. Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 target = 3 result = shortest_path(graph, source, target) print(result) # Expected output: [0, 2, 1, 3] (sequence of nodes for the shortest path) ``` Edge Cases to Consider: 1. Source and target being the same node. 2. Disconnected graph where no path exists from the source to the target. 3. Handling large graphs efficiently. 4. Ensuring the algorithm terminates correctly in the presence of cycles. Good luck!","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int, target: int) -> List[int]: Calculate the shortest path in a graph using Dijkstra\'s algorithm. Args: graph (Dict[int, List[Tuple[int, int]]]): A dictionary representing the adjacency list of the graph. Keys are node identifiers and values are lists of tuples (neighbor, weight). source (int): The starting node identifier. target (int): The destination node identifier. Returns: List[int]: A list of node identifiers representing the shortest path from source to target. If no path exists, return an empty list. # Priority queue to store (distance, node) queue = [(0, source)] # Dictionary to store the shortest distances from source to each node distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Dictionary to store the previous node in the shortest path previous_nodes = {node: None for node in graph} while queue: current_distance, current_node = heapq.heappop(queue) # Early exit if we reach the target if current_node == target: break # If current node\'s distance is greater than the recorded shortest distance, skip processing if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight # If a shorter path to the neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) # Reconstruct the shortest path path = [] current = target while current is not None: path.append(current) current = previous_nodes[current] path.reverse() # If the source is included in the reconstructed path, return it, else return an empty list return path if path and path[0] == source else []"},{"question":"Sorting Books by Publication Year Scenario You are developing a library management system that helps in sorting books based on their publication years. Your task is to write a function that sorts a list of books by their publication year in ascending order. Problem Statement Implement a function `sort_books_by_year(books: List[Dict[str, Any]]) -> List[Dict[str, Any]]` that takes a list of dictionaries, where each dictionary represents a book with at least two keys: - `title`: a string representing the book\'s title. - `year`: an integer representing the year the book was published. The function should return a list of dictionaries sorted by the `year` key in ascending order. Input Format: * `books` - a list of dictionaries. Each dictionary includes: - `title` - a string representing the book\'s title. - `year` - an integer representing the publication year of the book. Output Format: * A list of dictionaries sorted by the `year` key in ascending order. Constraints: * The list `books` may be empty. * Each dictionary in the list is guaranteed to have a `title` and a `year` key, where: - `title` is a non-empty string. - `year` is a non-negative integer. Examples: ```python >>> books = [ ... {\\"title\\": \\"The Great Gatsby\\", \\"year\\": 1925}, ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"year\\": 1960}, ... {\\"title\\": \\"1984\\", \\"year\\": 1949} ... ] >>> sort_books_by_year(books) [ {\\"title\\": \\"The Great Gatsby\\", \\"year\\": 1925}, {\\"title\\": \\"1984\\", \\"year\\": 1949}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"year\\": 1960} ] >>> sort_books_by_year([]) [] >>> books = [ ... {\\"title\\": \\"Brave New World\\", \\"year\\": 1932}, ... {\\"title\\": \\"Animal Farm\\", \\"year\\": 1945}, ... {\\"title\\": \\"Fahrenheit 451\\", \\"year\\": 1953} ... ] >>> sort_books_by_year(books) [ {\\"title\\": \\"Brave New World\\", \\"year\\": 1932}, {\\"title\\": \\"Animal Farm\\", \\"year\\": 1945}, {\\"title\\": \\"Fahrenheit 451\\", \\"year\\": 1953} ] ``` Notes: - Ensure that the function handles an empty list correctly. - Maintain the original structure of each dictionary in the list. - The sorting should be stable; books published in the same year should retain their original order relative to each other.","solution":"from typing import List, Dict, Any def sort_books_by_year(books: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Sorts a list of books by their publication year in ascending order. Parameters: books (List[Dict[str, Any]]): A list of dictionaries, where each dictionary represents a book with \'title\' and \'year\' keys. Returns: List[Dict[str, Any]]: The list of books sorted by the \'year\' key. return sorted(books, key=lambda book: book[\'year\'])"},{"question":"# Problem Statement You are given a list of strings representing different file paths in a file system. Implement a data structure that efficiently supports directory creation and file path queries to understand the directory structure. Specifically, you need to implement a FileSystem class that can perform the following operations: 1. **Create a directory** at a given path. 2. **Return a list of all paths** starting with a given prefix. # Input 1. A series of paths represented as strings in the following format: `/directory/subdirectory/.../`. 2. Multiple operations: `mkdir` and `ls`. # Output For each `ls` operation, return a list of all paths in the file system that start with the specified prefix in lexicographical order. # Operations 1. `mkdir(path)`: Create a directory at the given absolute `path`. 2. `ls(prefix)`: Return a list of all paths that start with the given `prefix`. # Constraints * The length of any path string will be between 1 and 200. * Each path will only contain lowercase alphanumeric characters (\'a\'-\'z\', \'0\'-\'9\'), slashes (\'/\'), or periods (\'.\'). * The number of operations will not exceed 100000. # Example ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/a/b/d\\") fs.mkdir(\\"/e/f\\") print(fs.ls(\\"/a/b\\")) # Should return [\\"/a/b/c\\", \\"/a/b/d\\"] print(fs.ls(\\"/e\\")) # Should return [\\"/e/f\\"] print(fs.ls(\\"/a\\")) # Should return [\\"/a/b/c\\", \\"/a/b/d\\"] ``` # Requirements Implement the `FileSystem` class with the following method stubs: ```python class FileSystem: def __init__(self): Initializes the FileSystem. def mkdir(self, path: str): Creates a directory at the given path. def ls(self, prefix: str) -> list: Returns a list of all paths that start with the given prefix, in lexicographical order. ``` You need to implement the above class so that it correctly supports the `mkdir` and `ls` operations efficiently. # Implementation Notes * Use a suitable data structure, like a Trie or a nested dictionary, to manage the directory hierarchy. * Ensure that all operations conform to the expected time complexity and handle edge cases such as querying for non-existent paths.","solution":"class FileSystem: def __init__(self): Initializes the FileSystem. self.paths = set() def mkdir(self, path: str): Creates a directory at the given path. self.paths.add(path) def ls(self, prefix: str) -> list: Returns a list of all paths that start with the given prefix, in lexicographical order. return sorted([path for path in self.paths if path.startswith(prefix)]) # Example usage: # fs = FileSystem() # fs.mkdir(\\"/a/b/c\\") # fs.mkdir(\\"/a/b/d\\") # fs.mkdir(\\"/e/f\\") # print(fs.ls(\\"/a/b\\")) # Should return [\\"/a/b/c\\", \\"/a/b/d\\"] # print(fs.ls(\\"/e\\")) # Should return [\\"/e/f\\"] # print(fs.ls(\\"/a\\")) # Should return [\\"/a/b/c\\", \\"/a/b/d\\"]"},{"question":"# Problem Statement Imagine you are handling a text processing feature in a word processing software. One of the features is automatically applying proper title casing to given phrases, where each word\'s first letter is capitalized while the rest are in lower case. This problem aims to ensure that you can properly manipulate and transform text data using fundamental string operations. # Function to Implement Implement the function `title_case(phrase: str) -> str` in Python, where: * `phrase` is a string containing words separated by spaces. # Input and Output * **Input**: A string `phrase` that may include common punctuation marks (e.g., commas, periods, exclamation marks) adjacent to words. * **Output**: A formatted string with each word\'s first letter capitalized and the rest of the letters in lower case. # Constraints 1. The length of the input phrase will be between `0` and `10^3`. 2. The phrase may include alphabetic characters, spaces, and common punctuation. 3. Words are considered sequences of alphabetic characters separated by spaces or punctuation. # Examples ```python assert title_case(\\"hello world\\") == \\"Hello World\\" assert title_case(\\"this is a TEST\\") == \\"This Is A Test\\" assert title_case(\\"python programming, it\'s fun!\\") == \\"Python Programming, It\'s Fun!\\" assert title_case(\\"already ProPerly cASeD\\") == \\"Already Properly Cased\\" assert title_case(\\"single\\") == \\"Single\\" ``` # Implementation Notes When solving this problem: * Ignore any non-alphabetic characters when determining word boundaries but include them in the final title-case string as-is. * Ensure the transformation is applied correctly even in the presence of mixed case input. * Handle cases where input may be empty or consist only of punctuation or spaces.","solution":"def title_case(phrase: str) -> str: Returns a title-cased version of the input phrase. Each word\'s first letter is capitalized while the rest are in lower case. return \' \'.join(word.capitalize() for word in phrase.split())"},{"question":"# Text File Analysis **Objective**: Implement a function to analyze the contents of a text file and return specific statistics in a well-defined format. **Scenario**: In a project where you need to analyze large text files (such as logs or documentation), implement a function to extract and summarize key statistics: the total number of words, the frequency of each word, and the top N most common words. **Requirements**: - Define a function `analyze_text_file(file_path: str, top_n: int) -> dict` that: - Takes a file path (string) and an integer `top_n` representing the number of top common words to return. - Returns a dictionary with three keys: - `\\"total_words\\"` (int): the total number of words in the file. - `\\"word_frequency\\"` (dict): a dictionary where keys are words and values are their frequencies. - `\\"top_common_words\\"` (list of tuples): a list of tuples containing the top N most common words and their frequencies, sorted in descending order of frequency. - Handle file reading errors gracefully. - Ignore case and punctuation when calculating word frequencies. **Function Signature**: ```python def analyze_text_file(file_path: str, top_n: int) -> dict: pass ``` **Constraints**: - The file at `file_path` exists and is accessible. - The value of `top_n` is a positive integer less than or equal to the number of unique words in the file. **Examples**: 1. Given a file with the following content: ``` Hello world! Hello again, world. ``` `analyze_text_file(\\"path/to/file.txt\\", 2)` might return: ```python { \\"total_words\\": 4, \\"word_frequency\\": { \\"hello\\": 2, \\"world\\": 2, \\"again\\": 1, }, \\"top_common_words\\": [ (\\"hello\\", 2), (\\"world\\", 2), ] } ``` 2. If the file does not exist or cannot be read: - Should return: ```python { \\"total_words\\": 0, \\"word_frequency\\": {}, \\"top_common_words\\": [], \\"error\\": \\"File not found or cannot be read.\\" } ```","solution":"import re from collections import Counter def analyze_text_file(file_path: str, top_n: int) -> dict: try: with open(file_path, \'r\', encoding=\'utf-8\') as file: text = file.read().lower() # Remove punctuation and split into words words = re.findall(r\'bw+b\', text) total_words = len(words) word_frequency = Counter(words) top_common_words = word_frequency.most_common(top_n) return { \\"total_words\\": total_words, \\"word_frequency\\": dict(word_frequency), \\"top_common_words\\": top_common_words } except FileNotFoundError: return { \\"total_words\\": 0, \\"word_frequency\\": {}, \\"top_common_words\\": [], \\"error\\": \\"File not found or cannot be read.\\" }"},{"question":"# Coding Challenge: Frequency of the Most Frequent Element Given an array of integers `nums` and an integer `k`, you need to determine the frequency of the most frequent element in the array after performing at most `k` operations. In each operation, you can increment or decrement any element of the array by 1. **Objective**: Implement a function that returns the maximum frequency of the most frequent element you can achieve by performing at most `k` operations. # Task **Method Signature**: ```python def max_frequency(nums: list[int], k: int) -> int: pass ``` **Inputs**: 1. `nums (list[int])`: An array of integers. 2. `k (int)`: An integer representing the maximum number of operations you can perform. **Outputs**: - **Returns**: An integer representing the maximum frequency of the most frequent element after performing at most `k` operations. **Constraints**: - The length of `nums` will be between `1` and `10^5`. - The values in `nums` will be between `1` and `10^5`. - `k` is a non-negative integer. # Example Example 1 ```python nums = [1, 2, 4] k = 5 # After 5 operations: [4, 4, 4] # Maximum frequency: 3 ``` **Output**: `3` Example 2 ```python nums = [1, 4, 8, 13] k = 5 # After 5 operations: [1, 4, 8, 8] or [1, 4, 4, 13] or ... # Maximum frequency: 2 ``` **Output**: `2` # Implementation Requirements - Optimize for time complexity, given the constraints. - Use efficient data structures and algorithms to process the array and `k` operations. # Hints - Consider using a sliding window technique to keep track of the number of increments needed. - Utilize sorting for easier calculation of operations needed for each element in a window.","solution":"def max_frequency(nums: list[int], k: int) -> int: nums.sort() left = 0 max_freq = 0 curr_ops = 0 for right in range(len(nums)): curr_ops += (nums[right] - nums[right - 1]) * (right - left) while curr_ops > k: curr_ops -= nums[right] - nums[left] left += 1 max_freq = max(max_freq, right - left + 1) return max_freq"},{"question":"# Number Sequence Finder **Objective**: Write a function to identify the first n terms of a number sequence where each term is the sum of the previous h terms or the first h positive integers if there are not enough preceding terms. **Task**: 1. Define a function `number_sequence(n: int, h: int) -> List[int]` that generates the first `n` terms. 2. The sequence starts with the first `h` positive integers. 3. Each subsequent term is the sum of the previous `h` terms. ```python def number_sequence(n: int, h: int) -> List[int]: Generate the first n terms of a number sequence where each term is the sum of the previous h terms. Parameters: n: Number of terms to generate. h: Number of preceding terms to sum for each new term. Returns: A list containing the first n terms of the sequence. # Code implementation here pass if __name__ == \\"__main__\\": n = int(input(\\"Enter the number of terms: \\")) h = int(input(\\"Enter the span of preceding terms to sum: \\")) sequence = number_sequence(n, h) print(f\\"The first {n} terms of the sequence are: {sequence}\\") ``` **Constraints**: - `1 <= n <= 100` - `1 <= h <= 10` **Expected Input/Output**: - **Input**: Two integers `n` and `h`. - **Output**: A list containing the first `n` terms of the sequence. **Examples**: 1. Input: `n = 10`, `h = 3` - [Output]: `[1, 2, 3, 6, 11, 20, 37, 68, 125, 230]` 2. Input: `n = 5`, `h = 2` - [Output]: `[1, 2, 3, 5, 8]` **Performance Requirements**: - The solution should efficiently handle the sequence generation up to the maximum constraints without errors. **Explanation**: - The sequence is based on simple addition. - Edge cases include small values of `n` and `h`. This question tests the candidate\'s ability to implement algorithms, understand sequence generation, and manage constraints effectively.","solution":"from typing import List def number_sequence(n: int, h: int) -> List[int]: Generate the first n terms of a number sequence where each term is the sum of the previous h terms. Parameters: n: Number of terms to generate. h: Number of preceding terms to sum for each new term. Returns: A list containing the first n terms of the sequence. if n <= 0: return [] # Start with the first h positive integers sequence = list(range(1, h + 1)) # If n <= h, return the first n terms directly if n <= h: return sequence[:n] # Generate the sequence up to n terms while len(sequence) < n: next_term = sum(sequence[-h:]) # Sum the last h terms sequence.append(next_term) return sequence"},{"question":"# Question: Image Rotation Algorithm Enhancement **Context**: You are developing an image processing module that requires efficient rotation of images. The existing implementation uses a simple matrix rotation algorithm which is straightforward but can be optimized for large images. Your task is to optimize the image rotation algorithm by using Python\'s NumPy library for better performance and efficiency. **Task**: Write a Python function `rotate_image` that rotates a given 2D image (matrix) by 90 degrees clockwise. Use NumPy to handle the matrix operations efficiently. # Input: * A 2D list of integers `image` representing the grayscale values (0-255) of the pixels in the image. # Output: * A 2D list of integers representing the rotated image. # Constraints: * The dimensions of the input list will be between 1x1 and 1000x1000, inclusive. * Input values will be within the range [0, 255]. # Expected Performance: * The solution should efficiently handle the rotation operation, leveraging NumPy\'s advanced array manipulation capabilities. # Example: ```python image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(image) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Additional Requirements: * Include detailed comments explaining the steps of your implementation. * Handle edge cases, such as empty matrices and matrices with different dimensions. * Ensure the function maintains clarity and efficiency, avoiding unnecessary computations.","solution":"import numpy as np def rotate_image(image): Rotates a given 2D image (matrix) by 90 degrees clockwise using NumPy. Parameters: image (list of list of int): 2D list representing the grayscale values of the image. Returns: list of list of int: 2D list representing the rotated image. if not image: return [] np_image = np.array(image) rotated_image = np.rot90(np_image, k=-1) return rotated_image.tolist()"},{"question":"# Coding Assessment Question **Scenario**: As a data analyst, you often work with time series data. Your current task involves analyzing weather data and calculating certain metrics for different time periods. You are given data in the form of JSON objects, each representing daily weather information. Your task is to process this data, extract specific metrics, and organize the results by month. **Objective**: Write a function `analyze_weather_data` that: 1. Parses the provided JSON weather data. 2. Computes the average temperature for each month. 3. Finds the day with the highest and lowest temperature for each month. 4. Stores the results in a nested dictionary for easy access and report generation. **Function Signature**: ```python def analyze_weather_data(weather_data: str) -> dict[str, dict[str, dict[str, str]]]: Analyzes weather data and computes monthly metrics. Args: - weather_data (str): A JSON string representing daily weather data. Returns: - dict[str, dict[str, dict[str, str]]]: A nested dictionary where the outer keys are month names, the inner keys are \\"average_temperature\\", \\"highest_temperature_day\\", and \\"lowest_temperature_day\\", and the values are the corresponding metric values. ``` **Constraints**: - **Input**: - `weather_data`: A JSON string representing a list of dictionaries, where each dictionary contains: - `date` (string, format \\"YYYY-MM-DD\\"): The date of the weather data. - `temperature` (float): The temperature reading on that date. - **Output**: - A nested dictionary where outer keys are month names (e.g., \\"January\\", \\"February\\"), and inner keys are: - `\\"average_temperature\\"`: The average temperature for the month. - `\\"highest_temperature_day\\"`: The day with the highest temperature in the format \\"YYYY-MM-DD\\". - `\\"lowest_temperature_day\\"`: The day with the lowest temperature in the format \\"YYYY-MM-DD\\". **Example**: ```python weather_data = \'\'\' [ {\\"date\\": \\"2023-01-01\\", \\"temperature\\": 20.5}, {\\"date\\": \\"2023-01-02\\", \\"temperature\\": 19.0}, {\\"date\\": \\"2023-02-01\\", \\"temperature\\": 15.5}, {\\"date\\": \\"2023-02-02\\", \\"temperature\\": 17.0}, {\\"date\\": \\"2023-01-15\\", \\"temperature\\": 22.0} ] \'\'\' result = analyze_weather_data(weather_data) Expected Output (example): { \\"January\\": { \\"average_temperature\\": 20.5, \\"highest_temperature_day\\": \\"2023-01-15\\", \\"lowest_temperature_day\\": \\"2023-01-02\\" }, \\"February\\": { \\"average_temperature\\": 16.25, \\"highest_temperature_day\\": \\"2023-02-02\\", \\"lowest_temperature_day\\": \\"2023-02-01\\" } } ``` **Guidelines for Implementation**: 1. **JSON Parsing**: Use a library such as `json` to parse the input string. 2. **Date Handling**: Utilize datetime libraries to manage and manipulate dates (e.g., grouping by month). 3. **Metric Calculation**: Implement efficient algorithms to compute average, highest, and lowest temperatures. 4. **Edge Cases**: Handle cases like missing data for certain months or having only one data point for a month. ---","solution":"import json from collections import defaultdict from datetime import datetime from statistics import mean def analyze_weather_data(weather_data: str) -> dict: data = json.loads(weather_data) # Dict to store results month_data = defaultdict(list) # Process each entry for entry in data: date = datetime.strptime(entry[\'date\'], \\"%Y-%m-%d\\") temperature = entry[\'temperature\'] month = date.strftime(\\"%B\\") # append temperature and date together month_data[month].append((temperature, entry[\'date\'])) process_result = {} for month, temps in month_data.items(): temperatures = [temp for temp, _ in temps] dates = [date for _, date in temps] average_temperature = mean(temperatures) highest_temperature, highest_temperature_day = max(temps) lowest_temperature, lowest_temperature_day = min(temps) process_result[month] = { \\"average_temperature\\": round(average_temperature, 2), \\"highest_temperature_day\\": highest_temperature_day, \\"lowest_temperature_day\\": lowest_temperature_day } return process_result"},{"question":"# Context You are developing a feature for a social networking app that suggests mutual friends for users. The goal is to write a function that finds the common friends between two users based on the friend lists provided. # Problem Statement Implement a function `find_mutual_friends(user1_friends: list[str], user2_friends: list[str]) -> list[str]` that takes in two lists of friends for two users and returns a list of mutual friends. # Input - `user1_friends`: A list of strings representing the friends of user1. - `user2_friends`: A list of strings representing the friends of user2. # Output - A list of strings representing the mutual friends of user1 and user2. The list should be sorted in ascending order. # Constraints 1. A friend can be represented only once in each list. 2. Each friend is represented by a unique non-empty string. 3. The maximum length of each friend\'s name is 20 characters. 4. The maximum number of friends in each list is 10^5. # Examples ```python >>> find_mutual_friends([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"Bob\\", \\"David\\", \\"Charlie\\"]) [\\"Bob\\", \\"Charlie\\"] >>> find_mutual_friends([\\"Alice\\", \\"Bob\\"], [\\"David\\", \\"Charlie\\"]) [] >>> find_mutual_friends([\\"Emma\\", \\"Olivia\\"], [\\"Olivia\\", \\"Emma\\"]) [\\"Emma\\", \\"Olivia\\"] >>> find_mutual_friends([], [\\"Anna\\", \\"Elsa\\"]) [] ``` # Notes - For `user1_friends = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]` and `user2_friends = [\\"Bob\\", \\"David\\", \\"Charlie\\"]`, the mutual friends are `[\\"Bob\\", \\"Charlie\\"]` because they appear in both lists. - For `user1_friends = [\\"Alice\\", \\"Bob\\"]` and `user2_friends = [\\"David\\", \\"Charlie\\"]`, there are no mutual friends, so the result is an empty list. - Ensure your implementation is efficient, with a time complexity roughly proportional to the combined size of the two input lists.","solution":"def find_mutual_friends(user1_friends, user2_friends): Returns a sorted list of mutual friends of user1 and user2. Parameters: user1_friends (list): List of friends for user1. user2_friends (list): List of friends for user2. Returns: list: Sorted list of mutual friends. # Convert lists to sets to find intersection mutual_friends = set(user1_friends).intersection(set(user2_friends)) # Convert the set to a sorted list and return return sorted(mutual_friends)"},{"question":"# Question: Circular Buffer Implementation You have been tasked with implementing a circular buffer class, `CircularBuffer`, in Python. A circular buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. Your implementation should support the following operations: 1. **Appending Elements**: Implement a method `append(self, element: Any) -> None` that appends an element to the buffer. If the buffer is full, the oldest element is overwritten. 2. **Removing Elements**: Implement a method `remove(self) -> Any` that removes and returns the oldest element from the buffer. If the buffer is empty, raise an IndexError. 3. **Buffer Capacity**: Implement a method `capacity(self) -> int` that returns the current capacity of the buffer. 4. **Buffer Size**: Implement a method `size(self) -> int` that returns the number of elements currently in the buffer. 5. **Checking if the Buffer is Empty**: Implement a method `is_empty(self) -> bool` that returns True if the buffer is empty, and False otherwise. 6. **Checking if the Buffer is Full**: Implement a method `is_full(self) -> bool` that returns True if the buffer is full, and False otherwise. Input: - The provided `CircularBuffer` class and its instance methods. Output: - For `append()`, return None. - For `remove()`, return the element being removed. - For `capacity()`, return an integer representing the buffer\'s capacity. - For `size()`, return an integer representing the number of elements in the buffer. - For `is_empty()`, return a boolean indicating if the buffer is empty. - For `is_full()`, return a boolean indicating if the buffer is full. Constraints: - The buffer capacity is specified at the time of instantiation and remains constant. - The buffer can hold up to 1000 elements. - Elements in the buffer can be of any type. Example: ```python # Example usage: buffer = CircularBuffer(3) # Append elements buffer.append(1) buffer.append(2) buffer.append(3) print(buffer.is_full()) # Output: True # Append an element to a full buffer (overwrites the oldest element) buffer.append(4) print(buffer.size()) # Output: 3 # Remove elements print(buffer.remove()) # Output: 2 print(buffer.remove()) # Output: 3 # Buffer state after removal print(buffer.is_empty()) # Output: False print(buffer.remove()) # Output: 4 print(buffer.is_empty()) # Output: True # Buffer capacity print(buffer.capacity()) # Output: 3 ``` In this question, you are required to design and implement a circular buffer supporting elements\' insertion, removal, and the ability to track buffer size, capacity, and state.","solution":"class CircularBuffer: def __init__(self, capacity: int): self.capacity_value = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.count = 0 def append(self, element): self.buffer[self.tail] = element if self.is_full(): self.head = (self.head + 1) % self.capacity_value else: self.count += 1 self.tail = (self.tail + 1) % self.capacity_value def remove(self): if self.is_empty(): raise IndexError(\\"remove from empty buffer\\") element = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity_value self.count -= 1 return element def capacity(self): return self.capacity_value def size(self): return self.count def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.capacity_value"},{"question":"# Problem Statement You are tasked with implementing a modified Dijkstra\'s algorithm that can handle graphs with varying edge weights and vertices containing multiple attributes. Your algorithm should allow selecting the shortest path based on a customizable distance function that takes into account these attributes. # Function Signature ```python def custom_dijkstra(graph: Dict[Any, List[Tuple[Any, float]]], start: Any, end: Any, distance_function: Callable[[Tuple[Any, float]], float]) -> List[Any]: Finds the shortest path between start and end vertices in a graph using Dijkstra\'s algorithm with a customizable distance function. :param graph: A dictionary representing the graph where keys are vertices and values are lists of tuples (neighbor, edge weight). :param start: The starting vertex. :param end: The ending vertex. :param distance_function: A callable that takes a tuple (neighbor, edge weight) and returns the distance used for comparison. :return: A list of vertices representing the shortest path from start to end. ``` # Input - `graph`: A dictionary where keys are vertices and values are lists of tuples representing edges (neighbor vertex, edge weight). - `start`: The starting vertex. - `end`: The ending vertex. - `distance_function`: A callable that takes a tuple (neighbor vertex, edge weight) and returns the modified edge weight for distance calculation. # Output - Returns a list of vertices representing the shortest path from `start` to `end`. # Constraints - The graph contains up to 10^4 vertices. - The distance_function is guaranteed to provide a consistent numerical distance for comparison. - The edge weights in the graph are non-negative. # Example ```python from typing import Dict, List, Tuple, Any, Callable def custom_dijkstra(graph: Dict[Any, List[Tuple[Any, float]]], start: Any, end: Any, distance_function: Callable[[Tuple[Any, float]], float]) -> List[Any]: # To be implemented pass # Examples graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } # Standard Dijkstra\'s algorithm (distance function returns the edge weight itself) print(custom_dijkstra(graph, \'A\', \'D\', distance_function=lambda x: x[1])) # Output: [\'A\', \'B\', \'C\', \'D\'] # Custom distance function example: treat all edge weights as double their original values print(custom_dijkstra(graph, \'A\', \'D\', distance_function=lambda x: 2 * x[1])) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` # Implementation Tips - Utilize a priority queue to manage the vertices to be processed next. - Track the shortest known distance to each vertex and update as shorter paths are found. - Use the customizable distance function during the distance comparison to adapt the algorithm to different criteria.","solution":"import heapq from typing import Dict, List, Tuple, Any, Callable def custom_dijkstra(graph: Dict[Any, List[Tuple[Any, float]]], start: Any, end: Any, distance_function: Callable[[Tuple[Any, float]], float]) -> List[Any]: # Priority queue to store (distance, vertex, path) pq = [(0, start, [start])] # Dictionary to store the shortest known distance to each vertex distances = {vertex: float(\'inf\') for vertex in graph} distances[start] = 0 while pq: current_distance, current_vertex, current_path = heapq.heappop(pq) # If we reached the end vertex, return the path if current_vertex == end: return current_path # If the current distance is greater than the recorded shortest distance, skip processing if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = distance_function((neighbor, weight)) new_distance = current_distance + distance # If a shorter path to the neighbor is found, update and push to priority queue if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(pq, (new_distance, neighbor, current_path + [neighbor])) # If end is not reachable, return an empty list return []"},{"question":"# Sort a Nearly Sorted Array Problem Statement You are required to implement an algorithm that sorts a nearly sorted integer array. In a nearly sorted array, each element is at most `k` positions away from its target position in the sorted array. Specifically, you need to output the sorted array. Use a min-heap approach for your solution. Function Signature ```python def sort_nearly_sorted(arr: list[int], k: int) -> list[int]: ``` Input - `arr: list[int]` - a list of integers, where `1 <= len(arr) <= 10^6`. - `k: int` - an integer, where `0 <= k <= len(arr)`. Output - A list of integers representing the sorted array. Example ```plaintext Input: [2, 6, 3, 12, 56, 8], 3 Output: [2, 3, 6, 8, 12, 56] ``` Constraints - The array contains at least one element. - All elements in the array are integers. - Implement an efficient solution with time complexity better than O(n log n). Note 1. Your implementation should use a min-heap to efficiently sort the nearly sorted array. 2. Aim to minimize additional space usage and ensure the solution is scalable for large inputs.","solution":"import heapq def sort_nearly_sorted(arr, k): Sorts a nearly sorted array where each element is at most k positions away from its sorted position. The function uses a min-heap to sort the array. :param arr: List[int] - the nearly sorted array :param k: int - the maximum distance elements are away from their sorted position :return: List[int] - the sorted array n = len(arr) min_heap = [] result = [] # Initialize the min-heap with the first k+1 elements for i in range(min(k+1, n)): heapq.heappush(min_heap, arr[i]) # Process the remaining elements in the array for i in range(k+1, n): result.append(heapq.heappop(min_heap)) heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the min-heap while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"**Text-Based File Parsing for Data Analysis** You are developing a text-processing tool that reads a structured text file and performs various data analysis tasks, such as extracting specific fields, summarizing data, and generating custom outputs. The text files follow a consistent structure but require parsing and processing to extract meaningful information. **Objective:** Complete the missing implementation for parsing the text file, extracting data, and performing analysis tasks as specified. Ensure the tool processes the files end-to-end as required. **Requirements:** 1. **File Reader Function**: - Implement a function to read a structured text file. - Refer to `read_file`. 2. **Data Extraction**: - Implement a function to extract specific fields based on given keys. - Refer to `extract_fields`. 3. **Data Summarization**: - Implement a function to summarize the extracted data, such as calculating averages or counts. - Refer to `summarize_data`. 4. **Custom Output Generation**: - Implement a function that generates custom outputs based on the analysis, such as generating reports or visualizations. - Refer to `generate_output`. **Function Signatures**: ```python def read_file(file_path: str) -> str: # Implement file reading function pass def extract_fields(data: str, keys: list[str]) -> dict[str, list]: # Implement data extraction function pass def summarize_data(extracted_data: dict[str, list], summary_keys: list[str]) -> dict[str, float | int]: # Implement data summarization function pass def generate_output(summary: dict[str, float | int], output_format: str) -> str: # Implement custom output generation function pass ``` **Input and Output**: Input: 1. A path to a structured text file. 2. A list of keys to extract specific fields from the text file. 3. A list of keys to summarize the extracted data. 4. A format specification for the output. Output: 1. A string representing the custom output generated from the data analysis. **Constraints**: - The structured text file will follow a predefined format. - Keys for extraction and summarization will be valid and present in the file. - Output formats can include \'json\', \'csv\', or \'plaintext\'. **Example**: ```python file_path = \\"data.txt\\" keys_to_extract = [\\"name\\", \\"age\\", \\"score\\"] summary_keys = [\\"age\\", \\"score\\"] output_format = \\"json\\" result = text_file_parser(file_path, keys_to_extract, summary_keys, output_format) ``` Output: ```json { \\"average_age\\": 28.5, \\"total_score\\": 235 } ```","solution":"import json import csv from typing import List, Dict, Union def read_file(file_path: str) -> str: Reads the content of the given file and returns it as a string. with open(file_path, \'r\') as file: data = file.read() return data def extract_fields(data: str, keys: List[str]) -> Dict[str, List]: Extracts specific fields from the data based on the given keys. Returns a dictionary where keys are the field names and values are lists of field values. lines = data.split(\'n\') extracted_data = {key: [] for key in keys} for line in lines: parts = line.split(\',\') entry = {part.split(\':\')[0].strip(): part.split(\':\')[1].strip() for part in parts} for key in keys: if key in entry: extracted_data[key].append(entry[key]) return extracted_data def summarize_data(extracted_data: Dict[str, List], summary_keys: List[str]) -> Dict[str, Union[float, int]]: Summarizes the extracted data for specified summary keys. Returns a dictionary with summaries like averages and totals. summary = {} for key in summary_keys: if extracted_data[key]: numeric_data = list(map(float, extracted_data[key])) summary[f\'average_{key}\'] = sum(numeric_data) / len(numeric_data) summary[f\'total_{key}\'] = sum(numeric_data) return summary def generate_output(summary: Dict[str, Union[float, int]], output_format: str) -> str: Generates a custom output based on the summary data and output format. Supported formats: \'json\', \'csv\', \'plaintext\' if output_format == \'json\': return json.dumps(summary, indent=4) elif output_format == \'csv\': output = \\"key,valuen\\" output += \\"n\\".join([f\\"{key},{value}\\" for key, value in summary.items()]) return output elif output_format == \'plaintext\': return \\"n\\".join([f\\"{key}: {value}\\" for key, value in summary.items()]) else: raise ValueError(\\"Unsupported output format\\") def text_file_parser(file_path: str, keys_to_extract: List[str], summary_keys: List[str], output_format: str) -> str: End-to-end function to read file, extract fields, summarize data and generate custom output. data = read_file(file_path) extracted_data = extract_fields(data, keys_to_extract) summary = summarize_data(extracted_data, summary_keys) return generate_output(summary, output_format)"},{"question":"# Context In a reference management system, users often need to format citations according to different academic styles. Citations typically include the author\'s last name, the publication year, and the title of the work. You are tasked with automating this process by implementing a function that formats citations based on specified rules. # Task Write a Python function that formats a list of citations according to the APA style guidelines. Each citation is represented by a dictionary containing the author\'s last name, publication year, and title of the work. The APA style guidelines specify that each citation should appear as follows: ``` Author\'s Last Name, First Initial. (Year). Title of the work. ``` For simplicity, assume all first names are represented by a single initial followed by a dot. Also, titles should be capitalized appropriately. # Function Signature ```python def format_citations(citations: list[dict[str, str]]) -> list[str]: pass ``` # Input - `citations` (list of dict): List of dictionaries where each dictionary represents a citation with the following keys: - `\\"last_name\\"` (str): The last name of the author. - `\\"initial\\"` (str): The first initial of the author\'s first name. - `\\"year\\"` (str): The publication year. - `\\"title\\"` (str): The title of the work. # Output A list of formatted strings, where each string represents a formatted citation according to APA style. # Constraints - There will be at least 1 and at most 1000 citations. - All strings will be non-empty and contain no leading or trailing whitespace. # Example ```python citations = [ {\\"last_name\\": \\"Smith\\", \\"initial\\": \\"J\\", \\"year\\": \\"2020\\", \\"title\\": \\"Understanding AI\\"}, {\\"last_name\\": \\"Doe\\", \\"initial\\": \\"A\\", \\"year\\": \\"2019\\", \\"title\\": \\"Machine Learning Basics\\"} ] expected_output = [ \\"Smith, J. (2020). Understanding AI.\\", \\"Doe, A. (2019). Machine Learning Basics.\\" ] assert format_citations(citations) == expected_output ```","solution":"def format_citations(citations): Formats a list of citations according to the APA style guidelines. formatted_citations = [] for citation in citations: formatted_citation = f\\"{citation[\'last_name\']}, {citation[\'initial\']}. ({citation[\'year\']}). {citation[\'title\']}.\\" formatted_citations.append(formatted_citation) return formatted_citations"},{"question":"# Problem Statement **Efficient Fibonacci Calculator** You are working for a company that deals with large datasets and complex calculations. They need an efficient solution to compute Fibonacci numbers as part of their financial models. Your task is to write a Python function that calculates the Nth Fibonacci number using an efficient algorithm. The Fibonacci sequence is defined as: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ) Write a Python function `fibonacci(n: int) -> int` that returns the Nth Fibonacci number. **Input Format:** - A single integer `n` representing the position in the Fibonacci sequence (must be a non-negative integer). **Output Format:** - Returns the Nth Fibonacci number as an integer. **Constraints:** - The input `n` must be a non-negative integer. - The function should handle incorrect input types by raising a `ValueError` with an appropriate message. **Examples:** ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: n=-1 must be a non-negative integer >>> fibonacci(10.5) Traceback (most recent call last): ... ValueError: n=10.5 must be a non-negative integer >>> fibonacci(\\"ten\\") Traceback (most recent call last): ... ValueError: n=\'ten\' must be a non-negative integer ``` Implement the function using an efficient algorithm such as matrix exponentiation or dynamic programming to handle large values of `n` efficiently.","solution":"def fibonacci(n: int) -> int: Returns the Nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The Nth Fibonacci number. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(f\\"n={n} must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Task In this task, you need to implement the `find_shortest_path` function to determine the shortest path through a directed, weighted graph using Dijkstra\'s algorithm. The function should return the shortest path and the corresponding distance from a given start node to a target node. You will also write a `test_find_shortest_path` function to test the shortest path calculated on different graph inputs. # Requirements: * Implement `find_shortest_path` to: - Use a priority queue to explore nodes with the smallest known distance first. - Keep track of the shortest path to each node using a predecessor map. - Allow early exit once the shortest path to the target node is found. * Implement `test_find_shortest_path` to: - Print the shortest path and the corresponding total distance for various test cases. # Input Format: - `graph`: A dictionary where keys are node identifiers and values are lists of tuples representing the adjacent nodes and their respective edge weights. - `start`: A node identifier representing the starting point in the graph. - `target`: A node identifier representing the endpoint in the graph. # Output Format: - In `find_shortest_path`, return a tuple containing: - A list of nodes representing the shortest path from `start` to `target`. - The total distance of this path. - In `test_find_shortest_path`, print the shortest path and the total distance for each test case. # Constraints: - The graph is directed, meaning edges have a direction. - All edge weights are non-negative. - Ensure to handle cases where no path exists between the start and target nodes. # Example Usage: Given: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' target = \'D\' ``` After running `find_shortest_path` function, the output might be: ```python ([\'A\', \'B\', \'C\', \'D\'], 4) ``` For test cases in `test_find_shortest_path`, the output might include: ```python Shortest path: [\'A\', \'B\', \'C\', \'D\'] Total distance: 4 ``` Implement the functions `find_shortest_path` and `test_find_shortest_path` to verify your solution correctness.","solution":"import heapq def find_shortest_path(graph, start, target): Determines the shortest path through a directed, weighted graph using Dijkstra\'s algorithm. :param graph: A dictionary where keys are node identifiers and values are lists of tuples representing the adjacent nodes and their respective edge weights. :param start: A node identifier representing the starting point in the graph. :param target: A node identifier representing the endpoint in the graph. :return: A tuple containing a list of nodes representing the shortest path from start to target and the total distance of this path. # Priority queue to explore nodes with the smallest known distance first priority_queue = [(0, start, [])] # (current_distance, current_node, path_taken) visited = set() min_dist = {start: 0} while priority_queue: (current_distance, current_node, path) = heapq.heappop(priority_queue) if current_node in visited: continue # Append current node to the path path = path + [current_node] visited.add(current_node) # Early exit if target node is reached if current_node == target: return path, current_distance # Explore neighbors for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if neighbor not in visited and (neighbor not in min_dist or distance < min_dist[neighbor]): min_dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path)) return [], float(\'inf\') # Return empty list and infinite distance if no path found"},{"question":"# Calculate GCD of Two Numbers You are asked to implement a function that calculates the Greatest Common Divisor (GCD) of two positive integers using the Euclidean algorithm. The function must handle edge cases and ensure proper validation of inputs. Function Signature ```python def gcd(a: int, b: int) -> int: Calculate the Greatest Common Divisor of two positive integers using Euclidean algorithm. Parameters: a (int): First positive integer. b (int): Second positive integer. Returns: int: The GCD of the two input integers. Raises: ValueError: If either of the input integers is not a positive integer. ``` Input & Output - **Input**: - Two arguments, `a` and `b`, which are both positive integers. - **Output**: - An integer representing the greatest common divisor of the two provided integers. Constraints - The function should raise a `ValueError` if either of the input integers is not a positive integer. Example Cases ```python assert gcd(48, 18) == 6 assert gcd(56, 98) == 14 assert gcd(101, 103) == 1 assert gcd(12, 15) == 3 try: gcd(-4, 18) except ValueError as e: assert str(e) == \\"Both numbers must be positive integers\\" try: gcd(0, 18) except ValueError as e: assert str(e) == \\"Both numbers must be positive integers\\" try: gcd(\\"a\\", 18) except ValueError as e: assert str(e) == \\"Both numbers must be positive integers\\" ``` Ensure you thoroughly test your implementation with various edge cases and adhere to the error handling requirements specified.","solution":"def gcd(a: int, b: int) -> int: Calculate the Greatest Common Divisor of two positive integers using Euclidean algorithm. Parameters: a (int): First positive integer. b (int): Second positive integer. Returns: int: The GCD of the two input integers. Raises: ValueError: If either of the input integers is not a positive integer. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both numbers must be positive integers\\") if a <= 0 or b <= 0: raise ValueError(\\"Both numbers must be positive integers\\") while b: a, b = b, a % b return a"},{"question":"# Scenario You work as a software engineer for a financial analytics company. Your team is building an application that processes and analyses stock trading data. One of the features of the application is to detect potential arbitrage opportunities based on historical price data. To improve the performance, you need to implement an algorithm that efficiently determines the maximum profit that can be made by buying and selling a stock over a given period. # Task Implement a function `max_profit` that takes a list of integers `prices` representing the price of a given stock on each day. The function should calculate the maximum possible profit if you can only complete one transaction (i.e., buy one day and sell on another day in the future). # Input - A list of integers `prices` where each integer represents the stock price on a given day. # Output - An integer representing the maximum profit obtainable from one buy-sell transaction. If no profit can be made, return 0. # Constraints - The input list\'s length must be between 2 and 10^5. - Each element in `prices` must be between 1 and 10^4. # Performance Requirements - The algorithm should have a time complexity of O(n), where n is the length of the input list. # Example ```python prices = [7, 1, 5, 3, 6, 4] # The optimum transaction would be to buy at 1 and sell at 6, yielding a profit of 5. max_profit(prices) # should return 5 prices = [7, 6, 4, 3, 1] # No profitable transaction can be made, so return 0. max_profit(prices) # should return 0 ``` # Note - A detailed explanation is not required in the function. - Assume that the data provided is always valid and does not need additional validation for format or range beyond specified constraints. ```python def max_profit(prices): Calculates the maximum profit obtainable from one buy-sell transaction. Args: prices (List[int]): List of stock prices on each day. Returns: int: Maximum profit that can be obtained from one transaction. 0 if no profit is possible. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit ```","solution":"def max_profit(prices): Calculates the maximum profit obtainable from one buy-sell transaction. Args: prices (List[int]): List of stock prices on each day. Returns: int: Maximum profit that can be obtained from one transaction. 0 if no profit is possible. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Coding Assessment Question A company is storing employee information in a database using a nested dictionary structure, where each employee has a unique ID, and each employee record may contain details like name, age, and supervisor IDs. Your task is to implement a function to reconstruct the reporting hierarchy tree for a given employee ID. # Function Signature: ```python def construct_hierarchy(employee_id: int, employees: dict) -> dict: Constructs the reporting hierarchy tree for the given employee. :param employee_id: int - ID of the employee whose hierarchy is to be constructed :param employees: dict - a nested dictionary containing employee records, where keys are employee IDs and values are dictionaries with employee details, which may include a key \'supervisor_id\' :return: dict - hierarchy tree of the employee starting from given employee Example: employees = { 1: {\'name\': \'Alice\', \'age\': 30, \'supervisor_id\': None}, 2: {\'name\': \'Bob\', \'age\': 25, \'supervisor_id\': 1}, 3: {\'name\': \'Charlie\', \'age\': 28, \'supervisor_id\': 1}, 4: {\'name\': \'David\', \'age\': 22, \'supervisor_id\': 2} } >>> construct_hierarchy(1, employees) {1: {\'name\': \'Alice\', \'age\': 30, \'supervisor_id\': None, \'subordinates\': { 2: {\'name\': \'Bob\', \'age\': 25, \'supervisor_id\': 1, \'subordinates\': { 4: {\'name\': \'David\', \'age\': 22, \'supervisor_id\': 2, \'subordinates\': {}} }}, 3: {\'name\': \'Charlie\', \'age\': 28, \'supervisor_id\': 1, \'subordinates\': {}} }}} pass ``` # Requirements: 1. Implement `construct_hierarchy` function to construct and return the hierarchical tree of the given employee. 2. Each employee in the hierarchy should have a `subordinates` key, which contains a dictionary of immediate subordinates\' records. 3. The root of the hierarchy should be the given `employee_id`. # Constraints: - Each employee ID in the dictionary is unique. - The `supervisor_id` for the top-most employee is `None`. - The `supervisor_id` key may not be present if the employee doesn\'t have a supervisor. - The hierarchy must reflect the multi-level reporting structure. # Notes: - You can assume all input data is valid and consistent. - The hierarchy tree should be constructed recursively. - Handle all edge cases, including employees without subordinates.","solution":"def construct_hierarchy(employee_id: int, employees: dict) -> dict: Constructs the reporting hierarchy tree for the given employee. def build_hierarchy(eid): employee = employees[eid] subordinates = {sub_id: build_hierarchy(sub_id) for sub_id in employees if employees[sub_id].get(\'supervisor_id\') == eid} employee[\'subordinates\'] = subordinates return employee return {employee_id: build_hierarchy(employee_id)}"},{"question":"# Scenario You are developing a software application to manage a library system. The library contains a collection of books, each with unique ISBN numbers, titles, authors, and publication years. Users of the library can borrow and return books. To ensure availability and manage inventory efficiently, you need to implement functionality for tracking the borrowing and returning of books. # Task Your task is to implement the `Library` class that manages the collection of books and tracks the borrowing status. Specifically, you need to complete the `borrow_book`, `return_book`, and `get_available_books` methods to handle these operations. **Class to Implement**: - `Library` class with the following methods: - `borrow_book(isbn: str, user_id: str) -> bool`: Borrows a book by its ISBN for a specific user. Returns `True` if the book is successfully borrowed, and `False` if the book is already borrowed or not found. - `return_book(isbn: str, user_id: str) -> bool`: Returns a borrowed book by its ISBN for a specific user. Returns `True` if the book is successfully returned, and `False` if the book was not borrowed by the user or not found. - `get_available_books() -> List[Dict[str, Any]]`: Returns a list of dictionaries with details of all available books (i.e., books that are not currently borrowed). **Input and Output Formats**: - `borrow_book` receives the ISBN of the book and the user ID as input and returns a boolean. - `return_book` receives the ISBN of the book and the user ID as input and returns a boolean. - `get_available_books` returns a list of dictionaries. Each dictionary contains details of an available book with keys `\'isbn\'`, `\'title\'`, `\'author\'`, and `\'year\'`. # Example Usage ```python library = Library([ {\'isbn\': \'978-3-16-148410-0\', \'title\': \'Book A\', \'author\': \'Author A\', \'year\': 2000}, {\'isbn\': \'978-1-56619-909-4\', \'title\': \'Book B\', \'author\': \'Author B\', \'year\': 2005}, ]) # Borrow a book library.borrow_book(\'978-3-16-148410-0\', \'user1\') # Returns: True # Try to borrow the same book again library.borrow_book(\'978-3-16-148410-0\', \'user2\') # Returns: False # Return the book library.return_book(\'978-3-16-148410-0\', \'user1\') # Returns: True # Check available books library.get_available_books() # Returns: # [ # {\'isbn\': \'978-3-16-148410-0\', \'title\': \'Book A\', \'author\': \'Author A\', \'year\': 2000}, # {\'isbn\': \'978-1-56619-909-4\', \'title\': \'Book B\', \'author\': \'Author B\', \'year\': 2005}, # ] ``` # Constraints: - Assume ISBNs are unique for each book. - Users are identified uniquely by their user ID. - The method `borrow_book` and `return_book` should handle cases where the book is not found robustly.","solution":"from typing import List, Dict, Any class Library: def __init__(self, books: List[Dict[str, Any]]): self.books = {book[\'isbn\']: book for book in books} self.borrowed_books = {} def borrow_book(self, isbn: str, user_id: str) -> bool: if isbn in self.books and isbn not in self.borrowed_books: self.borrowed_books[isbn] = user_id return True return False def return_book(self, isbn: str, user_id: str) -> bool: if isbn in self.borrowed_books and self.borrowed_books[isbn] == user_id: del self.borrowed_books[isbn] return True return False def get_available_books(self) -> List[Dict[str, Any]]: available_books = [self.books[isbn] for isbn in self.books if isbn not in self.borrowed_books] return available_books"},{"question":"# Subarray Sum Problem You are given an array `arr` of integers and an integer `k`. Write a function `find_subarray_sum` that finds a continuous subarray in `arr` whose sum equals `k`. If such a subarray exists, return the subarray (as a list of integers). If no such subarray exists, return an empty list. Input * `arr`: A list of integers where `1 <= len(arr) <= 10^3` and `-10^3 <= arr[i] <= 10^3` * `k`: An integer where `-10^4 <= k <= 10^4` Output * A list of integers representing the continuous subarray in `arr` whose sum is `k`. * If no such subarray exists, return an empty list. Constraints * You must not use brute force methods such as checking all possible subarrays. * Aim to achieve an efficient time complexity, ideally O(n). Example ```python >>> find_subarray_sum([1, 2, 3, 4, 5], 9) [2, 3, 4] >>> find_subarray_sum([10, -1, 2, 3, 1, 5], 6) [2, 3, 1] >>> find_subarray_sum([5, -1, 10, -2, 3], 11) [10, -2, 3] >>> find_subarray_sum([3, 4, 7], 1) [] ``` Implementation Note Ensure that your solution handles edge cases appropriately, such as arrays with a single element or no valid subarray found. Consider the possibility of negative numbers in the input array and their effect on the sum calculation.","solution":"def find_subarray_sum(arr, k): Finds a continuous subarray in `arr` whose sum equals `k`. Returns the subarray as a list of integers. current_sum = 0 sum_indices = {0: -1} for i, num in enumerate(arr): current_sum += num if current_sum - k in sum_indices: start_index = sum_indices[current_sum - k] + 1 return arr[start_index:i + 1] sum_indices[current_sum] = i return []"},{"question":"# Problem Statement: A company records the daily temperature readings of a particular city and wants to identify significant temperature patterns. Specifically, they need to find all consecutive days where the temperature was consistently increasing. # Function Signature: ```python def find_increasing_streaks(temperatures: List[int]) -> List[List[int]] ``` # Input: - `temperatures` (List[int]): A list of integers representing daily temperature readings. (1 ≤ len(temperatures) ≤ 1,000; -100 ≤ temperatures[i] ≤ 100) # Output: - List[List[int]]: A list of lists, with each list containing the temperatures of one streak of consecutive days where the temperature was consistently increasing. The lists must be ordered by their starting day in the input list. # Constraints: - The function should efficiently handle the input size within the given constraints. - Consider edge cases such as all temperatures being the same, or only one day of temperature data. # Example: ```python # Example 1: find_increasing_streaks([30, 31, 32, 28, 29, 30, 35]) # Returns: [[30, 31, 32], [28, 29, 30, 35]] # Example 2: find_increasing_streaks([35, 34, 33, 32, 31]) # Returns: [] # Example 3: find_increasing_streaks([10, 15, 20, 25, 20, 25, 30]) # Returns: [[10, 15, 20, 25], [20, 25, 30]] ``` # Hints: - Iterate through the temperature list once to find all streaks of increasing days. - Use a sliding window approach to capture the start and end of each streak efficiently. - Remember to handle the end of the list gracefully, ensuring no out-of-bounds errors occur. # Additional Context: The company plans to use these streaks to identify potential trends and patterns in their data, aiding in future weather predictions and planning. It is important that the solution be as precise and informative as possible, capturing all possible increasing streaks without omissions.","solution":"from typing import List def find_increasing_streaks(temperatures: List[int]) -> List[List[int]]: result = [] n = len(temperatures) if n < 2: return result i = 0 while i < n - 1: if temperatures[i] < temperatures[i + 1]: start = i while i < n - 1 and temperatures[i] < temperatures[i + 1]: i += 1 result.append(temperatures[start:i + 1]) i += 1 return result"},{"question":"# Island Perimeters You are given a 2D grid map of a field where `1` represents land and `0` represents water. Each cell is a square with equal sides, and the grid is completely surrounded by water. The field does not have any lakes; every area of water is connected entirely. Write an algorithm to calculate the total perimeter of all the islands (land patches) in the grid. Requirements 1. Implement `def island_perimeters(grid: List[List[int]]) -> int`, which returns the total perimeter of all islands in the input grid. 2. Consider both isolated islands and interconnected land patches. # Input - A list of lists of integers `grid` representing the field layout (1 ≤ len(grid), len(grid[0]) ≤ 100). # Output - An integer representing the total perimeter of all islands. # Constraints - Each cell is either land (`1`) or water (`0`). - Individual land cells connected orthogonally (up, down, left, right) form a contiguous land mass (island). - Make sure to account for shared borders between land cells to avoid over-counting the perimeter. Example ```python grid1 = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] assert island_perimeters(grid1) == 16 grid2 = [ [1, 0], [0, 1] ] assert island_perimeters(grid2) == 4 ``` Write code to: - Traverse the grid and calculate the total perimeter by examining each land cell and its neighbors. - Efficiently handle the grid size up to the specified limits without excessive time complexity.","solution":"from typing import List def island_perimeters(grid: List[List[int]]) -> int: Calculates the total perimeter of all islands (land patches) in the input grid. Parameters: grid (List[List[int]]): 2D grid representation of the field. Returns: int: Total perimeter of all islands. def is_water_or_boundary(x, y): return x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0 total_perimeter = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: perimeter = 0 # Check all four sides (up, down, left, right) if is_water_or_boundary(i - 1, j): perimeter += 1 if is_water_or_boundary(i + 1, j): perimeter += 1 if is_water_or_boundary(i, j - 1): perimeter += 1 if is_water_or_boundary(i, j + 1): perimeter += 1 total_perimeter += perimeter return total_perimeter"},{"question":"# Scenario You are designing a logistics system to manage and analyze the stock levels of various products in a warehouse. One of the critical tasks is to determine trends in product inventory using a sliding window to find the maximum stock level within subarrays of a given size. # Task You need to write a function `max_in_sliding_window(window_size: int, stock_levels: List[int]) -> List[int]` that identifies the maximum stock levels in each sliding window of the given size. # Details 1. **max_in_sliding_window(window_size: int, stock_levels: List[int]) -> List[int**: * Takes the size of the sliding window and a list of stock levels, slides the window across the list to find the maximum stock level within each window, and returns a list of the maximum values for each window. # Input and Output * **Input Format**: * The input consists of an integer `window_size` and a list `stock_levels`. * `window_size` is an integer between 1 and the length of `stock_levels`. * `stock_levels` is a list of integers representing the stock levels of the products. * **Output Format**: * The function should return a list of integers representing the maximum stock level in each sliding window. # Constraints * `1 <= window_size <= len(stock_levels)` * `1 <= len(stock_levels) <= 10^5` * `-10^4 <= stock_levels[i] <= 10^4` # Examples * Example 1: ```python max_in_sliding_window(3, [5, 3, 8, 9, 7, 10, 2]) # [8, 9, 9, 10, 10] ``` * Example 2: ```python max_in_sliding_window(2, [4, 2, 12, 3, 8, 6]) # [4, 12, 12, 8, 8] ``` # Additional Considerations 1. Optimize your solution to handle large input sizes efficiently, as a naïve solution with a complexity of O(n * window_size) may not be performant enough. 2. Ensure your solution correctly handles the edge cases, such as when the number of stock levels is equal to the window size, or all stock levels are the same.","solution":"from collections import deque from typing import List def max_in_sliding_window(window_size: int, stock_levels: List[int]) -> List[int]: Returns the maximum stock levels in each sliding window of the given size. if not stock_levels or window_size < 1: return [] result = [] deque_idx = deque() for i in range(len(stock_levels)): # Remove elements that are out of current window while deque_idx and deque_idx[0] <= i - window_size: deque_idx.popleft() # Remove elements that are less than the currently being added element while deque_idx and stock_levels[deque_idx[-1]] < stock_levels[i]: deque_idx.pop() deque_idx.append(i) # If we\'ve processed at least window_size elements if i >= window_size - 1: result.append(stock_levels[deque_idx[0]]) return result"},{"question":"# Task Implement a function `min_jumps_to_reach_end(arr: List[int]) -> int` that determines the minimum number of jumps needed to reach the end of an array. Each element in the array represents the maximum jump length at that position. # Function Signature ```python def min_jumps_to_reach_end(arr: List[int]) -> int: pass ``` # Input - A list of integers `arr` where each `arr[i]` (1 ≤ arr[i] ≤ 100) represents the maximum length of the jump from that position. # Output - An integer representing the minimum number of jumps needed to reach the end of the array. If the end is not reachable, return -1. # Example ```python assert min_jumps_to_reach_end([2, 3, 1, 1, 2, 4, 2, 0, 1, 1]) == 4 assert min_jumps_to_reach_end([1, 1, 1, 1]) == 3 assert min_jumps_to_reach_end([1, 2, 3, 4, 5]) == 3 assert min_jumps_to_reach_end([2, 3, 0, 1]) == 2 assert min_jumps_to_reach_end([0, 1, 2, 3]) == -1 ``` # Constraints - The list `arr` will contain at least one element and at most 10000 elements. - Each element in `arr` is a positive integer. # Performance Requirements - The function should run efficiently to handle large lists up to the maximum constraint of 10,000 elements.","solution":"from typing import List def min_jumps_to_reach_end(arr: List[int]) -> int: Determines the minimum number of jumps needed to reach the end of an array, where each element in the array represents the maximum jump length at that position. :param arr: List of integers representing maximum jump lengths. :return: Minimum number of jumps to reach the end of the array, or -1 if it\'s not possible. if not arr or len(arr) == 1: return 0 n = len(arr) jumps = 0 current_end = 0 farthest = 0 for i in range(n): # If the current index is out of reach and it\'s not the starting point if i > farthest: return -1 # Update the farthest we can reach farthest = max(farthest, i + arr[i]) if i == current_end: # We need to make a jump to continue jumps += 1 current_end = farthest # If we have reached or exceeded the end, break if current_end >= n - 1: break return jumps if current_end >= n - 1 else -1"},{"question":"# Coding Challenge: Find the Digit Sum Palindrome Problem Statement You are tasked with finding the smallest positive integer ( N ) such that the sum of the digits of ( N ) is a palindrome and ( N ) itself is also a palindrome. Functional Requirements: Write a function `find_digit_sum_palindrome()` that: - Returns the smallest integer ( N ) such that both ( N ) and the sum of its digits are palindromic numbers. # Input: - No input is required as this is a self-contained problem. # Output: - Returns an integer ( N ). # Constraints: - You must ensure that both ( N ) and the sum of its digits are palindromes. - Your algorithm should efficiently find the smallest ( N ) fulfilling the given criteria. # Performance: - Optimize to minimize the potential range of numbers to check. - Use properties and characteristics of palindromic numbers to reduce computational overhead. Example: ```python assert find_digit_sum_palindrome() == 121 ``` In this example, the resulting ( N ) value of 121 is a palindrome, and the sum of its digits (1 + 2 + 1) equals 4, which is also a palindrome. Guidelines: - Start by defining a helper function `is_palindrome(num: int) -> bool` that checks if a supplied number is a palindrome. - Use an iterative approach to find the smallest palindromic number ( N ) whose digit sum is also a palindrome. - Take care to ensure the efficiency of the search, possibly leveraging known properties of palindromic numbers to limit the search space. # Solution Implementation Example: ```python def is_palindrome(num: int) -> bool: return str(num) == str(num)[::-1] def find_digit_sum_palindrome() -> int: num = 1 while True: if is_palindrome(num) and is_palindrome(sum(int(digit) for digit in str(num))): return num num += 1 # Test the function print(find_digit_sum_palindrome()) # Example usage ```","solution":"def is_palindrome(num: int) -> bool: return str(num) == str(num)[::-1] def digit_sum(num: int) -> int: return sum(int(digit) for digit in str(num)) def find_digit_sum_palindrome() -> int: num = 1 while True: if is_palindrome(num) and is_palindrome(digit_sum(num)): return num num += 1 # Example usage print(find_digit_sum_palindrome()) # should print a number like 121 or similar that satisfies the condition"},{"question":"# Question: Minimum Path Sum in a Grid Given a 2D grid of integers where each cell represents the cost to traverse through that cell, write a function to find the minimum cost path from the top-left cell to the bottom-right cell. You can only move either down or right at any point in time. - **Input**: A 2D list of integers representing the grid. - **Output**: Return the minimum cost as an integer. Constraints: * The grid dimensions will be at most 100x100. * Each value in the grid will be an integer between 0 and 100. * Ensure that your solution runs efficiently within the given constraints. # Example ```python def min_path_sum(grid: List[List[int]]) -> int: pass # Example 1: # The function call should return 7 print(min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ])) # Example 2: # The function call should return 12 print(min_path_sum([ [1, 2, 3], [4, 5, 6] ])) ``` # Notes: 1. Consider using dynamic programming approaches to build the solution incrementally. 2. Make sure your code optimizes for both time and space complexity.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Problem Statement You\'re developing a file system management tool aimed at organizing files by their extensions. Your task is to create a class that can categorize files based on their extensions and provide functionalities to add files, retrieve the list of files for a given extension, and get a summary of files for all extensions. # Goal Create a `FileOrganizer` class that can: 1. **Add a File** * Add a file name to the organizer, correctly categorizing it based on its extension. 2. **Retrieve Files by Extension** * Retrieve all files that match a given extension. 3. **Get All Files Summary** * Provide a summary of all files organized by their extensions. # Implementation FileOrganizer Class 1. **Methods** * `add_file(file_name: str)`: Adds a file to the correct extension category. * `get_files(extension: str)`: Returns a list of all files with the specified extension. * `summary()`: Returns a dictionary summarizing all files by their extensions. # Input and Output Format ```python class FileOrganizer: def __init__(self): # Initialization code here def add_file(self, file_name: str): # Adds a file to the correct extension category def get_files(self, extension: str): # Returns a list of files with the specified extension def summary(self): # Returns a dictionary summarizing all files by extension ``` # Example Usage ```python # Create a FileOrganizer instance organizer = FileOrganizer() # Add files organizer.add_file(\\"document.txt\\") organizer.add_file(\\"photo.jpg\\") organizer.add_file(\\"music.mp3\\") organizer.add_file(\\"document.pdf\\") organizer.add_file(\\"photo.png\\") # Retrieve files by extension txt_files = organizer.get_files(\\"txt\\") # Expected Output: [\\"document.txt\\"] # Get a summary of all files summary = organizer.summary() # Expected Output: {\\"txt\\": [\\"document.txt\\"], \\"jpg\\": [\\"photo.jpg\\"], \\"pdf\\": [\\"document.pdf\\"], \\"png\\": [\\"photo.png\\"], \\"mp3\\": [\\"music.mp3\\"]} ``` # Constraints and Performance Requirements 1. The file names added will be valid and contain a single extension. 2. Operations must execute in O(1) average time complexity due to internal dictionary usage for categorizing files. 3. The designed class should handle at least 1,000 different file extensions efficiently. # Example Scenario ```python # Create a FileOrganizer instance organizer = FileOrganizer() # Add files organizer.add_file(\\"notes.txt\\") organizer.add_file(\\"photo.jpg\\") organizer.add_file(\\"song.mp3\\") # Retrieve files by extension print(organizer.get_files(\\"txt\\")) # Expected Output: [\\"notes.txt\\"] print(organizer.get_files(\\"jpg\\")) # Expected Output: [\\"photo.jpg\\"] # Get a summary of all files print(organizer.summary()) # Expected Output: {\\"txt\\": [\\"notes.txt\\"], \\"jpg\\": [\\"photo.jpg\\"], \\"mp3\\": [\\"song.mp3\\"]} ``` # Write your FileOrganizer class below:","solution":"class FileOrganizer: def __init__(self): self.files = {} def add_file(self, file_name: str): extension = file_name.split(\\".\\")[-1] if extension not in self.files: self.files[extension] = [] self.files[extension].append(file_name) def get_files(self, extension: str): return self.files.get(extension, []) def summary(self): return self.files"},{"question":"# Program Description In many scenarios, such as database operations and network communications, you may need to encode data in specific formats. One common encoding format is Base64, which represents binary data in an ASCII string format. Your task is to implement a function that encodes a given string into its Base64 representation. # Function Signature ```python def to_base64(input_str: str) -> str: ``` # Input - **input_str**: A string representing the text data to be encoded. # Output - A string representing the Base64 encoded output of the input string. # Constraints - Do not use any built-in libraries or functions specifically for Base64 encoding. - You may assume the length of the input string does not exceed (10^6). # Exceptions The function should raise a `ValueError` in the following case: - The input string is empty. # Example ```python >>> to_base64(\'hello\') \'aGVsbG8=\' >>> to_base64(\'foo bar\') \'Zm9vIGJhcg==\' >>> to_base64(\'\') Traceback (most recent call last): ... ValueError: Empty string was passed to the function ``` # Implementation Notes - Remember that Base64 encoding encodes every 3 bytes of the input into 4 characters. If the number of bytes in the input is not divisible by 3, padding with `=` is required. - Ensure proper handling for edge cases, including empty string and padding requirements. - Optimize for performance to handle the maximum input size efficiently.","solution":"def to_base64(input_str: str) -> str: if not input_str: raise ValueError(\\"Empty string was passed to the function\\") base64_chars = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\" binary_string = \'\'.join(f\\"{ord(char):08b}\\" for char in input_str) padding_length = (6 - len(binary_string) % 6) % 6 binary_string = binary_string + \'0\' * padding_length base64_string = \'\' for i in range(0, len(binary_string), 6): base64_string += base64_chars[int(binary_string[i:i+6], 2)] while len(base64_string) % 4 != 0: base64_string += \'=\' return base64_string"},{"question":"# Question **Problem Statement**: You are given a string `s` which contains English alphabets and spaces. Your task is to implement a function that removes all the vowels (a, e, i, o, u - both uppercase and lowercase) from the string. Function Signature: ```python def remove_vowels(s: str) -> str: pass ``` Input: - `s`: A string containing English alphabets and spaces. `str`. Output: - Return a new string after removing all the vowels from the input string. Constraints: - The length of `s` does not exceed (10^5). Examples: - `remove_vowels(\\"Hello World\\")` should return `\\"Hll Wrld\\"`. - `remove_vowels(\\"This is a test\\")` should return `\\"Ths s tst\\"`. - `remove_vowels(\\"Programming\\")` should return `\\"Prgrmmng\\"`. - `remove_vowels(\\"AEIOUaeiou\\")` should return `\\"\\"`. Notes: - The function should handle edge cases like an empty string or a string with no vowels. - Consider both time and space efficiency in your implementation. **Hint**: - Using a set to store vowels can help in efficiently checking whether a character is a vowel or not. Good luck!","solution":"def remove_vowels(s: str) -> str: vowels = set(\\"aeiouAEIOU\\") return \'\'.join([char for char in s if char not in vowels])"},{"question":"# Data Transformation and Aggregation Context: You are developing a report generation tool for a sales department. The tool needs to process a list of sales records and produce aggregated results including the total sales amount per product and the total sales amount per salesperson. Problem Statement: Write a function `aggregate_sales_data(sales_records: list) -> tuple` that accepts a list of dictionaries representing individual sales records and returns a tuple of two dictionaries. The first dictionary should have product names as keys and their corresponding total sales amount as values. The second dictionary should have salesperson names as keys and their corresponding total sales amount as values. Function Signature: ```python def aggregate_sales_data(sales_records: list) -> tuple: # Your code here ``` Expected Input and Output: * **Input**: A list of dictionaries. Each dictionary contains the following keys: ``` - \'product\': str, name of the product sold - \'salesperson\': str, name of the salesperson - \'amount\': float, amount of the sale ``` For example: ```python [ {\'product\': \'Laptop\', \'salesperson\': \'Alice\', \'amount\': 1200.00}, {\'product\': \'Laptop\', \'salesperson\': \'Bob\', \'amount\': 1100.00}, {\'product\': \'Keyboard\', \'salesperson\': \'Alice\', \'amount\': 20.00} ] ``` * **Output**: A tuple containing two dictionaries. For example: * `({\'Laptop\': 2300.00, \'Keyboard\': 20.00}, {\'Alice\': 1220.00, \'Bob\': 1100.00})` Constraints: * Each sales record will have the mandatory fields \'product\', \'salesperson\', and \'amount\'. * The \'amount\' field will always be a non-negative float. * The input list may contain duplicate sales records. Example: ```python # Example usage sales_records = [ {\'product\': \'Laptop\', \'salesperson\': \'Alice\', \'amount\': 1200.00}, {\'product\': \'Laptop\', \'salesperson\': \'Bob\', \'amount\': 1100.00}, {\'product\': \'Keyboard\', \'salesperson\': \'Alice\', \'amount\': 20.00} ] print(aggregate_sales_data(sales_records)) # Expected Output ({\'Laptop\': 2300.00, \'Keyboard\': 20.00}, {\'Alice\': 1220.00, \'Bob\': 1100.00}) ``` Performance Requirements: Ensure your function performs efficiently even with a large number of sales records in the input list. Test Cases: Test your code with the following scenarios: * Empty list. * List with a single sales record. * List with multiple sales records, including duplicate entries. * Varying product names and salesperson names.","solution":"def aggregate_sales_data(sales_records): Aggregates sales data by product and by salesperson. Args: sales_records (list): A list of dictionaries containing sales records. Each dictionary has keys: \'product\' (str), \'salesperson\' (str), and \'amount\' (float). Returns: tuple: Two dictionaries. The first dictionary has product names as keys and total sales amount as values. The second dictionary has salesperson names as keys and total sales amount as values. total_sales_by_product = {} total_sales_by_salesperson = {} for record in sales_records: product = record[\'product\'] salesperson = record[\'salesperson\'] amount = record[\'amount\'] if product in total_sales_by_product: total_sales_by_product[product] += amount else: total_sales_by_product[product] = amount if salesperson in total_sales_by_salesperson: total_sales_by_salesperson[salesperson] += amount else: total_sales_by_salesperson[salesperson] = amount return total_sales_by_product, total_sales_by_salesperson"},{"question":"Coding Assessment Question **Title**: Most Frequent Substring in a Large Text **Objective**: Write a function that identifies the most frequent substring of a specified length from a large input string. **Description**: Given a string `text` and an integer `k`, write a function that finds the substring of length `k` that appears most frequently in the string. If multiple substrings have the same maximum frequency, return the lexicographically smallest one. **Function Signature**: ```python def most_frequent_substring(text: str, k: int) -> str: ``` # Parameters: * **text (str)**: A string containing up to 10^5 characters consisting of lower-case English letters. * **k (int)**: An integer specifying the length of substrings to consider. (1 ≤ k ≤ len(text)) # Returns: * **str**: The most frequent substring of length `k`. If multiple substrings have the same frequency, return the smallest one lexicographically. # Constraints: * The function should handle large strings efficiently. * Ensure optimal performance to avoid excessive computation time. # Example: ```python assert most_frequent_substring(\\"aabacbebebe\\", 3) == \\"beb\\" assert most_frequent_substring(\\"ababcabcabcabc\\", 2) == \\"ab\\" assert most_frequent_substring(\\"aaaaa\\", 1) == \\"a\\" ``` # Notes: * You may assume that `text` has at least one valid substring of length `k`. * Consider using efficient data structures such as hashmaps to count substring occurrences. # Scenario: Identifying frequent patterns in large volumes of text data can be beneficial in various applications such as bioinformatics (e.g., DNA sequence analysis), data compression algorithms, and natural language processing tasks. This problem simulates such real-world scenarios by focusing on the development of efficient text analysis techniques.","solution":"def most_frequent_substring(text: str, k: int) -> str: Identifies the most frequent substring of length k from the input text. If multiple substrings have the same maximum frequency, returns the lexicographically smallest one. from collections import defaultdict # Dictionary to store the frequency of each substring substring_counts = defaultdict(int) # Count frequencies of all substrings of length k for i in range(len(text) - k + 1): substring = text[i:i + k] substring_counts[substring] += 1 # Find the substring with the highest frequency max_freq = 0 most_frequent_substr = None for substr, count in substring_counts.items(): if count > max_freq or (count == max_freq and substr < most_frequent_substr): max_freq = count most_frequent_substr = substr return most_frequent_substr"},{"question":"# Minimum Spanning Tree using Kruskal\'s Algorithm Context You have been tasked with finding the minimum spanning tree (MST) of a connected, undirected graph using Kruskal\'s algorithm. The graph consists of vertices and weighted edges, with the goal of minimizing the total weight of the tree that connects all vertices. Requirements Write a class `Graph` with the following methods: 1. **`__init__(self, vertices: int)`**: Initialize your graph, taking the number of vertices as a parameter. This method should properly initialize the internal structure to represent the graph. 2. **`add_edge(self, u: int, v: int, weight: int)`**: Add an edge between vertices `u` and `v` with the given `weight`. 3. **`find_mst(self) -> list`**: Compute and return the list of edges in the MST using Kruskal\'s algorithm. Each edge should be represented as a tuple `(u, v, weight)`. Input and Output * **Input**: * `__init__` method should accept an integer `vertices` representing the number of vertices. * `add_edge` method should accept two integers `u`, `v` and an integer `weight`. * `find_mst` method should return a list of tuples where each tuple contains two integers `u`, `v` and an integer `weight`. * **Output**: * `find_mst` should return the edges of the MST. * **Constraints**: * The number of vertices `n` is such that (1 leq n leq 1000). * The number of edges `m` is such that (0 leq m leq frac{n(n-1)}{2}). * Edge weights are non-negative integers. Example ```python graph = Graph(4) graph.add_edge(0, 1, 10) graph.add_edge(0, 2, 6) graph.add_edge(0, 3, 5) graph.add_edge(1, 3, 15) graph.add_edge(2, 3, 4) mst = graph.find_mst() print(mst) # Output should be: [(2, 3, 4), (0, 3, 5), (0, 1, 10)] ``` Note * The MST is unique if edge weights are distinct. If there are multiple valid MSTs, any one of them can be returned. * The `find_mst` method should use Kruskal\'s algorithm, leveraging a union-find (disjoint-set) data structure to detect and avoid cycles.","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 class Graph: def __init__(self, vertices): self.V = vertices self.edges = [] def add_edge(self, u, v, weight): self.edges.append((u, v, weight)) def find_mst(self): # Sort edges based on their weight self.edges.sort(key=lambda edge: edge[2]) ds = DisjointSet(self.V) mst = [] for edge in self.edges: u, v, weight = edge if ds.find(u) != ds.find(v): mst.append(edge) ds.union(u, v) if len(mst) == self.V - 1: break return mst"},{"question":"# Coding Assessment Question Problem Statement: You are tasked with finding the largest product of adjacent digits in a given series within a length specified. Write a function `largest_adjacent_product(series: str, length: int) -> int` that takes a string `series` representing a sequence of digits and an integer `length` representing the number of adjacent digits, and returns the largest product of adjacent digits in the series within the specified length. Input: * `series` (1 <= len(series) <= 1000): A string comprised only of digits representing the series. * `length` (1 <= length <= len(series)): An integer representing the number of adjacent digits to consider for the product. Output: * An integer representing the largest product of adjacent digits in the specified length. Example: ```python assert largest_adjacent_product(\\"73167176531330624919225119674426574742355349194934\\", 6) == 23520 assert largest_adjacent_product(\\"123456789\\", 2) == 72 assert largest_adjacent_product(\\"102030405060708090\\", 3) == 0 assert largest_adjacent_product(\\"1111111111\\", 5) == 1 ``` Constraints: * Your solution must operate within a reasonable time complexity given the constraints. * Efficiently handle edge cases where the series length is minimal or maximal. * Ensure accurate computation even with large numbers of adjacent digits. Performance: * Aim for an optimal solution that ensures each digit sequence is considered only once per examination pass. * Minimize unnecessary computations and avoid checks when calculations are clear. This new question checks the understanding of string manipulation, sliding window concepts, and efficient computation, aligning well with the complexity and style of the existing question set.","solution":"def largest_adjacent_product(series: str, length: int) -> int: Returns the largest product of adjacent digits in the given series within the specified length. Parameters: series (str): A string comprised only of digits representing the series. length (int): The number of adjacent digits to consider for the product. Returns: int: The largest product of adjacent digits in the specified length. if length == 0 or length > len(series): return 0 max_product = 0 for i in range(len(series) - length + 1): product = 1 for j in range(length): product *= int(series[i + j]) max_product = max(max_product, product) return max_product"},{"question":"# Problem Statement You are required to implement a calendar event management system that allows users to add, remove, update, and retrieve events. The system should support basic operations with an additional functionality of finding events within a specified date range. # Objectives 1. **Class `EventManager`:** - **Methods**: - `add_event(event_id: str, event_name: str, start_date: str, end_date: str) -> str`: - **Input**: - An `event_id`: a unique string identifier for the event. - An `event_name`: a string representing the name of the event. - A `start_date`: a string representing the start date of the event in the format \\"YYYY-MM-DD\\". - An `end_date`: a string representing the end date of the event in the format \\"YYYY-MM-DD\\". - **Output**: Return a string \\"Event added successfully\\" if the event is added without conflicts. - **Requirements**: - Ensure that `start_date` and `end_date` are valid dates. - Ensure that `end_date` is not earlier than `start_date`. - Ensure there are no conflicting events (overlapping dates) with the same `event_id`. - Raise a `ValueError` with an appropriate message if any constraint is violated. - `remove_event(event_id: str) -> str`: - **Input**: An `event_id`: a string identifier for the event to be removed. - **Output**: Return a string \\"Event removed successfully\\" if the event is found and removed. - **Requirements**: - Ensure the event with the given `event_id` exists. - Raise a `ValueError` with the message \\"Event not found\\" if the event does not exist. - `update_event(event_id: str, new_start_date: str, new_end_date: str) -> str`: - **Input**: - An `event_id`: a string identifier for the event to be updated. - A `new_start_date`: a string representing the new start date of the event in the format \\"YYYY-MM-DD\\". - A `new_end_date`: a string representing the new end date of the event in the format \\"YYYY-MM-DD\\". - **Output**: Return a string \\"Event updated successfully\\" if the event dates are updated without conflicts. - **Requirements**: - Ensure the event with the given `event_id` exists. - Ensure `new_start_date` and `new_end_date` are valid dates. - Ensure that `new_end_date` is not earlier than `new_start_date`. - Ensure there are no conflicting events (overlapping dates) with the same `event_id`. - Raise a `ValueError` with an appropriate message if any constraint is violated. - `get_event(event_id: str) -> dict`: - **Input**: An `event_id`: a string identifier for the event to be retrieved. - **Output**: Return a dictionary with the event details (`event_id`, `event_name`, `start_date`, `end_date`). - **Requirements**: - Ensure the event with the given `event_id` exists. - Raise a `ValueError` with the message \\"Event not found\\" if the event does not exist. - `get_events_in_date_range(start_date: str, end_date: str) -> List[dict]`: - **Input**: - A `start_date`: a string representing the start date of the range in the format \\"YYYY-MM-DD\\". - An `end_date`: a string representing the end date of the range in the format \\"YYYY-MM-DD\\". - **Output**: Return a list of dictionaries, each containing the details of the events that fall within the specified date range. - **Requirements**: - Ensure `start_date` and `end_date` are valid dates. - Ensure that `end_date` is not earlier than `start_date`. - Return events that have any overlap with the date range specified (partially or fully within the range). - Raise a `ValueError` with an appropriate message if any constraint is violated. # Examples ```python # EventManager usage example manager = EventManager() # Add events assert manager.add_event(\\"E001\\", \\"Team Meeting\\", \\"2023-05-01\\", \\"2023-05-01\\") == \\"Event added successfully\\" assert manager.add_event(\\"E002\\", \\"Project Deadline\\", \\"2023-05-15\\", \\"2023-05-15\\") == \\"Event added successfully\\" assert manager.add_event(\\"E003\\", \\"Conference\\", \\"2023-06-01\\", \\"2023-06-03\\") == \\"Event added successfully\\" # Get event details assert manager.get_event(\\"E001\\") == {\\"event_id\\": \\"E001\\", \\"event_name\\": \\"Team Meeting\\", \\"start_date\\": \\"2023-05-01\\", \\"end_date\\": \\"2023-05-01\\"} # Update event assert manager.update_event(\\"E002\\", \\"2023-05-20\\", \\"2023-05-20\\") == \\"Event updated successfully\\" # Get events in date range assert manager.get_events_in_date_range(\\"2023-05-01\\", \\"2023-05-31\\") == [ {\\"event_id\\": \\"E001\\", \\"event_name\\": \\"Team Meeting\\", \\"start_date\\": \\"2023-05-01\\", \\"end_date\\": \\"2023-05-01\\"}, {\\"event_id\\": \\"E002\\", \\"event_name\\": \\"Project Deadline\\", \\"start_date\\": \\"2023-05-20\\", \\"end_date\\": \\"2023-05-20\\"} ] # Remove event assert manager.remove_event(\\"E003\\") == \\"Event removed successfully\\" assert manager.get_event(\\"E003\\") == \\"Event not found\\" # Should raise a ValueError: Event not found ``` You are expected to write and test your implementations to ensure all scenarios and edge cases are properly handled.","solution":"from datetime import datetime from typing import List, Dict class EventManager: def __init__(self): self.events = {} def _is_valid_date(self, date_str: str) -> bool: try: datetime.strptime(date_str, \\"%Y-%m-%d\\") return True except ValueError: return False def _validate_dates(self, start_date: str, end_date: str): if not self._is_valid_date(start_date) or not self._is_valid_date(end_date): raise ValueError(\\"Invalid date format.\\") if start_date > end_date: raise ValueError(\\"End date cannot be earlier than start date.\\") def add_event(self, event_id: str, event_name: str, start_date: str, end_date: str) -> str: self._validate_dates(start_date, end_date) if event_id in self.events: raise ValueError(\\"Event ID already exists.\\") self.events[event_id] = { \\"event_id\\": event_id, \\"event_name\\": event_name, \\"start_date\\": start_date, \\"end_date\\": end_date } return \\"Event added successfully\\" def remove_event(self, event_id: str) -> str: if event_id not in self.events: raise ValueError(\\"Event not found\\") del(self.events[event_id]) return \\"Event removed successfully\\" def update_event(self, event_id: str, new_start_date: str, new_end_date: str) -> str: self._validate_dates(new_start_date, new_end_date) if event_id not in self.events: raise ValueError(\\"Event not found\\") self.events[event_id][\\"start_date\\"] = new_start_date self.events[event_id][\\"end_date\\"] = new_end_date return \\"Event updated successfully\\" def get_event(self, event_id: str) -> dict: if event_id not in self.events: raise ValueError(\\"Event not found\\") return self.events[event_id] def get_events_in_date_range(self, start_date: str, end_date: str) -> List[Dict]: self._validate_dates(start_date, end_date) results = [] for event in self.events.values(): if not (event[\\"end_date\\"] < start_date or event[\\"start_date\\"] > end_date): results.append(event) return results"},{"question":"# Question: Implement a Robust Matrix Multiplication with Edge Case Handling You are assigned the task of enhancing a basic matrix multiplication function to handle a variety of edge cases robustly and efficiently. Problem Statement Modify the existing `MatrixMultiply` class to include functionality for handling cases where the input matrices contain zeros, irregular shapes, or large values that could cause overflow. Ensure that matrix operations are performed safely and validate the inputs beforehand. Requirements 1. **Extend MatrixMultiply Class**: - Handle cases where the input matrices contain rows or columns of zeros by skipping unnecessary computations. - Add checks for potential overflow or underflow scenarios particularly when dealing with very large or very small numbers. 2. **Row and Column Validation**: - Modify the class to include a method that validates the dimensions of the input matrices, ensuring they are compatible for multiplication (i.e., number of columns in the first matrix should be equal to the number of rows in the second). Input and Output - The `__matmul__` function in `MatrixMultiply` should check for zero rows and columns, and handle large value operations gracefully. - It should return the resultant matrix from the multiplication, ensuring that all edge cases are correctly managed. Constraints - Both input matrices are assumed to be two-dimensional lists containing integers or floating-point numbers. - Ensure minimal changes to avoid breaking existing functionalities. - Perform the necessary validation so that users are aware when unsafe operations have been attempted. Testing and Performance - Ensure that the extended functionality does not introduce significant performance degradation. - Add test cases to validate the additional safety checks, dimensional validations, and edge cases. Example ```python class MatrixMultiply: def __init__(self, matrix1, matrix2): self.matrix1 = matrix1 self.matrix2 = matrix2 def validate_dimensions(self): if len(self.matrix1[0]) != len(self.matrix2): raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") def safe_multiplication(self, num1, num2): if num1 == 0 or num2 == 0: return 0 result = num1 * num2 if result > 1e308: # assuming floating-point limit return float(\'inf\') if result < -1e308: return float(\'-inf\') return result def __matmul__(self): self.validate_dimensions() result = [[0] * len(self.matrix2[0]) for _ in range(len(self.matrix1))] for i in range(len(self.matrix1)): for j in range(len(self.matrix2[0])): for k in range(len(self.matrix2)): result[i][j] += self.safe_multiplication(self.matrix1[i][k], self.matrix2[k][j]) return result matrix1 = [[1, 2], [3, 4]] matrix2 = [[2, 0], [1, 2]] mm = MatrixMultiply(matrix1, matrix2) result = mm @ () print(result) # Expected output: [[4, 4], [10, 8]] ``` Output: ```plaintext [[4, 4], [10, 8]] ``` Implement the above solution and validate using test cases to handle scenarios for zero rows/columns, potential overflow, and compatibility checks.","solution":"class MatrixMultiply: def __init__(self, matrix1, matrix2): self.matrix1 = matrix1 self.matrix2 = matrix2 def validate_dimensions(self): if not self.matrix1 or not self.matrix2: raise ValueError(\\"One or both matrices are empty\\") if len(self.matrix1[0]) != len(self.matrix2): raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") def safe_multiplication(self, num1, num2): if num1 == 0 or num2 == 0: return 0 result = num1 * num2 # Safe guarding against floating-point overflow and underflow if result > 1e308: return float(\'inf\') if result < -1e308: return float(\'-inf\') return result def __matmul__(self, other): self.validate_dimensions() result = [[0] * len(self.matrix2[0]) for _ in range(len(self.matrix1))] for i in range(len(self.matrix1)): for j in range(len(self.matrix2[0])): for k in range(len(self.matrix2)): result[i][j] += self.safe_multiplication(self.matrix1[i][k], self.matrix2[k][j]) return result # Example Usage: matrix1 = [[1, 2], [3, 4]] matrix2 = [[2, 0], [1, 2]] mm = MatrixMultiply(matrix1, matrix2) result = mm.__matmul__(None) print(result) # Expected output: [[4, 4], [10, 8]]"},{"question":"# Question: Implement a Real-time Temperature Conversion Service with Caching Your task is to implement a simple real-time temperature conversion service in Python that efficiently converts temperatures between Celsius, Fahrenheit, and Kelvin using caching to store previously converted values. Specifically: 1. **Create a `Temperature` class** that can store a temperature in Celsius, Fahrenheit, and Kelvin. 2. **Implement methods to convert temperatures** between these units within this class. 3. **Use a caching mechanism** to store previously computed temperature conversions to avoid redundant computations and improve performance. **Class Definition**: ```python class Temperature: def __init__(self, celsius: float): self.celsius = celsius self.cache = {} def to_fahrenheit(self) -> float: pass def to_kelvin(self) -> float: pass def from_fahrenheit(self, fahrenheit: float) -> float: pass def from_kelvin(self, kelvin: float) -> float: pass def convert_and_cache(self, target_unit: str) -> float: pass ``` **Input**: - `Temperature` class takes an initial temperature in Celsius as input. - Methods to convert temperatures to and from Fahrenheit and Kelvin. - Method `convert_and_cache` to perform the conversion and store the result in a cache for quick lookup. **Output**: - Methods return the converted temperature. - `convert_and_cache` method updates the cache and returns the converted temperature. **Constraints**: - Ensure that the conversions are accurate to at least two decimal places. - Implement a caching mechanism that prevents redundant conversions and manages memory efficiently. - Handle edge cases such as negative temperatures and large temperature values. # Example: ```python def main(): temp = Temperature(25) # 25°C assert temp.to_fahrenheit() == 77.0 # Convert to Fahrenheit assert temp.to_kelvin() == 298.15 # Convert to Kelvin assert temp.from_fahrenheit(77) == 25.0 # Convert from Fahrenheit to Celsius assert temp.from_kelvin(298.15) == 25.0 # Convert from Kelvin to Celsius # Using cache assert temp.convert_and_cache(\'F\') == 77.0 assert temp.convert_and_cache(\'K\') == 298.15 if __name__ == \\"__main__\\": main() ``` Ensure to test your implementation with a variety of temperatures to validate its correctness and performance.","solution":"class Temperature: def __init__(self, celsius: float): self.celsius = celsius self.cache = {\'C\': celsius} def to_fahrenheit(self) -> float: if \'F\' not in self.cache: self.cache[\'F\'] = round((self.celsius * 9/5) + 32, 2) return self.cache[\'F\'] def to_kelvin(self) -> float: if \'K\' not in self.cache: self.cache[\'K\'] = round(self.celsius + 273.15, 2) return self.cache[\'K\'] def from_fahrenheit(self, fahrenheit: float) -> float: celsius = round((fahrenheit - 32) * 5/9, 2) self.cache[\'C\'] = celsius return celsius def from_kelvin(self, kelvin: float) -> float: celsius = round(kelvin - 273.15, 2) self.cache[\'C\'] = celsius return celsius def convert_and_cache(self, target_unit: str) -> float: target_unit = target_unit.upper() if target_unit == \'C\': return self.celsius elif target_unit == \'F\': return self.to_fahrenheit() elif target_unit == \'K\': return self.to_kelvin() else: raise ValueError(\\"Unsupported target unit. Supported units are \'C\', \'F\', and \'K\'.\\")"},{"question":"# Scenario As part of a weather forecasting application, you are tasked with processing temperature data to identify trends and anomalies. You need to write a function that analyzes a sequence of daily temperatures and determines the longest subsequence of days where the temperature continuously rises. # Task Write a function to find the length of the longest contiguous subsequence of increasing temperatures. # Function: `longest_increasing_temperatures` Input - A list of integers `temperatures` where each integer represents the temperature for a day. Output - An integer representing the length of the longest contiguous subsequence of days with increasing temperatures. Example ```python assert longest_increasing_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == 3 # [73, 74, 75] assert longest_increasing_temperatures([30, 40, 50, 60, 50, 60, 70, 80]) == 4 # [50, 60, 70, 80] assert longest_increasing_temperatures([90, 85, 80, 75, 70]) == 1 # No increasing subsequence, return 1 assert longest_increasing_temperatures([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 # Entire list is an increasing subsequence ``` Constraints - The input list can have a length ranging between 1 and 10000. - Each temperature value is an integer between -100 and 100. # Notes - Ensure your solution is efficient and can handle the upper range of input sizes effectively. - Pay attention to edge cases, such as an empty input list or a list with only one temperature value.","solution":"def longest_increasing_temperatures(temperatures): Function to find the length of the longest contiguous subsequence of increasing temperatures. Parameters: temperatures (list of int): List of daily temperatures. Returns: int: Length of the longest contiguous subsequence of increasing temperatures. if len(temperatures) == 0: return 0 # Edge case: no temperatures provided # Initial parameters for tracking the longest increasing sequence max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Roman Numeral Converter Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Each symbol has a value as follows: - I : 1 - V : 5 - X : 10 - L : 50 - C : 100 - D : 500 - M : 1000 There are a few rules on how to write Roman numerals: 1. Roman numerals are usually written from largest to smallest from left to right. 2. There are six instances where a smaller numeral appears before a larger numeral to indicate subtraction: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. Your task is to write a class `RomanNumeralConverter` that implements the following functionalities: 1. **Convert an integer to a Roman numeral.** 2. **Convert a Roman numeral to an integer.** Class Definition: ```python class RomanNumeralConverter: def __init__(self) -> None: Initialize the RomanNumeralConverter with any necessary data. pass def int_to_roman(self, num: int) -> str: Converts an integer to a Roman numeral. :param num: The integer to convert. :return: The Roman numeral representation of the integer. pass def roman_to_int(self, roman: str) -> int: Converts a Roman numeral to an integer. :param roman: The Roman numeral to convert. :return: The integer representation of the Roman numeral. pass ``` Input: - The `int_to_roman` function takes an integer (`num`). - The `roman_to_int` function takes a Roman numeral string (`roman`). Output: - `int_to_roman`: A string representing the Roman numeral. - `roman_to_int`: An integer representing the value of the Roman numeral. Constraints: - The integer `num` is guaranteed to be within the range from 1 to 3999 inclusive. - The Roman numeral will be a valid string representing a number within the same range. Example: ```python # Example sequence of operations: converter = RomanNumeralConverter() assert converter.int_to_roman(3) == \'III\' assert converter.int_to_roman(58) == \'LVIII\' assert converter.int_to_roman(1994) == \'MCMXCIV\' assert converter.roman_to_int(\'III\') == 3 assert converter.roman_to_int(\'LVIII\') == 58 assert converter.roman_to_int(\'MCMXCIV\') == 1994 ```","solution":"class RomanNumeralConverter: def __init__(self) -> None: self.roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } self.int_to_roman_map = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] def int_to_roman(self, num: int) -> str: Converts an integer to a Roman numeral. :param num: The integer to convert. :return: The Roman numeral representation of the integer. roman = \'\' for value, symbol in self.int_to_roman_map: while num >= value: roman += symbol num -= value return roman def roman_to_int(self, roman: str) -> int: Converts a Roman numeral to an integer. :param roman: The Roman numeral to convert. :return: The integer representation of the Roman numeral. total = 0 prev_value = 0 for char in reversed(roman): current_value = self.roman_to_int_map[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"# Question: Advanced Array Rearrangement You are given an array of integers. Your task is to rearrange elements of the array so that all even numbers appear before all odd numbers. The relative order of the even numbers should remain the same as it was in the input array, and the same goes for the odd numbers. Your Task 1. Implement a function `rearrange_array` that takes a list of integers and rearranges it according to the above criteria. 2. Ensure the relative order of the even and odd numbers is preserved in the output. Function Signature ```python def rearrange_array(arr: list[int]) -> list[int]: pass ``` # Parameters * **arr (list[int])**: A list of integers. # Returns * A list of integers where all even numbers precede all odd numbers, with preserved relative order. # Examples ```python rearrange_array([8, 5, 2, 9, 6, 3]) # Expected: [8, 2, 6, 5, 9, 3] rearrange_array([1, 2, 3, 4, 5]) # Expected: [2, 4, 1, 3, 5] rearrange_array([11, 13, 15]) # Expected: [11, 13, 15] ``` # Constraints * The length of the array does not exceed 10^6. * The elements of the array can vary between -10^6 and 10^6. * Implement the function with a time complexity of O(n), where n is the length of the array.","solution":"def rearrange_array(arr): Rearranges the elements of the array so that all even numbers appear before all odd numbers while preserving the relative order of the even and odd numbers. Parameters: arr (list[int]): A list of integers Returns: list[int]: A new list where all even numbers are before all odd numbers with their relative order preserved. even_numbers = [x for x in arr if x % 2 == 0] odd_numbers = [x for x in arr if x % 2 != 0] return even_numbers + odd_numbers"},{"question":"# Coding Assessment Question Context: Binary search is a fundamental searching algorithm that is renowned for its efficiency, especially when dealing with sorted arrays. Mastering the implementation of binary search is crucial for optimizing search operations in various applications. Task: Implement a function `binary_search(arr: list, target: int) -> int` that searches for a target value in a sorted list of integers using the binary search algorithm. The function should return the index of the target if found, and -1 otherwise. Refer to the provided algorithm details for expected behavior and edge case considerations. Function Signature: ```python def binary_search(arr: list, target: int) -> int: pass ``` Input: - `arr` (list): A sorted list of integers. - `target` (int): The integer value to search for in the list. Output: - The function should return the index of the target if found, and -1 otherwise. Constraints: - The list should be sorted in ascending order. - Assume there are no duplicate elements in the list. Examples: ```python >>> arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> target1 = 5 >>> binary_search(arr1, target1) 4 >>> arr2 = [10, 20, 30, 40, 50, 60, 70] >>> target2 = 25 >>> binary_search(arr2, target2) -1 >>> arr3 = [] >>> target3 = 10 >>> binary_search(arr3, target3) -1 ``` Notes: - Implement the algorithm iteratively for simplicity. - The function should handle edge cases such as empty arrays appropriately. Hint: * Binary search works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.","solution":"def binary_search(arr, target): Searches for a target value in a sorted list of integers using the binary search algorithm. Returns the index of the target if found, and -1 otherwise. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Task: Identifying Unique Elements in a List Objective Write a function `find_unique_elements` that returns the unique elements from a given list in the order they first appeared. Scenario You are given a list of integers where some elements may appear multiple times. Your task is to return a new list containing only the unique elements, preserving their original order of first appearance. Function Signature ```python def find_unique_elements(arr: list) -> list: pass ``` Input - `arr` - A list of integers. Output - A list of integers containing only the unique elements found in `arr`, in the order they first appeared. Constraints - 1 <= len(arr) <= 10^5 - -10^9 <= arr[i] <= 10^9 for every element arr[i] Examples ```python assert find_unique_elements([4, 5, 6, 7, 4, 5, 8]) == [4, 5, 6, 7, 8] assert find_unique_elements([1, 2, 2, 3, 1, 4]) == [1, 2, 3, 4] assert find_unique_elements([]) == [] ``` # Requirements 1. Ensure your solution is efficient and handles large lists within acceptable time limits. 2. Do not use additional data structures that compromise the order of elements. 3. Write your code considering the constraints on list size and element values. # Approach - Initialize an empty set to keep track of elements that have already been encountered. - Iterate through the list and add elements to both the result list and the set if they have not already been encountered (i.e., if they are not in the set). - Return the resultant list containing only the unique elements.","solution":"def find_unique_elements(arr): Returns the unique elements from the given list in the order they first appeared. Args: arr (list): A list of integers. Returns: list: A list of unique integers. seen = set() unique_elements = [] for element in arr: if element not in seen: unique_elements.append(element) seen.add(element) return unique_elements"},{"question":"# Question: Implement a Trie with Prefix Deletion You are required to extend a basic implementation of a Trie (Prefix Tree) to support prefix deletion. In addition to insertion and search operations, the Trie should be capable of deleting all words that share a common prefix. Function Specifications: 1. **Insert Word**: * Function Name: `insert` * Input: A single word `word` as a string. * Output: None. The word is inserted into the Trie. 2. **Search Word**: * Function Name: `search` * Input: A single word `word` as a string. * Output: A boolean value. Returns `True` if the word is present in the Trie, `False` otherwise. 3. **Delete Prefix**: * Function Name: `delete_prefix` * Input: A single prefix `prefix` as a string. * Output: None. Deletes all words in the Trie that start with the given prefix. You are required to implement the `Trie` class with the aforementioned functionalities. Constraints: - Words consist of lowercase English letters. - Handle edge cases where the prefix is not present in the Trie. - The operations should utilize the properties of the Trie to ensure efficient implementation. Example Usage: ```python # Initialize Trie trie = Trie() # Insert words trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apply\\") trie.insert(\\"apex\\") trie.insert(\\"bat\\") # Search words print(trie.search(\\"app\\")) # Expected Output: True print(trie.search(\\"bat\\")) # Expected Output: True print(trie.search(\\"batt\\")) # Expected Output: False # Delete prefix trie.delete_prefix(\\"ap\\") # Search words after deletion print(trie.search(\\"apple\\")) # Expected Output: False print(trie.search(\\"apex\\")) # Expected Output: False print(trie.search(\\"bat\\")) # Expected Output: True ``` Ensure that all methods and class variables within the `Trie` class are appropriately defined and tested to handle the required operations efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def delete_prefix(self, prefix): node = self.root stack = [] for char in prefix: if char not in node.children: return # Prefix not in trie stack.append((char, node)) node = node.children[char] # If the prefix itself is a word, mark it as not end of word if node.is_end_of_word: node.is_end_of_word = False # Remove all children nodes from the last node of the prefix node.children = {} # Clean up the nodes on the way back up the stack if they are no longer part of any word while stack: char, parent = stack.pop() if not parent.children[char].children and not parent.children[char].is_end_of_word: del parent.children[char] else: break"},{"question":"# Question: Implement a Function to Detect Cycles in a Directed Graph You are provided with a directed graph represented as an adjacency list. Your task is to implement a function to detect if the graph contains any cycles. If there are any cycles, return `True`. Otherwise, return `False`. The graph is represented as follows: - An integer **V**, representing the number of vertices in the graph. - A list of lists **graph** where **graph[i]** contains the list of vertices `j` such that there is an edge from vertex **i** to vertex **j**. This representation is 0-indexed. # Input * An integer **V** (1 <= V <= 1000) -- the number of vertices. * A list **graph** representing the adjacency list, where **graph[i]** contains vertices connected to vertex **i** by directed edges. # Output * A boolean value representing whether the graph contains a cycle (`True`) or not (`False`). # Constraints * The graph can be disconnected. * No duplicate edges will exist. # Example ```python Input: V = 4 graph = [ [1], # Edge from vertex 0 to 1 [2], # Edge from vertex 1 to 2 [3], # Edge from vertex 2 to 3 [1] # Edge from vertex 3 to 1 creating a cycle ] Output: True Input: V = 3 graph = [ [1], # Edge from vertex 0 to 1 [2], # Edge from vertex 1 to 2 [] # Vertex 2 has no outgoing edges ] Output: False ``` # Note - Pay attention to directed edges and ensure that your cycle detection works for directed graphs. - Consider using Depth-First Search (DFS) with recursion to keep track of visited vertices and recursion stack to detect cycles. Implement the function `detect_cycle_in_directed_graph(V, graph)` to solve the problem.","solution":"def detect_cycle_in_directed_graph(V, graph): def dfs(vertex, visited, rec_stack): visited[vertex] = True rec_stack[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[vertex] = False return False visited = [False] * V rec_stack = [False] * V for node in range(V): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Implementing a Simple Text Match Function You are tasked with implementing a function that determines if a given pattern string matches a specified target string. The pattern string may include two special characters: 1. `?` - Matches exactly one character of any kind. 2. `*` - Matches zero or more characters of any kind, including an empty string. # Function Signature ```python def is_match(target: str, pattern: str) -> bool: pass ``` # Input * `target`: A string representing the target text which we want to match against the pattern. * `pattern`: A string that includes the pattern containing letters and the special characters `?` and `*`. # Output * A boolean value indicating whether the pattern matches the target string according to the given rules. # Examples 1. For `target = \\"abcdef\\"` and `pattern = \\"a?c*e\\"`, the function should return `True`. 2. For `target = \\"abc\\"` and `pattern = \\"a*c?d\\"`, the function should return `False`. 3. For `target = \\"abcd\\"` and `pattern = \\"a*d\\"`, the function should return `True`. 4. For `target = \\"abcdef\\"` and `pattern = \\"abcdef*\\"`, the function should return `True`. 5. For `target = \\"defgh\\"` and `pattern = \\"*fg*\\"`, the function should return `True`. # Constraints & Edge Cases * The target and pattern strings are non-empty and case-sensitive (i.e., \'a\' does not match \'A\'). * Consider edge cases where the target or pattern is composed entirely of special characters. * Handle cases where the pattern is significantly shorter or longer than the target. # Performance * Ensure your function handles large input sizes efficiently. * Optimize to handle various edge cases without excessive computational overhead. Write your implementation of the `is_match` function to achieve the desired behavior while considering the constraints and performance requirements.","solution":"def is_match(target: str, pattern: str) -> bool: Determines if a given pattern string matches the specified target string. The pattern string may include \'?\' (matches exactly one character) and \'*\' (matches zero or more characters). Parameters: target (str): The target string. pattern (str): The pattern string. Returns: bool: True if the pattern matches the target, False otherwise. m, n = len(target), len(pattern) # dp[i][j] will be True if the first i characters in target # can be matched by the first j characters in pattern dp = [[False] * (n + 1) for _ in range(m + 1)] # An empty pattern matches an empty target dp[0][0] = True # Handle patterns with \'*\' at the beginning for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == target[i - 1] or pattern[j - 1] == \'?\': dp[i][j] = dp[i - 1][j - 1] elif pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] return dp[m][n]"},{"question":"# Coding Assessment Question Problem Statement You are given a 2D grid representing a labyrinth where each cell may either be a wall (\'#\') or an open space (\'.\'). Your task is to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1), where \'n\' and \'m\' are the dimensions of the grid. You are only allowed to move up, down, left, or right. Implement the Breadth-First Search (BFS) algorithm to achieve this. If there is no valid path, return -1. Function Signature ```python def shortest_path(grid): Finds the shortest path from the top-left to the bottom-right corner of the grid using BFS. Parameters: grid (List[List[str]]): A 2D list where each element is either \'.\' (open space) or \'#\' (wall). Returns: int: The length of the shortest path, or -1 if no valid path exists. # your code here ``` Input Format - `grid`: A 2D list of characters where `grid[i][j]` is either \'.\' (an open space) or \'#\' (a wall). Output Format - An integer representing the length of the shortest path from the top-left to the bottom-right corner, or -1 if no path exists. Constraints - The dimensions of the grid ( (n, m) ) ( (1 leq n, m leq 100) ). Example Given the grid: ```python test_grid = [ [\'.\', \'.\', \'#\', \'.\'], [\'#\', \'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'#\'], [\'#\', \'#\', \'.\', \'.\'] ] ``` calling `shortest_path(test_grid)` should return: ``` 7 ``` The path (0, 0) -> (0, 1) -> (1, 1) -> (2, 1) -> (2, 2) -> (2, 3) -> (3, 3) has a length of 7. # Requirements 1. Use BFS to explore the grid. 2. Ensure the function handles edge cases, such as no possible path. 3. Consider grid boundaries to prevent out-of-bounds errors.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left to the bottom-right corner of the grid using BFS. Parameters: grid (List[List[str]]): A 2D list where each element is either \'.\' (open space) or \'#\' (wall). Returns: int: The length of the shortest path, or -1 if no valid path exists. if not grid or grid[0][0] == \'#\' or grid[-1][-1] == \'#\': return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == \'.\': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Longest Consecutive Sequence Finder You have been hired by a software company that specializes in analyzing and processing numerical data. They want you to develop an efficient method to find the length of the longest consecutive elements sequence in an unsorted list of numbers. # Task: Implement a function `longest_consecutive(nums: List[int]) -> int` that: * Takes a list of integers (`nums`), where each integer can be any valid 32-bit signed integer. * Returns the length of the longest consecutive elements sequence in the list. # Input: * `nums`: A list of integers (0 <= len(nums) <= 10^5, each integer can be any valid 32-bit signed integer) # Output: * An integer representing the length of the longest consecutive elements sequence. # Example: ```python >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, -1]) 2 >>> longest_consecutive([9, 1, 4, 7, 3]) 2 >>> longest_consecutive([]) 0 ``` # Constraints: * Ensure your solution handles large input sizes efficiently. * Consider edge cases where there are no elements in the list. # Performance Requirement: * Your solution should perform in linear time, considering the constraints and typical operations associated with searching and comparing elements within the list.","solution":"from typing import List def longest_consecutive(nums: List[int]) -> int: Finds the length of the longest consecutive elements sequence in the list. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Check if it\'s the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem: Reversed Integer Digits with Specific Conditions Write two functions: 1. `reverse_integer_digits(n: int) -> int`: - Given a non-negative integer `n`, this function should return an integer consisting of the digits of `n` reversed. Note that the returned integer should not have leading zeros. 2. `sum_of_odd_digits(n: int) -> int`: - Given a non-negative integer `n`, this function should return the sum of its odd digits. # Input and Output Format Function `reverse_integer_digits` - **Input**: A non-negative integer `n` (0 ≤ n ≤ 10^9). - **Output**: An integer representing the digits of `n` reversed, with no leading zeros. Function `sum_of_odd_digits` - **Input**: A non-negative integer `n` (0 ≤ n ≤ 10^9). - **Output**: An integer representing the sum of the odd digits in `n`. # Constraints - The functions should handle edge cases such as `n` being zero or consisting entirely of the same digit. - Ensure the functions operate efficiently for the maximum input size. # Example: ```python >>> reverse_integer_digits(1230) 321 >>> reverse_integer_digits(10000) 1 >>> sum_of_odd_digits(123456) 9 >>> sum_of_odd_digits(24680) 0 ``` # Additional Notes - Be mindful of edge cases where the input might have trailing zeros which should not appear in the reversed result. - Consider special cases like `n = 0` where the output should be `0` for both functions. - Handle large integer values up to 10^9 efficiently. Compose the responses based on the requirements and constraints specified.","solution":"def reverse_integer_digits(n: int) -> int: Given a non-negative integer n, return an integer consisting of the digits of n reversed, with no leading zeros. reversed_digits = str(n)[::-1] return int(reversed_digits) def sum_of_odd_digits(n: int) -> int: Given a non-negative integer n, return the sum of its odd digits. return sum(int(d) for d in str(n) if int(d) % 2 == 1)"},{"question":"# Scenario As part of a data processing pipeline, you need to transform a list of timestamps into a more human-readable format. This task will test your understanding of date and time manipulation, along with your ability to handle various input formats gracefully. # Task Write a function `format_timestamps` that converts a list of timestamps from the ISO 8601 format to a human-readable string format. Your function should handle various conforming ISO 8601 timestamp formats. # Function Signature ```python from typing import List def format_timestamps(timestamps: List[str]) -> List[str]: pass ``` # Input - `timestamps` (List[str]): a list of timestamps in ISO 8601 format, for example, \\"2023-10-15T14:45:30Z\\" or \\"2023-10-15\\". # Output - Returns a list of the formatted timestamps in the \\"YYYY-MM-DD HH:MM:SS\\" format. Include \\"00:00:00\\" for dates without times but ensure time zone normalization to UTC. # Constraints - The input list may be empty. - Each timestamp is guaranteed to be a valid ISO 8601 format. # Examples ```python print(format_timestamps([])) # Output: [] print(format_timestamps([\\"2023-10-15T14:45:30Z\\", \\"2023-10-15\\"])) # Output: [\\"2023-10-15 14:45:30\\", \\"2023-10-15 00:00:00\\"] print(format_timestamps([\\"2021-03-01T12:00:00+01:00\\", \\"2021-03-01\\"])) # Output: [\\"2021-03-01 11:00:00\\", \\"2021-03-01 00:00:00\\"] print(format_timestamps([\\"2022-12-25T00:00:00Z\\", \\"2022-12-25T15:30:00-05:00\\"])) # Output: [\\"2022-12-25 00:00:00\\", \\"2022-12-25 20:30:00\\"] ``` # Hint You may find libraries like `datetime` and `dateutil` useful for parsing and converting timestamps. Ensure that all timestamps are normalized to UTC before formatting.","solution":"from typing import List from dateutil import parser import pytz def format_timestamps(timestamps: List[str]) -> List[str]: formatted_timestamps = [] for ts in timestamps: dt = parser.isoparse(ts) # Normalize to UTC if dt.tzinfo is not None: dt = dt.astimezone(pytz.UTC) # Format as YYYY-MM-DD HH:MM:SS formatted_timestamps.append(dt.strftime(\'%Y-%m-%d %H:%M:%S\')) return formatted_timestamps"},{"question":"Sorting Algorithm Analysis and Implementation You are required to analyze and implement two sorting algorithms in Python: Merge Sort and Quick Sort. This will test your understanding of sorting techniques, their efficiencies, and the ability to implement them. Problem Statement: Design and implement two functions: 1. `merge_sort(arr)`: Sorts a list of integers using the Merge Sort algorithm. 2. `quick_sort(arr)`: Sorts a list of integers using the Quick Sort algorithm. # Function Definitions: 1. **`merge_sort(arr)`**: - **Input**: A list of integers (`arr`). - **Output**: A new list of integers sorted in ascending order. - **Constraints**: Handle the case where the input list is empty. 2. **`quick_sort(arr)`**: - **Input**: A list of integers (`arr`). - **Output**: A sorted list of integers in ascending order, modifying the original list in-place. - **Constraints**: Handle the case where the input list is empty. Example: ```python arr1 = [38, 27, 43, 3, 9, 82, 10] sorted_arr1 = merge_sort(arr1) print(f\\"Merge Sorted Array: {sorted_arr1}\\") arr2 = [38, 27, 43, 3, 9, 82, 10] quick_sort(arr2) print(f\\"Quick Sorted Array: {arr2}\\") ``` Expected Output: For `merge_sort`: - Merge Sorted Array: `[3, 9, 10, 27, 38, 43, 82]` For `quick_sort`: - Quick Sorted Array: `[3, 9, 10, 27, 38, 43, 82]` # Additional Requirements: - Ensure stability in the Merge Sort implementation. - Optimize the Quick Sort to handle both best and worst cases efficiently (consider using randomized pivot selection). - Explain the time complexity of both algorithms in average, best, and worst cases. Notes: - You may use additional helper functions if needed. - Take care of edge cases like an empty list. This question will help assess the candidate’s ability to implement fundamental algorithms, optimize code, and handle various edge cases effectively.","solution":"def merge_sort(arr): Function to perform merge sort on a list of integers. if len(arr) <= 1: return arr def merge(left, right): result = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def quick_sort(arr): Function to perform quick sort on a list of integers in place. if len(arr) <= 1: return def partition(low, high): pivot_index = low pivot_value = arr[high] for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[pivot_index] = arr[pivot_index], arr[i] pivot_index += 1 arr[pivot_index], arr[high] = arr[high], arr[pivot_index] return pivot_index def quick_sort_recursive(low, high): if low < high: pivot_index = partition(low, high) quick_sort_recursive(low, pivot_index - 1) quick_sort_recursive(pivot_index + 1, high) quick_sort_recursive(0, len(arr) - 1)"},{"question":"# Problem: Consecutive Element Product Sequence You are tasked with writing a function that processes a list of integers by replacing each element with the product of the previous and the next elements. For the first and last elements, since there are no previous and next elements respectively, they should remain unchanged. Function Signature ```python def consecutive_product_sequence(arr: List[int]) -> List[int]: Replaces each element in the list with the product of the previous and the next elements. Parameters: arr (List[int]): The input list of integers. Returns: List[int]: The transformed list as per the above rule. Example: >>> consecutive_product_sequence([2, 3, 4, 5]) [2, 8, 15, 5] >>> consecutive_product_sequence([1, 2, 3, 4, 5]) [1, 3, 8, 15, 5] ``` Input * A single list `arr` (0 <= len(arr) <= 1000) containing integer elements. Output * A list of integers with each element replaced by the product of its previous and next elements, except for the first and last elements which remain unchanged. Constraints * The length of the list can be from 0 to 1000. * Handle the cases where the list has less than 3 elements appropriately. Examples ```python consecutive_product_sequence([2, 3, 4, 5]) # Should output: [2, 8, 15, 5] consecutive_product_sequence([1, 2, 3, 4, 5]) # Should output: [1, 3, 8, 15, 5] consecutive_product_sequence([5]) # Should output: [5] consecutive_product_sequence([5, 10]) # Should output: [5, 10] consecutive_product_sequence([]) # Should output: [] ```","solution":"from typing import List def consecutive_product_sequence(arr: List[int]) -> List[int]: Replaces each element in the list with the product of the previous and the next elements. Parameters: arr (List[int]): The input list of integers. Returns: List[int]: The transformed list as per the above rule. n = len(arr) # If the list has less than 3 elements, return it unchanged if n < 3: return arr # Create a new list to store the result result = arr[:] for i in range(1, n-1): result[i] = arr[i-1] * arr[i+1] return result"},{"question":"# Convert Mixed Case String to Title Case Context String manipulation is a fundamental skill in programming. One common requirement is to convert a string so that each word starts with an uppercase letter and all other letters are in lowercase, often referred to as Title Case. This question assesses your ability to manipulate strings and handle capitalization correctly. Task Write a Python function `convert_to_title_case(mixed_case_string: str) -> str` that converts a string with mixed case words to title case. Your solution should incorporate proper error handling for invalid input values. Specifications - **Input**: A string `mixed_case_string` containing words separated by spaces. - **Output**: The title case string. - **Constraints**: - The input string will only contain alphabetic characters and spaces. - The input will not be empty. - Words in the input string may be in any case (e.g., \\"hello\\", \\"Hello\\", \\"HELLO\\"). Error Handling - Raise a `ValueError` with the message \\"Empty string was passed to the function\\" if the input string is empty. - Raise a `ValueError` with the message \\"Invalid character detected in input string\\" if the input string contains non-alphabetic characters (excluding spaces). Examples ```python >>> convert_to_title_case(\\"hello world\\") \'Hello World\' >>> convert_to_title_case(\\"Python PROGRAMMING\\") \'Python Programming\' >>> convert_to_title_case(\\"hErE Is A MixED case STRING\\") \'Here Is A Mixed Case String\' >>> convert_to_title_case(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> convert_to_title_case(\\"Hello World 123\\") Traceback (most recent call last): ... ValueError: Invalid character detected in input string ``` Notes - Your solution should efficiently handle the conversion to title case. - Ensure thorough testing of your function with various input cases, including edge cases, to guarantee reliability.","solution":"def convert_to_title_case(mixed_case_string: str) -> str: Converts a string with mixed case words to title case. Args: mixed_case_string (str): A string containing words separated by spaces. Returns: str: A title cased string. Raises: ValueError: If the input string is empty or contains non-alphabetic characters excluding spaces. if mixed_case_string == \\"\\": raise ValueError(\\"Empty string was passed to the function\\") if not all(c.isalpha() or c.isspace() for c in mixed_case_string): raise ValueError(\\"Invalid character detected in input string\\") return mixed_case_string.title()"},{"question":"**Scenario**: You are working as a backend developer for an e-commerce platform. One of your tasks is to develop a system for managing customer orders. Each customer can place multiple orders, and each order can contain multiple items. Your job is to create a data structure to efficiently manage this information and implement functions that provide key insights about orders. **Task**: Create a Python class `OrderManagement` to manage customer orders. Implement the following methods: 1. `add_order(self, customer_id: int, order_id: int, items: List[str]) -> None`: This method should add a new order to the system for a given customer. 2. `get_orders(self, customer_id: int) -> List[int]`: This method should return a list of order IDs for a specific customer. 3. `get_items_in_order(self, order_id: int) -> List[str]`: This method should return a list of items in a specified order. # Requirements: - **`add_order` Method:** - **Input**: `customer_id` (integer), `order_id` (integer), and `items` (a list of strings representing item names) - **Output**: None - **`get_orders` Method:** - **Input**: `customer_id` (integer) - **Output**: A list of order IDs associated with the given customer ID - **`get_items_in_order` Method:** - **Input**: `order_id` (integer) - **Output**: A list of items in the specified order # Constraints: - The system should efficiently handle up to 100,000 customers and 500,000 orders. - Each order contains up to 100 items. - A customer can place any number of orders. Implement these methods considering the constraints to ensure optimal performance and memory usage. **Function Signatures**: ```python def add_order(self, customer_id: int, order_id: int, items: List[str]) -> None: pass def get_orders(self, customer_id: int) -> List[int]: pass def get_items_in_order(self, order_id: int) -> List[str]: pass ``` **Example**: ```python manager = OrderManagement() # Adding orders manager.add_order(1, 101, [\\"itemA\\", \\"itemB\\", \\"itemC\\"]) manager.add_order(1, 102, [\\"itemD\\", \\"itemE\\"]) manager.add_order(2, 201, [\\"itemF\\"]) # Retrieving orders for a customer assert manager.get_orders(1) == [101, 102] assert manager.get_orders(2) == [201] assert manager.get_orders(3) == [] # Retrieving items in an order assert manager.get_items_in_order(101) == [\\"itemA\\", \\"itemB\\", \\"itemC\\"] assert manager.get_items_in_order(102) == [\\"itemD\\", \\"itemE\\"] assert manager.get_items_in_order(201) == [\\"itemF\\"] assert manager.get_items_in_order(301) == [] ``` # Notes: Consider edge cases such as: - Adding orders for a non-existent customer. - Retrieving orders or items for IDs that are not present in the system. - The data structure should be optimized for frequent read operations.","solution":"from typing import List, Dict, Union class OrderManagement: def __init__(self): self.customer_orders: Dict[int, List[int]] = {} self.order_items: Dict[int, List[str]] = {} def add_order(self, customer_id: int, order_id: int, items: List[str]) -> None: if customer_id not in self.customer_orders: self.customer_orders[customer_id] = [] self.customer_orders[customer_id].append(order_id) self.order_items[order_id] = items def get_orders(self, customer_id: int) -> List[int]: return self.customer_orders.get(customer_id, []) def get_items_in_order(self, order_id: int) -> List[str]: return self.order_items.get(order_id, [])"},{"question":"# Road Intersection Planner Problem Description You are part of a city planning team and have been asked to analyze a proposed street layout to ensure that no intersections have more than two roads connecting directly to them. You are provided with a list of connections where each connection is a tuple representing two intersections connected by a road. Your task is to determine if the street layout is valid based on the given criterion and, if it is valid, return a list representing the degree (number of connecting roads) of each intersection. Function Signature Write a Python function `validate_street_network(connections: List[Tuple[int, int]]) -> Union[List[int], str]` that takes one parameter: - `connections`: A list of tuples representing the roads between intersections, where each tuple `(a, b)` indicates a road between intersection `a` and intersection `b`. Return - A list of integers where the `i-th` element represents the number of roads connected to the `i-th` intersection (if the layout is valid). - The string `\\"Invalid layout\\"` if any intersection has more than two roads connected to it. Constraints - The number of intersections `N` will be between 2 and 50. - The number of roads `R` will be between 1 and 100. - Intersections are numbered starting from 0. Example ```python def validate_street_network(connections: List[Tuple[int, int]]) -> Union[List[int], str]: # Your code here # Example Test Cases connections1 = [(0, 1), (1, 2), (2, 3), (3, 4)] print(validate_street_network(connections1)) # Output: [1, 2, 2, 2, 1] connections2 = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 1)] print(validate_street_network(connections2)) # Output: [1, 3, 2, 2, 2] connections3 = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (0, 2)] print(validate_street_network(connections3)) # Output: \\"Invalid layout\\" ``` In these examples, the first street network is valid where all intersections have at most two connections. The second street network is invalid as intersection 1 has three connected roads. The third network is also invalid as intersection 0 has more than two connected roads. Requirements - Implement the `validate_street_network` function to solve the problem by accurately tracking and checking the number of roads connected to each intersection. - Ensure your solution is efficient and meets the problem constraints.","solution":"from typing import List, Tuple, Union def validate_street_network(connections: List[Tuple[int, int]]) -> Union[List[int], str]: # Find the maximum intersection index to determine the size of degree list if not connections: return \\"Invalid layout\\" max_intersection = max(max(a, b) for a, b in connections) degrees = [0] * (max_intersection + 1) for a, b in connections: degrees[a] += 1 degrees[b] += 1 if degrees[a] > 2 or degrees[b] > 2: return \\"Invalid layout\\" return degrees"},{"question":"**Rotating Matrix 90 Degrees Clockwise** You are given a square matrix `M` of size `n x n` containing integers. Your task is to rotate the matrix by 90 degrees in the clockwise direction and return the resulting matrix. # Input - An integer `n` representing the size of the square matrix (2 ≤ n ≤ 100). - A 2D list `M` of integers where each element `M[i][j]` (0 ≤ i, j < n) represents the value at the `i-th` row and `j-th` column of the matrix. # Output - A 2D list that represents the original matrix rotated by 90 degrees clockwise. # Constraints - The matrix will have at least 2 rows and columns. - The matrix will be square (number of rows equals number of columns). # Example ```python M = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] def rotate_matrix(M: List[List[int]]) -> List[List[int]]: # Your code here if __name__ == \\"__main__\\": print(rotate_matrix(M)) ``` # Example Usage ```python M = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(M) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Write the function `rotate_matrix` such that passing the above example `M` returns the matrix rotated by 90 degrees clockwise.","solution":"def rotate_matrix(M): Rotates a given n x n matrix by 90 degrees clockwise. Parameters: M (List[List[int]]): A 2D list representing the n x n matrix. Returns: List[List[int]]: The rotated matrix. n = len(M) # Create a new matrix to store the result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = M[i][j] return rotated"},{"question":"# Problem Statement You are given a 2D matrix where each cell contains an integer representing either the height of the terrain or water. Your task is to find the number of islands present in the matrix. An island is defined as a group of contiguous cells with the same value, surrounded by either different values or the edges of the matrix. Contiguity is defined by the four cardinal directions (up, down, left, right). # Function to Implement ```python def count_islands(matrix: list[list[int]]) -> int: Counts the number of islands in a matrix. Parameters: matrix (list[list[int]]): The 2D matrix containing integer values representing heights or water. Returns: int: The number of islands in the given matrix. pass ``` # Example ```python matrix = [ [1, 1, 0, 0, 2], [1, 0, 0, 2, 2], [1, 1, 0, 2, 0], [0, 0, 0, 0, 0], [2, 2, 2, 1, 1] ] print(count_islands(matrix)) # Output: 5 # Explanation: There are 5 islands as follows: # 1. The group of 1s at the top-left corner. # 2. The single 0-cell at matrix[0][2]. # 3. The group of 2s near the top-right corner. # 4. The group of 1s near the bottom-right corner. # 5. The group of 2s at the bottom-left corner. ``` # Constraints 1. The matrix will have at least 1 row and 1 column. 2. The matrix will have at most 1000 rows and 1000 columns. 3. The matrix contains integer values between 0 and 1000. # Assumptions 1. The matrix is non-empty. 2. The values in the matrix represent discernible terrain or water features. # Performance Requirements Ensure that your solution efficiently handles large matrices (up to 1000x1000 in size) in terms of both time and space complexity. Aim to achieve a solution with a time complexity of O(n * m) where n and m are the dimensions of the matrix.","solution":"def count_islands(matrix: list[list[int]]) -> int: if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, value): if not (0 <= r < rows and 0 <= c < cols): return if visited[r][c] or matrix[r][c] != value: return visited[r][c] = True # Traverse the four cardinal directions dfs(r - 1, c, value) dfs(r + 1, c, value) dfs(r, c - 1, value) dfs(r, c + 1, value) count = 0 for r in range(rows): for c in range(cols): if not visited[r][c]: count += 1 dfs(r, c, matrix[r][c]) return count"},{"question":"# Problem Description: You are tasked with implementing a function that finds the lowest common ancestor (LCA) of two given nodes in a binary tree. # Function Signature: ```python def lowest_common_ancestor(root: Optional[TreeNode], p: TreeNode, q: TreeNode) -> Optional[TreeNode]: pass ``` # Input: - A reference to the root `TreeNode` of a binary tree. - References to two nodes `p` and `q` in the binary tree. - The `TreeNode` class is structured as follows: ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right ``` # Output: - Returns the `TreeNode` reference to the lowest common ancestor of nodes `p` and `q`. # Constraints: - The number of nodes in the tree is in the range `[2, 10^5]`. - The value of nodes in the tree are unique. # Example: ```python # Given the binary tree: # 3 # / # 5 1 # / / # 6 2 0 8 # / # 7 4 # Example nodes p = 5 and q = 1 root = TreeNode(3) node5 = TreeNode(5) node1 = TreeNode(1) node6 = TreeNode(6) node2 = TreeNode(2) node0 = TreeNode(0) node8 = TreeNode(8) node7 = TreeNode(7) node4 = TreeNode(4) root.left = node5 root.right = node1 node5.left = node6 node5.right = node2 node1.left = node0 node1.right = node8 node2.left = node7 node2.right = node4 # lowest_common_ancestor(root, node5, node1) should return the node with value 3 ancestor = lowest_common_ancestor(root, node5, node1) assert ancestor.val == 3 ``` # Notes: - You may assume that both `p` and `q` are present in the binary tree. - Consider edge cases where the nodes `p` and `q` are the same or are located in deeply nested parts of the tree.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root: Optional[TreeNode], p: TreeNode, q: TreeNode) -> Optional[TreeNode]: if root is None: return None if root == p or root == q: return root left_lca = lowest_common_ancestor(root.left, p, q) right_lca = lowest_common_ancestor(root.right, p, q) if left_lca and right_lca: return root return left_lca if left_lca else right_lca"},{"question":"# Seat Reservation System **Problem Statement**: Design a class to manage a seat reservation system for a small venue. The venue has a fixed number of rows and seats per row. Customers can reserve, cancel, and check the availability of seats. **Class Definition** ```python class SeatReservation: def __init__(self, rows: int, seats_per_row: int): pass def reserve(self, row: int, seat: int) -> bool: pass def cancel(self, row: int, seat: int) -> bool: pass def check_availability(self, row: int, seat: int) -> bool: pass ``` **Input**: - During initialization, the class will receive: - `rows`: an integer representing the number of rows. - `seats_per_row`: an integer representing the number of seats per row. - For the `reserve` method: - `row`: an integer representing the row number (0-indexed). - `seat`: an integer representing the seat number (0-indexed). - For the `cancel` method: - `row`: an integer representing the row number (0-indexed). - `seat`: an integer representing the seat number (0-indexed). - For the `check_availability` method: - `row`: an integer representing the row number (0-indexed). - `seat`: an integer representing the seat number (0-indexed). **Output**: - For the `reserve` method: - Returns `True` if the reservation is successful. - Returns `False` if the seat is already reserved or the input is invalid. - For the `cancel` method: - Returns `True` if the cancellation is successful. - Returns `False` if the seat was not reserved or the input is invalid. - For the `check_availability` method: - Returns `True` if the seat is available. - Returns `False` if the seat is reserved or the input is invalid. **Constraints**: - Rows and seats per row are positive integers less than or equal to 100. - Methods should handle edge cases and invalid inputs appropriately. - Reservation and cancellation should not alter the availability of other seats. # Example ```python reservation_system = SeatReservation(3, 5) print(reservation_system.check_availability(1, 2)) # True, seat is available print(reservation_system.reserve(1, 2)) # True, reservation successful print(reservation_system.check_availability(1, 2)) # False, seat is now reserved print(reservation_system.cancel(1, 2)) # True, cancellation successful print(reservation_system.check_availability(1, 2)) # True, seat is available again print(reservation_system.reserve(1, 5)) # False, invalid input (seat number out of range) ``` **Notes**: - Make sure the class methods handle invalid row and seat numbers gracefully. - Consider edge cases like reserving the last seat in the last row or checking for seat availability before and after reservations.","solution":"class SeatReservation: def __init__(self, rows: int, seats_per_row: int): self.rows = rows self.seats_per_row = seats_per_row # Initialize a 2D list to keep track of seat reservations self.seats = [[False for _ in range(seats_per_row)] for _ in range(rows)] def reserve(self, row: int, seat: int) -> bool: if self._is_valid_seat(row, seat): if not self.seats[row][seat]: self.seats[row][seat] = True return True else: return False return False def cancel(self, row: int, seat: int) -> bool: if self._is_valid_seat(row, seat): if self.seats[row][seat]: self.seats[row][seat] = False return True else: return False return False def check_availability(self, row: int, seat: int) -> bool: if self._is_valid_seat(row, seat): return not self.seats[row][seat] return False def _is_valid_seat(self, row: int, seat: int) -> bool: return 0 <= row < self.rows and 0 <= seat < self.seats_per_row"},{"question":"# String Manipulation: Reversing Words in a Sentence Background String manipulation tasks are common in programming. A typical problem is to reverse the order of words in a given sentence while preserving the initial casing of each word and keeping the punctuation intact. Task Write a function `reverse_words` that takes a sentence as input and returns a new sentence with the order of words reversed. The function should preserve the casing of each word and leave the punctuation (if any) at the end of the sentence. Function Signature ```python def reverse_words(sentence: str) -> str: Reverse the order of words in the given sentence. :param sentence: A string representing the input sentence. :return: A string with the words in reverse order. ``` Input * `sentence`: a string representing the input sentence. The sentence may end with a punctuation mark (e.g., ., !, ?). Output * The function should return a string with the order of words reversed. The output sentence should preserve the initial casing of each word and keep the punctuation (if any) at the end. Constraints * The input sentence will not be empty and will not contain leading or trailing whitespaces. * The input sentence will contain only alphabetic words separated by single spaces, and may optionally end with a punctuation mark. Requirements * The function should correctly handle sentences with various punctuation marks and preserve the punctuation at the end. * The function should not change the casing of any words. Example ```python # Example usage print(reverse_words(\\"Hello World!\\")) # Output: \\"World Hello!\\" print(reverse_words(\\"Keep it simple.\\")) # Output: \\"simple it Keep.\\" ```","solution":"def reverse_words(sentence: str) -> str: Reverse the order of words in the given sentence. :param sentence: A string representing the input sentence. :return: A string with the words in reverse order. # Check if the last character is a punctuation punctuation = \'\' if sentence[-1] in \'.!?\': punctuation = sentence[-1] sentence = sentence[:-1] # Split the sentence into words, reverse them and join them back words = sentence.split() reversed_sentence = \' \'.join(reversed(words)) # If there was punctuation, add it back. if punctuation: reversed_sentence += punctuation return reversed_sentence"},{"question":"# Problem Statement Create a function that takes a list of integers and returns a new list where each element is the sum of the previous integer elements in the list up to that position (inclusive). This is known as the cumulative sum or prefix sum of the list. **Function Signature**: ```python def cumulative_sum(lst: List[int]) -> List[int]: pass ``` **Input**: - A single list `lst` containing integers. **Output**: - A list of integers where the `i`-th element is the sum of elements from `lst[0]` to `lst[i]`. **Constraints**: - The input list will contain at most (10^6) elements. - Each element in the input list will be an integer in the range ([-10^9, 10^9]). **Performance Requirements**: - The function should have a time complexity of (O(n)), where (n) is the length of the input list. - The function should handle edge cases gracefully such as an empty list and large input numbers. # Example ```python assert cumulative_sum([1, 2, 3, 4]) == [1, 3, 6, 10] assert cumulative_sum([-1, 1, -1, 1]) == [-1, 0, -1, 0] assert cumulative_sum([5, 10, 20, -5, -10]) == [5, 15, 35, 30, 20] assert cumulative_sum([]) == [] ``` # Explanation The task is to compute the cumulative sum of the input list. For each position (i) in the input list `lst`, the output list should contain the sum of elements from position 0 to (i) in the input list. If the input list is empty, the output should also be an empty list. The function should perform efficiently even for a large number of elements in the input list.","solution":"from typing import List def cumulative_sum(lst: List[int]) -> List[int]: if not lst: return [] cum_sum = [] current_sum = 0 for num in lst: current_sum += num cum_sum.append(current_sum) return cum_sum"},{"question":"# Task: Objective: Implement a `TemperatureConverter` class that allows temperature conversions between Celsius, Fahrenheit, and Kelvin while maintaining precision and handling invalid inputs gracefully. Requirements: 1. Implement the class `TemperatureConverter` with methods to convert between Celsius, Fahrenheit, and Kelvin. 2. Ensure precision in conversion and validate input types and ranges appropriately. 3. Include exception handling for invalid temperature values (e.g., below absolute zero). Class Definition: ```python class TemperatureConverter: def __init__(self): pass def celsius_to_fahrenheit(self, celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Temperature cannot be below absolute zero in Celsius.\\") return (celsius * 9/5) + 32 def fahrenheit_to_celsius(self, fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Temperature cannot be below absolute zero in Fahrenheit.\\") return (fahrenheit - 32) * 5/9 def celsius_to_kelvin(self, celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Temperature cannot be below absolute zero in Celsius.\\") return celsius + 273.15 def kelvin_to_celsius(self, kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Temperature cannot be below absolute zero in Kelvin.\\") return kelvin - 273.15 def fahrenheit_to_kelvin(self, fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Temperature cannot be below absolute zero in Fahrenheit.\\") return (fahrenheit - 32) * 5/9 + 273.15 def kelvin_to_fahrenheit(self, kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Temperature cannot be below absolute zero in Kelvin.\\") return (kelvin - 273.15) * 9/5 + 32 ``` Testing: - Create multiple test cases to validate the conversion accuracy and edge case handling: 1. Valid conversions across all supported units. 2. Invalid temperatures below absolute zero for each unit. 3. Precision checks for floating-point values. Example: ```python converter = TemperatureConverter() # Valid conversions print(converter.celsius_to_fahrenheit(0)) # 32.0 print(converter.fahrenheit_to_celsius(32)) # 0.0 print(converter.celsius_to_kelvin(0)) # 273.15 print(converter.kelvin_to_celsius(273.15)) # 0.0 print(converter.fahrenheit_to_kelvin(32)) # 273.15 print(converter.kelvin_to_fahrenheit(273.15)) # 32.0 # Invalid input (below absolute zero) try: print(converter.celsius_to_fahrenheit(-300)) except ValueError as e: print(e) # Temperature cannot be below absolute zero in Celsius. ``` **Output**: ```shell 32.0 0.0 273.15 0.0 273.15 32.0 Temperature cannot be below absolute zero in Celsius. ``` Ensure to test for accuracy, edge cases, and exception handling for invalid temperatures.","solution":"class TemperatureConverter: def __init__(self): pass def celsius_to_fahrenheit(self, celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Temperature cannot be below absolute zero in Celsius.\\") return (celsius * 9/5) + 32 def fahrenheit_to_celsius(self, fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Temperature cannot be below absolute zero in Fahrenheit.\\") return (fahrenheit - 32) * 5/9 def celsius_to_kelvin(self, celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Temperature cannot be below absolute zero in Celsius.\\") return celsius + 273.15 def kelvin_to_celsius(self, kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Temperature cannot be below absolute zero in Kelvin.\\") return kelvin - 273.15 def fahrenheit_to_kelvin(self, fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Temperature cannot be below absolute zero in Fahrenheit.\\") return (fahrenheit - 32) * 5/9 + 273.15 def kelvin_to_fahrenheit(self, kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Temperature cannot be below absolute zero in Kelvin.\\") return (kelvin - 273.15) * 9/5 + 32"},{"question":"# Scenario You are tasked with creating a simplified recommendation system for a movie streaming service. Given user ratings for a set of movies, you need to implement a function that predicts the ratings for movies a user hasn\'t rated yet. # Requirements 1. Implement a function `recommend_movies` that takes in two arguments: - `user_ratings` which is a dictionary where keys are user IDs and values are dictionaries with movie IDs as keys and ratings as values. - `predict_for_user` which is an integer representing the user ID for whom to predict ratings. 2. The function should return a dictionary with movie IDs as keys and predicted ratings as values for the movies the user hasn\'t rated yet. # Input - `user_ratings: Dict[int, Dict[int, float]]` - Dictionary representing the ratings given by users to movies. - `predict_for_user: int` - The user ID for whom the ratings are to be predicted. # Output - `Dict[int, float]` - Dictionary with movie IDs as keys and predicted ratings as values. # Constraints - `0 <= len(user_ratings) <= 1000` - `0 <= len(user_ratings[user_id]) <= 500` - Ratings are floats between 0.0 and 5.0. - User IDs and movie IDs are positive integers. - The algorithm should use collaborative filtering to predict ratings. # Performance - The solution should be efficient in terms of both time and space complexity within the provided constraints. # Function Signature ```python def recommend_movies(user_ratings: Dict[int, Dict[int, float]], predict_for_user: int) -> Dict[int, float]: pass ``` # Example ```python user_ratings = { 1: {101: 5.0, 102: 3.0, 103: 4.0}, 2: {101: 4.0, 102: 2.0, 103: 5.0, 104: 3.0}, 3: {101: 3.0, 102: 5.0, 104: 4.0}, } predicted_ratings = recommend_movies(user_ratings, 1) # Example of a possible output, actual values may vary: # {104: 3.5} assert {104: 3.5} == predicted_ratings # Simplified expected output for illustration ``` # Solution Approach You may use collaborative filtering techniques such as User-Based or Item-Based approaches to predict ratings for the user. Use similarity measures like cosine similarity or Pearson correlation to estimate the missing ratings.","solution":"from typing import Dict, List import numpy as np def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = np.dot(vec1, vec2) magnitude1 = np.sqrt(np.dot(vec1, vec1)) magnitude2 = np.sqrt(np.dot(vec2, vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0 return dot_product / (magnitude1 * magnitude2) def recommend_movies(user_ratings: Dict[int, Dict[int, float]], predict_for_user: int) -> Dict[int, float]: all_movies = {movie_id for ratings in user_ratings.values() for movie_id in ratings} user_rated_movies = user_ratings.get(predict_for_user, {}) similarities = {} for user_id, ratings in user_ratings.items(): if user_id != predict_for_user: common_movies = set(user_rated_movies) & set(ratings) if common_movies: vec1 = [user_rated_movies[movie] for movie in common_movies] vec2 = [ratings[movie] for movie in common_movies] similarity = cosine_similarity(vec1, vec2) similarities[user_id] = similarity predictions = {} for movie in all_movies - user_rated_movies.keys(): numerator, denominator = 0.0, 0.0 for user_id, similarity in similarities.items(): if movie in user_ratings[user_id] and similarity > 0: numerator += similarity * user_ratings[user_id][movie] denominator += similarity if denominator > 0: predictions[movie] = numerator / denominator return predictions"},{"question":"Question # Context: You are working on a numerical analysis project and need to implement a matrix transformation operation. Specifically, for a given square matrix, you are required to perform a rotation. # Task: Write a Python function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]:` that takes a square matrix (a list of lists) as input and returns a new matrix which is rotated 90 degrees clockwise. # Input: - `matrix`: A list of lists where each inner list represents a row of a square matrix (n x n) and contains integers. # Output: - A new matrix which is the input matrix rotated 90 degrees clockwise. # Constraints: - The matrix will be a square matrix (i.e., the number of rows is equal to the number of columns). - 1 <= n <= 100 - -10^9 <= matrix[i][j] <= 10^9 # Example: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass # Your implementation here # Examples print(rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Expected output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_matrix([[1, 2], [3, 4]])) # Expected output: [ # [3, 1], # [4, 2] # ] ``` # Requirements: - Implement the rotation without using any additional nested loops. - Consider edge cases such as the smallest and largest possible sizes of the matrix. - Optimize for performance and minimize unnecessary operations.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix n = len(matrix) # Create a new matrix with rotated dimensions rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Problem Statement You are provided with a partially implemented Python class, `MatrixOperations`, that supports transformation operations on a 2D matrix. The class contains two static methods, `rotate_matrix` and `transpose_matrix`, but they are incomplete. Your task is to complete these methods so that they perform the requested operations on the input matrix. # Requirements and Constraints 1. **Input**: - The `rotate_matrix` method takes a square matrix (2D list of integers) as input and an optional direction parameter (\\"clockwise\\" or \\"counterclockwise\\"), defaulting to \\"clockwise\\". - The `transpose_matrix` method takes any 2D matrix (2D list of integers) as input. 2. **Output**: - The `rotate_matrix` method returns the rotated matrix as a 2D list of integers. - The `transpose_matrix` method returns the transposed matrix as a 2D list of integers. 3. **Constraints**: - The input matrix for `rotate_matrix` is always square (NxN). - The optional direction parameter for `rotate_matrix` can only be \\"clockwise\\" or \\"counterclockwise\\". - The dimensions of the input matrix for `transpose_matrix` will be in the range [1, 1000]x[1, 1000]. # Example **Input for `rotate_matrix`**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] direction = \\"clockwise\\" ``` **Output for `rotate_matrix`**: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Input for `transpose_matrix`**: ```python matrix = [ [1, 2, 3], [4, 5, 6] ] ``` **Output for `transpose_matrix`**: ```python [ [1, 4], [2, 5], [3, 6] ] ``` # Instructions 1. Implement the `rotate_matrix` static method to rotate the matrix 90 degrees in the specified direction. 2. Implement the `transpose_matrix` static method to transpose the matrix. 3. Ensure that your methods handle edge cases effectively (e.g., empty matrix). ```python class MatrixOperations: @staticmethod def rotate_matrix(matrix, direction=\\"clockwise\\"): # Your code goes here pass @staticmethod def transpose_matrix(matrix): # Your code goes here pass # Example usage: # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # rotated = MatrixOperations.rotate_matrix(matrix) # print(rotated) # transposed = MatrixOperations.transpose_matrix(matrix) # print(transposed) ```","solution":"class MatrixOperations: @staticmethod def rotate_matrix(matrix, direction=\\"clockwise\\"): Rotates the given NxN matrix 90 degrees in the specified direction. Parameters: matrix (list of list of int): A 2D list representing the NxN matrix. direction (str): Direction of rotation, either \\"clockwise\\" or \\"counterclockwise\\". Returns: list of list of int: The rotated matrix. n = len(matrix) if direction == \\"clockwise\\": return [[matrix[n-1-j][i] for j in range(n)] for i in range(n)] elif direction == \\"counterclockwise\\": return [[matrix[j][n-1-i] for j in range(n)] for i in range(n)] else: raise ValueError(\\"Direction must be \'clockwise\' or \'counterclockwise\'\\") @staticmethod def transpose_matrix(matrix): Transposes the given matrix. Parameters: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"# Frequency Counter for Most Common Words Scenario: You are creating a text analysis tool that needs to identify the most common words in a given text. The tool will help in summarizing the content by showing the words that appear most frequently. Task: Implement a function `most_common_words` that takes a string of text and an integer `n` as inputs and returns a list of the `n` most common words in the text. The words should be returned in descending order of their frequency. If multiple words have the same frequency, they should be sorted alphabetically. Function Signature: ```python def most_common_words(text: str, n: int) -> list: Identify the n most common words in the given text. :param str text: The input text to analyze. :param int n: The number of most common words to return. :return list: List of the n most common words sorted by frequency, and alphabetically for words with same frequency. Example: >>> most_common_words(\\"apple orange banana apple orange apple\\", 2) [\'apple\', \'orange\'] >>> most_common_words(\\"apple orange banana apple orange apple\\", 1) [\'apple\'] >>> most_common_words(\\"apple orange banana orange grape apple\\", 3) [\'apple\', \'orange\', \'banana\'] >>> most_common_words(\\"apple orange banana\\", -1) Traceback (most recent call last): ... ValueError: N must be a positive integer. >>> most_common_words(\\"\\", 3) [] # Your implementation goes here ``` Constraints: - The input `text` can contain punctuation and special characters. - All words should be considered case-insensitively (e.g., \\"Apple\\" and \\"apple\\" should be counted as the same word). - A word is defined as a sequence of alphanumeric characters. - Raise a `ValueError` if `n` is not a positive integer with the message: \\"N must be a positive integer.\\" Performance Requirement: - The function should handle texts of up to 10,000 words efficiently. Test your implementation with provided examples and additional test cases to ensure its correctness and performance.","solution":"import re from collections import Counter def most_common_words(text: str, n: int) -> list: if not isinstance(n, int) or n <= 0: raise ValueError(\\"N must be a positive integer.\\") # Normalize the text to lower case and extract words words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_counts = Counter(words) # Get the most common words and sort by frequency first and then alphabetically most_common = word_counts.most_common() sorted_common = sorted(most_common, key=lambda x: (-x[1], x[0])) # Extract only the words from the sorted list and return top n return [word for word, count in sorted_common[:n]]"},{"question":"# Context: You have been tasked with adding a new feature to an existing web server framework. This framework supports middleware, which are functions that process requests and responses. The new feature you need to add is a middleware function that logs the execution time of each request. # Task: Implement a middleware function, `log_execution_time`, that logs the time taken to process each request. This function should integrate seamlessly with the existing middleware handling mechanism. # Requirements: 1. **Function Implementation:** - Create the `log_execution_time` function which takes a request handler as its argument and returns a new handler that logs the execution time. - Ensure that the middleware correctly wraps around the handler, logging the start and end times of the request processing. 2. **Logging:** - Use the `logging` module to log the execution time. The log should include the request path and the total time taken to handle the request. - Ensure logs are output at the INFO level. 3. **Integration:** - Integrate the new middleware function with the existing framework to demonstrate its functionality. **Input and Output formats:** - **Input:** A request handler to be wrapped by the middleware. - **Output:** Logs the execution time for each request handled by the server. **Constraints:** - The middleware should work with the framework\'s existing request handling mechanism. - Use the `time` module to capture the start and end times. # Example: ```python import logging import time # Example request handler def example_handler(request): # Simulate request processing time.sleep(0.5) return \\"Response\\" # Middleware function def log_execution_time(handler): def wrapper(request): start_time = time.time() response = handler(request) end_time = time.time() execution_time = end_time - start_time logging.info(f\\"Request to {request[\'path\']} took {execution_time:.6f} seconds\\") return response return wrapper # Enable logging at the INFO level logging.basicConfig(level=logging.INFO) # Wrap the example handler with the middleware wrapped_handler = log_execution_time(example_handler) # Simulate a request request = {\\"path\\": \\"/example\\"} response = wrapped_handler(request) # Expected log output: Request to /example took 0.500000 seconds ```","solution":"import logging import time # Example request handler def example_handler(request): # Simulate request processing time.sleep(0.5) return \\"Response\\" # Middleware function def log_execution_time(handler): def wrapper(request): start_time = time.time() response = handler(request) end_time = time.time() execution_time = end_time - start_time logging.info(f\\"Request to {request[\'path\']} took {execution_time:.6f} seconds\\") return response return wrapper # Enable logging at the INFO level logging.basicConfig(level=logging.INFO) # Integrate the middleware with an example handler wrapped_handler = log_execution_time(example_handler)"},{"question":"# Problem Statement You are given a dictionary representing a dependency graph in which keys are task names, and values are lists of prerequisite task names. Implement a function to determine the minimum number of semesters required to complete all tasks, given that you can take multiple tasks at once but must respect the dependency constraints. # Function Signature ```python def min_semesters(tasks: dict) -> int: This function computes the minimum number of semesters required to complete all tasks given their dependencies. Parameters: - tasks (dict): Dictionary where keys are task names and values are lists of prerequisite task names. Returns: - int: Minimum number of semesters required to complete all tasks. Returns -1 if there is a cyclic dependency. ``` # Input * `tasks`: Dictionary with task names as keys and lists of prerequisite task names as values. # Output * Integer representing the minimum number of semesters required to complete all tasks. Returns `-1` if a cycle exists in the graph. # Example ```python # Given tasks dependencies tasks = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [], \\"E\\": [\\"B\\"], } assert min_semesters(tasks) == 3 # Example breakdown: Semester 1: D, Semester 2: B, C, Semester 3: A, E assert min_semesters({\\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"]}) == -1 # Cycle exists ``` # Constraints & Limitations * Task names are strings. * The graph can be disconnected. * Handle cycles in the dependency graph. **Note**: Make sure to account for the following edge cases in your implementation: * Tasks with no dependencies. * Cyclic dependencies, where no valid completion order exists.","solution":"from collections import defaultdict, deque def min_semesters(tasks: dict) -> int: def topological_sort_with_levels(graph): in_degree = {node: 0 for node in graph} for node in graph: for neighbor in graph[node]: in_degree[neighbor] += 1 queue = deque([node for node in graph if in_degree[node] == 0]) levels = 0 count_of_processed_nodes = 0 while queue: next_level = deque() while queue: node = queue.popleft() count_of_processed_nodes += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: next_level.append(neighbor) queue = next_level levels += 1 if count_of_processed_nodes == len(graph): return levels return -1 return topological_sort_with_levels(tasks)"},{"question":"# Scenario You are part of a team developing a library management system. One of your tasks is to implement a feature that calculates book return penalties based on the return date and the due date. # Task Write a function to calculate the return penalty for a book in the library based on its due date, return date, and the penalty rate per day. # Function: `calculate_penalty` Input - due_date: A string `due_date` representing the due date in the format `YYYY-MM-DD`. - return_date: A string `return_date` representing the return date in the format `YYYY-MM-DD`. - daily_penalty: An integer `daily_penalty` representing the penalty rate per day in cents. Output - An integer representing the total penalty amount in cents. If the book is returned on or before the due date, the penalty is `0`. Example ```python assert calculate_penalty(\\"2023-10-01\\", \\"2023-10-05\\", 50) == 200 assert calculate_penalty(\\"2023-10-01\\", \\"2023-09-28\\", 50) == 0 assert calculate_penalty(\\"2023-10-01\\", \\"2023-10-01\\", 50) == 0 assert calculate_penalty(\\"2023-10-01\\", \\"2023-10-03\\", 100) == 200 ``` Constraints - The input date strings will always be valid and in the correct format. - The `daily_penalty` will be a non-negative integer. # Notes - Do not use any external libraries for date manipulations. - Ensure the function is optimized for clarity and efficiency. - Implement basic error handling for edge cases such as negative penalties, even though the constraints specify non-negative penalties.","solution":"def calculate_penalty(due_date, return_date, daily_penalty): Calculate the return penalty for a book based on its due date, return date, and the penalty rate per day. Parameters: due_date (str): Due date in the format YYYY-MM-DD. return_date (str): Return date in the format YYYY-MM-DD. daily_penalty (int): Penalty rate per day in cents. Returns: int: Total penalty amount in cents. If the book is returned on or before the due date, the penalty is 0. from datetime import datetime # Convert the string dates to datetime objects due_date_dt = datetime.strptime(due_date, \\"%Y-%m-%d\\") return_date_dt = datetime.strptime(return_date, \\"%Y-%m-%d\\") # Calculate the difference in days diff_days = (return_date_dt - due_date_dt).days # If the return date is on or before the due date, there is no penalty if diff_days <= 0: return 0 # Calculate the penalty total_penalty = diff_days * daily_penalty return total_penalty"},{"question":"**Graph Exploration and Analysis** You are tasked with implementing a series of graph exploration and analysis functions for an undirected, weighted graph. This problem requires you to complete the functions for depth-first search (DFS), breadth-first search (BFS), Dijkstra\'s shortest path algorithm, and connected components identification. **Objective:** Complete the missing implementation for the graph functions to ensure they work together to explore and analyze the structure and properties of the graph. **Requirements:** 1. **Depth-First Search (DFS)**: - Implement a recursive DFS function to traverse the graph and collect nodes in the order they are visited. - Function should work for both connected and disconnected graphs. 2. **Breadth-First Search (BFS)**: - Implement an iterative BFS function to traverse the graph and collect nodes in the order they are visited, starting from a given node. 3. **Dijkstra\'s Algorithm**: - Implement a function to find the shortest path from a given start node to all other nodes in the graph using Dijkstra’s algorithm. Return a dictionary of node-to-node shortest path distances. 4. **Connected Components**: - Implement a function that identifies and returns all connected components within the graph. - Each component should be represented as a list of nodes. **Function Signatures**: ```python from typing import Dict, List, Tuple import heapq def dfs(graph: Dict[int, List[Tuple[int, int]]], start: int) -> List[int]: # Implement DFS function pass def bfs(graph: Dict[int, List[Tuple[int, int]]], start: int) -> List[int]: # Implement BFS function pass def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: # Implement Dijkstra\'s algorithm pass def connected_components(graph: Dict[int, List[Tuple[int, int]]]) -> List[List[int]]: # Implement connected components identification pass ``` **Input and Output**: Input: 1. An undirected, weighted graph represented as a dictionary where keys are node identifiers and values are lists of tuples representing adjacent nodes and edge weights. 2. A starting node for traversal or shortest path calculations. Output: 1. For DFS and BFS: A list of nodes in the order they are visited. 2. For Dijkstra\'s algorithm: A dictionary where keys are nodes and values are the shortest path distances from the start node. 3. For connected components: A list of lists, each containing the nodes in a connected component. **Constraints**: - Nodes are represented by integers starting from 0. - Graph contains no negative weight edges. - The graph is undirected and connected. **Example**: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 8)], 3: [(1, 5), (2, 8)] } # Example function calls dfs_result = dfs(graph, 0) bfs_result = bfs(graph, 0) dijkstra_result = dijkstra(graph, 0) components = connected_components(graph) ``` Expected Outputs: ```python dfs_result: [0, 1, 2, 3] # Example order, actual order depends on traversal implementation bfs_result: [0, 1, 2, 3] # Example order, actual order depends on traversal implementation dijkstra_result: {0: 0, 1: 3, 2: 1, 3: 8} components: [[0, 1, 2, 3]] ```","solution":"from typing import Dict, List, Tuple import heapq def dfs(graph: Dict[int, List[Tuple[int, int]]], start: int) -> List[int]: visited = set() result = [] def recursive_dfs(node): if node not in visited: visited.add(node) result.append(node) for neighbor, _ in graph[node]: recursive_dfs(neighbor) recursive_dfs(start) return result def bfs(graph: Dict[int, List[Tuple[int, int]]], start: int) -> List[int]: visited = set() queue = [start] result = [] while queue: node = queue.pop(0) if node not in visited: visited.add(node) result.append(node) for neighbor, _ in graph[node]: if neighbor not in visited: queue.append(neighbor) return result def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: min_heap = [(0, start)] distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances def connected_components(graph: Dict[int, List[Tuple[int, int]]]) -> List[List[int]]: visited = set() components = [] def recursive_dfs(node, component): if node not in visited: visited.add(node) component.append(node) for neighbor, _ in graph[node]: recursive_dfs(neighbor, component) for node in graph: if node not in visited: component = [] recursive_dfs(node, component) components.append(component) return components"},{"question":"# Distance Between Closest Pairs You are required to implement a function that identifies the smallest distance between any two distinct elements in an unsorted list of integers, handling edge cases such as lists with fewer than two elements. # Task Write a function `min_distance_pairs(nums: List[int]) -> Union[int, None]` that finds the smallest distance (difference) between any two distinct elements in an integer list `nums`. If the list contains fewer than two elements, your function should return `None`. # Specifications - **Input**: A list of integers `nums`. - **Output**: The smallest distance between any two distinct elements in the list, or `None` if there are fewer than two elements. # Constraints 1. The list `nums` can contain identical elements. 2. If `nums` has fewer than two elements, return `None`. # Performance Requirements - The expected time complexity should be O(n log n), where n is the length of the list `nums`. # Example ```python >>> min_distance_pairs([3, 8, 15, 7, 9]) 1 >>> min_distance_pairs([1, 2, 3, 4, 5]) 1 >>> min_distance_pairs([10, 50, 90]) 40 >>> min_distance_pairs([5]) None >>> min_distance_pairs([]) None >>> min_distance_pairs([5, 5, 5]) 0 ``` # Implementation ```python from typing import List, Union def min_distance_pairs(nums: List[int]) -> Union[int, None]: if len(nums) < 2: return None # Not enough elements to form a pair nums.sort() # O(n log n) sorting operation min_distance = float(\'inf\') # Initialize with infinity for i in range(len(nums) - 1): distance = nums[i + 1] - nums[i] if distance < min_distance: min_distance = distance return min_distance if min_distance != float(\'inf\') else None ```","solution":"from typing import List, Union def min_distance_pairs(nums: List[int]) -> Union[int, None]: if len(nums) < 2: return None # Not enough elements to form a pair nums.sort() # O(n log n) sorting operation min_distance = float(\'inf\') # Initialize with infinity for i in range(len(nums) - 1): distance = nums[i + 1] - nums[i] if distance < min_distance: min_distance = distance return min_distance if min_distance != float(\'inf\') else None"},{"question":"# Problem: Handling Multiple Nested Dictionaries Background In many programming scenarios, data is often represented in nested dictionary structures. Efficient navigation and manipulation of deeply nested dictionaries are important skills for data processing and transformation. Objective You will implement a function `get_value` that retrieves the value from a nested dictionary given a list of keys, each representing a level within the nested structure. If the key path does not exist in the dictionary, the function should return a default value. Requirements 1. **Function**: - Implement the `get_value` function that accepts three parameters: the nested dictionary, a list of keys representing the path, and a default value to be returned if the key path does not exist. 2. **Functionality**: - Traverse the nested dictionary according to the given keys. - If at any point the key does not exist in the dictionary, return the default value. Function Signature ```python def get_value(nested_dict, keys, default): # Your implementation ``` Constraints - The `nested_dict` will always be a dictionary. - The `keys` list will contain strings that denote the key path. - The `default` can be any data type. Example ```python nested_dict = { \'a\': { \'b\': { \'c\': 42 } } } >>> get_value(nested_dict, [\'a\', \'b\', \'c\'], \'default\') 42 >>> get_value(nested_dict, [\'a\', \'b\', \'d\'], \'default\') \'default\' >>> get_value(nested_dict, [\'a\', \'b\'], \'default\') {\'c\': 42} ``` **Note**: The examples illustrate how to retrieve values at different depth levels and handle cases where the specified key path does not exist. **Hints**: 1. Iterate through the keys list using a loop. 2. Use dictionary\'s `get` method to ensure clean retrieval and handle missing keys.","solution":"def get_value(nested_dict, keys, default): Retrieve the value from a nested dictionary given a list of keys. Parameters: nested_dict (dict): The nested dictionary to traverse. keys (list): A list of keys representing the path. default: The default value to return if the key path does not exist. Returns: The value at the key path if it exists, otherwise the default value. current_level = nested_dict for key in keys: if isinstance(current_level, dict) and key in current_level: current_level = current_level[key] else: return default return current_level"},{"question":"# Problem Statement Imagine you are working on a simple data visualization tool. Your task is to implement a function that determines the bounding box for a set of 2D points. A bounding box is defined as the smallest rectangle (aligned with the coordinate axes) that can completely contain all given points. # Function Signature ```python def find_bounding_box(points: list) -> tuple: Compute the bounding box coordinates for a given set of 2D points. :param points: A list of tuples, where each tuple contains the (x, y) coordinates of a point. :return: A tuple with four float values representing the coordinates of the lower-left and upper-right corners of the bounding box (min_x, min_y, max_x, max_y). ``` # Input Format * `points` (list of tuple): A list where each element is a tuple holding the `x` and `y` coordinates of a point (float). # Output Format * A tuple with four float values representing the coordinates of the lower-left and upper-right corners of the bounding box (min_x, min_y, max_x, max_y). # Constraints * The list will contain at least one point. * The coordinates can be any float values. # Example ```python find_bounding_box([(1.0, 2.0), (3.0, 4.0), (-1.0, -2.0)]) # Expected output: (-1.0, -2.0, 3.0, 4.0) ``` # Additional Notes * Ensure that the function handles negative coordinates correctly. * You may assume there will be no duplicate points in the input list.","solution":"def find_bounding_box(points: list) -> tuple: Compute the bounding box coordinates for a given set of 2D points. :param points: A list of tuples, where each tuple contains the (x, y) coordinates of a point. :return: A tuple with four float values representing the coordinates of the lower-left and upper-right corners of the bounding box (min_x, min_y, max_x, max_y). min_x = min(point[0] for point in points) min_y = min(point[1] for point in points) max_x = max(point[0] for point in points) max_y = max(point[1] for point in points) return (min_x, min_y, max_x, max_y)"},{"question":"# Problem Statement In your software project, you need to implement functions that work with prime numbers. One of the required functionalities is to count the prime numbers up to a given integer `n` (inclusive). Your task is to write a function `count_primes` that takes: - `n` (a positive integer up to which we need to count the prime numbers) The function should return the count of prime numbers less than or equal to `n`. Input: - `n`: int (1 <= n <= 10^7) Output: - An integer representing the count of prime numbers less than or equal to `n`. Constraints: - The `n` should be a positive integer. - Efficiency considerations: Aim for a time complexity of approximately O(n log(log(n))) and space complexity of O(n). # Examples: 1. `count_primes(10)` should return `4` (Prime numbers less than or equal to 10 are 2, 3, 5, and 7). 2. `count_primes(20)` should return `8` (Prime numbers less than or equal to 20 are 2, 3, 5, 7, 11, 13, 17, 19). 3. `count_primes(1)` should return `0` (There are no prime numbers less than or equal to 1). 4. `count_primes(100)` should return `25` (There are 25 prime numbers less than or equal to 100). 5. `count_primes(30)` should return `10` (Prime numbers less than or equal to 30 are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29). # Notes: - Use an efficient algorithm such as the Sieve of Eratosthenes to ensure the function runs within the allowed time constraints. - A `TypeError` should be raised if `n` is not an integer. - A `ValueError` should be raised if `n` is less than 1.","solution":"def count_primes(n): Returns the count of prime numbers less than or equal to n. Parameters: n (int): The upper limit to count prime numbers. Returns: int: Count of prime numbers less than or equal to n. if not isinstance(n, int): raise TypeError(\\"The input must be an integer.\\") if n < 1: raise ValueError(\\"The input must be a positive integer.\\") if n == 1: return 0 # There are no primes less than or equal to 1. sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return sum(sieve)"},{"question":"# Problem Statement Design a class `WordDictionary` that supports adding new words and finding if a string matches any previously added string with the ability to handle wildcard characters. A wildcard character `.` can represent any one letter. # Requirements 1. Implement the class `WordDictionary` with the following methods: - `addWord(word: str) -> None`: Adds `word` to the dictionary. - `search(word: str) -> bool`: Returns `True` if `word` is in the dictionary (accounting for `.` wildcards), otherwise returns `False`. 2. The implementation should be efficient in terms of both time and space complexity. # Class Definition Complete the class `WordDictionary` adhering to the following definition: ```python class WordDictionary: def __init__(self): pass def addWord(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` # Input and Output * **Input**: - The `addWord` method receives a single argument `word` which is a string composed of lowercase English letters (a-z). - The `search` method receives a single argument `word` which is a string composed of lowercase English letters (a-z) and/or the character `.`. - There can be up to 50,000 calls to `addWord` and 50,000 calls to `search`. * **Output**: - The `addWord` method does not return any value. - The `search` method returns a boolean `True` or `False` depending on whether the word exists in the dictionary. # Constraints * `0 <= length of word <= 50` * `1 <= number of words <= 5 * 10^4` # Example ```python >>> wordDictionary = WordDictionary() >>> wordDictionary.addWord(\\"bad\\") >>> wordDictionary.addWord(\\"dad\\") >>> wordDictionary.addWord(\\"mad\\") >>> wordDictionary.search(\\"pad\\") False >>> wordDictionary.search(\\"bad\\") True >>> wordDictionary.search(\\".ad\\") True >>> wordDictionary.search(\\"b..\\") True ``` # Notes * Use appropriate data structures to optimize the addition and search of words, particularly considering the wildcard functionality. * The wildcard character `.` can match any single letter, ensuring flexible search capability within the dictionary.","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: from re import fullmatch for w in self.words: if fullmatch(word, w): return True return False"},{"question":"# Coding Assessment Question Objective Implement a function to apply a sepia tone to an image using the Pillow library. Your implementation should efficiently handle large images while preserving the overall visual quality. Task Write a function `apply_sepia(img: Image) -> Image:` which applies a sepia tone filter to a given image. Input and Output Format **Input**: - `img`: An instance of `PIL.Image`. **Output**: - The function should return an instance of `PIL.Image` with the sepia tone applied. Constraints - Ensure that the transformation adheres to the typical sepia tone formula. - Your solution should handle images of varying sizes and aspect ratios gracefully. Performance Requirements - The function should run efficiently, with a time complexity of O(n), where n is the number of pixels in the image. Example ```python from PIL import Image def apply_sepia(img: Image) -> Image: Function to apply sepia tone to an image. sepia_filter = [ (0.393, 0.769, 0.189), (0.349, 0.686, 0.168), (0.272, 0.534, 0.131) ] def sepia(pixel: tuple) -> tuple: r, g, b = pixel tr = int(sepia_filter[0][0] * r + sepia_filter[0][1] * g + sepia_filter[0][2] * b) tg = int(sepia_filter[1][0] * r + sepia_filter[1][1] * g + sepia_filter[1][2] * b) tb = int(sepia_filter[2][0] * r + sepia_filter[2][1] * g + sepia_filter[2][2] * b) # Ensure pixel values are within bounds return ( min(255, tr), min(255, tg), min(255, tb), ) # Apply sepia tone sepia_img = img.convert(\\"RGB\\").point(sepia) return sepia_img # Example usage: # Load image using PIL with Image.open(\\"path/to/your/image.jpg\\") as img: # Apply sepia tone sepia_img = apply_sepia(img) # Save the sepia-toned image sepia_img.save(\\"path/to/your/sepia_image.png\\", format=\\"png\\") ``` Scenario Imagine you are developing an image editing tool and one of the requested features is to apply a sepia tone to uploaded images. Your task is to implement the core sepia tone functionality that will be used in the application. Use the provided `apply_sepia` function template to complete this task.","solution":"from PIL import Image def apply_sepia(img: Image) -> Image: Function to apply sepia tone to an image. sepia_filter = [ (0.393, 0.769, 0.189), (0.349, 0.686, 0.168), (0.272, 0.534, 0.131) ] def sepia(pixel: tuple) -> tuple: r, g, b = pixel tr = int(sepia_filter[0][0] * r + sepia_filter[0][1] * g + sepia_filter[0][2] * b) tg = int(sepia_filter[1][0] * r + sepia_filter[1][1] * g + sepia_filter[1][2] * b) tb = int(sepia_filter[2][0] * r + sepia_filter[2][1] * g + sepia_filter[2][2] * b) # Ensure pixel values are within bounds return ( min(255, tr), min(255, tg), min(255, tb), ) # Apply sepia tone sepia_img = img.convert(\\"RGB\\") pixels = sepia_img.load() # Create the pixel map for i in range(sepia_img.width): for j in range(sepia_img.height): pixels[i, j] = sepia(pixels[i, j]) return sepia_img # Example usage (This part would not be part of the solution function): # Load image using PIL # with Image.open(\\"path/to/your/image.jpg\\") as img: # # Apply sepia tone # sepia_img = apply_sepia(img) # # Save the sepia-toned image # sepia_img.save(\\"path/to/your/sepia_image.png\\", format=\\"png\\")"},{"question":"New Question [Question 2]: # Remove Duplicates from Sorted Array Context Given a sorted array of integers, the task is to remove the duplicates in place such that each element appears only once and returns the new length of the array. Do not allocate extra space for another array; you must do this by modifying the input array in place with O(1) extra memory. Function Signature ```python def remove_duplicates(nums: list[int]) -> int: ``` Inputs - `nums`: A sorted list of integers where duplicates will be removed. Outputs - An integer representing the new length of the array after duplicates have been removed. Constraints - The input array `nums` is sorted in ascending order. - The function should modify the array in place. - The returned length must be used to truncate the array. Performance Requirements - The solution should operate in O(n) time complexity. Example ```python >>> nums = [1, 1, 2] >>> length = remove_duplicates(nums) >>> length 2 >>> nums[:length] [1, 2] >>> nums = [0,0,1,1,1,2,2,3,3,4] >>> length = remove_duplicates(nums) >>> length 5 >>> nums[:length] [0, 1, 2, 3, 4] ``` Instructions 1. Use two pointers: one to iterate over the array and another to keep track of the position of the next unique element. 2. Modify the array in place to place each unique element at the appropriate position. 3. Return the length of the array after removing duplicates. Edge Cases to Consider - The array is empty. - The array contains all unique elements (no duplicates). - The array contains all duplicates (all elements are the same). Note Use the provided function signature and ensure that the function modifies the array and returns the correct length for all provided test cases.","solution":"def remove_duplicates(nums: list[int]) -> int: Removes the duplicates in place in the sorted array such that each element appears only once. Returns the new length of the array without duplicates. Args: nums (list[int]): The sorted list of integers. Returns: int: The length of the array after removing duplicates. # Edge case: If the array is empty, return 0 if not nums: return 0 # Initialize the write pointer write_index = 1 # Iterate over the array starting from the second element for i in range(1, len(nums)): # If the current element is different from the previous unique element, update nums[write_index] if nums[i] != nums[write_index - 1]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"# Binary Search Tree (BST) Implementation **Scenario**: You are assigned the task to create a Binary Search Tree (BST) to help manage and organize hierarchical data efficiently. A BST is a data structure that keeps elements in a sorted order, which allows for fast lookup, addition, and deletion operations. **Task**: Implement a `BST` class in Python which contains methods for insertion, searching for an element, and finding the minimum value in the tree. Additionally, implement a method to check if the tree is a valid BST. **Function Signature**: ```python class BSTNode: def __init__(self, key: int) -> None: pass class BST: def __init__(self) -> None: pass def insert(self, key: int) -> None: pass def search(self, key: int) -> bool: pass def find_min(self) -> int: pass def is_valid_bst(self) -> bool: pass ``` # Constraints: 1. **Inputs**: - `key`: Integer, the value to be inserted or searched in the BST. 2. **Outputs**: - `insert`: Method to insert a key into the BST. - `search`: Method to return `True` if the key is present in the BST, `False` otherwise. - `find_min`: Method to return the minimum value present in the BST. - `is_valid_bst`: Method to return `True` if the BST is valid, `False` otherwise. **Example**: ```python # Example of BST operations: bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) # Search for existing and non-existing keys print(bst.search(10)) # Output: True print(bst.search(20)) # Output: False # Find minimum value print(bst.find_min()) # Output: 5 # Check if the tree is a valid BST print(bst.is_valid_bst()) # Output: True # Create an invalid BST scenario and check validity bst_invalid = BST() bst_invalid.root = BSTNode(10) bst_invalid.root.left = BSTNode(15) bst_invalid.root.right = BSTNode(5) print(bst_invalid.is_valid_bst()) # Output: False ``` # Performance Requirements: 1. All operations should be optimized to O(log N) time complexity on average. 2. Ensure that the tree structure remains balanced enough to avoid worst-case scenarios. # Additional Constraints: 1. Ensure that inserting duplicate keys does not alter the tree structure. 2. Handle edge cases such as inserting into empty BST and operations on an empty BST gracefully.","solution":"class BSTNode: def __init__(self, key: int) -> None: self.key = key self.left = None self.right = None class BST: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: def _insert(root, key): if root is None: return BSTNode(key) elif key < root.key: root.left = _insert(root.left, key) elif key > root.key: root.right = _insert(root.right, key) return root self.root = _insert(self.root, key) def search(self, key: int) -> bool: def _search(root, key): if root is None: return False elif root.key == key: return True elif key < root.key: return _search(root.left, key) else: return _search(root.right, key) return _search(self.root, key) def find_min(self) -> int: def _find_min(root): while root.left is not None: root = root.left return root.key if self.root is None: return None return _find_min(self.root) def is_valid_bst(self) -> bool: def _is_valid_bst(root, left, right): if root is None: return True if not (root.key > left and root.key < right): return False return (_is_valid_bst(root.left, left, root.key) and _is_valid_bst(root.right, root.key, right)) return _is_valid_bst(self.root, float(\'-inf\'), float(\'inf\'))"},{"question":"# Problem Statement As a software developer for a logistics company, you are tasked with creating a function that simulates delivery routes. Specifically, you need to create a system that finds the most efficient path between warehouse locations while accounting for road closures. You need to implement a function `shortest_path` that determines the shortest path between given start and end warehouses in a graph of warehouses connected by roads. Warehouses and roads are represented as a graph using an adjacency list, and you need to consider the weights representing the distances between warehouses. # Function Signature ```python from typing import Dict, List, Tuple def shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: ... ``` # Input * `graph` - A dictionary where: * Each key is a warehouse identifier (a string). * Each value is a list of tuples. Each tuple represents a road and contains: * A destination warehouse (a string). * A weight representing the distance to that warehouse (an integer >= 0). * `start` - A string representing the identifier of the starting warehouse. * `end` - A string representing the identifier of the ending warehouse. # Output * A list of strings representing the sequence of warehouse identifiers constituting the shortest path from the start warehouse to the end warehouse. # Constraints 1. If the start or end warehouse does not exist in the graph, raise a `ValueError` with the message `\\"Invalid start or end warehouse\\"`. 2. If there is no path between the start and end warehouses, return an empty list. # Examples ```python >>> graph = { ... \\"A\\": [(\\"B\\", 1), (\\"C\\", 4)], ... \\"B\\": [(\\"C\\", 2), (\\"D\\", 5)], ... \\"C\\": [(\\"D\\", 1)], ... \\"D\\": [] ... } >>> shortest_path(graph, \\"A\\", \\"D\\") [\'A\', \'B\', \'C\', \'D\'] >>> graph = { ... \\"A\\": [(\\"B\\", 2), (\\"C\\", 2)], ... \\"B\\": [(\\"D\\", 2)], ... \\"C\\": [(\\"D\\", 2)], ... \\"D\\": [] ... } >>> shortest_path(graph, \\"A\\", \\"D\\") [\'A\', \'B\', \'D\'] >>> graph = { ... \\"A\\": [(\\"B\\", 1)], ... \\"B\\": [(\\"C\\", 2)], ... \\"C\\": [], ... \\"D\\": [] ... } >>> shortest_path(graph, \\"A\\", \\"D\\") [] >>> shortest_path(graph, \\"X\\", \\"D\\") Traceback (most recent call last): ... ValueError: Invalid start or end warehouse ``` # Notes 1. Ensure the algorithm used to find the shortest path is efficient and handles cases where the start or end warehouse is isolated. 2. Thoroughly validate inputs to handle edge cases such as nonexistent warehouses or disconnected graphs. 3. Consider using Dijkstra\'s algorithm or another appropriate shortest path algorithm for this task.","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: # Check if the start and end warehouses exist in the graph if start not in graph or end not in graph: raise ValueError(\\"Invalid start or end warehouse\\") # Priority queue for Dijkstra\'s algorithm priority_queue = [(0, start, [])] # (distance, current_node, path) visited = set() while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) new_path = path + [current_node] if current_node == end: return new_path for neighbor, weight in graph.get(current_node, []): if neighbor not in visited: heapq.heappush(priority_queue, (current_distance + weight, neighbor, new_path)) # If there\'s no path to the end warehouse return []"},{"question":"# Binary Search Tree Operations Implementation Context You have been tasked to enhance and utilize a `BinarySearchTree` class to perform a series of fundamental operations. This question aims to test your understanding and ability to extend the functionalities of the binary search tree effectively. Problem Statement 1. **Insert**: Implement a method `insert(self, value: int)` that inserts a given value into the binary search tree while maintaining the properties of the tree. * **Input**: `value` is an integer to be inserted. * **Output**: Modify the tree in place. 2. **Lowest Common Ancestor (LCA)**: Implement a method `find_lca(self, n1: int, n2: int) -> Node` to find the lowest common ancestor of two given nodes in the binary search tree. * **Input**: `n1` and `n2` are integers representing the values of the nodes. * **Output**: Return the node that is the lowest common ancestor of `n1` and `n2`. If either node does not exist, return `None`. # Implementation Details * Implement the following two methods inside the `BinarySearchTree` class provided: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): # Your implementation here def find_lca(self, n1: int, n2: int) -> Node: # Your implementation here ``` # Example Usage ```python bst = BinarySearchTree() values = [20, 10, 30, 5, 15, 25, 35] for v in values: bst.insert(v) n1 = 5 n2 = 15 lca_node = bst.find_lca(n1, n2) print(lca_node.val) # Should print the value of the LCA node which is: 10 n1 = 5 n2 = 30 lca_node = bst.find_lca(n1, n2) print(lca_node.val) # Should print the value of the LCA node which is: 20 ``` * **Constraints**: - The insert method should maintain the properties of the binary search tree. - The `n1` and `n2` values will always be present in the tree whenever the `find_lca` method is called. * **Submission Requirements**: - The `insert` method should modify the tree in place and should not return anything. - The `find_lca` method should return a Node object if both nodes exist, otherwise `None`. Explain your approach after implementing the above methods briefly.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.val: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) elif value > node.val: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def find_lca(self, n1: int, n2: int) -> Node: return self._find_lca_recursive(self.root, n1, n2) def _find_lca_recursive(self, node, n1, n2): if node is None: return None if node.val > n1 and node.val > n2: return self._find_lca_recursive(node.left, n1, n2) if node.val < n1 and node.val < n2: return self._find_lca_recursive(node.right, n1, n2) return node"},{"question":"# Tournament Round Robin In a round-robin tournament, each participant plays every other participant exactly once. Given a list of participants, you need to create a schedule that pairs each participant against every other participant. Your task is to implement a function that generates a round-robin schedule given a list of participant names. The schedule should be in the format of a list of tuples, where each tuple contains two participant names that will compete against each other. Function Signature: ```python def generate_round_robin_schedule(participants: List[str]) -> List[Tuple[str, str]]: # Your code here ``` Requirements: 1. Implement the function `generate_round_robin_schedule(participants: List[str]) -> List[Tuple[str, str]]` that takes a list of participant names. 2. The function should return a list of tuples, where each tuple represents a match between two different participants. 3. Ensure that each participant plays every other participant exactly once. 4. Handle cases where the list of participants contains only one or two names appropriately. Constraints: - The length of the participants list will be between 2 and 1000 inclusive. - Participant names will be unique and non-empty strings. Input/Output Examples: ```python assert generate_round_robin_schedule([\\"A\\", \\"B\\", \\"C\\"]) == [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"C\\")] assert generate_round_robin_schedule([\\"X\\", \\"Y\\"]) == [(\\"X\\", \\"Y\\")] assert generate_round_robin_schedule([\\"Tom\\", \\"Jerry\\", \\"Spike\\", \\"Tyke\\"]) == [(\\"Tom\\", \\"Jerry\\"), (\\"Tom\\", \\"Spike\\"), (\\"Tom\\", \\"Tyke\\"), (\\"Jerry\\", \\"Spike\\"), (\\"Jerry\\", \\"Tyke\\"), (\\"Spike\\", \\"Tyke\\")] ``` Note: - The order of the matches in the output list doesn\'t matter as long as all participants compete against each other exactly once. - Assume the list of participant names will not be empty and contains valid strings.","solution":"from typing import List, Tuple def generate_round_robin_schedule(participants: List[str]) -> List[Tuple[str, str]]: Generates a round-robin schedule where each participant plays every other participant exactly once. :param participants: A list of participant names. :return: A list of tuples, each representing a match between two participants. schedule = [] n = len(participants) for i in range(n): for j in range(i + 1, n): schedule.append((participants[i], participants[j])) return schedule"},{"question":"# Problem Statement As part of a text processing module, you need to design a function that performs a specific type of word manipulation. Given a sentence, the function should reverse each word in the sentence individually while preserving the original word order and spaces. Your task is to write a function `reverse_words` that takes a single string argument `sentence` and returns a new string where each word in the original sentence has been reversed, but the word order and spaces remain unchanged. Input: - `sentence`: str (a string containing words separated by spaces, of length 1 <= len(sentence) <= 1000) Output: - A string with each word in `sentence` reversed while maintaining the original space placement. Constraints: - The input string will only contain printable ASCII characters and spaces. - Words are defined as sequences of non-space characters. - Efficiency considerations: Aim for a time complexity of O(n) and space complexity of O(n), where n is the length of the sentence. # Examples: 1. `reverse_words(\\"Hello World\\")` should return `\\"olleH dlroW\\"`. 2. `reverse_words(\\"The quick brown fox\\")` should return `\\"ehT kciuq nworb xof\\"`. 3. `reverse_words(\\"a b c\\")` should return `\\"a b c\\"`. 4. `reverse_words(\\"123 456 789\\")` should return `\\"321 654 987\\"`. 5. `reverse_words(\\" leading and trailing \\")` should return `\\" gnidael dna gniliart \\"`. # Notes: - Spaces between words should be preserved exactly as they appear in the input. - Consecutive spaces should not be reduced or expanded. - Trailing and leading spaces should be maintained in the output string.","solution":"def reverse_words(sentence): This function takes a sentence string as input and returns a new string where each word in the original sentence has been reversed, while the order of the words and spaces remain unchanged. Parameters: sentence (str): The input sentence to be processed. Returns: str: A new string with each word reversed. words = sentence.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question Context You are working for a company that builds software for dietary analysis. One required feature is to categorize foods based on their calorie counts and then generate a summary of categories as strings. Your task is to implement this feature. Task Write a Python function `categorize_foods` that performs the following operations: 1. Take a list of tuples as input, where each tuple contains the name of a food (a string) and its calorie count (an integer). 2. Categorize the foods into three categories: - \'Low\': Up to 200 calories - \'Medium\': 201 to 500 calories - \'High\': More than 500 calories 3. Return a dictionary summarizing the categories, where the keys are \'Low\', \'Medium\', and \'High\', and the values are comma-separated strings of food names in each category. Function Signature ```python def categorize_foods(foods: List[Tuple[str, int]]) -> Dict[str, str]: ``` Input * `foods` (a list of tuples): Each tuple consists of a food name (a string) and its calorie count (an integer). Output * A dictionary with keys \'Low\', \'Medium\', and \'High\', and values which are comma-separated strings of food names belonging to each category. Constraints 1. The calorie count will be a non-negative integer. 2. The list `foods` will contain up to `1000` food items. Example ```python # Example foods = [(\\"Apple\\", 95), (\\"Cheeseburger\\", 700), (\\"Salad\\", 150), (\\"Fries\\", 365)] print(categorize_foods(foods)) # Output: {\'Low\': \'Apple,Salad\', \'Medium\': \'Fries\', \'High\': \'Cheeseburger\'} foods = [(\\"Orange\\", 62), (\\"Chicken Breast\\", 165), (\\"Pasta\\", 220), (\\"Ice Cream\\", 290), (\\"Steak\\", 750)] print(categorize_foods(foods)) # Output: {\'Low\': \'Orange,Chicken Breast\', \'Medium\': \'Pasta,Ice Cream\', \'High\': \'Steak\'} ``` Notes * Ensure the returned dictionary has all three keys: \'Low\', \'Medium\', and \'High\', even if some categories may be empty. * The food names in the output string should preserve their order from the input list. * Handle any edge cases where the input list might be empty.","solution":"from typing import List, Tuple, Dict def categorize_foods(foods: List[Tuple[str, int]]) -> Dict[str, str]: categories = { \'Low\': [], \'Medium\': [], \'High\': [] } for food, calorie in foods: if calorie <= 200: categories[\'Low\'].append(food) elif 201 <= calorie <= 500: categories[\'Medium\'].append(food) else: categories[\'High\'].append(food) # Convert lists to comma-separated strings for key in categories: categories[key] = \',\'.join(categories[key]) return categories"},{"question":"# Problem Statement You are creating a simple URL shortening service like Bitly. Your task is to write a function that shortens a given URL and another function to retrieve the original URL from its shortened version. You will implement the following functions: ```python def shorten_url(original_url: str) -> str: Receives a long URL and returns a shortened version of it. The shortened URL should: - Be of the form \\"http://short.est/{hash}\\" - Use a hash function to create a unique identifier for each original URL. The hash function should be deterministic, meaning the same original URL should always produce the same shortened URL. Requirements: - Ensure the generated hash is unique for different URLs. - Handle cases where the original URL is already shortened. pass def retrieve_original_url(short_url: str) -> str: Receives a shortened URL and returns the original long URL. Requirements: - You should be able to retrieve the original URL from a valid shortened URL. - If the short URL is not valid or not found, return an appropriate error message. pass ``` # Input/Output Formats **Input**: A long URL (string) to be shortened in `shorten_url()` function and a shortened URL (string) in the `retrieve_original_url()` function. **Output**: - The `shorten_url()` function outputs the shortened URL in the format \\"http://short.est/{hash}\\". - The `retrieve_original_url()` function outputs the original URL or an error message if the URL is invalid. # Constraints - Assume the `original_url` will always be a valid URL and contain a scheme (e.g., \\"http\\", \\"https\\"). - Ensure thread safety when creating and accessing short URLs to avoid collisions in a concurrent environment. # Performance Requirements - The hash generation and retrieval should be efficient, with minimal time complexity. - Consider using a fixed-length hashing mechanism to ensure consistency and prevent excessively long short URLs. Example usage of the functions: ```python original = \\"https://www.example.com/some/very/long/url\\" shortened = shorten_url(original) print(shortened) # Example output: \\"http://short.est/a1b2c3d\\" retrieved = retrieve_original_url(shortened) print(retrieved) # Expected output: \\"https://www.example.com/some/very/long/url\\" ```","solution":"import hashlib url_mapping = {} def shorten_url(original_url: str) -> str: Receives a long URL and returns a shortened version of it. Uses a hash function to generate a unique shorter URL. # Check if URL is already shortened and return the original if found in the mapping if original_url in url_mapping.values(): for short, long in url_mapping.items(): if long == original_url: return short # Generate a hash for the original URL hash_object = hashlib.md5(original_url.encode()) short_hash = hash_object.hexdigest()[:8] # Using first 8 characters to ensure short length short_url = f\\"http://short.est/{short_hash}\\" url_mapping[short_url] = original_url return short_url def retrieve_original_url(short_url: str) -> str: Receives a shortened URL and returns the original long URL. if short_url in url_mapping: return url_mapping[short_url] else: return \\"Error: Shortened URL not found\\""},{"question":"# Question Context A software company is developing a graph visualization tool. They need a utility function to calculate the shortest path between two nodes in a given undirected graph. You are tasked with creating this utility function. Task Write a function `shortest_path` that computes the shortest path between two nodes in an undirected graph using Breadth-First Search (BFS). Function Signature ```python def shortest_path(graph: dict, start: int, end: int) -> list: ``` Input * `graph` (dict): An adjacency list representation of the graph where keys are node identifiers and values are lists of adjacent nodes. Nodes are represented by integers. * `start` (int): The starting node. * `end` (int): The destination node. Output * (list): A list representing the shortest path from the start node to the end node, inclusive. If no path exists, return an empty list. Example ```python >>> graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4] } >>> shortest_path(graph, 1, 5) [1, 2, 4, 5] >>> shortest_path(graph, 1, 1) [1] >>> shortest_path(graph, 2, 3) [2, 4, 3] ``` Constraints * The function should handle graphs with a large number of nodes and edges efficiently. * Assume node identifiers are positive integers and the graph is connected. * Implement the BFS algorithm iteratively to avoid recursion limits and stack overflow issues. Edge Cases * When the `start` node is the same as the `end` node, the output should be a list containing only the `start` node. * If there is no path between `start` and `end`, the function should return an empty list.","solution":"from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Compute the shortest path between two nodes in an undirected graph using BFS. :param graph: Adjacency list representation of the graph. :param start: The starting node. :param end: The destination node. :return: A list representing the shortest path from the start node to the end node, inclusive. If no path exists, return an empty list. if start == end: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node not in visited: neighbours = graph.get(node, []) for neighbour in neighbours: new_path = list(path) new_path.append(neighbour) queue.append(new_path) if neighbour == end: return new_path visited.add(node) return []"},{"question":"# Question: Implement Iterative and Recursive Sorting Algorithms You are tasked with implementing two versions of a sorting algorithm that can sort a list of integers. Specifically, write one version using an **iterative approach** and another version using a **recursive divide-and-conquer approach**. Function Signatures 1. `def iterative_sort(nums: list[int]) -> list[int]` 2. `def recursive_sort(nums: list[int]) -> list[int]` Requirements * The iterative function should use a simple iterative sorting algorithm (e.g., insertion sort, selection sort). * The recursive function should use the merge sort algorithm. * Both functions should return a sorted list in ascending order. * The functions should raise a `ValueError` if the input list is empty. Input * `nums`: A list of integers. Example: `[3, 1, 4, 1, 5, 9]` Output * Return a sorted list of integers in ascending order. Constraints * The list can be empty but must raise an error if so. * Elements are integers within a reasonable range and size for sorting. Examples ```python # Iterative Examples assert iterative_sort([3, 1, 4, 1, 5, 9]) == [1, 1, 3, 4, 5, 9] assert iterative_sort([-3, -1, -4, -1, -5, -9]) == [-9, -5, -4, -3, -1, -1] assert iterative_sort([2, -3, 4, 0, 5, 3]) == [-3, 0, 2, 3, 4, 5] try: iterative_sort([]) except ValueError: pass # This is expected # Recursive Examples assert recursive_sort([3, 1, 4, 1, 5, 9]) == [1, 1, 3, 4, 5, 9] assert recursive_sort([-3, -1, -4, -1, -5, -9]) == [-9, -5, -4, -3, -1, -1] assert recursive_sort([2, -3, 4, 0, 5, 3]) == [-3, 0, 2, 3, 4, 5] try: recursive_sort([]) except ValueError: pass # This is expected ``` Constraints & Limitations * Performance should be O(n^2) for the iterative sort and O(n log n) for the recursive sort. * Space complexity should respect the nature of the iterative or recursive approach. * Ensure that your implementations handle edge cases correctly; provide sufficient test cases in your submission.","solution":"def iterative_sort(nums): Sort a list of integers using the iterative insertion sort algorithm. Raise ValueError if the input list is empty. if not nums: raise ValueError(\\"Input list is empty\\") # Insertion Sort for i in range(1, len(nums)): key = nums[i] j = i - 1 while j >= 0 and key < nums[j]: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = key return nums def recursive_sort(nums): Sort a list of integers using the recursive merge sort algorithm. Raise ValueError if the input list is empty. if not nums: raise ValueError(\\"Input list is empty\\") if len(nums) <= 1: return nums # Merge Sort def merge(left, right): sorted_list = [] while left and right: if left[0] <= right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left) sorted_list.extend(right) return sorted_list mid = len(nums) // 2 left_half = recursive_sort(nums[:mid]) right_half = recursive_sort(nums[mid:]) return merge(left_half, right_half)"},{"question":"# Coding Assessment Question Context You are tasked with designing a small application that collects weather data from an online weather service and writes it to a CSV file for further analysis. Task Create a function `fetch_and_write_weather_data(city: str, days: int) -> None` which: 1. Fetches weather data for the specified city and number of days from the OpenWeatherMap API. 2. Writes the collected data into a CSV file named `weather_data_<city>.csv`, with each row representing the weather data for one day. Requirements 1. Implement the function `fetch_and_write_weather_data(city: str, days: int) -> None`. 2. The function should not return any value. 3. The CSV file should have the following columns: Date, Min Temperature, Max Temperature, and Weather Description. 4. Handle API limit of requests and any network errors gracefully. Input and Output * **Input**: A string `city` representing the name of the city, and an integer `days` specifying the number of days of weather data to fetch. * **Output**: None (all results should be saved in a CSV file named `weather_data_<city>.csv`). Constraints * The function should fetch data for a maximum of 7 days due to API limitations. * Assume the API key is provided and valid within the script as a constant variable. * Handle common network and API errors gracefully to ensure the function does not crash unexpectedly. * Use the `requests` library for HTTP requests and `csv` module to write the CSV file. Example: ```python >>> fetch_and_write_weather_data(\\"New York\\", 5) ``` This might create a file named `weather_data_New_York.csv` with contents such as: ```csv Date,Min Temperature,Max Temperature,Weather Description 2023-07-01,20.5,29.0,Clear Sky 2023-07-02,21.0,30.0,Few Clouds 2023-07-03,19.0,28.0,Rain 2023-07-04,18.0,25.0,Thunderstorm 2023-07-05,20.0,27.0,Clear Sky ```","solution":"import requests import csv import os from datetime import datetime API_KEY = \'your_api_key\' # Replace \'your_api_key\' with your OpenWeatherMap API key def fetch_and_write_weather_data(city: str, days: int) -> None: url = f\\"http://api.openweathermap.org/data/2.5/forecast/daily?q={city}&cnt={days}&appid={API_KEY}&units=metric\\" try: response = requests.get(url) response.raise_for_status() data = response.json() weather_data = [] for day in data[\'list\']: date = datetime.utcfromtimestamp(day[\'dt\']).strftime(\'%Y-%m-%d\') min_temp = day[\'temp\'][\'min\'] max_temp = day[\'temp\'][\'max\'] description = day[\'weather\'][0][\'description\'] weather_data.append([date, min_temp, max_temp, description]) csv_filename = f\\"weather_data_{city}.csv\\" with open(csv_filename, mode=\'w\', newline=\'\') as file: writer = csv.writer(file) writer.writerow([\\"Date\\", \\"Min Temperature\\", \\"Max Temperature\\", \\"Weather Description\\"]) writer.writerows(weather_data) except requests.exceptions.RequestException as e: print(f\\"An error occurred while fetching weather data: {e}\\")"},{"question":"# Question Create a function that takes in a list of integers and returns a new list containing all the elements of the original list that are powers of 2. Provide both an iterative and a recursive version of the function. Function Signature ```python def filter_powers_of_2_iterative(lst: List[int]) -> List[int]: def filter_powers_of_2_recursive(lst: List[int]) -> List[int]: ``` Requirements: 1. **Function 1**: `filter_powers_of_2_iterative(lst: List[int]) -> List[int]` - Use iteration to process each element in the list. - Return a new list with elements that are powers of 2. 2. **Function 2**: `filter_powers_of_2_recursive(lst: List[int]) -> List[int]` - Use recursion to process the list. - Return a new list with elements that are powers of 2. - Handle empty lists as base cases in recursion. Input - `lst`: List of integers. The list can have zero or more integers. Output - Returns a list of integers from the original list that are powers of 2. If there are no powers of 2, return an empty list. Constraints - Elements in `lst` should be within the range -10⁵ to 10⁵. - The list can contain duplicate values, which should be preserved in the output if they are powers of 2. - Performance should be considered for very large lists up to the length of 10⁶. Example ```python >>> filter_powers_of_2_iterative([1, 2, 3, 4, 5, 8, 16, 32, 64, 100]) [1, 2, 4, 8, 16, 32, 64] ``` ```python >>> filter_powers_of_2_recursive([1, 7, 15, 16, 32, 64, 128, 9]) [1, 16, 32, 64, 128] ``` Scenario Implement the solution while considering corner cases such as a list with no powers of 2, negative numbers, and very large lists. Make sure the calculations for checking powers of 2 are efficient.","solution":"from typing import List def is_power_of_2(n: int) -> bool: Checks if a number is a power of 2. return n > 0 and (n & (n - 1)) == 0 def filter_powers_of_2_iterative(lst: List[int]) -> List[int]: Filters the given list to return only the elements that are powers of 2. Iterative implementation. return [x for x in lst if is_power_of_2(x)] def filter_powers_of_2_recursive(lst: List[int]) -> List[int]: Filters the given list to return only the elements that are powers of 2. Recursive implementation. if not lst: return [] head = lst[0] if is_power_of_2(head): return [head] + filter_powers_of_2_recursive(lst[1:]) else: return filter_powers_of_2_recursive(lst[1:])"},{"question":"# Task Implement a function `find_central_element` that identifies and returns the central element(s) of a list. If the list has an odd number of elements, return the single central element. If the list has an even number of elements, return the two central elements. # Scenarios Your function will be used by data analysts to quickly find the median value(s) in numerically or alphabetically ordered data sets. # Input - A list `data` containing either integers or strings, which is assumed to be sorted in non-decreasing order. # Output - If the input list has an odd number of elements, return the central element (as a single value). - If the input list has an even number of elements, return a tuple containing the two central elements. # Constraints 1. The list will contain at least one element. 2. The list will be sorted in ascending order. # Requirements - Preserve the original list input. - Do not use additional sorting algorithms. # Example ```python def find_central_element(data: list) -> int or tuple[int, int]: # Your implementation here pass # Example Test Cases: print(find_central_element([1, 2, 3, 4, 5])) # Expected output: 3 print(find_central_element([10, 20, 30, 40, 50, 60])) # Expected output: (30, 40) print(find_central_element([\'a\', \'b\', \'c\', \'d\', \'e\'])) # Expected output: \'c\' print(find_central_element([\'alpha\', \'beta\', \'gamma\'])) # Expected output: \'beta\' print(find_central_element([7])) # Expected output: 7 print(find_central_element([5, 10])) # Expected output: (5, 10) ```","solution":"def find_central_element(data): Returns the central element(s) of a sorted list. If the list has an odd number of elements, return the single central element. If the list has an even number of elements, return the two central elements as a tuple. n = len(data) mid = n // 2 if n % 2 == 1: return data[mid] else: return (data[mid - 1], data[mid])"},{"question":"# Prime Number Checker and Counter Scenario Prime numbers are numbers greater than 1 that have no divisors other than 1 and themselves. You are asked to implement a function that not only checks if a given number is prime but also counts the number of prime numbers less than the given number. Task Write a function `prime_check_and_count(n: int) -> Tuple[bool, int]` that: - Returns a tuple where: - The first element is `True` if `n` is a prime number, otherwise `False`. - The second element is the count of prime numbers less than `n`. Input Format - A single integer `n`. Output Format - Returns a tuple `(is_prime, prime_count)` where `is_prime` is a boolean indicating if `n` is prime, and `prime_count` is the count of prime numbers less than `n`. Constraints - `1 <= n <= 10^6` Examples ```python >>> prime_check_and_count(10) (False, 4) >>> prime_check_and_count(29) (True, 9) >>> prime_check_and_count(2) (True, 0) >>> prime_check_and_count(1) (False, 0) ``` Use this function signature and provide a solution that correctly performs both tasks of checking prime status and counting primes under the given constraints.","solution":"from typing import Tuple def prime_check_and_count(n: int) -> Tuple[bool, int]: if n <= 1: return (False, 0) primes = [True] * n primes[0] = primes[1] = False prime_count = 0 for start in range(2, n): if primes[start]: prime_count += 1 for i in range(start * start, n, start): primes[i] = False is_prime = all(n % i != 0 for i in range(2, int(n**0.5) + 1)) if n > 1 else False return (is_prime, prime_count)"},{"question":"# Group Anagrams - Hash Map Challenge **Context**: You are given a list of strings, and you need to group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. **Function to Implement**: ```python def group_anagrams(strs: list[str]) -> list[list[str]]: pass ``` **Input**: - `strs` (list of strs): A list of strings. **Output**: - Returns a list of lists, with each inner list containing strings that are anagrams of each other. **Constraints**: - Input list length: 0 <= len(strs) <= 10^4 - Length of each string: 1 <= len(strs[i]) <= 100 - All strings consist of lowercase English letters. **Performance Requirements**: - The solution should efficiently handle large inputs, ideally with a time complexity of O(n * k log k), where n is the number of strings and k is the length of the longest string. **Examples**: ```python assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] assert group_anagrams([\\"\\"]) == [[\\"\\"]] assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] assert group_anagrams([]) == [] assert group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"]) == [[\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"]] ``` **Hint**: - Consider using a dictionary to map sorted versions of words to a list of their anagrams. For example, after sorting, both \\"eat\\" and \\"tea\\" become \\"aet\\", which can be used as a dictionary key.","solution":"def group_anagrams(strs): Groups strings into anagrams. Args: - strs (list of str): List of strings to be grouped. Returns: - list of list of str: List of groups of anagrams. from collections import defaultdict anagrams = defaultdict(list) for s in strs: # Sort the string and use it as a key sorted_str = \'\'.join(sorted(s)) anagrams[sorted_str].append(s) return list(anagrams.values())"},{"question":"# Event Scheduling System You are required to implement an event scheduling system. The goal is to manage a list of events, ensure no conflicts between events, and provide the ability to query the schedule. Part 1: Implement Event Management Implement the `EventScheduler` class with the following methods: 1. `__init__(self)`: Initialize the scheduler with an empty list of events. 2. `add_event(self, start_time: int, end_time: int, event_name: str) -> bool`: Add a new event if it does not conflict with existing events. Return `True` if the event was added, otherwise return `False`. 3. `remove_event(self, event_name: str) -> bool`: Remove an event by its name. Return `True` if the event was removed, otherwise return `False`. 4. `get_events(self) -> list[tuple[int, int, str]]`: Return the list of all events sorted by their start time. Part 2: Implement event conflict checker Extend the class to include a method to find conflicts: 1. `check_conflict(self, start_time: int, end_time: int) -> bool`: Check if adding an event with given start and end times would conflict with existing events. Return `True` if there is a conflict, otherwise return `False`. # Input and Output Formats Input * `start_time`, `end_time`: Integer values representing the start and end times of an event. * `event_name`: A unique string identifier for each event. Output * `add_event(start_time, end_time, event_name)`: `True` if the event was successfully added, `False` otherwise. * `remove_event(event_name)`: `True` if the event was successfully removed, `False` otherwise. * `get_events()`: A list of tuples, each containing the start time, end time, and name of the event, sorted by start time. * `check_conflict(start_time, end_time)`: `True` if there’s a scheduling conflict, `False` otherwise. # Constraints 1. Events timings are represented by integer values between 0 and 10000. 2. No two events can overlap in time. 3. The `event_name` is a unique identifier for events. # Examples ```python scheduler = EventScheduler() scheduler.add_event(1, 3, \\"Meeting\\") scheduler.add_event(4, 6, \\"Workshop\\") scheduler.add_event(8, 10, \\"Conference\\") print(scheduler.get_events()) # Expected output: [(1, 3, \'Meeting\'), (4, 6, \'Workshop\'), (8, 10, \'Conference\')] scheduler.add_event(3, 5, \\"Training\\") # Expected output: False (training overlaps with workshop) print(scheduler.check_conflict(2, 5)) # Expected output: True (conflict with meeting and workshop) scheduler.remove_event(\\"Workshop\\") print(scheduler.get_events()) # Expected output: [(1, 3, \'Meeting\'), (8, 10, \'Conference\')] print(scheduler.check_conflict(2, 3)) # Expected output: True (conflict with meeting) ``` # Notes * Ensure that the `add_event` method validates the event timing and prevents overlapping events. * Utilize efficient algorithms to handle the scheduling and conflict checking. * Validate your implementation using both common and edge cases.","solution":"class EventScheduler: def __init__(self): self.events = [] def add_event(self, start_time: int, end_time: int, event_name: str) -> bool: if self.check_conflict(start_time, end_time): return False self.events.append((start_time, end_time, event_name)) self.events.sort(key=lambda x: x[0]) # Sort events by start_time return True def remove_event(self, event_name: str) -> bool: for event in self.events: if event[2] == event_name: self.events.remove(event) return True return False def get_events(self) -> list: return self.events def check_conflict(self, start_time: int, end_time: int) -> bool: if start_time >= end_time: return True # Invalid event timing for event in self.events: if not (end_time <= event[0] or start_time >= event[1]): return True return False"},{"question":"# File Path Normalization Context: File paths can be represented in various formats, sometimes including redundant components like `.` or `..` (representing the current directory and parent directory, respectively). It\'s crucial to resolve these to simplify the paths for consistent file handling in operating systems. Task: Write a function `normalize_path(path: str) -> str` that normalizes the given file path by resolving all `.` and `..` components. Specifications: 1. A `.` represents the current directory and can be removed. 2. A `..` represents the parent directory, and you should navigate up one directory level. 3. Consecutive slashes `//` should be replaced with a single slash `/`. 4. The path should not have a trailing slash unless it is the root directory `/`. 5. The function should handle both absolute paths (starting with `/`) and relative paths. Input: - A single string `path`, representing the file path to be normalized. Output: - Return the normalized path as a string. Constraints: - The input path length should not exceed 1024 characters. - The input path will only consist of printable ASCII characters. - The function should consider empty paths and paths containing only slashes as invalid and return an empty string. Example: ```python assert normalize_path(\\"/a//b/c/../d\\") == \\"/a/b/d\\" assert normalize_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert normalize_path(\\"a/b/c/./../../d\\") == \\"a/d\\" assert normalize_path(\\"/../\\") == \\"/\\" assert normalize_path(\\"/home/user/../user2/./docs/\\") == \\"/home/user2/docs\\" assert normalize_path(\\"\\") == \\"\\" assert normalize_path(\\"////\\") == \\"\\" ``` Notes: - Ensure to handle invalid and edge cases appropriately, returning an empty string for invalid paths. - Handle both absolute (`/`) and relative paths correctly. ```python def normalize_path(path: str) -> str: Returns the normalized path by resolving \'.\' and \'..\' components. if not path: return \\"\\" parts = [] for part in path.split(\'/\'): if part == \'\' or part == \'.\': continue if part == \'..\': if parts and parts[-1] != \'..\': parts.pop() elif not parts and path.startswith(\'/\'): # If starts with \'/\', \'..\' at the beginning should not move past root continue else: parts.append(\'..\') else: parts.append(part) normalized_path = \'/\' + \'/\'.join(parts) if path.startswith(\'/\') else \'/\'.join(parts) return normalized_path # Example Test Cases print(normalize_path(\\"/a//b/c/../d\\")) # Output: /a/b/d print(normalize_path(\\"/a/./b/../../c/\\")) # Output: /c print(normalize_path(\\"a/b/c/./../../d\\")) # Output: a/d print(normalize_path(\\"/../\\")) # Output: / print(normalize_path(\\"/home/user/../user2/./docs/\\")) # Output: /home/user2/docs print(normalize_path(\\"\\")) # Output: \\"\\" print(normalize_path(\\"////\\")) # Output: \\"\\" ```","solution":"def normalize_path(path: str) -> str: Returns the normalized path by resolving \'.\' and \'..\' components. if not path or path == \\"////\\": return \\"\\" parts = [] for part in path.split(\'/\'): if part == \'\' or part == \'.\': continue if part == \'..\': if parts and parts[-1] != \'..\': parts.pop() elif not parts and path.startswith(\'/\'): # If starts with \'/\', \'..\' at the beginning should not move past root continue else: parts.append(\'..\') else: parts.append(part) normalized_path = \'/\' + \'/\'.join(parts) if path.startswith(\'/\') else \'/\'.join(parts) return normalized_path or \'/\'"},{"question":"New Question Creation # Problem Statement You are given a file that contains several lines, each with a sequence of characters. Your task is to find and return the longest substring that appears in at least two different lines. If there are multiple substrings with the same maximum length, return the one that appears first lexicographically. # Specific Requirements 1. **Input**: - A file named \\"lines.txt\\" containing multiple lines of characters. 2. **Output**: - A string representing the longest substring found in at least two different lines. - If no such substring exists, return an empty string. # Example Consider the following lines in \\"lines.txt\\": ``` abcpqr xyzpqr mnopqr ``` The longest substring that appears in at least two different lines is \\"pqr\\". # Constraints - The file will contain only lowercase English letters. - The file can be large (up to 10K in content size). - Each line in the file will contain at most 500 characters. # Function Implementation You are required to implement the function `find_longest_common_substring(file_path: str) -> str` that reads the lines from the given file path and returns the longest common substring found in at least two different lines. # Additional Guidance Ensure to handle edge cases such as: - The file containing lines with no common substrings. - Proper handling of lines that are completely different. # Example Implementation ```python def find_longest_common_substring(file_path: str) -> str: def find_common_substrings(str1, str2): Helper function to find all common substrings between two strings. len1, len2 = len(str1), len(str2) common_substrings = set() for i in range(len1): for j in range(i + 1, len1 + 1): substr = str1[i:j] if substr in str2: common_substrings.add(substr) return common_substrings with open(file_path) as in_file: lines = [line.strip() for line in in_file] longest_substring = \\"\\" for i in range(len(lines)): for j in range(i + 1, len(lines)): common_substrings = find_common_substrings(lines[i], lines[j]) for substr in common_substrings: if (len(substr) > len(longest_substring) or (len(substr) == len(longest_substring) and substr < longest_substring)): longest_substring = substr return longest_substring if __name__ == \\"__main__\\": file_path = \\"path/to/lines.txt\\" print(find_longest_common_substring(file_path)) ```","solution":"def find_longest_common_substring(file_path: str) -> str: def find_common_substrings(str1, str2): Helper function to find all common substrings between two strings. len1, len2 = len(str1), len(str2) common_substrings = set() for i in range(len1): for j in range(i + 1, len1 + 1): substr = str1[i:j] if substr in str2: common_substrings.add(substr) return common_substrings with open(file_path) as in_file: lines = [line.strip() for line in in_file] longest_substring = \\"\\" for i in range(len(lines)): for j in range(i + 1, len(lines)): common_substrings = find_common_substrings(lines[i], lines[j]) for substr in common_substrings: if (len(substr) > len(longest_substring) or (len(substr) == len(longest_substring) and substr < longest_substring)): longest_substring = substr return longest_substring"},{"question":"# Scenario You have recently joined a tech company where your first task is to contribute to an internal tool that processes text files. Your task is to implement several text processing functions that will be frequently used by other team members. These functions include counting word frequencies, finding unique words, and extracting specific patterns from the text. # Task Implement the following text processing functions as specified: 1. `word_count(text)`: Returns a dictionary where keys are words and values are their respective counts in the given text. 2. `unique_words(text)`: Returns a set of unique words from the given text. 3. `find_pattern(text, pattern)`: Finds all occurrences of a given pattern in the text and returns them as a list. The pattern is defined using regular expressions. 4. `replace_words(text, target, replacement)`: Replaces every occurrence of the target word with the replacement word in the text. # Specifications - **Input**: - `word_count`, `unique_words`, `find_pattern`, `replace_words`: A single string `text`. - Additionally, `find_pattern`: A string `pattern` representing the regular expression pattern to search for. - Additionally, `replace_words`: Two strings `target` and `replacement` representing the word to be replaced and its replacement, respectively. - **Output**: - `word_count`: A dictionary with words as keys and their counts as values. - `unique_words`: A set of unique words in the text. - `find_pattern`: A list of strings matching the given pattern. - `replace_words`: A string with all occurrences of the target word replaced by the replacement word. # Example Implementations ```python import re def word_count(text): # Implement word frequency count logic pass def unique_words(text): # Implement unique words extraction logic pass def find_pattern(text, pattern): # Implement pattern finding logic using regular expressions pass def replace_words(text, target, replacement): # Implement word replacement logic pass ``` # Constraints - Ensure the functions handle text input robustly, including edge cases like empty strings or non-standard characters. - For `word_count` and `unique_words`, consider case-insensitivity (i.e., \\"Word\\" and \\"word\\" should be treated as identical). - The `find_pattern` function should utilize Python\'s `re` library for regular expression matching. - For `replace_words`, ensure that only whole words are replaced (i.e., \\"targeted\\" should not replace part of the word \\"target\\"). # Performance Requirements - The functions should perform efficiently, even for relatively long text inputs (e.g., text files with thousands of lines). - Strive for linear time complexity where practical, particularly for `word_count` and `unique_words`. # Example Usage ```python text = \\"Hello world! Hello everyone. Welcome to the world of Python.\\" print(word_count(text)) # {\'hello\': 2, \'world\': 2, \'everyone\': 1, \'welcome\': 1, \'to\': 1, \'the\': 1, \'of\': 1, \'python\': 1} print(unique_words(text)) # {\'hello\', \'world\', \'everyone\', \'welcome\', \'to\', \'the\', \'of\', \'python\'} print(find_pattern(text, r\'bworldb\')) # [\'world\', \'world\'] print(replace_words(text, \'world\', \'universe\')) # \\"Hello universe! Hello everyone. Welcome to the universe of Python.\\" ``` Feel free to implement and test variations to ensure the functions meet specifications and performance requirements.","solution":"import re from collections import Counter def word_count(text): words = re.findall(r\'bw+b\', text.lower()) return Counter(words) def unique_words(text): words = re.findall(r\'bw+b\', text.lower()) return set(words) def find_pattern(text, pattern): return re.findall(pattern, text) def replace_words(text, target, replacement): pattern = r\'b\' + re.escape(target) + r\'b\' return re.sub(pattern, replacement, text)"},{"question":"# Balanced String Checker Background A string is considered balanced if it consists of two different characters occurring the same number of times. For example, the string \\"aabb\\" is balanced because it has 2 \'a\' characters and 2 \'b\' characters. Task Write a function `is_balanced(s: str) -> bool` that checks if a given string `s` is balanced. The string consists of only lowercase English letters. Input * A string `s` with length between 1 and 1000, inclusive. Output * A boolean value: `True` if the string is balanced, `False` otherwise. Constraints * The string will only contain lowercase letters (\'a\' to \'z\'). * The string will contain exactly two distinct characters. Performance Requirements * Your solution should handle the string length efficiently. Example ```python assert is_balanced(\'aabb\') == True assert is_balanced(\'ababab\') == True assert is_balanced(\'aab\') == False assert is_balanced(\'aabbcc\') == False assert is_balanced(\'xxyy\') == True assert is_balanced(\'ab\') == True assert is_balanced(\'aaaabb\') == False ``` Notes * Ensure your solution correctly identifies whether the string contains exactly two types of characters and if they appear an equal number of times. * Consider edge cases where the string lengths vary from minimal to maximal limits specified.","solution":"def is_balanced(s: str) -> bool: Checks if the given string is balanced. A string is considered balanced if it consists of exactly two different characters occurring the same number of times. # Create a dictionary to count occurrences of each character freq = {} # Count frequencies of each character for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # Check if there are exactly two distinct characters if len(freq) != 2: return False # Get the frequencies of the two characters counts = list(freq.values()) # Check if the frequencies are the same return counts[0] == counts[1]"},{"question":"# Coding Challenge: Interleaving Strings Problem Statement Given three strings `s1`, `s2`, and `s3`, determine if `s3` is formed by an interleaving of `s1` and `s2`. An interleaving of `s1` and `s2` is a string constructed from all the characters of `s1` and `s2` such that the characters are taken in the same order as they appear in `s1` and `s2`, but they can be mixed with each other. Functional Requirements: Write a function `is_interleave(s1: str, s2: str, s3: str) -> bool` that: - Returns a boolean indicating whether `s3` is formed by an interleaving of `s1` and `s2`. # Input: - `s1`: A string of length m (0 <= m <= 100). - `s2`: A string of length n (0 <= n <= 100). - `s3`: A string of length m + n. # Output: - Returns `True` if `s3` is an interleaving of `s1` and `s2`. - Returns `False` otherwise. # Constraints: - All strings consist of lowercase English letters (`a`-`z`). Example: ```python assert is_interleave(\\"aabcc\\", \\"dbbca\\", \\"aadbbcbcac\\") == True assert is_interleave(\\"aabcc\\", \\"dbbca\\", \\"aadbbbaccc\\") == False assert is_interleave(\\"\\", \\"\\", \\"\\") == True ``` Guidelines: - Use a dynamic programming approach to solve the interleaving problem efficiently. - Consider using a 2D table where `dp[i][j]` indicates whether the substring `s3[:i+j]` is an interleaving of `s1[:i]` and `s2[:j]`. - Initialize the first row and column based on the comparison between the subsequences of `s1`, `s2` with `s3`. - Populate the table by checking conditions where the current character of `s3` matches with the current character of either `s1` or `s2`. Example Explanation: - In the first example, `s3` can be formed by interleaving `s1` and `s2` as follows: - a (from `s1`) | a (from `s1`) | d (from `s2`) | b (from `s2`) | b (from `s1`) | c (from `s1`) | b (from `s2`) | c (from `s2`) | a (from `s1`) | c (from `s1`). - In the second example, `s3` cannot be formed by interleaving `s1` and `s2` as it fails to maintain the order of characters from `s1` and `s2`. By solving this problem, you will practice string manipulation techniques, dynamic programming, and understanding sequence interleaving.","solution":"def is_interleave(s1: str, s2: str, s3: str) -> bool: Determines if s3 is formed by an interleaving of s1 and s2. m, n = len(s1), len(s2) if m + n != len(s3): return False dp = [[False] * (n+1) for _ in range(m+1)] dp[0][0] = True for i in range(1, m+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in range(1, n+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in range(1, m+1): for j in range(1, n+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1]) return dp[m][n]"},{"question":"# Coding Assessment Question **Problem Context**: You are developing a system that processes strings and requires a frequency analysis of characters. Your task is to implement two functions: one using a dictionary and another using sorting to determine the frequency of each character in a given string. **Task**: Implement two functions, `character_frequency_dict(s: str) -> dict` and `character_frequency_sorted(s: str) -> dict`, that compute the frequency of each character in a string using a dictionary approach and a sorting approach, respectively. The functions should ignore spaces and consider character case (i.e., \'A\' and \'a\' should be treated as different characters). **Function Signature**: ```python def character_frequency_dict(s: str) -> dict: pass def character_frequency_sorted(s: str) -> dict: pass ``` **Constraints**: 1. Both functions should return the same result for any given string. 2. Only alphanumeric characters should be counted. 3. Ignore spaces in the input string. 4. Optimize for both time and space where possible. **Input Format**: - A string containing alphanumeric characters and spaces. **Output Format**: - A dictionary with characters as keys and their frequencies as values. **Example**: ``` >>> character_frequency_dict(\\"Hello World\\") {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'W\': 1, \'r\': 1, \'d\': 1} >>> character_frequency_sorted(\\"Hello World\\") {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'W\': 1, \'r\': 1, \'d\': 1} >>> character_frequency_dict(\\"A quick brown fox\\") {\'A\': 1, \'q\': 1, \'u\': 1, \'i\': 1, \'c\': 1, \'k\': 1, \'b\': 1, \'r\': 1, \'o\': 2, \'w\': 1, \'n\': 1, \'f\': 1, \'x\': 1} >>> character_frequency_sorted(\\"A quick brown fox\\") {\'A\': 1, \'q\': 1, \'u\': 1, \'i\': 1, \'c\': 1, \'k\': 1, \'b\': 1, \'r\': 1, \'o\': 2, \'w\': 1, \'n\': 1, \'f\': 1, \'x\': 1} ``` **Additional Task**: - Create a `main` function that prompts user input, calls both frequency functions, and ensures that the outputs match. Handle empty strings and other edge cases appropriately. **Performance Requirements**: - The dictionary-based function should operate in O(n) time complexity, where n is the length of the string. - The sorting-based function should operate in O(n log n) time complexity, where n is the length of the string. **Edge Cases**: - An empty string should return an empty dictionary. - Provide meaningful output if the string contains non-alphanumeric characters (e.g., punctuation). Example Usage: ``` >>> main() Enter a string: Output for character_frequency_dict: {} Output for character_frequency_sorted: {} ```","solution":"def character_frequency_dict(s: str) -> dict: Computes the frequency of each character in a string using a dictionary approach. Only considers alphanumeric characters and ignores spaces. freq = {} for char in s: if char.isalnum(): if char in freq: freq[char] += 1 else: freq[char] = 1 return freq def character_frequency_sorted(s: str) -> dict: Computes the frequency of each character in a string using a sorting approach. Only considers alphanumeric characters and ignores spaces. filtered_chars = [char for char in s if char.isalnum()] filtered_chars.sort() if not filtered_chars: return {} freq = {} current_char = filtered_chars[0] count = 0 for char in filtered_chars: if char == current_char: count += 1 else: freq[current_char] = count current_char = char count = 1 freq[current_char] = count return freq"},{"question":"# Coding Assessment: Implementing K-Means Clustering **Objective**: Implement the K-Means clustering algorithm to cluster a set of instances. You will develop the necessary functions to fit the K-Means model, predict cluster assignments for new data, and evaluate the clustering quality. # Problem Statement Given a set of observations, implement the K-Means algorithm to group the observations into a specified number of clusters. Perform clustering on the given dataset, predict clusters for new data points, and measure the clustering performance using the silhouette score. # Scenario A data analyst wants to use K-Means clustering to segment customers into distinct groups based on their purchasing behavior. They have historical data on customer purchases. Your role is to implement the clustering model, predict the cluster of new customers based on their purchasing features, and evaluate the quality of the clustering. # Requirements 1. **Function to Fit K-Means Model**: * Input: * `features` (2D list of feature values), * `k` (integer, number of clusters), * `max_iter` (integer, maximum number of iterations). * Output: Dictionary containing cluster centroids and cluster assignments for each point. 2. **Function to Predict Cluster for New Instances**: * Input: `unknown_features` (2D list of feature values of unknown instances), `model` (Fitted model dictionary from step 1). * Output: List of predicted clusters for the unknown instances. 3. **Function to Calculate Silhouette Score**: * Input: * `features` (2D list of feature values), * `labels` (list of cluster assignments for the instances). * Output: Silhouette score (float) indicating the quality of the clustering. # Input and Output Format **Function 1: fit_kmeans_model** ```python def fit_kmeans_model(features: list[list[float]], k: int, max_iter: int) -> dict: pass ``` **Function 2: predict_clusters** ```python def predict_clusters(unknown_features: list[list[float]], model: dict) -> list[int]: pass ``` **Function 3: calculate_silhouette_score** ```python def calculate_silhouette_score(features: list[list[float]], labels: list[int]) -> float: pass ``` # Constraints * The number of features (columns) should be greater than 0. * The number of clusters `k` should be less than the number of data points. * The silhouette score should be calculated correctly for the provided labels and features. # Example ```python # Example data features = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.2, 1.9], [6.0, 7.0], [7.0, 7.5], ] k = 2 max_iter = 100 # Fit the K-Means model model = fit_kmeans_model(features, k, max_iter) # New instances unknown_features = [ [2.0, 3.0], [6.5, 7.8], ] # Predict using the model predicted_clusters = predict_clusters(unknown_features, model) print(predicted_clusters) # Expected output: [0, 1] # Calculate silhouette score labels = model[\'assignments\'] silhouette = calculate_silhouette_score(features, labels) print(silhouette) # Expected output: Score representing the clustering quality ``` * **Edge Cases**: * Handle cases where there are insufficient data points to form `k` clusters. * Ensure the algorithm works when data points are equidistant to multiple centroids. # Submission Complete the missing functions to fit the K-Means model, predict cluster assignments for new instances, and calculate the silhouette score for evaluating the clustering quality. Ensure your solution works well with provided examples and handles edge cases effectively.","solution":"import random from math import sqrt def fit_kmeans_model(features: list[list[float]], k: int, max_iter: int) -> dict: Fits K-Means model to the input features # Initializing centroids randomly from the features centroids = random.sample(features, k) for _ in range(max_iter): # Assigning clusters assignments = [] for feature in features: distances = [euclidean_distance(feature, centroid) for centroid in centroids] cluster = distances.index(min(distances)) assignments.append(cluster) # Updating centroids new_centroids = [] for cluster in range(k): cluster_points = [features[i] for i in range(len(features)) if assignments[i] == cluster] centroid = [sum(coord)/len(coord) for coord in zip(*cluster_points)] new_centroids.append(centroid) if cluster_points else new_centroids.append(random.choice(features)) if new_centroids == centroids: break else: centroids = new_centroids return {\'centroids\': centroids, \'assignments\': assignments} def euclidean_distance(point1: list[float], point2: list[float]) -> float: return sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def predict_clusters(unknown_features: list[list[float]], model: dict) -> list[int]: Predicts clusters for new data points based on trained K-Means model centroids = model[\'centroids\'] predictions = [] for feature in unknown_features: distances = [euclidean_distance(feature, centroid) for centroid in centroids] cluster = distances.index(min(distances)) predictions.append(cluster) return predictions def calculate_silhouette_score(features: list[list[float]], labels: list[int]) -> float: Calculates silhouette score for the clustering from sklearn.metrics import silhouette_score return silhouette_score(features, labels)"},{"question":"# Triple Sum Calculation Write a function that takes a list of integers and a target integer. The function should determine if there are three distinct elements in the list that sum up to the target value. If such a combination exists, return a list containing the three integers. If there are multiple such combinations, return any one of them. If no such combination exists, return an empty list. # Function Specifications **Method**: `find_three_sum` ```python def find_three_sum(nums: List[int], target: int) -> List[int]: pass ``` * **Description**: Determines if there are three distinct integers in the list that sum to the target value. * **Input**: * `nums` (List[int]): A list of integers. * `target` (int): The target sum. * **Output**: A list with three integers that sum to the target value, or an empty list if no such combination exists. * **Constraints**: * The input list will contain no more than 10,000 integers. * Each integer in the list is in the range of -10,000 to 10,000. * The input list may contain duplicate elements. # Example Usage ```python # Example 1 nums = [1, 2, 3, 4, 5, 6, 7] target = 12 print(find_three_sum(nums, target)) # Expected: [1, 4, 7] or any other valid triplet # Example 2 nums = [-1, 0, 1, 2, -1, -4] target = 0 print(find_three_sum(nums, target)) # Expected: [-1, -1, 2] or any other valid triplet # Example 3 nums = [1, 1, 1, 1] target = 3 print(find_three_sum(nums, target)) # Expected: [] (no such triplet exists) ``` # Note - You may return any valid triplet if multiple solutions exist. - The solution should handle both positive and negative integers. - The solution should avoid returning duplicate triplets.","solution":"from typing import List def find_three_sum(nums: List[int], target: int) -> List[int]: nums.sort() n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: s = nums[i] + nums[left] + nums[right] if s == target: return [nums[i], nums[left], nums[right]] elif s < target: left += 1 else: right -= 1 return []"},{"question":"# Coding Challenge: User Activity Analyzer Your task is to create a Python function that analyzes user activity on a social media platform. The function should aggregate activities from two sources: user_posts and user_comments. The output should provide an overview of the user\'s engagement metrics, including total posts, total comments, and average comments per post. Function Signature ```python def analyze_user_activity(user_id: int, start_date: str, end_date: str) -> dict: Analyze user activity from posts and comments between the specified dates. Args: user_id (int): The ID of the user whose activity is being analyzed. start_date (str): The start date for the analysis period (format YYYY-MM-DD). end_date (str): The end date for the analysis period (format YYYY-MM-DD). Returns: dict: Aggregated activity data including total posts, total comments, and average comments per post. ``` # Instructions 1. **Data Retrieval**: - Fetch user posts and comments for the given `user_id` between `start_date` and `end_date` from provided user_posts and user_comments functions. - Assume these functions return lists of dictionaries with post and comment data (e.g., `user_posts(user_id, start_date, end_date)` and `user_comments(user_id, start_date, end_date)`). 2. **Aggregation**: - Count the total number of posts and comments by the user within the specified date range. - Calculate the average number of comments per post. 3. **Output Format**: - Return a dictionary with keys: `total_posts`, `total_comments`, and `average_comments_per_post`. 4. **Error Handling**: - Ensure your function can handle scenarios where the user has no posts or comments in the specified date range. - Raise appropriate errors for invalid date formats or user_id values. 5. **Edge Cases**: - Handle cases where start_date is after end_date. - Ensure that when there are no posts but comments exist, the average comments per post is handled correctly (e.g., return 0). 6. **Testing**: - Write tests to cover different scenarios, including users with no activity, users with posts but no comments, and users with both posts and comments. # Example Data Assume we have the following mock data functions: ```python def user_posts(user_id, start_date, end_date): # Mock data for demonstration purposes return [ {\\"post_id\\": 1, \\"date\\": \\"2023-09-15\\"}, {\\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, ] def user_comments(user_id, start_date, end_date): # Mock data for demonstration purposes return [ {\\"comment_id\\": 1, \\"post_id\\": 1, \\"date\\": \\"2023-09-15\\"}, {\\"comment_id\\": 2, \\"post_id\\": 1, \\"date\\": \\"2023-09-15\\"}, {\\"comment_id\\": 3, \\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, {\\"comment_id\\": 4, \\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, {\\"comment_id\\": 5, \\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, ] ``` # Example Usage ```python >>> analyze_user_activity(123, \\"2023-09-01\\", \\"2023-09-30\\") { \\"total_posts\\": 2, \\"total_comments\\": 5, \\"average_comments_per_post\\": 2.5 } ``` # Constraints - Use the given user_posts and user_comments functions for fetching data. - Ensure proper date format validation (YYYY-MM-DD). - `user_id` is assumed to be an integer. Ensure your function handles the specified requirements and runs efficiently. ```python from datetime import datetime def analyze_user_activity(user_id: int, start_date: str, end_date: str) -> dict: def validate_date(date_str): try: return datetime.strptime(date_str, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Incorrect date format, should be YYYY-MM-DD\\") # Validate date formats start = validate_date(start_date) end = validate_date(end_date) if start > end: raise ValueError(\\"start_date should be before or equal to end_date\\") posts = user_posts(user_id, start_date, end_date) comments = user_comments(user_id, start_date, end_date) total_posts = len(posts) total_comments = len([comment for comment in comments if comment[\\"post_id\\"] in [post[\\"post_id\\"] for post in posts]]) average_comments_per_post = total_comments / total_posts if total_posts else 0 return { \\"total_posts\\": total_posts, \\"total_comments\\": total_comments, \\"average_comments_per_post\\": average_comments_per_post } if __name__ == \\"__main__\\": from pprint import pprint user_id = int(input(\\"Enter a user ID: \\").strip()) start_date = input(\\"Enter a start date (YYYY-MM-DD): \\").strip() end_date = input(\\"Enter an end date (YYYY-MM-DD): \\").strip() try: activity_data = analyze_user_activity(user_id, start_date, end_date) pprint(activity_data) except Exception as e: print(f\\"Error: {e}\\") ```","solution":"from datetime import datetime # Assuming these functions are given for fetching data def user_posts(user_id, start_date, end_date): # Mock data for demonstration purposes return [ {\\"post_id\\": 1, \\"date\\": \\"2023-09-15\\"}, {\\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, ] def user_comments(user_id, start_date, end_date): # Mock data for demonstration purposes return [ {\\"comment_id\\": 1, \\"post_id\\": 1, \\"date\\": \\"2023-09-15\\"}, {\\"comment_id\\": 2, \\"post_id\\": 1, \\"date\\": \\"2023-09-15\\"}, {\\"comment_id\\": 3, \\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, {\\"comment_id\\": 4, \\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, {\\"comment_id\\": 5, \\"post_id\\": 2, \\"date\\": \\"2023-09-18\\"}, ] def analyze_user_activity(user_id: int, start_date: str, end_date: str) -> dict: def validate_date(date_str): try: return datetime.strptime(date_str, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Incorrect date format, should be YYYY-MM-DD\\") # Validate date formats start = validate_date(start_date) end = validate_date(end_date) if start > end: raise ValueError(\\"start_date should be before or equal to end_date\\") posts = user_posts(user_id, start_date, end_date) comments = user_comments(user_id, start_date, end_date) total_posts = len(posts) post_ids = {post[\\"post_id\\"] for post in posts} total_comments = len([comment for comment in comments if comment[\\"post_id\\"] in post_ids]) average_comments_per_post = total_comments / total_posts if total_posts else 0 return { \\"total_posts\\": total_posts, \\"total_comments\\": total_comments, \\"average_comments_per_post\\": average_comments_per_post }"},{"question":"# String Pattern Matching Context In text processing and computer science, string pattern matching is an essential concept where you need to check if a pattern exists within a given text. One common approach to this problem is using the **Knuth-Morris-Pratt (KMP) algorithm**, which allows for efficient searching of the pattern. Your task is to implement the core functionality that checks whether a given pattern exists within a given text using the KMP algorithm. Problem Statement You will write a function `kmp_pattern_search` which internally uses the KMP algorithm to find the first occurrence of a given pattern in a given text. Input * `text`: A string where the pattern is to be searched. * `pattern`: A string pattern that needs to be searched within the text. Output * An integer representing the starting index of the first occurrence of the pattern in the text, or -1 if the pattern is not found. Constraints 1. The length of the text can be up to (10^5) characters. 2. The length of the pattern can be up to (10^4) characters. 3. Both text and pattern consist of only lowercase English letters. Example Usage ```python text = \\"hellotherehellotherehello\\" pattern = \\"there\\" assert kmp_pattern_search(text, pattern) == 5 text = \\"abrakadabra\\" pattern = \\"kada\\" assert kmp_pattern_search(text, pattern) == 4 text = \\"aaaaaaa\\" pattern = \\"ba\\" assert kmp_pattern_search(text, pattern) == -1 ``` Function Signature ```python def kmp_pattern_search(text: str, pattern: str) -> int: pass ``` Notes You should implement the `kmp_pattern_search` function, which utilizes the Knuth-Morris-Pratt algorithm. This involves creating a \\"partial match\\" table (also known as the \\"failure function\\") to keep track of the longest proper prefix which is also a suffix for sub-patterns. The task focuses on ensuring efficient pattern matching in terms of time complexity.","solution":"def kmp_pattern_search(text: str, pattern: str) -> int: def compute_lps_array(pattern): lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps M = len(pattern) N = len(text) lps = compute_lps_array(pattern) i = 0 # index for text j = 0 # index for pattern while i < N: if pattern[j] == text[i]: i += 1 j += 1 if j == M: return i - j elif i < N and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Question on File Reader and Text Data Analysis Context File reading and data processing are fundamental tasks in software development. This exercise focuses on reading text files and performing basic text analysis. Task Implement a function that reads multiple text files, processes the content, and performs text analysis by computing word frequency. Function Requirements 1. **Function Signature**: ```python def analyze_text_files(file_paths: list) -> dict: ``` 2. **Parameters**: * `file_paths` (list): A list of paths to the text files. 3. **Return Value**: * `word_freq` (dict): A dictionary where keys are words, and values are the frequency of those words across all files. Constraints * The `file_paths` list will be non-empty. * Only consider alphabetic words (ignore numbers, punctuation, and special characters). * Words should be treated case-insensitively (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). * The text files may be large, containing thousands of lines. Performance Requirements Your solution should be efficient in terms of both time and space complexity, capable of processing large text files in a reasonable time. Example Consider two text files with the following content: File `file1.txt`: ``` Hello world! This is a test file. ``` File `file2.txt`: ``` This file contains test data. Hello again! ``` ```python file_paths = [\\"file1.txt\\", \\"file2.txt\\"] word_freq = analyze_text_files(file_paths) # word_freq should be: # { # \'hello\': 2, # \'world\': 1, # \'this\': 2, # \'is\': 1, # \'a\': 1, # \'test\': 2, # \'file\': 2, # \'contains\': 1, # \'data\': 1, # \'again\': 1 # } ``` Submit your implementation of the `analyze_text_files` function below:","solution":"import os import re from collections import defaultdict def analyze_text_files(file_paths: list) -> dict: word_freq = defaultdict(int) for file_path in file_paths: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = re.findall(r\'b[a-zA-Z]+b\', line.lower()) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"# Temperature Data Analysis You are provided with a CSV file `temperature_data.csv`, which contains temperature readings from various cities over multiple days. The file structure has the following columns: - `city`: Name of the city - `date`: Date of the temperature recording in \\"YYYY-MM-DD\\" format - `temperature`: Temperature recorded on that date, in degrees Celsius # Instructions 1. Read the CSV file and parse the data. 2. For each city, determine the maximum temperature recorded. 3. Create a dictionary where the key is the city name and the value is the maximum temperature recorded in that city. 4. Find the city with the highest maximum temperature and the city with the lowest maximum temperature. # Example Given the following data in `temperature_data.csv`: ``` city,date,temperature New York,2022-01-01,5 New York,2022-01-02,7 Los Angeles,2022-01-01,21 Los Angeles,2022-01-02,19 Chicago,2022-01-01,-3 Chicago,2022-01-02,1 ``` The resulting dictionary should be: ``` { \\"New York\\": 7, \\"Los Angeles\\": 21, \\"Chicago\\": 1 } ``` Given this dictionary, the city with the highest maximum temperature is \\"Los Angeles\\" with 21 degrees, and the city with the lowest maximum temperature is \\"Chicago\\" with -3 degrees. # Objective Write a Python function `analyze_temperature_data` that reads the `temperature_data.csv` file, determines the maximum temperatures for each city, and identifies the cities with the highest and lowest maximum temperatures. ```python import csv from typing import Dict, Tuple def analyze_temperature_data(file_path: str) -> Tuple[Dict[str, float], Tuple[str, float], Tuple[str, float]]: Analyzes the temperature data in the given CSV file. :param file_path: Path to the CSV file containing temperature data. :return: A tuple containing: 1. A dictionary with city names as keys and their maximum temperatures as values. 2. A tuple with the city having the highest maximum temperature and its temperature. 3. A tuple with the city having the lowest maximum temperature and its temperature. # Your implementation goes here. pass # Example usage: # city_max_temps, highest_temp_city, lowest_temp_city = analyze_temperature_data(\\"path_to_your_temperature_data.csv\\") # print(city_max_temps) # Expected output should match the dictionary as described above # print(highest_temp_city) # Expected: (\'Los Angeles\', 21) # print(lowest_temp_city) # Expected: (\'Chicago\', -3) ``` # Constraints 1. The function should handle large files efficiently. 2. Assume the file is correctly formatted as per the given structure. 3. Temperature readings are valid floating point or integer numbers.","solution":"import csv from typing import Dict, Tuple def analyze_temperature_data(file_path: str) -> Tuple[Dict[str, float], Tuple[str, float], Tuple[str, float]]: Analyzes the temperature data in the given CSV file. :param file_path: Path to the CSV file containing temperature data. :return: A tuple containing: 1. A dictionary with city names as keys and their maximum temperatures as values. 2. A tuple with the city having the highest maximum temperature and its temperature. 3. A tuple with the city having the lowest maximum temperature and its temperature. city_max_temps = {} with open(file_path, \'r\') as file: reader = csv.DictReader(file) for row in reader: city = row[\'city\'] temperature = float(row[\'temperature\']) if city in city_max_temps: if temperature > city_max_temps[city]: city_max_temps[city] = temperature else: city_max_temps[city] = temperature highest_temp_city = max(city_max_temps.items(), key=lambda x: x[1]) lowest_temp_city = min(city_max_temps.items(), key=lambda x: x[1]) return city_max_temps, highest_temp_city, lowest_temp_city"},{"question":"Question You are tasked with finding the longest subsequence of unique characters in a given string. Specifically, you will: 1. Iterate through the string to identify the longest contiguous subsequence where no characters repeat. 2. Return the length of this subsequence. # Function Signature ```python def longest_unique_subsequence(s: str) -> int: Find the length of the longest subsequence with unique characters. ``` # Input - `s` (str): A string composed of ASCII characters. # Output - Returns an integer representing the length of the longest subsequence with unique characters. # Example ```python longest_unique_subsequence(\\"abcabcbb\\") # Expected Output: 3 (\\"abc\\" is the longest unique subsequence) longest_unique_subsequence(\\"bbbbb\\") # Expected Output: 1 (\\"b\\" is the only unique subsequence) longest_unique_subsequence(\\"pwwkew\\") # Expected Output: 3 (\\"wke\\" is the longest unique subsequence) ``` # Constraints * The input string `s` can have a length of up to 10,000 characters. * All characters in the string `s` are printable ASCII characters. # Scenario Imagine you are developing a text editing software that highlights the longest sequence of non-repeating characters. This feature helps in identifying patterns and analyzing text data efficiently.","solution":"def longest_unique_subsequence(s: str) -> int: Find the length of the longest subsequence with unique characters. last_seen = {} start = 0 longest = 0 for i, char in enumerate(s): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"# Prime Number Identifier and Counter You are given a list of integers and tasked with identifying which numbers are prime and counting the total number of prime numbers in the list. Objective Create a function that processes a list of integers to: 1. Identify which numbers are prime. 2. Count and return the total number of prime numbers in the list. Requirements 1. **Function Implementation**: - Write a function `identify_and_count_primes(numbers: List[int]) -> Tuple[List[int], int]` that: - Identifies all prime numbers in the provided list. - Returns a tuple containing a list of identified prime numbers and the total count of prime numbers. 2. **Prime Number Definition**: - A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. - The list can include negative numbers, zero, and one, but they are not considered prime. 3. **Input and Output**: - **Input**: A list of integers (`numbers`). - **Output**: A tuple where the first element is a list of prime numbers and the second element is the count of prime numbers. 4. **Constraints**: - The function should handle lists containing up to 10^5 integers efficiently. - The function should check each number to determine its primality within a time-efficient manner. 5. **Performance Requirements**: Aim for time complexity of O(n * sqrt(m)), where n is the length of the list and m is the maximum number in the list. Example Here is a sample function definition: ```python from typing import List, Tuple import math def identify_and_count_primes(numbers: List[int]) -> Tuple[List[int], int]: Identify the prime numbers in the list and count their total number. >>> identify_and_count_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) ([2, 3, 5, 7], 4) >>> identify_and_count_primes([0, 1, -1, -10, 11, 13, 17, 22]) ([11, 13, 17], 3) >>> identify_and_count_primes([15, 23, 39, 41, 51]) ([23, 41], 2) def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True prime_numbers = [num for num in numbers if is_prime(num)] return prime_numbers, len(prime_numbers) ``` Task Implement the function `identify_and_count_primes` based on the specifications provided. Ensure all test cases pass successfully and validate performance through large input sets.","solution":"from typing import List, Tuple def identify_and_count_primes(numbers: List[int]) -> Tuple[List[int], int]: Identify the prime numbers in the list and count their total number. Params: - numbers (List[int]): A list of integers Returns: - Tuple[List[int], int]: A tuple where the first element is a list of identified prime numbers and the second element is the count of prime numbers. def is_prime(n: int) -> bool: # For negative numbers, 0 and 1, return False since they are not prime if n <= 1: return False # 2 and 3 are prime numbers if n <= 3: return True # Exclude multiples of 2 and 3 if n % 2 == 0 or n % 3 == 0: return False # Check divisors from 5 to sqrt(n) with a step of 6 i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True prime_numbers = [num for num in numbers if is_prime(num)] return prime_numbers, len(prime_numbers)"},{"question":"# Problem Statement Context You are tasked with implementing a function to generate a Fibonacci-like sequence where each term is the sum of the two previous terms, but with a twist: the starting terms and the offset can be arbitrary values. Function Signature ```python def custom_fibonacci(n: int, start1: int, start2: int, offset: int) -> list[int]: ``` Input 1. `n (int)`: The number of terms to generate in the sequence. 2. `start1 (int)`: The first term of the sequence. 3. `start2 (int)`: The second term of the sequence. 4. `offset (int)`: An integer added to each term after the initial two terms. Output * Returns a `list[int]` of length `n` representing the generated sequence. If `n` is not a positive integer, return an empty list. Constraints * The function should handle any integer inputs for `start1`, `start2`, and `offset`. * Ensure that the sequence stops if `n` is zero or negative. Examples ```python >>> custom_fibonacci(5, 1, 1, 0) [1, 1, 2, 3, 5] >>> custom_fibonacci(5, 2, 3, 1) [2, 3, 6, 10, 17] >>> custom_fibonacci(0, 1, 1, 2) [] >>> custom_fibonacci(3, 5, 8, -1) [5, 8, 12] >>> custom_fibonacci(6, -1, -1, 2) [-1, -1, 0, 1, 3, 6] ``` Additional Requirements: 1. If `n` is less than 1, the function should return an empty list. 2. Make sure the function efficiently computes each term without unnecessary recalculations. ```python def custom_fibonacci(n: int, start1: int, start2: int, offset: int) -> list[int]: if n <= 0: return [] if n == 1: return [start1] if n == 2: return [start1, start2] result = [start1, start2] for _ in range(2, n): next_term = result[-1] + result[-2] + offset result.append(next_term) return result ```","solution":"def custom_fibonacci(n: int, start1: int, start2: int, offset: int) -> list[int]: if n <= 0: return [] if n == 1: return [start1] if n == 2: return [start1, start2] result = [start1, start2] for _ in range(2, n): next_term = result[-1] + result[-2] + offset result.append(next_term) return result"},{"question":"# Managing a Recurring Task Scheduler You are working on a project management tool that helps users schedule and manage recurring tasks. Your task is to implement two functions, `add_task` and `next_occurrence`, to manage and query the schedule of these tasks. # Task 1. **add_task(name: str, start_date: str, recurrence_pattern: str) -> None** - Input: - `name`: A `str` representing the name of the task. - `start_date`: A `str` in the format \\"YYYY-MM-DD\\" representing the starting date of the task. - `recurrence_pattern`: A `str` that could be one of \\"DAILY\\", \\"WEEKLY\\", \\"MONTHLY\\", or \\"YEARLY\\". - Output: `None` - Constraints: - The function should store the task details in a globally accessible list or dictionary. 2. **next_occurrence(name: str, current_date: str) -> str** - Input: - `name`: A `str` representing the name of the task. - `current_date`: A `str` in the format \\"YYYY-MM-DD\\" representing the current date. - Output: A `str` in the format \\"YYYY-MM-DD\\" indicating the next occurrence of the task. - Constraints: - The function should return the next occurrence date based on the `current_date` and the task\'s `recurrence_pattern`. - If the task does not exist, return an error message like \\"Task not found\\". # Example Usage ```python >>> add_task(\\"Backup\\", \\"2023-01-01\\", \\"DAILY\\") >>> next_occurrence(\\"Backup\\", \\"2023-01-01\\") \'2023-01-02\' >>> add_task(\\"Team Meeting\\", \\"2023-01-01\\", \\"WEEKLY\\") >>> next_occurrence(\\"Team Meeting\\", \\"2023-01-07\\") \'2023-01-08\' >>> add_task(\\"Monthly Report\\", \\"2023-01-01\\", \\"MONTHLY\\") >>> next_occurrence(\\"Monthly Report\\", \\"2023-01-01\\") \'2023-02-01\' >>> add_task(\\"Annual Review\\", \\"2023-01-01\\", \\"YEARLY\\") >>> next_occurrence(\\"Annual Review\\", \\"2023-01-01\\") \'2024-01-01\' ``` # Additional Requirements 1. **Error Handling**: - The `next_occurrence` function should raise a `ValueError` with the message \\"Task not found\\" if the task name does not exist. 2. **Date Calculation**: - Ensure the correct calculation of the next occurrence date, taking into account leap years and different month lengths for \\"MONTHLY\\" and \\"YEARLY\\" patterns. 3. **Input Validation**: - The functions should validate input formats and raise appropriate errors if inputs are not in the correct format. Implement these two functions while adhering to the described requirements and error handling.","solution":"from datetime import datetime, timedelta from dateutil.relativedelta import relativedelta tasks = {} def add_task(name: str, start_date: str, recurrence_pattern: str) -> None: if recurrence_pattern not in {\\"DAILY\\", \\"WEEKLY\\", \\"MONTHLY\\", \\"YEARLY\\"}: raise ValueError(\\"Invalid recurrence pattern\\") try: datetime.strptime(start_date, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Invalid date format\\") tasks[name] = {\\"start_date\\": start_date, \\"recurrence_pattern\\": recurrence_pattern} def next_occurrence(name: str, current_date: str) -> str: if name not in tasks: raise ValueError(\\"Task not found\\") try: current_date_obj = datetime.strptime(current_date, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Invalid date format\\") task = tasks[name] start_date_obj = datetime.strptime(task[\\"start_date\\"], \\"%Y-%m-%d\\") recurrence_pattern = task[\\"recurrence_pattern\\"] if recurrence_pattern == \\"DAILY\\": delta = timedelta(days=1) elif recurrence_pattern == \\"WEEKLY\\": delta = timedelta(weeks=1) elif recurrence_pattern == \\"MONTHLY\\": delta = relativedelta(months=1) elif recurrence_pattern == \\"YEARLY\\": delta = relativedelta(years=1) next_date = start_date_obj while next_date <= current_date_obj: next_date += delta return next_date.strftime(\\"%Y-%m-%d\\")"},{"question":"# Context In financial modeling and analysis, it is often required to calculate the moving average of a time-series data to understand trends or smooth out short-term fluctuations. The moving average is used in various domains such as stock market analysis, weather forecasting, and signal processing. # Problem Statement Write a function, `calculate_moving_average(data, window_size)`, that takes a list of numerical data points and an integer window size. Your task is to compute the moving average of the data points. The moving average for each point is defined as the average of the elements in the window of the specified size, centered at that point. For simplicity, if the window extends beyond the boundaries of the list, consider the missing values as zero. # Function Signature ```python def calculate_moving_average(data: List[float], window_size: int) -> List[float]: pass ``` # Input * `data`: A list of floating-point numbers representing the time-series data. * `window_size`: An odd integer representing the size of the window for which the moving average is calculated. # Output * A list of floating-point numbers representing the moving average of the input data. # Constraints * The input list `data` will contain a minimum of 1 and a maximum of 10,000 elements. * The window size `window_size` will be an odd integer and at least 1, and at most the size of `data`. # Example ```python data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0] window_size = 3 moving_average = calculate_moving_average(data, window_size) print(moving_average) ``` # Explanation In this example, the `calculate_moving_average` function would compute the 3-point moving average for the given time-series data. For instance, the moving average centered at the second element (2.0) would be (0 + 1.0 + 2.0) / 3 = 1.0, considering the missing value beyond the boundary as zero. # Performance Requirements Your solution should handle the upper limit of the given constraints efficiently and return the result in a reasonable time frame.","solution":"from typing import List def calculate_moving_average(data: List[float], window_size: int) -> List[float]: n = len(data) half_window = window_size // 2 moving_average = [] for i in range(n): start = max(0, i - half_window) end = min(n, i + half_window + 1) window_sum = sum(data[start:end]) norm_factor = end - start moving_average.append(window_sum / norm_factor) return moving_average"},{"question":"# Rearrange Array Alternately Objective You are required to implement a function that rearranges a sorted array in an alternate minimum-maximum order. Problem Description Implement the function `rearrange_alternately` that takes a sorted list of integers and rearranges it such that the resulting list is in an alternate maximum and minimum order. Function Signature ```python def rearrange_alternately(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A sorted list of integers in ascending order. The length of the list will be between 1 and (10^5), inclusive. # Output - Returns a new list where the elements are rearranged in alternate maximum and minimum order. # Constraints - The given list will be sorted in non-decreasing order. - Each element of the list lies in the range of (-10^6) to (10^6). # Example ```python # Example test cases arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9] result1 = rearrange_alternately(arr1) print(result1) # Output: [9, 1, 8, 2, 7, 3, 6, 4, 5] arr2 = [10, 20, 30, 40, 50, 60, 70, 80] result2 = rearrange_alternately(arr2) print(result2) # Output: [80, 10, 70, 20, 60, 30, 50, 40] ``` # Notes 1. The resulting list should alternate between the largest remaining element and the smallest remaining element. 2. If the input list has an odd number of elements, the last element in the output list will be the median element of the input list. 3. The given list will always contain at least one element. # Additional Information This problem can be solved using a two-pointer technique where one pointer starts from the beginning (smallest element) and another pointer starts from the end (largest element) of the sorted list.","solution":"from typing import List def rearrange_alternately(arr: List[int]) -> List[int]: result = [] n = len(arr) left, right = 0, n - 1 while left <= right: if left <= right: result.append(arr[right]) right -= 1 if left <= right: result.append(arr[left]) left += 1 return result"},{"question":"# Problem Statement You have been assigned to create a queue data structure to manage job scheduling in a system. The queue must support typical operations and handle error conditions gracefully. **Specifications**: Implement a `Queue` class with the following methods: 1. `enqueue(data: T)`: Add an element `data` to the end of the queue. 2. `dequeue() -> T`: Remove and return the front element of the queue. 3. `front() -> T`: Return (but do not remove) the front element of the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty, `False` otherwise. 5. `is_full() -> bool`: Return `True` if the queue is full, `False` otherwise. 6. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueOverflowError*: Raised when attempting to enqueue onto a full queue. - *QueueUnderflowError*: Raised when attempting to dequeue from or access the front of an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The queue should be limited by a maximum size constraint upon initialization. # Inputs: - Integer `limit`: Defines the maximum number of elements the queue can hold. - Sequence of operations requests including `enqueue`, `dequeue`, `front`, `is_empty`, `is_full`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `front`: The respective element. - For `is_empty`, `is_full`: Boolean value indicating state of queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python Q = Queue(3) Q.enqueue(10) Q.enqueue(20) print(Q.dequeue()) # Output: 10 print(Q.front()) # Output: 20 print(Q.is_empty()) # Output: False Q.enqueue(30) print(Q.is_full()) # Output: False Q.enqueue(40) Q.enqueue(50) # Raises QueueOverflowError: Too many elements ``` # Constraints: - Queue size `limit` ranges from 1 to 10^4. - Operations on the queue should be optimized for efficiency. # Task: Implement the `Queue` class described above, ensuring proper function and error handling compliance.","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit): self.limit = limit self.queue = [] def enqueue(self, data): if len(self.queue) >= self.limit: raise QueueOverflowError(\\"Queue is full\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty\\") return self.queue.pop(0) def front(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) >= self.limit def size(self): return len(self.queue)"},{"question":"# Question: Lifecycle of a Task Performing a sequence of tasks often involves specific dependencies such that some tasks must precede others. We represent this situation using directed graphs where each node is a task and a directed edge from node `u` to node `v` indicates that task `u` must be completed before task `v`. **Task:** Implement a function `task_order` that determines a valid order for completing all the tasks given their dependencies. The function should use **topological sort**. **Function Signature:** ```python def task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: pass ``` **Input Format:** - `num_tasks` - an integer representing the total number of tasks. - `dependencies` - a list of tuples where each tuple `(u, v)` indicates that task `u` must be completed before task `v`. **Output Format:** - A list of integers representing a valid order to complete the tasks. If there are multiple valid orders, return any one of them. If no valid order exists (due to a cyclic dependency), return an empty list. **Constraints:** - The number of tasks `num_tasks` is between 1 and 10^4. - The list `dependencies` can have up to 10^5 elements. - Each task is represented by a unique integer ID from `0` to `num_tasks - 1`. **Performance Requirement:** - The algorithm should run in O(V + E) time complexity where V is the number of tasks and E is the number of dependencies. **Example:** ```python >>> task_order(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) [0, 1, 2, 3] # or any other valid topological order >>> task_order(2, [(1, 0), (0, 1)]) [] ``` **Context:** Imagine you are managing a series of development milestones for a software project. Certain milestones cannot commence until others are completed. Your goal is to determine a proper order to tackle these tasks so that all dependencies are respected and the project progresses smoothly. Implementing the `task_order` function will help you handle complex dependencies and ensure a coherent and clear schedule for your project. Good luck!","solution":"def task_order(num_tasks, dependencies): from collections import defaultdict, deque # Building the graph graph = defaultdict(list) indegree = {i: 0 for i in range(num_tasks)} # Populate graph and indegree for u, v in dependencies: graph[u].append(v) indegree[v] += 1 # Queue for the tasks with no prerequisites (zero indegree) zero_indegree_queue = deque([k for k in indegree if indegree[k] == 0]) topological_order = [] while zero_indegree_queue: task = zero_indegree_queue.popleft() topological_order.append(task) # Reduce the indegree of the neighbors for neighbor in graph[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If the topological sort includes all tasks, return it if len(topological_order) == num_tasks: return topological_order else: # There is a cycle, thus it\'s impossible to complete all tasks return []"},{"question":"# String Permutations with Constraints You are tasked with writing a function to generate all unique permutations of a given string while ensuring that no two consecutive characters in the permutation are the same. Requirements 1. **Function:** `unique_permutations(s: str) -> List[str]` 2. **Input:** - A single string `s` (1 ≤ len(s) ≤ 10), which may contain repeated characters. 3. **Output:** - A list of unique permutations of the string `s`, such that no two consecutive characters are the same. 4. **Constraints:** - The function should handle cases where it is impossible to permute the string under the given constraint by returning an empty list. Examples ```python unique_permutations(\\"aab\\") # Output: [\\"aba\\"] unique_permutations(\\"aaa\\") # Output: [] unique_permutations(\\"abc\\") # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] ``` Notes - Your function should generate valid permutations and remove duplicates efficiently. - The result should be in lexicographical order for consistency, but do not worry about meeting this requirement strictly. - If the input string is such that no unique permutation meets the condition, return an empty list. - You may use existing standard libraries for permutations but ensure to enforce the unique consecutive character rule efficiently within them. Good luck and ensure to test your function adequately!","solution":"from itertools import permutations from typing import List def unique_permutations(s: str) -> List[str]: def is_valid(perm): for i in range(1, len(perm)): if perm[i] == perm[i-1]: return False return True all_perms = permutations(s) unique_perms = set() for perm in all_perms: if is_valid(perm): unique_perms.add(\\"\\".join(perm)) return sorted(unique_perms)"},{"question":"# Coding Challenge: A common problem in data manipulation is rotating a matrix. Your task is to implement a function that rotates a given 2D matrix 90 degrees clockwise. # Objective: Write a function `rotate_matrix` that: 1. Takes a square 2D list (matrix) of integers. 2. Rotates the matrix 90 degrees clockwise. 3. Returns the rotated matrix. Expected Input and Output: * **Input**: * A square matrix represented as a list of lists, where each inner list represents a row. * **Output**: * A new list of lists representing the rotated matrix. Performance Requirements: * The function should work efficiently even for larger matrices, operating ideally with a time complexity of O(n^2) and a space complexity of O(1) (in-place rotation). Constraints and Considerations: * Consider edge cases such as an empty matrix or a matrix with a single row and column. * Ensure the solution does not crash on invalid inputs by raising appropriate exceptions. * Ensure the solution handles uniform and non-uniform integer values effectively. * Use in-place modifications to save space, if possible. # Example: ```python def rotate_matrix(matrix: list) -> list: pass print(rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])) # Expected output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] #] print(rotate_matrix([[1]])) # Expected output: [[1]] print(rotate_matrix([])) # Expected output: [] ``` # Note: * You are required to provide a detailed explanation of your implementation choices and any assumptions made. * Describe any edge cases handled during implementation.","solution":"def rotate_matrix(matrix): Rotates a given n x n 2D matrix 90 degrees clockwise. Args: matrix (list of list of int): A square matrix to rotate. Returns: list of list of int: The rotated matrix. if not matrix or not matrix[0]: return matrix n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Coding Assessment Question **Title**: Rotate an NxN Matrix **Problem Statement**: Given an ( N times N ) matrix, write a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that rotates the matrix 90 degrees clockwise in-place. **Input**: - A square matrix represented as a list of lists, where each inner list represents a row of the matrix. The matrix will contain at least one row and one column. **Output**: - The same matrix represented as a list of lists, but rotated 90 degrees clockwise. **Constraints**: - The elements of the matrix will be integers. - The matrix dimensions will not exceed ( 100 times 100 ). **Performance Requirements**: - The solution should work efficiently for input close to the constraint limits. - Do not use extra space for another matrix; rotate in-place. **Examples**: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix1)) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15,14, 12, 16] ] print(rotate_matrix(matrix2)) # Expected output: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] matrix3 = [ [1] ] print(rotate_matrix(matrix3)) # Expected output: # [ # [1] # ] ``` **Scenario**: Imagine you are developing a photo editing application that includes various transformations for images. One of the features allows users to rotate the image. Images can be represented as ( N times N ) matrices where each element represents a pixel\'s intensity. Implement the `rotate_matrix` function to facilitate this transformation. **Additional Notes**: - Ensure that your solution handles matrices of various sizes, including the smallest possible ( 1 times 1 ) matrix. - Pay attention to the structure of the matrix during rotation to avoid overwriting elements incorrectly.","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in-place. Parameters: matrix (list of list of int): The NxN matrix to rotate. Returns: list of list of int: The rotated matrix. N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse() return matrix"},{"question":"# Problem Statement You are tasked with writing a function that calculates the factorial of a given non-negative integer `n`. Factorials can grow very large, so your function should focus on both correctness and efficiency. # Function Signature ```python def factorial(n: int) -> int: ``` # Input - `n` (integer): a non-negative integer (0 ≤ `n` ≤ 20). # Output - Return an integer representing the factorial of `n`. # Constraints - The function must handle all edge cases within the given constraints and execute in a reasonable time frame. - Remember that the factorial of 0 is defined as 1 (0! = 1). # Example ```python >>> factorial(0) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 ``` # Explanation - In the first example, since the factorial of 0 is defined as 1, the result is 1. - In the second example, the factorial of 5 (5!) is calculated as 5 * 4 * 3 * 2 * 1, resulting in 120. - In the third example, the factorial of 10 (10!) is calculated as 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1, resulting in 3628800. # Edge Cases - For `n = 0`, the factorial should return 1. - For the upper limit `n = 20`, the function should still perform efficiently without overflowing. **Note**: Consider using both iterative and recursive methods and choose the one that best balances efficiency and readability.","solution":"def factorial(n: int) -> int: Returns the factorial of a given non-negative integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Coding Assessment Question Scenario As part of a weather prediction application, you need to implement a function to compute the mean (average) temperature over a given period, represented by an array of daily temperature readings. # Objective Implement the `average_temperature` function that calculates the average of an array of temperatures. Additionally, create a robust test suite to verify the function\'s correctness in different scenarios. # Function Signature ```python def average_temperature(temperatures: List[float]) -> float: pass ``` # Constraints - The function should handle an empty list gracefully by returning `None`. - If any of the list items is not numerical, raise a `TypeError` with a meaningful message. - Ensure the function operates in O(n) time complexity and O(1) space complexity, where `n` is the number of temperatures. # Input - `temperatures` (List[float]): A list of floating-point numbers representing daily temperatures. # Output - (float or None): A floating-point number denoting the average temperature, or `None` if the input list is empty. # Examples ```python assert abs(average_temperature([23.5, 25.0, 20.1, 30.2, 22.0]) - 24.16) < 1e-2 assert average_temperature([]) is None assert abs(average_temperature([15.0, -5.0, 7.0, 10.0, 23.0]) - 10.0) < 1e-2 assert abs(average_temperature([10.0]) - 10.0) < 1e-2 try: average_temperature([20, \\"hot\\", 30]) except TypeError as e: assert str(e) == \\"All items must be numbers\\" try: average_temperature([20, None, 30]) except TypeError as e: assert str(e) == \\"All items must be numbers\\" ``` # Implementation Details 1. Implement the `average_temperature` function that adheres to the specified behavior and constraints. 2. Write a comprehensive test function `test_average_temperature()` to ensure the correctness of the function, including handling of edge cases and appropriate error messages.","solution":"from typing import List, Union def average_temperature(temperatures: List[float]) -> Union[float, None]: Calculates the average temperature from a list of temperatures. :param temperatures: List of floating point numbers representing temperatures :return: The average temperature or None if the list is empty :raises: TypeError if any item in the list is not a number if not temperatures: return None if not all(isinstance(temp, (int, float)) for temp in temperatures): raise TypeError(\\"All items must be numbers\\") return sum(temperatures) / len(temperatures)"},{"question":"# Question: Design a Function for Simulated Binary Cross-Over (SBX) Genetic algorithms are a heuristic approach for optimization problems. One of the commonly used operators in genetic algorithms is the Simulated Binary Crossover (SBX) which is used for generating child (offspring) solutions from two parent solutions. Steps to Solve: 1. Write a function `simulated_binary_crossover()` that performs SBX on two parent solutions. 2. Incorporate a variable `eta` (distribution index) which controls the extent to which the child solutions resemble their parents. # Specifications: Function: `simulated_binary_crossover` * **Input:** * `parent1` (list of float): The first parent solution. * `parent2` (list of float): The second parent solution. * `eta` (float): The distribution index. * `crossover_probability` (float): The probability of crossing over. * **Output:** * Returns a tuple containing the two child solutions (list of float). # Constraints: * Both parent solution lists are of the same length and contain floating point numbers. * The crossover probability is a value between 0 and 1. * The distribution index (`eta`) should be greater than 0. # Example: ```python def simulated_binary_crossover(parent1: list, parent2: list, eta: float, crossover_probability: float) -> tuple: pass # Example Input parent1 = [0.1, 0.5, 0.9] parent2 = [0.2, 0.6, 0.8] eta = 2 crossover_probability = 0.9 # Perform Simulated Binary Crossover child1, child2 = simulated_binary_crossover(parent1, parent2, eta, crossover_probability) assert len(child1) == len(parent1) assert len(child2) == len(parent2) assert all(isinstance(x, float) for x in child1) assert all(isinstance(x, float) for x in child2) ``` # Detailed Explanation: 1. **Simulated Binary Crossover (SBX)** - A method designed to simulate the mechanics of binary crossover used in binary-encoded genetic algorithms to real-parameter spaces. 2. **Distribution Index (η)** - A parameter controlling the spread of the offspring solutions around the parents. Higher values of η result in offspring closer to their parents. 3. **Crossover Probability** - Indicates the likelihood that crossover will occur between pairs of parents. # Implementation Steps: 1. For each pair of genes (elements) from the parent solutions, generate a random number to decide whether crossover will take place based on the `crossover_probability`. 2. If crossover occurs, use the SBX formula: ```python if random.random() <= 0.5: beta = (2 * random.random()) ** (1 / (eta + 1)) else: beta = (1 / (2 * (1 - random.random()))) ** (1 / (eta + 1)) ``` 3. Calculate the child genes using: ```python child1_gene = 0.5 * ((1 + beta) * parent1_gene + (1 - beta) * parent2_gene) child2_gene = 0.5 * ((1 - beta) * parent1_gene + (1 + beta) * parent2_gene) ``` 4. Repeat the process for all gene pairs in the parents. Your function should ensure that the child solutions generated are valid and each contain floating point numbers as specified. Remember to account for edge cases where crossover may not occur if the random number exceeds the `crossover_probability`.","solution":"import random def simulated_binary_crossover(parent1, parent2, eta, crossover_probability): if len(parent1) != len(parent2): raise ValueError(\\"Both parent lists must be of the same length.\\") child1 = [] child2 = [] for x1, x2 in zip(parent1, parent2): if random.random() <= crossover_probability: if abs(x1 - x2) > 1e-14: if random.random() <= 0.5: beta = (2 * random.random()) ** (1 / (eta + 1)) else: beta = (1 / (2 * (1 - random.random()))) ** (1 / (eta + 1)) child1.append(0.5 * ((1 + beta) * x1 + (1 - beta) * x2)) child2.append(0.5 * ((1 - beta) * x1 + (1 + beta) * x2)) else: child1.append(x1) child2.append(x2) else: child1.append(x1) child2.append(x2) return child1, child2"},{"question":"# Permutation and Combination - Generating All Subsets and Their Combinations Objective Implement functions to generate all possible subsets of a given set and to compute all combinations of a specific size from those subsets. Problem Statement Given a set of distinct integers and a integer ( k ), create functions that: 1. Generate all possible subsets of the set. 2. Generate all possible combinations of size ( k ) from the given set. Input and Output * **Input Format**: - A list of distinct integers representing the set. - An integer ( k ) representing the size of the combinations to be generated. * **Output Format**: 1. A list of lists where each inner list is a subset of the given set. 2. A list of lists where each inner list is a combination of size ( k ) from the given set. Constraints 1. The size of the initial set will not exceed 15. 2. ( k ) will be a positive integer and ( k leq text{length of the set} ). Requirements * **Functions**: 1. `generate_subsets(input_set: list[int]) -> list[list[int]]` 2. `generate_combinations(input_set: list[int], k: int) -> list[list[int]]` Detailed Requirements * The subsets should be ordered in any natural way (it doesn\'t need to be lexicographically ordered). * The order of subsets or combinations in the resulting list does not matter. * Duplicates should not be present in the result lists. Example ```python input_set = [1, 2, 3] k = 2 # Generating the subsets subsets = generate_subsets(input_set) print(subsets) # Possible output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] # Generating the combinations of size k combinations = generate_combinations(input_set, k) print(combinations) # Possible output: [[1, 2], [1, 3], [2, 3]] ```","solution":"from itertools import combinations def generate_subsets(input_set): Generate all possible subsets of the given set. :param input_set: A list of distinct integers. :return: A list of lists where each inner list is a subset of the input_set. subsets = [] n = len(input_set) for i in range(1 << n): subset = [input_set[j] for j in range(n) if i & (1 << j)] subsets.append(subset) return subsets def generate_combinations(input_set, k): Generate all possible combinations of size k from the given set. :param input_set: A list of distinct integers. :param k: The size of each combination. :return: A list of lists where each inner list is a combination of size k from input_set. return list(map(list, combinations(input_set, k)))"},{"question":"# Question: Problem Statement: Design a function to compute the majority element in a list of integers. The majority element is the element that appears more than n/2 times in the list, where n is the length of the list. You can assume that the input list always has a majority element. Function Signature: ```python def find_majority_element(nums: list[int]) -> int: Find the majority element that appears more than n/2 times in the list :param nums: List of integers :return: Majority element ``` Input: - `nums`: A list of integers with length n (1 ≤ n ≤ 10^5). Output: - An integer representing the majority element. Example: ```python >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element([1, 1, 1]) 1 >>> find_majority_element([1, 2, 3, 3, 3, 2, 3, 3, 3]) 3 ``` Constraints: - The length of the input list will be between 1 and 100,000. - The input list will always contain a majority element. Performance Requirements: The function should preferably operate in linear time O(n). Consider using a well-known algorithm for majority element detection, such as Boyer-Moore Voting Algorithm. Hint: Think about how the element that is the majority can be identified when counting occurrences in a single pass through the list. The Boyer-Moore Voting Algorithm is particularly efficient for this purpose.","solution":"def find_majority_element(nums: list[int]) -> int: Find the majority element that appears more than n/2 times in the list :param nums: List of integers :return: Majority element # Boyer-Moore Voting Algorithm majority_element = nums[0] count = 1 for num in nums[1:]: if count == 0: majority_element = num count = 1 elif num == majority_element: count += 1 else: count -= 1 return majority_element"},{"question":"# Interpolation with Cubic Splines Objective Create a function to perform cubic spline interpolation for a given set of data points and evaluate the spline at a specified point. Problem Scenario In data analysis and graphical computations, interpolating data points smoothly is often required. Cubic splines provide a piecewise function that can smoothly interpolate a given set of data points. Task Write a function `cubic_spline_interpolation(x_coords, y_coords, eval_point)` that computes the cubic spline interpolation for the provided `x_coords` and `y_coords`, and evaluates the spline at `eval_point`. Function Signature ```python def cubic_spline_interpolation(x_coords: List[float], y_coords: List[float], eval_point: float) -> float: pass ``` Input * `x_coords`: a list of float values representing x-coordinates of the data points. * `y_coords`: a list of float values representing y-coordinates of the data points, corresponding to `x_coords`. * `eval_point`: a float value where the spline will be evaluated. Output * Returns the interpolated value at `eval_point` as a float. Constraints * `x_coords` and `y_coords` will have the same length and contain at least 2 points. * `x_coords` will be strictly increasing. * `eval_point` will be a float within the range of `x_coords`. Examples ```python x = [0, 1, 2, 3, 4, 5] y = [0, 1, 4, 9, 16, 25] print(cubic_spline_interpolation(x, y, 2.5)) # Expected output: interpolated value at x = 2.5 print(cubic_spline_interpolation([1, 2, 3], [1, 8, 27], 2.5)) # Expected output: interpolated value at x = 2.5 ``` Constraints & Edge Cases * Ensure that the function handles an evaluation point exactly at a known x-coordinate. * Implement proper boundary handling for the first and last intervals. * Consider numerical stability and accuracy. Good luck!","solution":"from scipy.interpolate import CubicSpline from typing import List def cubic_spline_interpolation(x_coords: List[float], y_coords: List[float], eval_point: float) -> float: Computes the cubic spline interpolation for the provided x_coords and y_coords and evaluates the spline at eval_point. :param x_coords: List of x-coordinates of the data points :param y_coords: List of y-coordinates of the data points :param eval_point: Point where the spline should be evaluated :return: Interpolated value at eval_point # Use scipy\'s CubicSpline to perform the interpolation cs = CubicSpline(x_coords, y_coords) return cs(eval_point)"},{"question":"**[Question 2]: Rotated Array Search** You need to write a function `search_rotated_sorted_array` that takes a rotated, sorted array and a target value, and returns the index of the target value in the array. If the target is not found, return `-1`. A rotated array is an array that was originally sorted in increasing order, but then was rotated by some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). The array may contain duplicate values. To ensure your understanding of search algorithms and edge handling, your function should meet the following requirements: # Function Signature ```python def search_rotated_sorted_array(nums: List[int], target: int) -> int: ``` # Input - `nums`: A list of integers which was originally sorted in increasing order and then rotated by an unknown pivot. - `target`: An integer value that you need to find the index of in `nums`. # Output - Returns an integer index of the `target` in `nums`. If `target` is not found, return `-1`. # Constraints - The array `nums` can hold up to 10000 elements. - The array may contain duplicate values. - The function should have an average-case time complexity better than O(n), leveraging the properties of the rotated sorted array. # Example ```python # Example 1 nums = [4,5,6,7,0,1,2] target = 0 print(search_rotated_sorted_array(nums, target)) # Output: 4 # Example 2 nums = [4,5,6,7,0,1,2] target = 3 print(search_rotated_sorted_array(nums, target)) # Output: -1 # Example 3 nums = [3, 1, 2] target = 1 print(search_rotated_sorted_array(nums, target)) # Output: 1 ``` Ensure your code is efficient and correctly handles edge cases such as arrays with duplicates, small arrays, and cases where the target is not present.","solution":"from typing import List def search_rotated_sorted_array(nums: List[int], target: int) -> int: Returns the index of the target value in the rotated sorted array. If the target is not found, returns -1. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # When dividing the rotated array into two halves, one must be sorted. # Check if the left part is sorted if nums[left] <= nums[mid]: # Target is in the left part if it lies between left and mid if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Otherwise, the right part must be sorted # Target is in the right part if it lies between mid and right if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Description Given a list of integers, write a function to calculate the minimum cost of reducing all elements to the same value. The cost of reducing an element is defined as the absolute difference between the original value and the chosen target value. Your task is to implement the function that finds the minimum possible total cost. # Input and Output **Function Signature**: ```python def min_cost_to_equal_elements(arr: List[int]) -> int: pass ``` **Inputs**: * `arr` (List[int]): A list of integers with at least one element and at most (10^5) elements, where each integer is between (-10^6) and (10^6). **Outputs**: * Returns an integer representing the minimum cost to make all elements in the list equal. # Constraints * The list `arr` is non-empty. * The values in `arr` lie in the range ([-10^6, 10^6]). # Example ```python arr = [1, 3, 7] result = min_cost_to_equal_elements(arr) print(result) ``` **Output**: ``` 4 ``` # Task Write the `min_cost_to_equal_elements` function that determines the optimal target value to minimize the processing cost and calculates the corresponding minimum total cost. Implement proper handling of edge cases and ensure optimal performance for the given constraints. # Explanation The optimal solution should consider the median of the list as the target value, as this finds the point where the sum of absolute differences is minimized. Therefore, the cost is minimized when all elements are reduced to the median.","solution":"from typing import List def min_cost_to_equal_elements(arr: List[int]) -> int: Calculate the minimum cost of reducing all elements in the list to the same value. The cost is defined as the absolute difference between an element and the target value chosen to make all elements the same. # Sort the array to find the median element(s) arr.sort() # Find the median element n = len(arr) if n % 2 == 1: median = arr[n // 2] else: median = arr[n // 2 - 1] # Calculate the total cost of making all elements equal to the median total_cost = sum(abs(x - median) for x in arr) return total_cost"},{"question":"# Question: Warehouse Management System Context You are tasked with designing a warehouse management system that supports addition and removal of items, as well as retrieval of the current inventory based on various criteria. You will need to implement efficient methods for these functionalities to ensure quick response times even with a large volume of items. Requirements 1. **Warehouse Management Class (`Warehouse`)**: - Should maintain an internal structure (e.g., dictionary) to hold items and their quantities. - Must support adding new items, updating item quantities, as well as removing items. 2. **Item Retrieval Methods**: - Implement a method `get_inventory` to retrieve current stock details. - Allow retrieval based on different criteria: - All items in the warehouse. - Items below a specified quantity threshold. - Items within a specified quantity range. Implementation Details - **Input Format**: - Adding Items: (item_name: str, quantity: int) - Removing Items: (item_name: str, quantity: int) - Retrieval: various criteria as parameters to `get_inventory`. - **Output Format**: - For adding/removing: confirmation of the action. - For inventory retrieval: a list of items matching the criteria. - **Constraints**: - The system should handle up to 10,000 unique items efficiently. - Ensure robustness by handling edge cases such as attempting to remove more items than available, and adding/removing items with zero or negative quantities. Function Signature ```python from typing import List, Tuple class Warehouse: def __init__(self): self.inventory = {} def add_item(self, item_name: str, quantity: int) -> None: pass # Add item to the inventory def remove_item(self, item_name: str, quantity: int) -> None: pass # Remove item from the inventory def get_inventory(self, threshold: int = None, range_: Tuple[int, int] = None) -> List[Tuple[str, int]]: pass # Retrieve stock details based on criteria # Example Usage: # warehouse = Warehouse() # warehouse.add_item(\\"item1\\", 50) # warehouse.add_item(\\"item2\\", 30) # warehouse.remove_item(\\"item1\\", 10) # all_items = warehouse.get_inventory() # low_stock_items = warehouse.get_inventory(threshold=20) # range_stock_items = warehouse.get_inventory(range_=(10, 40)) ``` Performance Requirements - Aim for efficient inventory management, especially when dealing with large number of items and frequent updates. Incorporate necessary checks to ensure integrity of the inventory data at all times.","solution":"from typing import List, Tuple, Dict class Warehouse: def __init__(self): self.inventory = {} def add_item(self, item_name: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity to be added should be greater than zero.\\") if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity def remove_item(self, item_name: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity to be removed should be greater than zero.\\") if item_name not in self.inventory: raise KeyError(\\"Item not found in inventory.\\") if self.inventory[item_name] < quantity: raise ValueError(\\"Insufficient quantity to remove.\\") self.inventory[item_name] -= quantity if self.inventory[item_name] == 0: del self.inventory[item_name] def get_inventory(self, threshold: int = None, range_: Tuple[int, int] = None) -> List[Tuple[str, int]]: if threshold is not None: return [(item, qty) for item, qty in self.inventory.items() if qty < threshold] elif range_ is not None: return [(item, qty) for item, qty in self.inventory.items() if range_[0] <= qty <= range_[1]] else: return list(self.inventory.items())"},{"question":"# Coding Question **Scenario:** In a movie streaming service, users can rate movies on a scale of 1 to 5. The ratings are collected and stored in a list of integers. One essential task is to identify the most frequently given rating and how many times it was given. For this challenge, you need to write a function that identifies the highest frequency rating and its count. # Problem Statement: You are given a list of integers representing the ratings given by users for various movies. Each integer represents a rating from 1 to 5. Write a function `most_frequent_rating(ratings: list[int]) -> tuple[int, int]` that returns the most frequently given rating and its count. # Input: - A list of integers `ratings` where each integer represents a rating (1 <= len(ratings) <= 10^6, 1 <= ratings[i] <= 5). # Output: - A tuple containing two integers: 1. The rating that was given the most frequently. 2. The count of how many times this rating was given. # Constraints: - Each input element is a valid integer representing a rating between 1 and 5. - The list can be very large but will fit into memory. # Example: ```python >>> most_frequent_rating([1, 2, 2, 3, 4, 3, 5, 2, 1]) (2, 3) >>> most_frequent_rating([1, 1, 1, 3, 3, 3, 3, 5]) (3, 4) >>> most_frequent_rating([4, 4, 4, 4, 4]) (4, 5) >>> most_frequent_rating([2, 2, 2, 1, 1, 1]) (2, 3) # If there\'s a tie, return the rating with the smaller number. >>> most_frequent_rating([]) (0, 0) # Return (0, 0) for an empty list. ``` # Detailed Steps: 1. Use the `Counter` from the `collections` module to count occurrences of each rating. 2. Identify the rating with the highest count. 3. If multiple ratings have the same highest count, return the one with the smallest rating value. 4. Return a tuple containing the rating and its count. # Notes: - Ensure code handles empty lists by returning (0, 0). - Ensure code efficiently handles large lists.","solution":"from collections import Counter from typing import List, Tuple def most_frequent_rating(ratings: List[int]) -> Tuple[int, int]: Identifies the most frequently given rating and its count. Parameters: ratings (List[int]): A list of integers representing movie ratings. Returns: Tuple[int, int]: A tuple containing the most frequently given rating and its count. Returns (0, 0) if the list is empty. if not ratings: return (0, 0) rating_counts = Counter(ratings) most_common_rating, count = max(rating_counts.items(), key=lambda x: (x[1], -x[0])) return (most_common_rating, count)"},{"question":"# Problem Statement: You are building a feature to analyze text data for sentiment classification. A critical preprocessing step is normalizing the text by removing all punctuation and converting the text to lowercase. Given a string, your task is to write a function that performs this normalization. # Function Signature: ```python def normalize_text(text: str) -> str: # Your code here ``` # Input: - A string `text` containing alphanumeric characters, spaces, and punctuation marks. # Output: - A string with all punctuation removed and all characters converted to lowercase. # Constraints: - The input string can have up to 10^5 characters. - The input string can contain any printable ASCII characters. # Example: ```python - Input: \\"Hello, World! This is a Test.\\" - Output: \\"hello world this is a test\\" - Input: \\"Python\'s syntax is clear; it\'s easy to learn.\\" - Output: \\"pythons syntax is clear its easy to learn\\" ``` # Notes: - You can use Python’s built-in string methods for implementation. - Focus on efficiency, ensuring that your method can handle the upper limit of input size gracefully. # Task: Implement the function as described, and test it with various cases including edge cases for robust performance and correctness.","solution":"import string def normalize_text(text: str) -> str: Removes all punctuation from the input text and converts all characters to lowercase. text = text.lower() # Translation table to remove punctuation described by python\'s string.punctuation translator = str.maketrans(\'\', \'\', string.punctuation) return text.translate(translator)"},{"question":"# Problem Statement **Scenario**: In the realm of arcane magic, a powerful wizard is crafting spells using a unique sequence of runes. Each rune is represented by a distinct character. The wizard has discovered that the potency of a spell increases if no two consecutive runes are the same. Given a string representing an initial sequence of runes, the wizard needs your help to transform it into a potent spell by inserting the minimum number of additional runes such that there are no two consecutive identical runes. # Task Implement function `min_runes_to_insert(spell: str) -> int` which takes a string `spell` and returns the minimum number of runes to insert to ensure no two consecutive runes are the same. # Requirements * You must handle invalid inputs (e.g., non-string types). * The solution must efficiently determine the minimum number of runes needed. # Function Signature ```python def min_runes_to_insert(spell: str) -> int: Args: spell (str): The initial sequence of runes. Returns: int: The minimum number of runes to insert for a potent spell. Raises: ValueError: If the input is not a string. ``` # Constraints * `0 <= len(spell) <= 10^5` * The input string `spell` consists only of lowercase English letters. # Example ```python # Example 1 assert min_runes_to_insert(\\"aabb\\") == 2 # Example 2 assert min_runes_to_insert(\\"aaaa\\") == 3 # Example 3 assert min_runes_to_insert(\\"abc\\") == 0 ``` # Explanation In each example: - **Example 1**: For the input \\"aabb\\", inserting two runes (e.g., \\"aababab\\") ensures no consecutive identical runes. - **Example 2**: For the input \\"aaaa\\", inserting three different runes (e.g., \\"abababa\\") ensures no consecutive identical runes. - **Example 3**: The input \\"abc\\" already has no consecutive identical runes, so no runes need to be inserted. **Note**: Ensure your implementation is optimized to handle large inputs efficiently.","solution":"def min_runes_to_insert(spell: str) -> int: Returns the minimum number of runes to insert for a potent spell. Args: spell (str): The initial sequence of runes. Returns: int: The minimum number of runes to insert for a potent spell. Raises: ValueError: If the input is not a string or contains invalid characters. if not isinstance(spell, str): raise ValueError(\\"Input must be a string\\") n = len(spell) if n == 0: return 0 insertions = 0 for i in range(1, n): if spell[i] == spell[i - 1]: insertions += 1 return insertions"},{"question":"# Matrix Path Sum Finder You are required to implement an algorithm that finds the minimum path sum from the top-left corner to the bottom-right corner of a given `n x m` matrix, where each cell contains a non-negative integer. You can only move either down or right at any point in time. Function: min_path_sum Implement the `min_path_sum(matrix)` function which calculates the minimum path sum. **Input**: - `matrix` (List[List[int]]): A 2D list of non-negative integers representing the matrix. **Output**: - `min_sum` (int): The minimum sum of the path from the top-left to the bottom-right. Constraints: - The dimensions of the matrix are such that (1 leq n, m leq 100). - Each element in the matrix is a non-negative integer. Example: ```python def min_path_sum(matrix: List[List[int]]) -> int: # Your implementation here pass # Example usage matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(matrix)) # Should print 7 because the path 1→3→1→1→1 gives the minimum sum ``` Ensure that your implementation correctly calculates the minimum path sum. Using dynamic programming to optimize the solution is recommended.","solution":"def min_path_sum(matrix): Returns the minimum path sum from the top-left to the bottom-right of a matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) # Initialize a 2D dp array with the same dimensions as matrix dp = [[0] * m for _ in range(n)] # Set the starting point dp[0][0] = matrix[0][0] # Initialize the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner of dp contains the answer return dp[n-1][m-1]"},{"question":"# Question: Unique Words from a List of Sentences You need to implement a function that takes a list of sentences and returns a list of unique words across all sentences. The words should be returned in the order they first appeared, ignoring case. Function Signature ```python def unique_words(sentences: list[str]) -> list[str]: # Your code here ``` # Input - `sentences` (list[str]): A list of sentences where each sentence is a non-empty string. # Output - Returns a list of unique words, preserving the order of their first appearance. # Constraints - Each sentence contains words separated by spaces. - The words in each sentence consist of alphabetic characters only. - The input list of sentences will have at least one sentence. # Example ```python assert unique_words([\\"Hello world\\", \\"world of Python\\"]) == [\'hello\', \'world\', \'of\', \'python\'] assert unique_words([\\"Python is great\\", \\"is Python great\\"]) == [\'python\', \'is\', \'great\'] assert unique_words([\\"A quick brown fox\\", \\"jumps over the lazy dog\\"]) == [\'a\', \'quick\', \'brown\', \'fox\', \'jumps\', \'over\', \'the\', \'lazy\', \'dog\'] assert unique_words([\\"apple Apple\\", \\"banana BANANA\\"]) == [\'apple\', \'banana\'] assert unique_words([\\"This is a sentence\\", \\"This is another sentence\\"]) == [\'this\', \'is\', \'a\', \'sentence\', \'another\'] ``` # Notes - Each word should be converted to lowercase to ensure case insensitivity. - The order in the output list should be based on the first occurrence across all sentences. - Your implementation should perform efficiently even with a large number of sentences and long sentences. - Consider using a data structure that maintains order and uniqueness to achieve the desired output.","solution":"def unique_words(sentences: list[str]) -> list[str]: Returns a list of unique words in the order they first appeared across all sentences, ignoring case. seen_words = set() unique_word_list = [] for sentence in sentences: words = sentence.lower().split() for word in words: if word not in seen_words: seen_words.add(word) unique_word_list.append(word) return unique_word_list"},{"question":"# Question: You are given a list of integers, each representing a building\'s height in an area where it can rain. Your task is to find out how much water is trapped after the rain. This is a common \\"rainwater trapping\\" problem where you need to calculate the total volume of water trapped between buildings based on the given heights. Requirements: 1. Implement the function `trap_rainwater` which calculates the total amount of trapped rainwater. 2. The function should use an efficient algorithm to ensure optimal performance. Input: - `heights`: list of int (where each element represents the height of a building) Output: - int (total units of trapped rainwater) # Constraints: - 0 <= `len(heights)` <= 3 * 10^4 - 0 <= `heights[i]` <= 10^5 # Example: ```python heights = [0,1,0,2,1,0,1,3,2,1,2,1] assert trap_rainwater(heights) == 6 heights = [4,2,0,3,2,5] assert trap_rainwater(heights) == 9 ``` # Notes: - The function should handle cases where no water can be trapped appropriately by returning 0. - Consider edge cases such as arrays with less than 3 elements, where no water can be trapped. - Use a two-pointer technique or dynamic programming to solve the problem efficiently. # Implementation: Implement the `trap_rainwater` function in Python, ensuring optimal performance with an O(n) time complexity solution.","solution":"def trap_rainwater(height): Calculate the total amount of rainwater trapped. :param height: List of building heights. :return: Total units of trapped rainwater. if not height or len(height) <= 2: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"# List Flattening and Summation You are provided with a predefined list that may contain integers, lists of integers, or nested lists of integers. Your task is to implement a function that flattens the list and computes the sum of all the integers in it. Objective: Implement a new function called `flatten_and_sum()` that takes a nested list of integers and returns the sum of all integers within the list. # Specifications: - **Function Name**: `flatten_and_sum` - **Input**: - `nested_list`: A list that contains integers and/or other lists of integers, which may be nested at any level. - **Output**: A single integer representing the sum of all integers in the input `nested_list`. # Constraints: - The `nested_list` should be validated to contain only integers or lists of integers. - Handle empty lists appropriately by returning 0. - Consider deeply nested structures. # Example: ```python print(flatten_and_sum([1, 2, [3, 4, [5, 6]], 7])) # Expected: 28 print(flatten_and_sum([0, [1, 2, [3, 4]], 5])) # Expected: 15 print(flatten_and_sum([])) # Expected: 0 print(flatten_and_sum([[[]], []])) # Expected: 0 ``` # Steps: 1. Implement the `flatten_and_sum` function. 2. Use recursion to handle arbitrary levels of nested lists. 3. Accumulate the sum of the integers as you traverse through the nested structure. # Edge Cases to Consider: - Completely empty lists. - Lists that contain only one integer or deeply nested empty lists. - Large nested structures. ```python def flatten_and_sum(nested_list): def flatten(lst): for e in lst: if isinstance(e, list): yield from flatten(e) else: yield e return sum(flatten(nested_list)) # Example Usage print(flatten_and_sum([1, 2, [3, 4, [5, 6]], 7])) # Expected: 28 ```","solution":"def flatten_and_sum(nested_list): Flattens a nested list and calculates the sum of all integers within it. def flatten(lst): for element in lst: if isinstance(element, list): yield from flatten(element) else: yield element return sum(flatten(nested_list))"},{"question":"# Background Graph traversal is a fundamental operation in computer science that involves visiting all the nodes in a graph. One approach to graph traversal is Breadth-First Search (BFS), which explores a graph level by level. BFS is useful in various applications such as finding the shortest path in an unweighted graph, peer-to-peer networks, and social networks. # Task You are provided with a graph in the form of an adjacency matrix and a starting node. Your task is to perform a Breadth-First Search (BFS) starting from the given node and return the order in which the nodes are visited. # Function Signature ```python def bfs_traversal(adj_matrix: List[List[int]], start_node: int) -> List[int]: ``` # Input * `adj_matrix`: A 2D list of integers where `adj_matrix[i][j] = 1` indicates an edge between nodes `i` and `j`, and `adj_matrix[i][j] = 0` indicates no edge. * `start_node`: An integer indicating the starting node for the BFS traversal. # Output * Returns a list of integers representing the order in which nodes are visited during the BFS. # Constraints * The number of nodes `N` in the graph satisfies ( 1 leq N leq 1000 ). * The `start_node` will always be a valid node in the graph. * The graph may be disconnected; in such cases, BFS will only traverse the connected component containing the start node. # Example ```python adj_matrix = [ [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0] ] start_node = 0 print(bfs_traversal(adj_matrix, start_node)) # Output: [0, 1, 4, 2, 3] ``` # Notes * Use a queue data structure to implement the BFS traversal. * Keep track of visited nodes to avoid processing a node more than once. This new question aligns with the original set in terms of style, complexity, and scope by focusing on a fundamental graph traversal technique and providing a clear and structured problem statement. It challenges the user\'s understanding of graph data structures and BFS algorithm while ensuring a consistent tone and format.","solution":"from collections import deque from typing import List def bfs_traversal(adj_matrix: List[List[int]], start_node: int) -> List[int]: Perform BFS traversal on a graph represented by an adjacency matrix starting from a given node. :param adj_matrix: 2D list of integers, representing the adjacency matrix of the graph. :param start_node: Integer, indicating the starting node for the BFS traversal. :return: List of integers representing the order in which nodes are visited during the BFS. num_nodes = len(adj_matrix) visited = [False] * num_nodes order = [] queue = deque([start_node]) visited[start_node] = True while queue: current_node = queue.popleft() order.append(current_node) # Traverse all adjacent nodes for neighbor in range(num_nodes): if adj_matrix[current_node][neighbor] == 1 and not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True return order"},{"question":"# Question You are required to solve a problem involving string manipulation and pattern matching. Problem Statement Given a string `s` and a list of words `words`, implement a function `find_concatenation_indices` that finds all the starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. Each word in `words` has the same length. Function Signature ```python def find_concatenation_indices(s: str, words: List[str]) -> List[int]: ``` Input - `s` (str): A string of length in the range [1, 10^4]. - `words` (List[str]): A list of strings (words) where each word has length `k` and list length is in the range [1, 500]. Output - `List[int]`: Return a list of starting indices of the concatenated substrings in `s`. Constraints 1. The words in `words` are all of the same length `k`. 2. Each word in `words` consists of lowercase English letters. 3. `s` consists of lowercase English letters. Example ```python s = \\"barfoothefoobarman\\" words = [\\"foo\\", \\"bar\\"] print(find_concatenation_indices(s, words)) # Output: [0, 9] (The substrings are \\"barfoo\\" and \\"foobar\\") s = \\"wordgoodgoodgoodbestword\\" words = [\\"word\\", \\"good\\", \\"best\\", \\"word\\"] print(find_concatenation_indices(s, words)) # Output: [] ``` Requirements - Efficiently handle the given constraints. - Consider both time and space complexity while designing the solution. - Handle edge cases such as `s` or `words` being empty, and when no such concatenation exists.","solution":"from typing import List def find_concatenation_indices(s: str, words: List[str]) -> List[int]: if not s or not words: return [] word_len = len(words[0]) num_words = len(words) concat_len = word_len * num_words if len(s) < concat_len: return [] word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 result_indices = [] for i in range(len(s) - concat_len + 1): seen_words = {} for j in range(num_words): word_index = i + j * word_len word = s[word_index:word_index + word_len] if word not in word_count: break if word in seen_words: seen_words[word] += 1 else: seen_words[word] = 1 if seen_words[word] > word_count[word]: break else: result_indices.append(i) return result_indices"},{"question":"# Sum of List Elements Context Summing the elements of a list is a fundamental task in programming, applicable in data analysis, numerical computations, and more. This question evaluates your ability to write a basic function that operates on a list of integers, handling both positive and negative values. Task Write a Python function `sum_of_elements(numbers: List[int]) -> int` that computes the sum of all the integers in a given list. Your solution should also handle the empty list scenario by returning 0. Specifications - **Input**: A list `numbers` containing integers. - **Output**: An integer that represents the sum of all elements in the provided list. - **Constraints**: - The input list can contain any number of integers, including zero. - The list can contain negative numbers. Error Handling - No specific error handling is required for invalid input (assume the input is always a list of integers). Examples ```python >>> sum_of_elements([1, 2, 3, 4]) 10 >>> sum_of_elements([-1, -2, -3, -4]) -10 >>> sum_of_elements([1, -1, 2, -2]) 0 >>> sum_of_elements([]) 0 >>> sum_of_elements([100]) 100 ``` Notes - Aim for a clear and concise implementation. - Ensure your solution handles edge cases, such as an empty list or a list with a single element.","solution":"from typing import List def sum_of_elements(numbers: List[int]) -> int: Returns the sum of all integers in the provided list. return sum(numbers)"},{"question":"# Problem Statement **Context**: You are tasked with creating a class that represents a matrix and provides functionality to perform basic matrix operations. This includes addition, subtraction, matrix multiplication, and transpose. The class should handle matrices of any size, provided the operations are mathematically valid (e.g., dimensions match). # Task: Implement a `Matrix` class with the following methods: ```python class Matrix: def __init__(self, data: list): Initialize the matrix with a 2D list. pass def add(self, other: \'Matrix\') -> \'Matrix\': Add two matrices. pass def subtract(self, other: \'Matrix\') -> \'Matrix\': Subtract another matrix from the current matrix. pass def multiply(self, other: \'Matrix\') -> \'Matrix\': Multiply the current matrix with another matrix. pass def transpose(self) -> \'Matrix\': Return the transpose of the matrix. pass def __str__(self) -> str: Return the string representation of the matrix. pass ``` # Input: * A list of lists, where each sublist represents a row of the matrix. * For the `add`, `subtract`, and `multiply` methods, another `Matrix` object. # Output: * For `__init__`, return None. * For `add`, `subtract`, and `multiply`, return a new `Matrix` object representing the result. * For `transpose`, return a new `Matrix` object. * For `__str__`, return a string representation of the matrix. # Constraints: * The input data for matrix initialization will always be a non-empty list of non-empty lists with consistent row lengths. * The dimensions for addition and subtraction operations must match. * The number of columns in the first matrix must equal the number of rows in the second for multiplication. * Each matrix will have at most 100 rows and 100 columns. # Example: ```python # Initialize two matrices matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[7, 8, 9], [10, 11, 12]]) # Add the matrices result_add = matrix1.add(matrix2) print(result_add) # Output: # [8, 10, 12] # [14, 16, 18] # Subtract the matrices result_subtract = matrix1.subtract(matrix2) print(result_subtract) # Output: # [-6, -6, -6] # [-6, -6, -6] # Transpose the matrix result_transpose = matrix1.transpose() print(result_transpose) # Output: # [1, 4] # [2, 5] # [3, 6] # Multiply the matrices matrix3 = Matrix([[1, 2], [3, 4], [5, 6]]) matrix4 = Matrix([[7, 8, 9], [10, 11, 12]]) result_multiply = matrix3.multiply(matrix4) print(result_multiply) # Output: # [27, 30, 33] # [61, 68, 75] # [95, 106, 117] ``` # Requirements: * Validate all inputs before performing operations (raise exceptions for invalid operations). * Ensure efficient and clear implementations for each method. * Include comments and docstrings to explain the logic where necessary. # Notes: * You may use any standard Python libraries for matrix operations. * Test edge cases, such as non-compatible dimensions for operations or empty matrices. **Good luck!**","solution":"class Matrix: def __init__(self, data: list): Initialize the matrix with a 2D list. self.data = data def add(self, other: \'Matrix\') -> \'Matrix\': Add two matrices. if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]): raise ValueError(\\"Matrices must have the same dimensions for addition.\\") result = [ [self.data[i][j] + other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data)) ] return Matrix(result) def subtract(self, other: \'Matrix\') -> \'Matrix\': Subtract another matrix from the current matrix. if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]): raise ValueError(\\"Matrices must have the same dimensions for subtraction.\\") result = [ [self.data[i][j] - other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data)) ] return Matrix(result) def multiply(self, other: \'Matrix\') -> \'Matrix\': Multiply the current matrix with another matrix. if len(self.data[0]) != len(other.data): raise ValueError(\\"Number of columns in the first matrix must be equal to the number of rows in the second matrix.\\") result = [ [ sum(self.data[i][k] * other.data[k][j] for k in range(len(self.data[0]))) for j in range(len(other.data[0])) ] for i in range(len(self.data)) ] return Matrix(result) def transpose(self) -> \'Matrix\': Return the transpose of the matrix. result = [ [self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0])) ] return Matrix(result) def __str__(self) -> str: Return the string representation of the matrix. return \'n\'.join([\' \'.join(map(str, row)) for row in self.data])"},{"question":"# Coding Assessment Question Context: In graph theory, a tree is a connected acyclic graph. The diameter of a tree is the length of the longest path between any two nodes in the tree. The length of a path is the number of edges in the path. Problem Statement: Given a tree represented as an undirected graph with `N` nodes and `N-1` edges, write a function to calculate its diameter. Function Signature: ```python def tree_diameter(edges: List[Tuple[int, int]]) -> int: pass ``` Input: - List of tuples `edges`, where each tuple `(u, v)` represents an undirected edge between nodes `u` and `v`. Output: - An integer representing the diameter of the tree. Example: 1. **Input**: `edges = [(1, 2), (2, 3), (2, 4), (4, 5)]` **Output**: `3` 2. **Input**: `edges = [(1, 2), (2, 3), (1, 4), (4, 5), (4, 6)]` **Output**: `4` Constraints: - `3 ≤ N ≤ 10^5`, where `N` is the number of nodes. - Let node IDs be integers from 1 to N. Note: - A common algorithm to find the diameter of a tree involves running a Breadth-First Search (BFS) from an arbitrary node to find the farthest node, then running another BFS from that farthest node to determine the diameter. Write the Python function to solve this problem.","solution":"from collections import deque, defaultdict def tree_diameter(edges): if not edges: return 0 def bfs(start_node): queue = deque([start_node]) distances = {start_node: 0} farthest_node = start_node while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in distances: queue.append(neighbor) distances[neighbor] = distances[node] + 1 if distances[neighbor] > distances[farthest_node]: farthest_node = neighbor return farthest_node, distances[farthest_node] # Create the graph from the edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Start BFS from an arbitrary node (node 1) start_node = edges[0][0] farthest_node, _ = bfs(start_node) # Perform BFS again from the farthest node found other_end, diameter = bfs(farthest_node) return diameter"},{"question":"# Fibonacci Sequence Generator You are developing a sequence analysis tool that involves generating the Fibonacci sequence up to a given number of terms. Using the function `fibonacci_sequence(n: int) -> List[int]`, write a program that computes the first `n` terms of the Fibonacci sequence and returns them as a list. Ensure that the input value is validated and the function handles non-positive values appropriately by raising a `ValueError`. Function Signature: ```python def fibonacci_sequence(n: int) -> List[int]: pass ``` Input: - `n`: An integer representing the number of terms in the Fibonacci sequence. Output: - Returns a list of integers where each value is a term in the Fibonacci sequence up to the `n`th term. Constraints: - (1 leq n leq 93) - The function should handle invalid inputs by raising a `ValueError`. Example: ```python >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] ``` # Explanation: 1. The first term of the Fibonacci sequence is 0. 2. The second term is 1. 3. Each subsequent term is the sum of the two preceding ones. - For `n = 5`, the first 5 terms are [0, 1, 1, 2, 3]. Try to implement the `fibonacci_sequence` function and ensure it considers all edge cases and input constraints.","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. :param n: Number of terms to generate in the Fibonacci sequence. :type n: int :return: List of the first n terms of the Fibonacci sequence. :rtype: List[int] :raises ValueError: If n is not a positive integer. if n <= 0: raise ValueError(\\"The number of terms must be a positive integer.\\") sequence = [] a, b = 0, 1 for _ in range(n): sequence.append(a) a, b = b, a + b return sequence"},{"question":"# Predicting House Prices using Random Forest Context You are given a dataset containing various features of houses along with their corresponding prices. Your task is to predict the price of houses using a Random Forest regressor model. Task Implement a function `train_house_price_model` that: 1. Reads the house pricing data from a CSV file. 2. Splits the data into training and testing sets. 3. Trains a Random Forest regressor on the training set. 4. Evaluates the model\'s performance on the test set. 5. Returns the trained model and the Mean Absolute Error (MAE) of the predictions. # Function Signature ```python def train_house_price_model(data_file: str, test_size: float, n_estimators: int, random_state: int) -> Tuple[RandomForestRegressor, float]: ``` # Input 1. `data_file`: (str) Path to the CSV file containing house price data. Assume the target (price) is in the last column and feature data is in preceding columns. 2. `test_size`: (float) Proportion of the dataset to include in the test split. 3. `n_estimators`: (int) Number of trees in the forest. 4. `random_state`: (int) Seed used by the random number generator. # Output Returns a tuple containing: 1. The trained RandomForestRegressor model. 2. The Mean Absolute Error (MAE) of the model on the test set. # Constraints * The CSV file is well-formatted and contains no missing values or non-numeric data in feature columns. * Ensure that you appropriately handle any potential overfitting. Example ```python model, mae = train_house_price_model(\\"house_prices.csv\\", test_size=0.2, n_estimators=100, random_state=42) ``` Use the provided code as a reference for your implementation and be sure to follow all principles discussed. # Notes: * Consider using `train_test_split` from `sklearn.model_selection` for splitting the data. * Use `RandomForestRegressor` from `sklearn.ensemble`. * Compute the Mean Absolute Error (MAE) using `mean_absolute_error` from `sklearn.metrics`. --- This question examines your ability to handle data preprocessing, model training, performance evaluation, and implementation of an ensemble learning technique in a way that is analogous to the provided stock price prediction problem.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_absolute_error from typing import Tuple def train_house_price_model(data_file: str, test_size: float, n_estimators: int, random_state: int) -> Tuple[RandomForestRegressor, float]: # Read the house pricing data from a CSV file data = pd.read_csv(data_file) # Assuming the target (price) is in the last column and feature data is in preceding columns X = data.iloc[:, :-1] y = data.iloc[:, -1] # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state) # Train a Random Forest regressor on the training set model = RandomForestRegressor(n_estimators=n_estimators, random_state=random_state) model.fit(X_train, y_train) # Predict house prices on the test set y_pred = model.predict(X_test) # Evaluate the model\'s performance using Mean Absolute Error (MAE) mae = mean_absolute_error(y_test, y_pred) return model, mae"},{"question":"# Coding Challenge: Implement an Expression Evaluator **Scenario**: You are developing a simple calculator application. Your first task is to implement an expression evaluator that can parse and compute the result of mathematical expressions provided as strings. **Objective**: Implement the `ExpressionEvaluator` class, including methods to tokenize, parse, and evaluate mathematical expressions consisting of addition, subtraction, multiplication, and division. **Requirements**: 1. Implement the `ExpressionEvaluator` class. 2. Implement the `evaluate` method to compute the result of a given mathematical expression. **Function Signature**: ```python class ExpressionEvaluator: def __init__(self): ... def evaluate(self, expression: str) -> float: ... ``` **Expected Input and Output**: - `__init__(self)`: Initializes the evaluator instance. - `evaluate(self, expression: str) -> float`: Computes and returns the result of the given mathematical expression. **Constraints**: - The expression will consist of digits (0-9), four arithmetic operators (+, -, *, /), parentheses, and spaces. - The length of the expression will be in the range [1, 1000]. - The division operator \'/\' will always be integer division. - The expressions are guaranteed to be valid. **Performance Requirements**: - Tokenization, parsing, and evaluation should be efficient and able to handle expressions within the constraints smoothly. **Testing**: Your implementation should be verified by the following tests: 1. Evaluating simple expressions (e.g., \\"3+5\\"). 2. Evaluating expressions with multiple operators (e.g., \\"3+5*2\\"). 3. Evaluating expressions with parentheses (e.g., \\"(3+5)*2\\"). 4. Evaluating expressions with spaces (e.g., \\" 3 + 5 * 2 \\"). 5. Evaluating complex nested expressions (e.g., \\"((3+5)*2)/(2-3)\\"). Implement the `ExpressionEvaluator` class and `evaluate` method, ensuring your solution passes the described tests.","solution":"class ExpressionEvaluator: def __init__(self): pass def evaluate(self, expression: str) -> float: def get_number(): nonlocal i num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 return num def get_term(): nonlocal i num = get_factor() while i < len(expression) and expression[i] in \\"*/\\": if expression[i] == \'*\': i += 1 num *= get_factor() elif expression[i] == \'/\': i += 1 num //= get_factor() return num def get_factor(): nonlocal i if expression[i] == \'(\': i += 1 num = get_expression() i += 1 # skip closing parenthesis return num else: return get_number() def get_expression(): nonlocal i num = get_term() while i < len(expression) and expression[i] in \\"+-\\": if expression[i] == \'+\': i += 1 num += get_term() elif expression[i] == \'-\': i += 1 num -= get_term() return num i = 0 expression = expression.replace(\' \', \'\') return get_expression()"},{"question":"# Depth-First Search (DFS) for Connected Components **Scenario**: As a network engineer, you are analyzing the network topology to determine the number of isolated subnetworks (connected components) within a large network graph. **Task**: Implement a Depth-First Search (DFS) algorithm to find the number of connected components in an undirected graph. The graph is represented as an adjacency list. **Function Signature**: ```python def count_connected_components(graph: dict) -> int: ``` # Requirements: 1. **Input**: * A dictionary, `graph`, where keys represent nodes and values are lists of connected nodes. Each node in the graph is represented by an integer. * The graph can contain up to 10^5 nodes and 10^6 edges. 2. **Output**: * An integer representing the number of connected components in the graph. 3. **Constraints**: * Nodes are uniquely identified by integers. * The graph is undirected and may be disconnected. * Handle graphs with no nodes or edges appropriately. # Example: ```python >>> count_connected_components({ 0: [1, 2], 1: [0], 2: [0, 3], 3: [2], 4: [] # isolated node }) 2 >>> count_connected_components({ 0: [1], 1: [0, 2], 2: [1, 3, 4], 3: [2, 4], 4: [2, 3], }) 1 >>> count_connected_components({}) 0 >>> count_connected_components({ 0: [1, 2, 3, 4], 1: [0], 2: [0], 3: [0], 4: [0] }) 1 ``` # Notes: * **Edge Cases**: Pay attention to edge cases like empty graphs, graphs with isolated nodes, and graphs that are already fully connected. * **Performance**: The algorithm should efficiently process large graphs. Implement your function below: ```python def count_connected_components(graph: dict) -> int: visited = set() def dfs(node): if node not in visited: visited.add(node) for neighbor in graph[node]: dfs(neighbor) count = 0 for node in graph: if node not in visited: dfs(node) count += 1 return count # Return the number of connected components in the graph ```","solution":"def count_connected_components(graph: dict) -> int: visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: stack.append(neighbor) count = 0 for node in graph: if node not in visited: dfs(node) count += 1 # Check for isolated nodes that are not connected to any other node count += len([node for node in graph if not graph[node] and node not in visited]) return count"},{"question":"# Log File Parser and Analyzer You are given a log file in plain text format, where each line represents a log entry. Each log entry includes the timestamp, log level, and a message, all separated by a pipe (`|`) symbol. Your task is to implement a log file parser and analyzer with the following features: * **Log Filtering**: Extract log entries that match a specified log level (e.g., \\"ERROR\\", \\"INFO\\"). * **Count Log Levels**: Count the occurrences of each log level in the log file. * **Time Range Filtering**: Extract log entries that fall within a specified time range. # Input - The path to the log file as a string. - The log level for filtering as a string (optional). - The start time of the time range as a string in \\"YYYY-MM-DD HH:MM:SS\\" format (optional). - The end time of the time range as a string in \\"YYYY-MM-DD HH:MM:SS\\" format (optional). # Output - A list of log entries that match the filtering criteria. - A dictionary with log levels as keys and their counts as values. # Constraints - Assume that the log file is well-formed and that each line follows the specified format. - The timestamp in the log file is in \\"YYYY-MM-DD HH:MM:SS\\" format. - The log file size can be large, e.g., up to 10MB. # Example ```python # Example log file content 2023-10-01 14:45:00|INFO|Started processing 2023-10-01 14:46:01|ERROR|Failed to process request 2023-10-01 14:47:02|DEBUG|Running garbage collection 2023-10-01 14:48:03|INFO|Completed processing # Example main invocation if __name__ == \\"__main__\\": log_file_path = \\"system.log\\" log_level = \\"ERROR\\" start_time = \\"2023-10-01 14:45:00\\" end_time = \\"2023-10-01 14:50:00\\" filtered_logs = filter_logs(log_file_path, log_level=log_level, start_time=start_time, end_time=end_time) log_counts = count_log_levels(log_file_path) print(\\"Filtered Logs:\\", filtered_logs) print(\\"Log Level Counts:\\", log_counts) ``` **Note**: Assume that appropriate libraries (e.g., datetime) are available and used appropriately in your implementation.","solution":"import datetime def parse_log_line(line): timestamp, level, message = line.strip().split(\'|\', 2) return datetime.datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\"), level, message def filter_logs(file_path, log_level=None, start_time=None, end_time=None): start_time = datetime.datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") if start_time else None end_time = datetime.datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") if end_time else None filtered_logs = [] with open(file_path, \'r\') as log_file: for line in log_file: timestamp, level, message = parse_log_line(line) if log_level and level != log_level: continue if start_time and timestamp < start_time: continue if end_time and timestamp > end_time: continue filtered_logs.append(line.strip()) return filtered_logs def count_log_levels(file_path): log_level_count = {} with open(file_path, \'r\') as log_file: for line in log_file: _, level, _ = parse_log_line(line) if level in log_level_count: log_level_count[level] += 1 else: log_level_count[level] = 1 return log_level_count"},{"question":"# Question: Implement a Merge Sorted Linked List Function You are tasked with implementing a function that merges two sorted linked lists into a single sorted linked list. You should maintain the relative order of the elements from both lists while merging them. Requirements 1. **Function Name**: merge_sorted_lists 2. **Input**: Two linked lists, represented by the `Node` class, where each linked list is sorted in non-decreasing order. 3. **Output**: A new linked list that contains all elements from both input lists, sorted in non-decreasing order. Node Class Definition ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Constraints 1. You may not use any additional data structures or modify the values within the nodes. 2. Ensure the implementation efficiently handles edge cases, such as one or both input lists being empty. Example ```python # Helper function to create linked list from a list def create_linked_list(lst): dummy = Node() current = dummy for val in lst: current.next = Node(val) current = current.next return dummy.next # Helper function to convert linked list back to a list def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result # Example usage list1 = create_linked_list([1, 3, 5]) list2 = create_linked_list([2, 4, 6]) merged_list = merge_sorted_lists(list1, list2) print(linked_list_to_list(merged_list)) # Output: [1, 2, 3, 4, 5, 6] list3 = create_linked_list([1]) list4 = create_linked_list([2, 3, 4]) merged_list = merge_sorted_lists(list3, list4) print(linked_list_to_list(merged_list)) # Output: [1, 2, 3, 4] ``` Guidelines - Implement a helper function to traverse and combine the two lists efficiently. - Handle the edge cases where one or both lists are empty within the main function.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_lists(list1, list2): dummy = Node() current = dummy while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 elif list2: current.next = list2 return dummy.next # Helper function to create linked list from a list def create_linked_list(lst): dummy = Node() current = dummy for val in lst: current.next = Node(val) current = current.next return dummy.next # Helper function to convert linked list back to a list def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"# Scenario You are developing a tool for a library to manage book information. The tool will process a list of book records and classify them according to various characteristics. # Problem Statement Write a function `classify_books(books: List[Dict[str, str]]) -> Dict[str, List[str]]` that takes a list of book records (each being a dictionary with specific attributes) and categorizes them into multiple lists based on the following conditions: 1. Books by authors with names containing digits. 2. Books classified as \\"fiction\\". 3. Books whose titles contain special characters (such as `!`, `@`, `#`, etc.). 4. Books published in the 21st century (from the year 2000 onwards). 5. Books with titles starting with the letter \\"A\\". Each book record dictionary contains the following keys: - `title` (str): The title of the book. - `author` (str): The author\'s name. - `genre` (str): The genre of the book. - `year` (str): The publication year of the book. Additionally, implement a check to ignore any books with invalid year (not a 4-digit number) or empty mandatory fields (title, author, genre, or year). Input * `books` (List of dictionaries): A list of book records, each being a dictionary with keys: `title`, `author`, `genre`, and `year`. Output * `result` (Dictionary): A dictionary with keys [\\"author_digits\\", \\"fiction\\", \\"special_characters\\", \\"21st_century\\", \\"title_starts_with_A\\"] and values as lists of book titles that belong to those categories. Function Signature ```python def classify_books(books: List[Dict[str, str]]) -> Dict[str, List[str]]: pass ``` Constraints * Ignore any book records with invalid year (year not a 4-digit number) or empty mandatory fields. * The function should handle invalid or empty inputs gracefully. Example ```python books = [ {\\"title\\": \\"A Tale of Two Cities\\", \\"author\\": \\"Charles Dickens\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1859\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1949\\"}, {\\"title\\": \\"Br@ve New World\\", \\"author\\": \\"Aldous Huxley\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1932\\"}, {\\"title\\": \\"Dracula\\", \\"author\\": \\"Bram Stoker\\", \\"genre\\": \\"horror\\", \\"year\\": \\"1897\\"}, {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1951\\"}, {\\"title\\": \\"The Road\\", \\"author\\": \\"Cormac McCarthy\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"2006\\"}, {\\"title\\": \\"A00000\\", \\"author\\": \\"Author7\\", \\"genre\\": \\"drama\\", \\"year\\": \\"2000\\"}, ] expected_output = { \\"author_digits\\": [\\"A00000\\"], \\"fiction\\": [\\"A Tale of Two Cities\\", \\"1984\\", \\"Br@ve New World\\", \\"The Catcher in the Rye\\", \\"The Road\\"], \\"special_characters\\": [\\"Br@ve New World\\"], \\"21st_century\\": [\\"The Road\\", \\"A00000\\"], \\"title_starts_with_A\\": [\\"A Tale of Two Cities\\", \\"A00000\\"], } result = classify_books(books) assert result == expected_output ``` Note Ensure your solution efficiently handles edge cases and large inputs. Document any assumptions made.","solution":"import re from typing import List, Dict def classify_books(books: List[Dict[str, str]]) -> Dict[str, List[str]]: classified_books = { \\"author_digits\\": [], \\"fiction\\": [], \\"special_characters\\": [], \\"21st_century\\": [], \\"title_starts_with_A\\": [] } for book in books: title = book.get(\\"title\\", \\"\\") author = book.get(\\"author\\", \\"\\") genre = book.get(\\"genre\\", \\"\\") year = book.get(\\"year\\", \\"\\") if not title or not author or not genre or not year or not (year.isdigit() and len(year) == 4): continue year = int(year) if re.search(r\'d\', author): classified_books[\\"author_digits\\"].append(title) if genre.lower() == \\"fiction\\": classified_books[\\"fiction\\"].append(title) if re.search(r\'[!@#%^&*()_+-=[]{}|:;\\"\',<>./?]\', title): classified_books[\\"special_characters\\"].append(title) if year >= 2000: classified_books[\\"21st_century\\"].append(title) if title.startswith(\\"A\\"): classified_books[\\"title_starts_with_A\\"].append(title) return classified_books"},{"question":"# String Compression **Context**: You are working on optimizing storage for strings by implementing a basic form of data compression. Your goal is to compress a given string by using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would become \\"a2b1c5a3\\". If the compressed string is not shorter than the original string, return the original string. **Task**: Implement the function `compress_string(s: str) -> str` that compresses the given string if the compressed version is shorter, otherwise returns the original string. **Input**: - `s`: A string containing only uppercase and lowercase English letters. **Output**: - Return the compressed string if it is shorter than the original string, otherwise return the original string. **Constraints**: - The input string `s` will have a length between 0 and 10^5. - The string will only contain English letters (both uppercase and lowercase). **Examples**: ```python >>> compress_string(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> compress_string(\\"abcd\\") \'abcd\' >>> compress_string(\\"aabbcc\\") \'aabbcc\' >>> compress_string(\\"aabbccc\\") \'a2b2c3\' ``` **Hints**: - Use a two-pointer approach to traverse the string. - Maintain a result list to build the compressed string. - Track the current character and its count during traversal.","solution":"def compress_string(s: str) -> str: Compresses the given string using the counts of repeated characters. :param s: The input string containing only uppercase and lowercase English letters. :return: The compressed string if it is shorter, otherwise the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Append the last character and count compressed.append(s[-1] + str(count)) # Convert the list to a string compressed_str = \'\'.join(compressed) # Return the original string if the compressed version is not shorter return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Question Context In many computational problems, working with powers of numbers and identifying special properties of numbers like being a power of another can be important. Powers of 2, for instance, are used in binary systems and often in algorithmic optimizations. Task Write a function `is_power_of_two` that checks whether a given integer is a power of 2. Function Signature ```python def is_power_of_two(n: int) -> bool: ``` Input * `n` – An integer. Output * Return `True` if the integer is a power of 2. * Return `False` otherwise. Constraints * The integer `n` can range from `-10^18` to `10^18`. Examples ```python assert is_power_of_two(1) == True # 2^0 is 1 assert is_power_of_two(2) == True # 2^1 is 2 assert is_power_of_two(16) == True # 2^4 is 16 assert is_power_of_two(18) == False # 18 is not a power of 2 assert is_power_of_two(-4) == False # No negative power of 2 is possible ``` Explanation * A number `n` is a power of 2 if it is greater than `0` and there is only one bit set in its binary representation. * Use bitwise operations to determine if `n` has exactly one \'1\' bit, such as leveraging `n & (n - 1) == 0` for positive integers.","solution":"def is_power_of_two(n: int) -> bool: Checks if the given integer is a power of 2. Parameters: n (int): The integer to check. Returns: bool: True if n is a power of 2, otherwise False. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Question: Deepest Leaves Sum Given the root of a binary tree, return the sum of values of its deepest leaves. Use a breadth-first traversal to traverse the tree level by level. Function Signature: ```python def deepest_leaves_sum(root: Node) -> int: pass ``` Input: - `root`: The root node of the binary tree, which can be `None` for an empty tree. Output: - An integer representing the sum of the values of the deepest leaves. Constraints: - Tree can be empty, in which case the sum is 0. - You must achieve (O(n)) time complexity where (n) is the number of nodes in the tree. # Example: ```python # Example 1: # Construct the following binary tree # 1 # / # 2 3 # /| # 4 5 6 # # 7 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) root.right.right.right = Node(7) assert deepest_leaves_sum(root) == 7 # Example 2: # Construct the following binary tree # 1 # / # 2 3 # / # 4 5 # / # 7 8 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.left.left.left = Node(7) root.left.right.right = Node(8) assert deepest_leaves_sum(root) == 15 # deepest leaves are 7 and 8, their sum is 15 ``` # Notes: - You may define additional helper functions if necessary. - Make sure to handle edge cases like an empty tree or trees with only one node.","solution":"from collections import deque class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepest_leaves_sum(root: Node) -> int: if not root: return 0 queue = deque([root]) level_sum = 0 while queue: level_sum = 0 size = len(queue) for _ in range(size): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"# Coding Assessment Question Your task is to implement the following function: ```python def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent following the mapping of a traditional phone keypad. Args: digits: A string of digits ranging from 2 to 9 (inclusive). Returns: A list of all possible letter combinations that can be formed with the input digits. # Your implementation here pass ``` # Detailed Specifications and Constraints: 1. **Input**: - `digits` (str): A string containing digits from \'2\' to \'9\'. The length of the string will be in the range [0, 4]. 2. **Output**: - Returns a list of strings where each string represents one possible letter combination. 3. **Edge Cases**: - An empty input string should return an empty list. - Input with a single digit should return the corresponding letters. - Multiple digits should be combined to form complete letter combinations. 4. **Performance Requirements**: - The function should run efficiently even for the upper limit of input size. - Consider optimizing the generation of combinations. # Testing: Use the following test cases to validate your implementation: ```python assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] assert sorted(letter_combinations(\\"23\\")) == sorted([ \\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\" ]) assert sorted(letter_combinations(\\"7\\")) == sorted([\\"p\\", \\"q\\", \\"r\\", \\"s\\"]) assert sorted(letter_combinations(\\"923\\")) == sorted([ \\"wac\\", \\"wad\\", \\"wad\\", \\"wae\\", \\"waf\\", \\"wbd\\", \\"wbe\\", \\"wbf\\", \\"wcd\\", \\"wce\\", \\"wcf\\", \\"xac\\", \\"xad\\", \\"xae\\", \\"xaf\\", \\"xbd\\", \\"xbe\\", \\"xbf\\", \\"xcd\\", \\"xce\\", \\"xcf\\", \\"yac\\", \\"yad\\", \\"yae\\", \\"yaf\\", \\"ybd\\", \\"ybe\\", \\"ybf\\", \\"ycd\\", \\"yce\\", \\"ycf\\", \\"zac\\", \\"zad\\", \\"zae\\", \\"zaf\\", \\"zbd\\", \\"zbe\\", \\"zbf\\", \\"zcd\\", \\"zce\\", \\"zcf\\" ]) ``` Feel free to add more test cases to thoroughly validate edge cases and ensure the accuracy of your implementation.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent following the mapping of a traditional phone keypad. Args: digits: A string of digits ranging from 2 to 9 (inclusive). Returns: A list of all possible letter combinations that can be formed with the input digits. if not digits: return [] # Mapping of digit to letters (as on a phone keypad) digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): # If the path is the same length as digits, append the result if index == len(digits): combinations.append(\'\'.join(path)) return # Get the letters that the current digit maps to, and loop through them possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() # backtrack combinations = [] backtrack(0, []) return combinations"},{"question":"# Number Sequence Finder **Context**: A common programming task involves finding patterns or specific elements within sequences. This problem requires identifying a particular sequence of numbers within a given list of integers. The task will assess the ability to manipulate lists, use loops efficiently, and understand sequence detection. **Objective**: Write a function that identifies if a specific sequence of numbers (subsequence) exists within a given list of integers. The function should return `True` if the sequence is found and `False` otherwise. # Function Signature ```python def find_sequence(lst: list, sequence: list) -> bool: Determine if the specific sequence of numbers exists in the given list. Parameters: - lst (list): The list of integers to be searched. - sequence (list): The subsequence to find within the list. Returns: - bool: `True` if the sequence exists in the list, `False` otherwise. Examples: >>> find_sequence([1, 2, 3, 4, 5], [2, 3, 4]) True >>> find_sequence([10, 11, 12, 13, 14], [12, 14]) False >>> find_sequence([5, 6, 7, 8, 9], [8, 9]) True >>> find_sequence([1, 3, 5, 7], [3, 5, 6]) False >>> find_sequence([], [1, 2, 3]) False >>> find_sequence([1, 1, 1, 1], [1, 1]) True pass ``` # Constraints * The `sequence` and `lst` will always contain integers and not be empty. * The `lst` can be of any length, including zero. * Maintain a time complexity of O(n*m) where n is the length of `lst` and m is the length of the `sequence`. # Requirements * Complete the `find_sequence(lst: list, sequence: list) -> bool` function to achieve the objectives as described. * Ensure the implementation is efficient and performs well even for larger lists and sequences.","solution":"def find_sequence(lst: list, sequence: list) -> bool: Determine if the specific sequence of numbers exists in the given list. Parameters: - lst (list): The list of integers to be searched. - sequence (list): The subsequence to find within the list. Returns: - bool: `True` if the sequence exists in the list, `False` otherwise. len_lst = len(lst) len_seq = len(sequence) if len_seq == 0: return True for i in range(len_lst - len_seq + 1): if lst[i:i + len_seq] == sequence: return True return False"},{"question":"# Airport Bag Distribution System **Problem Statement**: You are tasked with designing an airport bag distribution system. Your function should determine how to distribute a given number of bags across available storage units while ensuring that the number of bags in each unit is balanced as evenly as possible. **Function Signature**: ```python def distribute_bags(total_bags: int, num_units: int) -> list[int]: pass ``` **Requirements**: 1. The function should distribute the given `total_bags` into `num_units`. 2. Each unit should have a nearly equal number of bags, with the difference between the maximum and minimum number of bags across units being no more than one. 3. If there are more units than bags, the excess units should have zero bags. 4. Return a list where the `i-th` element indicates the number of bags in the `i-th` unit. **Input**: * `total_bags` (int): The total number of bags to distribute. Assumed to be non-negative. * `num_units` (int): The number of available storage units. Assumed to be positive. **Output**: * `list`: A list of integers where each integer represents the number of bags in the corresponding storage unit. **Constraints**: * Number of units should be greater than 0. * The function should handle cases where the number of bags is zero. **Examples**: ```python >>> distribute_bags(10, 3) [4, 3, 3] >>> distribute_bags(4, 5) [1, 1, 1, 1, 0] >>> distribute_bags(15, 4) [4, 4, 4, 3] >>> distribute_bags(0, 2) [0, 0] ``` **Note**: - The function should aim for a balanced distribution of bags across the units. - Validate the correctness of the function by ensuring that the sum of all elements in the output list equals `total_bags`.","solution":"def distribute_bags(total_bags: int, num_units: int) -> list[int]: Distribute total_bags among num_units as evenly as possible. Args: total_bags (int): Total number of bags to distribute. num_units (int): Number of available storage units. Returns: list[int]: List where the ith element represents the number of bags in the ith unit. # Initialize an array of zeros with length equal to the number of storage units. distribution = [0] * num_units # Distribute the bags for i in range(total_bags): distribution[i % num_units] += 1 return distribution"},{"question":"# Problem Statement Implement a function `count_connected_components(graph: list[list[int]]) -> int` that computes and returns the number of connected components in an undirected graph represented by an adjacency list. # Implementation Details * **Input Format**: A list of lists `graph`, where `graph[i]` contains the nodes that are directly connected to node `i`. * The nodes are zero-indexed. * **Output Format**: An integer representing the number of connected components in the graph. * **Constraints**: * The graph can have up to `10^5` nodes. * Each node can have up to `10^5` edges. * **Performance Requirements**: * The function should handle large graphs efficiently, with an optimal time complexity. # Example ```python >>> count_connected_components([[1,2], [0,3], [0,3], [1,2]]) 1 >>> count_connected_components([[1], [0], [3], [2]]) 2 >>> count_connected_components([[], []]) 2 >>> count_connected_components([[], [2], [1, 3], [2]]) 2 ``` # Explanation The function `count_connected_components` should correctly determine the number of connected components in various graph structures, including edge cases with isolated nodes and fully connected components. To achieve efficiency, consider employing Depth-First Search (DFS) or Breadth-First Search (BFS) to explore all reachable nodes from each unvisited starting node.","solution":"def count_connected_components(graph): Returns the number of connected components in an undirected graph represented by an adjacency list. def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() num_components = 0 for i in range(len(graph)): if i not in visited: num_components += 1 visited.add(i) dfs(i, visited) return num_components"},{"question":"# Scenario A software engineer is working on a web application that involves a lot of string manipulations. One frequent operation is to determine whether a given string can be converted into a palindrome by removing at most one character. This feature is essential for providing suggestions for auto-correction in text input fields. # Task Write a Python function `can_form_palindrome(s: str) -> bool` that determines whether it is possible to rearrange a given string into a palindrome by removing at most one character. # Requirements - The function should return `True` if the string can be rearranged into a palindrome by deleting at most one character, and `False` otherwise. - Handle both lowercase and uppercase letters and consider them distinct. # Input and Output - **Input**: A single string `s` where 1 <= `len(s)` <= 10^5 - **Output**: A boolean value indicating whether the string can be rearranged into a palindrome after removing at most one character. # Constraints - The input string will contain only ASCII characters. # Examples ```python >>> can_form_palindrome(\\"abca\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abcdef\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aa\\") True ``` # Notes - Consider using two-pointer technique to check the potential removal scenarios efficiently.","solution":"def can_form_palindrome(s: str) -> bool: def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) i, j = i + 1, j - 1 return True"},{"question":"# Subject: String Manipulation and Pattern Matching You are tasked to implement a function that finds and returns all the starting indices of the substrings in a text that match a given pattern. # Description Given a text string and a pattern string, you need to find and return the list of starting indices of all the substrings in the text that match the pattern. # Implementation Functions 1. **`find_pattern_occurrences(text: str, pattern: str) -> List[int]`**: - **Input**: - `text`: A string (where (1 leq text{len(text)} leq 10^5)) - `pattern`: A string (where (1 leq text{len(pattern)} leq 10^4)) - **Output**: Returns a list of integers representing the starting indices of the substrings in the text that match the given pattern. # Function Definition ```python from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds and returns the starting indices of all the substrings in the text that match the pattern. Args: text (str): The text string where to search for the pattern. pattern (str): The pattern string to match. Returns: List[int]: A list of starting indices where the pattern is found in the text. pass ``` # Requirements - Do not use any external libraries except for `typing`. - Ensure your code is efficient and handles edge cases appropriately. # Examples ```python # Example 1 print(find_pattern_occurrences(\\"abracadabra\\", \\"abra\\")) # Should return [0, 7] # Example 2 print(find_pattern_occurrences(\\"aaaaa\\", \\"aa\\")) # Should return [0, 1, 2, 3] # Example 3 print(find_pattern_occurrences(\\"mississippi\\", \\"issi\\")) # Should return [1, 4] ``` Ensure your code passes these tests and handle edge cases, such as when the pattern is not found in the text, or when the text is empty. # Constraints - The algorithm should be efficient enough to handle the large input size within a reasonable time complexity. - Do not assume that the text and pattern will always be lowercase; consider both uppercase and lowercase letters.","solution":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds and returns the starting indices of all the substrings in the text that match the pattern. Args: text (str): The text string where to search for the pattern. pattern (str): The pattern string to match. Returns: List[int]: A list of starting indices where the pattern is found in the text. if not text or not pattern: return [] pattern_length = len(pattern) results = [] for i in range(len(text) - pattern_length + 1): if text[i:i+pattern_length] == pattern: results.append(i) return results"},{"question":"# Problem Statement You are given a string consisting of \'a\', \'b\', and \'c\'. Your task is to implement a function to determine if it is possible to rearrange the characters of the string so that no two adjacent characters are the same. If such an arrangement is possible, return the rearranged string; otherwise, return an empty string. # Function Signature ```python def rearrange_string(s: str) -> str: ``` # Input - `s`: A string consisting only of the characters \'a\', \'b\', and \'c\'. The length of the string is at most 1000. # Output - A string with the same characters as the input string but rearranged such that no two adjacent characters are the same, or an empty string if no such arrangement exists. # Examples ```python # Example 1 s = \\"aab\\" print(rearrange_string(s)) # Output: \\"aba\\" # Example 2 s = \\"aaaa\\" print(rearrange_string(s)) # Output: \\"\\" # Example 3 s = \\"aabbbcc\\" print(rearrange_string(s)) # Output: \\"abcabcb\\", or any valid rearranged string # Example 4 s = \\"aaabbbcc\\" print(rearrange_string(s)) # Output: \\"abacbcba\\", or any valid rearranged string # Example 5 s = \\"abc\\" print(rearrange_string(s)) # Output: \\"abc\\", or any valid rearranged string ``` # Notes 1. If the rearrangement is possible, there may be multiple valid answers, any of which are acceptable. 2. Consider edge cases where the number of occurrences of one character significantly exceeds that of the others. # Constraints - The string length will be at most 1000. - The string consists only of the characters \'a\', \'b\', and \'c\'.","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: frequency = Counter(s) max_heap = [(-freq, char) for char, freq in frequency.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if not max_heap and prev_freq < 0: return \\"\\" if max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 return \\"\\".join(result)"},{"question":"# Arm-strong Numbers: Check & List Scenario You need to write a program to identify and list Armstrong numbers within a given range. An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. Input and Output * Input: * Two integers `start` and `end` representing the inclusive range within which to find Armstrong numbers. * Output: * A list of integers representing all Armstrong numbers within the given range. Constraints * The start and end of the range will always be positive integers where `1 <= start <= end <= 10^6`. * The algorithm should have a time complexity suitable for large values of `end` (up to 10^6). Functions Definition ```python def is_armstrong_number(num: int) -> bool: Check if the given number is an Armstrong number. Args: num (int): The number to check. Returns: bool: True if the number is an Armstrong number, False otherwise. # Implementation goes here def list_armstrong_numbers(start: int, end: int) -> list[int]: List all Armstrong numbers within the given range. Args: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). Returns: list[int]: A list of all Armstrong numbers within the range. # Implementation goes here ``` Implement the above methods so that the performance of the functions is optimal for larger ranges. Example ```python # Example 1: start, end = 1, 500 print(list_armstrong_numbers(start, end)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407] # Example 2: start, end = 100, 1000 print(list_armstrong_numbers(start, end)) # Output: [153, 370, 371, 407] ```","solution":"def is_armstrong_number(num: int) -> bool: Check if the given number is an Armstrong number. Args: num (int): The number to check. Returns: bool: True if the number is an Armstrong number, False otherwise. digits = [int(d) for d in str(num)] n = len(digits) return num == sum(d ** n for d in digits) def list_armstrong_numbers(start: int, end: int) -> list[int]: List all Armstrong numbers within the given range. Args: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). Returns: list[int]: A list of all Armstrong numbers within the range. return [num for num in range(start, end + 1) if is_armstrong_number(num)]"},{"question":"# Coding Assessment Question Context: You are tasked with building a part of a logistics system that organizes shipping containers efficiently. The system needs to determine whether it\'s possible to distribute a given list of container weights into two groups with equal total weight. This ensures balanced loads on different transport vehicles. Task: Write a function `can_partition` that takes a list of integers `containers`. The function should return a boolean indicating whether the containers can be partitioned into two groups of equal weight. Function Signature: ```python def can_partition(containers: list[int]) -> bool: ``` Input: * `containers`: A list of integers where each integer represents the weight of a container. Output: * A boolean indicating whether it is possible to partition the containers into two groups with an equal sum. Constraints: * The length of the list `containers` will be between 1 and 200. * Each container weight will be a positive integer less than or equal to 100. Examples: ```python can_partition([1, 5, 11, 5]) => True # Two groups: [1, 5, 5] and [11] can_partition([1, 2, 3, 5]) => False # Cannot be partitioned into two groups with equal sum can_partition([1, 1, 1, 1, 2, 2]) => True # Two groups: [1, 1, 2] and [1, 1, 2] can_partition([3, 3, 3, 4, 5]) => True # Two groups: [3, 3, 4] and [3, 5] can_partition([5, 5, 5, 10, 20]) => False # Cannot be partitioned into two groups with equal sum ``` Scenario: You are working on the backend for a shipping company that automatically allocates the loads onto trucks. Utilize your function to ensure that the cargo is evenly distributed by weight across two different trucks for optimal balance and handling.","solution":"def can_partition(containers: list[int]) -> bool: total_weight = sum(containers) # If the total weight is odd, it cannot be split into two equal parts if total_weight % 2 != 0: return False target = total_weight // 2 n = len(containers) # Create a boolean DP array to check for possible sums dp = [False] * (target + 1) dp[0] = True for weight in containers: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return dp[target]"},{"question":"# Coding Assessment: Genetic Algorithm for 2D Function Optimization Problem Statement You are provided with an implementation of a Genetic Algorithm for optimizing a one-dimensional function. Your task is to implement a similar optimization algorithm but for a two-dimensional function. Objectives 1. Implement a `genetic_algorithm_2d` function that optimizes a given function in two dimensions. 2. Your implementation should be able to find either the maximum or minimum value of the function based on a flag. 3. Implement a `SearchProblem2D` class with appropriate methods to support the optimization process. Input - **Function to Optimize**: A function `f(x, y)` that takes two arguments and returns a floating-point value. - **Initial Population**: A list of coordinate tuples representing the initial population. - **Bounds**: The minimum and maximum bounds for `x` and `y`. - **Algorithm Parameters**: Population size, mutation rate, crossover rate, number of generations, and a flag for finding maximum or minimum. Output - A state object with the optimized coordinates `(x, y)` and the corresponding function value. # Constraints 1. **Function Implementation**: Your `SearchProblem2D` class must have the following methods: - `__init__(self, x: float, y: float, function_to_optimize)` - `mutate(self, mutation_rate: float) -> \'SearchProblem2D\'` - `crossover(self, other: \'SearchProblem2D\') -> Tuple[\'SearchProblem2D\', \'SearchProblem2D\']` - `score(self) -> float` 2. **Genetic Algorithm**: Your `genetic_algorithm_2d` function must have the following signature: ```python def genetic_algorithm_2d( initial_population: List[SearchProblem2D], find_max: bool = True, max_x: float = math.inf, min_x: float = -math.inf, max_y: float = math.inf, min_y: float = -math.inf, population_size: int = 100, mutation_rate: float = 0.01, crossover_rate: float = 0.7, num_generations: int = 100 ) -> Any: ``` 3. **Performance Requirement**: Your implementation should efficiently converge to an optimal or near-optimal solution within a reasonable time frame for typical inputs. # Example Usage ```python # Define a sample function to optimize def function_to_optimize(x, y): return -((x-3)**2 + (y+2)**2) + 50 # Create initial population initial_population = [SearchProblem2D(x=random.uniform(-10, 10), y=random.uniform(-10, 10), function_to_optimize=function_to_optimize) for _ in range(100)] # Perform genetic algorithm result = genetic_algorithm_2d( initial_population, find_max=True, max_x=10, min_x=-10, max_y=10, min_y=-10 ) print(f\\"Optimal state: (x={result.x}, y={result.y}), value={result.score()}\\") ``` Ensure your function is well-tested with various 2D functions to validate its correctness and performance.","solution":"import random import math from typing import List, Tuple, Callable, Any class SearchProblem2D: def __init__(self, x: float, y: float, function_to_optimize: Callable[[float, float], float]): self.x = x self.y = y self.function_to_optimize = function_to_optimize def mutate(self, mutation_rate: float, min_x: float, max_x: float, min_y: float, max_y: float) -> \'SearchProblem2D\': new_x = self.x + mutation_rate * (random.uniform(-1, 1) * (max_x - min_x)) new_y = self.y + mutation_rate * (random.uniform(-1, 1) * (max_y - min_y)) new_x = min(max(min_x, new_x), max_x) new_y = min(max(min_y, new_y), max_y) return SearchProblem2D(new_x, new_y, self.function_to_optimize) def crossover(self, other: \'SearchProblem2D\') -> Tuple[\'SearchProblem2D\', \'SearchProblem2D\']: alpha = random.uniform(0, 1) new_x1 = alpha * self.x + (1 - alpha) * other.x new_y1 = alpha * self.y + (1 - alpha) * other.y new_x2 = alpha * other.x + (1 - alpha) * self.x new_y2 = alpha * other.y + (1 - alpha) * self.y return SearchProblem2D(new_x1, new_y1, self.function_to_optimize), SearchProblem2D(new_x2, new_y2, self.function_to_optimize) def score(self) -> float: return self.function_to_optimize(self.x, self.y) def genetic_algorithm_2d( initial_population: List[SearchProblem2D], find_max: bool = True, max_x: float = math.inf, min_x: float = -math.inf, max_y: float = math.inf, min_y: float = -math.inf, population_size: int = 100, mutation_rate: float = 0.01, crossover_rate: float = 0.7, num_generations: int = 100 ) -> Any: population = initial_population for generation in range(num_generations): sorted_population = sorted(population, key=lambda sf: sf.score(), reverse=find_max) next_generation = sorted_population[:population_size // 2] while len(next_generation) < population_size: parent1 = random.choice(sorted_population[:population_size // 2]) parent2 = random.choice(sorted_population[:population_size // 2]) if random.random() < crossover_rate: child1, child2 = parent1.crossover(parent2) else: child1, child2 = parent1, parent2 child1 = child1.mutate(mutation_rate, min_x, max_x, min_y, max_y) child2 = child2.mutate(mutation_rate, min_x, max_x, min_y, max_y) next_generation.extend([child1, child2]) population = next_generation[:population_size] best_solution = sorted(population, key=lambda sf: sf.score(), reverse=find_max)[0] return best_solution"},{"question":"# Binary Tree Height Calculation Context: You are working on a tree data structure problem, where the task is to determine the height of a binary tree. The height (or depth) of a binary tree is the number of edges on the longest path from the root node to a leaf node. A binary tree is defined as a tree where each node has at most two children. Requirements: * Write a function `calculate_tree_height(tree: dict) -> int` that calculates and returns the height of the binary tree represented by a nested dictionary. * Each node in the tree is represented as a key in the dictionary, with a value being another dictionary for its children. If a node has no children, its value is an empty dictionary (`{}`). * Handle edge cases, such as an empty tree (represented by an empty dictionary) which should return a height of -1 (since there are no nodes). Input: * A nested dictionary `tree` representing the binary tree. Output: * An integer representing the height of the binary tree. Constraints: * The number of nodes in the tree will not exceed 10^5. Examples: ```python # Example 1 tree = { \'a\': { \'b\': { \'d\': {}, \'e\': {} }, \'c\': { \'f\': {}, \'g\': {} } } } calculate_tree_height(tree) # Output: 2 # Example 2 tree = { \'a\': { \'b\': {}, \'c\': {} } } calculate_tree_height(tree) # Output: 1 # Example 3 tree = { \'a\': {} } calculate_tree_height(tree) # Output: 0 # Example 4 tree = {} calculate_tree_height(tree) # Output: -1 # Example 5 tree = { \'a\': { \'b\': { \'c\': { \'d\': {} } } } } calculate_tree_height(tree) # Output: 3 ``` Your implementation should efficiently calculate the height of the tree, ensuring it can handle the maximum constraint effectively.","solution":"def calculate_tree_height(tree: dict) -> int: Calculate the height of the binary tree represented by a nested dictionary. Parameters: tree (dict): The nested dictionary representing the tree. Returns: int: The height of the tree. if not tree: return -1 def height(node): if not node: return 0 return 1 + max((height(child) for child in node.values()), default=-1) return max((height(tree[root]) for root in tree), default=-1)"},{"question":"# Coding Assessment Question: Implement Pivot Index Function Context Understanding array manipulations and being able to identify certain indices based on specific conditions is a key skill in programming. This exercise will require you to identify and implement an algorithm that finds the pivot index of an array, demonstrating your ability to handle array operations and manage edge cases. Problem Statement Write a function `pivot_index(nums: List[int]) -> int` that returns the pivot index of the given list of integers. The pivot index is the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indices, return the left-most pivot index. Input and Output * The input will be a list of integers `nums`. * The output should be an integer which is the pivot index of `nums`. Constraints * The input list `nums` will have a length between 1 and 10^4. * The elements of `nums` will be in the range of -10^3 to 10^3. * Implement the function with O(n) time complexity. Edge Cases * Consider how to handle arrays with a single element. * Ensure proper handling of arrays where the sum of the numbers might be very large or very small. Example ```python def pivot_index(nums: List[int]) -> int: Return the pivot index such that the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. :param nums: list of integers :return: pivot index if exists, else -1 >>> pivot_index([1, 7, 3, 6, 5, 6]) 3 >>> pivot_index([1, 2, 3]) -1 >>> pivot_index([2, 1, -1]) 0 >>> pivot_index([-1, -1, -1, 0, 1, 1]) 0 >>> pivot_index([]) -1 total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1 ``` Implement the function and ensure it passes all the provided tests.","solution":"from typing import List def pivot_index(nums: List[int]) -> int: Return the pivot index such that the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. :param nums: list of integers :return: pivot index if exists, else -1 total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"# Problem Statement You are given a `LinkedList` class implementation, which supports basic operations like insertion, deletion, and traversal of linked list elements. Your task is to enhance this class by implementing a method to detect and remove loops from the linked list. # Task Write a method `remove_loop(self)` for the `LinkedList` class which detects and removes a loop if present in the linked list. If no loop is found, the linked list should remain unchanged. # Constraints * The solution should aim for a time complexity of O(N) and a space complexity of O(1). * The linked list consists of nodes where each node stores an integer value and a reference to the next node. * The input linked list may or may not contain a loop. # Class Definition ```python class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): Appends a new node with given data at the end of the linked list. # Implementation provided def remove_loop(self): Detects and removes the loop from the linked list if present. # To be implemented def detect_loop(self): Returns True if a loop is present in the linked list, else False. # Implementation provided ``` # Assumptions 1. Your linked list may start off with no loop, or it might already contain a loop. 2. You are guaranteed that all elements will have unique values. # Input/Output Example Below is an example of how your method should work: ```python ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) ll.append(5) # Creating a loop for testing ll.head.next.next.next.next.next = ll.head.next.next print(ll.detect_loop()) # Output: True (indicating that a loop exists) ll.remove_loop() print(ll.detect_loop()) # Output: False (indicating that the loop has been removed) ``` # Notes * Ensure your implementation is efficient and avoids unnecessary re-traversals of the linked list. * You should appropriately deal with edge cases like an empty list or a single-node list.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): Appends a new node with given data at the end of the linked list. new_node = Node(data) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def remove_loop(self): Detects and removes the loop from the linked list if present. if not self.head or not self.head.next: return slow = self.head fast = self.head # Detect loop using Floyd\'s cycle-finding algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If loop exists if slow == fast: slow = self.head if slow != fast: while slow.next != fast.next: slow = slow.next fast = fast.next fast.next = None else: while fast.next != slow: fast = fast.next fast.next = None def detect_loop(self): Returns True if a loop is present in the linked list, else False. slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Data Processing for Weather Patterns You have been provided with a dataset containing daily weather data for multiple cities, stored in a CSV file. The task is to process this data to generate statistics for a specific city over a given period. Requirements 1. **Function Implementation**: - Implement a function `city_weather_stats(file_path: str, city: str, start_date: str, end_date: str) -> dict`, which takes the file path to the CSV data, a city name, and a date range as inputs, and returns a dictionary containing weather statistics for that city within the specified date range. 2. **Input and Output Formats**: - **Input**: * `file_path` (string): The path to the CSV file containing the weather data. * `city` (string): The name of the city to get statistics for. * `start_date` (string): The start date in \\"YYYY-MM-DD\\" format. * `end_date` (string): The end date in \\"YYYY-MM-DD\\" format. - **Output**: * A dictionary with the following statistics: - `average_temperature` (float): The average temperature over the specified period. - `total_rainfall` (float): The total rainfall over the specified period. - `max_temperature` (float): The highest temperature recorded over the specified period. - `min_temperature` (float): The lowest temperature recorded over the specified period. 3. **Constraints**: - Ensure that your code handles: * Missing data entries. * Incorrect date formats. * Cities that are not present in the dataset. 4. **Performance Requirements**: - Ensure that the solution reads and processes the data efficiently. - Utilize caching if necessary to avoid redundant calculations. Sample Dataset (weather_data.csv) ``` date,city,temperature,rainfall 2022-01-01,New York,5.6,0.0 2022-01-01,Los Angeles,15.2,0.0 2022-01-02,New York,6.1,1.5 2022-01-02,Los Angeles,14.8,0.0 ... ``` Example: ```python from datetime import datetime import pandas as pd def city_weather_stats(file_path: str, city: str, start_date: str, end_date: str) -> dict: Calculate weather statistics for a specific city over a provided date range. try: df = pd.read_csv(file_path) df[\'date\'] = pd.to_datetime(df[\'date\']) df_filtered = df[(df[\'city\'] == city) & (df[\'date\'] >= pd.to_datetime(start_date)) & (df[\'date\'] <= pd.to_datetime(end_date))] if df_filtered.empty: return { \\"average_temperature\\": None, \\"total_rainfall\\": None, \\"max_temperature\\": None, \\"min_temperature\\": None } avg_temp = df_filtered[\'temperature\'].mean() total_rain = df_filtered[\'rainfall\'].sum() max_temp = df_filtered[\'temperature\'].max() min_temp = df_filtered[\'temperature\'].min() return { \\"average_temperature\\": avg_temp, \\"total_rainfall\\": total_rain, \\"max_temperature\\": max_temp, \\"min_temperature\\": min_temp } except Exception as e: print(f\\"An error occurred: {e}\\") return {} # Sample usage: # city_stats = city_weather_stats(\'weather_data.csv\', \'New York\', \'2022-01-01\', \'2022-01-31\') # print(city_stats) ``` # Implementation Note - Validate date inputs and handle any data inconsistencies such as missing temperature or rainfall values gracefully. - Ensure your solution efficiently processes potentially large datasets.","solution":"import pandas as pd def city_weather_stats(file_path: str, city: str, start_date: str, end_date: str) -> dict: Calculate weather statistics for a specific city over a provided date range. Params: - file_path: str : the path to the CSV file containing the weather data. - city: str : the name of the city to get statistics for. - start_date: str : the start date in \\"YYYY-MM-DD\\" format. - end_date: str : the end date in \\"YYYY-MM-DD\\" format. Returns: - dict : dictionary containing weather statistics (average_temperature, total_rainfall, max_temperature, min_temperature) try: # Load the dataset df = pd.read_csv(file_path) # Convert date column to datetime df[\'date\'] = pd.to_datetime(df[\'date\'], format=\\"%Y-%m-%d\\", errors=\'coerce\') # Filter the data for the specified city and date range df_filtered = df[(df[\'city\'].str.lower() == city.lower()) & (df[\'date\'] >= pd.to_datetime(start_date)) & (df[\'date\'] <= pd.to_datetime(end_date))] if df_filtered.empty: return { \\"average_temperature\\": None, \\"total_rainfall\\": None, \\"max_temperature\\": None, \\"min_temperature\\": None } # Calculate statistics avg_temp = df_filtered[\'temperature\'].mean() total_rain = df_filtered[\'rainfall\'].sum() max_temp = df_filtered[\'temperature\'].max() min_temp = df_filtered[\'temperature\'].min() return { \\"average_temperature\\": avg_temp, \\"total_rainfall\\": total_rain, \\"max_temperature\\": max_temp, \\"min_temperature\\": min_temp } except Exception as e: print(f\\"An error occurred: {e}\\") return {} # Sample usage: # city_stats = city_weather_stats(\'weather_data.csv\', \'New York\', \'2022-01-01\', \'2022-01-31\') # print(city_stats)"},{"question":"# Problem Statement You are given two strings: a source string and a target string. Your task is to implement a function `can_transform(source, target)` to determine if the target string can be formed by rearranging the characters of the source string. You should return a boolean indicating whether the transformation is possible. # Function Signature ```python def can_transform(source: str, target: str) -> bool: pass ``` # Input - `source`: A string containing the original characters. - `target`: A string for which you need to check if it can be formed by rearranging characters of the source string. # Output - A boolean value, `True` if the target string can be formed by rearranging the characters of the source string, otherwise `False`. # Constraints - Both `source` and `target` are composed of lowercase alphabetical characters. - Both strings may have lengths up to 100 characters. - It is not necessary to use all characters from the source; unused characters are allowed. # Examples ```python can_transform(\\"anagram\\", \\"nagaram\\") # Expected output: True can_transform(\\"rat\\", \\"car\\") # Expected output: False can_transform(\\"aabbcc\\", \\"abc\\") # Expected output: True can_transform(\\"hello\\", \\"olleh\\") # Expected output: True can_transform(\\"test\\", \\"tset\\") # Expected output: True can_transform(\\"example\\", \\"samplex\\") # Expected output: False ``` # Notes - Focus on the frequency of characters in the source and target strings. - Consider edge cases where one string is a permutation of the other, or when they have different lengths. - Think about performance and how to efficiently compare the character counts between the two strings.","solution":"def can_transform(source: str, target: str) -> bool: Determine if the target string can be formed by rearranging the characters of the source string. from collections import Counter # Create character frequency counts for both source and target source_counter = Counter(source) target_counter = Counter(target) # Check if target\'s character counts are all less than or equal to the source\'s character counts for char, count in target_counter.items(): if count > source_counter[char]: return False return True"},{"question":"# Scenario You are developing a utility for processing text data in a document management system. One of the tasks is to scan a text and detect the most frequently occurring word. It is important that the utility ignores case differences and punctuation, and handles ties by returning the word that appears first in the text. # Task Write a Python function that takes a string of text and returns the most frequently occurring word. The comparison should be case-insensitive, and punctuation should be ignored. If there is a tie for the most frequent word, return the one that appears first in the text. # Function Signature ```python def find_most_frequent_word(text: str) -> str: ``` # Input & Output Requirements * **Input**: * `text` (str): A string containing the text to process, containing words separated by whitespace and possibly including punctuation. * **Output**: * A string representing the most frequently occurring word. # Constraints: * Words are defined as sequences of alphanumeric characters. * The text contains at least one word. # Validations: 1. Ignore punctuation and case. 2. If multiple words have the same highest frequency, return the first one that appears. # Example Scenarios: 1. **Input**: ```python find_most_frequent_word(\\"Hello world! Hello\\") ``` **Output**: ```python \\"hello\\" ``` 2. **Input**: ```python find_most_frequent_word(\\"This is a test. This test is only a test.\\") ``` **Output**: ```python \\"test\\" ``` 3. **Input**: ```python find_most_frequent_word(\\"It was the best of times, it was the worst of times.\\") ``` **Output**: ```python \\"it\\" ``` Formulate your function to comply with the requirements specified and test it thoroughly for correctness.","solution":"import re from collections import Counter def find_most_frequent_word(text: str) -> str: Returns the most frequently occurring word in the given text, ignoring case and punctuation. Ties are broken by the word that appears first in the text. # Normalize text by converting to lower case and removing punctuation normalized_text = re.sub(r\'[^a-zA-Z0-9s]\', \'\', text.lower()) words = normalized_text.split() # Count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency most_frequent_word = max(words, key=lambda word: (word_counts[word], -words.index(word))) return most_frequent_word"},{"question":"# Array Manipulation - Multiply Adjacent You are given a list of integers. Your task is to write a function that, for each integer in the list, multiplies it by the integer immediately to its left, then returns a new list containing only the resultant values from these multiplications. Task Implement a function named `multiply_adjacent` that performs this operation on a list of integers. Input * A list of integers ( text{arr} ) of length ( n ) where ( n geq 1 ). Output * A new list representing the result of multiplying each integer by its immediate left integer. Constraints * The list will contain at least one integer. * If the list contains only one integer, the output should be an empty list as there are no adjacent integers to multiply. Examples Consider the following examples: Example 1: Input: `[2, 3, 4]` Output: `[6, 12]` Explanation: - ( 3 * 2 = 6 ) - ( 4 * 3 = 12 ) Example 2: Input: `[1, 2, 3, 4]` Output: `[2, 6, 12]` Explanation: - ( 2 * 1 = 2 ) - ( 3 * 2 = 6 ) - ( 4 * 3 = 12 ) Example 3: Input: `[5]` Output: `[]` Explanation: No adjacent integers to multiply. Implementation ```python def multiply_adjacent(arr): Multiplies each integer by its immediate left integer. Parameters: - arr: (List[int]) A list of integers. Returns: - List[int]: A list containing the results of the multiplications. if len(arr) <= 1: return [] result = [] for i in range(1, len(arr)): result.append(arr[i] * arr[i - 1]) return result ```","solution":"def multiply_adjacent(arr): Multiplies each integer by its immediate left integer. Parameters: - arr: (List[int]) A list of integers. Returns: - List[int]: A list containing the results of the multiplications. if len(arr) <= 1: return [] result = [] for i in range(1, len(arr)): result.append(arr[i] * arr[i - 1]) return result"},{"question":"# Fibonacci Sequence Finder The following is a coding challenge to test your understanding of dynamic programming and optimization techniques. You are tasked with creating a function that efficiently finds the `n`-th Fibonacci number. # Scenario A research team is working on an algorithm that requires frequent calculations of Fibonacci numbers. Since the direct recursive method is inefficient for large `n`, they need an optimized solution that balances time complexity and space efficiency. # Task Write a function `fibonacci` that calculates the `n`-th Fibonacci number using an efficient approach, such as dynamic programming with memoization or iterative computation. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Input - `n` (int): The position in the Fibonacci sequence (0-indexed). # Output - Returns the `n`-th Fibonacci number as an integer. # Constraints - `0 <= n <= 1000` - The function should handle the base cases (e.g., Fibonacci numbers for `n = 0` and `n = 1`) appropriately. - Consider both time and space efficiency in your implementation. # Example **Input** ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(20) == 6765 ``` **Output** ```python 0 1 55 6765 ``` Your solution should find the `n`-th Fibonacci number in a time-efficient manner without recalculating intermediate results multiple times.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Task Write a function to determine if a given integer is a permutation of another integer. # Objective Write a function `is_permutation(a: int, b: int) -> bool` that: 1. Takes two integers `a` and `b` as input. 2. Checks if `a` is a permutation of `b`. # Input * Two integers `a` and `b` where `-10^9 ≤ a, b ≤ 10^9`. # Output * A boolean value: `True` if `a` is a permutation of `b`, and `False` otherwise. # Constraints 1. A permutation means that both numbers have the exact same digits with the same frequencies. 2. Handle the case where the integers could be negative. 3. Ensure the solution efficiently handles the upper and lower bounds within resource constraints. # Performance Requirement * The solution should handle the full range of inputs efficiently. # Scenarios 1. If `a` is 123 and `b` is 321, the function should return `True`. 2. If `a` is -123 and `b` is 321, the function should return `False`. 3. If `a` is 100 and `b` is 10, the function should return `False`. # Example ```python print(is_permutation(123, 321)) # Output: True print(is_permutation(145, 541)) # Output: True print(is_permutation(-123, 321)) # Output: False print(is_permutation(100, 10)) # Output: False print(is_permutation(0, 0)) # Output: True ``` Implement the function to solve the problem accurately and efficiently for all valid inputs.","solution":"def is_permutation(a: int, b: int) -> bool: Determines if integer a is a permutation of integer b. # Convert both integers to their string representations, ignoring signs str_a = sorted(str(abs(a))) str_b = sorted(str(abs(b))) # Compare the sorted characters of both strings return str_a == str_b"},{"question":"# Problem Statement You are given an integer `n` representing the number of teams in a single-elimination tournament. In such a tournament, teams compete in pairs and the winner advances to the next round, while the loser is eliminated. The process continues until only one team remains as the winner. Your task is to implement a function `tournament_rounds(n: int) -> int` that calculates the total number of rounds required to determine a winner. # Input: * A single integer `n` representing the number of teams. (1 <= n <= 10^9) # Output: * Return an integer indicating the total number of rounds needed to determine the winner. # Constraints: * The input `n` will be a positive integer. # Example: ```python def test_tournament_rounds(): assert tournament_rounds(1) == 0 assert tournament_rounds(2) == 1 assert tournament_rounds(4) == 2 assert tournament_rounds(7) == 3 assert tournament_rounds(16) == 4 test_tournament_rounds() ``` # Performance Considerations: * Ensure the solution handles large values of `n` efficiently. * Consider mathematical properties of logarithmic growth since each round halves the number of competitors.","solution":"import math def tournament_rounds(n: int) -> int: Calculate the total number of rounds required to determine the winner in a single-elimination tournament given `n` teams. Parameters: n (int): The number of teams. Returns: int: The total number of rounds needed. if n <= 1: return 0 return math.ceil(math.log2(n))"},{"question":"# Coding Assessment Question **Title**: Implement Morse Code Encoder **Context**: You are working on a communication tool that can encode text messages into Morse code. Morse code is a method used in telecommunication to encode text characters as standardized sequences of two different signal durations, called dots and dashes. **Task**: Write a function `encode_morse` that takes a string as input and returns its Morse code representation. **Input**: - `text`: a string representing the text message to be encoded. It consists only of uppercase letters and spaces. **Output**: - A string representing the encoded Morse code. Use a single space to separate Morse code for each letter and three spaces to separate Morse code for each word. **Constraints**: - The input string will only contain uppercase English letters (A-Z) and spaces. - The Morse code for each character is provided below in the `morse_code` dictionary. - The input string will have at least one character. **Example**: ```python text = \\"HELLO WORLD\\" print(encode_morse(text)) ``` **Expected Output**: ``` \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" ``` **Notes**: - Utilize the Morse code dictionary provided below for encoding: ```python morse_code = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\' } ``` **Additional Example**: ```python text = \\"MORSE CODE\\" print(encode_morse(text)) ``` **Expected Output**: ``` \\"-- --- .-. ... . -.-. --- -.. .\\" ``` ```python # Implementation of the Morse encoder def encode_morse(text): morse_code = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\' } words = text.split(\' \') morse_words = [\' \'.join(morse_code[char] for char in word) for word in words] return \' \'.join(morse_words) # Testing the function print(encode_morse(\\"HELLO WORLD\\")) # Outputs: .... . .-.. .-.. --- .-- --- .-. .-.. -.. print(encode_morse(\\"MORSE CODE\\")) # Outputs: -- --- .-. ... . -.-. --- -.. . ```","solution":"def encode_morse(text): morse_code = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\' } words = text.split(\' \') morse_words = [\' \'.join(morse_code[char] for char in word) for word in words] return \' \'.join(morse_words)"},{"question":"# Multi-Client Chat Server You are tasked with building a multi-client chat server from the ground up using Python. The server should be able to handle multiple client connections simultaneously, broadcast messages from one client to all other connected clients in real-time, and provide basic server-side commands. # Requirements 1. **Server Implementation**: Create a class `ChatServer` that: * Listens for incoming TCP connections on a specified port. * Manages multiple client connections using threading or asynchronous programming. * Broadcasts messages from any client to all connected clients. * Handles client disconnections gracefully. 2. **Client Implementation**: Create a class `ChatClient` that: * Connects to the `ChatServer` using TCP. * Allows the user to send messages to the server. * Receives and displays messages broadcast by the server. 3. **Command Support**: * Server should support basic commands such as listing all connected clients (`/list`) and shutting down the server (`/shutdown`). 4. **Testing and Validation**: * Provide a set of test scripts to demonstrate the functionality of your server and client implementations. * Ensure your server can handle edge cases such as clients abruptly disconnecting. # Scenario Context A group of developers in a software company frequently need to communicate in real-time in various development environments. They require a lightweight, reliable chat server they can deploy locally across different machines to ensure seamless communication during development and debugging sessions. # Input and Output * Input: Messages from clients. * Output: Messages broadcast to all connected clients, server-side commands output. # Constraints * Ensure the server can handle at least 10 concurrent client connections. * Messages should not be lost when clients connect and disconnect frequently. ```python import socket import threading import logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(message)s\') class ChatServer: def __init__(self, host=\'localhost\', port=12345): self.host = host self.port = port self.clients = [] def broadcast(self, message, client_socket): for client in self.clients: if client != client_socket: try: client.send(message) except: client.close() self.clients.remove(client) def handle_client(self, client_socket, client_address): logging.info(f\\"New connection from {client_address}\\") while True: try: message = client_socket.recv(1024) if not message: break logging.info(f\\"Received message from {client_address}: {message}\\") self.broadcast(message, client_socket) except: break client_socket.close() self.clients.remove(client_socket) logging.info(f\\"Connection from {client_address} has been closed\\") def start(self): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((self.host, self.port)) server_socket.listen() logging.info(f\\"Server started on port {self.port}\\") while True: client_socket, client_address = server_socket.accept() self.clients.append(client_socket) thread = threading.Thread(target=self.handle_client, args=(client_socket, client_address)) thread.start() class ChatClient: def __init__(self, host=\'localhost\', port=12345): self.server_host = host self.server_port = port self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) def receive_messages(self): while True: try: message = self.client_socket.recv(1024) if not message: break print(message.decode(\'utf-8\')) except: break def start(self): try: self.client_socket.connect((self.server_host, self.server_port)) except: logging.error(\\"Failed to connect to the server\\") return threading.Thread(target=self.receive_messages).start() while True: message = input() if message.lower() == \'/exit\': self.client_socket.close() break self.client_socket.send(message.encode(\'utf-8\')) if __name__ == \\"__main__\\": import sys if len(sys.argv) < 2: print(\\"Usage: python chat.py server|client\\") sys.exit(1) role = sys.argv[1].lower() if role == \'server\': server = ChatServer() server.start() elif role == \'client\': client = ChatClient() client.start() else: print(\\"Invalid role, use \'server\' or \'client\'\\") ``` In this example, a `ChatServer` class handles incoming connections, broadcasts messages, and maintains a list of connected clients. The `ChatClient` class connects to the server, sends messages, and displays received messages. The chat server utilizes threading to manage multiple connections concurrently. This setup can easily be tested by running one instance of the script in `server` mode and multiple instances in `client` mode.","solution":"import socket import threading import logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(message)s\') class ChatServer: def __init__(self, host=\'localhost\', port=12345): self.host = host self.port = port self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.clients = [] self.server_running = True def broadcast(self, message, client_socket): for client in self.clients: if client != client_socket: try: client.send(message) except: client.close() self.clients.remove(client) def handle_client(self, client_socket, client_address): logging.info(f\\"New connection from {client_address}\\") while True: try: message = client_socket.recv(1024) if not message: break logging.info(f\\"Received message from {client_address}: {message.decode(\'utf-8\')}\\") self.broadcast(message, client_socket) except: break client_socket.close() self.clients.remove(client_socket) logging.info(f\\"Connection from {client_address} has been closed\\") def start(self): self.server_socket.bind((self.host, self.port)) self.server_socket.listen() logging.info(f\\"Server started on port {self.port}\\") while self.server_running: client_socket, client_address = self.server_socket.accept() self.clients.append(client_socket) threading.Thread(target=self.handle_client, args=(client_socket, client_address)).start() def stop(self): self.server_running = False self.server_socket.close() class ChatClient: def __init__(self, host=\'localhost\', port=12345): self.server_host = host self.server_port = port self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) def receive_messages(self): while True: try: message = self.client_socket.recv(1024) if not message: break print(message.decode(\'utf-8\')) except: break def start(self): try: self.client_socket.connect((self.server_host, self.server_port)) logging.info(\\"Connected to the server\\") except: logging.error(\\"Failed to connect to the server\\") return threading.Thread(target=self.receive_messages).start() while True: message = input() if message.lower() == \'/exit\': self.client_socket.close() break self.client_socket.send(message.encode(\'utf-8\')) if __name__ == \\"__main__\\": import sys if len(sys.argv) < 2: print(\\"Usage: python chat.py server|client\\") sys.exit(1) role = sys.argv[1].lower() if role == \'server\': server = ChatServer() server.start() elif role == \'client\': client = ChatClient() client.start() else: print(\\"Invalid role, use \'server\' or \'client\'\\")"},{"question":"# Question Write a Python function called `multiply_except_self` that takes a list of integers and returns a new list such that, at each index, the value is the product of all the numbers in the original list except the one at that index. Function Signature ```python def multiply_except_self(nums: list[int]) -> list[int]: pass ``` Input * `nums`: A non-empty list of integers. Output * A list of integers where each element is the product of all elements in the input list except the one at the corresponding index. Constraints * The length of `nums` will be in the range [1, 10^5]. * Each integer in `nums` will be in the range [-10^9, 10^9]. Requirements * You must solve this problem without using division. * The input list `nums` should not be modified during the function execution. Example ```python >>> multiply_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> multiply_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> multiply_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> multiply_except_self([1, 2, 3, 0, 5]) [0, 0, 0, 30, 0] >>> multiply_except_self([1]) [1] ``` Notes * Handle edge cases such as lists containing one element or lists containing zeroes appropriately. * The solution should be efficient and optimize for time and space complexity considering the constraints provided.","solution":"def multiply_except_self(nums: list[int]) -> list[int]: # Length of the input list n = len(nums) # Initialize the result list with 1s result = [1] * n # Temporary variable to store the product of elements to the left of the current index left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Temporary variable to store the product of elements to the right of the current index right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"# Coding Assessment Question You are tasked with implementing a function that takes a list of integers and returns a new list with duplicates removed, but the order of the elements should remain the same as their first occurrence in the input list. Ensure the function validates the input for any errors before proceeding with the removal of duplicates. **Function Signature**: ```python def remove_duplicates(arr: list) -> list: Remove duplicates from a list while maintaining the order of first occurrences. Parameters: arr (list): A list of integers. Returns: list: A new list with duplicates removed and order preserved. Raises: TypeError: If input is not a list or if list elements are not integers. Sample Input/Output: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([5, 5, 5, 5]) [5] >>> remove_duplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> remove_duplicates([]) [] >>> remove_duplicates([1, \'a\', 2]) Traceback (most recent call last): ... TypeError: All elements in the list must be integers >>> remove_duplicates(\\"string\\") Traceback (most recent call last): ... TypeError: Expected a list as input ``` **Constraints**: * The function must handle input validation: * Should raise a `TypeError` if the input is not a list or if the list contains non-integer elements. * The input is guaranteed not to be `None`. **Scenarios**: 1. Standard cases with mixed duplicates and unique elements. 2. Edge cases involving empty lists, lists with non-integer elements, and completely duplicate lists. 3. Typical list processing applications, ensuring data integrity and order preservation.","solution":"def remove_duplicates(arr): Remove duplicates from a list while maintaining the order of first occurrences. Parameters: arr (list): A list of integers. Returns: list: A new list with duplicates removed and order preserved. Raises: TypeError: If input is not a list or if list elements are not integers. if not isinstance(arr, list): raise TypeError(\\"Expected a list as input\\") if not all(isinstance(i, int) for i in arr): raise TypeError(\\"All elements in the list must be integers\\") seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Problem: **Circular Queue Implementation** You\'re tasked with implementing a `CircularQueue` class that includes basic queue operations along with unique functionalities to efficiently handle queue overflow and underflow situations. This task will test your understanding of queues and their variations. Required Operations: 1. **Enqueue**: Add an element at the end of the queue. 2. **Dequeue**: Remove and return the front element from the queue. 3. **Front**: Retrieve the front element without removing it. 4. **Rear**: Retrieve the last element without removing it. 5. **Is Full**: Check if the queue is full. 6. **Is Empty**: Check if the queue is empty. 7. **Resize**: Increase the capacity of the queue dynamically if it is full during an enqueue operation. Input and Output Formats: 1. **Enqueue**: - Input: An integer element. - Output: None 2. **Dequeue**: - Input: None - Output: The front element of the queue. 3. **Front**: - Input: None - Output: The front element of the queue. 4. **Rear**: - Input: None - Output: The rear element of the queue. 5. **Is Full**: - Input: None - Output: `True` if the queue is full, `False` otherwise. 6. **Is Empty**: - Input: None - Output: `True` if the queue is empty, `False` otherwise. 7. **Resize**: - Input: An integer indicating the new size. - Output: None # Constraints: - Ensure `enqueue` and `dequeue` operations perform in O(1) time. - For `resize`, the new size should be greater than the current queue size. - The `enqueue` operation should automatically trigger a `resize` when the queue is full. Example: ```python Q = CircularQueue(3) Q.enqueue(1) Q.enqueue(2) print(Q.front()) # Output: 1 print(Q.rear()) # Output: 2 Q.enqueue(3) print(Q.is_full()) # Output: True Q.enqueue(4) # Queue should resize automatically print(Q.rear()) # Output: 4 Q.dequeue() print(Q.front()) # Output: 2 print(Q.is_empty()) # Output: False ``` Implement these methods within the `CircularQueue` class and ensure that your implementation handles all edge cases appropriately, such as when the queue is empty or full.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.head = -1 self.tail = -1 self.size = 0 def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity def enqueue(self, value: int): if self.is_full(): self.resize(self.capacity * 2) if self.is_empty(): self.head = 0 self.tail = (self.tail + 1) % self.capacity self.queue[self.tail] = value self.size += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.head] self.queue[self.head] = None self.head = (self.head + 1) % self.capacity self.size -= 1 if self.is_empty(): self.head = -1 self.tail = -1 return value def front(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.head] def rear(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.tail] def resize(self, new_capacity: int): new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.head + i) % self.capacity] self.capacity = new_capacity self.queue = new_queue self.head = 0 self.tail = self.size - 1 if self.size > 0 else -1"},{"question":"# Question: Implement a Recursive and Iterative Fibonacci Calculator Your task is to create a function that computes the nth Fibonacci number using both recursive and iterative approaches. The function should allow the user to select the desired method via a boolean parameter. Function Signature ```python def fibonacci(n: int, use_recursive: bool = True) -> int: ``` Input * `n`: A non-negative integer indicating the position in the Fibonacci sequence. * `use_recursive`: A boolean to select whether to use the recursive or iterative method for calculating the Fibonacci number. Defaults to `True` (use recursive method). Output * An integer representing the nth Fibonacci number. Constraints * `0 ≤ n ≤ 30` (to ensure the recursive method completes in a reasonable time). Requirements 1. Implement both the recursive and iterative methods for computing the Fibonacci number. 2. Ensure the function handles the base cases (`n=0` and `n=1`) correctly. 3. Provide error handling for any invalid inputs (e.g., negative integers). # Example ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(5) == 5 assert fibonacci(10, use_recursive=False) == 55 assert fibonacci(10) == 55 ``` Implement both the recursive and iterative versions within the same function and use the `use_recursive` parameter to decide which method to execute.","solution":"def fibonacci(n: int, use_recursive: bool = True) -> int: Computes the nth Fibonacci number using either a recursive or iterative approach. Parameters: n (int): The position in the Fibonacci sequence (must be a non-negative integer). use_recursive (bool): If True, use the recursive method. Otherwise, use the iterative method. Returns: int: The nth Fibonacci number. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") # Recursive approach if use_recursive: def fib_recursive(m: int) -> int: if m == 0: return 0 elif m == 1: return 1 else: return fib_recursive(m-1) + fib_recursive(m-2) return fib_recursive(n) # Iterative approach else: if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question You are given an array of positive integers representing the lengths of different ropes. Your task is to write a function that returns the minimum total length of rope after cutting them into segments of the same length. All ropes must be cut into pieces of integer lengths and the size of these pieces is determined by the length of the shortest rope. # Function Signature ```python def min_total_length(ropes: list[int]) -> int: Calculate the minimum total length of ropes after cutting them into segments of the same length. :param ropes: A list of integers representing the lengths of the ropes. :return: The minimum total length of ropes after cutting. ``` # Example ```python >>> min_total_length([4, 6, 8]) 18 # Detailed explanation: # The lengths of the segments will be the greatest common divisor (gcd) of [4, 6, 8], which is 2. # After cutting the ropes into segments of length 2: # - Rope of length 4 becomes 2 segments of length 2, # - Rope of length 6 becomes 3 segments of length 2, # - Rope of length 8 becomes 4 segments of length 2. # The total length is 4 + 6 + 8 = 18 >>> min_total_length([5, 10, 15]) 30 # Detailed explanation: # The lengths of the segments will be the gcd of [5, 10, 15], which is 5. # After cutting the ropes into segments of length 5: # - Rope of length 5 becomes 1 segment of length 5, # - Rope of length 10 becomes 2 segments of length 5, # - Rope of length 15 becomes 3 segments of length 5. # The total length is 5 + 10 + 15 = 30 >>> min_total_length([1, 1, 1]) 3 # Detailed explanation: # The lengths of the segments will be the gcd of [1, 1, 1], which is 1. # After cutting the ropes into segments of length 1: # - Each rope remains the same as they are already of length 1. # The total length is 1 + 1 + 1 = 3 ``` # Input Constraints * The length of the ropes array will be at least 1 and at most (10^5). * Each rope length will be a positive integer between 1 and (10^6). # Requirements * Your solution must be efficient with a time complexity that takes into account the input size constraints. # Edge Cases * Test with an array where all ropes have the same length. * Test with an array where the lengths of the ropes are prime numbers.","solution":"import math from functools import reduce def min_total_length(ropes): Calculate the minimum total length of ropes after cutting them into segments of the same length. :param ropes: A list of integers representing the lengths of the ropes. :return: The minimum total length of ropes after cutting. def gcd(a, b): while b: a, b = b, a % b return a # Calculate the gcd of all rope lengths overall_gcd = reduce(gcd, ropes) # The minimum total length is the sum of the rope lengths after cutting return sum(ropes) # Example usage: # print(min_total_length([4, 6, 8])) # Outputs: 18 # print(min_total_length([5, 10, 15])) # Outputs: 30 # print(min_total_length([1, 1, 1])) # Outputs: 3"},{"question":"# Coding Assessment Question Problem: You are provided with a library that can calculate basic arithmetic operations, along with functions to determine whether an integer is a prime number. Your task is to implement a function that identifies the smallest prime number greater than a given integer and utilizes the available functions from the library. Function Signature: ```python def next_prime_number(n: int) -> int: Find the smallest prime number greater than the given input integer. Input Parameters: ----------------- n: An integer for which the next prime number needs to be found Returns: -------- An integer representing the smallest prime number greater than `n` pass ``` Input: - `n` is an integer where 1 <= n <= 10^6. Output: - Return the smallest prime number greater than `n`. Constraints: * The input `n` will be a positive integer. * The function must utilize the library\'s prime checking functions for determining if a number is prime. Example: ```python next_prime_number(10) # Output: 11 next_prime_number(14) # Output: 17 ``` Available Library Functions: - `is_prime(x: int) -> bool`: Returns True if `x` is a prime number, False otherwise. - `next_integer(y: int) -> int`: Returns the next integer greater than `y`. You should ensure the implementation is efficient and can handle the upper constraint values gracefully.","solution":"# Assume the library functions are imported from the library # from library import is_prime, next_integer def is_prime(x: int) -> bool: Mock function for library\'s is_prime. This implementation is just for testing purposes. if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def next_integer(y: int) -> int: Mock function for library\'s next_integer This implementation is just for testing purposes. return y + 1 def next_prime_number(n: int) -> int: current_number = next_integer(n) while not is_prime(current_number): current_number = next_integer(current_number) return current_number"},{"question":"# Binary Tree Inorder Traversal Given the root of a binary tree, implement a function to return the inorder traversal of its nodes\' values. Inorder traversal visits nodes in the order: left, root, right. Description Create the function `inorder_traversal` to perform an inorder traversal on a binary tree and return the list of node values in the corresponding order. Requirements - Recursively visit the left subtree. - Visit the current node. - Recursively visit the right subtree. - Collect the node values in the above order. Function Signature ```python def inorder_traversal(root: Optional[TreeNode]) -> List[int]: ``` Parameters: - `root (Optional[TreeNode])`: The root node of the binary tree. A node is defined as `TreeNode` with properties `val`, `left`, and `right`. Returns: - `List[int]`: A list of node values in inorder. TreeNode Class Definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example Use Case: ```python >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> inorder_traversal(root) [1, 3, 2] ``` Constraints: - The number of nodes in the tree is in the range [0, 100]. - `-100 <= Node.val <= 100`","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform an inorder traversal of a binary tree and return the list of node values. Args: root (Optional[TreeNode]): The root node of the binary tree. Returns: List[int]: A list of node values in inorder. res = [] def inorder(node: Optional[TreeNode]): if not node: return inorder(node.left) res.append(node.val) inorder(node.right) inorder(root) return res"},{"question":"# Coding Assessment Question: Circular Array Rotation **Context**: Rotating elements in an array is a common operation in programming that can be applied in various scenarios such as data manipulation and algorithm design. Understanding and implementing such operations efficiently is critical. **Objective**: Write a function `rotate_array(nums: List[int], k: int) -> List[int]` that rotates the given list `nums` to the right by `k` steps. **Function Signature**: ```python def rotate_array(nums: List[int], k: int) -> List[int]: pass ``` # Input: - A list of integers `nums` where `0 <= len(nums) <= 10^5`. - An integer `k` where `0 <= k <= 10^5`. # Output: - A list representing the `nums` rotated to the right by `k` steps. # Constraints: - The rotation should be performed in-place with O(1) extra space complexity if possible. - Handle cases where `k` is greater than the length of `nums`. # Examples: ```python >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_array([1, 2, 3], 4) [3, 1, 2] >>> rotate_array([], 3) [] >>> rotate_array([1], 10) [1] ``` # Additional Notes: 1. Consider the efficiency of the solution when approaching the upper limits of the input constraints. 2. If `k` is greater than the length of the array, rotating by `k` is equivalent to rotating by `k % len(nums)`.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotate the array nums by k steps to the right. if not nums: return nums n = len(nums) k = k % n # handle the case where k is greater than the length of the array nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"# Context A common requirement in various coding tasks is to identify patterns in strings, such as finding the longest substring with unique characters. This problem tests your ability to use data structures efficiently to solve string manipulation and pattern-matching challenges. # Problem Statement Write a Python function called `longest_unique_substring` that takes a string `s` as input and returns the length of the longest substring with all unique characters. # Input - A string `s` where `1 <= len(s) <= 10^5`. The string consists only of printable ASCII characters. # Output - An integer representing the length of the longest substring that contains no repeating characters. # Function Signature ```python def longest_unique_substring(s: str) -> int: pass ``` # Constraints - You are given a string `s` with a length up to 100,000, so your solution should be optimized for performance. - The characters in the string are all printable ASCII characters (i.e., characters in the range 32-126). # Example ```python assert longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" assert longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" assert longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" assert longest_unique_substring(\\"\\") == 0 # no characters assert longest_unique_substring(\\"a\\") == 1 # \\"a\\" ``` # Guidelines 1. Use a sliding window approach to efficiently find the longest substring without repeating characters. 2. Maintain a set or dictionary to track the characters in the current window. 3. Expand the window by adding new characters and contract it when a duplicate character is found. 4. Continuously update the maximum length of the unique substring found during the process. 5. Return the length of the longest unique substring as the output. Your function will be evaluated for correctness and performance, so ensure it handles various input cases efficiently.","solution":"def longest_unique_substring(s: str) -> int: n = len(s) if n == 0: return 0 char_set = set() left = 0 max_length = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Statement You are hired as a software developer at a logistics company. Your task is to create a system to help manage the loading of cargo into a truck. The system needs to calculate the maximum number of unique cargo items that can fit into the truck without exceeding a given weight limit. # Function Signature ```python def max_unique_cargo(weights: list[int], max_weight: int) -> int: pass ``` # Input - `weights`: A list of integers where each element represents the weight of a cargo item. - `max_weight`: An integer representing the maximum weight the truck can hold. # Output - An integer representing the maximum number of unique cargo items that can be loaded into the truck without exceeding the weight limit. # Constraints - `0 <= len(weights) <= 10^5` - `1 <= max_weight <= 10^9` - Each element in `weights` is a non-negative integer and can be no greater than max_weight. # Example - Input: `([1, 3, 2, 5, 4], 9)` - Output: `3` # Scenario An efficient logistics company needs to know how many different cargo types can be loaded into their trucks for a given route. This will help them in getting the optimal usage of the truck\'s capacity and maximizing the number of unique cargos transported. # Performance Requirements - The solution should be optimized to handle large input sizes efficiently. - Consider the time complexity for sorting or other operations. # Requirements - Avoid using built-in Python functions that explicitly solve the problem. - Make sure to consider edge cases and invalid inputs. Raise a `ValueError` for any negative weights or if max_weight is less than zero. - Ensure that your algorithm handles scenarios where no cargo can be loaded due to weight constraints.","solution":"def max_unique_cargo(weights: list[int], max_weight: int) -> int: if len(weights) == 0 or max_weight <= 0: return 0 weights = [w for w in weights if w <= max_weight] # Filter out weights larger than max_weight weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= max_weight: total_weight += weight count += 1 else: break return count"},{"question":"# Question: Efficient String Transformation with Minimum Operations You are working on a string transformation algorithm that needs to convert one string into another with the minimum number of operations. The allowed operations are inserting a character, deleting a character, or replacing a character. Your task is to implement a function that computes the minimum number of operations needed to transform one string into another using these operations. # Input and Output Formats Function Signature ```python def min_operations_to_transform(s1: str, s2: str) -> int: pass ``` Inputs: - `s1` (str): The initial string. - `s2` (str): The target string. Outputs: - The function should return an integer representing the minimum number of operations needed to transform `s1` into `s2`. Constraints: - The length of `s1` and `s2` will be between 0 and 1000. Performance Requirements: - The function should efficiently handle the input size constraints. Examples: ```python >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") 2 >>> min_operations_to_transform(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_transform(\\"\\", \\"abc\\") 3 >>> min_operations_to_transform(\\"abcdef\\", \\"abcdef\\") 0 ``` # Scenario In many applications, such as spell correction, DNA sequence analysis, and file comparison, it is crucial to determine the minimum number of changes required to convert one string into another. Your task is to develop an algorithm to calculate the edit distance, which is a measure of similarity between two strings. This algorithm will be essential in contexts where precise transformations and minimal modifications are necessary. Make sure to implement the function efficiently to handle the given constraints, focusing on optimizing the computation of the transformation operations.","solution":"def min_operations_to_transform(s1: str, s2: str) -> int: Returns the minimum number of operations needed to transform string s1 into string s2. Allowed operations are insertion, deletion, and substitution. m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If the first string is empty, insert all characters of the second string elif j == 0: dp[i][j] = i # If the second string is empty, remove all characters of the first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are equal, no more operations are needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Problem Statement You have been given the task of improving the performance of string comparison operations within a dataset containing various strings. Your goal is to efficiently find the longest common prefix shared among a list of strings using a Divide and Conquer approach. This problem will evaluate your understanding of the Divide and Conquer technique by requiring you to implement it to solve a common problem. # Function to Implement Implement the function `longest_common_prefix(strs: List[str]) -> str` in Python, where: * `strs` is a list of strings. # Input and Output * **Input**: A list `strs` of strings. * **Output**: The longest common prefix string among all strings in the list. If there is no common prefix, return an empty string `\\"\\"`. # Constraints 1. The list length will be between `0` and `10^3`. 2. Each string length will be between `0` and `200`. 3. Strings will consist of only lowercase English letters. # Examples ```python assert longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) == \\"\\" assert longest_common_prefix([\\"interspecies\\",\\"interstellar\\",\\"interstate\\"]) == \\"inters\\" assert longest_common_prefix([]) == \\"\\" assert longest_common_prefix([\\"a\\"]) == \\"a\\" ``` # Performance Requirements * Your solution should effectively utilize the Divide and Conquer strategy to ensure optimal time complexity. # Additional Notes Consider edge cases such as: * An empty list of strings. * Lists containing strings with no common prefix. * Lists where all strings are identical. * Single string input in the list. Implement your function to handle all edge cases appropriately, while ensuring optimal performance.","solution":"from typing import List def common_prefix(left: str, right: str) -> str: min_length = min(len(left), len(right)) for i in range(min_length): if left[i] != right[i]: return left[:i] return left[:min_length] def longest_common_prefix_helper(strs: List[str], l: int, r: int) -> str: if l == r: return strs[l] mid = (l + r) // 2 lcp_left = longest_common_prefix_helper(strs, l, mid) lcp_right = longest_common_prefix_helper(strs, mid + 1, r) return common_prefix(lcp_left, lcp_right) def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" return longest_common_prefix_helper(strs, 0, len(strs) - 1)"},{"question":"# Coding Assessment Question: Problem Context You work on software that interfaces with various peripherals, requiring frequent manipulation and validation of formatted text. A key task is ensuring that given hexadecimal strings are valid and converting them to their corresponding decimal values for further processing. Task Implement a function `hex_to_decimal_validated(hex_str: str) -> int` that validates a given hexadecimal string and converts it to its decimal equivalent. The function should raise appropriate exceptions for invalid hexadecimal strings or non-string inputs. Function Signature ```python def hex_to_decimal_validated(hex_str: str) -> int: ``` Input * A single string `hex_str` representing a hexadecimal number which may have an optional \\"0x\\" or \\"0X\\" prefix. Output * An integer representing the decimal equivalent of the hexadecimal string. Constraints 1. The input string is always non-empty. 2. The hexadecimal string will only include characters from 0-9, a-f, A-F, and may have a leading \\"0x\\" or \\"0X\\". 3. Handle both positive and negative hexadecimal numbers (if it starts with \'-\'). Examples * `hex_to_decimal_validated(\\"0x1a3f\\")` should return `6719`. * `hex_to_decimal_validated(\\"1A3F\\")` should return `6719`. * `hex_to_decimal_validated(\\"-0X1a3f\\")` should return `-6719`. * `hex_to_decimal_validated(\\"3e7\\")` should return `999`. * `hex_to_decimal_validated(\\"-FF\\")` should return `-255`. Notes 1. Ensure that the function raises a `ValueError` for invalid hexadecimal strings and a `TypeError` for non-string inputs. 2. The function should ignore leading \\"0x\\" or \\"0X\\" if present, and validate the remaining characters as valid hexadecimal digits. 3. You must not use Python\'s built-in `int()` function with base 16 directly. Implement the conversion manually. Additional Implementation Details 1. Treat the input case-sensitively and process both lower and upper cases. 2. Consider edge cases like negative hex values, absence or presence of \\"0x\\" prefix. 3. Your solution should be efficient in handling strings up to a reasonable length (e.g., 1000 characters). ```python def hex_to_decimal_validated(hex_str: str) -> int: hex_map = {str(i): i for i in range(10)} hex_map.update({chr(i): i-55 for i in range(65, 71)}) # A-F to 10-15 hex_map.update({chr(i): i-87 for i in range(97, 103)}) # a-f to 10-15 # Check input type if not isinstance(hex_str, str): raise TypeError(\\"Input must be a string\\") # Handle negative values is_negative = hex_str.startswith(\'-\') if is_negative: hex_str = hex_str[1:] # Strip leading \\"0x\\" or \\"0X\\" if hex_str.startswith(\'0x\') or hex_str.startswith(\'0X\'): hex_str = hex_str[2:] # Validate hexadecimal characters if not all(c in hex_map for c in hex_str): raise ValueError(\\"Invalid hexadecimal string\\") # Convert hexadecimal to decimal manually decimal_value = 0 for char in hex_str: decimal_value = decimal_value * 16 + hex_map[char] return -decimal_value if is_negative else decimal_value ```","solution":"def hex_to_decimal_validated(hex_str: str) -> int: hex_map = {str(i): i for i in range(10)} hex_map.update({chr(i): i-55 for i in range(65, 71)}) # A-F to 10-15 hex_map.update({chr(i): i-87 for i in range(97, 103)}) # a-f to 10-15 # Check input type if not isinstance(hex_str, str): raise TypeError(\\"Input must be a string\\") # Handle negative values is_negative = hex_str.startswith(\'-\') if is_negative: hex_str = hex_str[1:] # Strip leading \\"0x\\" or \\"0X\\" if hex_str.startswith(\'0x\') or hex_str.startswith(\'0X\'): hex_str = hex_str[2:] # Validate hexadecimal characters if not all(c in hex_map for c in hex_str): raise ValueError(\\"Invalid hexadecimal string\\") # Convert hexadecimal to decimal manually decimal_value = 0 for char in hex_str: decimal_value = decimal_value * 16 + hex_map[char] return -decimal_value if is_negative else decimal_value"},{"question":"# Vowel Count Transformation Challenge **Context**: Transforming and analyzing strings is a common problem in text processing. In this challenge, you are tasked with creating a function to transform a given string by removing all the vowels and then counting the number of vowels that were removed. This problem can be approached by leveraging various string manipulation techniques and understanding the properties of character sets. You have three implementations of functions that perform similar tasks: 1. `remove_vowels1(s: str) -> Tuple[str, int]` 2. `remove_vowels2(s: str) -> Tuple[str, int]` 3. `remove_vowels3(s: str) -> Tuple[str, int]` # Task Your task is to implement a new function that removes all vowels from a given string and counts how many vowels were removed using an optimized and reliable method different from the provided implementations. Your solution will be evaluated based on correctness, efficiency, and handling edge cases effectively. # Specification * **Function Name**: `optimized_remove_vowels` * **Input**: - `s` (str): a string containing any combination of uppercase and lowercase letters, digits, and symbols. * **Output**: - Returns a tuple `(str, int)`: the transformed string with no vowels, and the count of vowels that were removed. # Constraints - The input string `s` can have up to `10^6` characters. - Your solution should handle edge cases such as empty strings and strings with no vowels. - Your implementation should not simply replicate the provided functions directly but aim to offer a different and possibly more optimized approach. # Examples ```python >>> optimized_remove_vowels(\\"hello\\") (\'hll\', 2) >>> optimized_remove_vowels(\\"abcdef\\") (\'bcdf\', 2) >>> optimized_remove_vowels(\\"xyz\\") (\'xyz\', 0) >>> optimized_remove_vowels(\\"AEIOUaeiou\\") (\'\', 10) >>> optimized_remove_vowels(\\"\\") (\'\', 0) >>> optimized_remove_vowels(\\"Python Programming!\\") (\'Pythn Prgrmmng!\', 4) ``` # Additional Requirement Include a brief paragraph in your solution describing why your approach is distinct and any trade-offs made. # Bonuses 1. **Runtime Efficiency**: Provide a runtime analysis comparing your implementation with the given functions for extremely large strings. 2. **Memory Efficiency**: Discuss any memory overhead reductions your implementation achieves compared to using built-in string manipulation functions.","solution":"def optimized_remove_vowels(s: str) -> tuple: Removes all vowels from a given string and counts how many vowels were removed. Parameters: s (str): Input string Returns: tuple: Transformed string with no vowels, and the count of vowels removed vowels = set(\\"aeiouAEIOU\\") removed_count = 0 result = [] for char in s: if char in vowels: removed_count += 1 else: result.append(char) return (\\"\\".join(result), removed_count) # Approach: # - The function uses a set to store vowels, which allows for O(1) average-time complexity for membership checks. # - For each character in the input string, the function checks if it is a vowel. # - If it is, it increments the removed_count; otherwise, it adds the character to the result list. # - At the end, it joins the list into a single string. # Trade-offs: # - This approach is efficient in terms of both time and space complexity, maintaining linear O(n) time complexity. # - Building the result string using a list is efficient in Python as lists are mutable. # - Using a set for vowels ensures faster membership testing compared to lists or strings. # Runtime Efficiency: # - This method looks through the string once and appends characters to a list, resulting in linear time complexity, O(n). # Memory Efficiency: # - The memory overhead is minimal, primarily associated with storing the result list and set of vowels."},{"question":"# Problem Statement Create a function named `binary_to_hex_str` that takes a binary string and converts it into its equivalent hexadecimal string, prefixed with \\"0x\\". # Function Signature ```python def binary_to_hex_str(binary_str: str) -> str: pass ``` # Input - **binary_str (str)**: A string representing a binary number (0 ≤ len(binary_str) ≤ 32) where each character is either \'0\' or \'1\'. # Output - **str**: The hexadecimal representation prefixed with \\"0x\\". # Constraints - The input string will always be a valid binary number without leading zeros (except for the special case of \\"0\\"). # Requirements 1. Ensure the result is in the correct hexadecimal format (e.g., binary \\"1100100\\" should return \\"0x64\\"). 2. Handle edge cases, such as `binary_str` being \\"0\\", which should properly return \\"0x0\\". 3. Optimize for performance and readability. # Examples ```python assert binary_to_hex_str(\\"0\\") == \\"0x0\\" assert binary_to_hex_str(\\"110\\") == \\"0x6\\" assert binary_to_hex_str(\\"1111\\") == \\"0xf\\" assert binary_to_hex_str(\\"101010\\") == \\"0x2a\\" ``` # Additional Context This function implementation will test your understanding of numerical base conversions and ensure you can handle basic string operations and Python\'s built-in functions for these conversions. This question maintains a similar complexity to typical base conversion problems, challenging your ability to translate between different numeral systems.","solution":"def binary_to_hex_str(binary_str: str) -> str: Converts a binary string to its equivalent hexadecimal string prefixed with \'0x\'. :param binary_str: A string representing a binary number. :return: A hexadecimal representation prefixed with \\"0x\\". if binary_str == \\"0\\": return \\"0x0\\" # Convert binary string to integer decimal_value = int(binary_str, 2) # Convert integer to hexadecimal string and prefix with \'0x\' hex_value = hex(decimal_value) return hex_value"},{"question":"# Question: Implement a Single-Linked List Manipulation System You are tasked with implementing a single-linked list and performing multiple operations on it. The linked list should support basic operations: adding a node, removing a node, and reversing the list. Functions to Implement: 1. **Node Class** - Represents a node in the linked list. - **Attributes**: - `value: int`: Value stored in the node. - `next: Optional[Node]`: Reference to the next node in the list. 2. **LinkedList Class** - Manages a singly linked list. - **Methods**: - `add_node(value: int)`: Adds a node with the given value to the end of the list. - `remove_node(value: int)`: Removes the first node with the given value from the list. - `reverse_list()`: Reverses the linked list. - `__str__()`: Returns a string representation of the list for easy visualization. **Constraints**: - Assume all values in the nodes are integers. **Example:** ```python # Creating a linked list and adding nodes ll = LinkedList() ll.add_node(1) ll.add_node(2) ll.add_node(3) print(ll) # Output: \\"1 -> 2 -> 3\\" # Removing a node ll.remove_node(2) print(ll) # Output: \\"1 -> 3\\" # Reversing the list ll.reverse_list() print(ll) # Output: \\"3 -> 1\\" ``` Implement the following classes and methods: ```python class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def add_node(self, value: int): pass def remove_node(self, value: int): pass def reverse_list(self): pass def __str__(self): pass ```","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def add_node(self, value: int): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove_node(self, value: int): current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next return prev = current current = current.next def reverse_list(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def __str__(self): values = [] current = self.head while current: values.append(current.value) current = current.next return \\" -> \\".join(map(str, values))"},{"question":"Directory Size Calculator **Objective**: Write a program to compute the total size of a directory, including all its subdirectories and files. **Scenario**: You are working on a file management system that needs to report the total storage used by a directory. The system must account for all nested subdirectories and their files to provide an accurate total size. Function Details: Implement the function `directory_size(path: str) -> int`: 1. **Input**: - `path` (str): The absolute or relative file path of the directory to be measured. - Constraints: The path must be a valid directory path on the system. 2. **Output**: - Returns the total size of the directory in bytes, including the sizes of all nested files and subdirectories. 3. **Error Handling**: - If the path does not exist or is not a directory, raise a `ValueError` with the message \\"Invalid directory path.\\" - If there are permissions issues accessing the files, raise a `PermissionError` with the message \\"Insufficient permissions to read the directory.\\" 4. **Performance Requirements**: - The solution should handle directories with a large number of files and nested subdirectories efficiently. Example Usage: ```python >>> directory_size(\\"/home/user/documents\\") 40960 >>> directory_size(\\"/var/log\\") 123456789 >>> directory_size(\\"./my_project\\") 204800 ``` # Requirements - Write clean and well-documented code. - Optimize the implementation to handle deep and large directory structures. **Hints**: - Consider using Python\'s built-in modules such as `os` and `os.path` for directory traversal and file size calculation. - Handling edge cases, such as symbolic links and permission issues, will ensure robustness in various file system configurations.","solution":"import os def directory_size(path): Computes the total size of a directory including all subdirectories and files. Args: path (str): The absolute or relative file path of the directory to be measured. Returns: int: The total size of the directory in bytes. Raises: ValueError: If the path does not exist or is not a directory. PermissionError: If there are permissions issues accessing the files. if not os.path.exists(path) or not os.path.isdir(path): raise ValueError(\\"Invalid directory path.\\") total_size = 0 for dirpath, dirnames, filenames in os.walk(path): for filename in filenames: filepath = os.path.join(dirpath, filename) try: total_size += os.path.getsize(filepath) except PermissionError: raise PermissionError(\\"Insufficient permissions to read the directory.\\") return total_size"},{"question":"# Problem Statement You are developing a new application that needs to compute the number of distinct island shapes in a given 2D grid. An island is a group of connected `1`s (land) connected horizontally or vertically (not diagonally). Two islands are considered distinct if one island\'s shape is different from another island\'s shape after considering all possible rotations (0°, 90°, 180°, 270°) and reflections (mirror images). Write a function `num_distinct_islands(grid: List[List[int]]) -> int` that calculates the number of distinct island shapes. # Expected Input and Output * **Input**: * `grid` (List[List[int]]): A 2D grid containing only `0`s (water) and `1`s (land). * **Output**: * Return an integer representing the number of distinct island shapes. # Constraints * The dimensions of the `grid` will be in the range [1, 50] x [1, 50]. # Example Input & Output *Example 1*: ```python grid = [ [1, 1, 0, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1] ] num_distinct_islands(grid) ``` *Output*: ```python 3 ``` *Explanation*: The three distinct islands are: 1. Shape 1 (2x2 square in the top-left) 2. Shape 2 (2 vertical cells in the bottom-right) 3. Shape 3 (single cell in the middle-right) *Example 2*: ```python grid = [ [1, 1, 1], [1, 0, 1], [0, 1, 1] ] num_distinct_islands(grid) ``` *Output*: ```python 1 ``` *Explanation*: The only distinct island shape is a 3x2 shape with central gap. # Performance Requirements * Optimize the solution to handle the constraint limits efficiently. Ensure that the solution uses effective data structures to manage and compare island shapes appropriately. # Scenario for Consideration Imagine you are working on a geographical survey project that requires identifying unique landmass shapes from satellite images. This application needs to recognize various unique landmasses irrespective of their orientation and mirrored appearance to catalogue them efficiently. Use the above function to implement such functionality.","solution":"from typing import List, Set, Tuple def rotate_90(shape): Rotate the shape by 90 degrees return [(y, -x) for x, y in shape] def reflect(shape): Reflect the shape about the y-axis return [(-x, y) for x, y in shape] def normalize_shape(shape): Normalize the shape by rotating and reflecting to the smallest lexicographical order shapes = set() current = shape for _ in range(4): # Rotate 0°, 90°, 180°, 270° current = rotate_90(current) min_representation = tuple(sorted(current)) shapes.add(min_representation) reflected = reflect(current) min_representation = tuple(sorted(reflected)) shapes.add(min_representation) return min(shapes) def num_distinct_islands(grid: List[List[int]]) -> int: def bfs(x, y): queue = [(x, y)] island_shape = [] grid[x][y] = -1 while queue: cx, cy = queue.pop(0) island_shape.append((cx - x, cy - y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # directions nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = -1 queue.append((nx, ny)) return island_shape m, n = len(grid), len(grid[0]) island_shapes = set() for i in range(m): for j in range(n): if grid[i][j] == 1: island_shape = bfs(i, j) normalized = normalize_shape(island_shape) island_shapes.add(normalized) return len(island_shapes)"},{"question":"# Coding Question **Find Most Frequent Word** You are given a list of words and you need to find the word that appears most frequently in the list. If there is a tie, return the word that comes first lexicographically. The function should be efficient in terms of time complexity. # Problem Statement: Implement a function called `most_frequent_word` that takes a list of strings `words` and returns the most frequent word. If there is a tie, return the lexicographically smallest word. # Constraints: 1. The length of the list `words` will be between 1 and 10^5. 2. Each word in `words` will contain only lowercase English letters and has a length between 1 and 10^5. # Function Signature: ```python def most_frequent_word(words: List[str]) -> str: Find the most frequent word in the list. If there is a tie, return the lexicographically smallest word. Parameters: words (List[str]): A list of strings representing words. Returns: str: The most frequent word. ``` # Example: ```python words1 = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] print(most_frequent_word(words1)) # Output: \\"apple\\" words2 = [\\"cat\\", \\"dog\\", \\"cat\\", \\"bird\\", \\"dog\\", \\"dog\\"] print(most_frequent_word(words2)) # Output: \\"dog\\" words3 = [\\"bat\\", \\"cat\\", \\"bat\\", \\"cat\\"] print(most_frequent_word(words3)) # Output: \\"bat\\" # both \\"bat\\" and \\"cat\\" appear twice, but \\"bat\\" is lexicographically smaller ``` # Algorithm: 1. Use a dictionary to count the frequency of each word in the list. 2. Iterate through the dictionary to find the word with the highest frequency. 3. In case of a tie (words with the same frequency), select the word that comes first lexicographically. 4. Return the word that meets the criteria. # Note: - Ensure that your solution is efficient and can handle the upper limits of the input size. - You may use Python\'s built-in libraries to assist with the word counting and sorting operations.","solution":"from typing import List from collections import Counter def most_frequent_word(words: List[str]) -> str: Find the most frequent word in the list. If there is a tie, return the lexicographically smallest word. Parameters: words (List[str]): A list of strings representing words. Returns: str: The most frequent word. word_count = Counter(words) max_frequency = max(word_count.values()) max_words = [word for word, count in word_count.items() if count == max_frequency] return min(max_words)"},{"question":"# Email Template Formatter As a web developer, you\'re tasked with creating a function that formats email templates for various occasions. The function should accept a template string with placeholders and a dictionary of values, and return the formatted email. Requirements: 1. The template string will contain placeholders in the format `{key}` which should be replaced by corresponding values in the dictionary. 2. If a placeholder does not have a corresponding value in the dictionary, it should remain unaltered. 3. Preserve any whitespace and special formatting within the template string. # Function Specification Implement a function `format_email_template(template: str, values: dict) -> str` that replaces placeholders in the template string with the corresponding values from the dictionary. Inputs: - `template`: A string containing placeholders in the format `{key}`. - `values`: A dictionary containing keys and values to replace corresponding placeholders in the template string. Outputs: - A string with all placeholders replaced by their corresponding values from the dictionary. Constraints: - The `template` string will be non-empty. - Placeholders in the template will be in the format `{key}`, with `key` being alphanumeric with no special characters or spaces. - The `values` dictionary will contain keys corresponding to some or all of the placeholders in the template. Performance Requirements: - The function should handle relatively large template strings (up to 10,000 characters) efficiently. - Only one pass through the template string should be used to make replacements. Example Usage: ```python template = \\"Dear {name},nnWe are pleased to inform you that your application for {position} has been {status}. Please contact {contact_person} for further details.nnBest regards,n{company}\\" values = { \\"name\\": \\"John Doe\\", \\"position\\": \\"Software Developer\\", \\"status\\": \\"accepted\\", \\"contact_person\\": \\"Jane Smith\\", \\"company\\": \\"Tech Corp\\" } formatted_email = format_email_template(template, values) print(formatted_email) # Output: # Dear John Doe, # # We are pleased to inform you that your application for Software Developer has been accepted. Please contact Jane Smith for further details. # # Best regards, # Tech Corp ```","solution":"def format_email_template(template: str, values: dict) -> str: Replace placeholders in the template string with corresponding dictionary values. formatted_template = template for key, value in values.items(): formatted_template = formatted_template.replace(f\\"{{{key}}}\\", value) return formatted_template"},{"question":"# Problem Statement You are tasked with creating a function `top_voted_questions(tag: str, time_period: str) -> list | None` which fetches and returns the list of the top voted questions from Stack Overflow for a given tag within a specified time period. # Function Signature ```python def top_voted_questions(tag: str, time_period: str) -> list | None: pass ``` # Input - **tag**: A string representing the tag to filter the questions by. - **time_period**: A string representing the time period to filter the questions by. It can be either \\"day\\", \\"week\\", or \\"month\\". # Output - Returns a list of dictionaries, where each dictionary contains: ```python { \\"question_title\\": \\"Question Title\\", \\"question_score\\": Score, \\"question_link\\": \\"https://stackoverflow.com/questions/{question_id}\\" } ``` If the input is invalid or an error occurs during fetching or parsing, the function should return `None`. # Constraints - The function should handle network timeouts and HTTP errors gracefully. - Use requests for HTTP GET requests and JSON parsing. - Validate the inputs to ensure they are not empty and that `time_period` is either \\"day\\", \\"week\\", or \\"month\\". # Requirements - Validate that both inputs are provided and are not empty strings. - Make an HTTP GET request to `https://api.stackexchange.com/2.3/questions?order=desc&sort=votes&tagged={tag}&site=stackoverflow&fromdate={from_date}` to fetch the top voted questions of the specified tag and time period. - Parse the JSON response to extract the list of question titles, scores, and URLs to the questions. - Handle potential errors gracefully by returning `None`. # Example ```python >>> top_voted_questions(\\"python\\", \\"week\\") [{\'question_title\': \'What is the difference between semicolons and newlines in Python?\', \'question_score\': 543, \'question_link\': \'https://stackoverflow.com/questions/12345678\'}, {\'question_title\': \'How do I use the map function in Python?\', \'question_score\': 389, \'question_link\': \'https://stackoverflow.com/questions/23456789\'}, ...] ``` # Notes - Consider edge cases such as empty strings for the tag or an invalid time period. - Optimize error handling to ensure the function survives typical network or parsing errors.","solution":"import requests from datetime import datetime, timedelta def top_voted_questions(tag: str, time_period: str) -> list | None: if not tag or time_period not in {\\"day\\", \\"week\\", \\"month\\"}: return None end_date = int(datetime.now().timestamp()) if time_period == \\"day\\": start_date = int((datetime.now() - timedelta(days=1)).timestamp()) elif time_period == \\"week\\": start_date = int((datetime.now() - timedelta(days=7)).timestamp()) elif time_period == \\"month\\": start_date = int((datetime.now() - timedelta(days=30)).timestamp()) url = f\\"https://api.stackexchange.com/2.3/questions?order=desc&sort=votes&tagged={tag}&site=stackoverflow&fromdate={start_date}&todate={end_date}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() questions = [] for item in data.get(\\"items\\", []): question = { \\"question_title\\": item[\\"title\\"], \\"question_score\\": item[\\"score\\"], \\"question_link\\": f\'https://stackoverflow.com/questions/{item[\\"question_id\\"]}\' } questions.append(question) return questions except (requests.RequestException, KeyError, ValueError): return None"},{"question":"# Context In data analysis, aggregating information over a sliding window of fixed size is a common task. By computing a statistic (such as sum, average, max, etc.) over subsets of the data known as windows, one can observe trends and detect anomalies over time. This technique is widely used in signal processing, time series analysis, and real-time data processing. # Problem You need to implement a function `sliding_window_sum(arr: list[int | float], k: int) -> list[float]` that takes a list of numeric values `arr` and an integer `k` representing the window size, and returns a list of sums where each sum is calculated over a window of size `k` that slides across the array from left to right. # Detailed Requirements 1. **Window Sum Calculation**: - Create a sliding window of size `k` from the start of the list and sum up the elements within that window. - Slide the window one element to the right and calculate the sum for the new window. - Repeat the process until the window can no longer slide (i.e., when the end of the window exceeds the last element of the list). 2. **Edge Case Handling**: - If `k` is greater than the length of the list, return an empty list. - If the list is empty or `k` is less than or equal to 0, return an empty list. 3. **Return Value**: The function returns a list of float values representing the sums of each sliding window. # Function Signature ```python def sliding_window_sum(arr: list[int | float], k: int) -> list[float]: ``` # Example ```python >>> sliding_window_sum(arr=[1, 2, 3, 4, 5], k=3) [6.0, 9.0, 12.0] >>> sliding_window_sum(arr=[10, 20, 30], k=2) [30.0, 50.0] >>> sliding_window_sum(arr=[1.5, 2.5, 3.5, 4.5], k=2) [4.0, 6.0, 8.0] >>> sliding_window_sum(arr=[1, -1, 1, -1, 1], k=1) [1.0, -1.0, 1.0, -1.0, 1.0] >>> sliding_window_sum(arr=[2, 4, 6], k=4) [] >>> sliding_window_sum(arr=[], k=3) [] >>> sliding_window_sum(arr=[3, 5, 7], k=0) [] ``` # Constraints 1. The input list will have at most 10^5 elements. 2. The window size `k` will be an integer where `0 <= k <= 10^5`. 3. The elements of the list will be integers or floats. # Notes - Focus on efficient calculations to handle large lists and window sizes. - Ensure the function is optimized for performance and handles potential edge cases.","solution":"def sliding_window_sum(arr: list[int | float], k: int) -> list[float]: Returns a list of sums calculated over a sliding window of size k across the list arr. if not arr or k <= 0 or k > len(arr): return [] window_sum = sum(arr[:k]) result = [float(window_sum)] for i in range(len(arr) - k): window_sum = window_sum - arr[i] + arr[i + k] result.append(float(window_sum)) return result"},{"question":"# Question **Zigzag Array** A zigzag array is defined as an array where the difference between adjacent elements alternates between positive and negative. In other words, the differences A[1] - A[0], A[2] - A[1], A[3] - A[2], ... should all switch signs. Write a function `is_zigzag_array(arr: List[int]) -> bool` that determines whether a given array is a zigzag array. # Input - `arr` (List of integers): The array to be checked, `2 <= len(arr) <= 10^5`. # Output - Returns `True` if the array is a zigzag array, otherwise `False`. # Constraints - The length of the array will be at least 2 and at most 100,000. # Example ```python def is_zigzag_array(arr: List[int]) -> bool: # Your implementation here. # Example Usage print(is_zigzag_array([1, 3, 2, 4])) # Expected output: True print(is_zigzag_array([1, 2, 3, 4])) # Expected output: False ``` # Explanation - In the first example, the differences are: - 3 - 1 = 2 (positive) - 2 - 3 = -1 (negative) - 4 - 2 = 2 (positive) The differences alternate in sign, so the array is a zigzag array. - In the second example, the differences are: - 2 - 1 = 1 (positive) - 3 - 2 = 1 (positive) - 4 - 3 = 1 (positive) The differences do not alternate in sign, so the array is not a zigzag array.","solution":"from typing import List def is_zigzag_array(arr: List[int]) -> bool: for i in range(1, len(arr) - 1): if not ((arr[i] > arr[i-1] and arr[i] > arr[i+1]) or (arr[i] < arr[i-1] and arr[i] < arr[i+1])): return False return True"},{"question":"**Meeting Room Scheduler** You are provided with a task to determine if a person can attend all meetings based on the given schedule. Each meeting is represented by a time interval `[start, end)` where `start` is inclusive and `end` is exclusive. The goal is to verify if none of the meetings overlap. **Function Signature**: ```python def can_attend_all_meetings(intervals: list[list[int]]) -> bool: pass ``` **Input**: - `intervals`: A list of lists where each sublist contains exactly two integers `[start, end)` representing the start and end times of a meeting. **Output**: - A boolean value `True` if the person can attend all meetings, otherwise `False`. **Constraints**: - The `intervals` list contains between 1 and 1000 sublists. - The meeting times are represented as non-negative integers. - The `start` time is always less than the `end` time within each sublist. **Example**: ```python >>> can_attend_all_meetings([[0, 30], [5, 10], [15, 20]]) False >>> can_attend_all_meetings([[7, 10], [2, 4]]) True ``` **Explanation**: 1. For the first example: - The meeting `[0, 30]` overlaps with both `[5, 10]` and `[15, 20]`, so it\'s not possible to attend all meetings. 2. For the second example: - No meetings overlap, so it is possible to attend all meetings. **Performance Requirements**: Optimize your solution to efficiently handle the upper constraints. Sorting the meetings by their start time and then checking for any overlaps can achieve a time complexity of `O(n log n)` followed by a linear scan, which is sufficient for the given constraints. **Scenarios**: Consider scenarios such as scheduling software for conference rooms, hospital appointment systems, or personal calendar management to contextualize this problem in real-life applications.","solution":"def can_attend_all_meetings(intervals): Determines if a person can attend all meetings given intervals [start, end). Args: intervals (list of list of int): A list of meetings where each meeting is represented as [start, end]. Returns: bool: True if the person can attend all meetings, False otherwise. # Sort intervals based on start time intervals.sort(key=lambda x: x[0]) # Check for any overlaps for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"# Coding Question: You are tasked with implementing a function to find the shortest path in a graph represented as an adjacency matrix. # Problem Statement: Design the `shortest_path` function to determine the shortest path from a given start node to a target node in a weighted, undirected graph represented by an adjacency matrix. **Function Signature:** ```python def shortest_path(matrix: list[list[int]], start: int, target: int) -> int: pass ``` # Input: 1. `matrix`: A 2D list where `matrix[i][j]` represents the weight of the edge between node `i` and node `j`. If `i == j`, `matrix[i][j]` is 0. A value of `float(\'inf\')` represents no direct path between the nodes. 2. `start`: An integer, the starting node index. 3. `target`: An integer, the target node index. # Output: An integer representing the shortest path cost from the `start` node to the `target` node. If no path exists, return `float(\'inf\')`. # Constraints: - The input graph is guaranteed to be non-empty and contain at least one node. - Nodes are zero-indexed. - The sum of the weights in the adjacency matrix does not exceed an acceptable limit for practical calculations. # Example: ```python >>> matrix = [ ... [0, 3, 1, float(\'inf\')], ... [3, 0, 7, 5], ... [1, 7, 0, 2], ... [float(\'inf\'), 5, 2, 0] ... ] >>> start = 0 >>> target = 3 >>> shortest_path(matrix, start, target) 3 >>> matrix = [ ... [0, float(\'inf\'), float(\'inf\')], ... [float(\'inf\'), 0, float(\'inf\')], ... [float(\'inf\'), float(\'inf\'), 0] ... ] >>> start = 0 >>> target = 2 >>> shortest_path(matrix, start, target) float(\'inf\') ``` # Notes: - Use Dijkstra\'s algorithm to solve this problem. - Assume all edge weights are positive. - Carefully manage nodes and distances to ensure optimal performance for reasonably large graphs.","solution":"import heapq def shortest_path(matrix, start, target): Returns the shortest path cost from start node to target node in a weighted, undirected graph represented by an adjacency matrix. If no path exists, returns float(\'inf\'). n = len(matrix) distances = [float(\'inf\')] * n distances[start] = 0 visited = [False] * n min_heap = [(0, start)] while min_heap: current_distance, current_node = heapq.heappop(min_heap) if visited[current_node]: continue visited[current_node] = True for neighbor in range(n): if matrix[current_node][neighbor] != float(\'inf\') and not visited[neighbor]: distance = current_distance + matrix[current_node][neighbor] if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances[target]"},{"question":"# Matrix Transposition Scenario You are working on a data processing library where handling large datasets efficiently is crucial. One common data manipulation task is transposing matrices. Transposing a matrix involves swapping the rows and columns, which is often required in various mathematical and data processing contexts. Task Implement a function that receives a rectangular matrix (a list of lists) and returns its transpose. The matrix can have any dimensions but is guaranteed to be non-empty. The transpose of a matrix is achieved by swapping its rows with its columns. Function **Function `transpose_matrix`:** - **Input**: A list of lists `matrix` representing a rectangular matrix. Each inner list is a row, and all inner lists have the same length, though it is guaranteed to be a non-empty matrix. - **Output**: A transposed version of the input matrix, which is also a list of lists where each inner list is now a column from the original matrix. ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transpose the given matrix. Parameters: - matrix (list[list[int]]): A list of lists of integers representing a non-empty rectangular matrix Returns: - list[list[int]]: A transposed version of the input matrix # Your code here ``` Examples ```python # Example 1 matrix1 = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix1)) # [[1, 4], [2, 5], [3, 6]] # Example 2 matrix2 = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] print(transpose_matrix(matrix2)) # [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # Example 3 matrix3 = [ [1, 2], [3, 4], [5, 6] ] print(transpose_matrix(matrix3)) # [[1, 3, 5], [2, 4, 6]] ``` Constraints * The input matrix is guaranteed to be non-empty. * Ensure that your function handles different dimensions efficiently, including square matrices, wide rectangular matrices, and tall rectangular matrices. * You can assume all inner lists (rows of the matrix) are of equal length.","solution":"def transpose_matrix(matrix): Transpose the given matrix. Parameters: - matrix (list[list[int]]): A list of lists of integers representing a non-empty rectangular matrix Returns: - list[list[int]]: A transposed version of the input matrix return [list(row) for row in zip(*matrix)]"},{"question":"# Sort List of Objects by Multiple Criteria Context You are asked to implement a function that sorts a list of objects by multiple criteria. The objects represent students with their respective attributes: `name` (str), `age` (int), and `grade` (float). The sorting should be done primarily by grade in descending order, secondarily by age in ascending order, and finally by name in lexicographical order. Task Implement a function `sort_students(students: List[Dict[str, Union[str, int, float]]]) -> List[Dict[str, Union[str, int, float]]]` that receives a list of student objects and returns the list sorted based on the specified criteria. Input Specifications - `students` (List[Dict[str, Union[str, int, float]]]): A list of dictionaries where each dictionary has: - `name` (str): The name of the student. - `age` (int): The age of the student. - `grade` (float): The grade of the student. Output Specifications - (List[Dict[str, Union[str, int, float]]]): The list of student objects sorted by the specified criteria. Constraints - The list will contain at least one student and at most 1000 students. - Names will consist of only alphabetical characters and will be at least one character long. Example ```python students = [ {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 88.5}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"grade\\": 88.5}, {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grade\\": 91.0}, {\\"name\\": \\"Dave\\", \\"age\\": 23, \\"grade\\": 88.5} ] sorted_students = sort_students(students) ``` Output: ```python [ {\\"name\\": \\"Charlie\\", \\"age\\": 23, \\"grade\\": 91.0}, {\\"name\\": \\"Alice\\", \\"age\\": 23, \\"grade\\": 88.5}, {\\"name\\": \\"Dave\\", \\"age\\": 23, \\"grade\\": 88.5}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"grade\\": 88.5} ] ``` # Implementation Implement the function `sort_students` using the template below: ```python from typing import List, Dict, Union def sort_students(students: List[Dict[str, Union[str, int, float]]]) -> List[Dict[str, Union[str, int, float]]]: return sorted(students, key=lambda student: (-student[\\"grade\\"], student[\\"age\\"], student[\\"name\\"])) ```","solution":"from typing import List, Dict, Union def sort_students(students: List[Dict[str, Union[str, int, float]]]) -> List[Dict[str, Union[str, int, float]]]: Sorts a list of student dictionaries by grade in descending order, age in ascending order, and name in lexicographical order. return sorted(students, key=lambda student: (-student[\\"grade\\"], student[\\"age\\"], student[\\"name\\"]))"},{"question":"# Scenario: You are developing a Python utility to manage contacts for a small business. The utility should allow users to add new contacts, find contacts by name, and display all contacts sorted by their names. Each contact has a name and a phone number. Your task is to implement a class `ContactManager` that provides these functionalities. # Task: Write a class `ContactManager` with the following methods: 1. `add_contact(name: str, phone: str) -> None`: Adds a new contact to the contact list. 2. `find_contact(name: str) -> str`: Finds and returns the phone number of the contact with the specified name. If the contact does not exist, return a message indicating so. 3. `display_contacts() -> None`: Displays all contacts, sorted by their names, in the format \\"Name: Phone\\". # Example: ```python class ContactManager: def __init__(self): self.contacts = [] def add_contact(self, name: str, phone: str) -> None: pass # Implement the method here def find_contact(self, name: str) -> str: pass # Implement the method here def display_contacts(self) -> None: pass # Implement the method here # Example usage: manager = ContactManager() manager.add_contact(\\"Alice\\", \\"123-456-7890\\") manager.add_contact(\\"Bob\\", \\"098-765-4321\\") print(manager.find_contact(\\"Alice\\")) # Outputs: 123-456-7890 print(manager.find_contact(\\"Charlie\\")) # Outputs: Contact not found. manager.display_contacts() # Outputs: # Alice: 123-456-7890 # Bob: 098-765-4321 ``` Input: - `name`: A string representing the contact\'s name. - `phone`: A string representing the contact\'s phone number. Output: - For `find_contact`, return the contact\'s phone number or a \\"Contact not found\\" message. - For `display_contacts`, print all contacts sorted by name in the format \\"Name: Phone\\". Constraints: - Contact names are case-sensitive. - Assume that names are unique.","solution":"class ContactManager: def __init__(self): self.contacts = {} def add_contact(self, name: str, phone: str) -> None: Adds a new contact to the contact list. self.contacts[name] = phone def find_contact(self, name: str) -> str: Finds and returns the phone number of the contact with the specified name. If the contact does not exist, returns a message indicating so. return self.contacts.get(name, \\"Contact not found\\") def display_contacts(self) -> None: Displays all contacts, sorted by their names, in the format \\"Name: Phone\\". for name in sorted(self.contacts): print(f\\"{name}: {self.contacts[name]}\\")"},{"question":"You are required to develop a function that simulates the First Come First Serve (FCFS) disk scheduling algorithm. The FCFS scheduling algorithm services the disk requests in the order they arrive. # Function Specifications ```python def fcfs_disk_scheduling(requests: list[int], head_start: int) -> tuple[list[int], int]: pass ``` # Input * `requests`: A list of integers where each integer represents a disk request. * `head_start`: An integer representing the initial position of the disk head. # Output * A tuple containing: * A list of integers representing the order in which the disk head will process the requests. * An integer representing the total number of head movements. # Constraints * 1 ≤ len(requests) ≤ 1000 * 0 ≤ requests[i] ≤ 1000 * 0 ≤ head_start ≤ 1000 # Requirements * Implement the function using the First Come First Serve (FCFS) disk scheduling algorithm. * Calculate the total number of head movements needed to process all the requests. * Ensure your code handles all edge cases such as no disk requests or head start at the same position as a request. # Example ```python # Inputs requests = [98, 183, 37, 122, 14, 124, 65, 67] head_start = 53 # Function: fcfs_disk_scheduling order, total_movements = fcfs_disk_scheduling(requests, head_start) # Order Output: [53, 98, 183, 37, 122, 14, 124, 65, 67] # Total Head Movements Output: 640 ``` Explanation: - Initial head position is at 53. - Service first request at 98: Movement = |98 - 53| = 45 - Move to next request at 183: Movement = |183 - 98| = 85 - Continue servicing until the last request in the given order. - Total head movements = 45 + 85 + 146 + 85 + 108 + 110 + 59 + 2 = 640 ***","solution":"def fcfs_disk_scheduling(requests: list[int], head_start: int) -> tuple[list[int], int]: Simulates the First Come First Serve (FCFS) disk scheduling algorithm. Parameters: - requests: List of disk requests. - head_start: Initial position of the disk head. Returns: - A tuple containing the order of requests and the total number of head movements. # Initialize the total number of head movements and the starting position total_head_movements = 0 current_head_position = head_start # List to keep track of the order of positions visited (starting with the initial position) order = [head_start] # Process each request in the order they are given for request in requests: # Calculate the head movements to the current request movement = abs(current_head_position - request) total_head_movements += movement # Move the head to the current request current_head_position = request order.append(request) return (order, total_head_movements)"},{"question":"# Coding Problem: You are provided with a list of integers representing amounts of money. You need to find out if it is possible to split these amounts into two equal sum subsets. Implement a function to check this condition. Problem Statement: Given a list of integers `amounts`, implement a function `can_split_equally(amounts: list) -> bool` to return `True` if you can split the list into two subsets that have equal sum, otherwise return `False`. # Function Signature: ```python def can_split_equally(amounts: list) -> bool: ``` # Input: - A list of integers `amounts` where each integer represents an amount of money, with list length ranging from 0 to 100 and individual values from 0 to 100. # Output: - A boolean value `True` if the list can be split into two subsets with equal sum, otherwise `False`. # Constraints: - The input list can contain zero or more integers. - Use dynamic programming or any optimal algorithm to solve the problem. # Example: ```python assert can_split_equally([1, 5, 11, 5]) == True assert can_split_equally([1, 2, 3, 5]) == False assert can_split_equally([2, 2, 2, 2]) == True ``` # Detailed Requirements: * Implement a dynamic programming approach to determine if such a partition is possible. * Handle edge cases where the list length is zero or where all integers are the same. # Performance Requirements: * Your solution should efficiently handle lists up to 100 elements long. * Aim for a time complexity that ensures the solution is practical for the given constraints. # Example Scenario: Given the list `[1, 5, 11, 5]`, you can split it into subsets `[1, 5, 5]` and `[11]` which both sum to 11. Given the list `[1, 2, 3, 5]`, no split is possible that results in equal sums, so the result is `False`. Good luck!","solution":"def can_split_equally(amounts: list) -> bool: Checks if the list can be partitioned into two subsets with equal sum. total_sum = sum(amounts) # If total sum is odd, it cannot be split equally if total_sum % 2 != 0: return False target = total_sum // 2 n = len(amounts) # Create a dp array where dp[i] will be True if a sum i can be achieved with the elements dp = [False] * (target + 1) dp[0] = True for amount in amounts: # Traverse backwards to make sure we do not overwrite values we still need to consider within this iteration for i in range(target, amount - 1, -1): dp[i] = dp[i] or dp[i - amount] return dp[target]"},{"question":"# Coding Challenge Scenario You are developing a utility for a filesystem manager which needs to simplify file paths. Given an absolute path for a file (Unix-style), your task is to simplify it. For example, the absolute path `/home/` should be simplified to `/home` and the path `/a/./b/../../c/` should be simplified to `/c`. Task Implement the function `simplify_path(path: str) -> str` which simplifies the given Unix-style absolute path by resolving `.` and `..` and removing any redundant slashes. # Input and Output - **Input**: A string `path` representing the absolute path. - **Output**: A string representing the simplified absolute path. # Constraints - The `path` is a non-empty string containing characters from the set `{a-z, A-Z, 0-9, ., /}`. - The path always starts with a slash `/`. # Performance Requirements - Your solution should aim for ( O(n) ) time complexity and ( O(n) ) space complexity, where ( n ) is the length of the input string. # Validations - Ensure your implementation handles edge cases including multiple slashes and paths that resolve beyond the root directory. # Examples - `simplify_path(\\"/home/\\")` should return `\\"/home\\"` - `simplify_path(\\"/../\\")` should return `\\"/\\"` - `simplify_path(\\"/home//foo/\\")` should return `\\"/home/foo\\"` - `simplify_path(\\"/a/./b/../../c/\\")` should return `\\"/c\\"` # Additional Notes - You can assume that typical inputs are valid Unix-style paths. - Your function should not modify the original input string but rather construct and return a new simplified path.","solution":"def simplify_path(path: str) -> str: Simplify the given Unix-style absolute path by resolving `.` and `..` and removing any redundant slashes. components = path.split(\'/\') path_stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if path_stack: path_stack.pop() else: path_stack.append(component) return \'/\' + \'/\'.join(path_stack)"},{"question":"# Problem Statement Create an implementation of a K-Means clustering algorithm that handles high-dimensional integer data and includes methods for optimal centroid initialization using the K-Means++ algorithm. You will also implement a method that evaluates the clustering quality using the Silhouette Coefficient. # Requirements 1. **Input**: - `data`: A two-dimensional list of integers, where each sublist represents a data point with multiple features. - `k` (int): Number of clusters to form. Default value: 3. - `max_iter` (int): Maximum number of iterations for the K-Means algorithm. Default value: 300. - `tol` (float): Tolerance to declare convergence. Default value: 1e-4. 2. **Output**: - You will create three methods: `fit(data)` to perform the clustering, `predict(data)` to assign each data point to a cluster, and `silhouette_score(data)` to evaluate clustering. # Constraints - The number of data points in `data` will be at least 2 and not more than 10,000. - Each data point will have at least 2 features and not more than 500 features. - All integers in `data` are between 0 and 1000, inclusive. # Example ```python # Sample inputs data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 0, 1], [4, 3, 5], [9, 7, 8] ] # Creating the K-Means model kmeans = KMeansClustering(k=2, max_iter=100, tol=1e-3) kmeans.fit(data) # Predicting cluster assignments new_data = [3, 3, 3] prediction = kmeans.predict(new_data) print(f\\"Cluster for {new_data}: {prediction}\\") # Evaluating clustering quality score = kmeans.silhouette_score(data) print(f\\"Silhouette Score: {score}\\") ``` # Instructions: 1. Implement the class `KMeansClustering` with methods: - `__init__(self, k=3, max_iter=300, tol=1e-4)`: Initialize attributes. - `init_centroids(self, data)`: Initialize centroids using K-Means++ method. - `fit(self, data)`: Perform the K-Means clustering on the input data. - `predict(self, data_point)`: Assign the given data point to one of the clusters. - `silhouette_score(self, data)`: Compute the Silhouette Coefficient for the clustering. 2. Ensure the implementation is scalable and performs efficiently as per the constraints. 3. The method `silhouette_score` should evaluate the segregation of clusters and provide a measure of how aptly the data points have been clustered. # Note: - Make sure you use appropriate distance measures and vectorized operations where applicable. - Handle edge cases like potential convergence before `max_iter` iterations.","solution":"import random import numpy as np class KMeansClustering: def __init__(self, k=3, max_iter=300, tol=1e-4): self.k = k self.max_iter = max_iter self.tol = tol self.centroids = [] def init_centroids(self, data): n = len(data) centroids = [] centroids.append(data[random.randint(0, n-1)]) for _ in range(1, self.k): distances = [] for datapoint in data: min_distance = float(\'inf\') for centroid in centroids: dist = np.linalg.norm(np.array(datapoint) - np.array(centroid)) min_distance = min(min_distance, dist) distances.append(min_distance) distances = np.array(distances) probabilities = distances / distances.sum() next_centroid_index = np.random.choice(range(n), p=probabilities) centroids.append(data[next_centroid_index]) self.centroids = centroids def fit(self, data): data = np.array(data) self.init_centroids(data) prev_centroids = np.zeros((self.k, data.shape[1])) for _ in range(self.max_iter): if np.all(np.abs(np.array(self.centroids) - np.array(prev_centroids)) < self.tol): break clusters = [[] for _ in range(self.k)] for datapoint in data: distances = [np.linalg.norm(datapoint - centroid) for centroid in self.centroids] min_distance_index = np.argmin(distances) clusters[min_distance_index].append(datapoint) prev_centroids = self.centroids.copy() for i, cluster in enumerate(clusters): if cluster: self.centroids[i] = np.mean(cluster, axis=0) def predict(self, data_point): data_point = np.array(data_point) distances = [np.linalg.norm(data_point - centroid) for centroid in self.centroids] return np.argmin(distances) def silhouette_score(self, data): import sklearn.metrics data = np.array(data) labels = np.array([self.predict(datapoint) for datapoint in data]) score = sklearn.metrics.silhouette_score(data, labels, metric=\'euclidean\') return score"},{"question":"Problem Statement You have been given a dataset of stock prices for a specific company over a period of time. Your task is to implement a function that detects and returns the periods where the stock prices were continuously increasing for a specified minimum number of days. # Function to Implement ```python def find_increasing_periods(prices, min_days): Find and return the periods where the stock prices were continuously increasing for at least min_days. @param prices: A list of float values representing the stock prices. @param min_days: An integer representing the minimum number of consecutive days the prices should be increasing. @return: A list of tuples, where each tuple contains the start and end index of a period where the stock prices were continuously increasing for at least min_days. # Your code here pass ``` # Input and Output Formats Input - `prices`: A list of float values representing the stock prices. - `min_days`: An integer representing the minimum number of consecutive days the prices should be increasing. Output - A list of tuples, where each tuple contains the start and end index of a period where the stock prices were continuously increasing for at least `min_days`. # Constraints - The list `prices` will have at least one element and at most 10^6 elements. - The integer `min_days` will be between 1 and the length of the `prices` list (inclusive). # Example ```python # Example Input: prices = [100.0, 101.5, 102.3, 100.2, 101.0, 101.5, 102.0, 101.8, 102.5] min_days = 2 # Example Output: # [(0, 2), (3, 6), (7, 8)] print(find_increasing_periods(prices, min_days)) ``` # Notes - The function should detect periods where each price in the period is strictly higher than the previous price. - Overlapping or adjacent periods should be combined into a single period. - If no such periods exist, the function should return an empty list. - Consider edge cases where periods might occur at the start or end of the list without sufficient room to increase further.","solution":"def find_increasing_periods(prices, min_days): Find and return the periods where the stock prices were continuously increasing for at least min_days. @param prices: A list of float values representing the stock prices. @param min_days: An integer representing the minimum number of consecutive days the prices should be increasing. @return: A list of tuples, where each tuple contains the start and end index of a period where the stock prices were continuously increasing for at least min_days. result = [] n = len(prices) start = None for i in range(1, n): if prices[i] > prices[i - 1]: # Current price is increasing compared to the previous day if start is None: start = i - 1 # Mark the start of a new increasing period else: if start is not None: if i - start >= min_days: result.append((start, i - 1)) start = None # Reset the start pointer # Check the last possible increasing period if the list ended during an increasing streak if start is not None and n - start >= min_days: result.append((start, n - 1)) return result"},{"question":"# Temperature Conversion Tool **Objective**: Implement a function that converts temperature values between Celsius, Fahrenheit, and Kelvin, while handling common edge cases and ensuring accuracy. **Scenario**: In a scientific application, users may need to convert temperature readings among different units. The task is to develop a tool that can take a temperature value and its current unit, then return the converted values in other units. **Requirements**: - Define a function `convert_temperature(value: float, unit: str) -> dict` that: - Takes a temperature value (float) and its unit (string, with possible values \\"C\\", \\"F\\", \\"K\\" indicating Celsius, Fahrenheit, Kelvin). - Returns a dictionary with keys `\\"Celsius\\"`, `\\"Fahrenheit\\"`, and `\\"Kelvin\\"` and their respective converted values. - Handle invalid units by returning an error message. - Consider the absolute zero limits (-273.15°C, -459.67°F, 0 K) and handle temperatures below these limits gracefully. **Function Signature**: ```python def convert_temperature(value: float, unit: str) -> dict: pass ``` **Constraints**: - The unit input will be one of the following strings: \\"C\\", \\"F\\", \\"K\\". - The temperature value will be within a reasonable range of floats. **Examples**: 1. `convert_temperature(100, \\"C\\")` - Might return: ```python { \\"Celsius\\": 100.0, \\"Fahrenheit\\": 212.0, \\"Kelvin\\": 373.15 } ``` 2. `convert_temperature(32, \\"F\\")` - Should return: ```python { \\"Celsius\\": 0.0, \\"Fahrenheit\\": 32.0, \\"Kelvin\\": 273.15 } ``` 3. `convert_temperature(300, \\"K\\")` - Should return: ```python { \\"Celsius\\": 26.85, \\"Fahrenheit\\": 80.33, \\"Kelvin\\": 300.0 } ``` 4. `convert_temperature(-500, \\"K\\")` - Should return: ```python { \\"error\\": \\"Temperature below absolute zero (0 K) is not possible.\\" } ``` 5. `convert_temperature(36.6, \\"Z\\")` - Should return: ```python { \\"error\\": \\"Invalid unit provided. Must be \'C\', \'F\', or \'K\'.\\" } ```","solution":"def convert_temperature(value: float, unit: str) -> dict: Convert a given temperature to Celsius, Fahrenheit, and Kelvin. Parameters: value (float): The temperature value. unit (str): The unit of the temperature value. Must be one of \'C\', \'F\', \'K\'. Returns: dict: A dictionary with keys \'Celsius\', \'Fahrenheit\', and \'Kelvin\'. Included converted temperature values, or an error message. if unit == \\"C\\": if value < -273.15: return {\\"error\\": \\"Temperature below absolute zero (-273.15°C) is not possible.\\"} celsius = value fahrenheit = (value * 9/5) + 32 kelvin = value + 273.15 elif unit == \\"F\\": if value < -459.67: return {\\"error\\": \\"Temperature below absolute zero (-459.67°F) is not possible.\\"} celsius = (value - 32) * 5/9 fahrenheit = value kelvin = celsius + 273.15 elif unit == \\"K\\": if value < 0: return {\\"error\\": \\"Temperature below absolute zero (0 K) is not possible.\\"} celsius = value - 273.15 fahrenheit = (celsius * 9/5) + 32 kelvin = value else: return {\\"error\\": \\"Invalid unit provided. Must be \'C\', \'F\', or \'K\'.\\"} return { \\"Celsius\\": round(celsius, 2), \\"Fahrenheit\\": round(fahrenheit, 2), \\"Kelvin\\": round(kelvin, 2) }"},{"question":"# Graph Traversal by BFS Objective Implement a function to perform Breadth-First Search (BFS) traversal on a graph. The graph will be represented as an adjacency list, and you will need to return the traversal order starting from a given node. Description Given a graph in the form of an adjacency list and a starting node, your task is to write a function that returns the list of nodes in the order they are visited using BFS traversal. Function Signature ```python def bfs_traversal(graph: Dict[int, List[int]], start_node: int) -> List[int]: pass ``` Input * `graph` (Dict[int, List[int]]): The graph represented as an adjacency list, where keys are node identifiers, and values are lists of adjacent nodes. It is guaranteed that all node identifiers are integers. * `start_node` (int): The node from which to begin the BFS traversal. Output * Returns a list of integers representing the nodes in the order they were visited during the BFS traversal. Constraints * The graph does not contain any self-loops or duplicate edges. * The graph may be disconnected, but you only need to perform BFS starting from the given start node. Examples ```python >>> bfs_traversal({0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4]}, 0) [0, 1, 2, 3, 4, 5] >>> bfs_traversal({0: [1], 1: [0, 2], 2: [1]}, 2) [2, 1, 0] >>> bfs_traversal({}, 0) [] >>> bfs_traversal({1: [], 2: []}, 1) [1] ``` Additional Information * Assume that if the graph is empty and the start node is given, the function should return an empty list. * Consider edge cases such as disconnected graphs or components not connected to the start node. Performance Expectations * Expected to handle large graphs up to 10^5 nodes and edges efficiently. * Use appropriate data structures and techniques to ensure BFS operates within acceptable time limits for the given constraints.","solution":"from collections import deque from typing import Dict, List def bfs_traversal(graph: Dict[int, List[int]], start_node: int) -> List[int]: Perform BFS traversal on a graph starting from the given start node. :param graph: A dictionary representing the adjacency list of the graph. :param start_node: The node from which to start the BFS traversal. :return: A list of nodes in the order they were visited during BFS. if not graph or start_node not in graph: return [] visited = set() queue = deque([start_node]) traversal_order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return traversal_order"},{"question":"# Problem Statement Write a function named `can_reach_end` that determines whether it\'s possible to reach the last position in an array of non-negative integers, where each element represents the maximum number of steps you can move forward from that position. # Detailed Requirements * Define a function `can_reach_end(arr: List[int]) -> bool`. * The function takes a single input: a list of non-negative integers. * Starting from the first index, determine if it is possible to reach the last index of the array by moving forward according to the maximum steps at each position. # Input and Output - **Input**: A list of non-negative integers. - **Output**: A boolean, `True` if it\'s possible to reach the last position, `False` otherwise. **Constraints:** 1. The list will have at least 1 element and no more than 10,000 elements. 2. Each element in the list will be a non-negative integer within the range [0, 100]. # Examples **Example 1:** ``` can_reach_end([2, 3, 1, 1, 4]) -> True ``` *Explanation*: Starting from index 0, you can move up to 2 steps forward to index 1 or index 2. From index 1, you can move up to 3 steps forward to reach the end of the array. **Example 2:** ``` can_reach_end([3, 2, 1, 0, 4]) -> False ``` *Explanation*: Starting from index 0, you can move up to 3 steps forward. However, no matter what steps you take, you will always end up needing to pass through index 3, which has a value of 0, making it impossible to reach the last index. # Explanation The function `can_reach_end` should implement a greedy algorithm to check whether the last index is reachable from the first index by leveraging the maximum steps allowed at each position in the array. This involves keeping track of the farthest position that can be reached so far and updating it as you iterate through the array.","solution":"from typing import List def can_reach_end(arr: List[int]) -> bool: Determines if the last index of the array can be reached from the first index given that each element in the array represents the maximum number of steps that can be taken forward from that position. max_reachable = 0 target = len(arr) - 1 for i, steps in enumerate(arr): if i > max_reachable: return False max_reachable = max(max_reachable, i + steps) if max_reachable >= target: return True return max_reachable >= target"},{"question":"# Question: Fibonacci Sequence to a Specific Term In this task, you\'ll be implementing a function to generate the Fibonacci sequence up to a specified term and return the entire sequence as a list. # Tasks: 1. Write a function `fibonacci_sequence(n: int) -> list` that generates the Fibonacci sequence up to the `n`-th term. 2. The sequence should start with `[0, 1]` and continue by the rule that each number is the sum of the two preceding ones. # Input: * A single integer `n` (1 ≤ n ≤ 50) which denotes the number of terms to include in the Fibonacci sequence. # Output: * A list containing the first `n` terms of the Fibonacci sequence. # Constraints: * You may assume that the input will always be a valid integer within the given range. * Aim for an efficient implementation that has linear time complexity, O(n). # Examples: ```python >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(15) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377] ``` # Notes: * The first two terms of the sequence are defined as 0 and 1. * The sequence should be generated in a straightforward manner, and the function should return a list containing the first `n` terms of the sequence, even if `n` is small. For example, if `n` is 1, the resulting list should be `[0]`.","solution":"def fibonacci_sequence(n): Returns the first n terms of the Fibonacci sequence. if n == 1: return [0] elif n == 2: return [0, 1] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"# Programming Assessment Question **Context**: You are developing a financial application that processes transactions and adjusts account balances. To ensure the correctness of the account data, you must implement a mechanism to detect and handle duplicate transactions. **Task**: Implement a function `remove_duplicate_transactions(transactions: list[tuple[str, int]]) -> list[tuple[str, int]]` that removes duplicate transactions from a list of transactions. Each transaction is represented as a tuple containing a transaction id and the transaction amount. Function Signature: ```python def remove_duplicate_transactions(transactions: list[tuple[str, int]]) -> list[tuple[str, int]]: pass ``` Input: * `transactions`: List of tuples, where each tuple contains: - A string representing the transaction id. - An integer representing the transaction amount. Output: * List of tuples, representing the unique transactions, preserving the original order of their first occurrence in the input list. Constraints: * The input list `transactions` will contain at most 100,000 transactions. * Each transaction id is a unique string of length up to 50 characters. * Each transaction amount is an integer within the range of [-10^9, 10^9]. Requirements: * Ensure that duplicate transactions (same transaction id) are removed. * The order of the transactions in the output list should be the same as their first appearance in the input list. * A transaction is considered duplicate if its transaction id has already appeared in a previous transaction. Example: ```python remove_duplicate_transactions([(\\"txn1\\", 100), (\\"txn2\\", 200), (\\"txn1\\", 100), (\\"txn3\\", 300)]) # Output: [(\\"txn1\\", 100), (\\"txn2\\", 200), (\\"txn3\\", 300)] remove_duplicate_transactions([(\\"txn1\\", 100), (\\"txn2\\", 100), (\\"txn3\\", 100)]) # Output: [(\\"txn1\\", 100), (\\"txn2\\", 100), (\\"txn3\\", 100)] remove_duplicate_transactions([(\\"txn1\\", -100), (\\"txn1\\", -100), (\\"txn1\\", -100)]) # Output: [(\\"txn1\\", -100)] ``` Additional Notes: * Focus on the efficiency of your solution to handle the potentially large input size. * Consider edge cases such as an empty transaction list and all transactions being unique. * Ensure proper usage of data structures to achieve optimal time complexity.","solution":"def remove_duplicate_transactions(transactions: list[tuple[str, int]]) -> list[tuple[str, int]]: Removes duplicate transactions based on transaction id while preserving the order of their first occurrence. seen = set() result = [] for txn in transactions: txn_id = txn[0] if txn_id not in seen: seen.add(txn_id) result.append(txn) return result"},{"question":"# Levenshtein Distance Calculation You are given two strings: a source string and a target string. Your task is to implement the Levenshtein distance algorithm, which calculates the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform the source string into the target string. # Task 1. Implement the `levenshtein_distance` function to compute the Levenshtein distance between two strings. 2. Utilize dynamic programming to optimize the calculation of distance. # Input - Two strings `source` and `target` representing the sequences to be transformed and compared. # Output An integer representing the Levenshtein distance between `source` and `target`. # Example ```python source = \\"kitten\\" target = \\"sitting\\" ``` **Output**: ``` 3 ``` # Constraints - The sequences consist only of uppercase and lowercase English letters. - 1 ≤ len(source), len(target) ≤ 1000 # Notes 1. You must use dynamic programming to build your solution. 2. Consider and handle edge cases such as empty strings. 3. Optimize for performance given the constraints. ```python def levenshtein_distance(source: str, target: str) -> int: # Your implementation here if __name__ == \\"__main__\\": source = input(\\"Enter the source string: \\") target = input(\\"Enter the target string: \\") distance = levenshtein_distance(source, target) print(distance) ``` # Remarks * Test the implementation with different test cases to ensure accuracy. * Account for scenarios where one of the strings could be empty. * Ensure your implementation is efficient and handles the problem constraints effectively.","solution":"def levenshtein_distance(source: str, target: str) -> int: Compute the Levenshtein distance between two strings using dynamic programming. m, n = len(source), len(target) # Create a (m+1)x(n+1) matrix to store distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the matrix using DP approach for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # no operation needed else: dp[i][j] = min(dp[i - 1][j] + 1, # deletion dp[i][j - 1] + 1, # insertion dp[i - 1][j - 1] + 1) # substitution return dp[m][n]"},{"question":"# Implementing a Decision Tree for Predicting House Prices You are provided with a dataset containing various features of houses along with their corresponding prices. You are required to implement a decision tree regressor to predict the house prices based on the features. **Function Signature**: ```python def train_decision_tree_regressor( features: np.ndarray, prices: np.ndarray, max_depth: int, min_samples_split: int ) -> Any: ``` **Input**: - `features`: A 2D numpy array of shape `(n_samples, n_features)`, where `n_samples` is the number of samples, and `n_features` is the number of features. - `prices`: A 1D numpy array of shape `(n_samples,)` containing the prices of the houses. - `max_depth`: An integer representing the maximum depth of the decision tree. - `min_samples_split`: An integer representing the minimum number of samples required to split a node. **Output**: - A trained decision tree regressor model. **Constraints**: - Ensure `max_depth` is a positive integer. - Ensure `min_samples_split` is a positive integer. - The dataset will contain valid data, and all inputs will be provided in the correct formats. Your implementation should use the following steps: 1. Initialize a decision tree regressor with the given parameters. 2. Train the decision tree using the provided features and prices. 3. Return the trained model. # Example ```python import numpy as np from sklearn.tree import DecisionTreeRegressor def train_decision_tree_regressor(features, prices, max_depth, min_samples_split): # Initialize the decision tree regressor with provided parameters model = DecisionTreeRegressor(max_depth=max_depth, min_samples_split=min_samples_split) # Fit the model on the dataset model.fit(features, prices) # Return the trained model return model # Example usage features = np.array([ [1400, 3, 2], [1600, 3, 2], [1700, 4, 3], [1875, 3, 2], [1100, 3, 1], [1550, 3, 2] ]) prices = np.array([245000, 312000, 279000, 308000, 199000, 292000]) max_depth = 3 min_samples_split = 2 model = train_decision_tree_regressor(features, prices, max_depth, min_samples_split) print(model) ``` Write your implementation for the `train_decision_tree_regressor` function below, ensuring adherence to the above specifications and requirements.","solution":"import numpy as np from sklearn.tree import DecisionTreeRegressor def train_decision_tree_regressor(features: np.ndarray, prices: np.ndarray, max_depth: int, min_samples_split: int) -> DecisionTreeRegressor: Trains a Decision Tree Regressor using the provided features and prices. Parameters: features (np.ndarray): 2D array of shape (n_samples, n_features) containing the house features. prices (np.ndarray): 1D array of shape (n_samples,) containing the house prices. max_depth (int): Maximum depth of the decision tree. min_samples_split (int): Minimum number of samples required to split an internal node. Returns: DecisionTreeRegressor: Trained decision tree regressor model. # Validate that max_depth and min_samples_split are positive integers if not (isinstance(max_depth, int) and max_depth > 0): raise ValueError(\\"max_depth must be a positive integer\\") if not (isinstance(min_samples_split, int) and min_samples_split > 0): raise ValueError(\\"min_samples_split must be a positive integer\\") # Initialize the decision tree regressor with the provided parameters model = DecisionTreeRegressor(max_depth=max_depth, min_samples_split=min_samples_split) # Train the model using the provided features and prices model.fit(features, prices) return model"},{"question":"# Task: Create a Multithreaded File Processor for Text Analysis Scenario You are tasked with developing a multithreaded file processor that reads multiple text files, computes the word frequency for each file, and saves the results to new files in a specific format. The script must handle large files efficiently by leveraging multithreading. Requirements 1. **Function Implementation**: Implement the function `process_text_files(file_paths: List[str], output_dir: str) -> List[str]` - **Input**: - `file_paths`: A list of paths to text files (List[str]). - `output_dir`: A directory path where the result files should be saved (str). - **Output**: A list of messages (List[str]) indicating the result of processing for each file. Each message should specify the input file name and the outcome, such as successful processing or error details. 2. **Constraints**: - Use multithreading to process files concurrently. - Handle edge cases such as empty files, non-existent files, and permission errors. - Save the word frequency results in a file named `word_freq_<original_file_name>.txt` with each word-frequency pair on a new line. 3. **Performance Requirements**: - The function must process multiple files efficiently using threading. - Ensure that reading, processing, and writing files are optimized for performance. 4. **Output Format**: - The word frequency result file should contain lines in the format: `<word>: <frequency>` Example Usage ```python file_paths = [ \\"/path/to/file1.txt\\", \\"/path/to/file2.txt\\", # more file paths ] output_dir = \\"/path/to/output/dir/\\" results = process_text_files(file_paths, output_dir) for result in results: print(result) ``` # Additional Considerations - Ensure your implementation is robust and includes appropriate error handling. - Test with different file sizes and content to cover various scenarios including large files, empty files, non-existent files, and permission errors. - Optimize for performance with appropriate use of multithreading and efficient file handling techniques.","solution":"import os import threading from collections import Counter from typing import List def process_file(file_path: str, output_dir: str, result_messages: List[str]): try: # Read the file with open(file_path, \'r\') as f: text = f.read() # Compute word frequency words = text.split() word_counts = Counter(words) # Prepare the output filename file_name = os.path.basename(file_path) output_file = os.path.join(output_dir, f\\"word_freq_{file_name}\\") # Write the word frequency to the output file with open(output_file, \'w\') as f: for word, count in word_counts.items(): f.write(f\\"{word}: {count}n\\") result_messages.append(f\\"Processed {file_name} successfully.\\") except Exception as e: result_messages.append(f\\"Error processing {file_path}: {e}\\") def process_text_files(file_paths: List[str], output_dir: str) -> List[str]: threads = [] result_messages = [] # Create a thread for each file for file_path in file_paths: thread = threading.Thread(target=process_file, args=(file_path, output_dir, result_messages)) threads.append(thread) thread.start() # Wait for all threads to finish for thread in threads: thread.join() return result_messages"},{"question":"# Scenario: You are developing a sensor network for a smart home system. The system receives periodic temperature readings, and you need to monitor the stability of these readings. In particular, you need a function to check if the temperature readings remain within a specified range over a defined period. This will help in detecting any sudden anomalies in the temperature. # Task: Implement a function `is_stable(temps: list, threshold: int) -> bool` that checks whether the maximum difference between any two temperature readings in the list is less than or equal to the given threshold. # Function Signature: ```python def is_stable(temps: list, threshold: int) -> bool: pass ``` # Input: * `temps`: A list of integers representing temperature readings. * `threshold`: An integer representing the maximum allowable difference between the highest and lowest readings for the temperature to be considered stable. # Output: * Return `True` if the temperature readings are stable according to the given threshold, and `False` otherwise. # Example: ```python >>> is_stable([20, 22, 21, 23, 22], 3) True >>> is_stable([20, 22, 21, 25, 22], 3) False >>> is_stable([15, 15, 15, 15], 0) True ``` # Constraints: * The list of temperature readings may contain up to 1,000 elements. # Notes: * Consider edge cases such as an empty list, a list with one element, and uniform temperature readings. * Ensure your function handles these scenarios efficiently.","solution":"def is_stable(temps: list, threshold: int) -> bool: if not temps: return True max_temp = max(temps) min_temp = min(temps) return (max_temp - min_temp) <= threshold"},{"question":"# Question: Balanced String Rearrangement You are given a balanced string consisting of equal numbers of \'L\' and \'R\' characters. A string is considered balanced if it contains an equal number of \'L\' and \'R\' characters. Your task is to write a function that rearranges the given string such that every possible split at a random position in the string results in the two parts being balanced. # Function Signature ```python def balanced_rearrangement(s: str) -> str: ``` # Input - `s` (str): A balanced string containing only \'L\' and \'R\' characters (1 <= len(s) <= 10^5). # Output - Returns a string which is a rearranged version of `s` where every possible split of the string results in two balanced substrings. # Constraints 1. The length of the input string will always be even. 2. The string will only contain \'L\' and \'R\' characters. 3. The function should be optimized to handle the upper constraint efficiently. # Example ```python >>> balanced_rearrangement(\\"RLRRLLRLRL\\") \\"RRRRLLLLLL\\" >>> balanced_rearrangement(\\"LLRR\\") \\"LLRR\\" ``` # Explanation In the first example, the output string \\"RRRRLLLLLL\\" can be split at any position such that both parts of the split have equal numbers of \'L\' and \'R\' characters. For instance: - Splitting \\"RRRRLLLLLL\\" at position 4 results in \\"RRRR\\" and \\"LLLLLL\\" where each part has the same number of \'L\' and \'R\'. - Similar balance is maintained for splits at all other positions. In the second example, the input string \\"LLRR\\" is already balanced, so it is returned as is. The output ensures every possible split results in balanced substrings. # Hints 1. Think about how you can rearrange the characters to ensure balance at each possible split. 2. Consider strategies for grouping characters to maintain the balance property.","solution":"def balanced_rearrangement(s: str) -> str: Rearranges the given string such that every possible split at a random position in the string results in the two parts being balanced. # Since the string is balanced and consists of only \'L\' and \'R\', # we can simply count the occurrences of \'L\' and \'R\'. count_L = s.count(\'L\') count_R = s.count(\'R\') # Given the constraints, these counts should be equal for a balanced string. # We\'ll generate a new string that has all \'L\'s followed by all \'R\'s. # Or vice versa, because both are valid as they maintain balance. # Construct the new balanced string result = \'L\' * count_L + \'R\' * count_R return result"},{"question":"# Context You are working on an encryption algorithm where you need to transform a string into its encrypted form by shifting each character by a specific number of positions in the alphabet. # Description Implement a function that encrypts a given string by shifting each character to the right by a provided shift amount. If the shift brings a character past \'z\', it should wrap around to the start of the alphabet. # Function Signature ```python def caesar_cipher(s: str, shift: int) -> str: pass ``` # Input * `s` (str): A string consisting of lowercase alphabetical characters only (1 ≤ len(s) ≤ 100). * `shift` (int): An integer (0 ≤ shift ≤ 25) representing the number of positions to shift each character. # Output * Return a new string where each character from the input `s` has been shifted right by the `shift` amount, wrapping around the alphabet if necessary. # Constraints * The input string will only contain lowercase alphabetical characters. * The shift number will be between 0 and 25, inclusive. # Example ```python s = \\"xyz\\" shift = 3 # The encrypted string should be \\"abc\\" result = caesar_cipher(s, shift) ``` # Notes * To handle wrapping around the alphabet, remember that shifting \'z\' by 1 results in \'a\', \'z\' by 2 results in \'b\', and so on. * You can use ASCII values to compute the new characters by taking advantage of the sequential nature of the alphabet.","solution":"def caesar_cipher(s: str, shift: int) -> str: Encrypts a given string by shifting each character to the right by the provided shift amount. If the shift brings a character past \'z\', it wraps around to the start of the alphabet. :param s: A string consisting of lowercase alphabetical characters only. :param shift: An integer representing the number of positions to shift each character. :return: The encrypted string after shifting. encrypted = [] for char in s: new_char = chr(((ord(char) - ord(\'a\') + shift) % 26) + ord(\'a\')) encrypted.append(new_char) return \'\'.join(encrypted)"},{"question":"# Assessment Question: Merge Two Sorted Linked Lists You are tasked with writing a function to merge two sorted linked lists into a single sorted linked list. The function should accept the heads of two linked lists and return the head of a new linked list that contains all the nodes from both input lists, sorted in non-decreasing order. Consider the following constraints for your solution: - Each linked list node contains an integer value. - The input linked lists are sorted in non-decreasing order. - The function should handle empty input lists (represented by `None`). Function Signature ```python def merge_two_sorted_lists(list1: ListNode | None, list2: ListNode | None) -> ListNode | None: pass ``` Input and Output Format: - Input: References to the heads of two sorted linked lists or `None`. - Output: A reference to the head of the merged sorted linked list. Example ```python >>> list1_node1 = ListNode(1) >>> list1_node2 = ListNode(3) >>> list1_node1.next = list1_node2 >>> list2_node1 = ListNode(2) >>> list2_node2 = ListNode(4) >>> list2_node1.next = list2_node2 >>> merged_list_head = merge_two_sorted_lists(list1_node1, list2_node1) >>> merged_list_head.val 1 >>> merged_list_head.next.val 2 >>> merged_list_head.next.next.val 3 >>> merged_list_head.next.next.next.val 4 ``` Constraints 1. The maximum number of nodes in each linked list is 1000. 2. The values of the nodes are between -1000 and 1000. 3. Both linked lists are sorted in non-decreasing order. Performance Requirements - Ensure the function runs efficiently with a time complexity of O(n + m), where n and m are the lengths of the respective input lists. # Additional Information - ListNode class is predefined and uses the following structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Write the function `merge_two_sorted_lists` that will fulfill the above requirements.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(list1: ListNode | None, list2: ListNode | None) -> ListNode | None: dummy = ListNode() current = dummy while list1 and list2: if list1.val < list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 elif list2: current.next = list2 return dummy.next"},{"question":"# Scenario: Design a program that simulates a simple shopping cart system for an online store. Customers can add items to their cart, remove items, and view the total cost of the items in their cart. Each item has a name, price, and quantity. # Problem Description: Implement a class `ShoppingCart` that allows you to manage items in a shopping cart. The class should provide methods to add an item, remove an item, and get the total cost. # Class Signature: ```python class ShoppingCart: def __init__(self): pass def add_item(self, name: str, price: float, quantity: int) -> None: pass def remove_item(self, name: str) -> None: pass def total_cost(self) -> float: pass ``` # Input: - `name` (str): A string representing the name of the item. - `price` (float): A floating-point number representing the price of the item. - `quantity` (int): An integer representing the quantity of the item. # Output: - `add_item`: This method doesn\'t return anything. - `remove_item`: This method doesn\'t return anything. - `total_cost`: Returns a floating-point number representing the total cost of all items in the shopping cart. # Constraints: - Item names are unique. - 1 <= len(name) <= 100 - 0.01 <= price <= 10^4 - 1 <= quantity <= 10^3 # Example: ```python cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) cart.add_item(\\"banana\\", 0.5, 5) print(cart.total_cost()) # Output should be 5.5 cart.remove_item(\\"apple\\") print(cart.total_cost()) # Output should be 2.5 ``` # Requirements: 1. Implement the `ShoppingCart` class and its methods. 2. Ensure that adding an item with the same name replaces the existing item in the cart. 3. Handle edge cases such as adding and removing items in different orders. Your task is to complete the implementation of the `ShoppingCart` class. ```python class ShoppingCart: def __init__(self): self.items = {} def add_item(self, name: str, price: float, quantity: int) -> None: self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name: str) -> None: if name in self.items: del self.items[name] def total_cost(self) -> float: return sum(item[\'price\'] * item[\'quantity\'] for item in self.items.values()) ``` Test your implementation with the provided example.","solution":"class ShoppingCart: def __init__(self): self.items = {} def add_item(self, name: str, price: float, quantity: int) -> None: Adds an item to the shopping cart. If the item already exists, it replaces it. self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name: str) -> None: Removes an item from the shopping cart if it exists. if name in self.items: del self.items[name] def total_cost(self) -> float: Returns the total cost of all items in the shopping cart. return sum(item[\'price\'] * item[\'quantity\'] for item in self.items.values())"},{"question":"# Objective Implement a function to find the length of the longest string chain in an array of strings. # Problem Description Given an array of strings `words`, write a function `longest_str_chain(words: List[str]) -> int` to find the length of the longest string chain. A string chain is defined as a sequence of words where each word is a predecessor of the next. A word `wordA` is a predecessor of `wordB` if and only if we can add exactly one letter anywhere in `wordA` to make it equal to `wordB`. # Input and Output Formats * **Input**: A list of strings. ```python from typing import List ``` * **Output**: An integer representing the length of the longest string chain. # Constraints 1. The number of words in the array is in the range `[1, 1000]`. 2. Each word length is in the range `[1, 16]`. 3. All words are composed of lower-case English letters. # Performance Requirements * The function should perform in O(n * m^2) time complexity, where `n` is the number of words and `m` is the maximum length of the words. # Function Signature Example ```python def longest_str_chain(words: List[str]) -> int: # Your code here pass ``` # Edge Cases 1. The array is empty or contains only one word. 2. All words in the array have the same length. 3. Words form multiple chains of the same longest length. # Example Example 1 * **Input**: `words = [\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"]` * **Output**: `4` * **Explanation**: The longest string chain is `[\\"a\\",\\"ba\\",\\"bda\\",\\"bdca\\"]`. Example 2 * **Input**: `words = [\\"xbc\\",\\"pcxbcf\\",\\"xb\\",\\"cxbc\\",\\"pcxbc\\"]` * **Output**: `5` * **Explanation**: The longest string chain is `[\\"xb\\",\\"xbc\\",\\"cxbc\\",\\"pcxbc\\",\\"pcxbcf\\"]`. Example 3 * **Input**: `words = [\\"abcd\\",\\"dbqca\\"]` * **Output**: `1` * **Explanation**: The longest string chain is just one word long, as no string can be formed by adding a single character to the other. # Testing Use the provided examples in the question to test different scenarios and edge cases.","solution":"from typing import List from collections import defaultdict def longest_str_chain(words: List[str]) -> int: words.sort(key=len) # Sorting the words based on their lengths longest_chain = defaultdict(int) max_chain_length = 1 for word in words: for i in range(len(word)): predecessor = word[:i] + word[i+1:] longest_chain[word] = max(longest_chain[word], longest_chain[predecessor] + 1) max_chain_length = max(max_chain_length, longest_chain[word]) return max_chain_length"},{"question":"# Context: You are building a scheduling system for a university to manage the allocation of classrooms for different classes. The system should ensure that no two classes are scheduled in the same room at the same time. # Task: Implement a function to allocate classrooms to classes such that no classes overlap in the same room. You are given a list of classes, each with a start and end time, and you need to determine the minimum number of rooms required. # Requirements: 1. **Function Implementation:** - Write a function `allocate_classrooms` that takes a list of tuples, where each tuple consists of a start time and end time of a class (both inclusive). - Determine the minimum number of classrooms required to schedule all the given classes without conflicts in time. 2. **Edge Cases Handling:** - Handle cases with no classes. - Handle overlapping times with various complexities. 3. **Testing:** - Provide several test cases demonstrating the correctness of your implementation. **Input and Output formats:** - **Input:** A list of tuples `[(start1, end1), (start2, end2), ...]` representing the scheduled time of classes. - **Output:** An integer representing the minimum number of classrooms required. **Constraints:** - 1 <= number of classes <= 10^4 - 0 <= start_time, end_time <= 10^4 - Start times and end times are integers. # Example: ```python def allocate_classrooms(classes): # Implement your solution here pass # Example Usage classes = [(30, 75), (0, 50), (60, 150)] print(allocate_classrooms(classes)) # Expected output: 2 ``` # Notes: - Focus on ensuring that your implementation efficiently handles large inputs. - You might consider using data structures such as heaps for efficient interval management.","solution":"import heapq def allocate_classrooms(classes): if not classes: return 0 # Sort classes by start time classes.sort(key=lambda x: x[0]) # Initialize a heap heap = [] # Add the end time of the first class heapq.heappush(heap, classes[0][1]) # Iterate through the rest of the classes for i in range(1, len(classes)): # If the current class starts after or when the earliest ending class finishes, # remove the end time from the heap if classes[i][0] >= heap[0]: heapq.heappop(heap) # Add the current class\'s end time to the heap heapq.heappush(heap, classes[i][1]) # The size of the heap is the minimum number of classrooms required return len(heap)"},{"question":"# Course Registration System: Class Schedule Checker You are tasked with building a function that takes a list of class schedules for students and determines if any student is registered for conflicting classes. Each class schedule consists of a series of classes with their start and end times in 24-hour format. Function Signature ```python def check_schedule_conflicts(schedules: list[list[tuple[int, int]]]) -> list[bool]: pass ``` Requirements: 1. For each student\'s schedule, check if any of the classes overlap. 2. Output should be a list of booleans, where each boolean corresponds to whether there is a conflict in the corresponding input schedule. Function Implementation: * **Input**: A list `schedules` where each element is a list of tuples. Each tuple represents a class with a start time and an end time. * **Output**: A list of booleans, where each boolean is `True` if there is a conflict in the schedule and `False` otherwise. Example ```python >>> check_schedule_conflicts([[(9, 10), (10, 11), (15, 16)], [(8, 10), (9, 11)], [(14, 16), (16, 18), (18, 20)]]) [False, True, False] ``` Constraints * Each class time is represented as a tuple `(start, end)`, where `start` and `end` are integers between 0 and 23. * The `end` time is strictly greater than the `start` time within each tuple. * The number of classes in each schedule can range from 1 to 100. * Aim to optimize both the time and space complexity of your solution. Notes * Two classes conflict if they overlap in time, i.e., one class starts before the other ends. * Schedules must be checked independently. * Ensure to consider appropriate edge cases such as a single class in a schedule. Good luck!","solution":"def check_schedule_conflicts(schedules: list[list[tuple[int, int]]]) -> list[bool]: Determines if there are any conflicting classes in each student\'s schedule. :param schedules: List of student schedules. Each schedule is a list of tuples where each tuple contains start and end time of a class. :return: List of booleans indicating if there\'s a conflict (True if there is a conflict, False otherwise) for each schedule. def has_conflict(schedule): # Sort the classes by start time sorted_schedule = sorted(schedule) for i in range(len(sorted_schedule) - 1): # Check if the end time of the current class is greater than the start time of the next class if sorted_schedule[i][1] > sorted_schedule[i+1][0]: return True return False return [has_conflict(schedule) for schedule in schedules]"},{"question":"# Scenario As a data analyst, you\'re tasked with creating a tool to analyze the performance of various sales representatives in your company. Specifically, you need to determine the top performers based on their sales figures over multiple quarters. The company maintains a list of sales records for each representative, and your tool should identify which representatives consistently achieve the highest sales. # Task Write a Python function that accepts a dictionary containing sales data and computes the top `n` sales representatives based on their total sales across all quarters. The function should return a sorted list of tuples containing the representative\'s name and their total sales, sorted in descending order of total sales. # Function Signature ```python def top_sales_reps( sales_data: dict[str, list[float]], n: int ) -> list[tuple[str, float]]: ``` # Input & Output Requirements * **Input**: * `sales_data` (dict): A dictionary where keys are sales representative names (strings) and values are lists of sales figures (floats) for various quarters. * `n` (int): The number of top performers to return. Must be positive. * **Output**: * A list of tuples, each containing the name of the sales representative and their total sales, limited to the top `n` performers, sorted in descending order of total sales. # Constraints: * If `n` exceeds the number of sales representatives, return the list of all representatives sorted by their total sales. * Sales figures and `n` must be non-negative. * Raise a `ValueError` if `n` is non-positive or if any sales figure is negative. # Example Scenarios: 1. **Input**: ```python top_sales_reps( sales_data={ \\"Alice\\": [1200.50, 3000.75, 2500.00], \\"Bob\\": [800.00, 1500.25, 900.50], \\"Carol\\": [3000.00, 4500.75, 5200.25] }, n=2 ) ``` **Output**: ```json [(\\"Carol\\", 12701.0), (\\"Alice\\", 6701.25)] ``` 2. **Input**: ```python top_sales_reps( sales_data={ \\"Dave\\": [1500.00, 1300.00], \\"Eve\\": [2000.00, 1800.50, 2100.75], \\"Frank\\": [], \\"Grace\\": [300.00, 400.25, 500.00] }, n=3 ) ``` **Output**: ```json [(\\"Eve\\", 5901.25), (\\"Dave\\", 2800.0), (\\"Grace\\", 1200.25)] ``` 3. **Input**: ```python top_sales_reps( sales_data={ \\"Henry\\": [1000.00, 2000.00], \\"Ivy\\": [1500.00, 2500.00], \\"Jack\\": [2000.00, -1000.00] }, n=1 ) ``` **Output**: ```python ValueError: Sales figures can not be negative ``` Formulate your function with these considerations and thoroughly test it to ensure correctness.","solution":"def top_sales_reps(sales_data: dict[str, list[float]], n: int) -> list[tuple[str, float]]: if n <= 0: raise ValueError(\\"The number of top performers \'n\' must be a positive integer.\\") for sales in sales_data.values(): if any(sale < 0 for sale in sales): raise ValueError(\\"Sales figures can not be negative.\\") total_sales = {rep: sum(sales) for rep, sales in sales_data.items()} sorted_sales = sorted(total_sales.items(), key=lambda x: x[1], reverse=True) return sorted_sales[:n]"},{"question":"# Problem Statement You are given a grid of size `m x n` initialized with all `0`s. You are also given several update operations. Each update operation is represented by a 2D array, where each element is `[r, c]` and represents incrementing all elements of the submatrix starting at the top-left corner `(0, 0)` to `(r-1, c-1)` by 1. Your task is to implement the following function: 1. `max_count_after_operations(m: int, n: int, ops: List[List[int]]) -> int` This function returns an integer representing the number of maximum integers in the matrix after applying all the update operations. # Function Signature ```python def max_count_after_operations(m: int, n: int, ops: List[List[int]]) -> int: Given dimensions of the grid (m, n) and a list of operations (ops), find the number of maximum integers in the matrix after performing all the operations. ``` # Input 1. The function `max_count_after_operations(m: int, n: int, ops: List[List[int]])` takes two integers `m` and `n` representing the dimensions of the matrix, and a list of operations `ops` where each operation is represented by a list `[r, c]`. # Output 1. The function should return an integer which is the count of the maximum elements in the matrix after all operations have been applied. # Constraints 1. 1 <= m, n <= 10^5 2. 0 <= number of operations <= 10^4 3. 1 <= r <= m 4. 1 <= c <= n # Example Usage ```python assert max_count_after_operations(3, 3, [[2, 2], [3, 3]]) == 4 assert max_count_after_operations(3, 3, [[2, 2], [3, 3], [3, 3]]) == 4 assert max_count_after_operations(3, 3, []) == 9 ``` # Explanation 1. In the first example, the operations `[[2, 2], [3, 3]]` mean that: - By applying [2, 2], the top-left `2x2` submatrix is incremented. - Then, by [3, 3], the top-left `3x3` submatrix is incremented. The top-left `2x2` submatrix will be incremented twice, while the rest of the submatrix only once. Thus, the four cells `(0,0), (0,1), (1,0), (1,1)` will hold the highest value. 2. In the second example, an additional `[3, 3]` operation results in no additional changes to the maximum count since it still encompasses the previously updated cells. 3. In the third example, no operations mean the entire matrix remains 0, with 9 elements being the maximum (since they are all 0).","solution":"def max_count_after_operations(m: int, n: int, ops: list) -> int: if not ops: return m * n min_r = m min_c = n for op in ops: min_r = min(min_r, op[0]) min_c = min(min_c, op[1]) return min_r * min_c"},{"question":"# Problem Statement: You need to design a `StringTransformation` class that facilitates the transformation of a list of strings into a specific target string using a combination of replace and permutation techniques. # Requirements: * Implement the class `StringTransformation` with a method `transform` that takes a list of strings and a target string, and returns a boolean indicating whether the transformation is possible. * Make sure the algorithm efficiently handles edge cases and large inputs. # Function Signature: ```python class StringTransformation: def transform(self, strings: list[str], target: str) -> bool: ``` # Expected Input: * A list of strings, e.g., [\\"abc\\", \\"de\\", \\"fgh\\"]. * A target string, e.g., \\"abcdefgh\\". # Expected Output: * A boolean value indicating whether the transformation is possible, e.g., True or False. # Constraints: * 1 <= len(strings) <= 100 * 1 <= len(target) <= 1000 * All input strings consist of lowercase English letters. # Implementation Details: 1. Implement the `can_permute` helper function to check if two strings can be transformed into each other via permutation. Ensure it\'s nested within the class. 2. Implement the `can_replace` helper function to determine if a substring replacement results in the target substring, respecting positions and counts of characters. 3. Use these helpers within the `transform` method to check if the given strings can be concatenated, replaced, or permuted to match the target. # Example: ```python >>> transformer = StringTransformation() >>> transformer.transform([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdefgh\\") True >>> transformer.transform([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdfegh\\") True >>> transformer.transform([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdxgh\\") False ``` # Notes: * Avoid using any built-in Python permutation or combination functions. * Consider optimizing your implementation to address both space and time complexity concerns.","solution":"class StringTransformation: def transform(self, strings: list[str], target: str) -> bool: from collections import Counter def can_permute(a: str, b: str) -> bool: return Counter(a) == Counter(b) concatenated_string = \'\'.join(strings) return can_permute(concatenated_string, target)"},{"question":"# Coding Question: Optimizing k-Nearest Neighbors (k-NN) for Large-Scale Data You have an implementation of the k-Nearest Neighbors (k-NN) classifier that works well for small datasets. However, as the dataset size increases, the performance degrades due to the O(n) complexity of querying each new point. Your task is to modify and extend the current implementation to improve its efficiency. Use a k-d tree for optimizing the nearest neighbor search. Implement the k-d tree construction and querying processes. Test the modified k-NN classifier on a large synthetic dataset. # Task 1. **Implement K-d Tree Construction**: - Create a function to build the k-d tree from the training data. 2. **Implement K-d Tree Query**: - Develop a method to query the k-d tree for finding the k-nearest neighbors efficiently. 3. **Integrate and Test**: - Integrate the k-d tree with the existing k-NN classifier. - Test the optimized k-NN classifier on a large synthetic dataset. # Function Signatures ```python class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right class KNNWithKDTree: def __init__(self, k=3): self.k = k self.tree = None def fit(self, X, y): Build the k-d tree from the training data. :param X: array-like of shape (n_samples, n_features), the training input samples. :param y: array-like of shape (n_samples,), the target values. # Build the k-d tree here def _build_kd_tree(self, points, depth=0): Recursively build a k-d tree. :param points: array-like, points to be included in the tree. :param depth: int, the current depth of the tree. :return: KDTreeNode, the root of the k-d tree. # Implement the construction of k-d tree here def _kd_tree_query(self, node, point, depth=0): Query the k-d tree to find the k-nearest neighbors. :param node: KDTreeNode, current node in the k-d tree. :param point: array-like, the query point. :param depth: int, the depth of the current node. :return: list of tuples, containing the nearest neighbors and their distances. # Implement the querying process here def predict(self, X): Predict the class labels for the provided data. :param X: array-like of shape (n_samples, n_features), the input samples. :return: array-like of shape (n_samples,), the predicted class labels. # Implement the prediction logic using the k-d tree here def test_knn_with_kd_tree(): Test function for k-NN optimized with k-d tree. # Implement test logic here using synthetic data ``` # Constraints: 1. Ensure that the k-d tree implementation handles high-dimensional data efficiently. 2. Use a plotting library to visualize the performance improvement of the k-d tree over the traditional k-NN approach with large datasets. # Sample Input: No specific input is needed as you will generate synthetic data for testing. # Sample Output: A plot comparing the query performance of the traditional k-NN and k-NN with k-d tree on large synthetic data, demonstrating improved efficiency.","solution":"import numpy as np class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right class KNNWithKDTree: def __init__(self, k=3): self.k = k self.tree = None self.X = None self.y = None def fit(self, X, y): Build the k-d tree from the training data. :param X: array-like of shape (n_samples, n_features), the training input samples. :param y: array-like of shape (n_samples,), the target values. self.X = X self.y = y points = np.concatenate((X, y.reshape(-1, 1)), axis=1) self.tree = self._build_kd_tree(points) def _build_kd_tree(self, points, depth=0): Recursively build a k-d tree. :param points: array-like, points to be included in the tree. :param depth: int, the current depth of the tree. :return: KDTreeNode, the root of the k-d tree. if len(points) == 0: return None k = points.shape[1] - 1 # number of features axis = depth % k points = points[points[:, axis].argsort()] median = len(points) // 2 return KDTreeNode( point=points[median], left=self._build_kd_tree(points[:median], depth + 1), right=self._build_kd_tree(points[median + 1:], depth + 1) ) def _kd_tree_query(self, node, point, depth=0): Query the k-d tree to find the k-nearest neighbors. :param node: KDTreeNode, current node in the k-d tree. :param point: array-like, the query point. :param depth: int, the depth of the current node. :return: list of tuples, containing the nearest neighbors and their distances. if node is None: return [] k = len(point) axis = depth % k next_branch = None opposite_branch = None if point[axis] < node.point[axis]: next_branch = node.left opposite_branch = node.right else: next_branch = node.right opposite_branch = node.left best = self._kd_tree_query(next_branch, point, depth + 1) distance = np.linalg.norm(point - node.point[:-1]) best.append((node.point, distance)) best = sorted(best, key=lambda x: x[1])[:self.k] radius = best[-1][1] if best else float(\'inf\') if abs(point[axis] - node.point[axis]) < radius: best += self._kd_tree_query(opposite_branch, point, depth + 1) best = sorted(best, key=lambda x: x[1])[:self.k] return best def predict(self, X): Predict the class labels for the provided data. :param X: array-like of shape (n_samples, n_features), the input samples. :return: array-like of shape (n_samples,), the predicted class labels. predictions = [] for point in X: neighbors = self._kd_tree_query(self.tree, point) labels = [neighbor[0][-1] for neighbor in neighbors] predictions.append(max(set(labels), key=labels.count)) return np.array(predictions)"},{"question":"Problem Statement: Given a string `s`, your task is to find the length of the longest substring without repeating characters. Write a function `length_of_longest_substring(s: str) -> int` that performs this task. Function Signature: ```python def length_of_longest_substring(s: str) -> int: ... ``` Input: * A string `s` (0 <= len(s) <= 10^5) Output: * An integer representing the length of the longest substring without repeating characters. Constraints: * The input string `s` consists of English letters, digits, symbols, and spaces. Example Usage: ```python print(length_of_longest_substring(\\"abcabcbb\\")) # Output: 3 print(length_of_longest_substring(\\"bbbbb\\")) # Output: 1 print(length_of_longest_substring(\\"pwwkew\\")) # Output: 3 print(length_of_longest_substring(\\"\\")) # Output: 0 ``` Scenario: You are a software engineer designing a text editing tool. One of the key features is to highlight the longest segment of text that contains unique characters, aiding users in identifying patterns or avoiding redundant inputs. Implement a function to efficiently determine this segment length, ensuring it performs well even with very large texts. Notes: - Ensure the function handles edge cases such as empty strings. - Consider utilizing an optimized approach like the sliding window technique to achieve an efficient solution.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 seen_chars = {} for end in range(n): if s[end] in seen_chars and seen_chars[s[end]] >= start: start = seen_chars[s[end]] + 1 seen_chars[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# [New Question]: # Programming Task - Product Discount Calculation You are tasked with implementing a function in Python that calculates the final price of a product after applying a discount and sales tax. # Objective Write a function `calculate_final_price` that computes the final price of a product given its initial price, discount rate, and applicable sales tax rate. # Function Signature ```python def calculate_final_price(initial_price: float, discount_rate: float, tax_rate: float) -> float: pass ``` # Input - `initial_price` (float): The original price of the product before any discounts or taxes. - `discount_rate` (float): The discount rate as a percentage (e.g., 10 for a 10% discount). - `tax_rate` (float): The sales tax rate as a percentage (e.g., 8 for an 8% sales tax). # Output - The function should return the final price of the product as a float, rounded to two decimal places. # Constraints - The `initial_price` will be a non-negative float. - The `discount_rate` and `tax_rate` will be non-negative floats and can be greater than 100%. - Ensure that calculations maintain precision and accuracy up to two decimal points. # Example Scenario Given: ```python initial_price = 100.00 discount_rate = 10.0 tax_rate = 8.0 ``` Expected output: ```python 97.20 ``` Explanation: - Discounted price = initial_price * ((100 - discount_rate) / 100) = 100 * 0.90 = 90.00 - Final price after tax = discounted_price * ((100 + tax_rate) / 100) = 90.00 * 1.08 = 97.20 # Notes - Apply the discount first and then the sales tax on the discounted price. - Round the final result to two decimal places before returning the value.","solution":"def calculate_final_price(initial_price: float, discount_rate: float, tax_rate: float) -> float: Calculates the final price of a product after applying the discount and sales tax. Args: initial_price (float): The original price of the product before any discounts or taxes. discount_rate (float): The discount rate as a percentage (e.g., 10 for a 10% discount). tax_rate (float): The sales tax rate as a percentage (e.g., 8 for an 8% sales tax). Returns: float: The final price of the product, rounded to two decimal places. # Calculate the discounted price discounted_price = initial_price * ((100 - discount_rate) / 100) # Calculate the final price after applying the tax final_price = discounted_price * ((100 + tax_rate) / 100) # Round the result to two decimal places return round(final_price, 2)"},{"question":"# Question: You have been hired by a software company to implement a utility that recalculates the complex mathematical expression for each new day. The expression involves dynamically parsed variables and your task is to evaluate this expression programmatically. # Function Signature ```python def evaluate_expression(expression: str, variables: dict) -> float: pass ``` # Input * **expression**: a string representing a mathematical expression to be evaluated. The expression can include variables, which are denoted by names. * **variables**: a dictionary mapping variable names (strings) to their respective values (floats). # Output * **Returns**: a floating-point number which is the result of evaluating the expression using the provided variable values. # Constraints * The expression can contain basic binary operators: `+`, `-`, `*`, `/`. * The expression can contain parentheses for grouping and controlling the order of operations. * Assume all variable names in the expression will always exist within the variables dictionary. * The length of the expression is at most 10^4 characters. * Raise a `ValueError` for any invalid mathematical expressions. # Example ```python >>> evaluate_expression(\\"a + b * (c - d)\\", {\\"a\\": 2.0, \\"b\\": 3.0, \\"c\\": 10.0, \\"d\\": 2.0}) 26.0 >>> evaluate_expression(\\"x / y + z\\", {\\"x\\": 10.0, \\"y\\": 2.0, \\"z\\": 3.0}) 8.0 ``` # Explanation * For the first example: substituting the variables gives `2 + 3 * (10 - 2)`, which simplifies to `2 + 3 * 8` then `2 + 24`, resulting in `26.0`. * For the second example: substituting the variables gives `10 / 2 + 3`, which simplifies to `5 + 3`, resulting in `8.0`. # Notes - You can use the `eval` function in Python, but make sure to securely parse and restrict the evaluations appropriately to avoid security risks. - You must handle operator precedence and parentheses correctly as per the standard mathematical rules. - Proper error handling for invalid expressions or syntax errors should be implemented by raising a `ValueError`. Implement the function `evaluate_expression` correctly and efficiently to handle large input sizes and complex nested expressions.","solution":"def evaluate_expression(expression: str, variables: dict) -> float: Evaluates a mathematical expression with given variable mappings. Args: expression (str): The mathematical expression to evaluate. variables (dict): A dictionary mapping variable names to their respective float values. Returns: float: The result of evaluating the expression. Raises: ValueError: If the expression is invalid or contains issues. # Replace variables with their values in the expression for var, value in variables.items(): # Ensure proper replacement of variable names with their values expression = expression.replace(var, str(value)) try: result = eval(expression, {\\"__builtins__\\": None}, {}) except Exception as e: raise ValueError(f\\"Invalid expression: {e}\\") return result"},{"question":"# Problem Statement You are provided with a task to simulate a basic text editor. Your task is to implement an undo functionality that allows users to revert their last changes. The text editor can handle three operations: appending a string, deleting the last `k` characters, and retrieving the `k`th character that is currently in the text. # Task Write a Python class called `TextEditor` that simulates this text editor. Implement the following functions: 1. **append(string)**: Appends the given string to the current text. 2. **delete(k)**: Deletes the last `k` characters from the current text. 3. **get(k)**: Returns the `k`th character in the current text (1-based indexing). 4. **undo()**: Reverts the last operation (either an append or a delete). If no operations have been performed, do nothing. You should maintain an internal state to remember the sequence of operations performed for the purpose of undoing them. # Class Definition ```python class TextEditor: def __init__(self): pass def append(self, string: str) -> None: pass def delete(self, k: int) -> None: pass def get(self, k: int) -> str: pass def undo(self) -> None: pass ``` # Input Your `TextEditor` class will handle the following methods: * `append(string: str)`: A string `string` (length <= 100) to append to the current text. * `delete(k: int)`: An integer `k` (where 1 <= k <= current length of text) indicating the number of last characters to delete. * `get(k: int)`: An integer `k` (1-based index) where 1 <= k <= current length of text, indicating the character position to retrieve. * `undo()`: No parameters. Reverts the last operation performed (either append or delete). # Output * `append(string)`, `delete(k)`, and `undo()` return nothing. * `get(k)` returns a single character string representing the `k`th character of the text. # Example ```python >>> editor = TextEditor() >>> editor.append(\\"hello\\") >>> editor.append(\\" world\\") >>> editor.get(6) \'w\' >>> editor.delete(6) >>> editor.get(5) \'o\' >>> editor.undo() >>> editor.get(6) \'w\' >>> editor.undo() >>> editor.get(6) IndexError # since the character at index 6 does not exist ``` # Constraints * The total number of operations will not exceed 10000. * Ensure your class efficiently handles a sequence of mixed operations, including multiple undos and redos.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string: str) -> None: self.history.append(self.text) self.text += string def delete(self, k: int) -> None: self.history.append(self.text) self.text = self.text[:-k] def get(self, k: int) -> str: if 1 <= k <= len(self.text): return self.text[k-1] raise IndexError(\\"Index out of range\\") def undo(self) -> None: if self.history: self.text = self.history.pop()"},{"question":"# Problem Statement You are given a list of integers, where every element appears twice except for one. Implement the function `find_unique(lst: List[int]) -> int` that finds and returns the element that appears only once. Input * `lst` (List[int]): A list of integers where every element appears exactly twice except for one integer that appears only once. Output * The function should return an integer representing the unique element in the list. Example ```python >>> find_unique([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique([2, 2, 3, 4, 4]) 3 >>> find_unique([7, 8, 9, 8, 7]) 9 >>> find_unique([10, 10, 20]) 20 ``` # Constraints * The length of the list `lst` is guaranteed to be odd. * All integers in the list will be in the range ([-10^6, 10^6]). * You should aim to achieve a solution with linear runtime complexity, i.e., O(n). * Use a constant amount of space, i.e., O(1). # Requirements * The function should handle large input sizes efficiently. * Consider using bit manipulation techniques to achieve the required space complexity.","solution":"from typing import List def find_unique(lst: List[int]) -> int: Finds and returns the element that appears only once in a list where every other element appears exactly twice. Args: lst (List[int]): A list of integers Returns: int: The unique element unique_element = 0 for num in lst: unique_element ^= num return unique_element"},{"question":"**Scenario**: Sorting is a fundamental operation in computer science, and there are various algorithms to achieve it, each with different performance characteristics. One interesting challenge is to sort elements while performing a minimum number of swaps. **Problem Statement**: You are given an array of distinct integers. Your task is to sort this array in ascending order by performing the smallest possible number of swaps. Write a function `minimum_swaps_to_sort` to accomplish this. **Function Signature**: ```python def minimum_swaps_to_sort(arr: List[int]) -> int: pass ``` **Input**: - `arr` (List[int]): A list of distinct integers that need to be sorted. **Output**: - Return an integer representing the minimum number of swaps required to sort the array. **Constraints**: 1. 1 <= len(arr) <= 10^5 2. All elements in `arr` are distinct. # Example: ```python # Example usage print(minimum_swaps_to_sort([4, 3, 1, 2])) # Expected Output: 3 print(minimum_swaps_to_sort([2, 3, 4, 1, 5])) # Expected Output: 3 print(minimum_swaps_to_sort([1, 3, 5, 2, 4, 6, 7])) # Expected Output: 3 ``` **Explanation**: - In the first example, the optimal sequence of swaps will sort the array `[4, 3, 1, 2]` with 3 swaps. - In the second example, the array `[2, 3, 4, 1, 5]` can be sorted with 3 swaps. - In the third example, sorting `[1, 3, 5, 2, 4, 6, 7]` requires 3 swaps. The goal is to determine the minimum number of swaps that will place every element in its correct position.","solution":"from typing import List def minimum_swaps_to_sort(arr: List[int]) -> int: n = len(arr) arrpos = [(value, index) for index, value in enumerate(arr)] arrpos.sort() visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with building a notification service for an application that supports different types of notifications like messages, alerts, and reminders. Each notification has a priority, and the system should process the highest-priority notifications first. If two notifications have the same priority, the system should process the one that was received earlier. Implement a priority queue that supports dynamic insertion and fetching of notifications based on their priority and arrival order. **Task**: Implement a `NotificationQueue` class that facilitates dynamic insertion and priority-based fetching of notifications. **Requirements**: 1. **Initialization**: - Provide a class `NotificationQueue` that initializes an empty queue. 2. **Insertion**: - Implement an `add_notification` method to add a new notification with a specified priority. 3. **Fetching**: - Implement a `get_notification` method that retrieves and removes the highest-priority notification from the queue. - If the queue is empty, return `None`. # Function Details - **Class**: `NotificationQueue` - **Constructor**: - `__init__(self) -> None` - Initializes an empty priority queue. - **Methods**: - `add_notification(self, notification: str, priority: int) -> None` - Adds a new notification with the given string message and priority to the queue. - `get_notification(self) -> Optional[str]` - Retrieves and removes the highest-priority notification message from the queue. **Constraints**: - Number of operations `Q` where `1 <= Q <= 10^4`. - Priority value for notifications within `0 <= priority <= 10^9`. - Notification messages are non-empty strings with a maximum length of 100 characters. # Input Format: - Multiple lines, where each line represents an operation (`add_notification` or `get_notification`). # Output Format: - For each `get_notification` operation, output the notification message with the highest priority. - If the queue is empty during a `get_notification` operation, output `None`. # Example: ```python notif_queue = NotificationQueue() notif_queue.add_notification(\\"Low battery\\", 5) notif_queue.add_notification(\\"Update available\\", 7) notif_queue.add_notification(\\"Meeting at 3 PM\\", 4) print(notif_queue.get_notification()) # Output: \\"Update available\\" print(notif_queue.get_notification()) # Output: \\"Low battery\\" print(notif_queue.get_notification()) # Output: \\"Meeting at 3 PM\\" print(notif_queue.get_notification()) # Output: None ``` # Solution: ```python import heapq from typing import List, Tuple, Optional class NotificationQueue: def __init__(self) -> None: self.heap = [] self.counter = 0 # To track the order of insertion def add_notification(self, notification: str, priority: int) -> None: heapq.heappush(self.heap, (-priority, self.counter, notification)) self.counter += 1 def get_notification(self) -> Optional[str]: if self.heap: return heapq.heappop(self.heap)[2] return None # Example usage: notif_queue = NotificationQueue() notif_queue.add_notification(\\"Low battery\\", 5) notif_queue.add_notification(\\"Update available\\", 7) notif_queue.add_notification(\\"Meeting at 3 PM\\", 4) print(notif_queue.get_notification()) # Output: \\"Update available\\" print(notif_queue.get_notification()) # Output: \\"Low battery\\" print(notif_queue.get_notification()) # Output: \\"Meeting at 3 PM\\" print(notif_queue.get_notification()) # Output: None ```","solution":"import heapq from typing import Optional class NotificationQueue: def __init__(self) -> None: self.heap = [] self.counter = 0 # To track the order of insertion def add_notification(self, notification: str, priority: int) -> None: Adds a new notification with the given message and priority to the queue. heapq.heappush(self.heap, (-priority, self.counter, notification)) self.counter += 1 def get_notification(self) -> Optional[str]: Retrieves and removes the highest-priority notification message from the queue. If the queue is empty, returns None. if self.heap: return heapq.heappop(self.heap)[2] return None # Example usage: notif_queue = NotificationQueue() notif_queue.add_notification(\\"Low battery\\", 5) notif_queue.add_notification(\\"Update available\\", 7) notif_queue.add_notification(\\"Meeting at 3 PM\\", 4) print(notif_queue.get_notification()) # Output: \\"Update available\\" print(notif_queue.get_notification()) # Output: \\"Low battery\\" print(notif_queue.get_notification()) # Output: \\"Meeting at 3 PM\\" print(notif_queue.get_notification()) # Output: None"},{"question":"# Question: Given a binary tree, implement a function to find the path from the root to the deepest leaf node. Return the path as a list of values. If there are multiple deepest leaves with the same depth, return the path to the leftmost deepest node. # Function Signature: ```python def deepest_path(root: Optional[TreeNode]) -> List[int]: ``` # Input: * `root`: The root node of a binary tree. # Output: * A list of integer values representing the path from the root to the deepest leaf node, returned in order from root to leaf. # Constraints: * The binary tree contains at most 10^4 nodes. * The value of each node is an integer within the range `[-10^5, 10^5]`. # Example: ```python # Example of TreeNode class definition for reference: # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.left.left = TreeNode(7) root.right.right = TreeNode(6) root.right.right.right = TreeNode(8) assert deepest_path(root) == [1, 2, 4, 7] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.right = TreeNode(4) root.right.right.right = TreeNode(5) root.right.right.right.right = TreeNode(6) assert deepest_path(root) == [1, 3, 4, 5, 6] ``` # Explanation: * In the first example, the path to the deepest leaf node (7) is `[1, 2, 4, 7]`. * In the second example, the path to the deepest leaf node (6) is `[1, 3, 4, 5, 6]`, even though multiple nodes have the same depth, the leftmost criterion does not apply here since the deepest path is on the rightmost node. --- # Note: To construct the TreeNode class for the binary tree: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_path(root: Optional[TreeNode]) -> List[int]: if not root: return [] def dfs(node, depth): if not node: return (depth, []) left_depth, left_path = dfs(node.left, depth + 1) right_depth, right_path = dfs(node.right, depth + 1) if left_depth >= right_depth: return (left_depth, [node.val] + left_path) else: return (right_depth, [node.val] + right_path) depth, path = dfs(root, 0) return path"},{"question":"# Problem Statement You need to write a function `number_of_islands(grid: List[List[str]]) -> int` that determines the number of distinct islands in a given 2D grid map. An island is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. Each cell is either land (\'1\') or water (\'0\'). A grid is navigable if you can move to the adjacent land cell horizontally or vertically. Diagonal moves are not allowed. # Input - A 2D list `grid` of characters representing the map: - `\'1\'` represents land. - `\'0\'` represents water. - The grid\'s dimensions are given by (m) x (n) where (1 leq m, n leq 300). # Output - An integer representing the number of distinct islands on the given grid. # Examples ```python >>> grid = [ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ] >>> number_of_islands(grid) 3 >>> grid = [ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ] >>> number_of_islands(grid) 3 ``` # Constraints - The input grid can have a maximum size of 300x300. - Each cell in the grid is either `\'1\'` or `\'0\'`.","solution":"from typing import List def number_of_islands(grid: List[List[str]]) -> int: if not grid: return 0 rows = len(grid) cols = len(grid[0]) count = 0 def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == \'0\': return grid[r][c] = \'0\' # Mark the land as visited by turning it into water # Check all four directions (up, down, left, right) dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) for r in range(rows): for c in range(cols): if grid[r][c] == \'1\': count += 1 dfs(r, c) return count"},{"question":"# Problem Context Working with strings in programming often involves the need to identify patterns or counts of specific subpatterns. One interesting problem is to compute the frequency of a specific substring within a larger text. This could be useful for various text analysis tasks. # Problem Statement You need to write a function `count_substring_occurrences(text: str, pattern: str) -> int` that takes two strings: `text`, which is the main body of text, and `pattern`, which is the substring that you want to count within `text`. The function should return the number of times `pattern` occurs in `text`. # Function Signature ```python def count_substring_occurrences(text: str, pattern: str) -> int: # your code here ``` # Input - A string `text` which represents the main text. - A string `pattern` which represents the substring to be counted within `text`. # Output - An integer representing the number of times `pattern` occurs in `text`. # Constraints - `text` and `pattern` will only contain lowercase English letters. - The length of `pattern` will be less than or equal to the length of `text`. - If `pattern` is an empty string, the number of occurrences in `text` should be 0. # Examples ```python assert count_substring_occurrences(\\"abracadabra\\", \\"abra\\") == 2 assert count_substring_occurrences(\\"aaaaaa\\", \\"aa\\") == 5 assert count_substring_occurrences(\\"hello\\", \\"ll\\") == 1 assert count_substring_occurrences(\\"abc\\", \\"d\\") == 0 assert count_substring_occurrences(\\"test\\", \\"\\") == 0 ``` # Edge Cases to Consider 1. When `pattern` is an empty string, the result should be 0. 2. If `pattern` is longer than `text`, the function should naturally return 0. 3. Ensure proper handling of overlapping patterns, such as in the second example.","solution":"def count_substring_occurrences(text: str, pattern: str) -> int: Returns the number of times pattern occurs in text. if not pattern: return 0 count = 0 start = 0 while True: start = text.find(pattern, start) if start == -1: break count += 1 start += 1 # Move past the current match to check for overlapping patterns return count"},{"question":"# Problem Statement: You\'re working on a feature for an e-commerce application that manages product pricing. To better understand how pricing changes over time, you need a function that calculates the moving average of product prices. A moving average smooths out price data to show long-term trends by averaging a window of `k` consecutive prices. Your task is to implement a function that performs this calculation efficiently. # Function Definition: ```python def calculate_moving_average(prices: list[float], k: int) -> list[float]: Calculate the moving average of the product prices over a window of k consecutive prices. Parameters: - prices: A list of floats representing the product prices. - k: An integer specifying the size of the moving average window. Returns: - A list of floats representing the moving averages. ``` # Input and Output: - **Input**: - `prices`: A list of floats, where each float represents the price of a product at a different time point. The list length will not exceed 10^4. - `k`: An integer, where 1 ≤ `k` ≤ 10^3. - **Output**: A list of floats, each representing the moving average of `k` consecutive prices. # Constraints: - If `k` is greater than the length of the `prices` list, return an empty list. - The input `prices` list can include any valid floating-point numbers. - Handle edge cases such as an empty prices list or invalid `k` values gracefully. # Example: ```python calculate_moving_average([1.0, 2.0, 3.0, 4.0, 5.0], 2) # Output: [1.5, 2.5, 3.5, 4.5] calculate_moving_average([10.0, 20.0, 30.0, 40.0, 50.0], 3) # Output: [20.0, 30.0, 40.0] calculate_moving_average([5.0, 4.0, 3.0, 2.0, 1.0], 1) # Output: [5.0, 4.0, 3.0, 2.0, 1.0] calculate_moving_average([100.0, 200.0, 300.0], 5) # Output: [] calculate_moving_average([], 3) # Output: [] ``` # Notes: - Ensure the function uses an efficient algorithm to calculate the moving averages, avoiding unnecessary recalculations. - Consider using data structures that support quick insertion and deletion operations to maintain the moving window of `k` prices. - Be cautious of potential floating-point precision issues when dealing with currency-like prices. Good luck, and happy coding!","solution":"from typing import List def calculate_moving_average(prices: List[float], k: int) -> List[float]: Calculate the moving average of the product prices over a window of k consecutive prices. Parameters: - prices: A list of floats representing the product prices. - k: An integer specifying the size of the moving average window. Returns: - A list of floats representing the moving averages. n = len(prices) if k > n: return [] result = [] window_sum = sum(prices[:k]) result.append(window_sum / k) for i in range(k, n): window_sum += prices[i] - prices[i - k] result.append(window_sum / k) return result"},{"question":"# Question: Rearrange Numbers to Form the Largest Possible Number You are tasked with writing a function `largest_possible_number` that takes a list of integers and arranges them such that they form the largest possible number when concatenated together. # Function Signature: ```python def largest_possible_number(numbers: List[int]) -> str: pass ``` # Input Format * A list of non-negative integers. # Output Format * A string representing the largest possible number formed by the input list. # Constraints * 1 <= len(numbers) <= 100 * 0 <= numbers[i] <= 10^9 # Example ```python >>> largest_possible_number([3, 30, 34, 5, 9]) \'9534330\' >>> largest_possible_number([1, 20, 23, 4, 8]) \'8423201\' >>> largest_possible_number([10, 2]) \'210\' ``` # Notes Your implementation should handle large lists and large values efficiently. They should also account for cases where the input list contains multiple numbers of varied lengths and values, ensuring they are concatenated in the optimal order to form the largest possible number.","solution":"from typing import List def largest_possible_number(numbers: List[int]) -> str: from functools import cmp_to_key def compare(x, y): return (x + y > y + x) - (x + y < y + x) numbers_str = list(map(str, numbers)) numbers_str.sort(key=cmp_to_key(compare), reverse=True) largest_num = \'\'.join(numbers_str) return largest_num if largest_num[0] != \'0\' else \'0\'"},{"question":"# Coding Assessment Question Context: A numerical problem involves monitoring the stock prices of a company and identifying key points of interest. You need to develop an algorithm to detect the largest peak value and the largest trough value in a given sequence of stock prices. Task: Write a Python function `find_peak_and_trough(prices: List[int]) -> Tuple[int, int]` that identifies the highest peak (largest value) and the lowest trough (smallest value) in the provided list of stock prices. 1. **Function Signature**: ```python def find_peak_and_trough(prices: List[int]) -> Tuple[int, int]: ``` 2. **Input**: - `prices` (a list of integers): The historical stock prices represented as a list of integers. 3. **Output**: - Returns a tuple containing two integers: - The first integer is the largest peak value. - The second integer is the lowest trough value. 4. **Constraints**: - The input list `prices` always contains at least two elements. - The length of `prices` is at most 10^5. - Each price is guaranteed to be a positive integer and within the range 1 to 10^6. 5. **Performance Requirement**: - Your solution should handle the largest constraints within a reasonable time frame. Examples: ```python # Example 1 assert find_peak_and_trough([10, 7, 8, 9, 6, 12, 4, 11]) == (12, 4) # Peak is 12, Trough is 4 # Example 2 assert find_peak_and_trough([5, 5, 5, 5, 5]) == (5, 5) # All values are the same so peak and trough are both 5 ``` Notes: - Consider edge cases where prices may not vary significantly. - Implement efficient algorithms to process the data within the provided constraints. - Avoid unnecessary computations and strive for solutions with linear time complexity, if possible.","solution":"from typing import List, Tuple def find_peak_and_trough(prices: List[int]) -> Tuple[int, int]: Identifies the highest peak (largest value) and the lowest trough (smallest value) in the provided list of stock prices. Args: prices: A list of integers representing the historical stock prices. Returns: A tuple containing two integers: - The first integer is the largest peak value. - The second integer is the lowest trough value. peak = max(prices) trough = min(prices) return peak, trough"},{"question":"# Scenario: You are working as a backend developer and need to optimize the performance of a web application by reducing the response time of database queries. One crucial task is to implement a caching mechanism that stores and retrieves query results efficiently to minimize redundant database accesses. # Task: Implement a class-based caching system that uses Least Recently Used (LRU) eviction policy. The cache should store results based on query strings and return cached results for previously seen queries. If the cache reaches its capacity, it should evict the least recently used item before storing a new one. # Class Signature: ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a given capacity. Parameters: - capacity (int): The maximum number of items the cache can hold. def get(self, query: str) -> str: Retrieve the result of the given query from the cache. Parameters: - query (str): The query string to look up. Returns: - str: The result of the query if found in the cache, otherwise returns a message indicating a cache miss. def put(self, query: str, result: str) -> None: Store the result of a query in the cache. Parameters: - query (str): The query string that produced the result. - result (str): The result of the query to be stored in the cache. ``` # Constraints: - The methods should provide O(1) time complexity for both get and put operations. - The class should handle edge cases such as trying to get a result for a query not in the cache (cache miss). - Handle cache capacity properly with least recently used eviction policy. # Performance: - The cache should efficiently handle up to 10,000 items. - The solution must ensure that the web application’s response time improves significantly by reducing redundant database access for frequent queries. # Evaluation: - Your solution will be evaluated on its correctness, efficiency, and adherence to the LRU eviction policy. - Appropriate handling of cache hits and misses, as well as the maintainability and readability of the code, will be considered. --- This new question should fit well with the original set, matching in length, complexity, and style, and focusing on the implementation of a typical algorithmic challenge commonly encountered in backend development.","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] def get(self, query: str) -> str: if query in self.cache: self.order.remove(query) self.order.append(query) return self.cache[query] else: return \\"Cache miss\\" def put(self, query: str, result: str) -> None: if query in self.cache: self.order.remove(query) elif len(self.cache) >= self.capacity: oldest_query = self.order.pop(0) del self.cache[oldest_query] self.cache[query] = result self.order.append(query)"},{"question":"# Problem Statement: You are optimizing solutions for various numerical challenges. One common task is finding prime numbers within specific ranges, which often surfaces in algorithmic competitions and data processing. **Goal**: Implement a function that returns a list of all prime numbers less than or equal to a given number `m`. # Input: - A single integer `m` (2 ≤ `m` ≤ 1,000,000). Check and validate the input. If the input is not an integer or not castable to an integer, raise a TypeError with the message: `\\"Parameter m must be int or castable to int.\\"` - If `m` is less than 2, raise a ValueError with the message: `\\"Parameter m must be greater than or equal to 2.\\"`. # Output: - A list of integers, representing the prime numbers less than or equal to `m`. # Constraints: - Utilize efficient algorithms such as the Sieve of Eratosthenes to handle the upper limit efficiently. # Performance Requirements: - Ensure the solution is optimal in terms of both time and space complexity. # Example: For example: ```python >>> list_primes(10) [2, 3, 5, 7] >>> list_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> list_primes(1) ValueError: \'Parameter m must be greater than or equal to 2.\' >>> list_primes(15.5) ValueError: \'Parameter m must be int or castable to int.\' >>> list_primes(\'a\') TypeError: \'Parameter m must be int or castable to int.\' ``` # Scenario: Software developers and data scientists frequently need to filter or identify prime numbers from datasets quickly. Your task is to write a highly optimized function to fulfill these needs efficiently.","solution":"def list_primes(m): Returns a list of all prime numbers less than or equal to a given number m. Parameters: m : int An integer m (2 ≤ m ≤ 1,000,000) Returns: list A list of all prime numbers ≤ m. Raises: TypeError If the input is not an integer or not castable to an integer. ValueError If the input is less than 2. try: m = int(m) except (ValueError, TypeError): raise TypeError(\\"Parameter m must be int or castable to int.\\") if m < 2: raise ValueError(\\"Parameter m must be greater than or equal to 2.\\") sieve = [True] * (m + 1) sieve[0] = sieve[1] = False for i in range(2, int(m**0.5) + 1): if sieve[i]: for j in range(i*i, m + 1, i): sieve[j] = False return [x for x in range(2, m + 1) if sieve[x]]"},{"question":"# Problem Statement You are tasked with implementing a `SortedList` class that maintains a sorted list with efficient insertion and deletion operations. The class should support the following operations: * **Initialization**: Create an empty sorted list. * **`insert(value: int) -> None`**: Insert `value` into the sorted list while maintaining the sorted order. * **`remove(value: int) -> None`**: Remove one occurrence of `value` from the list. If `value` is not present, do nothing. * **`__contains__(value: int) -> bool`**: Check whether `value` is present in the sorted list. * **`__len__() -> int`**: Return the number of elements in the list. * **`__getitem__(index: int) -> int`**: Return the element at the given `index` in the sorted list. * **`__iter__() -> Iterator[int]`**: Return an iterator over the sorted list. # Function Signature Here\'s the function signature you should implement: ```python class SortedList: def __init__(self) -> None: pass def insert(self, value: int) -> None: pass def remove(self, value: int) -> None: pass def __contains__(self, value: int) -> bool: pass def __len__(self) -> int: pass def __getitem__(self, index: int) -> int: pass def __iter__(self) -> Iterator[int]: pass ``` # Input/Output Format * The constructor initializes an empty sorted list. * The `insert` method takes one integer `value`, and inserts it into the sorted list. * The `remove` method takes one integer `value`, and removes one occurrence of it from the list. * The `__contains__` method takes one integer `value`, and returns a boolean indicating if the value is present in the list. * The `__len__` method returns the number of elements in the list. * The `__getitem__` method takes an integer `index`, and returns the element at that index. * The `__iter__` method returns an iterator over the sorted list. # Constraints * Each operation should have a time complexity of (O(log n)) on average. * The elements in the list are unique. # Examples ```python # Example 1 sl = SortedList() sl.insert(3) print(3 in sl) # Output: True print(len(sl)) # Output: 1 sl.remove(3) print(3 in sl) # Output: False print(len(sl)) # Output: 0 # Example 2 sl.insert(1) sl.insert(5) sl.insert(3) for val in sl: print(val, end=\\" \\") # Output: 1 3 5 print() print(sl[0]) # Output: 1 print(sl[1]) # Output: 3 print(sl[2]) # Output: 5 ``` **Performance Requirement** Your solution should be efficient and handle operations in logarithmic complexity, targeting a solution that works within (O(log n)) time per operation.","solution":"import bisect from typing import Iterator, List class SortedList: def __init__(self) -> None: self.data: List[int] = [] def insert(self, value: int) -> None: bisect.insort(self.data, value) def remove(self, value: int) -> None: index = bisect.bisect_left(self.data, value) if index != len(self.data) and self.data[index] == value: self.data.pop(index) def __contains__(self, value: int) -> bool: index = bisect.bisect_left(self.data, value) return index != len(self.data) and self.data[index] == value def __len__(self) -> int: return len(self.data) def __getitem__(self, index: int) -> int: return self.data[index] def __iter__(self) -> Iterator[int]: return iter(self.data)"},{"question":"# Problem Statement: You need to write a program to find the path from the root to a given target node in a binary tree. A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. Your task is to implement the function `find_path_to_node(root, target)` which takes two arguments: - `root`: the root node of the binary tree. - `target`: the value of the target node. The function should return a list containing the values of nodes forming the path from the root to the target node. If the target node does not exist in the tree, the function should return an empty list. # Requirements: 1. Implement the `TreeNode` class to define the structure of the nodes in the binary tree: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` 2. Implement the function `find_path_to_node`: ```python def find_path_to_node(root: TreeNode, target: int) -> list: # Your code to find the path to the target node. ``` # Example: ```python # Helper function to build the tree (binary tree construction is not part of the problem) def build_tree(nodes): val = next(nodes) if val == \'null\': return None node = TreeNode(int(val)) node.left = build_tree(nodes) node.right = build_tree(nodes) return node # Tree Construction [3,9,20,\'null\',\'null\',15,7] nodes = iter([3, 9, \'null\', \'null\', 20, 15, \'null\', \'null\', 7, \'null\', \'null\']) root = build_tree(nodes) target = 15 print(find_path_to_node(root, target)) # Output: [3, 20, 15] target = 9 print(find_path_to_node(root, target)) # Output: [3, 9] target = 7 print(find_path_to_node(root, target)) # Output: [3, 20, 7] target = 10 print(find_path_to_node(root, target)) # Output: [] ``` # Constraints: * The tree is a valid binary tree with node values being unique. * The number of nodes in the binary tree will not exceed `10^4`. * The target node value will be within the range of node values in the given binary tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_path_to_node(root: TreeNode, target: int) -> list: def helper(node, path): if not node: return False path.append(node.value) if node.value == target: return True if helper(node.left, path) or helper(node.right, path): return True path.pop() return False path = [] if helper(root, path): return path else: return []"},{"question":"# Problem: Implement a Directed Graph with Cycle Detection You are asked to implement a directed graph and write a function to detect cycles in the graph. The graph should efficiently store nodes and their directed edges. Function 1: `add_node` Write a method `add_node(self, node: int) -> None` that adds a node to the graph. Function 2: `add_edge` Write a method `add_edge(self, src: int, dst: int) -> None` that adds a directed edge from `src` to `dst`. Function 3: `detect_cycle` Write a method `detect_cycle(self) -> bool` that detects if there is a cycle in the graph. Input * A series of node and edge additions, followed by a call to `detect_cycle`. Output * Returns `True` if there is a cycle in the graph, otherwise `False`. Example ```python >>> graph = DirectedGraph() >>> graph.add_node(1) >>> graph.add_node(2) >>> graph.add_node(3) >>> graph.add_edge(1, 2) >>> graph.add_edge(2, 3) >>> graph.add_edge(3, 1) >>> graph.detect_cycle() True >>> graph = DirectedGraph() >>> graph.add_node(1) >>> graph.add_node(2) >>> graph.add_node(3) >>> graph.add_edge(1, 2) >>> graph.add_edge(2, 3) >>> graph.detect_cycle() False ``` Constraints * There are no duplicate nodes or edges. * The number of nodes is between 1 and 1000. * The number of edges is between 0 and 1000. * Nodes are represented as integers. # Additional Notes * The cycle detection should be implemented using Depth-First Search (DFS) or any other efficient algorithm. * Handle cases where graph is empty or contains no edges.","solution":"class DirectedGraph: def __init__(self): self.graph = {} def add_node(self, node: int) -> None: if node not in self.graph: self.graph[node] = [] def add_edge(self, src: int, dst: int) -> None: if src in self.graph and dst in self.graph: self.graph[src].append(dst) def detect_cycle(self) -> bool: visited = set() rec_stack = set() def dfs(node): if node not in visited: visited.add(node) rec_stack.add(node) for neighbour in self.graph[node]: if neighbour not in visited and dfs(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(node) return False for node in self.graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Matrix Transposition Context Matrix transposition is a fundamental operation in many scientific and engineering computations. Transposing a matrix involves swapping its rows with its columns. Task Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list (matrix) as input and returns the transposed version of the matrix. 1. The transpose of a matrix (A) with dimensions (m times n) is another matrix (A^T) with dimensions (n times m). 2. The element at (i)-th row and (j)-th column of (A) becomes the element at (j)-th row and (i)-th column of (A^T). Requirements * **Input Format**: - `matrix`: A list of lists of integers representing an (m times n) matrix. * **Output Format**: - A list of lists of integers representing the transposed (n times m) matrix. * **Constraints**: - The input matrix can be empty or a valid non-empty matrix. - Rows of the matrix may have varying lengths if the matrix is jagged, and the function should handle it appropriately. Example Usage ```python from typing import List # Function to transpose the matrix def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] # Determine number of rows and columns m, n = len(matrix), len(matrix[0]) # Handle jagged matrices by considering max length of rows n = max(len(row) for row in matrix) # Initialize the transposed matrix with dimensions transposed = [] for col in range(n): new_row = [] for row in matrix: if col < len(row): new_row.append(row[col]) else: new_row.append(None) # Handle jagged matrix transposed.append(new_row) return transposed # Example 1 matrix_1 = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix_1)) # Output: [[1, 4], [2, 5], [3, 6]] # Example 2 matrix_2 = [ [1, 2], [3, 4], [5, 6] ] print(transpose_matrix(matrix_2)) # Output: [[1, 3, 5], [2, 4, 6]] ``` Edge Cases * Handle empty matrices correctly, i.e., `[]` should return `[]`. * Handle jagged matrices where the rows have different lengths, filling shorter rows with `None`. Notes - Ensure efficiency for matrices up to dimensions around (10^3 times 10^3). - Consider edge cases and validate input to cover scenarios where inputs might be irregular or unexpected.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] # Determine the number of columns in the longest row to handle jagged matrices max_col_length = max(len(row) for row in matrix) if matrix else 0 # Create the transposed matrix initializing with None to handle jaggedness properly transposed = [[None] * len(matrix) for _ in range(max_col_length)] for row_idx, row in enumerate(matrix): for col_idx, element in enumerate(row): transposed[col_idx][row_idx] = element return transposed"},{"question":"# Coding Assessment Question A logistic company is integrating a feature to efficiently manage its delivery schedule by calculating the **Median Arrival Time** of its shipments. As the shipments come from various origins and have different travel times, you need to accurately determine the median time it takes for shipments to arrive. **Function Specification:** Implement the function `median_arrival_time` that takes a list of integers representing the arrival times in minutes and returns a float representing the median arrival time. ```python def median_arrival_time(arrival_times: list[int]) -> float: pass ``` # Input - `arrival_times` (list of integers): List containing the arrival times. It may be empty. # Output - Returns a float representing the median arrival time. # Constraints - You can assume that all elements in the list will be integers. - The list size can be large, and the implementation should be optimal. # Requirements - Handle edge cases like empty lists gracefully by raising a `ValueError` with the message `\\"List is empty\\"`. - The solution should be implemented with a time complexity of (O(n log n)) due to the sorting step. # Functionality Tests Ensure your function passes the following test cases: ```python >>> median_arrival_time([30]) 30.0 >>> median_arrival_time([15, 20, 35, 45, 50]) 35.0 >>> median_arrival_time([5, 3, 8, 1]) 4.0 >>> median_arrival_time([10, 200, 3, 40, 75, 85, 60]) 60.0 >>> median_arrival_time([]) Traceback (most recent call last): ... ValueError: List is empty ``` # Scenario Imagine you are optimizing the scheduling system for a courier service, which operates in various urban and rural areas. To ensure timely operations and improve service efficiency, calculate the median arrival time of shipments reaching their destinations using the `median_arrival_time` function. This will help in understanding the central tendency of shipment arrival times and adjusting schedules accordingly.","solution":"def median_arrival_time(arrival_times: list[int]) -> float: Returns the median arrival time from a list of arrival times. Parameters: arrival_times (list of int): A list containing the arrival times in minutes. Returns: float: Median of the arrival times. Raises: ValueError: If the list is empty. if not arrival_times: raise ValueError(\\"List is empty\\") sorted_times = sorted(arrival_times) n = len(sorted_times) if n % 2 == 1: return float(sorted_times[n // 2]) else: mid1 = sorted_times[n // 2 - 1] mid2 = sorted_times[n // 2] return (mid1 + mid2) / 2"},{"question":"# Coding Assessment Question: Box Volume Calculator Context: You are tasked with developing a function that calculates the volume of a rectangular box. The formula for the volume ( V ) of a box is: [ V = text{length} times text{width} times text{height} ] Task: Write a Python function `box_volume_calculator` that takes three floating-point numbers: `length`, `width`, and `height`, and returns the volume of the box calculated using the given formula. Input: * Three positive floating-point numbers `length`, `width`, and `height` representing the dimensions of the box. Output: * A floating-point number representing the calculated volume of the box. Constraints: * All dimensions (`length`, `width`, `height`) must be positive. Raise a `ValueError` if any dimension is zero or negative. Example: ```python >>> box_volume_calculator(2.0, 3.0, 4.0) 24.0 >>> box_volume_calculator(5.5, 7.5, 3.0) 123.75 >>> box_volume_calculator(2.0, -1.0, 2.0) Traceback (most recent call last): ... ValueError: All dimensions must be positive >>> box_volume_calculator(0.0, 3.0, 2.0) Traceback (most recent call last): ... ValueError: All dimensions must be positive ``` Requirements: 1. Ensure your function validates that all dimensions are positive. 2. Include error handling to raise a `ValueError` on invalid input. 3. Optimize your code for readability and efficiency. Performance: * The function should run in constant time ( O(1) ). * Memory usage must be constant as well ( O(1) ). # Answer: ```python def box_volume_calculator(length, width, height): if length <= 0 or width <= 0 or height <= 0: raise ValueError(\\"All dimensions must be positive\\") return length * width * height # Example usage: # print(box_volume_calculator(2.0, 3.0, 4.0)) # Output: 24.0 # print(box_volume_calculator(5.5, 7.5, 3.0)) # Output: 123.75 ```","solution":"def box_volume_calculator(length, width, height): if length <= 0 or width <= 0 or height <= 0: raise ValueError(\\"All dimensions must be positive\\") return length * width * height"},{"question":"# Scenario: You are developing a text-based analysis tool and need to implement a function that identifies the most frequently occurring word in a piece of text. The function should ignore punctuation and be case-insensitive. # Function Requirements: * Implement a function `most_frequent_word` that takes a string of text and returns the most common word. * Ignore punctuation (i.e., treat \\"hello!\\" and \\"hello\\" as the same word). * Treat the text as case-insensitive (i.e., \\"Hello\\" and \\"hello\\" should be considered the same word). * In the case of a tie, return any one of the most frequent words. * Handle edge cases such as empty strings or strings with no words. # Constraints: * The input text will be a valid non-null string. * Words will be separated by spaces. * Punctuation will only include: .,?!;:()[] # Function Signature: ```python def most_frequent_word(text: str) -> str: pass ``` # Example: ```python assert most_frequent_word(\\"Hello, hello! How are you? Are you okay?\\") == \\"are\\" assert most_frequent_word(\\"This is a test. This is only a test.\\") == \\"this\\" assert most_frequent_word(\\"No words here\\") == \\"no\\" # assuming single-word text returns the same word assert most_frequent_word(\\"\\") == \\"\\" ``` # Input: - `text` (string): A string containing the text to analyze. # Output: - (string): The most frequently occurring word in the text. **Good luck!**","solution":"import re from collections import Counter def most_frequent_word(text: str) -> str: Returns the most frequently occurring word in the text, ignoring punctuation and case. In case of a tie, any one of the most frequent words can be returned. if not text: return \\"\\" # Convert text to lowercase and remove punctuation cleaned_text = re.sub(r\'[^ws]\', \'\', text.lower()) # Split the cleaned text into words words = cleaned_text.split() if not words: return \\"\\" # Use Counter to find the most common word most_common_word, _ = Counter(words).most_common(1)[0] return most_common_word"},{"question":"# Task: Event Scheduler You have been hired to develop an event scheduler for a small company. The scheduler should be able to handle adding new events, deleting events, and checking for scheduling conflicts. Part 1: Event Addition Write a class `EventScheduler` with a method `add_event(event_name: str, start_time: str, end_time: str) -> bool` that: - Takes the name of the event `event_name`, and the start and end times of the event in the `HH:MM` 24-hour format. - Adds the event to the scheduler if there are no timing conflicts. - Returns `True` if the event is successfully added; otherwise, returns `False` if the event conflicts with an already scheduled event. Part 2: Event Deletion Add a method `delete_event(event_name: str) -> bool` to the class `EventScheduler` that: - Takes the name of the event `event_name` as input. - Deletes the event from the scheduler if it exists. - Returns `True` if the event is successfully deleted; otherwise, returns `False`. Part 3: Conflict Check Add a method `is_conflict(start_time: str, end_time: str) -> bool` to the class `EventScheduler` that: - Takes the start and end times in the `HH:MM` 24-hour format. - Returns `True` if the specified time range conflicts with any existing event in the scheduler; otherwise, returns `False`. Constraints: - Events provided are guaranteed to have valid `HH:MM` times and `start_time` is always less than `end_time`. - Only one event can be scheduled at a particular time slot, and event names are unique strings. Example ```python scheduler = EventScheduler() scheduler.add_event(\\"Meeting1\\", \\"09:00\\", \\"10:00\\") # returns True scheduler.add_event(\\"Meeting2\\", \\"09:30\\", \\"11:00\\") # returns False due to conflict scheduler.add_event(\\"Meeting3\\", \\"10:30\\", \\"11:30\\") # returns True scheduler.delete_event(\\"Meeting1\\") # returns True scheduler.is_conflict(\\"09:00\\", \\"10:00\\") # returns False after deletion >>> scheduler.add_event(\\"Meeting1\\", \\"09:00\\", \\"10:00\\") True >>> scheduler.is_conflict(\\"09:30\\", \\"10:30\\") True >>> scheduler.delete_event(\\"Meeting1\\") True >>> scheduler.is_conflict(\\"09:30\\", \\"10:30\\") False ``` Requirements - Ensure that the methods handle the conflicts and deletions correctly. - Provide efficient operations for adding, deleting, and checking conflicts of events. Implement the `EventScheduler` class with all the methods in Python.","solution":"class EventScheduler: def __init__(self): self.events = {} def add_event(self, event_name: str, start_time: str, end_time: str) -> bool: if self.is_conflict(start_time, end_time): return False self.events[event_name] = (start_time, end_time) return True def delete_event(self, event_name: str) -> bool: if event_name in self.events: del self.events[event_name] return True return False def is_conflict(self, start_time: str, end_time: str) -> bool: for s_time, e_time in self.events.values(): if not (end_time <= s_time or start_time >= e_time): return True return False"},{"question":"# Problem Statement You are given an array of integers `arr` of size `n`. Implement a data structure known as a \\"Fenwick Tree\\" (also called a \\"Binary Indexed Tree\\") that supports the following operations efficiently: 1. **Point Update**: Update the value of an element at a given index to a new value. 2. **Prefix Sum Query**: Query the sum of elements from the start of the array up to a given index. The Fenwick Tree should efficiently handle multiple such operations. # Function Specifications 1. **`__init__(self, size: int) -> None`**: Initialize the Fenwick Tree for an array of given size. 2. **`build(self, a: list[int]) -> None`**: Build the Fenwick Tree with the given initial array `a`. 3. **`update(self, idx: int, delta: int) -> None`**: Update the value at index `idx` by adding `delta`. 4. **`query(self, idx: int) -> int`**: Query the prefix sum of elements from the start up to index `idx`. # Input/Output Specifications - Input: - An array of integers `arr` of size `n`. - Multiple update and query operations. - Output: - For each query operation, return the prefix sum up to the specified index. # Constraints - ( 1 leq n leq 10^5 ) - ( -10^9 leq arr[i], val leq 10^9 ) - Queries and updates can be of the order ( 10^4 ). # Example ```python A = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3, 4, 5, 2, 6] size = 15 fenwick = FenwickTree(size) fenwick.build(A) print(fenwick.query(4)) # Output: 10, since 3 + 2 + (-1) + 6 = 10 print(fenwick.query(7)) # Output: 16, since 3 + 2 + (-1) + 6 + 5 + 4 + (-3) = 16 fenwick.update(3, 3) # Increase value at index 3 by 3, new value at index 3 is 9 print(fenwick.query(4)) # Output: 13, since 3 + 2 + (-1) + 9 = 13 fenwick.update(5, -1) # Decrease value at index 5 by 1, new value at index 5 is 4 print(fenwick.query(7)) # Output: 15, since 3 + 2 + (-1) + 9 + 5 + 4 + (-3) = 15 ``` # Task Your task is to implement the Fenwick Tree with the functionality for both efficient point updates and prefix sum queries.","solution":"class FenwickTree: def __init__(self, size: int) -> None: Initialize the Fenwick Tree for an array of given size. self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: Build the Fenwick Tree with the given initial array `a`. for idx, val in enumerate(a): self.update(idx + 1, val) def update(self, idx: int, delta: int) -> None: Update the value at index `idx` by adding `delta`. while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: Query the prefix sum of elements from the start up to index `idx`. sum_ = 0 while idx > 0: sum_ += self.tree[idx] idx -= idx & -idx return sum_"},{"question":"# Problem Statement Given an array of integers, you are required to return the smallest `k` numbers from the array in ascending order. You need to implement the function with an efficient algorithm that can handle large arrays. **Function Signature**: ```python def smallest_k_numbers(arr: List[int], k: int) -> List[int]: ``` # Input: - `arr`: A list of integers representing the input array. - `k`: An integer representing the number of smallest elements to return. # Output: - Returns a list of `k` integers representing the smallest `k` numbers from the input array in ascending order. # Constraints: - `1 <= len(arr) <= 10^5` (the array can be very large). - `1 <= k <= len(arr)` (k is valid within the length of the array). - The array elements are integers within the range `-10^9` to `10^9`. # Example: ```python assert smallest_k_numbers([7, 10, 4, 3, 20, 15], 3) == [3, 4, 7] assert smallest_k_numbers([1, 2, 3, 4, 5, 6], 2) == [1, 2] ``` # Additional Information: - Consider the time complexity of your algorithm. Sorting the entire array and then selecting the smallest `k` elements might not be the most efficient approach. - You may use built-in functions and data structures that can help achieve the solution effectively. # Note: - The function should return exactly `k` smallest numbers, sorted in ascending order, without altering the original array. # Solution Approach: Consider using a min-heap or other advanced data structures to achieve an efficient selection of the smallest `k` numbers from the array. Aim for an overall time complexity better than (O(n log n)).","solution":"from typing import List import heapq def smallest_k_numbers(arr: List[int], k: int) -> List[int]: Returns the smallest k numbers from the array in ascending order. # Use a min-heap to find the k smallest elements efficiently if k == 0: return [] return heapq.nsmallest(k, arr)"},{"question":"# Matrix Path Counting **Scenario**: You are developing a robot navigation system for a grid-based warehouse. The warehouse is represented as an `m x n` grid, and the robot can only move either right or down at any point in time. Your task is to compute the number of possible unique paths the robot can take to reach the bottom-right corner of the grid, starting from the top-left corner. **Task**: Implement a function `count_paths` that calculates the number of unique paths for the robot to travel from the top-left to the bottom-right corner of the grid. **Specifications**: * You will write a function `count_paths(m: int, n: int) -> int`. * `m`: Number of rows in the grid. * `n`: Number of columns in the grid. **Constraints**: * The dimensions `m` and `n` will be positive integers, with values up to `100`. * The robot can only move right or down. * Assume the grid does not contain any obstacles. **Expected Output**: * Return the total number of unique paths as an `int`. **Examples**: ```python # Example 1: 3x3 grid result = count_paths(3, 3) print(result) # Expected: 6 # Example 2: 2x2 grid result = count_paths(2, 2) print(result) # Expected: 2 # Example 3: 1x1 grid (trivial case) result = count_paths(1, 1) print(result) # Expected: 1 # Example 4: Larger grid result = count_paths(4, 5) print(result) # Expected: 35 ``` Implement the `count_paths` function to meet these requirements.","solution":"def count_paths(m, n): Calculate the number of unique paths in an m x n grid for a robot moving only right or down. # Initialize the 2D array with zero values dp = [[0] * n for _ in range(m)] # Set the base case: there is only one way to reach any cell in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Iterate through the grid and fill in the number of paths for each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will contain the total number of unique paths return dp[m-1][n-1]"},{"question":"# Context In a database management system, transactions are sequences of operations (such as read, write, and commit) that must be executed following certain rules to ensure data consistency and atomicity. Your task is to implement a simple transaction scheduler that validates and schedules transactions while maintaining the ACID properties (Atomicity, Consistency, Isolation, Durability). # Task Implement the `TransactionScheduler` class. Method Details 1. **`__init__(self)`**: * Initializes the TransactionScheduler with no active transactions. 2. **`begin(self, transaction_id: int) -> bool`**: * Begins a new transaction. * Returns `False` if the transaction with the same ID is already active; otherwise, returns `True`. 3. **`read(self, transaction_id: int, data_item: str) -> bool`**: * Registers a read operation for the transaction on the specified data item. * Returns `False` if the transaction is not active; otherwise, returns `True`. 4. **`write(self, transaction_id: int, data_item: str) -> bool`**: * Registers a write operation for the transaction on the specified data item. * Returns `False` if the transaction is not active; otherwise, returns `True`. 5. **`commit(self, transaction_id: int) -> bool`**: * Commits the transaction, making its changes permanent. * Returns `False` if the transaction is not active; otherwise, returns `True`. 6. **`rollback(self, transaction_id: int) -> bool`**: * Rolls back the transaction, discarding all its changes. * Returns `False` if the transaction is not active; otherwise, returns `True`. # Requirement Ensure your implementation: * **Handles concurrent transactions correctly**: multiple transactions can be active simultaneously without interfering with each other. * **Maintains transaction logs**: should be able to log all operations for each transaction. * **Manages transaction states**: from active to committed or rolled back. * **Ensures consistency and isolation**: no transaction should see partial results of another. # Input and Output * Input: Sequence of transaction operations in the form of method calls. * Output: Boolean values indicating the success or failure of each operation. # Example ```python scheduler = TransactionScheduler() print(scheduler.begin(1)) # Output: True print(scheduler.read(1, \\"A\\")) # Output: True print(scheduler.write(1, \\"B\\")) # Output: True print(scheduler.commit(1)) # Output: True print(scheduler.read(1, \\"A\\")) # Output: False (since the transaction has been committed) print(scheduler.begin(2)) # Output: True print(scheduler.rollback(2)) # Output: True print(scheduler.commit(2)) # Output: False (since the transaction has been rolled back) ``` # Constraints * Transaction IDs are positive integers. * Data item identifiers are strings of alphanumeric characters. * Number of operations is at most (10^6).","solution":"class TransactionScheduler: def __init__(self): self.active_transactions = {} # Dictionary to store active transactions and their logs self.transaction_states = {} # Dictionary to store transaction states (active, committed, rolledback) def begin(self, transaction_id: int) -> bool: if transaction_id in self.active_transactions: return False self.active_transactions[transaction_id] = [] self.transaction_states[transaction_id] = \'active\' return True def read(self, transaction_id: int, data_item: str) -> bool: if transaction_id not in self.active_transactions: return False self.active_transactions[transaction_id].append(f\\"READ {data_item}\\") return True def write(self, transaction_id: int, data_item: str) -> bool: if transaction_id not in self.active_transactions: return False self.active_transactions[transaction_id].append(f\\"WRITE {data_item}\\") return True def commit(self, transaction_id: int) -> bool: if transaction_id not in self.active_transactions: return False self.transaction_states[transaction_id] = \'committed\' del self.active_transactions[transaction_id] return True def rollback(self, transaction_id: int) -> bool: if transaction_id not in self.active_transactions: return False self.transaction_states[transaction_id] = \'rolledback\' del self.active_transactions[transaction_id] return True"},{"question":"# Genetic Algorithm for Portfolio Optimization **Context**: An investment company wants to optimize a portfolio of assets to maximize returns while minimizing risk. They have formulated this as a multi-objective optimization problem and want you to use a genetic algorithm to find the optimal asset allocation. # Task: Implement the `genetic_algorithm` function to optimize a portfolio. You are given an `AssetAllocation` class with the following attributes: ```python class AssetAllocation: def __init__(self, allocation: dict): self.allocation = allocation # A dictionary with asset names as keys and allocation percentages as values def fitness(self) -> tuple: Returns a tuple (returns, risk) where: - returns: float, the expected return of the portfolio - risk: float, the risk (standard deviation of returns) of the portfolio pass # Defined elsewhere def crossover(self, other) -> \'AssetAllocation\': Combines this allocation with another `AssetAllocation` instance to produce a new `AssetAllocation`. pass # Defined elsewhere def mutate(self) -> \'AssetAllocation\': Mutates the current allocation by randomly modifying the asset percentages. pass # Defined elsewhere ``` # Function Signature: ```python def genetic_algorithm( initial_population: list, generations: int = 100, population_size: int = 50, crossover_rate: float = 0.7, mutation_rate: float = 0.01, elitism: bool = True ) -> AssetAllocation: pass ``` # Input: - `initial_population (list[AssetAllocation])`: The initial population of asset allocations. - `generations (int)`: The number of generations to run the algorithm for. - `population_size (int)`: The size of the population in each generation. - `crossover_rate (float)`: The rate at which crossover operations are performed. - `mutation_rate (float)`: The rate at which mutation operations are performed. - `elitism (bool)`: If True, always retain the best allocation from one generation to the next. # Output: - An `AssetAllocation` instance representing the optimized asset allocation with the best fitness. # Constraints: - Ensure your algorithm handles cases where asset allocations are invalid or fitness calculation is undefined. - Optimize both returns and risk, aiming for a balanced portfolio. - Handle constraints of allocation percentages summing up to 100%. # Example: ```python # Assume we have a proper implementation of `AssetAllocation` class initial_population = [AssetAllocation({\'AssetA\': 20, \'AssetB\': 30, \'AssetC\': 50}), AssetAllocation({\'AssetA\': 25, \'AssetB\': 35, \'AssetC\': 40}), AssetAllocation({\'AssetA\': 30, \'AssetB\': 25, \'AssetC\': 45})] optimized_allocation = genetic_algorithm(initial_population, generations=200, population_size=30, crossover_rate=0.8, mutation_rate=0.02) print(f\\"Optimized Allocation: {optimized_allocation.allocation} with Fitness: {optimized_allocation.fitness()}\\") ``` **Expectation**: A solution demonstrating your understanding of genetic algorithms, handling optimization trade-offs, and ensuring robustness in portfolio optimization.","solution":"import random class AssetAllocation: def __init__(self, allocation: dict): self.allocation = allocation def fitness(self) -> tuple: pass # Defined elsewhere def crossover(self, other) -> \'AssetAllocation\': pass # Defined elsewhere def mutate(self) -> \'AssetAllocation\': pass # Defined elsewhere def genetic_algorithm( initial_population: list, generations: int = 100, population_size: int = 50, crossover_rate: float = 0.7, mutation_rate: float = 0.01, elitism: bool = True ) -> AssetAllocation: def select_parents(population): total_fitness = sum(ind.fitness()[0] for ind in population) probabilities = [ind.fitness()[0] / total_fitness for ind in population] parents = [] for _ in range(population_size): parents.append(random.choices(population, weights=probabilities, k=1)[0]) return parents def create_new_generation(parents): new_generation = [] # Elitism: Keeping the best individual if elitism: best_individual = max(parents, key=lambda ind: ind.fitness()[0]) new_generation.append(best_individual) while len(new_generation) < population_size: if random.random() < crossover_rate: parent1 = random.choice(parents) parent2 = random.choice(parents) child = parent1.crossover(parent2) else: child = random.choice(parents) if random.random() < mutation_rate: child = child.mutate() new_generation.append(child) return new_generation # Initialize population population = initial_population for generation in range(generations): parents = select_parents(population) population = create_new_generation(parents) # Return the best individual in the final population return max(population, key=lambda ind: ind.fitness()[0])"},{"question":"Challenge: Harmonious Subsequence You are required to implement a function, `harmonious_subsequence`, that finds the length of the longest harmony subsequence in an array of integers. A harmonious subsequence is one where the difference between the largest and smallest values is exactly 1. # Function Signature ```python def harmonious_subsequence(nums: list) -> int: ``` # Input - `nums` (list): A list of integers. # Output - (int): The length of the longest harmonious subsequence. # Constraints - The list `nums` will contain at least one integer. # Error Handling - Raise a `ValueError` if `nums` is not a list of integers. # Examples ```python assert harmonious_subsequence([1, 3, 2, 2, 5, 2, 3, 7]) == 5 assert harmonious_subsequence([1, 1, 1, 1]) == 0 assert harmonious_subsequence([1, 2, 3, 4]) == 2 assert harmonious_subsequence([6, 6, 7, 7, 8, 9]) == 4 # Edge cases assert harmonious_subsequence([]) == 0 assert harmonious_subsequence([0]) == 0 assert harmonious_subsequence([10, 9]) == 2 ``` # Explanation - `harmonious_subsequence([1, 3, 2, 2, 5, 2, 3, 7])` returns `5` because the longest harmonious subsequence is [3,2,2,2,3] with difference 3 - 2 = 1. - `harmonious_subsequence([1, 1, 1, 1])` returns `0` because there is no subsequence with exactly 1 difference. # Additional Notes - Ensure to handle edge cases properly. - Aim for an efficient solution, taking care not to overuse memory or processing power.","solution":"def harmonious_subsequence(nums: list) -> int: if not isinstance(nums, list) or not all(isinstance(num, int) for num in nums): raise ValueError(\\"Input must be a list of integers\\") if len(nums) == 0: return 0 num_count = {} for num in nums: num_count[num] = num_count.get(num, 0) + 1 max_length = 0 for num in num_count: if num + 1 in num_count: current_length = num_count[num] + num_count[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"# Task: Implement Custom Median-Finding Algorithm Scenario You are required to implement a function that finds the median of an unsorted list of numbers. The median is the middle value of a dataset when it is ordered from least to greatest; if the dataset has an even number of observations, the median is the average of the two middle values. Your task focuses on optimizing performance and handling edge cases effectively. Core Requirements You need to implement the provided median-finding function (`find_median`) with the following features: 1. **Efficient Sorting**: Utilize an efficient sorting algorithm to handle the median-finding process. 2. **Edge Case Handling**: Ensure the function addresses edge cases such as an empty list, a list with one element, and lists with duplicate values. 3. **Performance Optimization**: Optimize your sorting and median-finding strategies to ensure the solution handles large lists efficiently. Function Specifications You need to implement the following function: - `find_median(data: List[float]) -> float` Input - `data` (List[float]): A list of floating-point numbers for which the median is to be calculated. Output - Returns a float value representing the median of the given list. Constraints - The function should handle lists with up to 10^5 elements efficiently. - Ensure correct and efficient handling of non-standard input such as an empty list and extremely large or small values. Performance Requirements - The code should aim to achieve a time complexity of (O(n log n)) where `n` is the number of elements in the list. - The space complexity should remain within (O(n)). Example ```python # example usage print(find_median([3, 1, 4, 2])) # Output: 2.5 print(find_median([7, 3, 1, 5, 9])) # Output: 5 print(find_median([1])) # Output: 1.0 print(find_median([])) # Output: None, handles edge cases as well ```","solution":"from typing import List, Optional def find_median(data: List[float]) -> Optional[float]: Find the median of an unsorted list of numbers. Args: data (List[float]): A list of floating-point numbers Returns: float: The median value or None if the list is empty if not data: return None data.sort() n = len(data) mid = n // 2 if n % 2 == 0: median = (data[mid - 1] + data[mid]) / 2 else: median = data[mid] return median"},{"question":"# Coding Question Context: You are developing a program for a library inventory system. The system should efficiently manage book records, allowing users to search for books based on their titles. To facilitate this, the system needs to support fuzzy searching, where users can type part of a book\'s title, and the system will return all books that include that substring in their titles. Prompt: Given a list of book titles and a search string, implement a function `fuzzy_search(books: List[str], search_str: str) -> List[str]` that returns a list of titles containing the search string (case insensitive). The results should be returned in the order they appear in the original list. Input: * A list of strings, `books`, where each string represents a book title. * A string, `search_str`, representing the search query. Output: * A list of strings containing book titles from the original list that include `search_str` (case insensitive). Constraints: * The list of books will have at most 10,000 book titles. * Each book title will be a non-empty string with a maximum length of 100 characters. * The search string will be a non-empty string with a maximum length of 50 characters. * Ensure the solution is optimized for performance. Example: ```python def fuzzy_search(books: List[str], search_str: str) -> List[str]: pass # Example usage: books = [ \\"Harry Potter and the Philosopher\'s Stone\\", \\"The Hobbit\\", \\"A Tale of Two Cities\\", \\"Harry Potter and the Chamber of Secrets\\", \\"The Catcher in the Rye\\" ] print(fuzzy_search(books, \\"harry\\")) # Output: [\\"Harry Potter and the Philosopher\'s Stone\\", \\"Harry Potter and the Chamber of Secrets\\"] print(fuzzy_search(books, \\"the\\")) # Output: [\\"The Hobbit\\", \\"A Tale of Two Cities\\", \\"The Catcher in the Rye\\"] ``` Performance: * Your solution should be able to handle the maximum constraints efficiently, ensuring the search is performed in a reasonable time frame.","solution":"from typing import List def fuzzy_search(books: List[str], search_str: str) -> List[str]: Returns a list of book titles containing the search string (case insensitive). search_str = search_str.lower() return [book for book in books if search_str in book.lower()]"},{"question":"# Sorting Unique Characters Context: You are tasked with writing a function that takes a string and returns a list of unique characters sorted in alphabetical order. The function should be case-insensitive and should include only alphabetic characters, discarding any other characters. Requirements: * Write a function `sorted_unique_chars(input_str: str) -> list` that returns a list of unique alphabetic characters in alphabetical order, regardless of the case. * The function should remove any non-alphabetic characters from the string. * Ensure that your function handles edge cases such as empty strings and strings without alphabetic characters gracefully, returning an empty list in such cases. Input: * A single string `input_str` representing the input string. Output: * A list of unique alphabetic characters from `input_str`, sorted in alphabetical order. Constraints: * The input string can have a length of up to `10^6` characters. Examples: ```python # Example 1 sorted_unique_chars(\\"Hello, World!\\") # Output: [\'d\', \'e\', \'h\', \'l\', \'o\', \'r\', \'w\'] # Example 2 sorted_unique_chars(\\"12345\\") # Output: [] # Example 3 sorted_unique_chars(\\"\\") # Output: [] # Example 4 sorted_unique_chars(\\"Zebra123Apple!!\\") # Output: [\'a\', \'b\', \'e\', \'l\', \'p\', \'r\', \'z\'] # Example 5 sorted_unique_chars(\\"PythonProgramming\\") # Output: [\'a\', \'g\', \'h\', \'i\', \'m\', \'n\', \'o\', \'p\', \'r\', \'t\', \'y\'] ``` Your function should be efficient in handling large strings while ensuring correctness in de-duplication and sorting.","solution":"def sorted_unique_chars(input_str: str) -> list: Returns a list of unique alphabetic characters in alphabetical order. The function is case-insensitive and only includes alphabetic characters. # Keep only alphabetic characters and convert to lowercase alphabets = [char.lower() for char in input_str if char.isalpha()] # Get unique characters and sort them return sorted(set(alphabets))"},{"question":"# Question **Median Finder** Design a Python class called `MedianFinder` that efficiently supports calculating the running median of a stream of integers. The class should use two heaps (min-heap and max-heap) to ensure the median can be found in logarithmic time after each insertion. **Methods** 1. `add_num(self, num: int) -> None:` Adds an integer number from the data stream to the data structure. 2. `find_median(self) -> float:` Returns the median of all elements so far. The median is the middle value in an ordered integer list. If the list contains an even number of elements, the median is the average of the two middle values. **Class Signature** ```python import heapq class MedianFinder: def __init__(self): ... def add_num(self, num: int) -> None: ... def find_median(self) -> float: ... ``` # Expected Input and Output Format * **Input**: * `num` (int): An integer number from the data stream. * **Output**: * `add_num` does not return anything. * `find_median` returns the median as a float. # Constraints * The data stream can have at most `10^5` numbers. * The numbers in the stream are in the range `[-10^5, 10^5]`. # Scenario/Context Imagine you are developing a financial application that records and analyzes real-time transaction amounts. Calculating the median of the transaction amounts at any given time helps in identifying the central tendency and detecting anomalies in the data. # Example **Example 1**: ```python >>> mf = MedianFinder() >>> mf.add_num(1) >>> mf.add_num(2) >>> mf.find_median() 1.5 # since the list is [1, 2], the median is (1 + 2) / 2 = 1.5 >>> mf.add_num(3) >>> mf.find_median() 2.0 # since the list is [1, 2, 3], the median is 2 ``` **Example 2**: ```python >>> mf = MedianFinder() >>> mf.add_num(-1) >>> mf.add_num(-2) >>> mf.add_num(-3) >>> mf.add_num(-4) >>> mf.add_num(-5) >>> mf.find_median() -3.0 # since the list is [-5, -4, -3, -2, -1], the median is -3 ``` # Performance Considerations * ensure efficient insertion and retrieval of the median value. * with a focus on logarithmic operations using heaps. Submit your implementation as the `MedianFinder` class.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. # Max-heap to store the smaller half of the numbers self.max_heap = [] # Min-heap to store the larger half of the numbers self.min_heap = [] def add_num(self, num: int) -> None: Adds a number into the data structure. # Negate the number for max-heap functionality (since Python has only min-heap) heapq.heappush(self.max_heap, -num) # Ensure the largest number in max_heap is less than or equal to the smallest in min_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Balance the sizes of the two heaps so that max_heap is always the same size or 1 element larger if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def find_median(self) -> float: Returns the median of current data stream. # If the number of elements is odd, the median is the top of the max_heap # If the number of elements is even, the median is the average of the tops of both heaps if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Pathfinding in a 2D Grid Imagine you are developing a simple pathfinding algorithm for a 2D game world. The game map is represented by a grid where each cell can either be walkable or blocked. Your task is to determine the shortest path from a starting position to a target position, moving only horizontally or vertically. # Requirements * Implement the function `shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int` * **Input**: - `grid`: A 2D list of integers where `0` represents a walkable cell and `1` represents an obstacle. - `start`: A tuple `(x, y)` representing the starting coordinates. - `end`: A tuple `(x, y)` representing the target coordinates. * **Output**: - An integer representing the length of the shortest path from the start to the end. If no such path exists, return `-1`. # Constraints 1. The grid dimensions will be at most 500x500. 2. You can only move horizontally or vertically, not diagonally. 3. Both `start` and `end` will always be in walkable cells. 4. The input positions `(x, y)` are 0-indexed. # Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) ``` Output: `8` (The path is: right, right, down, down, down, right, down, right) # Performance Requirement The algorithm should be efficient, ideally using BFS (Breadth First Search), as it ensures the shortest path in an unweighted grid. The solution should handle grids up to the maximum size within a reasonable time frame. # Implementation Guide 1. **Check Base Cases**: If the start or end points are outside the grid boundaries or if start equals end, handle accordingly. 2. **Initialize BFS**: Use a queue to facilitate level-order traversal. 3. **Track Visited Cells**: Maintain a 2D list to mark cells that have already been explored. 4. **Expand Nodes**: For each cell, attempt to move in the four possible directions. 5. **Terminate Early**: If the end cell is reached, return the path length immediately. Your task is to successfully implement the function according to these guidelines and constraints. Good luck!","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: rows, cols = len(grid), len(grid[0]) if start == end: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1])) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: if (nx, ny) == end: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Sum of Squares of Even Digits **Overview**: Given an integer, we need to find the sum of the squares of its even digits. The function should convert the integer to its individual digits, filter out the even digits, square them, and then sum those squares. **Task**: Write a function `sum_of_squares_of_even_digits(num: int) -> int` that returns the sum of the squares of the even digits in the given integer. Your function should: 1. Validate the input to ensure `num` is an integer. 2. Extract the even digits from the integer. 3. Square each of these even digits and calculate their sum. 4. Return the result as an integer. **Function Signature**: ```python def sum_of_squares_of_even_digits(num: int) -> int: ``` **Input**: - `num` (integer): The integer to extract and square even digits from. **Output**: - Integer: The sum of the squares of the even digits. **Example**: ```python >>> sum_of_squares_of_even_digits(123456) 56 >>> sum_of_squares_of_even_digits(2468) 120 ``` **Constraints**: - The integer can be positive, negative, or zero. - Only consider the absolute value of the digits for squaring. **Requirements**: 1. Your function should include proper validation to ensure the input is an integer. 2. The solution should be efficient and handle cases where the input number has multiple digits. **Hints**: - Use the modulus operator to extract individual digits. - Check if the digit is even before performing the squaring operation. - Consider using a loop to accumulate the sum of squares of even digits. **Scenario/Context**: Imagine you are developing an analytical tool that processes numbers and extracts insights based on their digit properties. One feature is to calculate the sum of squares of even digits in a given number. Your task is to implement this feature.","solution":"def sum_of_squares_of_even_digits(num: int) -> int: Returns the sum of the squares of the even digits in the given integer. Parameters: num (int): The integer to extract and square even digits from. Returns: int: The sum of the squares of the even digits. if not isinstance(num, int): raise ValueError(\\"Input must be an integer\\") sum_square_evens = 0 for digit in str(abs(num)): digit = int(digit) if digit % 2 == 0: sum_square_evens += digit ** 2 return sum_square_evens"},{"question":"# Problem Statement You are tasked with implementing a simplified file compression algorithm that leverages Run-Length Encoding (RLE) for text files. This algorithm will compress and decompress a string by encoding sequences of repeating characters. # Requirements: 1. **Function to Compress Text**: - Name: `compress_text` - Input: A non-empty string `text`. - Output: A string where each sequence of repeating characters in the input is replaced by a single character followed by the number of repetitions. - Constraints: - Handle any printable ASCII characters. - Sequence with only one character should not be followed by a number. - Raise appropriate exceptions for invalid inputs. 2. **Function to Decompress Text**: - Name: `decompress_text` - Input: A string in the RLE compressed format. - Output: The original uncompressed string. - Constraints: - Ensure that the decompression accurately reconstructs the original text. - Handle edge cases for invalid RLE strings, such as invalid formats or nonexistent sequences. - Raise appropriate exceptions for invalid inputs. # Example: ```python def compress_text(text: str) -> str: # Your implementation here pass def decompress_text(compressed_text: str) -> str: # Your implementation here pass # Example Usage: compressed = compress_text(\\"aaabbc\\") print(compressed) # Output: \\"a3b2c\\" original = decompress_text(\\"a3b2c\\") print(original) # Output: \\"aaabbc\\" ``` # Notes: - Ensure the algorithm efficiently handles large strings. - Include comprehensive tests to validate your solution against various cases, including edge cases and invalid inputs. - Optimize for both time and space complexity appropriately for real-world file sizes. # Instructions: - Implement both functions ensuring correctness and optimal performance. - Write robust error handling to manage and raise exceptions for edge cases and invalid inputs. - Validate your solution with comprehensive tests covering normal cases, edge cases, and improper inputs.","solution":"def compress_text(text: str) -> str: if not text or not isinstance(text, str): raise ValueError(\\"Invalid input: text must be a non-empty string\\") compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(text[i-1] + (str(count) if count > 1 else \'\')) count = 1 compressed.append(text[-1] + (str(count) if count > 1 else \'\')) return \'\'.join(compressed) def decompress_text(compressed_text: str) -> str: if not compressed_text or not isinstance(compressed_text, str): raise ValueError(\\"Invalid input: compressed_text must be a non-empty string\\") decompressed = [] i = 0 while i < len(compressed_text): char = compressed_text[i] i += 1 count = 0 while i < len(compressed_text) and compressed_text[i].isdigit(): count = count * 10 + int(compressed_text[i]) i += 1 decompressed.append(char * (count if count != 0 else 1)) return \'\'.join(decompressed)"},{"question":"# Linked List Cycle Detection **Scenario**: Imagine you are developing a software that processes large data streams. Sometimes, these data streams can create loops due to recursive data linking. To prevent infinite looping during data processing, you need to create a utility that detects such cycles in the data structure. **Task**: Write a function `has_cycle` that determines whether a given singly linked list has a cycle. Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Detect if a cycle exists in a given singly linked list. Parameters ---------- head: ListNode The head node of the singly linked list. Returns ------- bool True if the list contains a cycle, False otherwise. ``` Input - `head`: The head node of a singly linked list. Output - Return `True` if there is a cycle in the list, `False` otherwise. Constraints - The linked list may have up to 10^5 nodes. - Each node\'s value should be an integer. - The function should handle cases where the list is empty. - Aim for a solution with constant space complexity. Example ```python # Examples: node1 = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Creates a cycle assert has_cycle(node1) == True node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = node1 # Creates a cycle assert has_cycle(node1) == True node1 = ListNode(1) assert has_cycle(node1) == False node1 = None assert has_cycle(node1) == False ``` **Note**: Your implementation should use Floyd’s Cycle-Finding Algorithm (Tortoise and Hare algorithm) to achieve the desired time complexity and space efficiency.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Detect if a cycle exists in a given singly linked list. Parameters ---------- head: ListNode The head node of the singly linked list. Returns ------- bool True if the list contains a cycle, False otherwise. if not head or not head.next: return False slow = head fast = head.next while fast is not None and fast.next is not None: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"# Coding Assessment Question Scenario You are a developer at a company that manages an online auction platform. You need to implement a feature to track the highest bid among various auction items. Each bid submission contains the item ID and the bid amount. The system should be able to retrieve the highest bid for any given item ID. Objective Implement a class `AuctionTracker` with methods to submit bids and retrieve the highest bid for any given item. Description Your task is to create a class named `AuctionTracker` that manages bid submissions and can retrieve the highest bid for any item. The class should include the following methods: 1. `submit_bid(item_id: str, bid_amount: float) -> None`: Submit a bid for an item. 2. `highest_bid(item_id: str) -> float`: Retrieve the highest bid for a given item. If no bids are present for the item, return `0.0`. # Requirements * The method `submit_bid` accepts an item ID (as a string) and a bid amount (as a float). * The method `highest_bid` accepts an item ID and returns the highest bid amount (as a float) for that item ID. * If no bids are submitted for an item, the `highest_bid` method should return `0.0`. # Input and Output * **Input for submit_bid**: * `item_id` (str): The ID of the auction item. * `bid_amount` (float): The bid amount for the auction item. * **Output for submit_bid**: * `None`. * **Input for highest_bid**: * `item_id` (str): The ID of the auction item. * **Output for highest_bid**: * `float`: The highest bid amount for the given item ID. # Example ```python tracker = AuctionTracker() tracker.submit_bid(\\"item1\\", 100.0) tracker.submit_bid(\\"item1\\", 200.0) tracker.submit_bid(\\"item2\\", 150.0) print(tracker.highest_bid(\\"item1\\")) # Output: 200.0 print(tracker.highest_bid(\\"item2\\")) # Output: 150.0 print(tracker.highest_bid(\\"item3\\")) # Output: 0.0 ``` # Implementation Details Implement the `AuctionTracker` class according to the given specifications. ```python class AuctionTracker: def __init__(self): self.bids = {} def submit_bid(self, item_id: str, bid_amount: float) -> None: if item_id not in self.bids: self.bids[item_id] = bid_amount else: self.bids[item_id] = max(self.bids[item_id], bid_amount) def highest_bid(self, item_id: str) -> float: return self.bids.get(item_id, 0.0) # Test the implementation with the given example tracker = AuctionTracker() tracker.submit_bid(\\"item1\\", 100.0) tracker.submit_bid(\\"item1\\", 200.0) tracker.submit_bid(\\"item2\\", 150.0) print(tracker.highest_bid(\\"item1\\")) # Output: 200.0 print(tracker.highest_bid(\\"item2\\")) # Output: 150.0 print(tracker.highest_bid(\\"item3\\")) # Output: 0.0 ```","solution":"class AuctionTracker: def __init__(self): self.bids = {} def submit_bid(self, item_id: str, bid_amount: float) -> None: if item_id not in self.bids: self.bids[item_id] = bid_amount else: self.bids[item_id] = max(self.bids[item_id], bid_amount) def highest_bid(self, item_id: str) -> float: return self.bids.get(item_id, 0.0)"},{"question":"# Coding Question: Build an Autocomplete System Using Trie **Scenario**: You are designing an autocomplete feature for a text editor similar to the one found in modern IDEs and text messaging applications. The system should suggest words based on the prefix, providing real-time recommendations as users type. This is particularly useful for improving typing speed and accuracy. **Given**: You need to implement a `Trie` data structure to store a dictionary of words and their corresponding frequencies. Use this trie to provide autocomplete suggestions efficiently. **Instructions**: 1. Implement the `AutocompleteSystem` class with the following methods: - `__init__(self, words: List[str])`: Initializes the trie with a list of words. - `addWord(self, word: str) -> None`: Adds a new word to the trie with default frequency of 0. - `registerWord(self, word: str) -> None`: Increases the frequency of the word each time it is selected. - `getSuggestions(self, prefix: str) -> List[str]`: Returns a list of up to 5 words with the highest frequency that start with the given prefix, sorted by frequency and lexicographic order if frequencies are the same. **Constraints**: - Words in the dictionary will have length between 1 and 100. - The total number of words will not exceed 10^4. - The system should provide suggestions in real-time as the user types. **Example**: ```python ac = AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\"]) ac.registerWord(\\"apple\\") ac.registerWord(\\"app\\") ac.registerWord(\\"apricot\\") ac.registerWord(\\"apple\\") print(ac.getSuggestions(\\"ap\\")) # Output: [\\"apple\\", \\"apricot\\", \\"app\\"] print(ac.getSuggestions(\\"ban\\")) # Output: [\\"banana\\"] ``` **Required Classes and Methods** (Interface): ```python class AutocompleteSystem: def __init__(self, words: List[str]): # Initialize the trie with the given list of words. def addWord(self, word: str) -> None: # Add a new word to the trie. def registerWord(self, word: str) -> None: # Register a word increase its frequency. def getSuggestions(self, prefix: str) -> List[str]: # Return top 5 suggestions for the given prefix. ``` Ensure that your implementation efficiently maintains and retrieves the words with the highest frequency in response to prefix queries leveraging the properties of the Trie.","solution":"class TrieNode: def __init__(self): self.children = {} self.word_count = 0 class AutocompleteSystem: def __init__(self, words): self.root = TrieNode() self.word_frequency = {} for word in words: self.addWord(word) def addWord(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_count += 1 self.word_frequency[word] = 0 def registerWord(self, word): if word in self.word_frequency: self.word_frequency[word] += 1 def collect_words(self, node, prefix): words = [] if node.word_count > 0: words.append((prefix, self.word_frequency[prefix])) for char, child in node.children.items(): words.extend(self.collect_words(child, prefix + char)) return words def getSuggestions(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] words_with_freq = self.collect_words(node, prefix) words_with_freq.sort(key=lambda x: (-x[1], x[0])) return [word for word, freq in words_with_freq[:5]]"},{"question":"# Scenario You are working with a warehouse management system where you need to keep track of the movement of items in and out of the warehouse. To optimize the tracking, you need to implement a system that can efficiently handle insertion, deletion, and summing up quantities of items within a certain range of positions in the item list. # Problem Statement Your task is to implement two functions: 1. `update_item_list(item_list: list[int], position: int, new_value: int) -> None`: This function should take the current list of items and update the quantity at the specified position. 2. `sum_range(item_list: list[int], left_bound: int, right_bound: int) -> int`: This function should return the sum of quantities within the specified sub-range. # Input and Output Formats **Function 1: `update_item_list`** - **Input**: - `item_list` (list of integers): A list of item quantities. - `position` (integer): The index in the list where the update needs to be made. - `new_value` (integer): The new quantity value to be set at the specified position. - **Output**: - This function does not return anything; it updates the input list in-place. **Function 2: `sum_range`** - **Input**: - `item_list` (list of integers): The list of item quantities. - `left_bound` (integer): The starting index of the sub-range. - `right_bound` (integer): The ending index of the sub-range. - **Output**: - An integer representing the sum of quantities within the specified range. # Constraints - The number of elements in the list, ( n ), is such that ( 1 leq n leq 10^5 ). - The quantities of items can be any integers within the range of what can be represented by 32-bit signed integers. - ( 0 leq text{left_bound} leq text{right_bound} < n ). # Performance Requirements - The function `update_item_list` should have a time complexity of ( O(1) ). - The function `sum_range` should have a time complexity of ( O(log n) ) if a segment tree or Fenwick tree is used for optimization. # Example ```python item_list = [5, 2, 9, 4, 7, 6] update_item_list(item_list, 2, 8) # item_list becomes [5, 2, 8, 4, 7, 6] sum_range(item_list, 1, 4) # should return 21 ``` # Explanation For the initial list `[5, 2, 9, 4, 7, 6]`, after updating the quantity at index 2 to 8, the list becomes `[5, 2, 8, 4, 7, 6]`. When asked for the sum of quantities between indices 1 and 4, the algorithm efficiently computes the sum as 2 + 8 + 4 + 7, which equals 21.","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_query(self, left, right): return self.query(right) - self.query(left - 1) def update_item_list(item_list, position, new_value): position += 1 # Fenwick Tree is 1-based indexing delta = new_value - item_list[position - 1] item_list[position - 1] = new_value fenwick_tree.update(position, delta) def sum_range(item_list, left_bound, right_bound): left_bound += 1 # Fenwick Tree is 1-based indexing right_bound += 1 # Fenwick Tree is 1-based indexing return fenwick_tree.range_query(left_bound, right_bound) # Global Fenwick Tree fenwick_tree = None def init_item_list(item_list): global fenwick_tree fenwick_tree = FenwickTree(len(item_list)) for i, val in enumerate(item_list): fenwick_tree.update(i + 1, val)"},{"question":"# Coding Assessment Question: Binary Search Tree - Depth and Balance Check You are given a Binary Search Tree (BST) and asked to implement a function to determine the current state of the tree with respect to its depth and balance. Specifically, you\'ll implement a method to calculate the depth of the tree and check if the tree is balanced. A tree is considered balanced if for any node, the height difference between its left and right subtrees is at most 1. # Task Write methods in the `BinarySearchTree` class to calculate the depth of the BST and determine if it is balanced. # Details * **Input**: The input is already included as an instance of the `BinarySearchTree` class, which contains nodes of the `TreeNode` class. * **Output**: The output should be the depth of the tree and a boolean indicating whether the tree is balanced. * **Constraints**: - The BST will contain at least one node. # Example **Input**: ```python tree = BinarySearchTree() tree.insert(10) tree.insert(5) tree.insert(20) tree.insert(3) tree.insert(7) tree.insert(15) tree.insert(30) ``` **Output**: Call to the new methods should output: ```plaintext Depth of the tree: 3 Is the tree balanced? False ``` # Implementation Requirements 1. Introduce a new method `calculate_depth` in the `BinarySearchTree` class to calculate the depth of the tree. 2. Introduce another method `is_balanced` to determine if the tree is balanced. # Implementation Example ```python class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def calculate_depth(self): # Implement this method to return the depth of the tree pass def is_balanced(self): # Implement this method to return whether the tree is balanced pass ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def calculate_depth(self): return self._calculate_depth(self.root) def _calculate_depth(self, node): if node is None: return 0 left_depth = self._calculate_depth(node.left) right_depth = self._calculate_depth(node.right) return max(left_depth, right_depth) + 1 def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if node is None: return True left_depth = self._calculate_depth(node.left) right_depth = self._calculate_depth(node.right) if abs(left_depth - right_depth) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right)"},{"question":"# Problem Description: URL Directory Structure Formatter You are tasked with implementing a function that reformats a list of URLs by consolidating them into a hierarchical directory structure. The URLs will represent web pages or directories, and your function should produce a human-readable directory tree as plain text. # Requirements 1. **Function Implementation**: Write a function `format_urls_to_tree(urls)` that formats a list of URLs into a directory structure. 2. The function should: * Parse the URLs into components based on slashes (\\"/\\"). * Construct a nested dictionary representing the directory tree. * Convert this dictionary into a human-readable string format showing the hierarchical structure. * Maintain an alphabetical order of elements at each level of the tree. 3. Ensure your solution can handle: * Multiple URLs with shared and unique paths. * URLs with different lengths. * Edge cases where the list of URLs may be empty. 4. **Input/Output**: * `urls`: A list of string URLs. * Returns a single string representing the directory structure. # Constraints * The number of URLs will not exceed 10,000. * Each URL will not exceed 2,000 characters. * URLs will contain only ASCII characters and follow the standard URL format. # Example ```python def format_urls_to_tree(urls): # Your code goes here pass # Example usage urls = [ \\"http://example.com/dir1/page1\\", \\"http://example.com/dir1/page2\\", \\"http://example.com/dir2/page1\\", \\"http://example.com/dir2/dir3/page1\\" ] formatted_tree = format_urls_to_tree(urls) print(formatted_tree) ``` Output ``` example.com |-- dir1 | |-- page1 | |-- page2 |-- dir2 |-- dir3 |-- page1 |-- page1 ``` Implement the function to correctly output the formatted directory structure as indicated in the example. Use helper functions or classes as necessary to ensure clarity and maintainability.","solution":"def format_urls_to_tree(urls): from collections import defaultdict import json def build_tree(): return defaultdict(build_tree) def insert_path(tree, parts): for part in parts: tree = tree[part] def tree_to_str(tree, indent=\'\'): result = [] for key in sorted(tree.keys()): result.append(f\\"{indent}{key}\\") result.extend(tree_to_str(tree[key], indent + \' \')) return result if not urls: return \\"\\" # Strip protocol and split paths parts_list = [url.split(\'//\')[1].split(\'/\') for url in urls] # Build tree tree = build_tree() for parts in parts_list: insert_path(tree, parts) # Convert tree to string return \'n\'.join(tree_to_str(tree)) # Usage example (for manual testing) urls = [ \\"http://example.com/dir1/page1\\", \\"http://example.com/dir1/page2\\", \\"http://example.com/dir2/page1\\", \\"http://example.com/dir2/dir3/page1\\" ] formatted_tree = format_urls_to_tree(urls) print(formatted_tree)"},{"question":"# Reordering Students\' List You have been tasked with reordering a list of students based on their grades while maintaining alphabetical order within the same grade. Implement a function that accomplishes this task. Function Signature ```python def reorder_students(students: List[Tuple[str, int]]) -> List[str]: Reorders a list of students based on their grades and returns the list of student names. Students with equal grades should be ordered alphabetically by their names. Parameters: students (List[Tuple[str, int]]): A list of tuples where each tuple consists of a student\'s name and their grade. Returns: List[str]: A list of student names ordered first by grades in descending order, and alphabetically within each grade if they are the same. ``` Input - `students`: A list of tuples, where each tuple consists of a string (student\'s name) and an integer (student\'s grade). - Each student\'s name is a non-empty string containing only alphabetic characters. - Each student\'s grade is an integer (0 <= grade <= 100). Output - Returns a sorted list of student names. Constraints - The function should handle a list of up to 10^4 students efficiently. - The students should be ordered primarily by descending grades. - Within the same grade, students should be ordered alphabetically by name. Examples ```python >>> reorder_students([(\\"Alice\\", 90), (\\"Bob\\", 80), (\\"Charlie\\", 90), (\\"Dave\\", 85)]) [\'Alice\', \'Charlie\', \'Dave\', \'Bob\'] >>> reorder_students([(\\"Eve\\", 75), (\\"Frank\\", 60), (\\"Grace\\", 75), (\\"Heidi\\", 65)]) [\'Eve\', \'Grace\', \'Heidi\', \'Frank\'] >>> reorder_students([(\\"Ivy\\", 100), (\\"Judy\\", 100), (\\"Mallory\\", 95), (\\"Oscar\\", 70)]) [\'Ivy\', \'Judy\', \'Mallory\', \'Oscar\'] >>> reorder_students([(\\"Peggy\\", 85), (\\"Trent\\", 80), (\\"Victor\\", 85), (\\"Walter\\", 80)]) [\'Peggy\', \'Victor\', \'Trent\', \'Walter\'] ```","solution":"from typing import List, Tuple def reorder_students(students: List[Tuple[str, int]]) -> List[str]: Reorders a list of students based on their grades and returns the list of student names. Students with equal grades should be ordered alphabetically by their names. Parameters: students (List[Tuple[str, int]]): A list of tuples where each tuple consists of a student\'s name and their grade. Returns: List[str]: A list of student names ordered first by grades in descending order, and alphabetically within each grade if they are the same. # Sort the students primarily by grade in descending order, and secondarily by name in ascending order sorted_students = sorted(students, key=lambda x: (-x[1], x[0])) # Extract just the names from the sorted list return [student[0] for student in sorted_students]"},{"question":"# Identifying Unique Words in a Set of Documents In this task, you are asked to implement a function which identifies the number of unique words in a given set of documents, ignoring case and punctuation. # Problem Statement Implement a function `unique_words_count` that takes a list of strings representing documents and returns the number of unique words across all documents, case-insensitively and ignoring punctuation. # Function Signature ```python def unique_words_count(documents: list) -> int: pass ``` # Input * documents: `list of str` - A list of documents containing text. Each document is a string. # Output * `int`: The number of unique words across all documents. # Example ```python >>> documents = [ ... \\"Hello, world! This is a test.\\", ... \\"Test the function with different sets of documents!\\", ... \\"Hello again, testing punctuation removal.\\" ... ] >>> unique_words_count(documents) 17 >>> documents = [ ... \\"Count, unique; words, in? multiple.document\'s:with punctuation\\" ... \\"Unique words\' counting MUST ignore casing and punctuation.\\" ... ] >>> unique_words_count(documents) 14 ``` # Constraints * Each document length is between 1 and (10^3) characters. * The total number of documents is between 1 and (10^3). # Explanation In the first example, the function identifies \\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"the\\", \\"function\\", \\"with\\", \\"different\\", \\"sets\\", \\"of\\", \\"documents\\", \\"again\\", \\"testing\\", \\"punctuation\\", \\"removal\\" as unique words. Note the case insensitivity and punctuation removal. In the second example, all words are considered in lower case and without punctuation, so the unique words are: \\"count\\", \\"unique\\", \\"words\\", \\"in\\", \\"multiple\\", \\"document\\", \\"with\\", \\"punctuation\\", \\"counting\\", \\"must\\", \\"ignore\\", \\"casing\\", \\"and\\", \\"punctuation\\". # Notes - You may use regular expressions or other text processing methods to remove punctuation. - Ensure to convert all words to lower case before counting the unique words. - Handle edge cases such as empty documents and documents with only punctuation gracefully.","solution":"import re def unique_words_count(documents: list) -> int: Returns the number of unique words across all documents, case-insensitively and ignoring punctuation. unique_words = set() word_pattern = re.compile(r\'bw+b\') for document in documents: words = word_pattern.findall(document.lower()) unique_words.update(words) return len(unique_words)"},{"question":"# Coding Assessment Question Scenario & Context You are a software engineer tasked with developing a feature-rich library management system. One of the functionalities you need to implement involves managing the borrowing and returning of books while keeping track of overdue payments based on the borrowing duration and the library\'s overdue fee policy. Problem Statement Implement two functions `borrow_book` and `calculate_overdue_payment` to manage the book borrowing system of the library. 1. **borrow_book**: This function should borrow a book given the book’s ID, the member’s ID, and the borrowing period. It should ensure the book is available before borrowing. 2. **calculate_overdue_payment**: This function should calculate the overdue payment for a book based on the actual return date versus the due date and a fixed daily overdue fee. Function Specifications 1. **borrow_book** function: - **Input**: - `library_books` (dict): A dictionary of books with book IDs as keys and an availability status (boolean) as values. - `book_id` (int): The ID of the book to be borrowed. - `member_id` (int): The ID of the member borrowing the book. - `borrow_days` (int): The number of days the book is borrowed for. - **Output**: - (string): A message indicating whether the borrowing was successful or if the book is currently unavailable. - **Constraints**: - `library_books` must contain available books. - `book_id` must be an integer. - `member_id` must be an integer. - `borrow_days` must be a positive integer. - **Error Handling**: - Raise an error if the book ID is not in the library books. - Raise an error if borrow days is not a positive integer. 2. **calculate_overdue_payment** function: - **Input**: - `borrow_date` (string): The date the book was borrowed in \\"YYYY-MM-DD\\" format. - `return_date` (string): The date the book was returned in \\"YYYY-MM-DD\\" format. - `due_date` (string): The due date for returning the book in \\"YYYY-MM-DD\\" format. - `daily_overdue_fee` (float): The daily overdue fee in dollars. - **Output**: - (float): The total overdue payment amount in dollars. - **Constraints**: - Dates must be provided in \\"YYYY-MM-DD\\" format. - `daily_overdue_fee` must be a positive float. - **Error Handling**: - Raise an error if the dates are not in the specified format. - Raise an error if the overdue fee is not positive. # Example ```python # Example 1 library_books = {101: True, 102: False, 103: True} borrow_book(library_books, 101, 1, 14) # Output: \\"Book 101 successfully borrowed by member 1 for 14 days.\\" # Example 2 calculate_overdue_payment(\\"2023-01-01\\", \\"2023-01-20\\", \\"2023-01-15\\", 1.50) # Output: 7.50 ``` Note * Ensure to import the required datetime classes and functions. * Ensure to raise appropriate errors where necessary.","solution":"from datetime import datetime def borrow_book(library_books, book_id, member_id, borrow_days): Borrows a book given the book ID, member ID, and borrowing period. Parameters: library_books (dict): Dictionary of book IDs and their availability status. book_id (int): ID of the book to be borrowed. member_id (int): ID of the member borrowing the book. borrow_days (int): Number of days the book is borrowed for. Returns: string: Message indicating the result of the borrow action. # Input validation if book_id not in library_books: raise ValueError(\\"Book ID not found in the library.\\") if not isinstance(borrow_days, int) or borrow_days <= 0: raise ValueError(\\"Borrow days must be a positive integer.\\") if library_books[book_id]: library_books[book_id] = False return f\\"Book {book_id} successfully borrowed by member {member_id} for {borrow_days} days.\\" else: return f\\"Book {book_id} is currently unavailable.\\" def calculate_overdue_payment(borrow_date, return_date, due_date, daily_overdue_fee): Calculates the overdue payment for a borrowed book. Parameters: borrow_date (string): Date when the book was borrowed (\\"YYYY-MM-DD\\"). return_date (string): Date when the book was returned (\\"YYYY-MM-DD\\"). due_date (string): Due date for returning the book (\\"YYYY-MM-DD\\"). daily_overdue_fee (float): Daily overdue fee in dollars. Returns: float: Total overdue payment amount in dollars. # Input validation try: borrow_dt = datetime.strptime(borrow_date, \\"%Y-%m-%d\\") return_dt = datetime.strptime(return_date, \\"%Y-%m-%d\\") due_dt = datetime.strptime(due_date, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Dates must be in \'YYYY-MM-DD\' format.\\") if not isinstance(daily_overdue_fee, (int, float)) or daily_overdue_fee <= 0: raise ValueError(\\"Daily overdue fee must be a positive number.\\") # Calculate overdue days overdue_days = (return_dt - due_dt).days if overdue_days > 0: return overdue_days * daily_overdue_fee return 0.0"},{"question":"# Problem Statement: Write a program that checks the validity of a given password based on specific criteria. Develop a function `is_valid_password` that takes a password as input and returns a boolean value indicating whether it meets the following security requirements: 1. The password length must be at least 8 characters. 2. It must contain at least one uppercase letter (A-Z). 3. It must contain at least one lowercase letter (a-z). 4. It must include at least one digit (0-9). 5. It must contain at least one special character from the set: !@#%^&*()_+-=[]{}|;\':\\",./<>? **Function Signature**: ```python def is_valid_password(password: str) -> bool: pass ``` # Requirements: * Implement the `is_valid_password` function. * Validate the length of the password. * Check for the presence of at least one uppercase letter, one lowercase letter, one digit, and one special character. * The function should return `True` if the password meets all the criteria; otherwise, it should return `False`. # Example Usage: ```python >>> is_valid_password(\\"P@ssw0rd!\\") True >>> is_valid_password(\\"password\\") False >>> is_valid_password(\\"P@ssw0rd123\\") True >>> is_valid_password(\\"P@ss\\") False ``` # Constraints: * The password will be a non-empty string. * Focus on clarity and efficiency of the solution. * Consider edge cases such as passwords that are just under or over the required length.","solution":"import re def is_valid_password(password: str) -> bool: Check if the given password meets the security requirements: 1. At least 8 characters long 2. Contains at least one uppercase letter (A-Z) 3. Contains at least one lowercase letter (a-z) 4. Contains at least one digit (0-9) 5. Contains at least one special character from the set: !@#%^&*()_+-=[]{}|;\':\\",./<>? if len(password) < 8: return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'d\', password): return False if not re.search(r\'[!@#%^&*()_+-=[]{}|;\'\\":,./<>?]\', password): return False return True"},{"question":"# Coding Assessment: Develop a Custom Dijkstra’s Algorithm for Navigation System Scenario You are working for an emerging tech company specializing in geographic information systems (GIS). Your team is tasked with creating a navigation system that finds the shortest path between two locations in an urban environment. The system will need to handle typical weighted graphs where nodes represent intersections and edges represent roads with associated travel times. Problem Statement Implement a custom version of Dijkstra’s algorithm to find the shortest path in a weighted, directed graph. Your implementation should efficiently calculate the shortest path from a given start node to a target node, while ensuring it scales for large urban networks and appropriately handles edge cases such as disconnected nodes or negative weights (which should not be allowed). Requirements 1. **Function Signature**: Specify a function `dijkstra_algorithm(graph: dict, start: str, end: str) -> tuple[list[str], int]`. 2. **Input Format**: - `graph`: A dictionary representing a weighted graph. Keys are node names (strings), and values are dictionaries where the key is a connected node (string) and the value is the travel time (positive integer). - `start`: A string representing the starting node. - `end`: A string representing the target node. 3. **Output Format**: - Return a tuple. The first element is a list of nodes (strings) representing the path from the start node to the end node (inclusive). The second element is an integer representing the total travel time along this path. - If no path exists, return ([], 0). 4. **Constraints**: - The graph should handle up to 10,000 intersections (nodes) and 50,000 roads (edges). - Travel times are positive integers. - Ensure the algorithm does not consider negative weights. 5. **Performance Requirements**: - Aim for efficiency in both time and space complexity. - Ensure the algorithm processes within a reasonable timeframe for large graphs. Example ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start = \'A\' end = \'D\' assert dijkstra_algorithm(graph, start, end) == ([\'A\', \'B\', \'C\', \'D\'], 4) ``` Notes 1. Implement the function `dijkstra_algorithm`. 2. Utilize appropriate data structures (e.g., priority queue) to optimize performance. 3. Ensure the function correctly handles scenarios with multiple paths and disconnected nodes while maintaining robustness and error handling. --- By following the guidelines for question creation, this new question is designed to be on par with the original question regarding style, complexity, length, and topic alignment. The added question entails implementing a well-known algorithm but introduces a distinct application domain (navigation systems) that complements the data mining focus of the original question.","solution":"import heapq def dijkstra_algorithm(graph, start, end): Implements Dijkstra\'s algorithm to find the shortest path in a weighted graph. :param graph: A dictionary representing a weighted graph. :param start: A string representing the starting node. :param end: A string representing the target node. :return: A tuple containing a list of nodes representing the shortest path and the total travel time. # Min-heap priority queue pq = [(0, start, [])] visited = set() while pq: (cost, node, path) = heapq.heappop(pq) if node in visited: continue visited.add(node) path = path + [node] if node == end: return (path, cost) for neighbor, weight in graph.get(node, {}).items(): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return ([], 0)"},{"question":"# Rainwater Trapping Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The elevation map is stored in a list where the height of each bar is given as an integer. **Task**: Implement a function to calculate the total amount of rainwater trapped. Function Signature ```python def trap_rainwater(height: list[int]) -> int: pass ``` Implementation Requirements: 1. Create a helper function `find_trapped_water` that uses a two-pointer technique to compute the trapped water. 2. Use this helper function to calculate and return the total amount of trapped rainwater. Input - A list of non-negative integers representing the elevation map. Output - An integer representing the total amount of trapped rainwater. Example ```python >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 ``` Constraints - `0 ≤ n ≤ 3 * 10^4` - `0 ≤ height[i] ≤ 10^5` Note - Make sure your solution handles edge cases such as very small arrays or arrays with no trapped water efficiently. - Optimize for both time and space complexity to ensure the function runs within acceptable bounds for large inputs. Scenario Imagine designing a landscape model in a virtual environment where terrain elevation is specified by discrete bars. To simulate realistic rainwater pooling, you need to calculate how much rainwater would accumulate on the uneven terrain. This task will validate your understanding of efficient algorithms and data structures for spatial computations.","solution":"def trap_rainwater(height): Given a list of non-negative integers representing an elevation map, compute the total amount of rainwater trapped. if not height or len(height) < 3: return 0 def find_trapped_water(height): left, right = 0, len(height) - 1 left_max, right_max = 0, 0 trapped_water = 0 while left < right: if height[left] < height[right]: if height[left] >= left_max: left_max = height[left] else: trapped_water += left_max - height[left] left += 1 else: if height[right] >= right_max: right_max = height[right] else: trapped_water += right_max - height[right] right -= 1 return trapped_water return find_trapped_water(height)"},{"question":"# Identifying Duplicate Emails in a Database Problem Statement You are asked to write a function that identifies all the duplicate email addresses in a given list. A duplicate email is defined as an email that appears more than once in the list, regardless of case (i.e., email addresses should be considered duplicates if they are the same when case is ignored). # Function Definitions 1. `find_duplicates(emails: list[str]) -> list[str]` - Identifies duplicate emails in the provided list. - **Input**: A list of strings `emails`, where each string represents an email address. - **Output**: A list of strings where each string is an email address that appears more than once in the input list. # Constraints - The list `emails` will have at most 10^4 email addresses. - Each email in the list is a valid email address. - The emails may contain both uppercase and lowercase characters. Treat emails as case-insensitive. # Example ```python find_duplicates([\'test.email@example.com\', \'Test.Email@example.com\', \'user@example.com\', \'user2@example.com\', \'USER@example.com\']) # Expected output: [\'test.email@example.com\', \'user@example.com\'] find_duplicates([\'john.doe@domain.com\', \'Jane.Doe@domain.com\', \'john.doe@domain.com\', \'jane.doe@domain.com\']) # Expected output: [\'john.doe@domain.com\', \'jane.doe@domain.com\'] find_duplicates([\'unique@address.com\', \'another@address.com\']) # Expected output: [] ``` # Notes - The order in the output list of duplicates does not matter, as long as it contains all duplicates. - Consider edge cases such as an empty list or a list with all unique emails.","solution":"def find_duplicates(emails): Identifies duplicate emails in the provided list, case-insensitive. :param emails: A list of email addresses. :return: A list of duplicate email addresses. email_count = {} for email in emails: normalized_email = email.lower() if normalized_email in email_count: email_count[normalized_email] += 1 else: email_count[normalized_email] = 1 duplicates = [email for email, count in email_count.items() if count > 1] return duplicates"},{"question":"# Find Missing Number in Sequence **Problem Statement**: You are given an array `arr` containing `n` distinct integers in the range `[0, n]`. This means that exactly one number in this range is missing. Write a function to find the missing number. **Function Signature**: ```python def find_missing_number(arr: list) -> int: ``` **Input**: - `arr`: A list of `n` distinct integers in the inclusive range `[0, n]` representing the sequence with one number missing (0 <= len(arr) <= 10000). **Output**: - An integer representing the missing number from the range `[0, n]`. **Constraints**: - The solution should have a time complexity of O(n) and a space complexity of O(1). **Examples**: ```python assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0, 1]) == 2 assert find_missing_number([9,6,4,2,3,5,7,0,1]) == 8 assert find_missing_number([0]) == 1 assert find_missing_number([0, 2, 3, 4, 5, 6, 7, 8, 9]) == 1 ``` **Note**: - Use appropriate algorithms to ensure the above constraints are met, and try to optimize the solution beyond the naive approach if possible.","solution":"def find_missing_number(arr): Returns the missing number in the range [0, n] from the given array arr. n = len(arr) total_sum = n * (n + 1) / 2 arr_sum = sum(arr) return int(total_sum - arr_sum)"},{"question":"# Matrix Rotation Checker You are required to write a function that checks if two given matrices are rotations of each other by 90, 180, or 270 degrees. The matrices will be represented as lists of lists, with each inner list representing a row of the matrix. # Function Definition Implement the following function: ```python def are_rotations(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: pass ``` # Input Parameters * **matrix1** (List[List[int]]): The first matrix to compare. * **matrix2** (List[List[int]]): The second matrix to compare. # Output * **bool**: `True` if `matrix2` is a 90, 180, or 270 degree rotation of `matrix1`, otherwise `False`. # Constraints * Both matrices will be non-empty and square (i.e., number of rows equals number of columns). * Matrices can have dimensions up to 20x20. * Each element in the matrices will be an integer. # Example ```python # Example usage and output print(are_rotations( [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] )) # Output: True (matrix2 is a 90 degree rotation of matrix1) print(are_rotations( [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] )) # Output: True (matrix2 is a 180 degree rotation of matrix1) print(are_rotations( [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] )) # Output: True (matrix2 is a 270 degree rotation of matrix1) print(are_rotations( [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ [1, 2, 3], [4, 5, 6], [7, 8, 0] ] )) # Output: False (matrix2 is not a rotation of matrix1) ``` # Notes * The function should use effective space and computation strategies to determine if one matrix is a rotation of another. * Consider edge cases where the matrices have the same dimensions but different values.","solution":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_180(matrix: List[List[int]]) -> List[List[int]]: return rotate_90(rotate_90(matrix)) def rotate_270(matrix: List[List[int]]) -> List[List[int]]: return rotate_90(rotate_180(matrix)) def are_rotations(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: if matrix1 == matrix2: return True if rotate_90(matrix1) == matrix2: return True if rotate_180(matrix1) == matrix2: return True if rotate_270(matrix1) == matrix2: return True return False"},{"question":"# Problem Statement You are tasked with implementing a queue data structure to manage a sequence of customer support inquiries. The queue should follow the FIFO (First-In, First-Out) principle and handle error conditions gracefully. **Specifications**: Implement a `Queue` class with the following methods: 1. `enqueue(data: T)`: Add an element `data` to the rear of the queue. 2. `dequeue() -> T`: Remove and return the front element of the queue. 3. `peek() -> T`: Return (but do not remove) the front element of the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty, `False` otherwise. 5. `is_full() -> bool`: Return `True` if the queue is full, `False` otherwise. 6. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueOverflowError*: Raised when attempting to enqueue into a full queue. - *QueueUnderflowError*: Raised when attempting to dequeue from or peek into an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The queue should be limited by a maximum size constraint upon initialization. # Inputs: - Integer `limit`: Defines the maximum number of elements the queue can hold. - Sequence of operations requests including `enqueue`, `dequeue`, `peek`, `is_empty`, `is_full`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `peek`: The respective element. - For `is_empty`, `is_full`: Boolean value indicating state of queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python Q = Queue(3) Q.enqueue(10) Q.enqueue(20) print(Q.dequeue()) # Output: 10 print(Q.peek()) # Output: 20 print(Q.is_empty()) # Output: False Q.enqueue(30) print(Q.is_full()) # Output: False Q.enqueue(40) Q.enqueue(50) # Raises QueueOverflowError: Too many elements ``` # Constraints: - Queue size `limit` ranges from 1 to 10^4. - Operations on the queue should be optimized for efficiency. # Task: Implement the `Queue` class described above, ensuring proper function and error handling compliance.","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit: int): self.limit = limit self.queue = [] def enqueue(self, data): if self.is_full(): raise QueueOverflowError(\\"Queue is full.\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty.\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty.\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) == self.limit def size(self): return len(self.queue)"},{"question":"# Array Rotation Context Array manipulation is a common task in many programming challenges, often requiring effective use of loops and understanding of array structures. This question assesses your ability to perform array rotations, which is a fundamental operation in many algorithms. Task Write a Python function `rotate_array(arr: list, k: int) -> list` that rotates the elements of a list `arr` to the right by `k` steps. The rotation should be performed in-place, meaning you should not use additional arrays to achieve the rotation. Ensure your solution handles both positive and negative values of `k`. Specifications - **Input**: - `arr`: A list of integers. - `k`: An integer representing the number of steps to rotate the array to the right. If `k` is negative, rotate to the left by `|k|` steps. - **Output**: A list of integers representing the rotated array. - **Constraints**: - The input list can contain between 1 and 1000 integers. - The integer `k` can range between -10000 and 10000. Examples ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -3) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 10) [1, 2, 3, 4, 5] >>> rotate_array([], 2) [] >>> rotate_array([1], 100) [1] ``` Notes - Consider using modular arithmetic to handle cases where `k` is larger than the length of the array. - Take into account edge cases, such as when the array is empty or contains a single element. - Ensure your solution is efficient in both time and space complexity, especially since the list can be large. Implementation Strategy 1. Compute the effective rotation steps by taking `k` modulo the length of the array. 2. If the computed steps are zero, return the array as-is. 3. Perform the rotation in-place by slicing the array appropriately. - Include error handling for invalid input, although the given constraints will ensure most cases are valid.","solution":"def rotate_array(arr, k): Rotates the elements of arr to the right by k steps. If k is negative, rotates the elements to the left by |k| steps. Parameters: arr (list): List of integers to be rotated k (int) : Number of steps to rotate the array Returns: list: Rotated list if not arr: return arr n = len(arr) k %= n # Normalize k so that it lies within the array length return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement A company has developed a custom sorting algorithm that sorts an array of integers based on the number of unique prime factors each integer contains. For integers with the same number of unique prime factors, the standard numerical sort is applied. Your task is to implement this custom sorting algorithm. # Requirements 1. Implement a function to perform prime factorization and determine the number of unique prime factors. 2. Apply a comparison function to sort the array. 3. Optimize for performance with large datasets. # Function Signature ```python from typing import List def unique_prime_sort(arr: List[int]) -> List[int]: # implementation ``` # Input Constraints 1. **Array Length**: The array can contain up to 10,000 integers. 2. **Element Range**: Each integer ranges from 1 to 10,000. # Output Return the array sorted based on the number of unique prime factors. # Example **Test the function with the following:** ```python arr = [15, 7, 8, 30, 21, 27, 10, 14] sorted_arr = unique_prime_sort(arr) print(sorted_arr) # Expected output: [7, 8, 10, 14, 15, 21, 27, 30] ``` # Explanation - 7 has 1 unique prime factor (7) - 8 has 1 unique prime factor (2) - 10 has 2 unique prime factors (2, 5) - 14 has 2 unique prime factors (2, 7) - 15 has 2 unique prime factors (3, 5) - 21 has 2 unique prime factors (3, 7) - 27 has 1 unique prime factor (3) - 30 has 3 unique prime factors (2, 3, 5) Hence, after sorting, the array becomes: [7, 8, 27, 10, 14, 15, 21, 30].","solution":"from typing import List import math def count_unique_prime_factors(n: int) -> int: unique_primes = set() if n < 2: return 0 while n % 2 == 0: unique_primes.add(2) n //= 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: unique_primes.add(i) n //= i if n > 2: unique_primes.add(n) return len(unique_primes) def unique_prime_sort(arr: List[int]) -> List[int]: return sorted(arr, key=lambda x: (count_unique_prime_factors(x), x)) # Example usage arr = [15, 7, 8, 30, 21, 27, 10, 14] sorted_arr = unique_prime_sort(arr) print(sorted_arr) # Expected output: [7, 8, 27, 10, 14, 15, 21, 30]"},{"question":"# Question **Problem Statement**: You are provided with a function that calculates the factorial of a number using recursion. Your task is to extend this functionality to compute the double factorial of a number, also using recursion. A double factorial of a number ( n ), denoted as ( n!! ), is defined as the product of all the integers from 1 up to ( n ) that have the same parity (even or odd) as ( n ). **Objective**: 1. Write a function called `double_factorial(n: int) -> int` that takes an integer ( n ) and returns the double factorial of ( n ). - If ( n ) is 0 or -1, the function should return 1. - If ( n ) is negative and not -1, the function should raise a `ValueError`. 2. Write a function called `generate_double_factorial_series(m: int) -> list[int]` that takes an integer ( m ) and returns a list of double factorials from 0 to ( m ). - It should utilize the `double_factorial(n)` function. **Constraints**: - You can assume `0 <= m <= 15` for generating the double factorial series. **Input**: - An integer `n` for the `double_factorial` function. - An integer `m` for the `generate_double_factorial_series` function. **Output**: - Integer result for `double_factorial` function. - List of integers for the `generate_double_factorial_series` function. **Examples**: 1. `double_factorial(7)` should return `105` since ( 7!! = 7 times 5 times 3 times 1 ). 2. `double_factorial(8)` should return `384` since ( 8!! = 8 times 6 times 4 times 2 ). 3. `generate_double_factorial_series(5)` should return `[1, 1, 2, 3, 8, 15]`. 4. `generate_double_factorial_series(0)` should return `[1]`. This will test your understanding of recursion and series generation. Your solution should handle edge cases and input validation appropriately.","solution":"def double_factorial(n: int) -> int: Returns the double factorial of a non-negative integer n. if n == 0 or n == -1: return 1 if n < -1: raise ValueError(\\"The double factorial is not defined for negative integers other than -1.\\") return n * double_factorial(n - 2) def generate_double_factorial_series(m: int) -> list: Generates a list of double factorials from 0 to m. series = [] for i in range(m + 1): series.append(double_factorial(i)) return series"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase English letters. Write a function: ```python def most_frequent_character(s: str) -> str: # your implementation here ``` The function should return the character that appears the most frequently in the string. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. # Input - A string `s` where `1 <= len(s) <= 10^5`. # Output - A single character which is the most frequently occurring character in the string, or the lexicographically smallest one if there is a tie. # Constraints - `1 <= len(s) <= 10^5` - The string `s` consists only of lowercase English letters. # Example ```python >>> most_frequent_character(\\"aacacbb\\") a ``` **Explanation**: - Frequency count of characters: `a: 3, b: 2, c: 2` - The character `a` has the highest frequency. ```python >>> most_frequent_character(\\"abababcc\\") a ``` **Explanation**: - Frequency count of characters: `a: 3, b: 3, c: 2` - Both `a` and `b` have the highest frequency, but `a` is lexicographically smaller. # Notes - The function should provide the result efficiently, considering the potential large length of the string. - Consider using a dictionary or collections.Counter to count character frequencies.","solution":"def most_frequent_character(s: str) -> str: from collections import Counter # Count the frequency of each character frequency = Counter(s) # Find the character with the highest frequency # In case of tie, the lexicographically smallest should be chosen most_frequent_char = min(frequency.keys(), key=lambda char: (-frequency[char], char)) return most_frequent_char"},{"question":"# Longest Shared Substring Problem Statement Design a function to find the longest substring that is shared between two input strings. This problem can be approached using dynamic programming. Function Signature ```python def longest_common_substring(str1: str, str2: str) -> str: pass ``` Input * The input parameters `str1` and `str2` are two strings for which we need to find the longest common substring. Output * The function should return the longest common substring. If there are multiple substrings of the same maximum length, return any one of them. * If no common substring exists, return an empty string (`\\"\\"`). Constraints 1. The length of each input string does not exceed 1000. 2. The strings contain only lowercase English letters. Examples ```python >>> longest_common_substring(\\"abcdef\\", \\"zbcdf\\") \\"bcd\\" >>> longest_common_substring(\\"abcdef\\", \\"ghijkl\\") \\"\\" >>> longest_common_substring(\\"substring\\", \\"string\\") \\"string\\" ``` Explanation 1. In the first example, \\"bcd\\" is the longest common substring shared between \\"abcdef\\" and \\"zbcdf\\". 2. In the second example, there is no common substring shared between \\"abcdef\\" and \\"ghijkl\\", so the output is an empty string. 3. In the third example, \\"string\\" is the longest common substring shared between \\"substring\\" and \\"string\\".","solution":"def longest_common_substring(str1: str, str2: str) -> str: Returns the longest common substring shared between str1 and str2. If there are multiple longest substrings, return any one of them. If there is no common substring, return an empty string. len1 = len(str1) len2 = len(str2) # Table to store lengths of longest common suffixes of substrings # LCSuff[i][j] will be the length of the longest common suffix of str1[0..i-1] and str2[0..j-1] LCSuff = [[0] * (len2 + 1) for _ in range(len1 + 1)] length_of_longest_common_substring = 0 # Length of longest common substring end_index_in_str1 = 0 # Ending index of longest common substring in str1 # Building the LCSuff table in bottom-up fashion for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1 if LCSuff[i][j] > length_of_longest_common_substring: length_of_longest_common_substring = LCSuff[i][j] end_index_in_str1 = i else: LCSuff[i][j] = 0 # If no common substring exists if length_of_longest_common_substring == 0: return \\"\\" # Longest common substring start_index_in_str1 = end_index_in_str1 - length_of_longest_common_substring return str1[start_index_in_str1:end_index_in_str1]"},{"question":"# Question: Implement a Robust Polynomial Evaluation Function You are tasked with enhancing the given Polynomial Evaluation system to handle a broader range of inputs and edge cases effectively. Problem Statement Modify the `PolynomialEvaluator` class to support evaluation of polynomials with more advanced features such as handling coefficients that can be zero or very large numbers. Implement safety checks to manage scenarios like overflow and underflow. Requirements 1. **Modify PolynomialEvaluator\'s evaluate function**: - Ensure that the function can manage coefficients that are zero to avoid unnecessary calculations. - Implement logic to handle very large coefficients that could cause overflow errors. - Return meaningful values or appropriate messages when the calculation cannot be performed due to extreme conditions. 2. **Add Overflow and Underflow Checks**: - Implement checks within the `evaluate` function to detect potential overflow or underflow scenarios. - Return predefined safe values or raise custom exceptions for such cases to inform users of unsafe operations. Input and Output - The `evaluate` function should take a list of coefficients and a single variable `x` and return the evaluated polynomial value at `x`. - The modified implementation should handle zero and extreme coefficient values gracefully and provide meaningful feedback. Constraints - Consider edge cases where some of the polynomial coefficients can be zero or extremely large. - Ensure minimal changes to avoid breaking existing functionalities. - Perform necessary validation so users are aware when unsafe operations have been attempted. Testing and Performance - Ensure that the modified functionality does not introduce significant performance degradation. - Add test cases to validate the additional safety checks, overflow, and underflow scenarios. Example ```python class PolynomialEvaluator: def evaluate(self, coefficients, x): # Implement evaluation logic here pass evaluator = PolynomialEvaluator() coefficients = [1e10, 0, 5e-10, 3.0] # Including zero and very large/small numbers x = 2.0 result = evaluator.evaluate(coefficients, x) # Should handle overflows and underflows gracefully ``` Output: ```plaintext result: expected to handle and not produce overflow or extreme values ``` Implement the above solution and validate using test cases to handle scenarios for zero, overflow, and underflow coefficient values.","solution":"class PolynomialEvaluator: def evaluate(self, coefficients, x): Evaluate the polynomial for a given x. Args: coefficients (list of float): coefficients of the polynomial x (float): value at which to evaluate the polynomial Returns: float: evaluated polynomial value or a message indicating overflow/underflow. import math result = 0.0 max_float = 1.79e308 min_float = -1.79e308 for i, coeff in enumerate(coefficients): term = coeff * (x ** i) if term > max_float: return \\"Overflow detected\\" if term < min_float: return \\"Underflow detected\\" result += term if result > max_float: return \\"Overflow detected\\" if result < min_float: return \\"Underflow detected\\" return result"},{"question":"# Coding Question: Implement an Automated Test Coverage Reporter As part of your ongoing responsibilities to enhance code quality, you need to create a script that automatically calculates and reports test coverage for each Python script in your project whenever it\'s modified. This will help to maintain high code quality standards by ensuring that each script has adequate test coverage. Objective You are to write a Python function `report_test_coverage` that: 1. Fetches the list of modified Python files in the latest commit using the GitHub API. 2. For each modified Python script: - Runs the tests associated with the script. - Calculates the test coverage using a coverage analysis tool (e.g., `coverage.py`). 3. Generates a report summarizing the test coverage for each script. # Input No direct input but relies on GitHub repository setup (referencing environment variables for GITHUB_TOKEN and GITHUB_REPOSITORY). # Output ```json [ { \\"file_path\\": \\"path/to/modified/script.py\\", \\"coverage_percentage\\": 85.0 }, { ... }, ] ``` # Constraints - Only consider Python files with `.py` extension. - Environment variables for GitHub are assumed to be always valid. - Tests should be written using a standard testing framework like `unittest` or `pytest`. - The coverage tool used should be readily available in the environment. # Requirements - Use the `requests` library to fetch commit file data. - Use `coverage.py` or a similar tool for coverage analysis. - Summarize coverage data for each modified script. # Performance - The script should execute within 10 seconds for up to 50 modified files. Example ```python import requests import os import coverage import json def report_test_coverage() -> list[dict]: # Your implementation here pass ```","solution":"import os import requests import coverage import json import subprocess def get_modified_files(): Fetches the list of modified Python files in the latest commit using GitHub API. token = os.getenv(\'GITHUB_TOKEN\') repo = os.getenv(\'GITHUB_REPOSITORY\') headers = { \'Authorization\': f\'token {token}\', \'Accept\': \'application/vnd.github.v3+json\' } # Get the latest commit repo_url = f\\"https://api.github.com/repos/{repo}/commits\\" response = requests.get(repo_url, headers=headers) response.raise_for_status() latest_commit = response.json()[0] commit_url = latest_commit[\'url\'] # Get modified files in the latest commit commit_response = requests.get(commit_url, headers=headers) commit_response.raise_for_status() files = commit_response.json()[\'files\'] modified_files = [file[\'filename\'] for file in files if file[\'filename\'].endswith(\'.py\')] return modified_files def calculate_coverage(file_path): Runs the tests and calculates test coverage for the given Python script. cov = coverage.Coverage() cov.start() # Extracting tests for the given file test_result = subprocess.run([\'pytest\', \'--maxfail=1\', \'--disable-warnings\'], capture_output=True, text=True) cov.stop() cov.save() # Produce coverage report report_data = cov.report(file=file_path, show_missing=True, skip_covered=False, ignore_errors=True) coverage_percentage = report_data return coverage_percentage def report_test_coverage(): Generates the test coverage report for modified Python scripts. modified_files = get_modified_files() report = [] for file_path in modified_files: coverage_percentage = calculate_coverage(file_path) report.append({ \\"file_path\\": file_path, \\"coverage_percentage\\": coverage_percentage }) return report"},{"question":"# Coding Assessment Question **Context**: In software development, it\'s crucial to work with data structures that maintain a precise order of elements. One such structure is the doubly linked list, which allows efficient insertion, deletion, and traversal in both directions. **Question**: Implement a doubly linked list with an additional functionality where the list can be split into two separate lists at a given index. **Function Signature**: ```python class Node: def __init__(self, data: int): self.data = data self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, data: int) -> None: pass # Implement append functionality def split(self, index: int) -> (\'DoublyLinkedList\', \'DoublyLinkedList\'): pass # Implement split functionality ``` **Input**: * `data` (int): An integer value to be added to the list. * `index` (int): A non-negative integer specifying the index at which the list should be split. **Output**: * After the split operation, the method returns two separate doubly linked lists: - The first list contains the elements from the head up to, but not including, the specified index. - The second list contains the elements from the specified index to the end. **Constraints**: * The `append` function can be called multiple times to construct the list before splitting. * The function `split` must handle cases where the index is out of bounds appropriately. * Efficiency in both time and space is important, but clear and correct implementation takes precedence. **Examples**: 1. *Example 1*: ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.append(4) l1, l2 = dll.split(2) ``` *After splitting at index 2:* - `l1` contains: 1, 2 - `l2` contains: 3, 4 2. *Example 2*: ```python dll = DoublyLinkedList() dll.append(5) dll.append(6) dll.append(7) l1, l2 = dll.split(1) ``` *After splitting at index 1:* - `l1` contains: 5 - `l2` contains: 6, 7 3. *Example 3* (index out of bounds): ```python dll = DoublyLinkedList() dll.append(7) dll.append(8) dll.append(9) l1, l2 = dll.split(5) ``` *After attempting to split at index 5 (out of bounds):* - `l1` contains: 7, 8, 9 - `l2` contains: None **Notes**: * Ensure each node links properly in both directions when lists are split. * Handle edge cases, such as splitting at the head (index 0) or at indices beyond the current length of the list. * Properly manage memory and avoid common pitfalls in linked list handling.","solution":"class Node: def __init__(self, data: int): self.data = data self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, data: int) -> None: new_node = Node(data) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def split(self, index: int) -> (\'DoublyLinkedList\', \'DoublyLinkedList\'): if index <= 0: return DoublyLinkedList(), self current = self.head for _ in range(index): if not current: # Index is out of bounds return self, DoublyLinkedList() current = current.next if not current: # Index is exactly at the end of the list return self, DoublyLinkedList() first_list = DoublyLinkedList() first_list.head = self.head first_list.tail = current.prev second_list = DoublyLinkedList() second_list.head = current second_list.tail = self.tail # Disconnect the two lists if current.prev: current.prev.next = None current.prev = None return first_list, second_list def to_list(self) -> list: result = [] current = self.head while current: result.append(current.data) current = current.next return result"},{"question":"Coding Assessment Question **Objective:** Implement a function to generate an HTML file from a Markdown file with basic element transformations. Problem Statement You are given a Markdown file and your task is to convert it into an HTML file. The HTML file should include proper HTML tags to represent the Markdown content, preserving the formatting style of the original document. Write a function `convert_markdown_to_html` that takes the following inputs: - `input_markdown_file`: (str) Path to the input Markdown file. - `output_html_file`: (str) Path where the output HTML file should be saved. The function should read the content of the Markdown file, convert it to HTML format, and save it into the specified output path. Constraints - The Markdown file contains basic elements such as headers (denoted by `#` for H1, `` for H2, etc.), paragraphs, bold text (enclosed by `**` or `__`), italic text (enclosed by `*` or `_`), and links (`[label](url)`). - Assume the Markdown file does not contain overly complex elements such as nested lists or inline HTML. Expected Input and Output ```python def convert_markdown_to_html( input_markdown_file: str, output_html_file: str ) -> None: # your implementation here # Example usage: convert_markdown_to_html(\\"sample.md\\", \\"sample.html\\") ``` * `Input`: * A sample markdown in `sample.md`: ``` # Welcome to Markdown This is a paragraph with **bold text** and *italic text*. Subheader Here is a [link](https://example.com). ``` * `Output`: An HTML file `sample.html` containing: ```html <html> <body> <h1>Welcome to Markdown</h1> <p>This is a paragraph with <strong>bold text</strong> and <em>italic text</em>.</p> <h2>Subheader</h2> <p>Here is a <a href=\\"https://example.com\\">link</a>.</p> </body> </html> ``` Notes 1. Ensure to handle common Markdown syntax accurately. 2. Assume the input Markdown file is well-formed and does not need extensive validation. 3. Consider edge cases where Markdown elements might combine (e.g., bold and italic text). 4. Ensure code clarity and provide comments where necessary.","solution":"import re def convert_markdown_to_html(input_markdown_file: str, output_html_file: str) -> None: def convert_line(line): line = line.strip() # Conversion rules rules = [ (r\'# (.*)\', r\'<h1>1</h1>\'), # H1 (r\' (.*)\', r\'<h2>1</h2>\'), # H2 (r\'**(.*?)**\', r\'<strong>1</strong>\'), # Bold (r\'*(.*?)*\', r\'<em>1</em>\'), # Italic (r\'[(.*?)]((.*?))\', r\'<a href=\\"2\\">1</a>\') # Links ] for pattern, replacement in rules: line = re.sub(pattern, replacement, line) if not any(pattern in line for pattern, _ in rules[:2]): line = f\'<p>{line}</p>\' return line with open(input_markdown_file, \'r\') as f: lines = f.readlines() html_lines = [\'<html>n\', \' <body>n\'] for line in lines: html_lines.append(f\' {convert_line(line)}n\') html_lines.append(\' </body>n\') html_lines.append(\'</html>n\') with open(output_html_file, \'w\') as f: f.writelines(html_lines)"},{"question":"**Problem Statement**: You are given an unsorted list of integers `arr` and an integer `target`. Your task is to implement the function `find_pair_with_sum(arr: List[int], target: int) -> Tuple[int, int]` which returns a tuple containing two numbers from the list that add up to the `target`. If no such pair exists, the function should return `None`. **Input Format**: * `arr`: A list of integers. * `target`: An integer representing the sum of the pair you are looking for. **Output Format**: * A tuple containing two integers from the list that add up to `target` or `None` if no such pair exists. **Constraints**: * All integers in the array can be positive, negative, or zero. * The length of `arr` is not fixed and can vary within reasonable limits (0 ≤ len(arr) ≤ 10^5). * The same element cannot be used twice. **Performance Requirements**: * Your solution should aim to have an average time complexity of O(n) where n is the number of elements in `arr`. **Example**: ```python def find_pair_with_sum(arr, target): # your code here print(find_pair_with_sum([2, 4, 5, 7, 899, 54, 32], 9)) # Output: (2, 7) or (4, 5) print(find_pair_with_sum([5, 4, 3, 2], 8)) # Output: (5, 3) print(find_pair_with_sum([3, 5, 7, 10, 2, 12], 15)) # Output: (3, 12) or (5, 10) print(find_pair_with_sum([1], 2)) # Output: None print(find_pair_with_sum([10, 9, 8, 7, 6, 5, 4], 20)) # Output: None print(find_pair_with_sum([], 5)) # Output: None ``` **Your Task**: * Implement the `find_pair_with_sum` function using an efficient algorithm such as a hash map to achieve the desired performance. Take into account edge cases and aim to achieve optimal performance.","solution":"from typing import List, Tuple, Optional def find_pair_with_sum(arr: List[int], target: int) -> Optional[Tuple[int, int]]: Finds and returns a tuple containing two numbers from the list that add up to the target. If no such pair exists, returns None. nums_seen = {} for num in arr: complement = target - num if complement in nums_seen: return (complement, num) nums_seen[num] = True return None"},{"question":"# Scenario: You are developing a software application that involves organizing various tasks by their priority levels. To ensure that tasks are executed based on their importance, you need to implement a priority queue. # Task: Write a class named `PriorityQueue` that simulates a priority queue with the following methods. # Class and Method Definitions: 1. **class PriorityQueue**: - A priority queue structure. 2. **add_task(task: str, priority: int) -> None** - Adds a new task with a specified priority to the queue. 3. **remove_task() -> str** - Removes and returns the task with the highest priority from the queue. - If the queue is empty, return the string \\"Queue is empty\\". 4. **peek_task() -> str** - Returns the task with the highest priority without removing it from the queue. - If the queue is empty, return the string \\"Queue is empty\\". # Input and Output Formats: - **Input**: - `task` (str): The task description to be added. - `priority` (int): The priority level of the task where a lower number indicates a higher priority (e.g., 1 is the highest priority). - **Output**: - `add_task`: None - `remove_task`: Returns the task with the highest priority as a string. If empty, returns \\"Queue is empty\\". - `peek_task`: Returns the task with the highest priority as a string. If empty, returns \\"Queue is empty\\". # Constraints: 1. Task descriptions (`task`) will only contain printable ASCII characters. 2. Priority levels (`priority`) will be integers between 1 and 100 inclusive. 3. Raises appropriate exceptions for invalid inputs, such as non-string `task` or non-integer `priority`. # Examples: - **Example 1**: ```python pq = PriorityQueue() pq.add_task(\\"Task 1\\", 2) pq.add_task(\\"Task 2\\", 1) pq.add_task(\\"Task 3\\", 3) pq.peek_task() # Output: \\"Task 2\\" ``` - **Example 2**: ```python pq = PriorityQueue() pq.add_task(\\"Task 1\\", 2) pq.add_task(\\"Task 2\\", 1) pq.remove_task() # Output: \\"Task 2\\" pq.remove_task() # Output: \\"Task 1\\" pq.remove_task() # Output: \\"Queue is empty\\" ```","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] def add_task(self, task: str, priority: int) -> None: if not isinstance(task, str): raise ValueError(\\"Task must be a string\\") if not isinstance(priority, int) or priority < 1 or priority > 100: raise ValueError(\\"Priority must be an integer between 1 and 100\\") heapq.heappush(self._queue, (priority, task)) def remove_task(self) -> str: if self._queue: return heapq.heappop(self._queue)[1] return \\"Queue is empty\\" def peek_task(self) -> str: if self._queue: return self._queue[0][1] return \\"Queue is empty\\""},{"question":"# Problem Statement Write a function that simulates managing a collection of tasks using priority queues. Each task can be added with a specific priority and can be dynamically updated or removed based on incoming commands. # Function to Implement Implement the function `manage_tasks(commands: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]` which: * Takes a list of commands and processes them to manage tasks. * Each command is a tuple consisting of a string indicating the operation (`\'add\'`, `\'remove\'`, `\'update\'`), the task ID, and the task priority. * Returns a list of task IDs sorted by their priorities in descending order. # Input Format 1. `commands` (List[Tuple[str, int, int]]): A list of commands to manage the tasks. Each command is a tuple with: * `\'add\'` (str): Command to add a task with a given task ID and priority. * `\'remove\'` (str): Command to remove a task with a given task ID. The priority value for this command can be ignored. * `\'update\'` (str): Command to update the priority of an existing task with a given task ID to a new priority value. # Output Format * Returns a list of tuples, where each tuple contains the task ID and its priority, sorted in descending order of priority. # Constraints * Task IDs will be unique integers. * Task priorities will be integers (can be negative, zero, or positive). * Operations will be valid and only target existing tasks correctly. # Example Given the following input: ```python commands = [(\'add\', 1, 10), (\'add\', 2, 20), (\'update\', 1, 15), (\'remove\', 2, 0)] ``` The expected output is: ```python [(1, 15)] ``` # Notes * Ensure that the function handles adding new tasks, updating priorities of existing tasks, and removing tasks correctly. * Returned tasks should be sorted by their priorities from highest to lowest. * Utilize appropriate data structures to manage tasks efficiently. ```python def manage_tasks(commands: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]: tasks = {} for command in commands: operation, task_id, priority = command if operation == \'add\': tasks[task_id] = priority elif operation == \'remove\': if task_id in tasks: del tasks[task_id] elif operation == \'update\': if task_id in tasks: tasks[task_id] = priority # Sort tasks by priority in descending order and return as a list of tuples return sorted(tasks.items(), key=lambda x: x[1], reverse=True) # Example usage: commands = [(\'add\', 1, 10), (\'add\', 2, 20), (\'update\', 1, 15), (\'remove\', 2, 0)] print(manage_tasks(commands)) # Output: [(1, 15)] ```","solution":"from typing import List, Tuple def manage_tasks(commands: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]: tasks = {} for command in commands: operation, task_id, priority = command if operation == \'add\': tasks[task_id] = priority elif operation == \'remove\': if task_id in tasks: del tasks[task_id] elif operation == \'update\': if task_id in tasks: tasks[task_id] = priority # Sort tasks by priority in descending order and return as a list of tuples return sorted(tasks.items(), key=lambda x: x[1], reverse=True)"},{"question":"# Challenge: Convert Roman Numerals to Integers Background Roman numerals are represented by combinations of the following symbols: - `I (1)`, `V (5)`, `X (10)`, `L (50)`, `C (100)`, `D (500)`, `M (1000)` Symbols are generally written from largest to smallest from left to right. However, when a smaller numeral appears before a larger one, it indicates subtraction. For example, `IV` means `4`, and `IX` means `9`. Objective Implement a function `roman_to_int(s: str) -> int` that converts a given Roman numeral string into its integer equivalent. Input * A string `s` containing a valid Roman numeral (length `1 <= len(s) <= 15`). Output * An integer representing the converted value from the Roman numeral. Constraints * The input string is guaranteed to be a valid Roman numeral representing an integer between 1 and 3999. * Perform the conversion in linear time complexity. Example ```python >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 ``` Note Consider using a dictionary to map single Roman numeral characters to their respective integer values and process the input string from left to right. Detect subtraction cases by comparing the current numeral with the next one.","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in s[::-1]: value = roman_to_value[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"# Scenario You are tasked with enhancing a text manipulation utility in Python that converts a given string to its title case format. Normally, the built-in `title()` method capitalizes the first letter of each word while making the rest of the letters lowercase. However, certain conjunctions and prepositions (like \'and\', \'or\', \'the\') should remain in lowercase unless they are the first or last words in the string. # Objective Write a Python function named `custom_title` that converts a given string to title case, considering exceptions for specific words. Ensure that exceptions are only lowercased if they are not the first or last word of the string. # Function Signature ```python def custom_title(input_string: str) -> str: pass ``` # Input - `input_string` (str): A non-empty string containing one or more words separated by spaces. # Output - Returns a string in title case format with exceptions considered for certain words. # Constraints - The input string should have a length of at most 1000 characters. - The words to be kept in lowercase (conjunctions and prepositions) are: \'and\', \'or\', \'the\', \'but\', \'for\', \'nor\', \'so\', \'yet\', \'at\', \'by\', \'in\', \'of\', \'on\', \'to\', \'up\', \'via\'. # Requirements 1. Convert the input string to title case, properly handling the exceptions. 2. Maintain the case sensitivity of the rest of the characters. 3. The function should not assume the input string is in a particular case form. 4. Consider edge cases, such as extra spaces between words or punctuation. # Examples ```python >>> custom_title(\\"a tale of two cities\\") \'A Tale of Two Cities\' >>> custom_title(\\"THE LORD OF THE RINGS\\") \'The Lord of the Rings\' >>> custom_title(\\"to be or not to be, that is the question\\") \'To Be or Not to Be, That Is the Question\' >>> custom_title(\\"HARRY POTTER and the chamber of SECRETS\\") \'Harry Potter and the Chamber of Secrets\' >>> custom_title(\\"a walk IN THE park\\") \'A Walk in the Park\' ``` # Notes * The function should be robust to variations in whitespace and punctuation. * Consider that the input may include proper nouns or acronyms where the case should be preserved. * Provide well-documented code and include any assumptions made in your solution. # Hints - Use the `str.split()` method to separate words. - Iterate over the words and apply the appropriate case transformations. - Take care to join the manipulated words back into a single string with proper spacing.","solution":"def custom_title(input_string: str) -> str: exceptions = {\'and\', \'or\', \'the\', \'but\', \'for\', \'nor\', \'so\', \'yet\', \'at\', \'by\', \'in\', \'of\', \'on\', \'to\', \'up\', \'via\'} words = input_string.split() if not words: return input_string # Capitalize the first and last words regardless of exceptions result = [words[0].capitalize()] for word in words[1:-1]: if word.lower() in exceptions: result.append(word.lower()) else: result.append(word.capitalize()) if len(words) > 1: result.append(words[-1].capitalize()) return \' \'.join(result)"},{"question":"# Question Statement String Permutation Checker In this exercise, you are required to implement a function that checks whether two given strings are permutations of each other. # Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: pass ``` # Input - Two strings `str1` and `str2`, each of length `n` where `1 <= n <= 10^4`. # Output - A boolean value `True` if the strings are permutations of each other, `False` otherwise. # Constraints - The strings will contain only ASCII characters. # Example - `are_permutations(\\"abc\\", \\"bca\\")` should return `True`. - `are_permutations(\\"abcd\\", \\"abcd\\")` should return `True`. - `are_permutations(\\"abc\\", \\"abcc\\")` should return `False`. - `are_permutations(\\"aabbcc\\", \\"ccbbaa\\")` should return `True`. - `are_permutations(\\"abc\\", \\"xyz\\")` should return `False`. # Testing The function should correctly handle scenarios where the strings: - Are of different lengths (should return `False`). - Contain the same characters in different orders. - Are exactly the same. - Contain duplicate characters. # Explanation Your implementation should: 1. Compare the lengths of the two strings. If they differ, return `False`. 2. Sort both strings and compare the sorted versions. 3. Alternatively, use a character count approach where you count occurrences of each character in both strings and compare the counts.","solution":"def are_permutations(str1: str, str2: str) -> bool: Check if two strings are permutations of each other. Args: str1 (str): The first string str2 (str): The second string Returns: bool: True if the strings are permutations of each other, False otherwise from collections import Counter if len(str1) != len(str2): return False return Counter(str1) == Counter(str2)"},{"question":"# Coding Assessment Question Context You are part of a team developing a financial analytics tool that requires analyzing transaction logs. One of the critical features of the tool is to detect periods of inactivity within a set of transaction timestamps. Your task is to identify the longest period of inactivity. Task Write a Python function `longest_inactivity_period` that calculates the longest time gap (in seconds) between consecutive transaction timestamps. Function Signature ```python def longest_inactivity_period(timestamps: List[str]) -> int: ``` Input * `timestamps` (a list of strings): Each string is a timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". Output * An integer representing the longest period of inactivity (in seconds) between any two consecutive timestamps. Constraints 1. The list of timestamps will contain at most `10000` elements. 2. Timestamps are provided in chronological order. 3. Each timestamp is a valid date-time string in the specified format. Example ```python from typing import List # Example def longest_inactivity_period(timestamps: List[str]) -> int: from datetime import datetime if not timestamps: return 0 max_gap = 0 fmt = \\"%Y-%m-%d %H:%M:%S\\" for i in range(1, len(timestamps)): t1 = datetime.strptime(timestamps[i-1], fmt) t2 = datetime.strptime(timestamps[i], fmt) gap = (t2 - t1).total_seconds() max_gap = max(max_gap, gap) return max_gap # Example usages timestamps = [\\"2023-10-01 10:00:00\\", \\"2023-10-01 12:00:00\\", \\"2023-10-01 12:30:00\\"] print(longest_inactivity_period(timestamps)) # Output: 7200 (2 hours in seconds) timestamps = [\\"2023-10-01 09:00:00\\", \\"2023-10-01 10:00:00\\", \\"2023-10-01 14:00:00\\", \\"2023-10-01 18:00:00\\"] print(longest_inactivity_period(timestamps)) # Output: 14400 (4 hours in seconds) ``` Notes * You should handle any situation where the timestamps list might be empty. * Assume the given timestamps are unique and no two entries have the same timestamp.","solution":"from typing import List from datetime import datetime def longest_inactivity_period(timestamps: List[str]) -> int: if not timestamps: return 0 max_gap = 0 fmt = \\"%Y-%m-%d %H:%M:%S\\" for i in range(1, len(timestamps)): t1 = datetime.strptime(timestamps[i-1], fmt) t2 = datetime.strptime(timestamps[i], fmt) gap = (t2 - t1).total_seconds() max_gap = max(max_gap, gap) return max_gap"},{"question":"Write a Python function `reverse_k_elements(queue: list[int], k: int) -> list[int]` that reverses the first `k` elements of a queue represented by a list, while leaving the other elements in the original order. # Requirements: 1. **Input**: A list of integers `queue` representing the queue and an integer `k` where `1 <= k <= len(queue)`. 2. **Output**: A list of integers where the first `k` elements are reversed and the rest of the elements remain in the same order. 3. **Constraints**: - The length of the queue is between 1 and (10^5). - Each element of the queue is an integer within the range (-10^5) to (10^5). # Performance: - Optimize for time complexity to ensure that the operations are efficient given the constraints. # Implementation: - Utilize appropriate data structures (such as a deque from the collections module) to facilitate efficient manipulation of the elements. # Example: ```python >>> reverse_k_elements([1, 2, 3, 4, 5], 3) [3, 2, 1, 4, 5] >>> reverse_k_elements([10, 20, 30, 40, 50], 2) [20, 10, 30, 40, 50] >>> reverse_k_elements([5, 6, 7, 8, 9, 10], 6) [10, 9, 8, 7, 6, 5] >>> reverse_k_elements([100], 1) [100] >>> reverse_k_elements([1, 2], 1) [1, 2] ``` # Special Considerations: - Ensure that the function works efficiently even if `k` is equal to the length of the queue. - Handle the input validation to ensure `k` is always within the valid range.","solution":"from collections import deque from typing import List def reverse_k_elements(queue: List[int], k: int) -> List[int]: Reverses the first k elements of the queue represented by a list. Args: queue (List[int]): The list representing the queue. k (int): The number of elements to reverse from the front of the queue. Returns: List[int]: The list with the first k elements reversed. if k <= 0 or k > len(queue): raise ValueError(\\"k must be between 1 and the length of the queue inclusive\\") # Utilize deque for efficient operations dq = deque(queue[:k]) dq.reverse() # Return the concatenated list with the reversed part and the remaining part return list(dq) + queue[k:]"},{"question":"# Problem Statement Write a Python function, `next_permutation(arr: List[int]) -> List[int]`, that transforms the given list of integers into the next lexicographical permutation of the elements. If such arrangement is not possible (i.e., if the list is sorted in descending order), it transforms the list into the lowest possible order (i.e., sorted in ascending order). # Function Signature ```python from typing import List def next_permutation(arr: List[int]) -> List[int]: ``` # Input - A list of integers `arr` where each integer is in the range `[-10^4, 10^4]` and the length of the list is `1 <= len(arr) <= 100`. # Output - The modified list of integers representing the next permutation or the lowest possible order permutation. # Constraints - The function must modify the list `in-place` without using additional memory for another list. - The input list must be validated to ensure it contains only integers. # Performance Requirements - The solution should achieve a time complexity of O(n) where n is the length of the list and space complexity of O(1). # Example ```python >>> arr = [1, 2, 3] >>> next_permutation(arr) [1, 3, 2] >>> arr = [3, 2, 1] >>> next_permutation(arr) [1, 2, 3] >>> arr = [1, 1, 5] >>> next_permutation(arr) [1, 5, 1] ``` # Additional Test Cases ```python >>> arr = [2, 3, 1, 3, 3] >>> next_permutation(arr) [2, 3, 3, 1, 3] >>> arr = [1] >>> next_permutation(arr) [1] >>> arr = [4, 3, 2, 1, 1] >>> next_permutation(arr) [1, 1, 2, 3, 4] >>> arr = [] >>> next_permutation(arr) [] ``` # Implementation Constraints - The algorithm should not use any sorting libraries or built-in functions to sort the array. - Ensure input validation is performed at the beginning of the function to check if all elements are integers. # Notes - The next permutation algorithm can be implemented using a well-known approach involving right-to-left scanning and swapping. - You may refer to pseudo code or algorithm descriptions of next permutation for additional insight.","solution":"from typing import List def next_permutation(arr: List[int]) -> List[int]: Transform the given list of integers into the next lexicographical permutation. If such arrangement is not possible (i.e., if the list is sorted in descending order), transform the list into the lowest possible order (i.e., sorted in ascending order). def is_valid_input(arr): return all(isinstance(x, int) for x in arr) if not is_valid_input(arr): raise ValueError(\\"Input list must contain only integers.\\") # Function to reverse the array elements in place def reverse(start): end = len(arr) - 1 while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Find the first index \'i\' which is not in descending order from the end i = len(arr) - 2 while i >= 0 and arr[i] >= arr[i + 1]: i -= 1 if i >= 0: # Find the element which is just greater than arr[i] from the end of the list j = len(arr) - 1 while arr[j] <= arr[i]: j -= 1 # Swap elements at indexes i and j arr[i], arr[j] = arr[j], arr[i] # Reverse the elements from index i+1 to the end of the list reverse(i + 1) return arr"},{"question":"# Coding Assessment Question: Evaluate Maximum Network Delay **Background**: You are tasked with computing the time it takes for a network signal to propagate from a specific source node to all other nodes in a network graph. The graph is represented as a list of directed edges with associated time delays. Determining the maximum delay time allows you to evaluate the efficiency of the network. If it is impossible for all nodes to receive the signal, return -1. **Objective**: Implement a function `network_delay_time` that calculates the maximum time delay required for a signal originating from a given node to reach all other nodes in the network. You should utilize Dijkstra\'s algorithm or an equivalent shortest path algorithm to achieve this. **Function Signature**: ```python def network_delay_time(times: list, n: int, k: int) -> int: pass ``` **Inputs and Outputs**: * **Input**: * `times` - A list of tuples `(u, v, w)` representing a directed edge from node `u` to node `v` with a weight/delay of `w` * `n` - An integer representing the number of nodes in the network (nodes are labeled from `1` to `n`) * `k` - An integer representing the starting node of the signal * **Output**: * An integer representing the time it takes for the signal to reach all nodes. If it is impossible for all nodes to be reached, return `-1`. **Constraints**: * The number of nodes `n` is between 1 and 100. * The number of edges in the graph will not exceed 10,000. * The time to traverse any edge is a positive integer that does not exceed 100. **Example**: 1. **Input**: `times: [(2, 1, 1), (2, 3, 1), (3, 4, 1)], n: 4, k: 2` **Output**: `2` 2. **Input**: `times: [(1, 2, 1)], n: 2, k: 1` **Output**: `1` 3. **Input**: `times: [(1, 2, 1)], n: 2, k: 2` **Output**: `-1` 4. **Input**: `times: [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 1)], n: 4, k: 1` **Output**: `4` **Hint**: Utilize a priority queue (min-heap) for efficient implementation of Dijkstra\'s algorithm to determine the shortest path from the source to all other nodes. **Edge Cases to Consider**: * Disconnected nodes (nodes that cannot be reached) * Single node network (n=1) * High number of edges and nodes **Starter Template**: ```python import heapq from collections import defaultdict, deque def network_delay_time(times: list, n: int, k: int) -> int: graph = defaultdict(list) for u, v, w in times: graph[u].append((v, w)) min_heap = [(0, k)] shortest_times = {} while min_heap: t, node = heapq.heappop(min_heap) if node in shortest_times: continue shortest_times[node] = t for neighbor, w in graph[node]: if neighbor not in shortest_times: heapq.heappush(min_heap, (t + w, neighbor)) if len(shortest_times) == n: return max(shortest_times.values()) return -1 ``` This question integrates seamlessly with the existing set by presenting a network-related complexity problem, requiring the same level of algorithmic understanding, particularly in graph theory and shortest path algorithms.","solution":"import heapq from collections import defaultdict def network_delay_time(times: list, n: int, k: int) -> int: Calculate the time it takes for a signal to propagate from node k to all other nodes. graph = defaultdict(list) # Build the graph for u, v, w in times: graph[u].append((v, w)) # Min-heap to store (time, node) for Dijkstra\'s algorithm min_heap = [(0, k)] shortest_times = {} while min_heap: t, node = heapq.heappop(min_heap) if node in shortest_times: continue shortest_times[node] = t for neighbor, w in graph[node]: if neighbor not in shortest_times: heapq.heappush(min_heap, (t + w, neighbor)) if len(shortest_times) == n: return max(shortest_times.values()) return -1"},{"question":"# Coding Assessment Question Context You have been hired to develop a program for a weather forecasting system. One of the core functionalities involves processing a list of temperature readings. Your task is to implement a function that finds the longest subarray where the temperature increases continuously. Problem Statement Implement a Python function named `longest_increasing_subarray(temps: List[int]) -> List[int]` that takes a list of temperature readings as its input and returns the longest subarray of continuous increasing temperatures. Requirements 1. **Input Format**: - The function will receive a list of integers `temps` where each integer represents a temperature reading. 2. **Output Format**: - The function should return a list of integers representing the longest subarray of continuous increasing temperatures. 3. **Constraints**: - The length of `temps` will be between 1 and 1000 inclusive. - If there are multiple subarrays with the same length, return the first one encountered. 4. **Performance**: - The function should have a time complexity of O(n), where n is the length of the input list. 5. **Scenario**: - Validate the function with multiple test cases to cover different patterns of temperature readings. Example Usage ```python >>> longest_increasing_subarray([71, 72, 75, 74, 76, 77, 78]) [74, 76, 77, 78] >>> longest_increasing_subarray([40, 42, 45, 46, 50, 49, 51]) [40, 42, 45, 46, 50] >>> longest_increasing_subarray([30, 31, 30, 33, 34, 36, 38, 40]) [30, 33, 34, 36, 38, 40] >>> longest_increasing_subarray([10, 9, 8, 7]) [10] ``` Implementation Guidelines Make sure to handle edge cases such as: - A list with a single element. - Lists where no continuous increasing subarray longer than one element exists.","solution":"from typing import List def longest_increasing_subarray(temps: List[int]) -> List[int]: if len(temps) == 0: return [] max_len = 1 max_start_index = 0 current_len = 1 current_start_index = 0 for i in range(1, len(temps)): if temps[i] > temps[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start_index = current_start_index current_len = 1 current_start_index = i if current_len > max_len: max_len = current_len max_start_index = current_start_index return temps[max_start_index:max_start_index + max_len]"},{"question":"# Question: Implement Matrix Transpose Function You are tasked with implementing a function that transposes a given matrix. Function: `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` Implement a function that takes a 2D list (matrix) and returns its transpose. **Inputs:** * `matrix (List[List[int]])`: A 2D list representing a matrix of size m x n, where m and n can be any positive integer. **Outputs:** * `List[List[int]]`: The transposed matrix of size n x m. **Constraints:** * The input matrix will have at least one row and one column (i.e., m, n >= 1). * All rows in the matrix will have the same number of columns. Input Examples: - `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - `[[1, 2], [3, 4], [5, 6]]` Output Examples: - `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]` - `[[1, 3, 5], [2, 4, 6]]` # Requirements 1. Ensure the transposition preserves the data and structure of the original matrix such that every element in the original matrix is correctly relocated in the transposed matrix. 2. Efficiently handle matrices with a varying number of rows and columns without using extensive memory or time. 3. Handle edge cases where the input matrix has only one row or one column. Examples Example 1: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` Example 2: ```python >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` Write the implementation ensuring it fulfills the requirements and handles all edge cases appropriately.","solution":"def transpose_matrix(matrix): Returns the transpose of the given matrix. Params: matrix (List[List[int]]): A 2D list representing the original matrix Returns: List[List[int]]: The transposed matrix # Use zip to transpose the matrix transposed = [list(row) for row in zip(*matrix)] return transposed"},{"question":"# Data Stream Delimiter You are responsible for creating functions to manage a data stream that needs to be formatted with a specific delimiter. This delimiter-separated data will both need to be encoded into a single string and decoded back into its original components. # Task 1. **Encoding**: Write a function `encode_data(data: List[str], delimiter: str) -> str` that takes a list of strings and a delimiter, and returns a single string where each element from the list is concatenated with the delimiter separating them. 2. **Decoding**: Write a function `decode_data(encoded_data: str, delimiter: str) -> List[str]` that takes an encoded string and a delimiter, and returns the list of original strings. # Expected Input and Output Format Input: * For `encode_data(data: List[str], delimiter: str) -> str`: - `data` is a list of strings. - `delimiter` is a string used to separate each element in the `data` list. * For `decode_data(encoded_data: str, delimiter: str) -> List[str]`: - `encoded_data` is a single string containing elements separated by the `delimiter`. - `delimiter` is the string that separates the original elements in the encoded string. Output: * For `encode_data(data: List[str], delimiter: str) -> str`: - Should return a single string with elements from the list separated by the delimiter. * For `decode_data(encoded_data: str, delimiter: str) -> List[str]`: - Should return a list of strings extracted from the encoded data using the delimiter. # Constraints and Limitations - Ensure the delimiter is not part of any data elements to avoid ambiguity in encoding and decoding. - `data` list will have at least one string, and its elements will not be empty. - Delimiter will be a non-empty string. - The `encoded_data` will always contain the delimiter to ensure proper splitting. # Example Example 1: ```python assert encode_data([\\"red\\", \\"blue\\", \\"green\\"], \\",\\") == \\"red,blue,green\\" assert decode_data(\\"red,blue,green\\", \\",\\") == [\\"red\\", \\"blue\\", \\"green\\"] ``` Example 2: ```python assert encode_data([\\"hello\\", \\"world\\", \\"python\\"], \\";\\") == \\"hello;world;python\\" assert decode_data(\\"hello;world;python\\", \\";\\") == [\\"hello\\", \\"world\\", \\"python\\"] ```","solution":"from typing import List def encode_data(data: List[str], delimiter: str) -> str: Encodes a list of strings into a single string with elements separated by a delimiter. Parameters: - data: List of strings - delimiter: Delimiting string Returns: - Encoded string return delimiter.join(data) def decode_data(encoded_data: str, delimiter: str) -> List[str]: Decodes a single string into a list of strings using a delimiter. Parameters: - encoded_data: Encoded string - delimiter: Delimiting string Returns: - Decoded list of strings return encoded_data.split(delimiter)"},{"question":"# Problem Statement You are given a string that contains a mix of letters, digits, and special characters. Your task is to reformat the string such that it separates the letters, digits, and special characters into three separate strings while preserving their original order. Return these three strings as a dictionary with keys \'letters\', \'digits\', and \'specials\'. # Function Signature ```python def reformat_string(s: str) -> dict: ``` # Input * `s` (string): The input string (1 ≤ len(s) ≤ 10^6). # Output * A dictionary with three keys: - \'letters\': A string containing all the alphabetic characters in `s`. - \'digits\': A string containing all the numeric characters in `s`. - \'specials\': A string containing all the special characters in `s`. # Constraints * The input string can include any printable ASCII characters. # Examples ```python print(reformat_string(\\"a1b2@c3!\\")) # Output: {\'letters\': \'abc\', \'digits\': \'123\', \'specials\': \'@!\'} print(reformat_string(\\"hello123!@#\\")) # Output: {\'letters\': \'hello\', \'digits\': \'123\', \'specials\': \'!@#\'} print(reformat_string(\\"2022is@awesome!\\")) # Output: {\'letters\': \'isawesome\', \'digits\': \'2022\', \'specials\': \'@!\'} ``` # Explanation 1. In the first example, the function should return a dictionary with \'letters\': \'abc\', \'digits\': \'123\', and \'specials\': \'@!\'. 2. In the second example, the function should return a dictionary with \'letters\': \'hello\', \'digits\': \'123\', and \'specials\': \'!@#\'. 3. In the third example, the function should return a dictionary with \'letters\': \'isawesome\', \'digits\': \'2022\', and \'specials\': \'@!\'.","solution":"def reformat_string(s: str) -> dict: Separates the input string into letters, digits, and special characters. :param s: The input string containing a mix of letters, digits, and special characters. :return: A dictionary with keys \'letters\', \'digits\', and \'specials\'. letters = [] digits = [] specials = [] for char in s: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) else: specials.append(char) return { \'letters\': \'\'.join(letters), \'digits\': \'\'.join(digits), \'specials\': \'\'.join(specials) }"},{"question":"# Question: Analyze and Optimize Data Stream Processing You are given a function that processes a continuous data stream of integer values. The function computes the average of the last `n` integers, maintaining a fixed-size sliding window. Your task is to analyze the current implementation, optimize it to reduce time and space complexity, and ensure it can handle large data streams efficiently. # Requirements 1. **Function**: Implement the function `optimized_average(data_stream: Iterator[int], window_size: int) -> Iterator[float | None]`. 2. **Optimization**: Instead of recalculating the sum for each new integer in the stream, use an optimized approach to maintain the current sum and adjust it as the window slides. 3. **Edge Cases**: - Return `None` for data points that don’t have enough previous points to form a full window. - Raise a `ValueError` if the window size is not a positive integer. # Input - `data_stream`: An iterator that yields integer values from the data stream. - `window_size`: An integer representing the size of the sliding window (must be positive). # Output - An iterator yielding the average of the last `n` integers, or `None` if the window is incomplete. # Example Input: ```python data_stream = iter([4, 7, 2, 9, 5, 3, 6, 8]) window_size = 3 ``` Output: ```python [None, None, 4.33, 6.00, 5.33, 5.67, 4.67, 5.67] ``` # Additional Notes - Ensure the result should be rounded to two decimal places for consistency. - Consider using collections such as `deque` to maintain the sliding window efficiently. # Testing Include tests to validate the function, similar to the provided `doctest` format. Ensure your tests cover various edge cases, including empty inputs and small window sizes. ```python def test_optimized_average(): data_stream = iter([4, 7, 2, 9, 5, 3, 6, 8]) window_size = 3 assert list(optimized_average(data_stream, window_size)) == [None, None, 4.33, 6.00, 5.33, 5.67, 4.67, 5.67] data_stream = iter([10, 20, 30, 40, 50]) window_size = 2 assert list(optimized_average(data_stream, window_size)) == [None, 15.00, 25.00, 35.00, 45.00] data_stream = iter([1, 2, 3, 4, 5]) window_size = 1 assert list(optimized_average(data_stream, window_size)) == [1.00, 2.00, 3.00, 4.00, 5.00] # Edge case: empty input data_stream = iter([]) window_size = 3 assert list(optimized_average(data_stream, window_size)) == [] test_optimized_average() ```","solution":"from typing import Iterator, List, Optional from collections import deque def optimized_average(data_stream: Iterator[int], window_size: int) -> Iterator[Optional[float]]: if window_size <= 0: raise ValueError(\\"Window size must be a positive integer.\\") window = deque() current_sum = 0.0 for value in data_stream: window.append(value) current_sum += value if len(window) > window_size: current_sum -= window.popleft() if len(window) == window_size: yield round(current_sum / window_size, 2) else: yield None"},{"question":"# Problem Statement As a software engineer in a logistics company, you are creating a tool to manage delivery schedules. To ensure timely deliveries, it is crucial to identify overlapping schedules that might lead to delays. Write a Python function `find_overlaps` that takes a list of delivery schedules and returns a list of overlapping periods. Each schedule is represented by a tuple of two integers, `start` and `end`, indicating the delivery window in hours. # Input Format - A list of tuples where each tuple contains two integers representing the start and end times of a delivery schedule window. # Output Format - A list of tuples where each tuple contains two integers representing the start and end times of overlapping periods. If there are no overlaps, return an empty list. # Constraints - The start and end times will be integers, and their values will be within 0 and 24. - Start times will always be less than end times. # Example ```python # Example 1 schedules = [(1, 5), (4, 8), (10, 12), (11, 13)] print(find_overlaps(schedules)) # Output: [(4, 5), (11, 12)] # Example 2 schedules = [(0, 3), (4, 6), (7, 10)] print(find_overlaps(schedules)) # Output: [] # Example 3 schedules = [(1, 5), (2, 6), (7, 9), (8, 10)] print(find_overlaps(schedules)) # Output: [(2, 5), (8, 9)] ``` # Implementation Below is the provided code snippet and your task is to implement the `find_overlaps` function: ```python def find_overlaps(schedules): Find overlapping delivery schedule periods. :param schedules: List[Tuple[int, int]] - List of delivery schedules. :return: List[Tuple[int, int]] - List of overlapping periods. overlaps = [] schedules.sort() for i in range(len(schedules) - 1): current_start, current_end = schedules[i] next_start, next_end = schedules[i + 1] if current_end > next_start: overlaps.append((next_start, min(current_end, next_end))) return overlaps ```","solution":"def find_overlaps(schedules): Find overlapping delivery schedule periods. :param schedules: List[Tuple[int, int]] - List of delivery schedules. :return: List[Tuple[int, int]] - List of overlapping periods. overlaps = [] schedules.sort() for i in range(len(schedules) - 1): current_start, current_end = schedules[i] next_start, next_end = schedules[i + 1] if current_end > next_start: overlaps.append((next_start, min(current_end, next_end))) return overlaps"},{"question":"# Coding Assessment Question: Context: You are designing an application to manage a library of books. Part of this application requires importing book data from various sources, consolidating the information, and presenting it in a user-friendly format. The data sources may vary in structure, sometimes including nested information, different formats, and missing fields. Task: Implement a function called `consolidate_books_data` that takes multiple sources of book data as input and produces a consolidated list of books with the following details: - Title - Author - Publication Year - ISBN Number The function should: 1. Handle input data from multiple formats (e.g., JSON, XML, nested dictionaries). 2. Normalize the data fields to ensure consistency. 3. Handle missing fields gracefully by using default values. 4. Merge duplicate entries based on ISBN, preferring entries with more complete information. 5. Provide detailed docstrings and comments for clarity. Requirements: 1. Use standard Python libraries (e.g., `json`, `xml.etree.ElementTree`) for data parsing. 2. Implement robust error-handling mechanisms to address common data inconsistencies. 3. Optimize the function to handle large datasets efficiently. 4. Include unit tests to validate the function\'s correctness with various inputs. Expected Input and Output: **Input**: - `data_sources` (List): A list of dictionaries representing book data from various sources. Each dictionary can be in JSON or XML format, or a nested dictionary. **Output**: - A list of dictionaries, each representing a consolidated book entry with the fields: \\"Title\\", \\"Author\\", \\"Publication Year\\", \\"ISBN Number\\". Constraints: - Ensure the function can handle up to 100,000 book entries efficiently. - Handle cases where data fields are missing, incomplete, or embedded in nested structures. - Utilize dictionaries to cache intermediate results and avoid redundant processing. Example: ```python # Example Input data_sources = [ { \\"format\\": \\"json\\", \\"content\\": \'{\\"books\\":[{\\"title\\":\\"Book A\\",\\"author\\":\\"Author 1\\",\\"year\\":2020,\\"isbn\\":\\"1234\\"}]}\' }, { \\"format\\": \\"xml\\", \\"content\\": \'<library><book><title>Book A</title><author>Author 1</author><publication_year>2020</publication_year><isbn>1234</isbn></book></library>\' }, { \\"format\\": \\"dict\\", \\"content\\": {\\"books\\": [{\\"title\\": \\"Book B\\", \\"author\\": \\"Author 2\\", \\"isbn\\": \\"5678\\"}]} } ] # Example Output [ {\\"Title\\": \\"Book A\\", \\"Author\\": \\"Author 1\\", \\"Publication Year\\": 2020, \\"ISBN Number\\": \\"1234\\"}, {\\"Title\\": \\"Book B\\", \\"Author\\": \\"Author 2\\", \\"Publication Year\\": \\"Unknown\\", \\"ISBN Number\\": \\"5678\\"} ] ``` Implementation Notes: - Include helper functions to parse JSON, XML, and nested dictionary data. - Use a strategy to prefer entries with more complete data when merging duplicates. - Ensure the function handles edge cases such as deeply nested structures and different field naming conventions. Your code should be structured and documented to ensure maintainability and readability. To test the function, consider creating various mock data sources that reflect realistic data variability.","solution":"import json import xml.etree.ElementTree as ET def parse_json(data): Parse JSON data and return a list of books. parsed = json.loads(data) return parsed.get(\'books\', []) def parse_xml(data): Parse XML data and return a list of books. books = [] root = ET.fromstring(data) for book in root.findall(\'.//book\'): book_data = { \'title\': book.findtext(\'title\', default=\'Unknown\'), \'author\': book.findtext(\'author\', default=\'Unknown\'), \'year\': book.findtext(\'publication_year\', default=\'Unknown\'), \'isbn\': book.findtext(\'isbn\', default=\'Unknown\') } books.append(book_data) return books def parse_dict(data): Parse nested dictionary data and return a list of books. return data.get(\'books\', []) def normalize_book(book): Normalize book dictionary ensuring all fields are present. return { \'Title\': book.get(\'title\', \'Unknown\'), \'Author\': book.get(\'author\', \'Unknown\'), \'Publication Year\': book.get(\'year\', \'Unknown\'), \'ISBN Number\': book.get(\'isbn\', \'Unknown\') } def consolidate_books_data(data_sources): Consolidate book data from multiple sources. Parameters: - data_sources: List of dictionaries with \'format\' and \'content\' keys. Returns: - List of consolidated book dictionaries. books = {} for source in data_sources: format = source[\'format\'] content = source[\'content\'] if format == \'json\': parsed_books = parse_json(content) elif format == \'xml\': parsed_books = parse_xml(content) elif format == \'dict\': parsed_books = parse_dict(content) else: continue # Skip unknown format for book in parsed_books: normalized = normalize_book(book) isbn = normalized[\'ISBN Number\'] if isbn in books: existing = books[isbn] for key in [\'Title\', \'Author\', \'Publication Year\']: if existing[key] == \'Unknown\' and normalized[key] != \'Unknown\': existing[key] = normalized[key] else: books[isbn] = normalized return list(books.values())"},{"question":"# Problem Statement: You are given an array of integers where every element appears thrice except for one element which appears exactly once. Write a function to find that single one-time appearing element. Your solution should have a linear runtime complexity and use only constant extra space. # Input: * `List[int] nums`: An array of integers. # Output: * An `int` - the element that appears only once in the array. # Constraints: * The array has at least one element and the length of the array is equal to `3n + 1` where `n` is a non-negative integer. # Example: ```python # Example 1: # Input: [2, 2, 3, 2] # Output: 3 # Example 2: # Input: [0, 1, 0, 1, 0, 1, 99] # Output: 99 ``` # Notes: * Consider using bitwise operations to solve this problem optimally. * Think about how you can track the count of each bit across all numbers in the array. # Function Signature: ```python def single_number(nums: List[int]) -> int: # Implementation here ```","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the element that appears only once in an array where every other element appears thrice. ones, twos = 0, 0 for num in nums: # First, add num to \'twos\' if it\'s already in \'ones\' twos |= ones & num # Then, XOR num with \'ones\' ones ^= num # Calculate common bits between \'ones\' and \'twos\' (these bits should be reset in both ones and twos) common_bit_mask = ~(ones & twos) # Reset the common bits in both \'ones\' and \'twos\' ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Coding Assessment Question: Evaluate a Mathematical Expression Scenario: You are tasked with evaluating a mathematical expression given as a string. The expression can contain integers and the four basic arithmetic operations: addition, subtraction, multiplication, and division. Problem: Write a function called `evaluate_expression(expression: str) -> int` that takes a string `expression` containing a valid mathematical expression and returns the result as an integer. Input and Output Formats: * **evaluate_expression(expression: str) -> int**: Takes a string `expression` and returns an integer which is the result of the evaluated expression. Constraints: * The expression is guaranteed to be valid and non-empty. * The expression contains non-negative integers and the operators `+`, `-`, `*`, `/`. * The expression does not contain any parentheses. * Division should be treated as integer division (i.e., round towards zero). * Use appropriate data structures and algorithms to ensure the evaluation process maintains an overall average time complexity of O(n). Example Usage: ```python assert evaluate_expression(\\"3+2*2\\") == 7 assert evaluate_expression(\\"3/2\\") == 1 assert evaluate_expression(\\"3+5/2\\") == 5 assert evaluate_expression(\\"10+2*6\\") == 22 assert evaluate_expression(\\"100*2+12\\") == 212 assert evaluate_expression(\\"100*2/12\\") == 16 assert evaluate_expression(\\"100*(2/12)\\") == 0 # Multiplication has higher precedence so 2/12 is evaluated first ``` Implementation: Implement the function to parse and evaluate the expression, considering operation precedence and handling integer division as specified.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string and returns the result as an integer. def helper(s): stack = [] num = 0 sign = \'+\' i = 0 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) if char in \'+-*/\' or i == len(s) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': top = stack.pop() if top < 0: stack.append(-(-top // num)) else: stack.append(top // num) sign = char num = 0 i += 1 return sum(stack) return helper(expression)"},{"question":"# Coding Assessment Question Context You are tasked with creating a utility for managing a simple task scheduling system. This system will involve scheduling tasks with specific durations and calculating when all tasks will be completed. Objective Your goal is to write a function that takes a list of task durations and calculates the total time required to complete all tasks when they are executed sequentially. Requirements 1. Implement the function `total_schedule_time(durations: list[int]) -> int` which takes a list of integers representing the durations of the tasks. 2. Ensure the function correctly sums up the durations to calculate the total time required. 3. The function should handle edge cases such as an empty list of durations by returning zero. Constraints * All durations will be non-negative integers. * The total number of tasks will not exceed 1000. * Each task duration is at most 1000 units of time. Examples ```python def total_schedule_time(durations: list[int]) -> int: # Your implementation here pass # Example usage and results assert total_schedule_time([1, 2, 3, 4]) == 10 assert total_schedule_time([5, 5, 5, 5, 5]) == 25 assert total_schedule_time([]) == 0 assert total_schedule_time([10]) == 10 ``` Notes: * The function should simply sum up all the task durations provided in the list. * Consider edge cases such as an empty list or very large durations within the allowed constraints.","solution":"def total_schedule_time(durations: list[int]) -> int: Returns the total time required to complete all tasks. :param durations: List of task durations. :return: Total time to complete all tasks. return sum(durations)"},{"question":"# Problem Statement: Time Slot Merger Context You are working on a scheduling application that helps coordinate meeting times for international teams. One of the features of the application is to merge overlapping and adjacent time slots to provide a consolidated schedule. This ensures that the schedule is manageable and avoids redundant time slots. Task Implement the function `merge_time_slots(time_slots: list) -> list` that merges overlapping or adjacent time slots into one continuous time slot. Function signature ```python def merge_time_slots(time_slots: list) -> list: ``` Input - `time_slots`: A list of tuples, where each tuple contains two integers representing the start and end times of a time slot. The times are in 24-hour format (e.g., 13 for 1 PM). The list may have any number of time slots, and the times are given in hours (e.g., (9, 11) for a slot from 9 AM to 11 AM). The end time is always greater than the start time within each slot. Output - A list of merged time slots represented as tuples. If two time slots overlap or are adjacent (the end time of one is the start time of the other), they should be merged into one. The merged list should be sorted by start times. Constraints 1. The maximum number of time slots is 10,000. 2. All times are given in integer hours from 0 to 24 (exclusive). 3. If the `time_slots` list is empty, return an empty list. Examples ```python merge_time_slots([(9, 11), (13, 14), (12, 13)]) # Output: [(9, 11), (12, 14)] merge_time_slots([(8, 10), (9, 11), (15, 18), (12, 14)]) # Output: [(8, 11), (12, 14), (15, 18)] merge_time_slots([(9, 12), (11, 14), (13, 15)]) # Output: [(9, 15)] merge_time_slots([(10, 12), (14, 16), (18, 20)]) # Output: [(10, 12), (14, 16), (18, 20)] merge_time_slots([]) # Output: [] ``` Explanation 1. For the first example, the time slots `(13, 14)` and `(12, 13)` can be merged into `(12, 14)` since they are adjacent. 2. In the second example, the time slots `(8, 10)` and `(9, 11)` overlap and are merged into `(8, 11)`. 3. The third example shows multiple overlaps, merging into a single slot `(9, 15)`. 4. The fourth example shows that non-overlapping time slots remain as they are. 5. The last example handles an empty input list by returning an empty list.","solution":"def merge_time_slots(time_slots): Merges overlapping or adjacent time slots into one continuous time slot. :param time_slots: List of tuples representing time slots. :returns: List of merged time slots sorted by start time. if not time_slots: return [] # Sort time slots by the start time time_slots.sort() merged_slots = [time_slots[0]] for current_start, current_end in time_slots[1:]: last_start, last_end = merged_slots[-1] # Check if the current time slot overlaps or is adjacent to the last one in merged_slots if current_start <= last_end: # Overlapping or adjacent merged_slots[-1] = (last_start, max(last_end, current_end)) else: merged_slots.append((current_start, current_end)) return merged_slots"},{"question":"# Log Analyzer for Application Errors You are tasked with creating a log analyzer that processes and summarizes application error logs. The logs are provided in a text file where each line is a JSON object representing an individual log entry. Requirements: 1. **Function Definition**: ```python def analyze_logs(file_path: str) -> dict: ``` 2. **Input**: * `file_path` (str): The path to the log file. 3. **Output**: * Return a dictionary with the following keys: - `total_entries`: Total number of log entries processed. - `error_counts`: A dictionary where keys are error codes and values are the count of occurrences of each error code. - `most_common_error`: The error code that appears the most frequently, and the number of times it appears. 4. **Constraints**: * Assume each log entry is a valid JSON object. * Each log entry JSON object contains a field `error_code` which is a string representing an error code. * If the log file is empty or no error codes are present, handle gracefully. Example: **Content of `logs.txt`**: ```json {\\"timestamp\\": \\"2023-10-01T12:00:00Z\\", \\"error_code\\": \\"ERR001\\", \\"message\\": \\"Null pointer exception\\"} {\\"timestamp\\": \\"2023-10-01T12:05:00Z\\", \\"error_code\\": \\"ERR002\\", \\"message\\": \\"Index out of range\\"} {\\"timestamp\\": \\"2023-10-01T12:10:00Z\\", \\"error_code\\": \\"ERR001\\", \\"message\\": \\"Null pointer exception\\"} {\\"timestamp\\": \\"2023-10-01T12:15:00Z\\", \\"error_code\\": \\"ERR003\\", \\"message\\": \\"Database connection error\\"} ``` **Calling `analyze_logs(\\"logs.txt\\")` should return**: ```python { \\"total_entries\\": 4, \\"error_counts\\": { \\"ERR001\\": 2, \\"ERR002\\": 1, \\"ERR003\\": 1 }, \\"most_common_error\\": (\\"ERR001\\", 2) } ``` Implementation Tips: * Use Python\'s built-in modules such as `json` for parsing log entries. * Consider edge cases such as empty log files or missing `error_code` fields. * Handle file I/O exceptions appropriately. # Testing: To test the function, create a sample log file with varied error codes and ensure the function correctly counts and identifies the most frequent error. You may also test with log files containing hundreds of entries to verify performance.","solution":"import json from collections import defaultdict def analyze_logs(file_path: str) -> dict: total_entries = 0 error_counts = defaultdict(int) try: with open(file_path, \'r\') as file: for line in file: total_entries += 1 log_entry = json.loads(line) if \'error_code\' in log_entry: error_counts[log_entry[\'error_code\']] += 1 if not error_counts: most_common_error = None else: most_common_error = max(error_counts.items(), key=lambda item: item[1]) return { \\"total_entries\\": total_entries, \\"error_counts\\": dict(error_counts), \\"most_common_error\\": most_common_error } except FileNotFoundError: return { \\"total_entries\\": 0, \\"error_counts\\": {}, \\"most_common_error\\": None } except json.JSONDecodeError: return { \\"total_entries\\": total_entries, \\"error_counts\\": dict(error_counts), \\"most_common_error\\": None }"},{"question":"# Subarray Sum Challenge Context You are developing a function to facilitate analysis of numerical data. The function should determine whether there exists a contiguous subarray within a given array that sums to a specified target value. Objective Write a function: 1. `subarray_sum(nums: list, target: int) -> bool`: This function checks if there is a contiguous subarray in the list `nums` that sums to the `target`. Detailed Requirements 1. **Function: subarray_sum** * **Input**: A list of integers `nums` and an integer `target`. * **Output**: A boolean value. * **Constraints**: - The input list should be non-empty. - Raise a `ValueError` for invalid input (non-list for `nums`, non-integer for `target`, or empty list). * **Description**: - The function should return `True` if there is at least one contiguous subarray that sums to the given `target`, and `False` otherwise. - Optimize the function to handle large lists efficiently. Example Usage ```python print(subarray_sum([1, 2, 3, 4], 6)) # True, as [2, 3, 1] sums to 6 print(subarray_sum([1, 2, 3, 4], 10)) # True, as [1, 2, 3, 4] sums to 10 print(subarray_sum([1, 2, 3, 4], 11)) # False, no subarray sums to 11 print(subarray_sum([-1, 1, 2, 3, -2], 3)) # True, as [1, 2, 3, -2, -1] sums to 3 ``` Constraints * You must handle different types of inputs robustly, including invalid and edge cases. * Ensure that the implementation is efficient and accurate for large input arrays. * Aim for a time complexity not higher than O(n), where n is the length of the array. Good luck!","solution":"def subarray_sum(nums, target): Returns True if there is at least one contiguous subarray that sums to the given target, otherwise returns False. Raises ValueError for invalid input. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums) or not isinstance(target, int): raise ValueError(\\"Invalid input.\\") if not nums: raise ValueError(\\"List must be non-empty.\\") cumulative_sum = 0 sums_map = {0: 1} # To handle the case when subarray starts from index 0 for num in nums: cumulative_sum += num if cumulative_sum - target in sums_map: return True sums_map[cumulative_sum] = sums_map.get(cumulative_sum, 0) + 1 return False"},{"question":"# Problem Statement You are given a list of integers where every element appears exactly three times, except for one element which appears exactly once. Your task is to find and return the element that appears only once. The computational efficiency is crucial, so aim to implement a solution with linear runtime complexity. # Function Signature ```python def find_unique_element(nums: list) -> int: Given a list of integers where every element appears three times except for one element which appears only once, this function should return the unique element that appears only once. :param nums: A list of integers where all elements except one appear exactly three times. :return: The unique integer that appears only once. pass ``` # Input * A list `nums` of integers, where the length of the list is at least 4 and no more than 10000. All integers are within the range of 32-bit signed integers. # Output * An integer that represents the unique element that appears only once in the list. # Constraints * The list `nums` will have a length between `4` and `10000` inclusive. * Every element in `nums` appears exactly three times except for one element which appears only once. # Example ```python assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_element([-1, -1, -1, -2]) == -2 assert find_unique_element([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` # Notes * Consider both time and space complexity. Try to achieve a solution that has O(n) time complexity and O(1) space complexity if possible. * Bit manipulation might be a useful approach to solve this problem efficiently.","solution":"def find_unique_element(nums: list) -> int: Given a list of integers where every element appears three times except for one element which appears only once, this function should return the unique element that appears only once. :param nums: A list of integers where all elements except one appear exactly three times. :return: The unique integer that appears only once. x1, x2 = 0, 0 for num in nums: x2 ^= x1 & num x1 ^= num mask = ~(x1 & x2) x1 &= mask x2 &= mask return x1"},{"question":"# Coding Assessment Question Context and Scenario: As a software developer, you are tasked with creating a customer rewards program for an online retail store. Customers accumulate points based on their purchases, and these points are stored in a list. Occasionally, the points list requires updates for adding new customers or updating existing customers\' points. Task: 1. **Function 1: Update Points** Write a function `update_points(points_list, customer_id, points)` that updates the points for a given `customer_id`. If the `customer_id` already exists in the `points_list`, it should update the points. If the `customer_id` does not exist, it should add the `customer_id` with the given points while maintaining the list sorted by `customer_id`. ```python def update_points(points_list: list[tuple[int, int]], customer_id: int, points: int) -> None: Update the points for a customer. If the customer_id exists, update the points. If not, add the customer_id with points to the list while maintaining the order. :param points_list: A list of tuples where each tuple contains a customer_id and their points. :param customer_id: The id of the customer. :param points: The points to be assigned to the customer. pass ``` **Example:** ```python points_list = [(101, 150), (102, 300), (103, 200)] update_points(points_list, 104, 250) print(points_list) # Output: [(101, 150), (102, 300), (103, 200), (104, 250)] update_points(points_list, 102, 350) print(points_list) # Output: [(101, 150), (102, 350), (103, 200), (104, 250)] ``` 2. **Function 2: Find Customer Points** Write a function `find_customer_points(points_list, customer_id)` that returns the points for the given `customer_id` from the `points_list`. If the `customer_id` is not found, it should return -1. ```python def find_customer_points(points_list: list[tuple[int, int]], customer_id: int) -> int: Retrieves the points for a given customer_id from the points list. :param points_list: A list of tuples where each tuple contains a customer_id and their points. :param customer_id: The id of the customer to search for. :return: The points of the customer if found, otherwise -1. pass ``` **Example:** ```python points_list = [(101, 150), (102, 300), (103, 200), (104, 250)] points = find_customer_points(points_list, 103) print(points) # Output: 200 points = find_customer_points(points_list, 105) print(points) # Output: -1 ``` Constraints: - The `points_list` contains tuples of `(customer_id, points)` sorted by `customer_id` in ascending order. - Customer ids are unique integers. - Ensure that the update and search operations handle edge cases, such as an empty list or invalid customer ids. - Your implementation should maintain the sorted order of the list after updates. - You are not allowed to use Python’s built-in `bisect` module functions directly in your implementation but can use the provided code snippets for handling sorted insertions and searches. Performance Requirements: - The `update_points` function should efficiently handle updates on lists with sizes up to (10^6) elements. - The `find_customer_points` function should be able to search through lists with up to (10^6) elements efficiently.","solution":"def update_points(points_list: list[tuple[int, int]], customer_id: int, points: int) -> None: Update the points for a customer. If the customer_id exists, update the points. If not, add the customer_id with points to the list while maintaining the order. :param points_list: A list of tuples where each tuple contains a customer_id and their points. :param customer_id: The id of the customer. :param points: The points to be assigned to the customer. for i, (cid, _) in enumerate(points_list): if cid == customer_id: points_list[i] = (customer_id, points) return if cid > customer_id: points_list.insert(i, (customer_id, points)) return points_list.append((customer_id, points)) def find_customer_points(points_list: list[tuple[int, int]], customer_id: int) -> int: Retrieves the points for a given customer_id from the points list. :param points_list: A list of tuples where each tuple contains a customer_id and their points. :param customer_id: The id of the customer to search for. :return: The points of the customer if found, otherwise -1. for cid, points in points_list: if cid == customer_id: return points return -1"},{"question":"Linked List Reversal Groups You are provided with a linked list and asked to reverse the nodes of the list k at a time. If the number of nodes is not a multiple of k, then the last remaining nodes should remain as they are. Implement a function `reverseKGroup` that takes as input the head of a linked list and an integer k, and returns the head of the modified list. The `ListNode` class is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Requirements: - Reverse the nodes of the list k at a time and return the head of the updated list. - The function should have a time complexity of O(n), where n is the number of nodes in the linked list. - Assume the list has at least one node and 1 <= k <= n. # Function Signature: ```python def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverses the nodes of the linked list k at a time. Parameters: head (ListNode): The head node of the linked list. k (int): The number of nodes in each group to reverse. Returns: ListNode: The head node of the modified linked list. # Your implementation goes here. ``` # Example Use: ```python # Helper function to create linked list from list for testing def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head # Helper function to display linked list for testing def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result # Example testing ll = create_linked_list([1, 2, 3, 4, 5]) k = 2 new_head = reverseKGroup(ll, k) print(linked_list_to_list(new_head)) # Output should be [2, 1, 4, 3, 5] ll = create_linked_list([1, 2, 3, 4, 5]) k = 3 new_head = reverseKGroup(ll, k) print(linked_list_to_list(new_head)) # Output should be [3, 2, 1, 4, 5] ``` # Constraints: - The linked list can have a length from 1 to 10^3. - The value of each node is unique and within the range of -10^3 to 10^3. # Performance: - The algorithm should have a linear time complexity O(n), where n is the number of nodes in the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while ptr and count < k: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"# Introduction You have been assigned to manage the configuration files for a large-scale software system. These configuration files hold values that dictate the behavior of different modules in the system. One common task is to merge the configuration values from multiple sources into a single cohesive configuration. # Problem Write a function `merge_config(config1: dict, config2: dict) -> dict` that merges two configuration dictionaries. In the merged configuration: - If a key appears in both `config1` and `config2`, the value from `config2` should take precedence. - If a key only appears in one of the dictionaries, its value should be included in the result. # Function Signature ```python def merge_config(config1: dict, config2: dict) -> dict: ``` # Input The input consists of two dictionaries, `config1` and `config2`, each representing a set of configuration values. Each dictionary\'s keys are strings and values can be any valid JSON data types: numbers, strings, lists, or nested dictionaries. # Output The function should return a single dictionary representing the merged configuration. # Constraints 1. Keys and values in the dictionaries can be of any type supported by JSON format (including nested dictionaries). 2. The merged dictionary must maintain nesting and handle deeply nested structures correctly. # Examples ```python config1 = { \\"version\\": 1, \\"logging\\": { \\"level\\": \\"info\\", \\"handlers\\": [\\"console\\"] }, \\"features\\": { \\"beta\\": True } } config2 = { \\"version\\": 2, \\"logging\\": { \\"level\\": \\"debug\\", \\"path\\": \\"/var/log/app.log\\" }, \\"features\\": { \\"release\\": True } } result = { \\"version\\": 2, \\"logging\\": { \\"level\\": \\"debug\\", \\"handlers\\": [\\"console\\"], \\"path\\": \\"/var/log/app.log\\" }, \\"features\\": { \\"beta\\": True, \\"release\\": True } } assert merge_config(config1, config2) == result ``` Make sure your solution handles nested structures and correctly merges configurations according to the rules specified.","solution":"def merge_config(config1: dict, config2: dict) -> dict: Merges two dictionaries, with values from config2 taking precedence if the same key exists in both. Handles nested dictionaries by recursively merging them. def merge(dict1, dict2): merged = dict1.copy() # start with a copy of the first dictionary for key, value in dict2.items(): if key in merged and isinstance(merged[key], dict) and isinstance(value, dict): merged[key] = merge(merged[key], value) else: merged[key] = value return merged return merge(config1, config2)"},{"question":"# Problem Statement Create a function that performs a breadth-first traversal (BFS) of a binary tree and returns a list of values representing nodes visited at each level from top to bottom. # Specifications * **Function**: `bfs_traversal(root: Optional[TreeNode]) -> list[list[int]]` * **Input**: A `TreeNode` representing the root of a binary tree. * **Output**: A list of lists, where each sublist represents the nodes at each level of the binary tree. # Definitions * The function should handle an empty tree (i.e., when `root` is `None`) and return an empty list in such cases. * The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Constraints * The number of nodes in the tree will not exceed `10^4`. * Each node\'s value is an integer within the range `[-10^5, 10^5]`. # Example ```python # Given the following binary tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) # After running bfs_traversal on the given tree result = bfs_traversal(root) # result should be [[3], [9, 20], [15, 7]] ``` # Notes * Implement your BFS algorithm to efficiently traverse the tree level-by-level. * Ensure your solution handles both large and small tree structures effectively, while maintaining clarity and correctness.","solution":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bfs_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Question: Implement Breadth-First Search (BFS) for a Graph You are given a graph represented as an adjacency list. Your task is to implement the Breadth-First Search (BFS) algorithm to traverse the graph starting from a given node. # Function Signature ```python def bfs_traversal(graph: Dict[Any, List[Any]], start_node: Any) -> List[Any]: pass ``` # Input - `graph` (Dict[Any, List[Any]]): A dictionary representation of the graph where keys are nodes and values are lists of adjacent nodes. - `start_node` (Any): The node from which the BFS traversal starts. # Output - Returns a list containing the nodes in the order they are visited during the BFS traversal. # Constraints - The graph is represented as a dictionary where each key is a node, and its value is a list of nodes representing the edges. - There are no parallel edges or loops. - Node values are unique and may be of any hashable type (e.g., int, str). - The graph can contain up to 1000 nodes. # Requirements - Implement the Breadth-First Search algorithm iteratively using a queue. - Handle disconnected graphs by returning only the nodes reachable from the start node. # Performance - Aim for an efficient implementation with respect to time and space complexity, considering the given constraints. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start_node = \'A\' print(bfs_traversal(graph, start_node)) # Output: [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ``` # Note - Ensure you thoroughly test your function with various edge cases such as an empty graph, a graph with a single node, and a graph where the start node has no connections.","solution":"from collections import deque from typing import Dict, List, Any def bfs_traversal(graph: Dict[Any, List[Any]], start_node: Any) -> List[Any]: Perform Breadth-First Search (BFS) on the graph starting from `start_node`. Args: graph (Dict[Any, List[Any]]): The adjacency list for the graph. start_node (Any): The node from which the BFS traversal starts. Returns: List[Any]: The list of nodes in the order they are visited during BFS traversal. if start_node not in graph: return [] visited = set() queue = deque([start_node]) bfs_order = [] while queue: current_node = queue.popleft() if current_node not in visited: visited.add(current_node) bfs_order.append(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append(neighbor) return bfs_order"},{"question":"E-Commerce Order Processing **Context**: You are responsible for managing an order processing system for an e-commerce company. Each order contains multiple items, and you need to ensure that the orders are processed correctly by calculating the total price for each order, including any applicable discounts. **Task**: Write a Python function named `process_order(order: dict) -> float` that performs the following tasks: 1. Loop through each item in the order. 2. Calculate the total price for each item by multiplying the quantity by the unit price. 3. Apply the appropriate discount if the quantity of an item exceeds a certain threshold: - If the quantity is greater than or equal to 10, apply a 10% discount. - If the quantity is greater than or equal to 20, apply a 20% discount. 4. Sum the total prices of all items to get the overall total for the order. 5. Return the total price as a float. **Constraints**: - The function should handle orders with any number of items. - Each item in the order is a dictionary with keys `name` (str), `quantity` (int), and `unit_price` (float). - Ensure to round the final total price to 2 decimal places for currency formatting. **Input**: - `order` (dict): A dictionary representing the order, where each entry is an item with the structure: ```python { \\"name\\": \\"...\\", \\"quantity\\": ..., \\"unit_price\\": ... } ``` **Output**: - `float`: The total price of the order after applying any discounts. **Example**: Given an order with the following items: ```python order = [ {\\"name\\": \\"Widget A\\", \\"quantity\\": 5, \\"unit_price\\": 10.00}, {\\"name\\": \\"Widget B\\", \\"quantity\\": 12, \\"unit_price\\": 20.00}, {\\"name\\": \\"Widget C\\", \\"quantity\\": 25, \\"unit_price\\": 15.00} ] ``` The function should return: ```python 560.00 ``` # Instructions: 1. Your function should iterate through the list of items and calculate each item\'s total cost considering the quantity and unit price. 2. Apply appropriate discounts based on the quantity. 3. Accumulate the total cost of all items. 4. Return the overall total rounded to 2 decimal places.","solution":"def process_order(order: list) -> float: Calculates the total price for an order, including quantity-based discounts. Args: order (list): A list of dictionaries, each containing \'name\', \'quantity\', and \'unit_price\' keys. Returns: float: The total price of the order rounded to 2 decimal places. total_price = 0.0 for item in order: quantity = item[\'quantity\'] unit_price = item[\'unit_price\'] price = quantity * unit_price if quantity >= 20: discount = 0.20 elif quantity >= 10: discount = 0.10 else: discount = 0.0 price -= price * discount total_price += price return round(total_price, 2)"},{"question":"# Question: Implement a Basic Calculator with Precedence Description Design a basic calculator that evaluates a string expression containing non-negative integers, addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and parentheses (`(`, `)`). The operations should respect the precedence of arithmetic operators as well as handle nested parentheses appropriately. Function Signature ```python def calculate(expression: str) -> int: pass ``` Input - `expression` (str): A valid arithmetic expression string containing non-negative integers and the operators `+`, `-`, `*`, `/`, and parentheses. The length of the expression will not exceed 1000 characters. Output - Returns the result as an integer after evaluating the expression. Constraints 1. The integer division should truncate toward zero (e.g., `7 / 3 = 2` and `-7 / 3 = -2`). 2. The expression is guaranteed to be a valid arithmetic expression. 3. The expression only contains non-negative integers. Example ```python expression = \\"3+(2*2)\\" result = calculate(expression) print(result) # Expected output: 7 expression = \\" 3/2 \\" result = calculate(expression) print(result) # Expected output: 1 expression = \\" 3+5 / 2 \\" result = calculate(expression) print(result) # Expected output: 5 ``` Performance Requirements - Your solution should efficiently evaluate the arithmetic expression in a manner that handles nested parentheses and operator precedence correctly. Note - Avoid using Python\'s `eval` function for security reasons. - Ensure that the solution handles whitespace appropriately and ignores any extra spaces in the input expression. - Use a stack-based approach to handle nested expressions and operator precedence effectively.","solution":"def calculate(expression: str) -> int: def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # python division to truncate toward zero def evaluate(expression): i = 0 operators = [] values = [] while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: # operator while (len(operators) != 0 and operators[-1] != \'(\' and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1] result = evaluate(expression) return result"},{"question":"# Question on Text Search and Pattern Matching Context Text search and pattern matching are fundamental operations in string manipulation, widely used in tasks such as text editing, data validation, and natural language processing. One common technique is the Knuth-Morris-Pratt (KMP) algorithm, which efficiently searches for occurrences of a pattern within a text. Task Implement the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of a pattern string within a given text string. Your function should return the starting indices of each match. Function Requirements 1. **Function Signature**: ```python def kmp_search(pattern: str, text: str) -> list: ``` 2. **Parameters**: * `pattern` (str): The pattern string to search for. * `text` (str): The text string in which to search for the pattern. 3. **Return Value**: * `indices` (list): A list of starting indices where the pattern is found in the text. Constraints * The pattern and text strings will both be non-empty. * The function should handle edge cases where the pattern does not exist within the text. * Both `pattern` and `text` strings may contain spaces and special characters. * The solution should be efficient and operate in linear time complexity relative to the length of the text. Performance Requirements Your implementation should efficiently handle large text inputs, ensuring optimal performance for texts with lengths up to 10^6 characters. Example Consider the text `ababcabcabababd` and the pattern `ababd`. ```python pattern = \\"ababd\\" text = \\"ababcabcabababd\\" indices = kmp_search(pattern, text) # indices should be [10] ``` Submit your implementation of the `kmp_search` function below:","solution":"def kmp_search(pattern: str, text: str) -> list: Implements the Knuth-Morris-Pratt (KMP) string matching algorithm. Returns a list of starting indices where the pattern is found in the text. def compute_lps_array(pattern: str) -> list: Compute the longest prefix which is also suffix (lps) array for pattern. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 return lps m = len(pattern) n = len(text) lps = compute_lps_array(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Swapping Nodes in a Linked List You are given a singly linked list and two integers `k1` and `k2`. Your task is to create a function that swaps the nodes at the `k1`-th and `k2`-th positions (1-based index). # Task Write a function `swap_nodes` that swaps the nodes at the given positions. Input: The function has three parameters: 1. `head`: the head node of the singly linked list. 2. `k1`: an integer representing the position of the first node to swap. 3. `k2`: an integer representing the position of the second node to swap. The linked list node is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output: Return the head node of the modified linked list. # Constraints: - The linked list will have at least two nodes. - `1 <= k1, k2 <= length of the linked list` - `k1` and `k2` are valid indices in the linked list (1-based). # Example ```python # Example usage: # Helper function to convert list to linked list for easier testing def list_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list for easier testing def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result # Creating a linked list: 1 -> 2 -> 3 -> 4 -> 5 head = list_to_linked_list([1, 2, 3, 4, 5]) k1 = 2 k2 = 4 # Apply the swap function head = swap_nodes(head, k1, k2) # Convert the modified linked list back to a list to check the result print(linked_list_to_list(head)) # Output: [1, 4, 3, 2, 5] ``` Use the following template to implement the solution: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_nodes(head, k1, k2): if k1 == k2: return head node1_prev = node2_prev = None node1 = node2 = head current = head position = 1 while current: if position + 1 == k1: node1_prev = current if position + 1 == k2: node2_prev = current if position == k1: node1 = current if position == k2: node2 = current current = current.next position += 1 if node1_prev: node1_prev.next = node2 else: head = node2 if node2_prev: node2_prev.next = node1 else: head = node1 node1.next, node2.next = node2.next, node1.next return head ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_nodes(head, k1, k2): if k1 == k2: return head node1_prev = node2_prev = None node1 = node2 = head current = head position = 1 while current: if position + 1 == k1: node1_prev = current if position + 1 == k2: node2_prev = current if position == k1: node1 = current if position == k2: node2 = current current = current.next position += 1 if node1_prev: node1_prev.next = node2 else: head = node2 if node2_prev: node2_prev.next = node1 else: head = node1 node1.next, node2.next = node2.next, node1.next return head"},{"question":"# Coding Assessment Question Objective: To demonstrate your understanding of sorting algorithms and their applications, you need to implement a function that sorts a list of strings containing numerical values as though the numbers were integers. Scenario: You are working on a data processing application that receives lists of numerical values in string format. These need to be sorted in ascending order as integers, not lexicographically. Implement a function to achieve this task efficiently. Requirements: 1. **Function Name**: `sort_numeric_strings` 2. **Input**: A list of strings, `num_strings` (1 ≤ len(num_strings) ≤ 1000), where each string represents a non-negative integer (0 ≤ each number ≤ 10^9). 3. **Output**: A list of strings sorted in ascending order based on their integer values. 4. **Constraints**: Your algorithm should correctly handle the provided input size and variations. 5. **Performance**: Aim for a sorting algorithm with an average time complexity of O(n log n). Example: ```python >>> sort_numeric_strings([\\"10\\", \\"1\\", \\"3\\", \\"20\\"]) [\'1\', \'3\', \'10\', \'20\'] >>> sort_numeric_strings([\\"5\\", \\"7\\", \\"2\\", \\"9\\", \\"0\\"]) [\'0\', \'2\', \'5\', \'7\', \'9\'] >>> sort_numeric_strings([\\"100\\", \\"21\\", \\"31\\", \\"4\\", \\"15\\"]) [\'4\', \'15\', \'21\', \'31\', \'100\'] >>> sort_numeric_strings([\\"1000\\", \\"5000\\", \\"999\\", \\"10000\\", \\"123\\"]) [\'123\', \'999\', \'1000\', \'5000\', \'10000\'] ``` Edge Cases to Consider: - Lists containing numbers with the same length but different values (e.g., `[\\"10\\", \\"2\\"]`). - Lists with numbers of varying lengths. - Lists with only one or a few elements. - Ensure that the function handles very large numerical values represented as strings. ```python def sort_numeric_strings(num_strings): # Your implementation here pass # Test cases print(sort_numeric_strings([\\"10\\", \\"1\\", \\"3\\", \\"20\\"])) # Expected: [\'1\', \'3\', \'10\', \'20\'] print(sort_numeric_strings([\\"5\\", \\"7\\", \\"2\\", \\"9\\", \\"0\\"])) # Expected: [\'0\', \'2\', \'5\', \'7\', \'9\'] print(sort_numeric_strings([\\"100\\", \\"21\\", \\"31\\", \\"4\\", \\"15\\"])) # Expected: [\'4\', \'15\', \'21\', \'31\', \'100\'] print(sort_numeric_strings([\\"1000\\", \\"5000\\", \\"999\\", \\"10000\\", \\"123\\"])) # Expected: [\'123\', \'999\', \'1000\', \'5000\', \'10000\'] ```","solution":"def sort_numeric_strings(num_strings): Sorts a list of strings containing numerical values as integers. Args: num_strings (List[str]): A list of strings where each string represents a non-negative integer. Returns: List[str]: A list of strings sorted in ascending order based on their integer values. return sorted(num_strings, key=int)"},{"question":"# Coding Assessment Question Scenario You are part of a team developing a recommendation system for an online bookstore. The system needs to generate book recommendations based on user ratings. Each book can be recommended if it falls within a specified rating range. Your task is to develop a function that filters lists of book ratings and returns only those which fit within a specified range. Additionally, ensure that your solution is optimized for large input sizes. Task Write a function named `filter_ratings` which takes a list of floats `ratings` representing book ratings and two floats `min_rating` and `max_rating`. Your function should return a new list containing only the ratings that fall between `min_rating` and `max_rating` inclusive. # Function Signature ```python def filter_ratings(ratings: list[float], min_rating: float, max_rating: float) -> list[float]: ``` # Input * `ratings` - A list of float numbers representing book ratings (1 <= len(ratings) <= 10^5, 0.0 <= ratings[i] <= 5.0). * `min_rating` - A float representing the minimum rating threshold (0.0 <= min_rating <= max_rating <= 5.0). * `max_rating` - A float representing the maximum rating threshold (0.0 <= min_rating <= max_rating <= 5.0). # Output * A list of floats representing the ratings that fall within the specified range [min_rating, max_rating] inclusive. # Constraints * Ensure the input ratings list and the resulting filtered list are efficiently managed. * Validate that `min_rating` is less than or equal to `max_rating`. If not, raise a `ValueError`. # Example ```python >>> filter_ratings([4.5, 3.2, 1.0, 4.8, 2.9, 3.7, 5.0, 2.2], 3.0, 4.5) [4.5, 3.2, 3.7] >>> filter_ratings([0.5, 1.5, 2.5, 3.5, 4.5, 5.0], 1.0, 3.0) [1.5, 2.5] >>> filter_ratings([0.8, 2.3, 1.1, 1.8, 0.0], 2.0, 4.0) [2.3] ``` Performance Requirements Your implementation should efficiently handle the upper limits of the constraints. Consider edge cases such as very narrow rating ranges or extremely large lists. Additionally, ensure that invalid inputs are correctly handled by raising appropriate exceptions.","solution":"def filter_ratings(ratings, min_rating, max_rating): Filters the ratings that fall within the inclusive range of min_rating and max_rating. Args: ratings (list of float): List of book ratings. min_rating (float): Minimum rating threshold. max_rating (float): Maximum rating threshold. Returns: list of float: The filtered list of ratings within the specified range. Raises: ValueError: If min_rating is greater than max_rating. if min_rating > max_rating: raise ValueError(\\"min_rating must be less than or equal to max_rating\\") return [rating for rating in ratings if min_rating <= rating <= max_rating]"},{"question":"# Binary Search Tree Operations You are required to implement a `BinarySearchTree` (BST) class with various operations such as insertion, searching, and deletion of nodes. Requirements: 1. **Insertion**: - Implement the `insert` method that adds a node with a given value to the BST. 2. **Search**: - Implement the `search` method that checks if a given value exists in the BST. 3. **Deletion**: - Implement the `delete` method that removes a node with a specified value from the BST. 4. **Traversal**: - Implement the `inorder_traversal` method that performs an in-order traversal of the BST and returns a list of the node values. Input: * Multiple operations to be performed on the BST: - Insert operation with an integer value. - Search operation with an integer value. - Delete operation with an integer value. - In-order traversal operation. Output: * For search operations, return `True` if the value is found in the BST, otherwise `False`. * For in-order traversal operation, return a list of integers representing the node values in in-order sequence. Constraints: * All integer values are unique within the BST. * Consider the time complexity for each of the operations. Example: ```python # Initialization bst = BinarySearchTree() # Insertion bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(15) # Search assert bst.search(10) == True assert bst.search(15) == True assert bst.search(25) == False # In-order Traversal assert bst.inorder_traversal() == [5, 10, 15, 20] # Deletion bst.delete(10) assert bst.search(10) == False # In-order Traversal after Deletion assert bst.inorder_traversal() == [5, 15, 20] ``` Implementation Hint: * Use the properties of BST to efficiently insert, search, and delete nodes. * For deletion, consider the three cases: node with no children, node with one child, and node with two children. ```python class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): Insert the given value into the Binary Search Tree. pass def search(self, value: int) -> bool: Search the BST for the given value. Return True if the value exists, otherwise return False. pass def delete(self, value: int): Delete the node with the given value from the BST. pass def inorder_traversal(self) -> list: Perform in-order traversal of the BST. Return a list of node values in in-order sequence. pass ``` Note: The Binary Search Tree operations should follow the principles of binary search trees with proper node linking and structural adjustments during insertions and deletions.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value: int): self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_node = self._min_value_node(node.right) node.value = min_node.value node.right = self._delete_recursive(node.right, min_node.value) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder_traversal(self) -> list: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node is not None: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result)"},{"question":"# Hexadecimal to Decimal Converter You need to implement a function that converts a given hexadecimal string to its equivalent decimal integer value. The function should be able to handle both uppercase and lowercase characters in the hexadecimal string. # Function Specification Implement the following function in Python: ```python def hex_to_decimal(hex_string: str) -> int: Convert a hexadecimal string to its decimal integer value. Parameters: - hex_string (str): A string representing a hexadecimal number. Must be non-empty and valid. Returns: - int: The decimal integer value of the hexadecimal string. Raises: - ValueError: If the input string is empty or contains invalid characters. Example Usage: >>> hex_to_decimal(\'1A\') 26 >>> hex_to_decimal(\'ff\') 255 >>> hex_to_decimal(\'10\') 16 ``` # Input and Output - **Input**: - `hex_string` (str): A non-empty string representing the hexadecimal number. The string must be valid consisting only of hexadecimal digits (0-9, A-F, a-f). - **Output**: The function should return the decimal integer value that corresponds to the hexadecimal input. # Constraints - The input string will have a length of up to 10 characters. - The function must handle input validation and raise appropriate errors for invalid hexadecimal strings or empty input. # Example: ```python >>> hex_to_decimal(\'1A\') 26 >>> hex_to_decimal(\'ff\') 255 >>> hex_to_decimal(\'10\') 16 >>> hex_to_decimal(\'ABCdef\') 11259375 >>> hex_to_decimal(\'\') Traceback (most recent call last): ... ValueError: Hexadecimal string must be non-empty and valid. >>> hex_to_decimal(\'1G3\') Traceback (most recent call last): ... ValueError: Hexadecimal string contains invalid characters. ``` Implement the function according to the specification above and ensure it passes the provided test cases.","solution":"def hex_to_decimal(hex_string: str) -> int: Convert a hexadecimal string to its decimal integer value. Parameters: - hex_string (str): A string representing a hexadecimal number. Must be non-empty and valid. Returns: - int: The decimal integer value of the hexadecimal string. Raises: - ValueError: If the input string is empty or contains invalid characters. if not hex_string: raise ValueError(\\"Hexadecimal string must be non-empty and valid.\\") try: return int(hex_string, 16) except ValueError: raise ValueError(\\"Hexadecimal string contains invalid characters.\\")"},{"question":"# Introduction Data compression is a process used to reduce the size of data. One simple and well-known form of lossless data compression is run-length encoding (RLE). RLE works by reducing the physical size of a repeating string of characters and encoding them as a single character followed by the number of times it repeats. # Task Write a function `run_length_encoding` that takes a string as input and returns its Run-Length Encoded (RLE) version. # Function Signature ```python def run_length_encoding(s: str) -> str: ``` # Input * `s`: A string containing alphanumeric characters only (length up to 10^5). # Output * Returns a string which is the run-length encoded version of the input string. # Example ```python # Example 1 encoded_string = run_length_encoding(\\"aaabbcccc\\") print(encoded_string) # Expected output: \\"a3b2c4\\" # Example 2 encoded_string = run_length_encoding(\\"wwwwaaadexxxxxx\\") print(encoded_string) # Expected output: \\"w4a3d1e1x6\\" # Example 3 encoded_string = run_length_encoding(\\"abcd\\") print(encoded_string) # Expected output: \\"a1b1c1d1\\" ``` # Constraints * The input string contains only uppercase/lowercase alphabets and digits. * The length of the input string is at most (10^5). # Notes * If the input string is empty, return an empty string. * The encoded string should maintain the order of characters as they appear in the original string. * Ensure that your function handles edge cases such as a single-character string or a string where all characters are unique. # Testing Your Function Ensure that your implementation is robust by testing it with various representative and edge cases. You should test cases of varying lengths and character distributions. ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() print(run_length_encoding(\\"aaaabbbcc\\")) # Expected: \\"a4b3c2\\" print(run_length_encoding(\\"aaaa\\")) # Expected: \\"a4\\" print(run_length_encoding(\\"\\")) # Expected: \\"\\" print(run_length_encoding(\\"z\\")) # Expected: \\"z1\\" print(run_length_encoding(\\"aabbcc\\")) # Expected: \\"a2b2c2\\" ```","solution":"def run_length_encoding(s: str) -> str: Returns the run-length encoded version of the input string. if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: encoded_string.append(f\\"{s[i-1]}{count}\\") count = 1 encoded_string.append(f\\"{s[-1]}{count}\\") # Append the last sequence return \'\'.join(encoded_string)"},{"question":"# Binary Tree Level Order Traversal Implement a function that performs level order traversal on a binary tree, returning the nodes\' values at each level in a list of lists. Your function should handle edge cases gracefully, such as when the tree is empty or has only one node. Input * The root node of a binary tree. Output * A list of lists, where each list contains the node values at one level of the tree, starting from the root level and moving down to the leaf level. Constraints 1. Each node of the tree has a value, `val`, which is an integer. 2. The tree can be arbitrarily large but will always be a valid binary tree. 3. Assume the tree does not contain any cycles. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> list: Perform level order traversal of a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> level_order_traversal(root) [[1], [2]] # Implementation starts here... ``` This task will assess your understanding of tree traversal methods, specifically level order traversal, as well as your ability to handle different tree structures and edge cases efficiently. Good luck!","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform level order traversal of a binary tree. Args: root: TreeNode - the root of the binary tree. Returns: List[List[int]] - a list of lists containing the node values at each level, starting from the root level and moving down to the leaf level. if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Subsets of a Set Given a list of distinct integers `nums`, write a function `find_subsets` to generate all possible subsets (the power set). The function should return the subsets sorted lexicographically by considering subsets as lists sorted in ascending order, then by their lengths in ascending order. Function Signature ```python def find_subsets(nums: list[int]) -> list[list[int]]: pass ``` Input - A list of distinct integers `nums` where ( 0 leq |nums| leq 10 ). Output - A list of list of integers containing all subsets of the input list, each subset sorted in ascending order, and the list of subsets sorted first by length in ascending order, then lexicographically. Constraints - The elements of the list will be distinct integers. Example ```python find_subsets([1, 2, 3]) ``` Output: ```python [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` ```python find_subsets([4, 1, 0]) ``` Output: ```python [[], [0], [1], [4], [0, 1], [0, 4], [1, 4], [0, 1, 4]] ``` Instructions 1. Use an iterative or recursive approach to build the power set. 2. Ensure subsets in the result list are sorted lexicographically and by length.","solution":"def find_subsets(nums): # Generate all subsets using backtracking def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] nums.sort() backtrack(0, []) result.sort(key=lambda x: (len(x), x)) return result"},{"question":"# Coding Question Problem Statement You are given a list of integers `arr` and an integer `k`. Your task is to implement the function `find_k_largest_elements(arr: list, k: int) -> list` that returns a list containing the `k` largest elements from the input list in any order. If there are fewer than `k` elements in the list, return all the elements in the list. If `k` is not a positive integer or if the input list is not valid, raise a `ValueError` with an appropriate message. Function Signature ```python def find_k_largest_elements(arr: list, k: int) -> list: pass ``` Input - `arr` (list): A list of integers. Can be empty. - `k` (int): An integer specifying the number of largest elements to find. Output - Returns a list of integers containing the `k` largest elements from the input list. Constraints - If `arr` is not a list of integers, raise a `ValueError` with the message: \\"the input array must be a list of integers\\". - If `k` is not a positive integer, raise a `ValueError` with the message: \\"k must be a positive integer\\". - The length of `arr` is up to `10^5`. Example ```python assert find_k_largest_elements([1, 2, 3, 4, 5], 2) == [4, 5] or find_k_largest_elements([1, 2, 3, 4, 5], 2) == [5, 4] assert find_k_largest_elements([23, 1, 45, 78, 3, 23], 3) == [23, 45, 78] or find_k_largest_elements([23, 1, 45, 78, 3, 23], 3) == [45, 78, 23] assert find_k_largest_elements([2, 1], 5) == [2, 1] or find_k_largest_elements([2, 1], 5) == [1, 2] try: find_k_largest_elements(\\"not a list\\", 3) except ValueError as e: assert str(e) == \\"the input array must be a list of integers\\" try: find_k_largest_elements([1, 2, 3], -3) except ValueError as e: assert str(e) == \\"k must be a positive integer\\" try: find_k_largest_elements([1, 2, 3], 0) except ValueError as e: assert str(e) == \\"k must be a positive integer\\" ``` Performance Requirements - The solution should handle lists up to length `10^5` efficiently.","solution":"def find_k_largest_elements(arr, k): Returns a list containing the k largest elements from the input list in any order. # Validate if arr is a list of integers if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"the input array must be a list of integers\\") # Validate if k is a positive integer if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer\\") # If the list is empty or k is greater than the length of the list, # return the list itself as there are fewer elements than k. if len(arr) == 0 or k >= len(arr): return arr # Use sorting to get the k largest elements return sorted(arr, reverse=True)[:k]"},{"question":"# Coding Assessment Question: Letter Frequency Analysis You are working on a text processing application that analyzes the frequency of letters in given input strings. Your task is to implement a function that counts the occurrences of each letter in a string, ignoring case and excluding non-alphabetic characters. The result should be case-insensitive and sorted alphabetically by the letter. **Function Specification** ```python def letter_frequency_analysis(input_string: str) -> dict: Analyze the frequency of letters in the given input string. Parameters: input_string (str): The string to be analyzed for letter frequency. Returns: dict: A dictionary where keys are the lowercase letters and values are their corresponding counts in the input string. ``` # Input * A string `input_string` representing the text to be analyzed. The string can be any length, including being empty. # Output * Return a dictionary with lowercase letters as keys and their counts as values. Exclude non-alphabetic characters and present the results in alphabetical order by the letter. # Constraints * Ignore the case of the letters (i.e., \'A\' and \'a\' are treated the same). * Exclude non-alphabetic characters from the count. * Handle large input strings efficiently. # Example ```python print(letter_frequency_analysis(\\"Hello, World!\\")) # {\'d\': 1, \'e\': 1, \'h\': 1, \'l\': 3, \'o\': 2, \'r\': 1, \'w\': 1} print(letter_frequency_analysis(\\"This is a test.\\")) # {\'a\': 1, \'e\': 1, \'h\': 1, \'i\': 2, \'s\': 3, \'t\': 3} print(letter_frequency_analysis(\\"\\")) # {} print(letter_frequency_analysis(\\"1234!@#\\")) # {} ``` # Notes - Ensure your function is efficient, especially for very large input strings. - Consider the impact of various character types and cases in your implementation. - Provide comments explaining any non-trivial logic used in your solution.","solution":"def letter_frequency_analysis(input_string: str) -> dict: Analyze the frequency of letters in the given input string. Parameters: input_string (str): The string to be analyzed for letter frequency. Returns: dict: A dictionary where keys are the lowercase letters and values are their corresponding counts in the input string. from collections import Counter import string # Convert the input string to lowercase and filter out non-alphabetic characters. filtered_string = \'\'.join(char.lower() for char in input_string if char.isalpha()) # Use Counter to count frequencies of each character in the filtered string. frequency = Counter(filtered_string) # Sort the dictionary by key (alphabetically). return dict(sorted(frequency.items()))"},{"question":"# Coding Assessment Question: Activity Tracker Data Analysis Scenario You are working on a fitness tracking application that records a variety of activities (e.g., walking, running, cycling) along with the start and end times of these activities. The application\'s goal is to compute various statistics based on the recorded activities. Problem Statement Implement a Python class `ActivityTracker` with methods to initialize the activity data and calculate the following statistics: 1. **Total Duration of Activities**: Calculate the total duration for all recorded activities in minutes. 2. **Average Speed per Activity Type**: Calculate the average speed for each type of activity. Speed is given by the distance divided by the duration of each activity. 3. **Longest Activity per Type**: Identify the longest activity duration for each type of activity. Requirements 1. The class should be initialized with an optional parameter, a list of dictionaries, each representing an activity. Each dictionary should contain `type`, `start_time`, `end_time`, and `distance` keys. 2. It should provide a method `add_activity` to add a new activity to the data. 3. Implement methods to calculate the required statistics: `total_duration`, `average_speed`, and `longest_activity`. 4. The calculations should handle edge cases such as no activities or zero distances gracefully. Input/Output Format - **Input**: - List of dictionaries representing the activities. - Each dictionary contains: - `type` (str): The type of activity (e.g., \'walking\', \'running\'). - `start_time` (datetime): The start time of the activity. - `end_time` (datetime): The end time of the activity. - `distance` (float): The distance covered during the activity in kilometers. - **Output**: - Total duration: An integer representing the total duration in minutes. - Average speed: A dictionary with activity types as keys and their corresponding average speeds in km/h as values. - Longest activity: A dictionary with activity types as keys and their corresponding longest duration in minutes as values. - **Constraints**: - Activities within the list will contain valid datetime and numerical values. - Activity list length can range from 0 to 10,000. Example Scenario ```python # Example input data from datetime import datetime activities = [ {\'type\': \'walking\', \'start_time\': datetime(2023, 1, 1, 9, 0), \'end_time\': datetime(2023, 1, 1, 9, 30), \'distance\': 3.0}, {\'type\': \'running\', \'start_time\': datetime(2023, 1, 2, 10, 0), \'end_time\': datetime(2023, 1, 2, 10, 45), \'distance\': 10.0}, {\'type\': \'cycling\', \'start_time\': datetime(2023, 1, 3, 7, 0), \'end_time\': datetime(2023, 1, 3, 8, 0), \'distance\': 20.0} ] # Initializing the class tracker = ActivityTracker(activities) # Calculating total duration total_duration_result = tracker.total_duration() print(\\"Total Duration:\\", total_duration_result) # Calculating average speed average_speed_result = tracker.average_speed() print(\\"Average Speed:\\", average_speed_result) # Calculating longest activity longest_activity_result = tracker.longest_activity() print(\\"Longest Activity:\\", longest_activity_result) # Adding a new activity tracker.add_activity({\'type\': \'walking\', \'start_time\': datetime(2023, 1, 4, 6, 0), \'end_time\': datetime(2023, 1, 4, 6, 45), \'distance\': 4.0}) ``` **Implementation Details**: - Use the `datetime` module to handle time calculations. - Ensure that calculations for statistics handle no activities or zero distance gracefully. - Efficiently process lists of activities with up to 10,000 entries.","solution":"from datetime import datetime class ActivityTracker: def __init__(self, activities=None): self.activities = activities if activities is not None else [] def add_activity(self, activity): self.activities.append(activity) def total_duration(self): total_minutes = 0 for activity in self.activities: start_time = activity[\'start_time\'] end_time = activity[\'end_time\'] duration = (end_time - start_time).total_seconds() / 60 total_minutes += duration return int(total_minutes) def average_speed(self): speeds = {} total_distances = {} durations = {} for activity in self.activities: activity_type = activity[\'type\'] start_time = activity[\'start_time\'] end_time = activity[\'end_time\'] duration = (end_time - start_time).total_seconds() / 3600 # Convert to hours distance = activity[\'distance\'] if activity_type not in speeds: speeds[activity_type] = 0 total_distances[activity_type] = 0 durations[activity_type] = 0 total_distances[activity_type] += distance durations[activity_type] += duration for activity_type in speeds: if durations[activity_type] != 0: speeds[activity_type] = total_distances[activity_type] / durations[activity_type] return speeds def longest_activity(self): longest_durations = {} for activity in self.activities: activity_type = activity[\'type\'] start_time = activity[\'start_time\'] end_time = activity[\'end_time\'] duration = (end_time - start_time).total_seconds() / 60 # Convert to minutes if activity_type not in longest_durations or duration > longest_durations[activity_type]: longest_durations[activity_type] = duration return {k: int(v) for k, v in longest_durations.items()}"},{"question":"# Problem Statement Implement a function that calculates the nth Fibonacci number using an iterative approach, without using recursion or memoization. This helps in understanding basic loop constructs and efficiency in terms of space complexity. # Function Signature ```python def iterative_fibonacci(n: int) -> int: pass ``` # Input * An integer `n`. - Constraints: `0 <= n <= 50` # Output * Return an integer, which is the nth Fibonacci number. # Example ```python assert iterative_fibonacci(0) == 0 assert iterative_fibonacci(1) == 1 assert iterative_fibonacci(2) == 1 assert iterative_fibonacci(10) == 55 assert iterative_fibonacci(30) == 832040 assert iterative_fibonacci(50) == 12586269025 ``` # Explanation The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, starting from 0 and 1. That is, - `Fib(0) = 0` - `Fib(1) = 1` - `Fib(n) = Fib(n-1) + Fib(n-2)` for `n >= 2` Your task is to implement the sequence in an iterative manner: 1. Start with the base cases: `Fib(0) = 0` and `Fib(1) = 1`. 2. Use a loop to calculate the Fibonacci series up to the nth number. 3. Update the current and the previous Fibonacci numbers iteratively. Ensure your function handles the boundary cases, such as when `n` is 0 or 1, correctly.","solution":"def iterative_fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement You are given a list of purchase transactions made by different customers. Each transaction is represented by a tuple (customer_id, item, amount), where \'customer_id\' is a unique identifier for each customer, \'item\' is the name of the purchased item, and \'amount\' is the money spent on that item. Your task is to determine the total amount spent by each customer and return the customer_id of the customer who spent the most. # Function Specification Your task is to implement the following function: ```python def find_top_spender(transactions: List[Tuple[int, str, float]]) -> int: Find the customer_id of the customer who spent the most money. Parameters: transactions (List[Tuple[int, str, float]]): A list of transactions, where each transaction is represented as a tuple (customer_id, item, amount) Returns: int: The customer_id of the customer who spent the most money. Example: >>> transactions = [ (1, \\"apple\\", 2.50), (2, \\"banana\\", 3.00), (1, \\"orange\\", 4.75), (2, \\"apple\\", 1.50) ] >>> find_top_spender(transactions) 1 >>> transactions = [ (3, \\"bread\\", 5.00), (4, \\"milk\\", 4.00), (3, \\"cheese\\", 6.00), (4, \\"butter\\", 3.00) ] >>> find_top_spender(transactions) 3 ``` # Input Format A list of tuples, where each tuple consists of: 1. **customer_id** (int): An identifier for the customer. 2. **item** (str): The name of the purchased item. 3. **amount** (float): The money spent on the item. # Output Format An integer representing the `customer_id` of the customer who spent the most money. # Constraints 1. Each transaction will have a valid `customer_id` and a non-negative `amount`. 2. The `transactions` list is non-empty and contains at least one transaction. 3. There are no ties in the highest spending amount. # Examples ```python transactions = [ (1, \\"apple\\", 2.50), (2, \\"banana\\", 3.00), (1, \\"orange\\", 4.75), (2, \\"apple\\", 1.50) ] >>> find_top_spender(transactions) 1 transactions = [ (3, \\"bread\\", 5.00), (4, \\"milk\\", 4.00), (3, \\"cheese\\", 6.00), (4, \\"butter\\", 3.00) ] >>> find_top_spender(transactions) 3 ``` # Notes 1. Handle invalid inputs gracefully by ensuring the input adheres to the specified format and constraints. 2. Consider edge cases such as customers with no transactions. 3. The function should efficiently compute the top spender, even for large lists of transactions.","solution":"def find_top_spender(transactions): Find the customer_id of the customer who spent the most money. Parameters: transactions (List[Tuple[int, str, float]]): A list of transactions, where each transaction is represented as a tuple (customer_id, item, amount) Returns: int: The customer_id of the customer who spent the most money. # Dictionary to store the total amount spent by each customer_id spending = {} # Iterate through each transaction for customer_id, item, amount in transactions: if customer_id in spending: spending[customer_id] += amount else: spending[customer_id] = amount # Find the customer_id with the maximum spending top_spender = max(spending, key=spending.get) return top_spender"},{"question":"# Problem: String Pattern Matching Context: You are developing a function for a text-processing software that checks for the presence of a pattern within a given string. Specifically, the function needs to identify if a certain pattern appears as a subsequence in the text. A subsequence is a sequence derived by deleting some or no elements of another sequence without changing the order of the remaining elements. Task: Write a function `is_pattern_in_text(text: str, pattern: str) -> bool` that takes a string `text` and a string `pattern` and determines if `pattern` is a subsequence of `text`. Input: - A string `text` (1 ≤ len(text) ≤ 10^5) consisting of lowercase English letters. - A string `pattern` (1 ≤ len(pattern) ≤ 10^5) consisting of lowercase English letters. Output: - A boolean value `True` if `pattern` is a subsequence of `text`, otherwise `False`. Constraints: - The function should handle large inputs efficiently. - The length of `pattern` will always be less than or equal to the length of `text`. Performance Requirements: - The function should be efficient with a target time complexity of O(n + m), where n is the length of `text` and m is the length of `pattern`. Examples: ```python assert is_pattern_in_text(\\"abcdef\\", \\"ace\\") == True assert is_pattern_in_text(\\"abcdef\\", \\"aeg\\") == False assert is_pattern_in_text(\\"hello\\", \\"hlo\\") == True assert is_pattern_in_text(\\"hello\\", \\"ool\\") == False assert is_pattern_in_text(\\"codingchallenge\\", \\"code\\") == True ``` Hints: - Iterate through the `text` and `pattern` to check the subsequence efficiently. - Utilize two pointers technique to match characters in sequence. - Consider edge cases such as when `pattern` is empty or identical to `text`.","solution":"def is_pattern_in_text(text, pattern): Determines if the pattern is a subsequence of the given text. :param text: str, the main text string :param pattern: str, the pattern to check :return: bool, True if pattern is a subsequence of text, otherwise False text_len = len(text) pattern_len = len(pattern) i, j = 0, 0 while i < text_len and j < pattern_len: if text[i] == pattern[j]: j += 1 i += 1 return j == pattern_len"},{"question":"# Scenario: You are tasked with developing a simple arithmetic expression evaluator that can handle basic mathematical operations. The evaluator should be able to parse and compute the value of expressions containing addition, subtraction, multiplication, and division. # Task: Implement a class `ExpressionEvaluator` that processes and evaluates arithmetic expressions. Your class should be able to: 1. Parse infix arithmetic expressions. 2. Convert infix expressions to postfix (Reverse Polish Notation) using the Shunting Yard algorithm. 3. Evaluate postfix expressions to compute the final result. # Requirements: - The input expressions will only contain non-negative integers and the operators: `+`, `-`, `*`, `/`. - Assume integer division for the `/` operator. - The input expressions are guaranteed to be valid and do not contain any whitespace. - Use the provided `ShuntingYard` and `PostfixEvaluator` classes as a starting point. # Class Specifications: 1. **ExpressionEvaluator**: - **evaluate(expression: str) -> int**: Evaluates the given arithmetic expression and returns the result. # Constraints: - The length of the input expression will not exceed 1000 characters. - All tokens in the expression are valid and properly formatted. # Example: ```python evaluator = ExpressionEvaluator() result1 = evaluator.evaluate(\\"3+5*2\\") print(result1) # Output: 13 result2 = evaluator.evaluate(\\"10+2*6\\") print(result2) # Output: 22 result3 = evaluator.evaluate(\\"100*2+12\\") print(result3) # Output: 212 result4 = evaluator.evaluate(\\"100*(2+12)\\") print(result4) # Output: 1400 result5 = evaluator.evaluate(\\"100*(2+12)/14\\") print(result5) # Output: 100 ``` # Note: - You should handle operator precedence appropriately (`*` and `/` have higher precedence than `+` and `-`). - You can assume that the input expressions are free of any syntax errors (e.g., no unbalanced parentheses). ```python class ShuntingYard: def __init__(self): self.precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} self.operators = set([\'+\', \'-\', \'*\', \'/\']) def to_postfix(self, expression): output = [] stack = [] for token in expression: if token.isdigit(): output.append(token) elif token in self.operators: while (stack and stack[-1] in self.operators and self.precedence[token] <= self.precedence[stack[-1]]): output.append(stack.pop()) stack.append(token) elif token == \'(\': stack.append(token) elif token == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() while stack: output.append(stack.pop()) return \'\'.join(output) class PostfixEvaluator: def evaluate(self, expression): stack = [] for token in expression: if token.isdigit(): stack.append(int(token)) elif token in \'+-*/\': b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a // b) return stack[0] class ExpressionEvaluator: def __init__(self): self.shunting_yard = ShuntingYard() self.postfix_evaluator = PostfixEvaluator() def evaluate(self, expression: str) -> int: postfix = self.shunting_yard.to_postfix(expression) return self.postfix_evaluator.evaluate(postfix) ```","solution":"class ShuntingYard: def __init__(self): self.precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} self.operators = set([\'+\', \'-\', \'*\', \'/\']) def to_postfix(self, expression): output = [] stack = [] i = 0 while i < len(expression): token = expression[i] if token.isdigit(): num = \'\' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 output.append(num) continue elif token in self.operators: while (stack and stack[-1] in self.operators and self.precedence[token] <= self.precedence[stack[-1]]): output.append(stack.pop()) stack.append(token) elif token == \'(\': stack.append(token) elif token == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() i += 1 while stack: output.append(stack.pop()) return \' \'.join(output) class PostfixEvaluator: def evaluate(self, expression): stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(int(token)) elif token in \'+-*/\': b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a // b) return stack[0] class ExpressionEvaluator: def __init__(self): self.shunting_yard = ShuntingYard() self.postfix_evaluator = PostfixEvaluator() def evaluate(self, expression: str) -> int: postfix = self.shunting_yard.to_postfix(expression) return self.postfix_evaluator.evaluate(postfix)"},{"question":"# Data Structure Manipulation and Validation Suppose you are working with employee data stored in JSON format. Your task is to validate and process this data to ensure it meets certain requirements, then convert it to a different format for further analysis. Your Task Write a Python function, `validate_and_process_employee_data`, which will: 1. Validate the employee data to ensure each employee entry contains the required fields: `\\"name\\"`, `\\"id\\"`, `\\"email\\"`, and `\\"department\\"`. 2. Convert the validated employee data into XML format and save it to a file named `\\"validated_employee_data.xml\\"`. # Function Signature ```python import xml.etree.ElementTree as ET from typing import List, Dict def validate_and_process_employee_data(employee_data: List[Dict[str, str]]) -> None: ``` Implementation Details - The input, `employee_data`, is a list of dictionaries where each dictionary represents an employee. - Each dictionary must contain the fields: `\\"name\\"`, `\\"id\\"`, `\\"email\\"`, and `\\"department\\"`. - If any entry is missing required fields, it should be skipped in the final XML. - The root element in the XML should be `<Employees>`, and each employee should be represented as an `<Employee>` element with sub-elements for `\\"name\\"`, `\\"id\\"`, `\\"email\\"`, and `\\"department\\"`. Example Given the following input: ```python employee_data = [ {\\"name\\": \\"Alice\\", \\"id\\": \\"001\\", \\"email\\": \\"alice@example.com\\", \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Bob\\", \\"id\\": \\"002\\", \\"email\\": \\"bob@example.com\\", \\"department\\": \\"HR\\"} ] ``` The output file `\\"validated_employee_data.xml\\"` should contain: ```xml <Employees> <Employee> <name>Alice</name> <id>001</id> <email>alice@example.com</email> <department>Engineering</department> </Employee> <Employee> <name>Bob</name> <id>002</id> <email>bob@example.com</email> <department>HR</department> </Employee> </Employees> ``` # Constraints - Ensure the XML is properly formatted and adheres to standard XML conventions. - Handle any potential issues with missing fields gracefully. - Use the `xml.etree.ElementTree` module for creating and writing XML files. # Hints - Use Python\'s `xml.etree.ElementTree.Element` to create XML elements. - Validate each employee entry before adding it to the XML tree. - Use error handling to manage potential problems with the input data.","solution":"import xml.etree.ElementTree as ET from typing import List, Dict def validate_and_process_employee_data(employee_data: List[Dict[str, str]]) -> None: root = ET.Element(\\"Employees\\") required_fields = {\\"name\\", \\"id\\", \\"email\\", \\"department\\"} for employee in employee_data: if required_fields <= employee.keys(): employee_element = ET.SubElement(root, \\"Employee\\") for field in required_fields: field_element = ET.SubElement(employee_element, field) field_element.text = employee[field] tree = ET.ElementTree(root) tree.write(\\"validated_employee_data.xml\\", encoding=\'utf-8\', xml_declaration=True)"},{"question":"# Sorted Matrix Search **Scenario**: You are working on optimizing search operations in a software application that deals with sorted matrices. In this context, a sorted matrix is one where each row and each column is sorted in ascending order. **Problem**: Implement the function `search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]` that searches for a given target value within a sorted matrix and returns the 1-based position (row, column) of the target. If the target is not found, the function should return (-1, -1). **Input**: * `matrix`: A 2D list (list of lists) of integers where each row and column is sorted in ascending order. * `target`: An integer to search for within the matrix. **Output**: * A tuple containing the 1-based row and column indices of the target if found or (-1, -1) if not found. **Constraints**: * The dimensions of the matrix, `m x n`, will have `1 <= m, n <= 1000`. * The elements in the matrix and `target` will be within the range `-10^9 <= elements, target <= 10^9`. **Example**: ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] # Search for target 5 result = search_matrix(matrix, 5) print(result) # Output should be (1, 2) since 5 is at matrix[0][1] # Search for target 20 result = search_matrix(matrix, 20) print(result) # Output should be (-1, -1) since 20 is not in the matrix ``` **Requirements**: * Implement an efficient search algorithm with a time complexity of O(m + n).","solution":"from typing import List, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row + 1, col + 1) # Return 1-based index elif matrix[row][col] > target: col -= 1 # Move left else: row += 1 # Move down return (-1, -1)"},{"question":"# Coding Assessment Question: Implementing the Median of Three Context Finding the median value of a small set of elements is a common task in many algorithms, such as those used in statistics and data analysis. This exercise will help you demonstrate your understanding of comparison and selection techniques by asking you to implement a function to find the median value among three given numbers. Problem Statement Write a function `median_of_three(a: int, b: int, c: int) -> int` that returns the median (middle) value of the three integers `a`, `b`, and `c`. The median is the number that would be in the middle if the three values were sorted in ascending order. Input and Output * The input will be three integers `a`, `b`, and `c`. * The output should be an integer which is the median of the three provided numbers. Constraints * The input values `a`, `b`, and `c` will be valid integers within the range of -10^6 to 10^6. * Ensure the implementation is efficient with O(1) time complexity. Edge Cases * Consider how to handle cases where two or three numbers are the same. * Ensure correct ordering for negative values. Example ```python def median_of_three(a: int, b: int, c: int) -> int: Return the median of three integers. :param a: the first number :param b: the second number :param c: the third number :return: the median value of a, b, and c >>> median_of_three(1, 3, 2) 2 >>> median_of_three(-1, 0, 1) 0 >>> median_of_three(5, 5, 5) 5 >>> median_of_three(10, 20, 15) 15 >>> median_of_three(-10, -20, -15) -15 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def median_of_three(a: int, b: int, c: int) -> int: Return the median of three integers. :param a: the first number :param b: the second number :param c: the third number :return: the median value of a, b, and c if a >= b and a <= c or a <= b and a >= c: return a elif b >= a and b <= c or b <= a and b >= c: return b else: return c"},{"question":"# Coding Assessment Question Scenario You are working on a project that involves processing strings with nested parentheses. Your task is to write a function that validates if a given string representing a sequence of nested parentheses is properly balanced. - A string of parentheses is considered balanced if every opening parenthesis \\"(\\" has a corresponding closing parenthesis \\")\\" and the pairs of parentheses are properly nested. Task Implement the following function: ```python def validate_parentheses(s: str) -> bool: Validates if a string of parentheses is properly balanced. Parameters: - s: A string containing only the characters \'(\' and \')\'. Returns: - A boolean indicating whether the string is balanced. ``` Requirements 1. **`validate_parentheses` Implementation**: Use efficient algorithms to determine if the string of parentheses is balanced. 2. **Input Constraints**: The string contains only \'(\' and \')\' characters. 3. **Output**: A boolean indicating whether the string is balanced. Example ```python assert validate_parentheses(\\"()\\") == True # This is a balanced string assert validate_parentheses(\\"(())\\") == True # This is a balanced string assert validate_parentheses(\\"(()\\") == False # This is not a balanced string assert validate_parentheses(\\")(\\") == False # This is not a balanced string assert validate_parentheses(\\"((()))\\") == True # This is a balanced string ``` Additional Notes - Ensure the function handles both short and long strings effectively. - Consider edge cases such as empty strings. - Focus on an optimal approach to ensure the solution works within a reasonable time frame even for longer strings.","solution":"def validate_parentheses(s: str) -> bool: Validates if a string of parentheses is properly balanced. Parameters: - s: A string containing only the characters \'(\' and \')\'. Returns: - A boolean indicating whether the string is balanced. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack"},{"question":"# Coding Assessment Question Context You are designing a system for managing customer orders in a restaurant. Customers place orders which are recorded in real-time, and your system needs to keep track of the most popular dishes. The popularity of a dish is measured by the number of times it has been ordered. Problem Statement Write a Python function `most_popular_dishes(orders: list, k: int) -> list` that returns a list of the `k` most frequently ordered dishes. If two dishes have the same frequency, sort them alphabetically. Input Format * A list of strings representing the names of the ordered dishes. For example, [\\"burger\\", \\"pizza\\", \\"burger\\"] represents three orders, where \\"burger\\" was ordered twice and \\"pizza\\" was ordered once. * An integer `k` representing the number of top dishes to return. Output Format * Return a list of strings representing the `k` most frequently ordered dishes sorted by frequency and alphabetically for ties. Constraints * The length of the orders list will be between 1 and 10^5. * Each string in the orders list will have a maximum length of 50 characters. * `k` will be between 1 and the number of unique dishes. Examples ```python >>> most_popular_dishes([\\"burger\\", \\"pizza\\", \\"burger\\", \\"sushi\\", \\"pizza\\", \\"pasta\\", \\"burger\\"], 2) [\\"burger\\", \\"pizza\\"] >>> most_popular_dishes([\\"pasta\\", \\"sushi\\", \\"pasta\\", \\"pizza\\", \\"pasta\\"], 1) [\\"pasta\\"] >>> most_popular_dishes([\\"noodles\\", \\"pizza\\", \\"burger\\", \\"sushi\\", \\"sushi\\", \\"sushi\\"], 1) [\\"sushi\\"] ``` Performance Requirements * The expected time complexity should be O(N log k), where N is the number of orders. * The expected space complexity should be O(N). Implementation Notes * Handle edge cases where the `k` is equal to or greater than the number of unique dishes. * Consider using a dictionary to count frequencies and a heap to efficiently find the top k dishes.","solution":"from collections import Counter import heapq def most_popular_dishes(orders: list, k: int) -> list: # Count frequencies of each dish dish_count = Counter(orders) # Use a heap to extract the k most common dishes heap = [(-freq, dish) for dish, freq in dish_count.items()] heapq.heapify(heap) # Extract the k elements most_popular = [] for _ in range(k): most_popular.append(heapq.heappop(heap)[1]) # Sort by alphabetical order in case of a tie return sorted(most_popular, key=lambda x: (-dish_count[x], x))"},{"question":"# Maze Solver You are required to implement a function that can solve a given maze. The maze is represented as a 2D array where cells with \'1\' represent open paths and cells with \'0\' represent walls. Starting from the top-left corner of the maze, navigate to the bottom-right corner while only moving up, down, left, or right. Function Definition: - **solve_maze(maze: list[list[int]]) -> bool** This function checks if there is a path from the top-left corner to the bottom-right corner of the maze. - **Input**: `maze` (list of list of integers) – A 2D list representing the maze. - **Output**: A boolean value `True` if there is a path from the top-left corner to the bottom-right corner, otherwise `False`. Constraints: - The maze will always be at least 2x2 in size. - You can assume that the start and end points are always open (i.e., have a value of \'1\'). Example: For `solve_maze`, given the following maze: ```python maze = [ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1] ] ``` The function should return `True` as there exists a path from the top-left corner `(0, 0)` to the bottom-right corner `(3, 3)`. ```python result = solve_maze(maze) print(result) # Output: True ``` For a maze like this: ```python maze = [ [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 1, 1] ] ``` The function should return `False` as there is no possible path from the top-left corner to the bottom-right corner. ```python result = solve_maze(maze) print(result) # Output: False ``` Context: This function is designed to test your ability to work with recursive algorithms and depth-first search (DFS) principles to find a viable path in a grid-based maze. This can be a fundamental problem in verifying navigation algorithms for robotics or path-finding in game development.","solution":"def solve_maze(maze): rows, cols = len(maze), len(maze[0]) def is_valid_move(row, col, visited): return (0 <= row < rows and 0 <= col < cols and maze[row][col] == 1 and not visited[row][col]) def dfs(row, col, visited): if row == rows - 1 and col == cols - 1: return True # Mark the cell as visited visited[row][col] = True # Define the moves: down, right, up, left moves = [(1, 0), (0, 1), (-1, 0), (0, -1)] for move in moves: next_row, next_col = row + move[0], col + move[1] if is_valid_move(next_row, next_col, visited): if dfs(next_row, next_col, visited): return True # Unmark the cell to backtrack visited[row][col] = False return False visited = [[False for _ in range(cols)] for _ in range(rows)] return dfs(0, 0, visited)"},{"question":"# Scenario: You are developing a software module for a logistics company to optimize delivery routes. One important feature is to identify and sort delivery addresses based on the distance from the warehouse. Given a list of delivery addresses with corresponding distances from the warehouse, your task is to create a function that sorts these addresses in ascending order of their distances. # Problem Description: Implement a function `sort_addresses_by_distance` that takes a list of tuples as input, where each tuple contains a delivery address and its distance from the warehouse. The function should return a list of addresses sorted by their distance from the warehouse. # Function Signature: `def sort_addresses_by_distance(addresses_with_distances: List[Tuple[str, float]]) -> List[str]:` # Input: - `addresses_with_distances`: A list of tuples, where each tuple contains a string (address) and a float (distance from the warehouse). # Output: - Returns a list of addresses sorted in ascending order based on their distances. # Constraints: - The list can contain up to 10^5 tuples. - The distance is a non-negative float. - If two addresses have the same distance, their original relative order should be preserved. # Example: ```python addresses = [ (\\"123 Maple Street\\", 5.2), (\\"456 Oak Avenue\\", 3.3), (\\"789 Pine Road\\", 5.2), (\\"101 Birch Blvd\\", 2.8) ] print(sort_addresses_by_distance(addresses)) # Output: [\\"101 Birch Blvd\\", \\"456 Oak Avenue\\", \\"123 Maple Street\\", \\"789 Pine Road\\"] ``` # Notes: - Use stable sorting to ensure the original relative order of addresses with equal distances is preserved. - Ensure your implementation is efficient enough to handle large inputs within reasonable time and space constraints.","solution":"def sort_addresses_by_distance(addresses_with_distances): Sorts the addresses by their distance from the warehouse in ascending order. Parameters: addresses_with_distances (List[Tuple[str, float]]): A list of tuples where each tuple contains a delivery address and its distance from the warehouse. Returns: List[str]: A list of addresses sorted by their distance from the warehouse. # Use the sorted function to sort the list of tuples by the second element (distance) in each tuple sorted_addresses = sorted(addresses_with_distances, key=lambda x: x[1]) # Extract and return only the addresses in sorted order return [address for address, distance in sorted_addresses]"},{"question":"# Task: Library Book Catalog Scenario You are developing a system for managing a library\'s book catalog. As part of this system, you need to implement a function that can retrieve details about books by a specific author. Construct a function `books_by_author(books: List[Dict[str, str]], author: str) -> List[str]` which, given a list of books and an author\'s name, returns a list of book titles written by that author. Each book in the input list is represented as a dictionary with the following keys: - `\\"title\\"`: The title of the book (str). - `\\"author\\"`: The author of the book (str). If no books by the specified author are found, the function should return an empty list. Input - `books` (List[Dict[str, str]]): A list of dictionaries, each representing a book with keys `title` and `author`. - `author` (str): The author\'s name to search for (e.g., \\"J.K. Rowling\\"). Output - Returns a list of book titles (List[str]) authored by the specified author. Constraints - The function should process and return the results efficiently even if the list contains up to 10,000 books. - Titles and author names will always be non-empty strings. # Implementation Implement the function following these requirements and consider the described edge cases and performance requirements. Example ```python books = [ {\\"title\\": \\"Harry Potter and the Sorcerer\'s Stone\\", \\"author\\": \\"J.K. Rowling\\"}, {\\"title\\": \\"Harry Potter and the Chamber of Secrets\\", \\"author\\": \\"J.K. Rowling\\"}, {\\"title\\": \\"The Hobbit\\", \\"author\\": \\"J.R.R. Tolkien\\"}, {\\"title\\": \\"The Lord of the Rings\\", \\"author\\": \\"J.R.R. Tolkien\\"} ] print(books_by_author(books, \\"J.K. Rowling\\")) # Returns: [\\"Harry Potter and the Sorcerer\'s Stone\\", \\"Harry Potter and the Chamber of Secrets\\"] print(books_by_author(books, \\"George Orwell\\")) # Returns: [] ```","solution":"from typing import List, Dict def books_by_author(books: List[Dict[str, str]], author: str) -> List[str]: Returns a list of book titles authored by the specified author. :param books: A list of dictionaries, each representing a book with keys \'title\' and \'author\' :param author: The author\'s name to search for :return: List of book titles by the specified author return [book[\'title\'] for book in books if book[\'author\'] == author]"},{"question":"# Unique Elements in List Write a function to return a list containing only the unique elements in the original list in the same order they appeared. All duplicates should be removed, and each unique element should appear only once in the resulting list. **Function Signature**: ```python def unique_elements(lst: List[int]) -> List[int]: pass ``` # Input: * `lst` (List[int]): A list of integers, where ( 0 leq text{len}(lst) leq 10^6 ). # Output: * Returns a list of integers containing only the unique elements from the original list in the order they first appeared. # Examples: ```python >>> unique_elements([1, 2, 2, 3, 4, 3, 5]) [1, 2, 3, 4, 5] >>> unique_elements([4, 5, 5, 5, 5, 6, 7, 7]) [4, 5, 6, 7] >>> unique_elements([]) [] ``` # Constraints: * You should aim for a time complexity of (O(n)) where (n) is the length of the input list. * The function should handle cases where the input list is very large efficiently without using excessive additional memory. * You should not use sorted or set data structures directly to maintain the order of first appearances. # Requirements: 1. Iterate through the list and use an additional data structure to track and ensure each element is only added once to the result. 2. Make sure to maintain the original order of appearance for the unique elements. 3. Optimize for both time and space complexity.","solution":"def unique_elements(lst): Returns a list containing only the unique elements in the original list in the same order they appeared. All duplicates are removed. seen = set() unique_lst = [] for item in lst: if item not in seen: seen.add(item) unique_lst.append(item) return unique_lst"},{"question":"# Generate Fibonacci Sequence with Validation You are required to implement a function that generates the Fibonacci sequence up to a specified number of terms. The implementation should include input validation to ensure robustness. Function Signature ```python def validated_fibonacci_sequence(number_of_terms: int) -> list: Returns a list representing the Fibonacci sequence up to the specified number of terms. Args: number_of_terms (int): The number of terms up to which the Fibonacci sequence is generated. Returns: list: The list of Fibonacci numbers. Raises: ValueError: If \'number_of_terms\' is not a positive integer. ``` Example ```python >>> print(validated_fibonacci_sequence(5)) [0, 1, 1, 2, 3] >>> print(validated_fibonacci_sequence(8)) [0, 1, 1, 2, 3, 5, 8, 13] ``` # Requirements 1. **Input Validation**: - Ensure `number_of_terms` is a positive integer. If not, raise a `ValueError` with the message \\"Number of terms must be a positive integer.\\" 2. **Output Format**: - The output should be a list of integers representing the Fibonacci sequence up to `number_of_terms`. 3. **Constraints**: - The function should handle the generation of the Fibonacci sequence efficiently. - Do not use any external libraries for the implementation. # Objective This question tests the student\'s understanding of: - Basic iteration and sequence generation. - Lists and appending elements in Python. - Input validation and error handling in Python. # Solution ```python def validated_fibonacci_sequence(number_of_terms: int) -> list: if number_of_terms <= 0: raise ValueError(\\"Number of terms must be a positive integer.\\") sequence = [] a, b = 0, 1 for _ in range(number_of_terms): sequence.append(a) a, b = b, a + b return sequence ``` Ensure this new question aligns with existing ones by maintaining a similar level of complexity, format, and scope. This question introduces concepts like sequence generation and list handling, which complement the previously established themes of iteration and validation.","solution":"def validated_fibonacci_sequence(number_of_terms: int) -> list: Returns a list representing the Fibonacci sequence up to the specified number of terms. Args: number_of_terms (int): The number of terms up to which the Fibonacci sequence is generated. Returns: list: The list of Fibonacci numbers. Raises: ValueError: If \'number_of_terms\' is not a positive integer. if not isinstance(number_of_terms, int) or number_of_terms <= 0: raise ValueError(\\"Number of terms must be a positive integer.\\") sequence = [] a, b = 0, 1 for _ in range(number_of_terms): sequence.append(a) a, b = b, a + b return sequence"},{"question":"# Scenario You are tasked with developing a utility to process large text files. A common requirement is to identify the top-k most frequent words in a document, excluding a given list of stop words. To accomplish this, you decide to create a Python function that reads a text file, processes it, and returns these top-k words in order of frequency. # Task Implement a function `find_top_k_words` that takes a file path and a list of stop words and returns the k most frequent words that are not stop words. # Details 1. **Function `find_top_k_words(file_path: str, stop_words: List[str], k: int) -> List[Tuple[str, int]]` Implementation**: * Read the text file specified by `file_path`. * Convert all words to lowercase and remove punctuation. * Exclude common stop words provided in `stop_words`. * Count the frequency of each word and return the top-k most frequent words. * Ensure the list of `stop_words` is case-insensitive. # Input * `file_path`: String representing the path to the text file. * `stop_words`: List of strings representing the words to be excluded from the frequency count. * `k`: Integer representing the number of top words to return. # Output * Returns a list of tuples where each tuple contains a word and its respective frequency, ordered by the highest frequency first. # Constraints * Assume the input file will contain a maximum of 1 million words. * The function should handle large files efficiently. * Ensure `k` is a positive integer and not greater than the number of unique words in the text after removing stop words. # Example ```python # text file content: # \\"This is a simple example. This example is simple and easy to understand.\\" stop_words = [\\"is\\", \\"a\\", \\"to\\", \\"and\\"] print(find_top_k_words(\\"example.txt\\", stop_words, 2)) # Expected output: [(\'this\', 2), (\'simple\', 2)] ``` # Notes 1. Include appropriate error handling for file reading (e.g., file not found). 2. Consider edge cases such as an empty file, no words after stop words removal, or large volumes of text. 3. Optimize the function for time and space efficiency, using suitable data structures.","solution":"from typing import List, Tuple import re from collections import Counter def find_top_k_words(file_path: str, stop_words: List[str], k: int) -> List[Tuple[str, int]]: Find the top k most frequent words in a text file, excluding stop words. :param file_path: Path to the text file. :param stop_words: List of stop words to exclude. :param k: Number of top frequent words to return. :return: List of tuples containing the word and its frequency, ordered by frequency. stop_words_set = set(word.lower() for word in stop_words) word_counter = Counter() try: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = re.findall(r\'bw+b\', line.lower()) filtered_words = [word for word in words if word not in stop_words_set] word_counter.update(filtered_words) except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} does not exist.\\") most_common_words = word_counter.most_common(k) return most_common_words"},{"question":"# Coding Assessment Question You need to develop a Python class named `CircularQueue` that implements a circular queue with a fixed size using a list. A circular queue is a linear data structure that follows the FIFO (First In First Out) principle and wraps around upon reaching the end of the list. This ensures efficient utilization of space. Implement the following functionalities: 1. **Initialization**: Initialize the queue with a specified size. 2. **Enqueue**: Add an element to the end of the queue. If the queue is full, it should overwrite the oldest element. 3. **Dequeue**: Remove and return the front element from the queue. If the queue is empty, return `None`. 4. **IsFull**: Return `True` if the queue is full; otherwise, `False`. 5. **IsEmpty**: Return `True` if the queue is empty; otherwise, `False`. Requirements 1. **Input Format**: - The `__init__` method should initialize the queue with a fixed size. - The `enqueue` method should accept an integer. - The `dequeue` method should return an integer or `None`. 2. **Output Format**: - The `enqueue` method should not return any value. - The `dequeue` method should return an integer or `None`. - The `isFull` and `isEmpty` methods should return a boolean. Constraints * Queue size is limited to a positive integer, `n` (1 ≤ n ≤ 10^6). * The elements in the queue are integers. Example ```python class CircularQueue: def __init__(self, size: int): Initialize the circular queue with the given size. self.size = size self.queue = [None] * size self.front = -1 self.rear = -1 self.count = 0 def enqueue(self, value: int): Add an element to the end of the queue. Overwrites the oldest element if full. if self.isFull(): self.front = (self.front + 1) % self.size else: if self.front == -1: self.front = 0 self.count += 1 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value def dequeue(self) -> int: Remove and return the front element of the queue. Return None if the queue is empty. if self.isEmpty(): return None value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.size self.count -= 1 if self.count == 0: self.front = -1 self.rear = -1 return value def isFull(self) -> bool: Return True if the queue is full, otherwise False. return self.count == self.size def isEmpty(self) -> bool: Return True if the queue is empty, otherwise False. return self.count == 0 # Example usage cq = CircularQueue(3) print(cq.isEmpty()) # Expected: True cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.isFull()) # Expected: True cq.enqueue(4) print(cq.dequeue()) # Expected: 2 print(cq.dequeue()) # Expected: 3 print(cq.dequeue()) # Expected: 4 print(cq.dequeue()) # Expected: None print(cq.isEmpty()) # Expected: True ``` Testing Ensure your implementation passes the following tests: ```python def test_circular_queue(): cq = CircularQueue(3) assert cq.isEmpty() == True, \\"Test Failed\\" cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) assert cq.isFull() == True, \\"Test Failed\\" cq.enqueue(4) assert cq.dequeue() == 2, \\"Test Failed\\" assert cq.dequeue() == 3, \\"Test Failed\\" assert cq.dequeue() == 4, \\"Test Failed\\" assert cq.dequeue() == None, \\"Test Failed\\" assert cq.isEmpty() == True, \\"Test Failed\\" cq.enqueue(10) assert cq.dequeue() == 10, \\"Test Failed\\" test_circular_queue() ```","solution":"class CircularQueue: def __init__(self, size: int): Initialize the circular queue with the given size. self.size = size self.queue = [None] * size self.front = -1 self.rear = -1 self.count = 0 def enqueue(self, value: int): Add an element to the end of the queue. Overwrites the oldest element if full. if self.isFull(): self.front = (self.front + 1) % self.size else: if self.front == -1: self.front = 0 self.count += 1 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value def dequeue(self) -> int: Remove and return the front element of the queue. Return None if the queue is empty. if self.isEmpty(): return None value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.size self.count -= 1 if self.count == 0: self.front = -1 self.rear = -1 return value def isFull(self) -> bool: Return True if the queue is full, otherwise False. return self.count == self.size def isEmpty(self) -> bool: Return True if the queue is empty, otherwise False. return self.count == 0"},{"question":"# Problem Statement Context In modern software systems, efficient sorting algorithms are crucial in handling large datasets. One of the well-known algorithms is **Merge Sort**, which is a divide-and-conquer algorithm with a time complexity of O(n log n). For this task, you are required to implement the Merge Sort algorithm. Task Implement the Merge Sort algorithm in Python. Your function should take an unsorted list of integers and return the list sorted in ascending order. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` Specifications 1. Your function should recursively split the list into halves until each half contains a single element, and then merge the sorted halves to produce the sorted list. 2. The input list can be empty or contain up to 10^5 integers. 3. You can assume all elements in the list are integers in the range -10^9 to 10^9. Example 1. Input: [38, 27, 43, 3, 9, 82, 10] Output: [3, 9, 10, 27, 38, 43, 82] 2. Input: [5, 2, 4, 6, 1, 3] Output: [1, 2, 3, 4, 5, 6] Constraints - The function should efficiently handle the sorting of large lists. - You are not allowed to use Python\'s built-in `sorted()` function or any other sorting libraries. Implement the function `merge_sort` to meet the specifications above.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Scenario You are required to develop a function that processes a string to sanitize and prepare it for a hypothetical secure transmission. This includes removing specified characters and normalizing spaces. # Problem Statement Write a function `sanitize_string(text: str, chars_to_remove: str) -> str` that takes in two strings: - `text` which is the input text that needs to be sanitized. - `chars_to_remove` which is a string of characters that should be removed from `text`. The function should return a new string where: - All characters that appear in `chars_to_remove` are removed from `text`. - Any sequence of whitespace characters (spaces, tabs, newlines, etc.) is reduced to a single space. - Leading and trailing whitespace should be removed. # Example ```python >>> sanitize_string(\\"Hello, World!\\", \\",!\\") \'Hello World\' >>> sanitize_string(\\" This is a tttest. \\", \\"t\\") \'This is a test.\' >>> sanitize_string(\\"Python#3.8!!\\", \\"#!\\") \'Python3.8\' >>> sanitize_string(\\"n Please tremove# these# characters! n\\", \\"#!\\") \'Please remove these characters\' >>> sanitize_string(\\"NoSpecialCharsHere\\", \\"@\\") \'NoSpecialCharsHere\' ``` # Input and Output Formats - **Input**: Two strings `text` and `chars_to_remove` where `text` will be any length between 0 and 10^5 characters, and `chars_to_remove` will be of length between 0 and 100 characters. - **Output**: A sanitized string following the described transformations. # Constraints - The input text `text` can contain any printable ASCII character. - The string `chars_to_remove` will contain distinct characters, all of which must be printable ASCII characters. - The function should handle large inputs efficiently. # Performance Requirements Your solution should aim for a time complexity of O(n) where n is the length of the input string, and space complexity of O(n).","solution":"def sanitize_string(text: str, chars_to_remove: str) -> str: Sanitizes the input text by removing specified characters and normalizing spaces. :param text: The input text to be sanitized. :param chars_to_remove: A string of characters that should be removed from the text. :return: The sanitized text. # Create a translation table for characters to be removed translation_table = str.maketrans(\'\', \'\', chars_to_remove) # Remove specified characters text = text.translate(translation_table) # Split and join to normalize spaces text = \' \'.join(text.split()) return text"},{"question":"# Context You are developing an e-commerce application, and one essential feature is allowing users to apply discount codes to their orders. Each discount code is associated with a percentage, which reduces the total cost of the order. To streamline this process, you need to create a function that can apply these discounts and calculate the new order total. # Task Implement a Python function called `apply_discount` that calculates the new total price after applying a discount code. Your function should adhere to the following requirements: # Requirements * Define the function as `apply_discount(total_price: float, discount_percentage: float) -> float`. * The function should return the new total price after applying the discount. * The discount should be applied using the formula ( text{new_total} = text{total_price} times left(1 - frac{text{discount_percentage}}{100}right) ). * Your function should raise a `ValueError` if the `total_price` is less than zero or if the `discount_percentage` is not between 0 and 100, inclusive, with appropriate error messages. * Assume that inputs will be of type `float`. # Example Usage ```python >>> apply_discount(100, 10) 90.0 >>> apply_discount(200, 25) 150.0 >>> apply_discount(-50, 10) Traceback (most recent call last): ... ValueError: Total price cannot be negative >>> apply_discount(100, 120) Traceback (most recent call last): ... ValueError: Discount percentage must be between 0 and 100 ``` # Constraints * The total price and discount percentage will be floating-point numbers. * Focus on the accuracy of the discount calculation and correct error handling. * Optimize for clear and maintainable code. # Performance Requirements * The function must run in constant time, O(1), given the simplicity of operations involved. * Error messages should be descriptive and user-friendly, aiding in debugging and correctness validation.","solution":"def apply_discount(total_price: float, discount_percentage: float) -> float: Calculate the new total price after applying the discount. Parameters: total_price (float): The original total price of the order. discount_percentage (float): The percentage discount to be applied. Returns: float: The new total price after applying the discount. Raises: ValueError: If total_price is less than 0. ValueError: If discount_percentage is not between 0 and 100, inclusive. if total_price < 0: raise ValueError(\\"Total price cannot be negative\\") if not (0 <= discount_percentage <= 100): raise ValueError(\\"Discount percentage must be between 0 and 100\\") new_total = total_price * (1 - discount_percentage / 100) return new_total"},{"question":"# Problem Statement: You are tasked with writing a function that simulates a simple event-driven queue system. The system processes a list of events and performs actions according to the event type. Your function should return the final state of the queue after processing all events. # Requirements: 1. Implement a function `process_events` that takes the following parameters: - `events`: A list of tuples, where each tuple represents an event. Each event has two elements: - The first element is a string representing the event type (\\"enqueue\\" or \\"dequeue\\"). - The second element is an integer representing the value to be enqueued (for \\"enqueue\\" event type). For \\"dequeue\\" events, this element will be ignored. 2. The function should: - Enqueue the integer value to the queue if the event type is \\"enqueue\\". - Dequeue an integer from the queue if the event type is \\"dequeue\\". - If a \\"dequeue\\" event occurs when the queue is empty, return an error message indicating an invalid operation. 3. Validate the input, making sure all events have valid types and perform the actions accordingly. # Constraints: - **Events list length**: The number of events ( n ) will be between 1 and 1000. - **Queue operations**: The queue should follow the First-In-First-Out (FIFO) principle. - **Input validation**: The function should raise appropriate exceptions for invalid inputs. # Function Signature: ```python def process_events(events: list[tuple[str, int]]) -> list[int]: pass ``` # Example: ```python events = [(\\"enqueue\\", 5), (\\"enqueue\\", 10), (\\"dequeue\\", 0), (\\"enqueue\\", 15)] result = process_events(events) print(result) # Output should be [10, 15] ``` # Note: - Ensure the function adheres to the FIFO behavior of the queue. - Handle edge cases, such as invalid event types or attempts to dequeue from an empty queue, gracefully by raising appropriate exceptions.","solution":"from collections import deque def process_events(events: list[tuple[str, int]]) -> list[int]: Simulates processing of a list of events involving queue operations. Args: events: A list of tuples, where each tuple is an event (\\"enqueue\\", value) or (\\"dequeue\\", 0). Returns: The final state of the queue as a list of integers. Raises: ValueError: If an invalid event type is encountered. IndexError: If a \\"dequeue\\" event occurs when the queue is empty. queue = deque() for event in events: if len(event) != 2: raise ValueError(\\"Event must be a tuple with 2 elements\\") event_type, value = event if event_type == \\"enqueue\\": queue.append(value) elif event_type == \\"dequeue\\": if not queue: raise IndexError(\\"Dequeue operation attempted on an empty queue\\") queue.popleft() else: raise ValueError(f\\"Invalid event type: {event_type}\\") return list(queue)"},{"question":"# Problem Statement: You are given a list of integers representing the heights of candles. Write a function `num_tallest_candles(candles: List[int]) -> int` that returns the number of candles that have the maximum height. # Input: * A list of integers `candles` (1 ≤ len(candles) ≤ 1000, 1 ≤ candles[i] ≤ 1000) # Output: * Returns an integer representing the number of candles that have the maximum height. # Constraints: * The input list must have at least one integer. * If `candles` is not a list or contains elements that are not positive integers, the function should raise a `ValueError`. # Requirements: * Your solution should have a time complexity of O(n) and space complexity of O(1). # Examples: ```python >>> num_tallest_candles([3, 2, 1, 3]) 2 >>> num_tallest_candles([4, 4, 1, 4, 4]) 4 >>> num_tallest_candles([1]) 1 >>> num_tallest_candles([2, 2, 2, 2]) 4 >>> num_tallest_candles([0]) Traceback (most recent call last): ... ValueError: all candle heights must be positive integers and greater than zero >>> num_tallest_candles(\'this is not a list\') Traceback (most recent call last): ... ValueError: the input must be a list of positive integers >>> num_tallest_candles([2, 3, -4, 5]) Traceback (most recent call last): ... ValueError: all candle heights must be positive integers and greater than zero ``` Your implementation should handle all edge cases effectively and adhere to the specified input constraints.","solution":"from typing import List def num_tallest_candles(candles: List[int]) -> int: Returns the number of candles that have the maximum height. # Input validation if not isinstance(candles, list) or not all(isinstance(candle, int) and candle > 0 for candle in candles): raise ValueError(\\"all candle heights must be positive integers and greater than zero\\") max_height = max(candles) return candles.count(max_height)"},{"question":"# Problem Statement: You are tasked with implementing a depth-first search algorithm (DFS) for a given graph and determining if there is a path between two specified nodes. Your implementation should gracefully handle the cases of disconnected graphs and report the status of the path. # Objective: Write a function `depth_first_search` that accepts the following parameters: 1. **graph**: Dict[str, List[str]] - A dictionary representing an adjacency list of the graph. 2. **start**: str - The starting node of the search. 3. **end**: str - The target node to find. Constraints: 1. The graph may contain cycles. 2. The graph may be disconnected. 3. Each node is represented by a unique string. 4. Return a boolean indicating if a path exists between the start and end nodes. # Input/Output: Input: * An adjacency list representing the graph and the start and end nodes. Output: * Boolean - `True` if a path exists from start to end, `False` otherwise. # Example: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\", \\"E\\"], \\"C\\": [\\"F\\"], \\"D\\": [\\"G\\"], \\"E\\": [], \\"F\\": [\\"H\\"], \\"G\\": [], \\"H\\": [] } result = depth_first_search(graph, \\"A\\", \\"H\\") # Expected output: True result = depth_first_search(graph, \\"A\\", \\"G\\") # Expected output: True result = depth_first_search(graph, \\"A\\", \\"E\\") # Expected output: True result = depth_first_search(graph, \\"A\\", \\"Z\\") # Expected output: False ``` # Your Task: Write the function `depth_first_search` that implements the specification detailed above.","solution":"def depth_first_search(graph, start, end): Determines if there is a path from start to end in the given graph using Depth-First Search (DFS). :param graph: Dict[str, List[str]] - A dictionary representing an adjacency list of the graph. :param start: str - The starting node of the search. :param end: str - The target node to find. :return: Boolean - True if a path exists from start to end, False otherwise. def dfs(node, visited): if node == end: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited): return True return False return dfs(start, set())"},{"question":"# Traversing Binary Trees In computer science, particularly in tree data structures, binary trees are fundamental. Given a binary tree, each node has at most two children, referred to as the left child and the right child. # Task Write a function `find_deepest_node(root)` that finds the deepest node(s) in a binary tree. If multiple nodes are at the same depth, return the list of these nodes in left-to-right order. # Constraints - Nodes in the binary tree contain unique integer values. - The input binary tree will have at least one node. # Requirements - Your solution should traverse the binary tree using breadth-first search (BFS) once to determine the maximum depth, and then another pass to collect all nodes at this depth. - Aim for an efficient solution in both time and space complexity. # Example ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right # Given tree: # 1 # / # 2 3 # / / # 4 5 6 7 # / # 8 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) root.left.left.left = TreeNode(8) assert find_deepest_node(root) == [8] ``` # Detailed Objective 1. **Understand the Inputs/Outputs**: - Input: `root`, the root node of the binary tree. - Output: list of integer values of the deepest nodes. 2. **Implement Breadth-First Search**: - Use a queue to traverse each level of the tree. - Track depth and nodes at each level efficiently. 3. **Depth Calculation**: - First pass to determine maximum depth. - Second pass to gather all nodes at this depth. 4. **Edge Case Handling**: - If the tree has only one node, return that single node. 5. **Function Signature**: - Ensure compatibility and reusability of the `TreeNode` class and `find_deepest_node` function. By following these guidelines, you ensure the new question aligns with style, complexity, topic alignment, and question length similar to the originally provided question.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right from collections import deque def find_deepest_node(root): if not root: return [] queue = deque([(root, 0)]) max_depth = -1 deepest_nodes = [] while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth deepest_nodes = [node.value] elif depth == max_depth: deepest_nodes.append(node.value) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return deepest_nodes"},{"question":"# Color Palette Management **Objective**: Create a color palette management system that allows for the addition, removal, and retrieval of colors in a palette. **Task**: 1. **Core Functionality**: Implement a class `ColorPalette` that manages a collection of colors. 2. **Methods to Implement**: - `add_color(name, hex_code)`: Adds a new color to the palette with the given name and hexadecimal code. - `remove_color(name)`: Removes a color from the palette by its name. - `get_color(name)`: Retrieves the hexadecimal code of the color by its name. - `list_colors()`: Returns a list of all colors in the palette with their names and hexadecimal codes. **Input and Output Formats**: * **Input**: * For `add_color`: `name` (str), `hex_code` (str) - The name and the hexadecimal code of the color. * For `remove_color`: `name` (str) - The name of the color to remove. * For `get_color`: `name` (str) - The name of the color to retrieve. * **Output**: * For `add_color` and `remove_color`: No return value. * For `get_color`: `hex_code` (str) - The hexadecimal code of the color. * For `list_colors`: A list of dictionaries with `name` (str) and `hex_code` (str) as keys. **Constraints**: * Every color name must be unique within the palette. * The `hex_code` should be a valid 6-character hexadecimal string. * If a color name does not exist when calling `remove_color` or `get_color`, an appropriate error message should be returned. **Functionality Requirements**: The methods should handle typical cases efficiently. Favor readability and correctness over premature optimization. **Class Signature**: ```python class ColorPalette: def __init__(self): # Initialize the color palette pass def add_color(self, name: str, hex_code: str) -> None: # Adds a new color to the palette pass def remove_color(self, name: str) -> None: # Removes a color from the palette by its name pass def get_color(self, name: str) -> str: # Retrieves the hexadecimal code of the color by its name pass def list_colors(self) -> list: # Returns a list of all colors in the palette pass ``` **Examples**: 1. `palette = ColorPalette()` `palette.add_color(\\"Red\\", \\"#FF0000\\")` `palette.add_color(\\"Green\\", \\"#00FF00\\")` `palette.get_color(\\"Red\\")` should return `\\"#FF0000\\"` `palette.remove_color(\\"Green\\")` should remove the color `Green` from the palette `palette.list_colors()` should return `[{\\"name\\": \\"Red\\", \\"hex_code\\": \\"#FF0000\\"}]` 2. `palette.add_color(\\"Blue\\", \\"#0000FF\\")` `palette.list_colors()` should return `[{\\"name\\": \\"Red\\", \\"hex_code\\": \\"#FF0000\\"}, {\\"name\\": \\"Blue\\", \\"hex_code\\": \\"#0000FF\\"}]` `palette.get_color(\\"Orange\\")` should return `\\"Error: Color \'Orange\' not found.\\"` `palette.remove_color(\\"Yellow\\")` should return `\\"Error: Color \'Yellow\' not found.\\"` **Notes**: 1. Ensure all error scenarios such as invalid hexadecimal codes or non-existent color names are handled gracefully with appropriate error messages. 2. Support case-insensitive color name lookups.","solution":"class ColorPalette: def __init__(self): # Initialize the color palette self.colors = {} def add_color(self, name: str, hex_code: str) -> None: if not isinstance(hex_code, str) or not hex_code.startswith(\'#\') or len(hex_code) != 7: raise ValueError(\\"Invalid hexadecimal code.\\") self.colors[name.lower()] = hex_code def remove_color(self, name: str) -> str: if name.lower() in self.colors: del self.colors[name.lower()] else: return f\\"Error: Color \'{name}\' not found.\\" def get_color(self, name: str) -> str: if name.lower() in self.colors: return self.colors[name.lower()] else: return f\\"Error: Color \'{name}\' not found.\\" def list_colors(self) -> list: return [{\\"name\\": name, \\"hex_code\\": hex_code} for name, hex_code in self.colors.items()]"},{"question":"Employee Information System You are tasked with creating a simple Employee Information System (EIS). Your system should be able to: 1. Add a new employee. 2. Remove an existing employee by their ID. 3. Retrieve employee details using their ID. 4. List all employees within a specified age range. Requirements: 1. **Add Employee (`add_employee` method)**: Takes employee details (ID, name, age) and adds the employee to the system. Ensure employee IDs are unique. 2. **Remove Employee (`remove_employee` method)**: Takes an ID and removes the corresponding employee from the system. 3. **Get Employee (`get_employee` method)**: Takes an ID and returns the details of the corresponding employee. 4. **List Employees by Age (`list_employees_by_age` method)**: Takes a minimum and maximum age and returns a list of employees whose ages are within the specified range. # Input: 1. **Input for Add Employee**: A dictionary containing employee details: ID (integer), Name (string), and Age (integer). 2. **Input for Remove Employee**: A single integer representing the employee ID to remove. 3. **Input for Get Employee**: A single integer representing the employee ID to retrieve information for. 4. **Input for List Employees by Age**: Two integers representing the minimum and maximum ages for the range. # Output: 1. **Output for Add Employee**: Nothing. The system updates internally. 2. **Output for Remove Employee**: Nothing. The system updates internally. 3. **Output for Get Employee**: A dictionary with the employee details (ID, name, age) or a message indicating the employee does not exist. 4. **Output for List Employees by Age**: A list of dictionaries containing employee details for each employee that matches the age criteria. # Constraints: - Employee IDs are positive integers. - Names are non-empty strings consisting of alphabetic characters and spaces. - Ages are integers between 18 and 65. - Maximum number of employees in the system is 10^3. Example: ```python eis = EmployeeInformationSystem() # Adding employees eis.add_employee({\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}) eis.add_employee({\\"ID\\": 102, \\"name\\": \\"Bob\\", \\"age\\": 40}) eis.add_employee({\\"ID\\": 103, \\"name\\": \\"Charlie\\", \\"age\\": 25}) # Removing an employee eis.remove_employee(102) # Getting employee details print(eis.get_employee(101)) # Output: {\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30} # Listing employees by age range 20 to 35 print(eis.list_employees_by_age(20, 35)) # Output: [{\\"ID\\": 101, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"ID\\": 103, \\"name\\": \\"Charlie\\", \\"age\\": 25}] ``` Implement the Employee Information System class with the methods described above. Ensure the system is efficient and handles edge cases appropriately.","solution":"class EmployeeInformationSystem: def __init__(self): self.employees = {} def add_employee(self, employee): Adds a new employee to the system. :param employee: Dictionary containing \'ID\', \'name\', and \'age\' of the employee if employee[\'ID\'] in self.employees: raise ValueError(\\"Employee ID must be unique\\") self.employees[employee[\'ID\']] = employee def remove_employee(self, employee_id): Removes an employee from the system by their ID. :param employee_id: Integer representing the employee ID to remove if employee_id in self.employees: del self.employees[employee_id] else: raise ValueError(\\"Employee ID not found\\") def get_employee(self, employee_id): Retrieves an employee\'s details by their ID. :param employee_id: Integer representing the employee ID :return: Dictionary containing the employee details or a message if the employee does not exist return self.employees.get(employee_id, \\"Employee does not exist\\") def list_employees_by_age(self, min_age, max_age): Lists all employees within a specified age range. :param min_age: Integer representing the minimum age :param max_age: Integer representing the maximum age :return: List of dictionaries containing employee details return [emp for emp in self.employees.values() if min_age <= emp[\'age\'] <= max_age]"},{"question":"# Coding Assessment Question Background One of the common tasks in data manipulation is to process records in a structured format and extract insights based on specific criteria. You are required to implement a function that computes the median of a set of numbers, where the median is defined as the middle value when the numbers are sorted in non-decreasing order, or the average of the two middle values if there is an even number of numbers. Problem Statement Write a function that, given a list of integers, finds the median value. Implement the function `find_median(numbers: List[int]) -> float` that computes the median of the input list. Input * A list of integers `numbers` with `1 ≤ len(numbers) ≤ 1000`. * The list `numbers` may contain both positive and negative integers. Output * A float representing the median value of the input list. Constraints * Your solution should handle sorting and median finding efficiently, considering `1 ≤ len(numbers) ≤ 1000`. Example ```python >>> find_median([4, 5, 1, 2, 3]) 3.0 >>> find_median([7, 1, 3, 2, 8, 5]) 4.0 # (3 + 5) / 2 = 4.0 >>> find_median([-5, -3, -10, -1, 0]) -3.0 ```","solution":"from typing import List def find_median(numbers: List[int]) -> float: Returns the median value of a list of integers. n = len(numbers) sorted_numbers = sorted(numbers) # sort the list to find the median mid = n // 2 # find the middle index if n % 2 == 0: # if even number of elements, return average of the two middle values return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2 else: # if odd number of elements, return the middle value return float(sorted_numbers[mid])"},{"question":"# Problem Statement You are provided with a network of cities and roads connecting them. Each road has a certain non-negative travel time associated with it. Your task is to find the shortest travel time between two specified cities in the network. Implement the function `shortest_travel_time` to compute the shortest path using Dijkstra\'s algorithm. Function Signature ```python def shortest_travel_time(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: ``` # Input - `num_cities`: An integer representing the number of cities in the network (cities are numbered from 0 to `num_cities`-1). - `roads`: A list of tuples where each tuple contains three integers `(u, v, w)` representing a bidirectional road from city `u` to city `v` with a travel time of `w`. - `start`: An integer representing the starting city\'s number. - `end`: An integer representing the destination city\'s number. # Output - An integer representing the shortest travel time between the `start` and `end` cities. If there is no path between these cities, return -1. # Constraints - 1 ≤ `num_cities` ≤ 1000 - 0 ≤ `u`, `v` < `num_cities` - 0 ≤ `w` ≤ 1000 - `start` and `end` are valid integers within the range of cities (0 to `num_cities`-1). - There may be multiple roads between the same pair of cities. # Example ```python # Example 1: num_cities = 5 roads = [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40), (0, 4, 100)] start, end = 0, 4 assert shortest_travel_time(num_cities, roads, start, end) == 100 # Example 2: num_cities = 3 roads = [(0, 1, 1), (1, 2, 1), (0, 2, 10)] start, end = 0, 2 assert shortest_travel_time(num_cities, roads, start, end) == 2 # Example 3: num_cities = 4 roads = [(0, 1, 5), (1, 2, 10), (2, 3, 5), (0, 2, 20)] start, end = 0, 3 assert shortest_travel_time(num_cities, roads, start, end) == 20 ``` # Notes 1. Validate the inputs properly before proceeding with the algorithm. 2. Use an efficient algorithm, such as Dijkstra\'s, to ensure the solution handles large inputs within acceptable time limits. 3. Handle edge cases, such as: - No roads at all. - Start and end being the same city. - Disconnected graph where no path exists between start and end.","solution":"import heapq from typing import List, Tuple def shortest_travel_time(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create a graph from the roads graph = {i: [] for i in range(num_cities)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra\'s algorithm initialization heap = [(0, start)] # (distance, node) distances = {i: float(\'inf\') for i in range(num_cities)} distances[start] = 0 visited = set() while heap: current_distance, current_node = heapq.heappop(heap) if current_node in visited: continue visited.add(current_node) # If we reach the end city, return the distance if current_node == end: return current_distance # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) # If end was not reached return -1"},{"question":"# Coding Assessment Question **Context**: You have been recruited to develop a component of a larger system that involves handling sequences of characters. The specific task is to check if a string is a permutation of a palindrome—even if it is not a palindrome itself, the characters in the string should be able to be rearranged to form one. **Objective**: Write a function `can_form_palindrome` that determines if the input string can be rearranged to form a palindrome. **Function signature**: ```python def can_form_palindrome(string: str) -> bool: pass ``` **Input**: * A single string `string` which may consist of lowercase and uppercase alphabetic characters. **Output**: * Return `True` if the string can be rearranged to form a palindrome, `False` otherwise. **Constraints**: 1. The string should only contain alphabetic characters. 2. The function should ignore spaces, punctuation, and case during computation. 3. The implementation should be efficient in terms of time and space complexity. **Example**: ```python >>> can_form_palindrome(\'Tact Coa\') True # Corresponds to permutations like \\"taco cat\\", \\"atco cta\\" >>> can_form_palindrome(\'apple\') False >>> can_form_palindrome(\'racecar\') True ``` **Performance Requirements**: * Aim for a linear time complexity (O(n)). * Utilize efficient space management considering character counts. **Additional Information**: * A string can form a palindrome if at most one character has an odd count in the string. * A useful approach is to count each character\'s frequency and then determine if the conditions for a palindrome can be met based on these counts. * Utilize set operations or dictionary structures to optimize the solution.","solution":"def can_form_palindrome(string: str) -> bool: Determines if a string can be rearranged to form a palindrome. Args: string (str): The string to analyze Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Clean the string: ignore spaces, convert to lowercase cleaned_string = string.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(cleaned_string) # Check the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one odd frequency character return odd_count <= 1"},{"question":"# Code Exercise: Implement a function that simulates the process of generating a list of unique random integers between 1 and `m`, such that the list contains exactly `n` distinct numbers. If `n` is greater than `m`, the function should return the list of numbers from 1 to `m` shuffled. # Function Signature ```python def generate_unique_randoms(n: int, m: int) -> list: ``` # Input - An integer `n`, where 1 ≤ `n`. - An integer `m`, where 1 ≤ `m`. # Output - Return a list of `n` unique random integers between 1 and `m`. # Constraints - The function should handle cases where `n` is greater than or equal to `m` by returning all integers from 1 to `m` shuffled if necessary. - Ensure the randomness is appropriately handled using Python\'s random library. # Scenario You are tasked with creating a lottery system where a certain number of unique random lottery numbers need to be generated within a specified range. The system needs to handle cases where the total numbers requested exceed the available range, ensuring no number repeats within a given set. # Example ```python # Example usage: print(generate_unique_randoms(5, 10)) # Output might be: [9, 2, 10, 5, 3] print(generate_unique_randoms(15, 10)) # Output might be: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ```","solution":"import random def generate_unique_randoms(n: int, m: int) -> list: Generates a list of `n` unique random integers between 1 and `m`. If `n` is greater than `m`, returns a shuffled list of numbers from 1 to `m`. Parameters: - n (int): Number of unique random integers to generate. - m (int): Upper bound of the range (inclusive). Returns: - list of `n` unique random integers between 1 and `m`. if n >= m: return random.sample(range(1, m + 1), m) return random.sample(range(1, m + 1), n)"},{"question":"# Coding Task: Implement K-Nearest Neighbors (K-NN) Classifier Description You are given a dataset containing labeled samples from two classes. Your task is to implement a basic version of the K-Nearest Neighbors (K-NN) algorithm to classify new data points. The classifier should identify the K nearest neighbors of a test sample and assign it the class that\'s most common among its neighbors. Requirements 1. Implement the `KNNClassifier` class. 2. The class should contain methods to fit the model on the training data and predict class labels for the test data. 3. Your implementation should handle cases where there are ties in the neighbors\' class counts by choosing the class with the smallest label. Input Format 1. Training data as a list of tuples where each tuple consists of a feature vector and a class label. 2. Test data as a list of feature vectors. Output Format A list of predicted class labels for the test samples. Constraints 1. The value of K will be a positive integer and will be provided during the initialization of the classifier. 2. Ensure your algorithm works efficiently even for moderately large datasets. Example ```python # Training data: (features, label) train_data = [ ([1, 2, 3], 1), ([3, 4, 5], 1), ([5, 6, 7], -1), ([2, 3, 4], -1), ([4, 5, 6], 1), ] # Test data: features only test_samples = [ [2, 3, 3], [5, 5, 5] ] # K-NN Classifier Initialization knn = KNNClassifier(train_data=train_data, k=3) # Fitting the model knn.fit() # Predicting predictions = knn.predict(test_samples) print(predictions) # Expected Output: [1, 1] ``` Implement the `KNNClassifier` class based on the given example above.","solution":"from collections import Counter import math class KNNClassifier: def __init__(self, train_data, k): self.train_data = train_data self.k = k def fit(self): pass # No fitting necessary for K-NN, but method required for API consistency. def predict(self, test_samples): predictions = [] for test_sample in test_samples: distances = [] for features, label in self.train_data: distance = self._euclidean_distance(features, test_sample) distances.append((distance, label)) # Sort based on distance and get top k elements sorted_distances = sorted(distances, key=lambda x: x[0])[:self.k] # Extract the labels of the k nearest neighbors k_nearest_labels = [label for _, label in sorted_distances] # Count the frequency of each label label_counter = Counter(k_nearest_labels) # Get the label with the highest frequency (smallest label in case of ties) most_common_label = min(label_counter.items(), key=lambda x: (-x[1], x[0]))[0] predictions.append(most_common_label) return predictions def _euclidean_distance(self, point1, point2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2)))"},{"question":"# Problem Statement Design and implement a function that adds a watermark text to an image. The function will adjust the opacity of the watermark text and position it at a specified location on the image. # Function Signature ```python def add_watermark(img_path: str, watermark_text: str, opacity: float, position: tuple) -> None: Adds a watermark text to an image and saves the result. Parameters: img_path (str): The path to the input image file. watermark_text (str): The text to be used as a watermark. opacity (float): The opacity of the watermark text, must be between 0.0 (completely transparent) and 1.0 (fully opaque). position (tuple): A tuple of two integers specifying the (x, y) position of the watermark text on the image. Returns: None ``` # Input * `img_path` (str): A valid file path to the input image. * `watermark_text` (str): The text to be added as a watermark. * `opacity` (float): The opacity level of the watermark, within the range [0.0, 1.0]. * `position` (tuple): A tuple of two integers indicating the (x, y) coordinates for the position of the watermark text on the image. # Output * The function should save the watermarked image to a file named `watermarked_output.png` in the current working directory. # Constraints * The function should raise a `ValueError` if the `opacity` is not within the range [0.0, 1.0]. * You may assume that the input image path is valid and the image load operation will succeed. * Ensure the watermark text is fully visible within the boundaries of the image given the specified position. # Performance Requirements * The implementation should efficiently handle images of size up to 4096x4096 pixels. # Example ```python # Add a watermark with 50% opacity at position (100, 200) and save it as \'watermarked_output.png\' add_watermark(\\"image_data/sample.jpg\\", \\"Sample Watermark\\", 0.5, (100, 200)) ``` # Notes * You may use the `PIL` (Pillow) library to handle image loading, saving, and text drawing. * Ensure the watermark text respects the specified opacity level. * Consider using the `RGBA` mode for handling image transparency. # Hints * Use the `ImageDraw` module from the `PIL` library to draw text on an image. * Use the `Image.alpha_composite` method to properly handle the opacity of the watermark text.","solution":"from PIL import Image, ImageDraw, ImageFont def add_watermark(img_path: str, watermark_text: str, opacity: float, position: tuple) -> None: Adds a watermark text to an image and saves the result. Parameters: img_path (str): The path to the input image file. watermark_text (str): The text to be used as a watermark. opacity (float): The opacity of the watermark text, must be between 0.0 (completely transparent) and 1.0 (fully opaque). position (tuple): A tuple of two integers specifying the (x, y) position of the watermark text on the image. Returns: None # Validate opacity value if not (0.0 <= opacity <= 1.0): raise ValueError(\\"Opacity must be between 0.0 and 1.0\\") # Open the original image image = Image.open(img_path).convert(\\"RGBA\\") # Create an image for the watermark text text_overlay = Image.new(\\"RGBA\\", image.size, (255, 255, 255, 0)) draw = ImageDraw.Draw(text_overlay) # Use a basic font font = ImageFont.load_default() # Draw the watermark text on the text overlay draw.text(position, watermark_text, font=font, fill=(255, 255, 255, int(255 * opacity))) # Composite the watermark with the original image watermarked_image = Image.alpha_composite(image, text_overlay) # Save the result watermarked_image.save(\\"watermarked_output.png\\")"},{"question":"# Problem: Efficient Prefix Sum Calculation Given an array of integers and several queries, implement a function to efficiently compute the sum of elements in a specified range of the array. Each query asks for the sum of elements between two given indices (inclusive). **Input Format** - The first input line contains an integer ( n ) (1 ≤ n ≤ 10^5), the number of elements in the array. - The second input line contains ( n ) integers representing the array elements ( a_i ) (-10^6 ≤ ( a_i ) ≤ 10^6). - The third input line contains an integer ( q ) (1 ≤ q ≤ 10^5), the number of queries. - The next ( q ) lines each contain two integers ( l ) and ( r ) (1 ≤ l ≤ r ≤ n), representing the range of indices for the query. **Output Format** - For each query, output the sum of elements from index ( l ) to ( r ), inclusive. **Constraints** - The time complexity for processing each query should be O(1). - Preprocessing of the array is allowed with a time complexity of O(n). **Example** *Input:* ``` 5 1 2 3 4 5 3 1 3 2 4 1 5 ``` *Output:* ``` 6 9 15 ``` # Detailed Requirements 1. Implement a function `prefix_sum` to compute the prefix sums of the array. 2. Implement a function `range_sum` to handle queries using the prefix sums and provide the results in constant time. 3. Ensure the solution handles large inputs efficiently by using appropriate data structures and pre-computation methods.","solution":"def prefix_sum(arr): Compute the prefix sums of the array. Args: arr : list of int The input array. Returns: list of int The prefix sum array. n = len(arr) prefix_sums = [0] * (n + 1) # Prefix sum array for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] return prefix_sums def range_sum(prefix_sums, l, r): Compute the sum of elements in the range [l, r] using prefix sums. Args: prefix_sums : list of int The prefix sum array. l : int The starting index of the range (1-based). r : int The ending index of the range (1-based). Returns: int The sum of elements in the range [l, r]. return prefix_sums[r] - prefix_sums[l - 1]"},{"question":"# Problem Statement You are given a list of dictionaries representing students and their scores in different subjects. Each dictionary has the student\'s name as a key, and the value is another dictionary containing subject names as keys and scores as values. Your task is to write a function `calculate_top_student()` that identifies the student with the highest average score across all subjects and returns their name. If multiple students have the same highest average score, return the name that appears first alphabetically. # Function Signature ```python def calculate_top_student(students: list) -> str: pass ``` # Input - A list of dictionaries, where each dictionary has a student\'s name as the key and another dictionary as the value containing subject names and their corresponding scores. # Output - A string representing the name of the student with the highest average score. If there is a tie, return the alphabetically first name. # Constraints - Each dictionary will have at least one student\'s data. - Each student will have scores in at least one subject. - Scores are non-negative integers. - Ensure the function completes within a reasonable time frame. # Example ```python students = [ {\\"Alice\\": {\\"Math\\": 90, \\"English\\": 85, \\"Science\\": 95}}, {\\"Bob\\": {\\"Math\\": 70, \\"English\\": 80, \\"Science\\": 75, \\"History\\": 85}}, {\\"Charlie\\": {\\"Math\\": 85, \\"English\\": 90, \\"History\\": 80}} ] >>> calculate_top_student(students) \'Alice\' ``` # Notes - Calculate the average score for each student by dividing the total score of all subjects by the number of subjects. - In case of a tie in average scores, return the name that is alphabetically first.","solution":"def calculate_top_student(students): Returns the name of the student with the highest average score. If multiple students have the same highest average score, returns the alphabetically first name. top_student = \\"\\" highest_avg = -1 for student_dict in students: for name, scores in student_dict.items(): total_score = sum(scores.values()) num_subjects = len(scores) average_score = total_score / num_subjects if (average_score > highest_avg) or (average_score == highest_avg and name < top_student): highest_avg = average_score top_student = name return top_student"},{"question":"# Objective Given the dimensions of a rectangular prism and a point in 3D space, write a function that checks whether the point lies inside the prism and another to calculate the volume of the prism. # Function Implementation Function 1: Check Point Inside Prism - **Function Name**: `is_point_inside_prism` - **Input**: - `prism_x` (tuple of two floats): x-coordinates of the prism\'s edges (min_x, max_x). - `prism_y` (tuple of two floats): y-coordinates of the prism\'s edges (min_y, max_y). - `prism_z` (tuple of two floats): z-coordinates of the prism\'s edges (min_z, max_z). - `point` (tuple of three floats): coordinates of the point (x, y, z). - **Output**: (bool) True if the point is inside or on the surface of the prism, False otherwise. - **Constraints**: - Coordinates defining the prism must have `min` values less than or equal to `max` values. Function 2: Calculate Prism Volume - **Function Name**: `calculate_prism_volume` - **Input**: - `prism_x` (tuple of two floats): x-coordinates of the prism\'s edges (min_x, max_x). - `prism_y` (tuple of two floats): y-coordinates of the prism\'s edges (min_y, max_y). - `prism_z` (tuple of two floats): z-coordinates of the prism\'s edges (min_z, max_z). - **Output**: (float) Volume of the prism (cubic meters). - **Constraints**: - Coordinates defining the prism must have `min` values less than or equal to `max` values. # Error Handling - Raise ValueError with appropriate messages in the following conditions: - `min` value greater than `max` value in the prism coordinates for both functions. # Example ```python def is_point_inside_prism(prism_x: Tuple[float, float], prism_y: Tuple[float, float], prism_z: Tuple[float, float], point: Tuple[float, float, float]) -> bool: # Implement the function as specified above def calculate_prism_volume(prism_x: Tuple[float, float], prism_y: Tuple[float, float], prism_z: Tuple[float, float]) -> float: # Implement the function as specified above ``` Sample Usage ```python # Check if a point is inside the prism is_point_inside_prism((0, 10), (0, 10), (0, 10), (5, 5, 5)) # Expected output: True is_point_inside_prism((0, 10), (0, 10), (0, 10), (15, 5, 5)) # Expected output: False # Calculate the volume of a prism calculate_prism_volume((0, 10), (0, 5), (0, 5)) # Expected output: 250.0 ``` # Notes - Ensure that your solution handles edge cases and constraints effectively. - Assume the inputs are provided in a 3D coordinate plane where the prism\'s edges are aligned with the coordinate axes.","solution":"def is_point_inside_prism(prism_x, prism_y, prism_z, point): Check if a point is inside or on the surface of a rectangular prism. Arguments: prism_x -- tuple of two floats (min_x, max_x) prism_y -- tuple of two floats (min_y, max_y) prism_z -- tuple of two floats (min_z, max_z) point -- tuple of three floats (x, y, z) Returns: bool -- True if the point is inside or on the prism, False otherwise min_x, max_x = prism_x min_y, max_y = prism_y min_z, max_z = prism_z x, y, z = point if min_x > max_x or min_y > max_y or min_z > max_z: raise ValueError(\\"Minimum values must be less than or equal to the maximum values in the prism coordinates.\\") return (min_x <= x <= max_x) and (min_y <= y <= max_y) and (min_z <= z <= max_z) def calculate_prism_volume(prism_x, prism_y, prism_z): Calculate the volume of a rectangular prism. Arguments: prism_x -- tuple of two floats (min_x, max_x) prism_y -- tuple of two floats (min_y, max_y) prism_z -- tuple of two floats (min_z, max_z) Returns: float -- Volume of the prism min_x, max_x = prism_x min_y, max_y = prism_y min_z, max_z = prism_z if min_x > max_x or min_y > max_y or min_z > max_z: raise ValueError(\\"Minimum values must be less than or equal to the maximum values in the prism coordinates.\\") length = max_x - min_x width = max_y - min_y height = max_z - min_z return length * width * height"},{"question":"# Coding Assessment Question Context JSON parsing is a common task in programming that involves extracting data from JSON-formatted text. In this exercise, you\'ll parse a JSON string to analyze its structure by counting the number of key-value pairs at the top level. Task Implement a function `count_keys` that takes a JSON string representing an object and returns the number of top-level key-value pairs in that object. Function Signature ```python def count_keys(json_str: str) -> int: ``` Input - `json_str` (string): A string in JSON format representing an object. The JSON object will always contain string keys and can have values that are strings, numbers, arrays, or other objects. Output - An integer representing the number of top-level key-value pairs in the JSON object. Example - Input: `json_str = \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\"}\'` - Output: `3` - Input: `json_str = \'{\\"success\\": true, \\"data\\": {\\"type\\": \\"user\\", \\"id\\": \\"1234\\"}}\'` - Output: `2` Constraints - `json_str` is guaranteed to be a valid JSON string. - The function should not modify the input string. Requirements * **Edge Cases**: Handle cases where the JSON object is empty (`{}`) properly. * **Performance**: The function should efficiently parse the JSON string and count the keys. Write a well-tested function to accurately count the keys in a JSON object. Make sure your implementation is robust and handles all edge cases.","solution":"import json def count_keys(json_str: str) -> int: Parses the JSON string and returns the number of top-level key-value pairs. Parameters: json_str (str): A string in JSON format representing an object. Returns: int: The number of top-level key-value pairs in the JSON object. json_obj = json.loads(json_str) return len(json_obj)"},{"question":"# Fibonacci Sequence with Memoization Given the task to generate the Fibonacci sequence up to a given length using an efficient approach with memoization, complete the following function. # Problem Description **Objective**: Write a function `generate_fibonacci` to generate the Fibonacci sequence for a given length using memoization. # Function Signature: ```python def generate_fibonacci(n: int) -> list[int]: ``` # Input - `n` (int): The length of the Fibonacci sequence to generate, `0 ≤ n ≤ 10^3`. # Output - Returns a list of integers representing the Fibonacci sequence up to the `n`-th element. # Constraints 1. `n` is a non-negative integer (0 ≤ n ≤ 1000). 2. Efficient computation - aim to use Memoization to improve time complexity. # Examples 1. **Example 1** ```python assert generate_fibonacci(0) == [] ``` 2. **Example 2** ```python assert generate_fibonacci(5) == [0, 1, 1, 2, 3] ``` 3. **Example 3** ```python assert generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Note - The provided examples illustrate typical inputs and can be used to validate your solution. - Ensure to handle edge cases such as when `n` is 0 or 1, and larger values within the constraints. # Hints - You may use a dictionary or list to store previously calculated Fibonacci numbers. - Implement the recursive approach with memoization to avoid redundant calculations.","solution":"def generate_fibonacci(n: int) -> list[int]: Generates the Fibonacci sequence up to the nth element using memoization. :param n: Length of the sequence to generate :return: List of integers representing the Fibonacci sequence if n == 0: return [] elif n == 1: return [0] fib_sequence = [0] * n fib_sequence[0], fib_sequence[1] = 0, 1 for i in range(2, n): fib_sequence[i] = fib_sequence[i - 1] + fib_sequence[i - 2] return fib_sequence"},{"question":"# Problem Description You are given a string containing a mix of numbers and alphabetic characters. Your task is to separate the numbers and letters into two distinct strings and then concatenate these two strings in the order of numbers followed by letters. # Task Write a function `rearrange_string` that takes one string as input and returns a single string with numbers followed by letters. # Input * `input_string` (str): A string containing both numbers and alphabetic characters. # Output * (str): A concatenated string with all numbers coming first, followed by all letters. # Constraints * The input string can be of any length, from 0 to 10^5. * The string will only contain digits from \'0\' to \'9\' and alphabetic characters from \'a\' to \'z\' and \'A\' to \'Z\'. * There will be at least one digit or one alphabetic character in the input string. # Performance Requirements * The solution should have a linear time complexity, i.e., O(n), where n is the length of the input string. # Example ```python def rearrange_string(input_string: str) -> str: pass # Example usage: print(rearrange_string(\\"a1b2c3\\")) # Output: \\"123abc\\" print(rearrange_string(\\"4d5e6f\\")) # Output: \\"456def\\" print(rearrange_string(\\"abc123\\")) # Output: \\"123abc\\" print(rearrange_string(\\"123\\")) # Output: \\"123\\" print(rearrange_string(\\"abc\\")) # Output: \\"abc\\" ```","solution":"def rearrange_string(input_string: str) -> str: Given a string containing both numbers and alphabetic characters, return a string with all numbers followed by all letters. numbers = [] letters = [] for char in input_string: if char.isdigit(): numbers.append(char) else: letters.append(char) return \'\'.join(numbers) + \'\'.join(letters)"},{"question":"# Unique Number Finder You have been given an array where every element appears twice except for one. This unique element appears exactly once. **Task**: Implement a function `find_unique_number` to find this unique element in the array. # Function Signature ```python def find_unique_number(nums: list) -> int: Find the element that appears exactly once in an array where every other element appears twice. Args: nums (list): A list of integers where each element appears exactly twice except for one. Returns: int: The element that appears only once. ``` # Requirements 1. **Input**: - `nums` (list): A list of integers (1 ≤ len(nums) ≤ 10^5), where every element except one appears twice. 2. **Output**: - An integer representing the unique element that appears only once in the list. # Instructions 1. You must implement the function without using extra memory (i.e., in constant space). 2. Maintain a linear runtime complexity of O(n). 3. Consider edge cases such as an empty input list should return None. 4. Ensure that your approach efficiently handles large input sizes. # Example ```python >>> find_unique_number([1, 2, 3, 1, 2]) 3 >>> find_unique_number([7, 11, 7, 3, 2, 11, 3]) 2 >>> find_unique_number([4]) 4 ``` # Constraints: - Performance is crucial; ensure your solution runs in O(n) time with O(1) additional space. - Your implementation must handle large inputs efficiently. # Hint - Think about how XOR operation can be used to achieve the desired result due to its properties.","solution":"def find_unique_number(nums): Find the element that appears exactly once in an array where every other element appears twice. Args: nums (list): A list of integers where each element appears exactly twice except for one. Returns: int: The element that appears only once. None if the list is empty. if not nums: return None unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Coding Question: Implement a Custom PCA with Optional k-NN Classifier Objective You are tasked with implementing a Principal Component Analysis (PCA) for dimensionality reduction, followed by an optional k-Nearest Neighbors (k-NN) classifier for the reduced dataset. Your solution should demonstrate your understanding of PCA, the process of dimensionality reduction, and the application of k-NN classification. Requirements 1. Implement a function `reduce_and_classify(features: np.ndarray, target: np.ndarray, n_components: int, use_knn: bool = True, k: int = 5, test_size: float = 0.25) -> tuple` that: * Applies PCA to the given feature set, reducing it to the specified number of components `n_components`. * If `use_knn` is True, splits the reduced feature set and target data into training and testing subsets based on the given `test_size`. * If `use_knn` is True, trains a k-NN classifier using `k` neighbors on the training data, and evaluates its performance on the test data set. * Returns a tuple containing the PCA model, the k-NN classifier (if used), and its accuracy score (if `use_knn` is True). 2. The function should handle common edge cases such as missing values or imbalanced target classes appropriately. Constraints - Input features will be a two-dimensional numpy array of shape (N, M), where N is the number of samples and M is the number of features. - Target will be a one-dimensional numpy array of length N. - The `test_size` parameter will be a float between 0 and 1, representing the proportion of the dataset to be used for testing. - The implementation should be efficient and work for datasets with up to 100,000 samples and 500 features without excessive memory usage. - If `use_knn` is False, the function should only perform PCA and return the PCA model. Performance Requirements - Submissions are expected to implement error handling for invalid inputs. - PCA should successfully reduce the dataset\'s dimensionality to the specified number of components. - If k-NN is used, the model accuracy on the test set should be reasonable. - Execution time should be reasonable, considering the complexity of the PCA and k-NN algorithms. Expected API ```python from typing import Tuple, Optional import numpy as np from sklearn.decomposition import PCA from sklearn.neighbors import KNeighborsClassifier def reduce_and_classify( features: np.ndarray, target: np.ndarray, n_components: int, use_knn: bool = True, k: int = 5, test_size: float = 0.25 ) -> Tuple[PCA, Optional[KNeighborsClassifier], Optional[float]]: # Your code here pass ``` # Example Usage ```python import numpy as np # Example dataset features = np.array([[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], ...]) target = np.array([0, 0, ...]) # Reduce dimensions with PCA and optionally classify with k-NN pca, knn, test_score = reduce_and_classify(features, target, n_components=2, use_knn=True, k=3, test_size=0.3) print(\\"PCA Model:\\", pca) if knn: print(\\"k-NN Classifier:\\", knn) print(\\"Test Set Accuracy:\\", test_score) ``` # Notes - You can use libraries such as `scikit-learn` for PCA, train-test splitting, and k-NN classification. - Document your code and provide comments explaining key steps and decisions.","solution":"from typing import Tuple, Optional import numpy as np from sklearn.decomposition import PCA from sklearn.neighbors import KNeighborsClassifier from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.metrics import accuracy_score def reduce_and_classify( features: np.ndarray, target: np.ndarray, n_components: int, use_knn: bool = True, k: int = 5, test_size: float = 0.25 ) -> Tuple[PCA, Optional[KNeighborsClassifier], Optional[float]]: # Standardize the features scaler = StandardScaler() features_standardized = scaler.fit_transform(features) # Apply PCA pca = PCA(n_components=n_components) features_reduced = pca.fit_transform(features_standardized) if use_knn: # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split( features_reduced, target, test_size=test_size ) # Train k-NN classifier knn = KNeighborsClassifier(n_neighbors=k) knn.fit(X_train, y_train) # Make predictions and evaluate accuracy y_pred = knn.predict(X_test) test_score = accuracy_score(y_test, y_pred) return pca, knn, test_score return pca, None, None"},{"question":"# Problem Statement You are tasked with designing a function that determines the perimeter of a rectangle. The perimeter of a rectangle is given by: [ P = 2 times (w + h) ] Where: - ( w ) is the width (in units) - ( h ) is the height (in units) # Requirements 1. **Function Name**: `calculate_perimeter` 2. **Input**: - A single list `dimensions` containing two positive integers: width and height. - Example: `[5, 3]` 3. **Output**: - A single tuple: (\\"Perimeter\\", calculated_perimeter) - Example: `(\\"Perimeter\\", 16)` # Constraints - Both width ( w ) and height ( h ) are positive integers greater than zero. - If either width or height is zero or negative, raise a `ValueError` with the message: - \\"Width cannot be 0 or negative\\" if the issue is with the width. - \\"Height cannot be 0 or negative\\" if the issue is with the height. # Example ```python Input: [5, 3] Output: (\\"Perimeter\\", 16) Input: [0, 3] Error: ValueError: Width cannot be 0 or negative Input: [5, -3] Error: ValueError: Height cannot be 0 or negative ``` # Your Task Write the function `calculate_perimeter` that reads a list with the width and height, validates them, calculates the perimeter using the specified formula, and returns the result in the expected format.","solution":"def calculate_perimeter(dimensions): Calculates the perimeter of a rectangle given its dimensions. :param dimensions: List containing two positive integers [width, height] :return: Tuple containing \\"Perimeter\\" and the calculated perimeter width, height = dimensions if width <= 0: raise ValueError(\\"Width cannot be 0 or negative\\") if height <= 0: raise ValueError(\\"Height cannot be 0 or negative\\") perimeter = 2 * (width + height) return (\\"Perimeter\\", perimeter)"},{"question":"Write a function that takes in a list of integers representing temperatures recorded over a period of time and determines the length of the longest continuous subarray where absolute temperature change does not exceed a given threshold. Your function should return the length of this subarray. # Function Signature ```python def longest_stable_period(temperatures: list, threshold: int) -> int: pass ``` # Input * `temperatures`: A list of integers representing the temperatures recorded. * `threshold`: An integer representing the maximum allowable change between any two consecutive temperatures in the subarray. # Output * `longest_stable_period` should return an integer, representing the length of the longest continuous subarray where absolute temperature change between any two consecutive readings does not exceed the `threshold`. # Constraints * All temperature values and the threshold are non-negative integers. * The `temperatures` list is non-empty. # Performance Requirements * Aim for a solution that has a time complexity of `O(n)` and space complexity of `O(1)`. # Notes 1. Raise a `ValueError` if `threshold` is negative. 2. Ensure that the function handles lists with only one temperature correctly. 3. Consecutive temperature changes should be computed as absolute differences. # Example ```python temperatures = [30, 32, 31, 34, 30, 29, 28, 29] threshold = 2 # Explanation: The longest stable period is [30, 32, 31, 34] with length 4 # Expected Output: 4 print(longest_stable_period(temperatures, threshold)) # Output: 4 ``` # Edge Cases 1. If the `temperatures` list contains only one element, the expected output is 1. 2. If `threshold` is 0, the function should find the longest subarray where all temperatures are the same. Implement the `longest_stable_period` function and ensure that your solution passes the provided test cases.","solution":"def longest_stable_period(temperatures: list, threshold: int) -> int: if threshold < 0: raise ValueError(\\"Threshold cannot be negative\\") n = len(temperatures) if n == 1: return 1 longest_period = 1 current_length = 1 for i in range(1, n): if abs(temperatures[i] - temperatures[i-1]) <= threshold: current_length += 1 else: longest_period = max(longest_period, current_length) current_length = 1 longest_period = max(longest_period, current_length) return longest_period"},{"question":"# Problem Statement You are building a compression utility that optimizes storage space for repetitive sequences in strings. Your goal is to implement the RLE (Run-Length Encoding) compression technique. The function should encode a given input string by compressing consecutive identical characters into one character followed by the number of repetitions. # Function Signature ```python def rle_encode(input_str): Compress the input string using Run-Length Encoding (RLE) algorithm. Parameters: input_str -- A non-empty string consisting of alphanumeric characters and symbols. Output: A compressed string using RLE format. pass ``` # Example Usage ```python >>> rle_encode(\\"aaabbccccd\\") \'a3b2c4d1\' >>> rle_encode(\\"wwwwwxyz\\") \'w5x1y1z1\' ``` # Requirements 1. **Input Constraints**: - The input string `input_str` is a non-empty string consisting of alphanumeric characters and symbols. 2. **Output**: - The function should return a compressed string representing the Run-Length Encoded format of the input string. 3. **Performance Consideration**: - Ensure the encoding process is efficient and runs in linear time relative to the size of the input. # Background Context Data compression is a crucial technique in software development, enabling more efficient storage and transmission of information. Run-Length Encoding (RLE) is a simple form of data compression where consecutive identical elements are replaced with a single instance of the element followed by a count of its occurrences. This method is particularly effective when the input data contains many repeated elements. Your task will help reduce storage space and enhance performance in applications that handle large sequences of repetitive data.","solution":"def rle_encode(input_str): Compress the input string using Run-Length Encoding (RLE) algorithm. Parameters: input_str -- A non-empty string consisting of alphanumeric characters and symbols. Output: A compressed string using RLE format. if not input_str: return \\"\\" compressed_str = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: compressed_str.append(f\\"{input_str[i - 1]}{count}\\") count = 1 compressed_str.append(f\\"{input_str[-1]}{count}\\") return \'\'.join(compressed_str)"},{"question":"# Question: Implement an Iterative Quick Sort You have to implement the quick sort algorithm iteratively. Given a list of integers, return the list sorted in ascending order using an iterative quick sort. Function Signature ```python def iterative_quick_sort(arr: list[int]) -> list[int]: pass ``` Input * A list of integers called `arr`. Output * A list of integers sorted in ascending order. Constraints * The input list will have a length between 0 and 1000. * Elements in the list are between -10^6 and 10^6. * Sorting must be performed using an iterative quick sort algorithm. Requirements * Ensure the provided function uses an iterative approach to quick sort. * Avoid using built-in sorting functions. Example ```python print(iterative_quick_sort([3, 6, 8, 10, 1, 2, 1])) # Output: [1, 1, 2, 3, 6, 8, 10] print(iterative_quick_sort([1, 1, 1, 1, 1])) # Output: [1, 1, 1, 1, 1] print(iterative_quick_sort([])) # Output: [] ``` Notes * Ensure to handle edge cases such as empty lists and lists with duplicate elements. * Your solution should be efficient in terms of both time and space complexity.","solution":"def iterative_quick_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr stack = [(0, len(arr) - 1)] while stack: start, end = stack.pop() if start < end: pivot_index = partition(arr, start, end) if pivot_index - 1 > start: stack.append((start, pivot_index - 1)) if pivot_index + 1 < end: stack.append((pivot_index + 1, end)) return arr def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1"},{"question":"# Coding Assessment Question: **Objective**: Write a function to identify the missing number in an arithmetic sequence. This will test your understanding of sequences, arithmetic progressions, and basic problem-solving skills. # Problem Statement: Implement the function `find_missing_number(sequence: List[int]) -> int` which identifies the missing number in an arithmetic sequence. The sequence contains exactly one missing element, and all other elements are in the correct order. # Function Signature: ```python def find_missing_number(sequence: List[int]) -> int: ``` # Input: - `sequence` (List[int]): A list of integers representing an incomplete arithmetic sequence missing exactly one element. # Output: - int: The missing number in the arithmetic sequence. # Constraints: - The sequence will always have at least 2 elements and at most 1000 elements. - The differences between consecutive elements are consistent apart from the missing number. - The list elements are given in increasing order. # Examples: - `find_missing_number([1, 3, 5, 9, 11])` -> 7 - `find_missing_number([10, 20, 30, 50, 60, 70])` -> 40 - `find_missing_number([2, 4, 8, 10])` -> 6 - `find_missing_number([5, 10, 15, 25])` -> 20 - `find_missing_number([100, 200, 300, 500, 600])` -> 400 # Edge Cases to Consider: - The function should handle short sequences (minimum length of 2). - Ensure it can handle both positive and negative sequences. - Consider sequences with both large and small differences between elements. # Additional Requirement: - Avoid using brute force approaches like nested loops; aim for a more efficient solution. # Notes: - The arithmetic sequence is such that the difference between any two consecutive elements is the same, except in the place where the missing number would be. - The solution is expected to identify the correct position and value of the missing element with optimal performance.","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Identifies the missing number in an arithmetic sequence. Parameters: sequence (List[int]): A list of integers representing an incomplete arithmetic sequence. Returns: int: The missing number in the arithmetic sequence. n = len(sequence) total_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 actual_sum = sum(sequence) return total_sum - actual_sum"},{"question":"# Problem Statement: Simulating Simple Database Query Execution Context: You are tasked with implementing a simple in-memory database query execution engine. The database is represented by a list of dictionaries, where each dictionary corresponds to a row, and keys in the dictionary correspond to column names. Queries will be provided in a simplified SQL-like syntax, and you need to execute these queries against the in-memory database. Task: Implement a function `execute_query` that simulates query execution on the in-memory database. Requirements: 1. **Function Signature:** ```python def execute_query(database: list[dict[str, any]], query: str) -> list[dict[str, any]]: Executes the given query on the in-memory database and returns the result as a list of dictionaries. ``` 2. The query string will be in the form: - SELECT column1, column2, ... FROM table WHERE columnX OPERATOR value - Operators can be: \'=\', \'!=\', \'<\', \'<=\', \'>\', \'>=\' - Note: Aim to support a single table (the provided list of dictionaries) and WHERE clause with basic operators. 3. Consider performance and edge cases like empty lists or non-matching queries. Input: * **database** (list[dict[str, any]]): The in-memory database where each dictionary corresponds to a row. * **query** (str): A simplified SQL-like query to execute on the database. Output: * Returns a list of dictionaries representing the selected rows after applying the query. Constraints: * The database list will have at most (10^4) rows. * Each row dictionary will have at most 10 columns. * The WHERE clause will only involve a single comparison. * Column names in the query will match those in the database. Example: ```python database = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35} ] query = \\"SELECT id, name FROM table WHERE age > 30\\" >>> execute_query(database, query) [{\'id\': 3, \'name\': \'Charlie\'}] query = \\"SELECT age FROM table WHERE name = \'Alice\'\\" >>> execute_query(database, query) [{\'age\': 30}] ``` Notes: * The examples demonstrate the usage of the `execute_query` function to perform database queries. * Consider edge cases like no matching rows or an empty database. * Given the constraints, you can simplify assumptions about data types in WHERE clause comparisons (e.g., all are either strings or numerical).","solution":"def execute_query(database: list[dict[str, any]], query: str) -> list[dict[str, any]]: def parse_query(query: str): # Remove potential extra white spaces query = query.strip() # Extract SELECT part select_part = query.split(\'FROM\')[0].strip()[6:].strip() selected_columns = [col.strip() for col in select_part.split(\',\')] # Extract WHERE part if exists where_part = \\"\\" if \'WHERE\' in query: where_part = query.split(\'WHERE\')[1].strip() return selected_columns, where_part def evaluate_condition(row: dict, condition: str) -> bool: import re # Define operators and corresponding lambda functions operators = { \'=\': lambda a, b: a == b, \'!=\': lambda a, b: a != b, \'<\': lambda a, b: a < b, \'<=\': lambda a, b: a <= b, \'>\': lambda a, b: a > b, \'>=\': lambda a, b: a >= b } # Match the condition (e.g., `age > 30`) pattern = re.compile(r\\"(w+)s*(=|!=|<|<=|>|>=)s*(.+)\\") match = pattern.match(condition) if match: column, operator, value = match.groups() column = column.strip() operator = operator.strip() value = value.strip().strip(\\"\'\\") # Remove quotes from value if exists # Convert value to the appropriate type (int or float or string) try: if value.isdigit(): value = int(value) else: value = float(value) except ValueError: pass # leave value as string # Evaluate the condition return operators[operator](row[column], value) return False selected_columns, where_condition = parse_query(query) result = [] for row in database: if where_condition == \\"\\" or evaluate_condition(row, where_condition): result.append({col: row[col] for col in selected_columns}) return result"},{"question":"# Shortest Path in a City Grid Problem Statement You have been hired as a software developer for a new city navigation app. The city is represented as a grid of streets, with some streets blocked due to construction. You need to implement a function that finds the shortest path from a starting point to a destination point within the city grid. Task Implement the function `shortest_path_in_city(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int` that calculates the minimum number of moves required to reach the destination from the starting point using Dijkstra\'s algorithm. Input - `grid`: A 2D list of integers where `0` represents a walkable street and `1` represents a blocked street. - `start`: A tuple of two integers representing the starting coordinates (row, col) in the grid. - `end`: A tuple of two integers representing the destination coordinates (row, col) in the grid. Output - Returns an integer representing the minimum number of moves required to reach the destination from the starting point. If it is impossible to reach the destination, return `-1`. Constraints - 1 ≤ number of rows in the grid ≤ 500 - 1 ≤ number of columns in the grid ≤ 500 - The starting and ending points are always within grid bounds. - The grid contains at least one walkable path. Example ```python grid = [ [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 1, 0] ] start = (0, 0) end = (2, 3) print(shortest_path_in_city(grid, start, end)) # Output: 5 grid = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) print(shortest_path_in_city(grid, start, end)) # Output: -1 ```","solution":"from typing import List, Tuple import heapq def shortest_path_in_city(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path in a city grid using Dijkstra\'s algorithm. :param grid: 2D list of integers where 0 represents walkable street and 1 represents blocked street. :param start: A tuple of starting coordinates (row, col) in the grid. :param end: A tuple of ending coordinates (row, col) in the grid. :return: Integer representing the minimum number of moves required to reach the destination from the starting point. Returns -1 if it is impossible to reach the destination. rows = len(grid) cols = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() pq = [(0, start[0], start[1])] # (distance, row, col) while pq: dist, r, c = heapq.heappop(pq) if (r, c) == end: return dist if (r, c) in visited: continue visited.add((r, c)) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: heapq.heappush(pq, (dist + 1, nr, nc)) return -1"},{"question":"# Question: Implement a Recursive Solution for the Longest Common Subsequence (LCS) Given the problem of finding the longest common subsequence (LCS) between two strings, implement a recursive function `longest_common_subsequence` that computes the length of the LCS. # Function Signature: ```python def longest_common_subsequence(str1: str, str2: str) -> int: pass ``` # Parameters: - `str1 (str)`: The first string for which the LCS needs to be found. - `str2 (str)`: The second string for which the LCS needs to be found. # Returns: - `int`: Returns the length of the longest common subsequence shared by the two strings. # Constraints: - Both `str1` and `str2` have lengths `1 <= len(str1), len(str2) <= 1000`. - The function should handle upper and lower case letters as distinct characters. # Example Usage: ```python assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3, \\"The LCS is \'ace\'\\" assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3, \\"The LCS is \'abc\'\\" assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0, \\"There is no common subsequence\\" ``` # Additional Notes: - You may use memoization to optimize the recursive solution. - Consider edge cases where one or both strings may be empty. - The function should handle efficient computation for inputs close to the upper constraint limits. Good luck, and ensure your solution is thoroughly tested!","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: def lcs_helper(i, j): if i == len(str1) or j == len(str2): return 0 if (i, j) in memo: return memo[(i, j)] if str1[i] == str2[j]: memo[(i, j)] = 1 + lcs_helper(i + 1, j + 1) else: memo[(i, j)] = max(lcs_helper(i + 1, j), lcs_helper(i, j + 1)) return memo[(i, j)] memo = {} return lcs_helper(0, 0)"},{"question":"# Coding Assessment Question Context You are developing a system to monitor the health of critical servers in a data center. One crucial aspect is to detect any sudden spikes in CPU usage that could indicate an issue. To achieve this, you must implement a function that identifies the point of maximum increase in CPU usage over a given period. Problem Implement a function that takes in a list of CPU usage percentages recorded at regular intervals and returns the start and end indices of the segment where the maximum increase in CPU usage occurs. Specifications * **Function Signature**: `def max_cpu_spike(cpu_usages: list[int]) -> tuple[int, int]:` * **Input**: A list of integers `cpu_usages` where each integer represents the percentage of CPU usage at a given time point. * **Output**: A tuple containing two integers, representing the start and end indices of the segment with the maximum increase in CPU usage. * **Constraints**: * The input list `cpu_usages` can have up to (10^5) integers. * The integers in the list range from 0 to 100. * **Performance Requirements**: * Aim for an average and worst-case time complexity of (O(n)). Example ```python cpu_usages = [10, 20, 10, 30, 50, 60, 20] print(max_cpu_spike(cpu_usages)) # Output: (2, 5) - from 10% to 60% cpu_usages = [70, 60, 50, 80, 90, 100, 90, 95] print(max_cpu_spike(cpu_usages)) # Output: (2, 5) - from 50% to 100% cpu_usages = [5, 4, 3, 2, 1] print(max_cpu_spike(cpu_usages)) # Output: (0, 0) - No increase detected ``` Notes * You need to identify contiguous segments where the percentage increase from the starting index to the end index is maximized. * Consider edge cases such as all elements being the same or a strictly decreasing sequence. * Ensure that the solution considers both the increase in values and the lengths of segments. * In case of multiple segments having the same increase, return the segment that appears first.","solution":"def max_cpu_spike(cpu_usages: list[int]) -> tuple[int, int]: Identifies the start and end indices of the segment where the maximum increase in CPU usage occurs. If no increase is found, returns (0, 0). max_increase = 0 start = end = 0 current_start = 0 for i in range(1, len(cpu_usages)): if cpu_usages[i] >= cpu_usages[i-1]: increase = cpu_usages[i] - cpu_usages[current_start] if increase > max_increase: max_increase = increase start = current_start end = i else: current_start = i return (start, end)"},{"question":"# Coding Assessment Question: Implementing a Queue using Two Stacks Context In this task, your objective is to implement a queue using two stacks. A queue follows the First-In-First-Out (FIFO) principle, whereas a stack follows the Last-In-First-Out (LIFO) principle. By using two stacks, simulate the behavior of a queue. Input & Output *Input*: You will have two functions: - `enqueue(x)`: Adds element `x` to the end of the queue. - `dequeue()`: Removes the element from the front of the queue and returns it. If the queue is empty, it should return `None`. *Output*: The output of `enqueue` should not be anything, while `dequeue` should return the element being removed or `None` if the queue is empty. Constraints 1. The operations should handle at least `10^4` operations efficiently, maintaining an average time complexity of O(1) per operation. 2. The `dequeue` operation should return `None` for an empty queue, ensuring robustness. Function Signature ```python class QueueUsingStacks: def __init__(self): Initialize your data structure here. def enqueue(self, x: int) -> None: Enqueues element x to the end of the queue. def dequeue(self) -> int | None: Dequeues the element from the front of the queue and returns it. ``` Scenario Consider the following scenario to further illustrate: ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Expected output: 1 print(queue.dequeue()) # Expected output: 2 print(queue.dequeue()) # Expected output: 3 print(queue.dequeue()) # Expected output: None ``` In the example above, elements are enqueued in the order `1, 2, 3`. Each subsequent `dequeue` operation retrieves the earliest enqueued element, displaying the queue\'s FIFO behavior. The final `dequeue` on an empty queue returns `None`. Complete the `QueueUsingStacks` class to perform these tasks efficiently.","solution":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.in_stack = [] self.out_stack = [] def enqueue(self, x: int) -> None: Enqueues element x to the end of the queue. self.in_stack.append(x) def dequeue(self) -> int | None: Dequeues the element from the front of the queue and returns it. if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) return self.out_stack.pop() if self.out_stack else None"},{"question":"# Task Implement a function `nth_ugly_number(n: int) -> int` to find the `n`-th ugly number. Ugly numbers are those numbers whose only prime factors are 2, 3, or 5. Note that `1` is typically treated as an ugly number, and the sequence of ugly numbers starts with 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, and so on. # Function Signature ```python def nth_ugly_number(n: int) -> int: pass ``` # Input - An integer `n` (1 ≤ n ≤ 10,000). # Output - An integer representing the `n`-th ugly number. # Example ```python assert nth_ugly_number(10) == 12 assert nth_ugly_number(1) == 1 assert nth_ugly_number(15) == 24 assert nth_ugly_number(100) == 1536 ``` # Constraints - Optimize for time efficiency to handle up to `n` equal to 10,000. # Performance Requirements - The function should efficiently generate the sequence of ugly numbers up to the required position, leveraging lazy evaluation techniques, dynamic programming, and possibly a priority queue to ensure optimal performance.","solution":"def nth_ugly_number(n: int) -> int: ugly_numbers = [0] * n ugly_numbers[0] = 1 index2 = index3 = index5 = 0 factor2, factor3, factor5 = 2, 3, 5 for i in range(1, n): next_ugly = min(factor2, factor3, factor5) ugly_numbers[i] = next_ugly if next_ugly == factor2: index2 += 1 factor2 = ugly_numbers[index2] * 2 if next_ugly == factor3: index3 += 1 factor3 = ugly_numbers[index3] * 3 if next_ugly == factor5: index5 += 1 factor5 = ugly_numbers[index5] * 5 return ugly_numbers[-1]"},{"question":"# Decision Tree Classifier Implementation and Application As a data scientist, you are tasked with building and evaluating a classifier based on the decision tree algorithm to classify flower species based on given features. Your task involves the following steps: 1. **Implement Decision Tree Classifier**: Write a function `train_and_classify(X, y, test_data)` that: * Takes as input: * `X`, a list of training input samples (each sample itself a list of feature values). * `y`, a list of training labels (categorical string values representing species). * `test_data`, a list of input samples to be used for testing the trained model. * Returns: * A list of predicted labels (species) for the input `test_data`. 2. **Use appropriate Decision Tree settings**: The Decision Tree should use the following settings: * Criterion: \'entropy\' * Max depth: 3 * Random state: 42 (to ensure reproducibility) 3. **Performance Requirements**: Your model should be able to handle reasonably small datasets efficiently. Ensure that training and prediction with the given settings perform optimally. **Input and Output Format:** Input: ```python X = [[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], [7.0, 3.2, 4.7, 1.4], [6.4, 3.2, 4.5, 1.5]] y = [\\"setosa\\", \\"setosa\\", \\"versicolor\\", \\"versicolor\\"] test_data = [[5.0, 3.4, 1.5, 0.2], [6.7, 3.1, 4.4, 1.4]] ``` Output: ```python [\\"setosa\\", \\"versicolor\\"] ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python from sklearn.tree import DecisionTreeClassifier def train_and_classify(X, y, test_data): Train a Decision Tree classifier with given data and return predictions on test data. Args: X (list of list of float): Training input samples. y (list of str): Training labels. test_data (list of list of float): Test input samples. Returns: list of str: Predicted labels for the test data. # Your implementation here return predictions # Example usage (you can use this for testing your function): X = [[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], [7.0, 3.2, 4.7, 1.4], [6.4, 3.2, 4.5, 1.5]] y = [\\"setosa\\", \\"setosa\\", \\"versicolor\\", \\"versicolor\\"] test_data = [[5.0, 3.4, 1.5, 0.2], [6.7, 3.1, 4.4, 1.4]] predictions = train_and_classify(X, y, test_data) print(predictions) # Expected output: [\\"setosa\\", \\"versicolor\\"] ```","solution":"from sklearn.tree import DecisionTreeClassifier def train_and_classify(X, y, test_data): Train a Decision Tree classifier with given data and return predictions on test data. Args: X (list of list of float): Training input samples. y (list of str): Training labels. test_data (list of list of float): Test input samples. Returns: list of str: Predicted labels for the test data. # Create the Decision Tree classifier with specified parameters clf = DecisionTreeClassifier(criterion=\'entropy\', max_depth=3, random_state=42) # Train the classifier with the training data and labels clf.fit(X, y) # Use the classifier to predict the labels for the test_data predictions = clf.predict(test_data) return predictions.tolist() # Example usage X = [[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], [7.0, 3.2, 4.7, 1.4], [6.4, 3.2, 4.5, 1.5]] y = [\\"setosa\\", \\"setosa\\", \\"versicolor\\", \\"versicolor\\"] test_data = [[5.0, 3.4, 1.5, 0.2], [6.7, 3.1, 4.4, 1.4]] predictions = train_and_classify(X, y, test_data) print(predictions) # Expected output: [\\"setosa\\", \\"versicolor\\"]"},{"question":"# Coding Assessment Question Implementing K-Nearest Neighbors with Weighted Voting Your task is to extend an existing K-Nearest Neighbors (KNN) algorithm to include weighted voting based on the distance of neighbors. This enhancement will give closer neighbors a higher vote in the classification decision process. Task 1. Implement a method `weighted_vote` that uses the inverse distance weighting to determine the class label. 2. Modify the `predict` function to use `weighted_vote` instead of simple majority voting. Additional Guidelines - Voting Strategy: - Use inverse distance weighting: Each neighbor\'s vote weight is the inverse of its distance to the query point. Function Signatures and Expected Behavioral Outline ```python class EnhancedKNN(KNN): def weighted_vote(self, neighbors): # Implement weighted voting method pass def predict(self, x): # Modify to use weighted voting for prediction pass ``` Input Examples and Output Expectations ```python # Sample input datasets x_train = np.array([[1, 2], [2, 3], [3, 4], [6, 7], [8, 9]]) y_train = np.array([0, 0, 1, 1, 1]) x_test = np.array([[2, 2], [3, 3], [4, 4]]) # Initialize and train the enhanced KNN knn = EnhancedKNN(k=3) knn.train(x_train, y_train) # Prediction using the enhanced KNN with weighted voting predictions = knn.predict(x_test) print(predictions) ``` - **Constraints**: - The number of neighbors `k` should be >= 1 and <= len(x_train). - Inputs must be 2-dimensional numpy arrays for x and 1-dimensional for y. - Ensure the same class labels as provided in the training data are used. - **Performance Requirements**: - Evaluate the model\'s classification accuracy on test data. - Ensure that the weighted voting properly reflects the influence of closer neighbors. Before and after modifications, use a simple classification accuracy metric to assess the improvement in prediction consistency.","solution":"import numpy as np from collections import Counter class EnhancedKNN: def __init__(self, k=3): self.k = k def train(self, x_train, y_train): self.x_train = x_train self.y_train = y_train def euclidean_distance(self, x1, x2): return np.sqrt(np.sum((x1 - x2) ** 2)) def weighted_vote(self, neighbors): weight_counter = {} for dist, label in neighbors: weight = 1 / (dist + 1e-5) # Added a small term to prevent division by zero if label in weight_counter: weight_counter[label] += weight else: weight_counter[label] = weight return max(weight_counter, key=weight_counter.get) def predict(self, x): predictions = [] for x_point in x: distances = [(self.euclidean_distance(x_point, x_train_point), y_train_label) for x_train_point, y_train_label in zip(self.x_train, self.y_train)] sorted_distances = sorted(distances, key=lambda d: d[0]) k_nearest_neighbors = sorted_distances[:self.k] prediction = self.weighted_vote(k_nearest_neighbors) predictions.append(prediction) return np.array(predictions)"},{"question":"# Rectangular Path Counting Problem Statement Consider an MxN grid. A robot starts at the top-left corner (1, 1) of the grid and aims to reach the bottom-right corner (M, N). The robot can move either down or right at any point in time. Your task is to determine how many distinct paths the robot can take to reach its destination. Write a function that calculates the number of distinct paths the robot can take to get from the top-left corner to the bottom-right corner of an MxN grid. Function Signature ```python def count_paths(m: int, n: int) -> int: pass ``` Input - `m` (int): the number of rows in the grid (1 ≤ m ≤ 100). - `n` (int): the number of columns in the grid (1 ≤ n ≤ 100). Output - Returns an integer representing the number of distinct paths from the top-left corner to the bottom-right corner. Example ```python assert count_paths(3, 7) == 28 assert count_paths(3, 2) == 3 ``` Constraints - The robot can only move right or down at any point in the grid. Performance Requirements Your solution should efficiently handle grids up to 100x100. # Context This problem involves calculating the number of distinct paths on a grid using combinatorial techniques. This problem challenges you to implement a solution that effectively navigates potential grid sizes within provided constraints. Edge Cases - Smallest grid possible (1x1), which should return a single path since it is already at the destination. - Larger grid sizes should not cause performance issues or excessive computation time.","solution":"def count_paths(m: int, n: int) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner of an MxN grid. # Edge case for smallest grid if m == 1 or n == 1: return 1 # Initializing a 2D list to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # There\'s exactly one way to reach any cell in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Filling the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# ​[Question 2]: Image Class Implementation and Manipulation Given the `Image` class which represents a grayscale image using a 2D matrix of pixel values, extend this class with additional functionalities to improve manipulation techniques. # Problem Statement 1. **Implementation**: - Implement a method to rotate the image by 90 degrees clockwise. - Implement a method to apply a Gaussian blur filter to the image. - Optimize a method to calculate the histogram of pixel intensities. 2. **Function Signature**: ```python class Image: def __init__(self, matrix: List[List[int]]): Initializes the image with a given matrix of pixel values. self.matrix = matrix def rotate_90_clockwise(self) -> \'Image\': Returns a new Image that is rotated 90 degrees clockwise. pass def gaussian_blur(self, kernel_size: int, sigma: float) -> \'Image\': Returns a new Image that has been blurred using a Gaussian filter. pass def calculate_histogram(self) -> List[int]: Returns the histogram of pixel intensities in the image. pass ``` # Input and Output - `rotate_90_clockwise`: - **Input**: None. - **Output**: A new `Image` object representing the rotated image. - `gaussian_blur`: - **Input**: An integer `kernel_size` and a float `sigma`. - **Output**: A new `Image` object representing the blurred image. - `calculate_histogram`: - **Input**: None. - **Output**: A list of 256 integers representing the count of each pixel intensity (0-255). # Constraints - The matrix dimensions can be large, up to 1000x1000, hence efficiency is crucial. - Pixel values are integers ranging from 0 to 255. - The `gaussian_blur` method should handle edge cases appropriately by considering padding. # Example ```python # Example Image matrix = [ [10, 10, 10, 10], [20, 20, 20, 20], [30, 30, 30, 30], [40, 40, 40, 40] ] image = Image(matrix) # Rotate 90 degrees clockwise rotated_image = image.rotate_90_clockwise() print(rotated_image.matrix) # Expected: [[40, 30, 20, 10], [40, 30, 20, 10], [40, 30, 20, 10], [40, 30, 20, 10]] # Gaussian Blur blurred_image = image.gaussian_blur(kernel_size=3, sigma=1.0) # Expected output will be a blurred version of the original matrix # Calculate Histogram histogram = image.calculate_histogram() print(histogram[10]) # Expected: 4 (since there are four pixel values of 10) print(histogram[20]) # Expected: 4 (since there are four pixel values of 20) print(histogram[30]) # Expected: 4 (since there are four pixel values of 30) print(histogram[40]) # Expected: 4 (since there are four pixel values of 40) ``` # Note Ensure your solution is efficient and applies proper techniques for image manipulation and histogram calculation.","solution":"import itertools import math class Image: def __init__(self, matrix): Initializes the image with a given matrix of pixel values. self.matrix = matrix def rotate_90_clockwise(self): Returns a new Image that is rotated 90 degrees clockwise. return Image([list(reversed(row)) for row in zip(*self.matrix)]) def gaussian_blur(self, kernel_size, sigma): Returns a new Image that has been blurred using a Gaussian filter. def gaussian_kernel(size, sigma): Generate a Gaussian kernel. kernel = [[0.0] * size for _ in range(size)] normalization_factor = 1 / (2 * math.pi * sigma ** 2) factor = -1 / (2 * sigma ** 2) kernel_sum = 0.0 for y in range(size): for x in range(size): y_offset = y - size // 2 x_offset = x - size // 2 kernel[y][x] = normalization_factor * math.exp(factor * (x_offset ** 2 + y_offset ** 2)) kernel_sum += kernel[y][x] for y in range(size): for x in range(size): kernel[y][x] /= kernel_sum return kernel def apply_kernel(matrix, kernel): Apply the convolution with the kernel on the matrix. height = len(matrix) width = len(matrix[0]) kernel_size = len(kernel) pad = kernel_size // 2 padded_matrix = [[0] * (width + 2 * pad) for _ in range(height + 2 * pad)] for i in range(height): for j in range(width): padded_matrix[i + pad][j + pad] = matrix[i][j] new_matrix = [[0] * width for _ in range(height)] for i in range(height): for j in range(width): acc = 0.0 for ki in range(kernel_size): for kj in range(kernel_size): acc += kernel[ki][kj] * padded_matrix[i + ki][j + kj] new_matrix[i][j] = int(acc) return new_matrix kernel = gaussian_kernel(kernel_size, sigma) new_matrix = apply_kernel(self.matrix, kernel) return Image(new_matrix) def calculate_histogram(self): Returns the histogram of pixel intensities in the image. histogram = [0] * 256 for pixel in itertools.chain.from_iterable(self.matrix): histogram[pixel] += 1 return histogram"},{"question":"Coding Assessment Question # Common Characters Finder Scenario: You are given a list of strings, and you need to find all characters that show up in all strings within the list (including duplicates). For example, given the input list `[\\"bella\\", \\"label\\", \\"roller\\"]`, the common characters across all strings are `[\\"e\\", \\"l\\", \\"l\\"]`. Task: Write a function `common_chars(words: list[str]) -> list[str]` that takes a list of strings and returns a list of characters that appear in all strings, including duplicates. Function Signature: ```python def common_chars(words: list[str]) -> list[str]: pass ``` Input: * `words`: A list of strings, where each string consists of lowercase English letters only. Output: * Returns a list of characters that appear in all strings, including duplicates. The order in the output list does not matter. Constraints: * The length of each string in `words` will be at most 100. * The total number of strings in `words` will be at most 1000. Example Usage: * Example 1: ```python common_chars([\\"bella\\", \\"label\\", \\"roller\\"]) # Output: [\\"e\\", \\"l\\", \\"l\\"] ``` * Example 2: ```python common_chars([\\"cool\\", \\"lock\\", \\"cook\\"]) # Output: [\\"c\\", \\"o\\"] ``` * Example 3: ```python common_chars([\\"apple\\", \\"banana\\", \\"cherry\\"]) # Output: [] ``` # Instructions: 1. Implement the function `common_chars` as described. 2. Ensure your solution handles edge cases such as strings with no common characters or multiple identical characters. 3. Optimize for both space and time complexity to handle the maximum input size efficiently. 4. Thoroughly test your implementation against various scenarios to ensure correctness.","solution":"def common_chars(words: list[str]) -> list[str]: Returns a list of characters that appear in all strings within the list, including duplicates. if not words: return [] # Start with the character count of the first word common_count = {char: words[0].count(char) for char in set(words[0])} # Iterate through the rest of the words for word in words[1:]: current_count = {char: word.count(char) for char in set(word)} # Update the common count dictionary for char in list(common_count.keys()): if char in current_count: common_count[char] = min(common_count[char], current_count[char]) else: del common_count[char] # Convert the common count dictionary to the result list result = [] for char, count in common_count.items(): result.extend([char] * count) return result"},{"question":"# Matrix Transposition and Symmetry Check Context: In many computational problems, matrices are utilized extensively, and it is often necessary to transpose them and check for certain properties, such as symmetry, which is useful in fields like linear algebra, data science, and computer graphics. Task: Write a function `is_symmetric(matrix: list[list[int]]) -> bool` which takes a square matrix (a list of lists, where each list is of equal length) as input, transposes it, and checks if the transposed matrix is equal to the original matrix. The function should return `True` if the matrix is symmetric and `False` otherwise. Input: * A list of lists of integers `matrix` representing the square matrix. Output: * A boolean value `True` if the matrix is symmetric, `False` otherwise. Example: ```python def is_symmetric(matrix: list[list[int]]) -> bool: Example usage: >>> is_symmetric([[1, 2, 3], [2, 4, 5], [3, 5, 6]]) True >>> is_symmetric([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) False ``` Constraints: * The input matrix will always be a square matrix with positive dimensions. * Each element within the matrix will be a non-negative integer. **Edge Cases to consider**: * A 1x1 matrix, which is trivially symmetric. * Large matrices where multiple checks must be efficiently handled. Requirements: * Make sure your function correctly handles all valid and edge case inputs. * Ensure the output is accurate and efficiently computed, especially for larger matrices.","solution":"def is_symmetric(matrix: list[list[int]]) -> bool: Checks if the given square matrix is symmetric. :param matrix: List of lists representing the square matrix :return: True if the matrix is symmetric, False otherwise n = len(matrix) # Check symmetry for i in range(n): for j in range(i, n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"# Problem Statement You are developing a traffic management system for a city and need to write a function that finds the shortest path from a given source intersection to all other intersections. The system includes intersections and roads connecting them, where each road has a specific travel time. Your task is to implement a function that uses Dijkstra\'s algorithm to calculate the shortest travel times from the source intersection to every other intersection in the city. # Function Signature ```python def shortest_path_from_source(n: int, roads: List[Tuple[int, int, int]], source: int) -> List[float]: :param n: Number of intersections. :param roads: List of tuples where each tuple contains (u, v, w), representing a road from intersection u to intersection v with travel time w. :param source: The source intersection from where the shortest times to other intersections are calculated. :return: A list where the element at index i represents the shortest travel time from the source intersection to intersection i. If an intersection is unreachable from the source, the travel time should be float(\'inf\'). Example: >>> n = 5 >>> roads = [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3)] >>> source = 0 >>> result = shortest_path_from_source(n, roads, source) >>> result[4] # shortest path from source 0 to intersection 4 7.0 >>> result[3] # no direct path from source 0 to intersection 3 9.0 ``` # Input * `n`: Integer (1 ≤ n ≤ 10^4). Number of intersections. * `roads`: A list of tuples, where each tuple `(u, v, w)` represents a directed road from intersection `u` to intersection `v` with travel time `w`. * `source`: Integer (0 ≤ source < n). The source intersection from where the shortest path to other intersections is calculated. # Output * A list where the element at index `i` represents the shortest travel time from the source intersection to intersection `i`. If an intersection is unreachable from the source, return `float(\'inf\')` for index `i`. # Constraints * The graph only has non-negative weights to ensure the feasibility of Dijkstra\'s algorithm. * The number of roads can be large, so efficiency should be considered. # Example Given `n = 5`, `roads = [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3)]`, and `source = 0`, the function should return: ``` [ 0.0, 2.0, 3.0, 9.0, 6.0 ] ``` # Detailed Description 1. Initialize a distance list `dist` of size `n` with `float(\'inf\')` values. Set `dist[source]` to `0`. 2. Use a min-heap (priority queue) to explore the roads from the source intersection. 3. Implement Dijkstra\'s algorithm: - Extract the intersection with the minimum travel time from the heap. - Update the travel times to its neighboring intersections if a shorter path is found. 4. Return the final `dist` list where each element represents the shortest travel time from the source intersection to the respective intersection.","solution":"import heapq from typing import List, Tuple def shortest_path_from_source(n: int, roads: List[Tuple[int, int, int]], source: int) -> List[float]: Finds the shortest travel times from the source intersection to every other intersection using Dijkstra\'s algorithm. # Initialize the graph as an adjacency list graph = [[] for _ in range(n)] for u, v, w in roads: graph[u].append((v, w)) # Distance array with all values set to infinity dist = [float(\'inf\')] * n dist[source] = 0 # Priority queue to select the node with the smallest distance min_heap = [(0, source)] while min_heap: current_dist, current_node = heapq.heappop(min_heap) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return dist"},{"question":"Coding Challenge: Paint Fence Algorithm # Objective: Develop a function that calculates the number of distinct ways to paint a fence with `n` posts using `k` different colors such that no more than two adjacent fence posts have the same color. # Problem Description: * You have a fence with `n` posts, labeled from 1 to n. * You have `k` different colors to paint the fence. You need to determine the number of ways you can paint the fence, ensuring that no more than two adjacent fence posts are painted the same color. # Function Specification: Implement the following function: ```python def num_ways_to_paint_fence(n: int, k: int) -> int: Calculate the number of ways to paint a fence with n posts using k colors, ensuring no more than two adjacent posts have the same color. Parameters: n (int): The number of fence posts. k (int): The number of colors available. Returns: int: The number of distinct ways to paint the fence. pass ``` # Input: * `n`: An integer representing the number of fence posts (1 ≤ n ≤ 50). * `k`: An integer representing the number of colors (1 ≤ k ≤ 50). # Output: * Returns an integer representing the number of distinct ways to paint the fence. # Example: ```python print(num_ways_to_paint_fence(3, 2)) # Expected output: 6 print(num_ways_to_paint_fence(4, 3)) # Expected output: 66 ``` # Constraints: * You may assume the output can be represented within the range of an integer in Python. # Additional Notes: * This is a classic dynamic programming problem. * Use a bottom-up approach to solve this efficiently. * Ensure your solution handles edge cases such as when `n` or `k` is 1. # Guideline: * Use dynamic programming to build a solution from the base case up. * You will need two main variables to track: - The number of ways to paint a fence of length `i` where the last two colors are different. - The number of ways to paint a fence of length `i` where the last two colors are the same. * Formulate the state transition based on these variables and iterate up to `n`. Good luck!","solution":"def num_ways_to_paint_fence(n: int, k: int) -> int: if n == 0: return 0 if n == 1: return k if n == 2: return k * k same = k diff = k * (k - 1) for i in range(3, n + 1): new_same = diff new_diff = (same + diff) * (k - 1) same = new_same diff = new_diff return same + diff"},{"question":"# Problem Statement You are given the implementation of a Linked List data structure where the `Node` has attributes `value` and `next`. For this task, you need to write a function `find_middle_node` that takes the head of a linked list and returns the value of the middle node. If there are two middle nodes, return the value of the second middle node. # Function Signature ```python def find_middle_node(head: Node) -> int: pass ``` # Inputs - `head`: A `Node` object representing the head of the linked list. # Output - An integer representing the value of the middle node in the linked list. # Constraints - The linked list will have at least one node. - The linked list contains integer values. # Example Consider the following linked list: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` ```python assert find_middle_node(head) == 3 ``` And for the linked list: ``` 1 -> 2 -> 3 -> 4 ``` ```python assert find_middle_node(head) == 3 ``` # Requirements - Utilize the provided `Node` class for the implementation. - Aim for an efficient solution that minimizes space complexity. - Ensure the function handles edge cases effectively, such as when the linked list has only one node.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def find_middle_node(head: Node) -> int: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.value"},{"question":"# Scenario: You are building an inventory system for a small online bookstore. Your task is to implement a function that determines the availability status of books based on a list of transactions. Each transaction either adds new stock or represents a sale of a particular book. You need to interpret the transactions and provide an updated inventory list showing which books are in stock and their quantities. # Requirements: 1. Implement a function `update_inventory` that takes a list of transactions as input and returns the updated inventory. 2. Each transaction is represented as a tuple of the form `(book_id: str, operation: str, quantity: int)`. 3. `operation` is either `\\"add\\"` (to add new stock) or `\\"sell\\"` (to sell stock). 4. Books that have a quantity of zero or less after processing the transactions should not appear in the final inventory. # Function Signature: ```python def update_inventory(transactions: list[tuple[str, str, int]]) -> dict: ``` # Input: - `transactions`: A list of tuples, where each tuple contains: - `book_id` (str): A unique identifier for the book. - `operation` (str): An operation (\\"add\\" or \\"sell\\"). - `quantity` (int): The quantity to add or sell. # Output: - A dictionary representing the updated inventory where: - The keys are book IDs. - The values are the quantities of each book in stock. # Constraints: - Book IDs are non-empty strings consisting of alphanumeric characters. - The quantity is a non-negative integer. - You may assume that the `sell` operation will not result in negative stock for a given book (i.e., there will always be enough stock to fulfill a `sell` operation). # Example: ```python assert update_inventory([(\'book1\', \'add\', 10), (\'book1\', \'sell\', 5), (\'book2\', \'add\', 3)]) == {\'book1\': 5, \'book2\': 3} assert update_inventory([(\'book1\', \'add\', 7), (\'book3\', \'sell\', 2), (\'book2\', \'add\', 12), (\'book1\', \'sell\', 7)]) == {\'book2\': 12} assert update_inventory([(\'book4\', \'add\', 5), (\'book4\', \'sell\', 5), (\'book5\', \'add\', 10)]) == {\'book5\': 10} assert update_inventory([]) == {} ``` # Hints: - Use a dictionary to keep track of the current stock of each book. - Loop through the transactions and update the dictionary accordingly. - Ensure that your implementation can handle an empty transactions list gracefully.","solution":"def update_inventory(transactions: list[tuple[str, str, int]]) -> dict: Updates and returns the inventory based on the list of transactions. Parameters: transactions (list of tuple[str, str, int]): List of transactions, where each transaction is a tuple with book_id, operation, and quantity. Returns: dict: Updated inventory with book_ids as keys and quantities as values. inventory = {} for book_id, operation, quantity in transactions: if operation == \\"add\\": if book_id in inventory: inventory[book_id] += quantity else: inventory[book_id] = quantity elif operation == \\"sell\\": if book_id in inventory: inventory[book_id] -= quantity if inventory[book_id] <= 0: del inventory[book_id] return inventory"},{"question":"# Maximum Sum of Non-Adjacent Elements You are given a list of integers representing the values of various items. Your task is to determine the maximum sum of non-adjacent elements from the list. Adjacent elements are defined as elements directly next to each other in the list. Input * A list of integers `values` where `values[i]` is the value of the i-th item. Output * An integer representing the maximum sum of non-adjacent elements in the list. Constraints * `1 ≤ len(values) ≤ 10^5` * `-10^4 ≤ values[i] ≤ 10^4` Example ```python # Input values = [3, 2, 5, 10, 7] # Output 15 ``` Explanation Here, the maximum sum of non-adjacent elements is calculated as follows: 1. Choose 3 (index 0), skip 2 (index 1). 2. Choose 5 (index 2), skip 10 (index 3). 3. Choose 7 (index 4). The sum is 3 + 5 + 7 = 15. Implement the function `max_non_adjacent_sum(values: List[int]) -> int`: ```python def max_non_adjacent_sum(values): # Implement here pass ```","solution":"def max_non_adjacent_sum(values): Returns the maximum sum of non-adjacent elements from the list. if not values: return 0 elif len(values) == 1: return max(0, values[0]) include = 0 exclude = 0 for value in values: # Current max excluding the current value new_exclude = max(include, exclude) # Current max including the current value include = exclude + value exclude = new_exclude # The final result would be the max of include and exclude return max(include, exclude)"},{"question":"# Number of Islands: Connected Components in a Binary Matrix Problem Statement You are given a 2D grid of shape `m x n` representing a map of \'1\'s (land) and \'0\'s (water). An island is formed by connecting adjacent lands horizontally or vertically. You can assume all four edges of the grid are surrounded by water. Write a function `num_islands(grid: List[List[str]]) -> int` that returns the number of islands. Input * `grid` (List[List[str]]): A 2D list representing the map, where `grid[i][j]` is either \'1\' (land) or \'0\' (water). Output * Return an integer representing the number of islands in the grid. Constraints * The dimensions of the grid `m` and `n` will not exceed 300. * Each element in the grid is either \'0\' or \'1\'. Examples ```python num_islands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ]) -> 3 # Explanation: There are three islands in this grid: one in the top left, one in the middle, and one in the bottom right. num_islands([ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"] ]) -> 6 # Explanation: Each \'1\' forms a separate island. ``` Additional Information You should use either Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the grid. Mark visited parts of the islands to prevent counting them multiple times. Test your function carefully against edge cases, including grids with no islands or grids with only water.","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # mark the land as visited # Visit all the neighbors (vertically and horizontally) dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': count += 1 dfs(grid, i, j) return count"},{"question":"# Problem Statement Objective Write a Python program that takes a list of integers and returns the list with duplicate elements removed, but maintains the original order of the elements. Motivation This task assesses your understanding of data structures, particularly lists and sets, and your ability to manipulate these structures effectively in Python. It also tests your comprehension of preserving order while removing duplicates. # Requirements 1. **Input**: A list of integers `L`. 2. **Output**: A list of integers where all duplicate values from the original list are removed, but the original order is preserved. # Constraints - The elements in the input list `L` are integers and there can be both positive and negative integers. - The length of the list `L` will be between 1 and 10^5. - The integers in the list will be between -10^6 and 10^6. # Performance - Your solution should efficiently handle the provided constraints, particularly with respect to time complexity. - Aim for a solution with linear time complexity, O(n). # Specification Example If the input list is `[1, 2, 2, 3, 4, 4, 5]`, the output should be `[1, 2, 3, 4, 5]`. If the input list is `[-1, 2, -1, 2, -2]`, the output should be `[-1, 2, -2]`. Notes - Pay special attention to keeping the first occurrence of each element and removing subsequent duplicates. - Utilize Python\'s data structures to maintain order and handle the removal of duplicates efficiently. # Example Code Scaffold Below is the skeleton of a Python function to solve this problem. Complete the function to achieve the expected behavior. ```python def remove_duplicates(L): # Implement your solution here return # Your cleaned list with duplicates removed ``` You can test your function with the following test cases: ```python print(remove_duplicates([1, 2, 2, 3, 4, 4, 5])) # Output: [1, 2, 3, 4, 5] print(remove_duplicates([-1, 2, -1, 2, -2])) # Output: [-1, 2, -2] ```","solution":"def remove_duplicates(L): Removes duplicate elements from the list L while maintaining the original order. :param L: List of integers :return: List of integers with duplicates removed seen = set() result = [] for item in L: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Problem Statement You are given a list of events, where each event is represented as a tuple containing the start time and end time (inclusive). Write a function `merge_events` that merges overlapping events and returns the consolidated list of events. Function Signature ```python def merge_events(events: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` Input - `events` (list[tuple[int, int]]): A list of events, where each event is a tuple `(start_time, end_time)`. The `start_time` and `end_time` are integers such that `0 <= start_time <= end_time <= 10^6`. Output - A list of consolidated events, where each event is represented by a tuple `(start_time, end_time)`. Constraints - The start and end times are inclusive. - The list of events can be empty, in which case an empty list should be returned. - You must merge all overlapping events into the smallest number of continuous events. # Example ```python events = [(1, 3), (2, 4), (5, 7), (6, 8)] print(merge_events(events)) # Output should be: [(1, 4), (5, 8)] events = [(1, 5), (2, 6), (8, 10), (9, 12)] print(merge_events(events)) # Output should be: [(1, 6), (8, 12)] events = [(0, 1), (2, 3), (4, 5)] print(merge_events(events)) # Output should be: [(0, 1), (2, 3), (4, 5)] events = [(1, 4), (4, 5), (5, 6)] print(merge_events(events)) # Output should be: [(1, 6)] ``` # Additional Notes - Ensure that the events are sorted by their start time before attempting to merge them. - The merged events should not overlap with each other. - Your solution should handle edge cases such as events that start or end at the same time. - The function should return the events in sorted order based on their start time.","solution":"def merge_events(events): if not events: return [] # Sort the events by start time (and by end time in case of tie) events.sort(key=lambda x: (x[0], x[1])) merged_events = [] current_start, current_end = events[0] for start, end in events[1:]: if start <= current_end: # If the current event overlaps or touches the previous one, # extend the current end to the maximum end we encounter. current_end = max(current_end, end) else: # If the current event does not overlap, # add the previous interval to the result and start a new interval merged_events.append((current_start, current_end)) current_start, current_end = start, end # Don\'t forget to add the last interval merged_events.append((current_start, current_end)) return merged_events"},{"question":"# Problem Statement You are given a string `s` containing only the characters \'A\', \'B\', and \'C\'. Your task is to implement a function `is_transformation_possible` that checks if it is possible to transform `s` into a target string `t` using the following operations: 1. Insert \'A\', \'B\', or \'C\' at any position. 2. Remove any \'A\', \'B\', or \'C\' from any position. 3. Swap any two adjacent characters. # Input Format - A string `s` containing only characters \'A\', \'B\', and \'C\'. - A string `t` containing only characters \'A\', \'B\', and \'C\'. # Output Format - Return `True` if it is possible to transform `s` into `t` using the allowed operations, and `False` otherwise. # Constraints - `1 <= len(s), len(t) <= 1000` - `s` and `t` only contain the characters \'A\', \'B\', and \'C\'. # Performance Requirements - Time Complexity: O(n) - Space Complexity: O(1) # Function Signature ```python def is_transformation_possible(s: str, t: str) -> bool: pass ``` # Example ```python assert is_transformation_possible(\\"ABC\\", \\"CBA\\") == True assert is_transformation_possible(\\"AABBCC\\", \\"ABABCC\\") == True assert is_transformation_possible(\\"AA\\", \\"BB\\") == False assert is_transformation_possible(\\"ABC\\", \\"AABCC\\") == False assert is_transformation_possible(\\"AB\\", \\"BA\\") == True ``` Implement your function `is_transformation_possible` to ensure it adheres to the constraints and performance requirements. # Explanation In the first example, \\"ABC\\" can be transformed into \\"CBA\\" by swapping: - \\"ABC\\" -> \\"BAC\\" -> \\"BCA\\" -> \\"CBA\\" In the second example, \\"AABBCC\\" can be transformed into \\"ABABCC\\" by swapping: - \\"AABBCC\\" -> \\"ABABCC\\" In the third example, \\"AA\\" cannot be transformed into \\"BB\\" since the character frequencies need to match. In the fourth example, \\"ABC\\" cannot be transformed into \\"AABCC\\" as the lengths differ. In the fifth example, \\"AB\\" can be transformed into \\"BA\\" by swapping: - \\"AB\\" -> \\"BA\\"","solution":"def is_transformation_possible(s: str, t: str) -> bool: from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Problem Statement You are given an undirected graph represented by an adjacency list and a list of nodes that form a path in the graph. Your task is to implement a function `valid_path(graph, path)` that determines if the given path is valid according to these criteria: 1. The path must start at the first node and end at the last node in the provided path list. 2. All consecutive nodes in the path must be directly connected by an edge in the graph. # Function Signature ```python def valid_path(graph: Dict[int, List[int]], path: List[int]) -> bool: ``` # Input 1. `graph`: A dictionary where the keys are integers representing nodes, and the values are lists of integers representing the nodes that are directly connected to the key node. 2. `path`: A list of integers representing the sequence of nodes that form a path. # Output * **Output**: A boolean value `True` if the path is valid, otherwise `False`. # Constraints * The graph will contain up to 1000 nodes (0 ≤ number of nodes ≤ 1000). * Each node identifier is a non-negative integer (0 ≤ node identifier ≤ 10^6). * There might be multiple edges and self-loops. # Example ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } path = [0, 2, 3] assert valid_path(graph, path) == True path = [0, 1, 3] assert valid_path(graph, path) == False # There is no direct edge between 1 and 3 ``` # Requirements * Your function should efficiently check the validity of the given path using the adjacency list. * Ensure to handle edge cases like paths with a single node or disconnected graphs.","solution":"from typing import Dict, List def valid_path(graph: Dict[int, List[int]], path: List[int]) -> bool: Determines if the given path is valid in the provided graph. :param graph: A dictionary representing the adjacency list of the graph. :param path: A list of integers representing the node sequence of the path. :return: True if the path is valid, False otherwise. # If path is empty or contains only one node, it is trivially valid. if len(path) <= 1: return True for i in range(len(path) - 1): current_node = path[i] next_node = path[i + 1] if next_node not in graph.get(current_node, []): return False return True"},{"question":"# Problem Statement Given a list of events with timestamps, write a function to identify overlapping events and return them in a specific format. Each event consists of a start time and an end time, both given as strings in \\"HH:MM\\" format. Overlapping events are events that share any part of their duration with another event. Your goal is to find all such overlapping event pairs and present them in a readable format. # Requirements 1. **Event Detection**: Implement the function `find_overlapping_events` that identifies all pairs of overlapping events. 2. **Time Parsing**: Properly parse the given times and ensure accurate duration calculations. 3. **Output Formatting**: Return the overlapping event pairs in a specified string format. # Constraints - The function should handle up to 1000 events. - Each timestamp is a string in \\"HH:MM\\" format, representing hours and minutes in a 24-hour format (e.g., \\"13:45\\" for 1:45 PM). - The event list is a list of tuples, where each tuple contains two strings (start time, end time). # Function Signature ```python from typing import List, Tuple def find_overlapping_events(events: List[Tuple[str, str]]) -> List[str]: pass if __name__ == \\"__main__\\": events = [(\\"11:00\\", \\"12:00\\"), (\\"11:30\\", \\"13:00\\"), (\\"12:30\\", \\"14:00\\")] overlapping = find_overlapping_events(events) for pair in overlapping: print(pair) ``` # Expected Behavior 1. **Input**: A list of tuples, where each tuple consists of two strings representing start and end times of events. 2. **Output**: A list of strings, each representing a pair of overlapping events in the format `\\"Event 1 [HH:MM-HH:MM] overlaps with Event 2 [HH:MM-HH:MM]\\"`. # Example ```python events = [(\\"11:00\\", \\"12:00\\"), (\\"11:30\\", \\"13:00\\"), (\\"12:30\\", \\"14:00\\")] overlapping = find_overlapping_events(events) for pair in overlapping: print(pair) ``` Example output: ``` \\"Event 1 [11:00-12:00] overlaps with Event 2 [11:30-13:00]\\" \\"Event 2 [11:30-13:00] overlaps with Event 3 [12:30-14:00]\\" ```","solution":"from typing import List, Tuple def parse_time(time_str: str) -> int: Convert time string \\"HH:MM\\" into minutes since midnight. hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes def find_overlapping_events(events: List[Tuple[str, str]]) -> List[str]: overlaps = [] # Create a list of [(start_minutes, end_minutes, index)] event_times = [(parse_time(start), parse_time(end), i) for i, (start, end) in enumerate(events)] n = len(events) for i in range(n): for j in range(i + 1, n): start1, end1, idx1 = event_times[i] start2, end2, idx2 = event_times[j] if max(start1, start2) < min(end1, end2): # overlap condition overlaps.append(f\\"Event {idx1 + 1} [{events[idx1][0]}-{events[idx1][1]}] overlaps with Event {idx2 + 1} [{events[idx2][0]}-{events[idx2][1]}]\\") return overlaps"},{"question":"# Log Analyzer for Web Server Access Logs You are assigned the task of analyzing a web server\'s access log to extract useful statistics. Each log entry follows the common log format, which looks like this: ``` 127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326 ``` Requirements: 1. **Function Definition**: ```python def analyze_log(log_entries: list) -> dict: ``` 2. **Input**: * `log_entries` (list): List of strings, where each string represents one access log entry. 3. **Output**: * Return a dictionary with the following keys: * \'total_requests\': Total number of requests. * \'requests_per_ip\': A dictionary where keys are IP addresses and values are counts of requests from each IP. * \'most_requested_file\': The filename of the most requested resource. * \'error_count\': The number of requests resulting in client (4xx) and server (5xx) errors combined. 4. **Constraints**: * Assume valid log entries are passed; you do not need to handle malformed logs. * Log entries are well-formed and follow the exact format as shown in the example. 5. **Performance Requirements**: * The function should handle up to 100,000 log entries efficiently. * Ensure that your solution performs necessary operations in a time-efficient manner. Example: ```python log_entries = [ \'127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326\', \'127.0.0.1 - frank [10/Oct/2000:13:55:38 -0700] \\"GET /style.css HTTP/1.0\\" 404 321\', \'192.168.1.1 - jane [10/Oct/2000:13:55:41 -0700] \\"POST /submit HTTP/1.1\\" 500 567\', \'192.168.1.1 - jane [10/Oct/2000:13:55:42 -0700] \\"GET /apache_pb.gif HTTP/1.1\\" 200 2326\' ] result = analyze_log(log_entries) # The \'result\' dictionary might look like: # { # \'total_requests\': 4, # \'requests_per_ip\': { # \'127.0.0.1\': 2, # \'192.168.1.1\': 2 # }, # \'most_requested_file\': \'/apache_pb.gif\', # \'error_count\': 2 # } ``` Implementation Tips: * Parse each log entry to extract useful information. * Use dictionaries and other data structures to store and analyze the data efficiently. * Be prepared for edge cases, such as multiple files with the same number of requests.","solution":"def analyze_log(log_entries: list) -> dict: from collections import defaultdict total_requests = len(log_entries) requests_per_ip = defaultdict(int) file_requests = defaultdict(int) error_count = 0 for entry in log_entries: parts = entry.split() ip = parts[0] status_code = int(parts[8]) requested_file = parts[6] requests_per_ip[ip] += 1 file_requests[requested_file] += 1 if 400 <= status_code <= 599: error_count += 1 most_requested_file = max(file_requests, key=file_requests.get) return { \'total_requests\': total_requests, \'requests_per_ip\': dict(requests_per_ip), \'most_requested_file\': most_requested_file, \'error_count\': error_count }"},{"question":"# Problem Statement Write a function that takes a string containing a mathematical expression and evaluates the result. The expression can include integers, the four basic arithmetic operations (addition `+`, subtraction `-`, multiplication `*`, and division `/`), as well as parentheses to indicate operation precedence. All expressions are guaranteed to be valid and division by zero doesn\'t need to be handled. Create a function `evaluate_expression(expression: str) -> float` that computes the value of a given mathematical expression. Function Signature: ```python def evaluate_expression(expression: str) -> float: ``` # Input * A string `expression` containing a valid mathematical expression where: * `1 <= len(expression) <= 200` * The expression contains integers and the following characters: `+`, `-`, `*`, `/`, `(`, `)`. * The integers in the expression are non-negative and will not exceed `10^4`. # Output * Return the computed result of the expression as a floating-point number. # Example ```python print(evaluate_expression(\\"2 + 3 * 4\\")) # Output: 14.0 print(evaluate_expression(\\"(1 + 2) * (3 + 4) / 2\\")) # Output: 10.5 print(evaluate_expression(\\"10 + 2 * 6\\")) # Output: 22.0 print(evaluate_expression(\\"100 * 2 + 12\\")) # Output: 212.0 print(evaluate_expression(\\"100 * (2 + 12)\\")) # Output: 1400.0 print(evaluate_expression(\\"100 * (2 + 12) / 14\\")) # Output: 100.0 ``` # Constraints * The implementation must respect the standard order of operations: parentheses, multiplication and division from left to right, addition and subtraction from left to right. * Handle potential floating-point arithmetic precision issues gracefully. Additional Notes * Use the `eval` function with caution – it\'s recommended to implement a safer evaluation method, such as using an explicit stack-based algorithm or an abstract syntax tree (AST). * Ensure that the function can handle nested parentheses and mixed operators correctly. Testing * Your solution will be evaluated on a variety of test cases, including expressions with multiple levels of nested parentheses and different combinations of operators. # Implementation Guide * Parse the expression using a stack-based approach to respect operator precedence and parentheses. * Alternatively, construct an abstract syntax tree (AST) of the expression and evaluate it recursively. Best of luck, and happy coding!","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. The expression can include integers, +, -, *, / operators, and parentheses. # Helper to perform the basic arithmetic operations. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == \'+\': operands.append(a + b) elif operator == \'-\': operands.append(a - b) elif operator == \'*\': operands.append(a * b) elif operator == \'/\': operands.append(a / b) # Helper to determine the precedence of operators. def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 # Function to convert infix expression to postfix expression. def infix_to_postfix(expression): ops = [] postfix = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = [] while i < len(expression) and expression[i].isdigit(): num.append(expression[i]) i += 1 postfix.append(int(\'\'.join(num))) i -= 1 # Step back after the number ends elif expression[i] == \'(\': ops.append(expression[i]) elif expression[i] == \')\': while ops and ops[-1] != \'(\': postfix.append(ops.pop()) ops.pop() # Pop the \'(\' else: # Operator encountered while (ops and precedence(ops[-1]) >= precedence(expression[i])): postfix.append(ops.pop()) ops.append(expression[i]) i += 1 while ops: postfix.append(ops.pop()) return postfix # Function to evaluate postfix expression. def evaluate_postfix(postfix): operands = [] for token in postfix: if isinstance(token, int): operands.append(token) else: apply_operator(operands, token) return operands[0] # Remove whitespaces for better parsing. expression = expression.replace(\' \', \'\') postfix = infix_to_postfix(expression) return float(evaluate_postfix(postfix))"},{"question":"# Question: Palindrome Permutation Check You are tasked with implementing two functions to determine if a given string is a permutation of a palindrome, and to generate one possible palindrome from the given string if it is a valid permutation of a palindrome. Function 1: `is_palindrome_permutation(s: str) -> bool` Implement a function that checks whether any permutation of the input string can form a palindrome. **Inputs:** * `s (str)`: A string consisting of lowercase letters (a-z) and spaces. **Outputs:** * `bool`: Return `True` if the input string has at least one permutation that is a palindrome; otherwise, return `False`. **Constraints:** * The input string can have spaces which should be ignored in palindrome permutations. Input Examples: - `\\"taco cat\\"` - `\\"racecar\\"` Output Examples: - `True` - `True` Function 2: `generate_palindrome(s: str) -> str` Implement a function that returns one possible palindrome permutation of the input string if it can form a palindrome. Otherwise, return an appropriate message indicating it is not possible. **Inputs:** * `s (str)`: A string consisting of lowercase letters (a-z) and spaces. **Outputs:** * `str`: A palindrome permutation of the input string, or a message like `\\"Cannot form a palindrome\\"` if no such permutation exists. **Constraints:** * The input string can have spaces which should be ignored in palindrome permutations. Input Examples: - `\\"taco cat\\"` - `\\"no lemon, no melon\\"` Output Examples: - `\\"tacocat\\"` - `\\"Cannot form a palindrome\\"` # Requirements 1. Handle edge cases such as empty strings, strings with only spaces, and non-palintranic permutations appropriately. 2. Maintain efficient memory usage and processing time. 3. Ensure accurate and clear error handling for inputs that cannot form a palindrome. Examples Example 1: ```python >>> is_palindrome_permutation(\\"taco cat\\") True >>> is_palindrome_permutation(\\"hello world\\") False ``` Example 2: ```python >>> generate_palindrome(\\"taco cat\\") \'tacocat\' >>> generate_palindrome(\\"hello world\\") \'Cannot form a palindrome\' ``` Write the implementations for both functions ensuring they fulfill the requirements and handle all edge cases appropriately.","solution":"def is_palindrome_permutation(s: str) -> bool: Check if any permutation of the input string can form a palindrome. Ignore spaces and consider only lowercase letters. from collections import Counter # Remove spaces and count characters s = s.replace(\' \', \'\') char_count = Counter(s) # At most one character can have an odd count for it to be a palindrome odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def generate_palindrome(s: str) -> str: Generate a palindrome permutation of the input string if possible. Return \'Cannot form a palindrome\' if no such permutation exists. Ignore spaces and consider only lowercase letters. from collections import Counter # Remove spaces and count characters s = s.replace(\' \', \'\') char_count = Counter(s) # Check if it\'s possible to form a palindrome if not is_palindrome_permutation(s): return \\"Cannot form a palindrome\\" # Build the first half and middle character (if any) of the palindrome first_half = [] middle_char = \'\' for char, count in char_count.items(): if count % 2 != 0: middle_char = char first_half.append(char * (count // 2)) # Join first half and middle character to form the full palindrome first_half = \'\'.join(first_half) return first_half + middle_char + first_half[::-1]"},{"question":"# Problem Statement Given an array of integers, write a function to determine the length of the longest subsequence where the difference between consecutive integers is either 1 or -1. # Requirements 1. **Input**: A list of integers `nums` of size `n` 2. **Output**: An integer representing the length of the longest possible subsequence # Constraints * `1 <= n <= 1000` * `-10^4 <= nums[i] <= 10^4` # Example ```python assert longest_consecutive_subsequence([1, 2, 3, 4, 5]) == 5 assert longest_consecutive_subsequence([1, 3, 2, 4, 5]) == 3 assert longest_consecutive_subsequence([10, 9, 4, 5, 6, 7, 4]) == 4 assert longest_consecutive_subsequence([-2, -1, 0, 1, 2, 1, 0]) == 7 ``` # Performance Considerations Your implementation should be as efficient as possible, ideally with a time complexity of O(n log n) or better. Consider utilizing dynamic programming or other algorithms suited for subsequence problems. # Implementation ```python def longest_consecutive_subsequence(nums): if not nums: return 0 dp = {} longest = 0 for num in nums: if num not in dp: dp[num] = 1 if num - 1 in dp: dp[num] = max(dp[num], dp[num - 1] + 1) if num + 1 in dp: dp[num] = max(dp[num], dp[num + 1] + 1) longest = max(longest, dp[num]) return longest # Example usage: print(longest_consecutive_subsequence([1, 2, 3, 4, 5])) # Output: 5 ```","solution":"def longest_consecutive_subsequence(nums): if not nums: return 0 nums_set = set(nums) longest = 0 for num in nums_set: if (num - 1) not in nums_set: current_num = num current_streak = 1 while (current_num + 1) in nums_set: current_num += 1 current_streak += 1 longest = max(longest, current_streak) return longest"},{"question":"# Question You are given two strings, `s1` and `s2`, consisting of lowercase English letters. Write a Python function `longest_anagram_substring(s1: str, s2: str) -> int`. This function should return the length of the longest common substring of `s1` and `s2` which is an anagram of some other substring in `s1`. # Input - Two strings `s1` and `s2` where (1 ≤ len(s1), len(s2) ≤ 1000). # Output - Return an integer representing the length of the longest common substring that is an anagram of a substring in `s1`. # Example ```python >>> longest_anagram_substring(\\"abcde\\", \\"edcba\\") 5 >>> longest_anagram_substring(\\"abcd\\", \\"dcbaabcd\\") 4 ``` # Explanation 1. In the first example, the entire strings `s1` and `s2` are anagrams of each other and thus the longest common substring is of length 5. 2. In the second example, the substring \\"abcd\\" in `s2` is an anagram of the substring \\"abcd\\" in `s1`, and there are no longer common substrings that are anagrams. # Constraints 1. You may assume that both strings only contain lowercase English letters. 2. The function should be efficient enough to handle the maximum input size within a reasonable time frame. # Tips - Consider using sliding windows and hashmaps to optimize the search for anagram substrings. - Use a frequency count for characters to check for anagram properties efficiently. - Employ a two-pointer or dynamic programming approach to find common substrings.","solution":"def longest_anagram_substring(s1: str, s2: str) -> int: def sorted_str_freq(s): return \'\'.join(sorted(s)) def longest_common_anagram(s1, s2): len1, len2 = len(s1), len(s2) longest_len = 0 # Create a dictionary of sorted substring frequencies for s1 s1_substrings = {} for length in range(1, len1 + 1): for start in range(len1 - length + 1): substring = s1[start:start + length] sorted_sub = sorted_str_freq(substring) if sorted_sub in s1_substrings: s1_substrings[sorted_sub] = max(s1_substrings[sorted_sub], length) else: s1_substrings[sorted_sub] = length # Compare with s2 substrings for length in range(1, len2 + 1): for start in range(len2 - length + 1): substring = s2[start:start + length] sorted_sub = sorted_str_freq(substring) if sorted_sub in s1_substrings: longest_len = max(longest_len, s1_substrings[sorted_sub]) return longest_len return longest_common_anagram(s1, s2)"},{"question":"# Question: Implement a Circular Queue You are tasked with implementing a circular queue data structure (also known as a ring buffer) using a fixed-size list. Your implementation should support typical queue operations: enqueue, dequeue, front (peek), isEmpty, and isFull. Class Definition Define a class `CircularQueue` with the following methods: 1. `__init__(self, k: int) -> None`: Initialize the queue with a fixed size `k`. 2. `enqueue(self, value: int) -> bool`: Insert an element into the circular queue. Return `True` if the operation is successful, or `False` otherwise. 3. `dequeue(self) -> bool`: Remove an element from the circular queue. Return `True` if the operation is successful, or `False` otherwise. 4. `front(self) -> int`: Get the front item from the queue without removing it. If the queue is empty, return -1. 5. `isEmpty(self) -> bool`: Check whether the queue is empty. 6. `isFull(self) -> bool`: Check whether the queue is full. Restrictions and Requirements * You should not use any built-in queue or deque libraries. * Handle operations efficiently to meet O(1) time complexity for each method. * Ensure that `enqueue` and `dequeue` handle edge cases, such as null or incorrect values. Input - Initialize the queue with a fixed integer `k`. - The input to `enqueue` will be a single integer. Output - `enqueue` and `dequeue` should return a boolean value indicating the success of the operation. - `front` should return the front element or -1 if the queue is empty. - `isEmpty` and `isFull` should return boolean values indicating the state of the queue. Examples ```python # Example 1 cq = CircularQueue(3) assert cq.enqueue(1) is True assert cq.enqueue(2) is True assert cq.enqueue(3) is True assert cq.enqueue(4) is False # Queue is full assert cq.isFull() is True # Queue is indeed full assert cq.front() == 1 # The front element is 1 assert cq.dequeue() is True assert cq.front() == 2 # Now the front element is 2 after one dequeue assert cq.enqueue(4) is True assert cq.isFull() is True # Queue again becomes full assert cq.dequeue() is True assert cq.dequeue() is True assert cq.dequeue() is True assert cq.dequeue() is False # Queue is empty, cannot dequeue # Example 2 cq = CircularQueue(1) assert cq.enqueue(10) is True assert cq.isFull() is True assert cq.enqueue(20) is False assert cq.dequeue() is True assert cq.dequeue() is False assert cq.isEmpty() is True assert cq.front() == -1 ``` Constraints & Limitations - The maximum number of elements `k` will always be a positive integer and no more than 1000. - Operations should be performed efficiently to ensure they meet O(1) time complexity. - Ensure to handle edge cases, such as operations on an empty or full queue gracefully.","solution":"class CircularQueue: def __init__(self, k: int): Initialize the circular queue with the given size k. self.queue = [0] * k self.size = k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: Insert an element into the circular queue. Return True if the operation is successful, or False otherwise. if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> bool: Remove an element from the circular queue. Return True if the operation is successful, or False otherwise. if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return True def front(self) -> int: Get the front item from the queue without removing it. If the queue is empty, return -1. if self.isEmpty(): return -1 return self.queue[self.head] def isEmpty(self) -> bool: Check whether the queue is empty. return self.head == -1 def isFull(self) -> bool: Check whether the queue is full. return (self.tail + 1) % self.size == self.head"},{"question":"# Implement a Mini Calendar Scheduler Problem Description You are asked to implement a simple calendar scheduler system that allows users to add, remove, and view events on a given date. Implementation Details 1. **Data Structures**: * Use a dictionary to store events, where the keys are dates (in `YYYY-MM-DD` format) and the values are lists of events scheduled for that date. 2. **Functions**: * **Add Event**: Write a function `add_event` that takes a date and an event description and adds the event to the specified date. * **Remove Event**: Write a function `remove_event` that takes a date and an event description and removes the specified event from that date. * **View Events**: Write a function `view_events` that takes a date and returns a list of events scheduled for that date. 3. **User Interaction**: * Implement a `main` function that allows the user to interact with the calendar by: * Adding events. * Removing events. * Viewing events for a specific date. * The user should be able to perform multiple operations until they choose to exit. Input Format * The date will be provided in `YYYY-MM-DD` format. * Event descriptions will be strings containing printable ASCII characters. * For each operation, the user should specify whether they want to add, remove, or view events. Output Format * Print the list of events scheduled for a date when the user chooses to view events. * Print a confirmation message when an event is added or removed. Constraints * Dates will be valid and in the correct `YYYY-MM-DD` format. * Event descriptions will be non-empty strings containing only printable ASCII characters. # Example User Interaction ``` Welcome to the Mini Calendar Scheduler! What would you like to do? 1. Add event 2. Remove event 3. View events 4. Exit Enter your choice: 1 Enter the date (YYYY-MM-DD): 2023-10-21 Enter the event description: Doctor\'s appointment Event added successfully! What would you like to do? 1. Add event 2. Remove event 3. View events 4. Exit Enter your choice: 3 Enter the date (YYYY-MM-DD): 2023-10-21 Events on 2023-10-21: 1. Doctor\'s appointment What would you like to do? 1. Add event 2. Remove event 3. View events 4. Exit Enter your choice: 4 Goodbye! ``` ________ Your Task Implement the functions `add_event`, `remove_event`, `view_events`, and the main functionality to handle user input and perform respective operations on the calendar.","solution":"calendar = {} def add_event(date, event): Adds an event to the specified date. :param date: Date in \'YYYY-MM-DD\' format. :param event: Event description as a string. if date not in calendar: calendar[date] = [] calendar[date].append(event) return f\\"Event added successfully!\\" def remove_event(date, event): Removes a specified event from the specified date. :param date: Date in \'YYYY-MM-DD\' format. :param event: Event description as a string. if date in calendar and event in calendar[date]: calendar[date].remove(event) if len(calendar[date]) == 0: # Clean up empty lists to keep the dictionary clean del calendar[date] return f\\"Event removed successfully!\\" return \\"Event not found!\\" def view_events(date): Returns a list of events for the specified date. :param date: Date in \'YYYY-MM-DD\' format. :return: List of event descriptions. if date in calendar: return calendar[date] return [] def main(): while True: print(\\"nWhat would you like to do?n1. Add eventn2. Remove eventn3. View eventsn4. Exit\\") choice = input(\\"Enter your choice: \\") if choice == \'1\': date = input(\\"Enter the date (YYYY-MM-DD): \\") event = input(\\"Enter the event description: \\") print(add_event(date, event)) elif choice == \'2\': date = input(\\"Enter the date (YYYY-MM-DD): \\") event = input(\\"Enter the event description: \\") print(remove_event(date, event)) elif choice == \'3\': date = input(\\"Enter the date (YYYY-MM-DD): \\") events = view_events(date) if events: print(f\\"Events on {date}:\\") for i, e in enumerate(events, 1): print(f\\"{i}. {e}\\") else: print(f\\"No events found on {date}.\\") elif choice == \'4\': print(\\"Goodbye!\\") break else: print(\\"Invalid choice, please try again.\\")"},{"question":"# Problem Statement You are tasked with creating a function that handles date manipulation in a specific format. Your function will take a date-string as input along with a number of days to add to or subtract from that date. The function should return the resulting date in the same format. # Function Signature ```python def manipulate_date(date_str: str, days: int) -> str: `date_str`: A string representing the date in \\"YYYY-MM-DD\\" format. `days`: An integer number indicating the number of days to add (if positive) or subtract (if negative). Returns the resulting date as a string in \\"YYYY-MM-DD\\" format. Constraints: * The date is guaranteed to be in the valid \\"YYYY-MM-DD\\" format. * The number of days can range between -10^4 and 10^4. Example: >>> manipulate_date(\'2023-10-10\', 5) \'2023-10-15\' >>> manipulate_date(\'2023-10-10\', -15) \'2023-09-25\' pass ``` # Guidelines 1. **Date Handling**: Use Python\'s built-in `datetime` module to handle date manipulations. 2. **Edge Cases**: Consider cases such as: - Adding 0 days (should return the same date). - Subtracting days that go back to the previous month or year. - Adding days that push the date into the next month or year. 3. **Output Format**: Ensure the output date is always in \\"YYYY-MM-DD\\" format, regardless of the input date. # Input and Output Format ```text manipulate_date(\'2023-10-10\', 5) => \'2023-10-15\' manipulate_date(\'2023-10-10\', -15) => \'2023-09-25\' manipulate_date(\'2023-02-28\', 1) => \'2023-03-01\' manipulate_date(\'2024-02-28\', 1) => \'2024-02-29\' # Leap year consideration manipulate_date(\'2023-01-01\', -1) => \'2022-12-31\' ``` # Constraints * The date string is always valid and in the format \\"YYYY-MM-DD\\". * The number of days to manipulate is between -10,000 to 10,000 inclusive. Notes - Implement the solution efficiently, ensuring it handles the maximum possible range of dates. - Consider leap years and varying days in months.","solution":"from datetime import datetime, timedelta def manipulate_date(date_str: str, days: int) -> str: `date_str`: A string representing the date in \\"YYYY-MM-DD\\" format. `days`: An integer number indicating the number of days to add (if positive) or subtract (if negative). Returns the resulting date as a string in \\"YYYY-MM-DD\\" format. input_date = datetime.strptime(date_str, \\"%Y-%m-%d\\") manipulated_date = input_date + timedelta(days=days) return manipulated_date.strftime(\\"%Y-%m-%d\\")"},{"question":"# Problem Statement Consider a scenario where you need to manage a list of contacts, with each contact represented by a tuple containing the contact\'s name and phone number. You are tasked with creating a function that can sort this list of contacts. The function needs to provide an option to sort the contacts either by name or by phone number. The function should take in a list of contacts and a sorting key. Depending on the sorting key, it should return a new list of contacts sorted accordingly. Write a function `sort_contacts(contacts: List[Tuple[str, str]], key: str) -> List[Tuple[str, str]]` that sorts the list of contacts based on the specified key. The key will either be `\'name\'` or `\'phone\'`. # Input - `contacts`: A list of tuples, where each tuple contains two strings `(name, phone)` representing a contact\'s name and phone number. - `key`: A string, either `\'name\'` or `\'phone\'`, indicating the sorting criterion. # Output - Returns a new list of tuples, sorted based on the given key. # Constraints - Both the contact\'s name and phone number are non-empty strings. - The list of contacts can contain up to 1000 contacts. - Phone numbers are strings of digits and may contain leading zeros. - The sorting should be case-insensitive when sorting by name. # Example ```python def sort_contacts(contacts: List[Tuple[str, str]], key: str) -> List[Tuple[str, str]]: if key == \'name\': return sorted(contacts, key=lambda x: x[0].lower()) elif key == \'phone\': return sorted(contacts, key=lambda x: x[1]) else: raise ValueError(\\"Invalid sorting key\\") # Testing the function contacts = [(\\"Alice\\", \\"12345\\"), (\\"bob\\", \\"67890\\"), (\\"Charlie\\", \\"24680\\"), (\\"alice\\", \\"13579\\")] print(sort_contacts(contacts, \'name\')) # Expected output: [(\'alice\', \'13579\'), (\'Alice\', \'12345\'), (\'bob\', \'67890\'), (\'Charlie\', \'24680\')] print(sort_contacts(contacts, \'phone\')) # Expected output: [(\'Alice\', \'12345\'), (\'alice\', \'13579\'), (\'Charlie\', \'24680\'), (\'bob\', \'67890\')] ```","solution":"from typing import List, Tuple def sort_contacts(contacts: List[Tuple[str, str]], key: str) -> List[Tuple[str, str]]: if key == \'name\': return sorted(contacts, key=lambda x: x[0].lower()) elif key == \'phone\': return sorted(contacts, key=lambda x: x[1]) else: raise ValueError(\\"Invalid sorting key\\")"},{"question":"# Question Description Context Working with arrays and transformations is a common task in programming. One such transformation involves modifying the values in an array based on specific criteria, which can be vital in various scenarios such as data normalization, filtering, or adjustments. Task You are required to design a function that squares every even number in an input array and leaves the odd numbers unchanged. Detailed Instructions * **Function Signature**: ```python def square_evens(arr: List[int]) -> List[int]: Squares the even numbers in the given list. :param arr: Input list of integers. :return: List of integers where every even number is squared. ``` * **Expected Input and Output Formats**: * The function accepts a single list of integers `arr`. * The function returns a list of integers where all even numbers are squared, and odd numbers remain unchanged. * **Constraints**: * The input array can be empty. * The integers in the input array can be positive, negative, or zero. * **Performance Requirements**: The function should run in linear time, i.e., O(n), where n is the length of the array. Examples: ```python >>> square_evens([1, 2, 3, 4]) [1, 4, 3, 16] >>> square_evens([0, -2, -3, 5]) [0, 4, -3, 5] >>> square_evens([]) [] >>> square_evens([1, 3, 5]) [1, 3, 5] >>> square_evens([2, 4, 6]) [4, 16, 36] >>> square_evens([-1, -2, -3, -4]) [-1, 4, -3, 16] ``` Edge Cases: 1. If the input array is empty, the function should return an empty list. 2. If the input array contains only odd numbers, all elements should remain unchanged. 3. If the input array contains zero, it should remain zero as it is an even number.","solution":"from typing import List def square_evens(arr: List[int]) -> List[int]: Squares the even numbers in the given list. :param arr: Input list of integers. :return: List of integers where every even number is squared. return [x**2 if x % 2 == 0 else x for x in arr]"},{"question":"# First Missing Positive Problem Statement Write a function `first_missing_positive(nums: List[int]) -> int` that finds the smallest positive integer missing in an unsorted list of integers. Input - A list of integers `nums` with length between 1 and 1000. Output - The smallest positive integer that is missing from the list. Constraints - The list may contain both positive and negative integers and zeros. - Your solution should run in O(n) time and use constant extra space (O(1)). Examples ```python >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 ``` Explanation - In the first example, the list goes up to 2, so 3 is the smallest missing positive integer. - In the second example, 2 is missing from the list of positive integers up to 4. - In the third example, the list lacks all positive integers starting from 1. Hence, 1 is the first missing positive integer.","solution":"def first_missing_positive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Coding Task: Write a function that determines the number of connected components in an undirected graph. An undirected graph is provided as an adjacency matrix. Each connected component should be counted and the total number should be returned. # Function Specification - **Function Name**: `count_connected_components` - **Input**: A 2D list `adj_matrix` representing the adjacency matrix of the graph. `adj_matrix[i][j]` is 1 if there is an edge between node `i` and node `j`, and 0 otherwise. - **Output**: An integer representing the number of connected components in the graph. # Example ```python adj_matrix = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ] print(count_connected_components(adj_matrix)) # Output: 2 ``` # Constraints 1. The graph represented by the adjacency matrix is undirected, which means that `adj_matrix[i][j] == adj_matrix[j][i]`. 2. `adj_matrix[i][i]` will always be 1, as each node is connected to itself. 3. The size of the adjacency matrix, `N`, (i.e., number of nodes) will be at most 1000. 4. Only valid adjacency matrices will be provided as input. # Points to Consider - Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the graph and identify connected components. - Keep track of visited nodes to avoid counting the same component multiple times. - You may use an iterative approach with a stack/queue to avoid recursion depth limits on large inputs. ```python def count_connected_components(adj_matrix): def dfs(node): stack = [node] while stack: curr = stack.pop() for neighbor, connected in enumerate(adj_matrix[curr]): if connected and neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() components = 0 for node in range(len(adj_matrix)): if node not in visited: dfs(node) components += 1 return components ```","solution":"def count_connected_components(adj_matrix): Returns the number of connected components in the undirected graph represented by the adjacency matrix. def dfs(node): stack = [node] while stack: curr = stack.pop() for neighbor, connected in enumerate(adj_matrix[curr]): if connected and neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() components = 0 for node in range(len(adj_matrix)): if node not in visited: visited.add(node) dfs(node) components += 1 return components"},{"question":"# Problem Statement Write a function that takes a non-negative integer `n` and returns the factorial of `n` (denoted as `n!`). The factorial of a non-negative integer `n` is the product of all positive integers less than or equal to `n`. You should also ensure that the function handles very large values of `n` efficiently. # Function Signature ```python def factorial(n: int) -> int: pass ``` # Input - `n` (0 ≤ n ≤ 10^6): A non-negative integer. # Output - An integer representing the factorial of `n`. # Example - Input: `n = 5` - Output: `120` - Explanation: The factorial of 5 is `5 * 4 * 3 * 2 * 1 = 120`. - Input: `n = 0` - Output: `1` - Explanation: The factorial of 0 is defined as 1. # Constraints - Ensure the solution is optimized for large values of `n`. The function should handle up to `n = 10^6` without causing performance issues. # Notes - Consider using iterative or optimized algorithms for computing the factorial to avoid potential stack overflow issues with recursion on large input values.","solution":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n. if n == 0: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"# Context The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. That is, F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n ≥ 2. This sequence finds applications in various domains such as computer algorithms, mathematics, and nature. # Problem You are required to implement a function `nth_fibonacci(n: int) -> int` that computes the n-th number in the Fibonacci sequence. The function should be efficient, aiming for a time complexity of O(log n) using matrix exponentiation. # Detailed Requirements 1. **Matrix Exponentiation**: - Use matrix exponentiation to achieve an efficient algorithm for finding the nth Fibonacci number, avoiding the exponential time complexity of naive recursion or the linear time complexity of iterative methods. 2. **Edge Case Handling**: - If `n` is less than 0, your function should raise a `ValueError` with the message \\"Input must be a non-negative integer.\\" 3. **Return Value**: The function returns an integer representing the n-th Fibonacci number. # Function Signature ```python def nth_fibonacci(n: int) -> int: ``` # Example ```python >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(2) 1 >>> nth_fibonacci(10) 55 >>> nth_fibonacci(-5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer. ``` # Constraints 1. The input integer `n` will be in the range of 0 ≤ n ≤ 10^9. # Notes - Matrix exponentiation is a method that can compute powers of a matrix in logarithmic time, enabling efficient calculation of the nth Fibonacci number. - Ensure that the function is both time-efficient and space-efficient to handle large values of `n` up to a billion.","solution":"def nth_fibonacci(n: int) -> int: Compute the nth Fibonacci number using matrix exponentiation. :param n: Index of the term to find in the Fibonacci sequence (0-based). Must be a non-negative integer. :return: The nth Fibonacci number. :raises ValueError: If the input is a negative integer. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") # Base cases if n == 0: return 0 if n == 1: return 1 # Helper function to multiply two 2x2 matrices def matrix_mult(a, b): return [ [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]], [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]] ] # Helper function to compute matrix exponentiation def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0]"},{"question":"# Calculate Sum of Digits Context The sum of digits of an integer `n` is the sum of all its individual digits. This task involves writing a function to compute this sum for a given integer `n`. Your task is to implement the function in such a way that it handles large integers efficiently. Task Write a function `sum_of_digits(n: int) -> int` that takes an integer `n` as input and returns the sum of its digits. The function should raise a `TypeError` if the input is not an integer. Function Signature ```python def sum_of_digits(n: int) -> int: ``` Input * An integer `n` where ( 0 leq n leq 10^{18} ). Output * An integer representing the sum of the digits of `n`. * Raise `TypeError` if the input is not an integer. Performance Requirements * Ensure that your implementation handles large integers efficiently. Example ```python >>> sum_of_digits(12345) 15 >>> sum_of_digits(9876543210) 45 >>> sum_of_digits(0) 0 >>> sum_of_digits(1000000000000000000) 1 >>> sum_of_digits(-9876) 30 >>> sum_of_digits(3.14) Traceback (most recent call last): ... TypeError: Input value of [number=3.14] must be an integer ``` Constraints * ( 0 leq n leq 10^{18} ) * Function should not take input/output from the user directly; it should be purely functional. Hints * Consider edge cases and ensure input validation. * Handle possible large integer values in the most optimal way.","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the given integer n. Parameters: n (int): The integer whose sum of digits is to be computed. Returns: int: Sum of the digits of n. Raises: TypeError: If the input is not an integer. if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") # Use absolute value to handle negative numbers n = abs(n) # Calculate the sum of digits return sum(int(digit) for digit in str(n))"},{"question":"# Question You are given a string and a pattern. Your task is to write a function that finds the starting index of the first occurrence of the pattern in the string using the Knuth-Morris-Pratt (KMP) string matching algorithm. # Function Signature ```python def kmp_search(text: str, pattern: str) -> int: ``` # Input - `text`: a string in which you are searching for the pattern. - `pattern`: a string that you are trying to find within the text. # Output - An integer representing the starting index of the first occurrence of the pattern in the text. - If the pattern is not found in the text, return -1. # Constraints - The pattern will not be empty and will always be smaller than or equal to the text. - Length of the text: 1 ≤ len(text) ≤ 10^5 - Length of the pattern: 1 ≤ len(pattern) ≤ 10^4 - Both text and pattern will only contain lowercase English letters. # Examples ```python >>> kmp_search(\\"abxabcabcaby\\", \\"abcaby\\") 6 >>> kmp_search(\\"hello\\", \\"ll\\") 2 >>> kmp_search(\\"aaaaa\\", \\"bba\\") -1 >>> kmp_search(\\"mississippi\\", \\"issip\\") 4 ``` # Explanation - In the first example, \\"abcaby\\" is found in \\"abxabcabcaby\\" starting at index 6, so the function returns 6. - In the second example, \\"ll\\" is found in \\"hello\\" starting at index 2, so the function returns 2. - If the pattern is not found in the text, as in the third example, the function returns -1. Implement your function in Python: ```python def kmp_search(text: str, pattern: str) -> int: # Your code here # ```","solution":"def kmp_search(text: str, pattern: str) -> int: def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Problem Statement You are given a set of integers representing a sequence, and your task is to write a function to find the length of the longest subsequence that is a palindrome. A subsequence is a series that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. # Function Signature ```python def longest_palindromic_subsequence(sequence: List[int]) -> int: pass ``` # Input * `sequence`: A list of integers representing the sequence. # Output * An integer representing the length of the longest palindromic subsequence. # Constraints * The length of `sequence` will be between 1 and 1000. * Each integer in the sequence will be between -1000 and 1000. # Performance Requirements * Your algorithm should aim for a time complexity of O(n^2). # Example ```python sequence = [1, 3, 2, 1, 3, 2, 1] print(longest_palindromic_subsequence(sequence)) # Expected Output: 5 (The longest palindromic subsequence is [1, 3, 2, 3, 1]) sequence = [8, 2, 3, 7, 1] print(longest_palindromic_subsequence(sequence)) # Expected Output: 1 (No palindromic subsequence longer than 1 exists, e.g., [8], [2], [3], [7], or [1]) sequence = [4, 6, 4, 3, 6, 3, 4] print(longest_palindromic_subsequence(sequence)) # Expected Output: 5 (The longest palindromic subsequence is [4, 6, 4, 3, 4]) ``` # Notes * Ensure to handle edge cases where all elements are unique, meaning the longest palindromic subsequence would have a length of 1. * Consider also sequences where the entire sequence itself is a palindrome.","solution":"from typing import List def longest_palindromic_subsequence(sequence: List[int]) -> int: Returns the length of the longest subsequence of the given sequence that is a palindrome. n = len(sequence) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 # every single character is a palindrome of length 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if sequence[i] == sequence[j] and cl == 2: dp[i][j] = 2 elif sequence[i] == sequence[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1]"},{"question":"# Coding Question: Detect Cycle in a Directed Graph Given a directed graph, implement a function to detect if there\'s a cycle present in the graph using Depth-First Search (DFS). Function Signature ```python def detect_cycle_in_digraph(graph: Dict[int, List[int]], num_vertices: int) -> bool: \'\'\' Params: - graph: A dictionary where the key is a vertex and the value is a list of directed edges (destination vertices). - num_vertices: An integer representing the number of vertices in the graph. Returns: - A boolean value: True if there is a cycle in the graph, False otherwise. \'\'\' ``` Example ```python # Sample graph represented with adjacency list: graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } num_vertices = 4 # Expected result: True (Due to cycle 0 -> 2 -> 0 or 3 -> 3) print(detect_cycle_in_digraph(graph, num_vertices)) ``` ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } num_vertices = 4 # Expected result: False (No cycle detected) print(detect_cycle_in_digraph(graph, num_vertices)) ``` Constraints - The number of vertices `num_vertices` is between 2 and 1000. - The graph is connected and can have up to 5000 edges. - Vertex indices are non-negative integers. Detailed Description 1. **Graph Representation**: The graph will be provided as an adjacency list in the form of a dictionary, where keys are the vertices and values are lists of vertices to which there are directed edges. 2. **DFS Implementation**: Use a Depth-First Search approach to traverse the graph and detect cycles. 3. **Input Validation**: Ensure to validate your inputs to handle cases, such as graphs with self-loops or disconnected subgraphs appropriately. 4. **Output**: Return a boolean indicating whether a cycle exists in the graph. Good luck, and ensure your implementation is optimized to handle the given constraints!","solution":"def detect_cycle_in_digraph(graph, num_vertices): Returns True if there is a cycle in the graph, False otherwise. Params: graph: A dictionary where the key is a vertex and the value is a list of directed edges (destination vertices). num_vertices: An integer representing the number of vertices in the graph. # Helper function to perform DFS and detect cycle def dfs(vertex, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited[vertex] = True rec_stack[vertex] = True # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(vertex, []): if not visited[neighbor]: # If not yet visited, recurse if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: # If already in rec_stack, cycle detected return True # Remove the vertex from recursion stack rec_stack[vertex] = False return False # Initialize visited and recStack arrays visited = [False] * num_vertices rec_stack = [False] * num_vertices # Call the recursive helper function to detect cycles in different DFS trees for node in range(num_vertices): if not visited[node]: # If node not yet visited if dfs(node, visited, rec_stack): return True return False"},{"question":"# Coding Assessment Question: Scenario: As a frontend developer, you\'re tasked with creating a small utility to help manage a store\'s inventory. You need to write functions to adjust stock quantities when new shipments arrive and when items are sold. Task: Write the two functions `update_inventory_on_shipment(arrival_list)` and `update_inventory_on_sale(sales_list)` to manage the inventory updates. Function Specifications: 1. **Function**: update_inventory_on_shipment - **Input**: - `arrival_list` (list of tuples): A list of tuples, where each tuple contains the item name (str) and the quantity (int) being added to the inventory. - **Output**: - (dict): Updated inventory dictionary where keys are item names (str) and values are quantities (int). 2. **Function**: update_inventory_on_sale - **Input**: - `sales_list` (list of tuples): A list of tuples, where each tuple contains the item name (str) and the quantity (int) being sold from the inventory. - **Output**: - (dict): Updated inventory dictionary where keys are item names (str) and values are quantities (int). Constraints: - `0 <= len(arrival_list) <= 10^6` - `0 <= len(sales_list) <= 10^6` - Quantity in any tuple in `arrival_list` or `sales_list` is a positive integer. - If an item does not exist in the inventory, it should be added with the given quantity during shipment. - If an item is sold in a quantity greater than available in the inventory, the item quantity should become zero. - Ensure the solution is optimized for large input sizes. # Example: ```python inventory = {} arrival_list = [(\\"apple\\", 50), (\\"banana\\", 30)] inventory = update_inventory_on_shipment(arrival_list) print(inventory) # Output: {\\"apple\\": 50, \\"banana\\": 30} sales_list = [(\\"apple\\", 10), (\\"banana\\", 15)] inventory = update_inventory_on_sale(sales_list) print(inventory) # Output: {\\"apple\\": 40, \\"banana\\": 15} sales_list = [(\\"apple\\", 50)] inventory = update_inventory_on_sale(sales_list) print(inventory) # Output: {\\"apple\\": 0, \\"banana\\": 15} ``` **Note**: Ensure that your solution handles updating the inventory efficiently, particularly for large lists of shipments and sales. The initial inventory is assumed to be empty, but it should correctly add quantities for new items and update existing ones.","solution":"def update_inventory_on_shipment(arrival_list): global inventory for item, quantity in arrival_list: if item in inventory: inventory[item] += quantity else: inventory[item] = quantity return inventory def update_inventory_on_sale(sales_list): global inventory for item, quantity in sales_list: if item in inventory: inventory[item] = max(0, inventory[item] - quantity) return inventory # Global inventory inventory = {}"},{"question":"# Matrix Pathfinding You need to create a function that determines the number of unique paths from the top-left corner to the bottom-right corner of a grid. The grid has obstacles which prevent movement through certain cells. Moving is restricted to right or down. Function Signature ```python def unique_paths_with_obstacles(grid: list[list[int]]) -> int: pass ``` Input * A 2D list `grid` of integers where: - `grid[i][j]` is either 0 (an empty cell) or 1 (an obstacle). - `1 ≤ m, n ≤ 100` where `m` is the number of rows and `n` is the number of columns. Output * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. Constraints * The start and end cells are always empty (i.e., `grid[0][0] == 0` and `grid[m-1][n-1] == 0`). * If there is no valid path, return 0. Example For instance, calling `unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]])` should return: ```python 2 ``` Explanation There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down. 2. Down -> Down -> Right -> Right. Notes * Make sure to handle grids with different obstacles and configurations. * Optimize the solution properly to handle larger grids efficiently.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. m, n = len(grid), len(grid[0]) # Edge case where the start or end is an obstacle if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize the DP table dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"# Problem Description You are tasked with implementing a simplified version of the popular board game \\"Connect Four.\\" Your function should determine if a player has won the game after their move. The function should check for a win condition (four consecutive pieces of the same kind) either horizontally, vertically, or diagonally. # Function Specification Write a function `check_winner(board: List[List[int]], player: int) -> bool` which takes in a 6x7 game board and a player identifier to determine if the player has won. Input - `board` (List[List[int]]): A 6x7 list of lists, representing the game board. Empty slots are denoted by 0, player 1\'s pieces by 1, and player 2\'s pieces by 2. - `player` (int): An integer (either 1 or 2) representing the player to check for a win condition. Output - A boolean value indicating whether the specified player has won. Constraints - The function should handle the standard 6x7 Connect Four board dimensions. # Example ```python from typing import List def check_winner(board: List[List[int]], player: int) -> bool: # implement here board = [ [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 2, 1, 0, 0], [0, 1, 1, 2, 2, 0, 0], ] print(check_winner(board, 1)) # Output: False board = [ [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 2, 1, 0, 0], [0, 1, 0, 2, 1, 0, 0], [1, 1, 1, 2, 2, 0, 0], ] print(check_winner(board, 2)) # Output: True ``` # Requirements - Consider all possible win conditions: horizontal, vertical, and diagonal. - Ensure the function is efficient and does not check unnecessary positions. - Corner cases should be handled gracefully (e.g., incomplete boards, nearly-winning conditions). Good luck!","solution":"from typing import List def check_winner(board: List[List[int]], player: int) -> bool: # Check horizontal win for row in board: for col in range(4): # Only need to check from 0 to 3 because of the next 3 cells if row[col] == player and row[col + 1] == player and row[col + 2] == player and row[col + 3] == player: return True # Check vertical win for col in range(7): for row in range(3): # Only need to check from 0 to 2 because of the next 3 cells if board[row][col] == player and board[row + 1][col] == player and board[row + 2][col] == player and board[row + 3][col] == player: return True # Check diagonal (positive slope) win for row in range(3): # Only need to check from 0 to 2 because of the next 3 cells for col in range(4): # Only need to check from 0 to 3 because of the next 3 cells if board[row][col] == player and board[row + 1][col + 1] == player and board[row + 2][col + 2] == player and board[row + 3][col + 3] == player: return True # Check diagonal (negative slope) win for row in range(3, 6): # Check from 3 to 5 because of the previous 3 cells for col in range(4): # Only need to check from 0 to 3 because of the next 3 cells if board[row][col] == player and board[row - 1][col + 1] == player and board[row - 2][col + 2] == player and board[row - 3][col + 3] == player: return True return False"},{"question":"# Longest Common Subsequence Scenario You are given two sequences, and you need to find the length of their longest common subsequence. The subsequence is a sequence that appears in the same relative order but not necessarily consecutively. This problem is typical in string matching, genetic sequence analysis, and version control comparisons. Problem # Function Signature ```python def longest_common_subsequence(seq1: str, seq2: str) -> int: ``` # Input * `seq1` (string): The first sequence consisting of lowercase letters. * `seq2` (string): The second sequence consisting of lowercase letters. # Output * `int`: The length of their longest common subsequence. # Constraints * `0 <= len(seq1), len(seq2) <= 1000` * All characters in `seq1` and `seq2` are lowercase English letters. Example ```python >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 ``` Requirements * Implement the function using dynamic programming. * Address edge cases such as empty input sequences or non-overlapping sequences. This question provides a clear problem statement, follows the guidelines for function signature and constraints, includes examples for expected behavior, and specifies implementation requirements.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> int: Returns the length of the longest common subsequence between seq1 and seq2. Parameters: seq1 (str): The first input sequence. seq2 (str): The second input sequence. Returns: int: The length of the longest common subsequence. m = len(seq1) k = len(seq2) # Initialize a 2D DP array with zeroes dp = [[0] * (k + 1) for _ in range(m + 1)] # Fill the DP array for i in range(1, m + 1): for j in range(1, k + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][k]"},{"question":"# Problem Statement: Give an integer array `arr`, find the maximum product of any three numbers in the array. # Input: An integer array `arr` of length `n`. # Output: Return the maximum product of any three numbers in the array, or `None` if the array has less than three elements. # Constraints: * The function should return `None` for arrays with fewer than three elements. * The implementation should handle arrays with negative and positive numbers. * The implementation should be efficient for both small and large arrays. # Function Signature: ```python def max_product_of_three(arr: List[int]) -> Optional[int]: # Your implementation goes here ``` # Examples: ```python assert max_product_of_three([1, 2, 3, 4]) == 24 assert max_product_of_three([-10, -10, 5, 2]) == 500 assert max_product_of_three([1, 2, 3]) == 6 assert max_product_of_three([-1, -2, -3, -4]) == -6 assert max_product_of_three([1]) == None ```","solution":"from typing import List, Optional def max_product_of_three(arr: List[int]) -> Optional[int]: if len(arr) < 3: return None arr.sort() return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3]) # Examples given in the problem statement: assert max_product_of_three([1, 2, 3, 4]) == 24 assert max_product_of_three([-10, -10, 5, 2]) == 500 assert max_product_of_three([1, 2, 3]) == 6 assert max_product_of_three([-1, -2, -3, -4]) == -6 assert max_product_of_three([1]) == None"},{"question":"# Pathfinding Algorithm with Diagonal Movements In this coding challenge, you are asked to extend the traditional A* pathfinding algorithm to support diagonal movements in addition to the standard horizontal and vertical movements. A* is a popular heuristic search algorithm for finding the shortest path between two points in a grid. Typically, it moves in four possible directions: up, down, left, and right. For this challenge, implement support for four additional diagonal directions: up-left, up-right, down-left, and down-right. The grid is represented as a 2D list of integers, where 0 indicates a walkable cell and 1 indicates an obstacle. You need to find the shortest path from a starting cell to a target cell, avoiding obstacles. If there is no path, return an empty list. # Function Specifications **Function: `find_path`** ```python def find_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` * **Description**: Uses the A* algorithm to find the shortest path from `start` to `goal`, allowing diagonal movements. * **Input**: - `grid`: A 2D list of integers. - `start`: A tuple `(row, col)` representing the starting cell. - `goal`: A tuple `(row, col)` representing the target cell. * **Output**: A list of tuples representing the path from start to goal (inclusive). Each tuple is a cell in the grid. # Heuristic Use the Euclidean distance as the heuristic for the A* algorithm when diagonal movements are allowed. # Additional Constraints 1. The grid\'s dimensions do not exceed 100x100. 2. Diagonal movements are allowed only if the destination cell and both adjacent horizontal and vertical cells are not obstacles. # Example Usage ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0], ] start = (0, 0) goal = (4, 4) path = find_path(grid, start, goal) # Expected output: A list of tuples representing the path, e.g., # [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (4, 4)] # Note: There may be multiple correct paths. ``` **Note**: Ensure your implementation is efficient with time complexity suitable for the given constraints. # Hints 1. Use a priority queue to manage the open list in the A* algorithm. 2. Validate that diagonal movements are legal by checking the adjacent horizontal and vertical cells. 3. Update the heuristic function to use Euclidean distance for diagonal movement support. Implement the `find_path` function following the specifications above to extend the A* pathfinding algorithm to support diagonal movements while maintaining efficiency.","solution":"import heapq from typing import List, Tuple import math def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> float: return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) def find_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: def neighbors(n): directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)] result = [] for direction in directions: nxt = (n[0] + direction[0], n[1] + direction[1]) if 0 <= nxt[0] < len(grid) and 0 <= nxt[1] < len(grid[0]) and grid[nxt[0]][nxt[1]] == 0: if abs(direction[0]) + abs(direction[1]) == 2: # Diagonal move if grid[n[0] + direction[0]][n[1]] == 1 or grid[n[0]][n[1] + direction[1]] == 1: continue result.append(nxt) return result open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start)) came_from = {start: None} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: current = heapq.heappop(open_set)[2] if current == goal: path = [] while current: path.append(current) current = came_from[current] path.reverse() return path for neighbor in neighbors(current): tentative_g_score = g_score[current] + heuristic(current, neighbor) if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], tentative_g_score, neighbor)) return []"},{"question":"# Array Compression You are given a list of integers where some elements may appear multiple times, and other elements may not be present at all. You must generate a compressed representation of this list using ranges and individual elements. The goal is to output a list of strings where each string is either a single element or a range of consecutive elements. Task Write a function `compress_list` that takes a list of integers and returns a list of strings that represent the compressed version of the input list. # Function Signature ```python def compress_list(arr: List[int]) -> List[str]: ``` # Input * `arr` (1 ≤ len(arr) ≤ 10,000): A list of integers. # Output A list of strings representing the compressed version of the input list. # Constraints * Ensure each range or single element in the output list is represented correctly and efficiently. * Consider edge cases where the array might have no elements or a single element. * Optimize for both time and space complexity, particularly for large input sizes. # Example ```python >>> compress_list([1, 2, 3, 6, 7, 8, 10]) [\'1-3\', \'6-8\', \'10\'] >>> compress_list([5, 6, 7, 12, 13, 14, 15, 16]) [\'5-7\', \'12-16\'] >>> compress_list([1]) [\'1\'] >>> compress_list([]) [] ``` # Hints * Utilize sorting and iterate through the sorted array to detect consecutive sequences. * Convert detected sequences into the correct string format and manage distinct elements efficiently. * Be mindful of potential overlaps and ensure non-overlapping ranges in the output.","solution":"from typing import List def compress_list(arr: List[int]) -> List[str]: if not arr: return [] arr = sorted(set(arr)) # Sort the array and remove duplicates compressed = [] start = arr[0] end = arr[0] for i in range(1, len(arr)): if arr[i] == end + 1: end = arr[i] else: if start == end: compressed.append(str(start)) else: compressed.append(f\\"{start}-{end}\\") start = arr[i] end = arr[i] if start == end: compressed.append(str(start)) else: compressed.append(f\\"{start}-{end}\\") return compressed"},{"question":"# Question: A travel agency offers various travel packages, each defined by a travel route (represented by start and end cities), duration in days, and a satisfaction score. Given a list of travel routes, durations, and satisfaction scores, find the maximum satisfaction score you can achieve within a given number of days. You can only utilize non-overlapping travel routes, but you can choose any route irrespective of the start city. **Function Signature**: ```python def max_satisfaction(routes: List[Tuple[str, str]], durations: List[int], satisfactions: List[int], max_days: int) -> int: Calculates the maximum satisfaction score achievable within the given maximum number of days, considering non-overlapping travel routes. :param routes: A list of tuples representing the start and end cities of the travel routes. :param durations: A list of integers representing the duration in days for each route. :param satisfactions: A list of integers representing the satisfaction scores for each route. :param max_days: An integer representing the maximum number of days available for travel. :return: An integer representing the maximum satisfaction score achievable within the given days. Example: >>> routes = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"A\\", \\"C\\")] >>> durations = [3, 2, 4] >>> satisfactions = [20, 15, 30] >>> max_days = 5 >>> max_satisfaction(routes, durations, satisfactions, max_days) 35 Constraints: - routes, durations, and satisfactions list will be of the same length. - 1 <= len(routes), len(durations), len(satisfactions) <= 10^3 - 1 <= max_days <= 10^5 - 1 <= satisfaction[i] <= 10^3 for any valid index i. - 1 <= duration[i] <= 10^2 for any valid index i. - all city names in routes are strings of uppercase English letters up to length 10. ``` **Requirements**: 1. Utilize dynamic programming to maximize the satisfaction score. 2. Ensure the function handles edge cases (e.g., empty lists, zero max_days). 3. The function should exhibit a time complexity of O(n * max_days) where n is the length of the routes list. **Example**: ```python >>> routes = [(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\")] >>> durations = [2, 2, 5, 4] >>> satisfactions = [10, 12, 20, 15] >>> max_days = 6 >>> print(max_satisfaction(routes, durations, satisfactions, max_days)) 27 ```","solution":"from typing import List, Tuple def max_satisfaction(routes: List[Tuple[str, str]], durations: List[int], satisfactions: List[int], max_days: int) -> int: n = len(routes) dp = [0] * (max_days + 1) for i in range(n): duration = durations[i] satisfaction = satisfactions[i] for d in range(max_days, duration - 1, -1): dp[d] = max(dp[d], dp[d - duration] + satisfaction) return dp[max_days]"},{"question":"# Coding Assessment Question **Problem Statement:** You need to write a function that calculates the distance between two points on a cartesian plane. The points are given as tuples of their coordinates. Your function should take two tuples as inputs, each representing the coordinates of a point in the 2-dimensional space. The coordinates are represented by floating-point numbers. The distance between two points ((x1, y1)) and ((x2, y2)) on a cartesian plane can be calculated using the Euclidean distance formula: [ d = sqrt{(x2 - x1)^2 + (y2 - y1)^2} ] **Function Signature:** ```python import math def calc_distance(point1: tuple(float, float), point2: tuple(float, float)) -> float: pass ``` # Input: - `point1`: A tuple containing two float values representing the coordinates of the first point ((x1, y1)). - `point2`: A tuple containing two float values representing the coordinates of the second point ((x2, y2)). # Output: - Returns a float, representing the distance between the two points. # Constraints: - Both tuples will contain exactly two elements. - The values will be floating-point numbers. # Example Usage: ```python print(calc_distance((0, 0), (3, 4))) # Output: 5.0 print(calc_distance((1.5, 2.5), (3.5, 4.5))) # Output: 2.8284271247461903 ``` # Edge Cases: - The function should work correctly for both positive and negative coordinates. - Ensure the function returns zero if both points are the same. **Test Cases:** 1. `calc_distance((0, 0), (3, 4))` should return `5.0`. 2. `calc_distance((1, 2), (4, 6))` should return `5.0`. 3. `calc_distance((-1, -1), (-4, -5))` should return `5.0`. 4. `calc_distance((2.5, 3.5), (2.5, 3.5))` should return `0.0`. 5. `calc_distance((2, -3), (-2, 0))` should return `5.0`. This new question aligns well with the existing set in terms of style, complexity, and scope, providing a unique problem while testing similar programming skills.","solution":"import math def calc_distance(point1: tuple, point2: tuple) -> float: Calculate the Euclidean distance between two points in a 2D plane. Args: point1 (tuple): A tuple containing the coordinates (x1, y1) of the first point. point2 (tuple): A tuple containing the coordinates (x2, y2) of the second point. Returns: float: The distance between the two points. x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"# Coding Assessment: Process and Aggregate User Activity Data Objective Your task is to write Python functions to process user activity logs and aggregate the information to provide insights about user behavior. You will be working with JSON data representing user activities on a web platform. Requirements 1. **Function 1: `process_user_activity(log: str) -> dict`** - Input: - A string representing a JSON formatted user activity log. - Output: - A dictionary containing processed user activity data. - Constraints: - The input string should be a valid JSON. - If the input is invalid JSON, return an appropriate error message. - The JSON should contain at least the fields `user_id`, `activity`, and `timestamp`. 2. **Function 2: `aggregate_user_activity(data: dict) -> dict`** - Input: - A dictionary containing processed user activity data aggregated by `user_id`. - Output: - A dictionary summarizing user activities including: - The total number of activities per user. - A list of all unique activities performed by each user. - The first and last activity timestamps for each user. Example JSON log format: ```json [ {\\"user_id\\": \\"user_1\\", \\"activity\\": \\"login\\", \\"timestamp\\": \\"2022-01-01T08:00:00Z\\"}, {\\"user_id\\": \\"user_1\\", \\"activity\\": \\"view_page\\", \\"timestamp\\": \\"2022-01-01T08:05:00Z\\"}, {\\"user_id\\": \\"user_2\\", \\"activity\\": \\"login\\", \\"timestamp\\": \\"2022-01-01T08:10:00Z\\"}, {\\"user_id\\": \\"user_1\\", \\"activity\\": \\"logout\\", \\"timestamp\\": \\"2022-01-01T08:30:00Z\\"}, {\\"user_id\\": \\"user_2\\", \\"activity\\": \\"view_page\\", \\"timestamp\\": \\"2022-01-01T08:15:00Z\\"} ] ``` Performance Requirements - The functions should efficiently handle large user activity logs. - Ensure the functions handle potential errors and missing fields gracefully. Example ```python >>> log = \'\'\'[ {\\"user_id\\": \\"user_1\\", \\"activity\\": \\"login\\", \\"timestamp\\": \\"2022-01-01T08:00:00Z\\"}, {\\"user_id\\": \\"user_1\\", \\"activity\\": \\"view_page\\", \\"timestamp\\": \\"2022-01-01T08:05:00Z\\"}, {\\"user_id\\": \\"user_2\\", \\"activity\\": \\"login\\", \\"timestamp\\": \\"2022-01-01T08:10:00Z\\"}, {\\"user_id\\": \\"user_1\\", \\"activity\\": \\"logout\\", \\"timestamp\\": \\"2022-01-01T08:30:00Z\\"}, {\\"user_id\\": \\"user_2\\", \\"activity\\": \\"view_page\\", \\"timestamp\\": \\"2022-01-01T08:15:00Z\\"} ]\'\'\' >>> processed_data = process_user_activity(log) >>> summary = aggregate_user_activity(processed_data) >>> print(summary) { \\"user_1\\": { \\"total_activities\\": 3, \\"unique_activities\\": [\\"login\\", \\"view_page\\", \\"logout\\"], \\"first_activity\\": \\"2022-01-01T08:00:00Z\\", \\"last_activity\\": \\"2022-01-01T08:30:00Z\\" }, \\"user_2\\": { \\"total_activities\\": 2, \\"unique_activities\\": [\\"login\\", \\"view_page\\"], \\"first_activity\\": \\"2022-01-01T08:10:00Z\\", \\"last_activity\\": \\"2022-01-01T08:15:00Z\\" } } ``` Notes 1. Ensure your solution handles invalid JSON gracefully. 2. Summary information must maintain the integrity of the data even if some fields are missing in the input. 3. Use appropriate string manipulation and JSON handling techniques to ensure data accuracy and robustness. Constraints - The input JSON string should be a valid JSON array of dictionaries. - Handle scenarios where user activities might be out of expected order, using timestamps to determine the first and last activities.","solution":"import json from collections import defaultdict from datetime import datetime def process_user_activity(log: str): Processes a user activity log string and returns a dictionary of user activities. Parameters: log (str): A string representing a JSON formatted user activity log. Returns: dict: Processed user activity data. try: activities = json.loads(log) except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON\\"} user_activities = defaultdict(list) for entry in activities: if \'user_id\' in entry and \'activity\' in entry and \'timestamp\' in entry: user_activities[entry[\'user_id\']].append(entry) else: return {\\"error\\": \\"Missing fields in JSON entry\\"} return user_activities def aggregate_user_activity(data): Aggregates user activity data by user_id and produces a summary. Parameters: data (dict): A dictionary containing user activity data aggregated by user_id. Returns: dict: A summary of user activities including total activities, unique activities, and activity timeframe. summary = {} for user_id, activities in data.items(): unique_activities = set() timestamps = [] for activity in activities: unique_activities.add(activity[\'activity\']) timestamps.append(datetime.fromisoformat(activity[\'timestamp\'].replace(\'Z\', \'+00:00\'))) summary[user_id] = { \\"total_activities\\": len(activities), \\"unique_activities\\": list(unique_activities), \\"first_activity\\": min(timestamps).isoformat().replace(\'+00:00\', \'Z\'), \\"last_activity\\": max(timestamps).isoformat().replace(\'+00:00\', \'Z\') } return summary"},{"question":"You are asked to implement a function that determines the smallest missing positive integer from an unsorted list of integers. The current naive implementation uses sorting and linear search, but it can be improved for better performance, especially with large datasets. # Task: Write a function `smallest_missing_positive` that takes a list of integers and returns the smallest missing positive integer. Optimize the function beyond the basic O(n log n) sorting approach. # Specifications: * **Input**: A list of integers, `arr`, where the length of `arr` can be up to 10^6. * **Output**: An integer representing the smallest missing positive integer. # Requirements: * You must solve the problem with better than O(n log n) time complexity. * Use constant space O(1) besides the input list for your solution. * Your function should efficiently handle large inputs. # Constraints: * The integers in the list can be both positive and negative, including zero. * Multiple test cases will be evaluated with varying lengths of `arr`. # Example: ```python def smallest_missing_positive(arr: list) -> int: pass # Example usage: # smallest_missing_positive([1, 2, 0]) should return 3 # smallest_missing_positive([3, 4, -1, 1]) should return 2 # smallest_missing_positive([7, 8, 9, 11, 12]) should return 1 ```","solution":"def smallest_missing_positive(arr): n = len(arr) # Step 1: Segregate positive numbers by moving negatives and zeros to the left j = 0 for i in range(n): if arr[i] <= 0: arr[i], arr[j] = arr[j], arr[i] j += 1 # Now j is the index of the first positive number arr = arr[j:] n = len(arr) # Step 2: Use index as a marker for i in range(n): val = abs(arr[i]) if 1 <= val <= n: idx = val - 1 if arr[idx] > 0: # Mark arr[val-1] as visited arr[idx] = -arr[idx] # Step 3: Find the first positive number\'s index for i in range(n): if arr[i] > 0: return i + 1 return n + 1 # Example usage: # print(smallest_missing_positive([1, 2, 0])) -> should return 3 # print(smallest_missing_positive([3, 4, -1, 1])) -> should return 2 # print(smallest_missing_positive([7, 8, 9, 11, 12])) -> should return 1"},{"question":"# Coding Assessment Question Scenario You are creating a library of functions for data analysis, and need to include utilities for image manipulation. To test students\' understanding, you decide to assess their ability to implement a feature that helps in resizing images while maintaining their aspect ratio. Task Implement a function `resize_image_aspect` that resizes an image represented by a 2D list of pixels (`image`) to a specific width, while maintaining the aspect ratio of the original image. Function Signature ```python def resize_image_aspect(image: List[List[int]], new_width: int) -> List[List[int]]: ``` Parameters - `image`: A List of Lists where each inner list represents a row of pixels (integers between 0 and 255), and all inner lists are of the same length. - `new_width`: An integer indicating the desired width of the resized image. Requirements 1. Calculate the appropriate height to maintain the aspect ratio based on the new width. 2. Use a simple nearest neighbor approach to resize the image. 3. If the new width is greater than the original width, fill the new pixels appropriately. 4. Handle edge cases such as empty images or invalid width inputs gracefully. 5. Provide at least two test cases demonstrating the function\'s effectiveness, e.g., using small images with known dimensions. Example Usage ```python original_image = [ [0, 0, 0, 0], [0, 255, 255, 0], [0, 255, 255, 0], [0, 0, 0, 0] ] resized_image = resize_image_aspect(original_image, 2) print(resized_image) # Expected output: [[0, 0], [0, 255]] resized_image = resize_image_aspect(original_image, 8) print(resized_image) # Expected output: appropriately scaled image maintaining aspect ratio ``` Constraints - Time complexity should be efficient for typical small to medium-sized images. - Handle edge cases such as negative or zero new_width appropriately by returning an empty list or a meaningful error message. Performance Requirements - The function should accurately resize the image according to the given width while maintaining the aspect ratio within the constraints of nearest neighbor interpolation.","solution":"from typing import List def resize_image_aspect(image: List[List[int]], new_width: int) -> List[List[int]]: Resizes an image to a specific width while maintaining its aspect ratio using nearest neighbor interpolation. Parameters: - image: List of Lists representing the 2D pixel values of the image. - new_width: The desired width for the resized image. Returns: - Resized image as a List of Lists of pixel values. if not image or new_width <= 0: return [] original_height = len(image) original_width = len(image[0]) if original_width == 0: # Edge case: original image width is zero return [] aspect_ratio = original_height / original_width new_height = int(new_width * aspect_ratio) resized_image = [] for new_row in range(new_height): original_row = int(new_row * original_height / new_height) new_row_data = [] for new_col in range(new_width): original_col = int(new_col * original_width / new_width) new_row_data.append(image[original_row][original_col]) resized_image.append(new_row_data) return resized_image"},{"question":"# Problem Statement: Enhanced Search Algorithm You are provided with a basic search algorithm that finds an element in a list. The current implementation only supports linear search. Your task is to enhance this implementation with two new features: 1. Implement the Binary Search algorithm for sorted lists. 2. Allow the user to choose between linear search and binary search. # Function Signature ```python def search_element(data_list: list, target: int, search_type: str = \\"linear\\") -> int: Searches for a target element in the list using the specified search algorithm. Parameters: data_list (list): List of integers to search. target (int): The element to search for. search_type (str): Type of search algorithm to use. One of \\"linear\\" or \\"binary\\". Returns: int: The index of the target element if found, otherwise -1. pass ``` # Input * `data_list`: A list of integers in which to search for the target element. * `target`: An integer representing the element to search for. * `search_type`: A string indicating the search algorithm to use (\\"linear\\" or \\"binary\\"). # Output * An integer representing the index of the target element if found, otherwise -1. # Constraints * The Binary Search should only be applied to sorted lists. * Validate that the search type provided is among the allowed options and handle invalid search types gracefully. # Example Usage ```python data_list = [1, 3, 5, 7, 9, 11, 13] target = 7 # Test Linear Search result = search_element(data_list, target, search_type=\\"linear\\") print(\\"Linear Search Result:\\") print(result) # Test Binary Search result = search_element(data_list, target, search_type=\\"binary\\") print(\\"Binary Search Result:\\") print(result) ``` # Solution Requirements * Implement the function `search_element` to support both linear search and binary search based on the specified search type. * Ensure that the Binary Search is applied correctly only to sorted lists. * Handle invalid search types by returning -1 and printing an appropriate error message. * Ensure your solution passes the provided example usage scenario.","solution":"def search_element(data_list, target, search_type=\\"linear\\"): Searches for a target element in the list using the specified search algorithm. Parameters: data_list (list): List of integers to search. target (int): The element to search for. search_type (str): Type of search algorithm to use. One of \\"linear\\" or \\"binary\\". Returns: int: The index of the target element if found, otherwise -1. def linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 def binary_search(arr, x): low = 0 high = len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == x: return mid elif arr[mid] < x: low = mid + 1 else: high = mid - 1 return -1 if search_type not in [\\"linear\\", \\"binary\\"]: print(\\"Invalid search type. Please choose \'linear\' or \'binary\'.\\") return -1 if search_type == \\"linear\\": return linear_search(data_list, target) if search_type == \\"binary\\": if data_list != sorted(data_list): print(\\"Binary search requires a sorted list.\\") return -1 return binary_search(data_list, target)"},{"question":"Question One of the fundamental problems in computer science is string pattern matching. Implement the Knuth-Morris-Pratt (KMP) algorithm that searches for a pattern `pat` within a given text `txt`. This function should return the starting index of the first occurrence of `pat` in `txt` or -1 if `pat` is not found. # Function Signature ```python def kmp_search(txt: str, pat: str) -> int: pass ``` # Input * A string `txt` (0 ≤ len(txt) ≤ 10^6), consisting of printable ASCII characters. * A string `pat` (1 ≤ len(pat) ≤ 10^6), consisting of printable ASCII characters. # Output * An integer representing the starting index of the first occurrence of `pat` in `txt`, or -1 if `pat` is not found. # Constraints * The algorithm must operate within O(n + m) time complexity, where `n` is the length of `txt` and `m` is the length of `pat`. # Examples ```python >>> kmp_search(\'abxabcabcaby\', \'abcaby\') 6 >>> kmp_search(\'hello world\', \'world\') 6 >>> kmp_search(\'abcdef\', \'gh\') -1 ``` # Scenario Efficient string pattern matching is crucial in text processing applications such as search engines, bioinformatics, and DNA sequence analysis. The KMP algorithm is designed to optimize this task by avoiding unnecessary comparisons. Your task is to implement this algorithm to achieve efficient string searches. # Notes Implement the KMP algorithm, ensuring it handles various input cases, including edge cases like an empty `txt`. The function will be tested on large inputs to ensure time efficiency is maintained.","solution":"def kmp_search(txt: str, pat: str) -> int: def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps n, m = len(txt), len(pat) if m == 0: return 0 lps = compute_lps(pat) i, j = 0, 0 while i < n: if pat[j] == txt[i]: i += 1 j += 1 if j == m: return i - j elif i < n and pat[j] != txt[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Context: You are developing a new feature for a data processing application that involves aggregating numbers within specified ranges. The application needs to handle multiple ranges and compute the sum for each range dynamically based on input. # Problem Statement: Write a Python function `range_sum(num_list: list, queries: list) -> list` that calculates the sum of numbers within given ranges in a list. The function should iterate over a list of queries where each query specifies a start and end index and returns the sum of numbers in those index ranges for each query. * Each query is a tuple containing two integers representing the start and end indices (both inclusive). For each query: - Extract the specified sublist. - Calculate and store the sum of the sublist. # Inputs: - `num_list (list)`: A list of integers. - `queries (list)`: A list of tuples where each tuple contains two integers representing the start and end indices of the range. # Outputs: - A list of integers where each integer is the sum of numbers in the specified range for each query. # Constraints: - `1 <= len(num_list) <= 10^5` - `1 <= len(queries) <= 1000` - `0 <= start <= end < len(num_list)` - All integers in `num_list` are between `-10^4` and `10^4`. # Example: ```python def range_sum(num_list: list, queries: list) -> list: pass # An example of the function in use: num_list = [1, 2, 3, 4, 5] queries = [(1, 3), (0, 2), (2, 4)] print(range_sum(num_list, queries)) # Output: [9, 6, 12] ``` # Notes: - Optimize for large input sizes to avoid performance issues. - Handle cases where queries might overlap or be consecutive. - Make sure the function operates within the given constraints effectively.","solution":"def range_sum(num_list: list, queries: list) -> list: Calculate the sum of numbers within given ranges. Parameters: - num_list (list): A list of integers. - queries (list): A list of tuples where each tuple contains two integers representing the start and end indices of the range. Returns: - list: A list of integers where each integer is the sum of numbers in the specified range for each query. # Precompute prefix sums to optimize range sum queries. prefix_sums = [0] * (len(num_list) + 1) for i in range(1, len(num_list) + 1): prefix_sums[i] = prefix_sums[i - 1] + num_list[i - 1] result = [] for start, end in queries: range_sum = prefix_sums[end + 1] - prefix_sums[start] result.append(range_sum) return result"},{"question":"# Coding Challenge: Sum of Digits You are tasked with creating a utility function that computes the sum of the digits of a given number recursively. Your function should validate the input parameter and handle possible edge cases. Function Signature ```python def sum_of_digits(number: int) -> int: # Your implementation here ``` Input 1. `number` (int): A non-negative integer whose sum of digits needs to be computed. Output - Returns an integer which is the sum of the digits of the input number. Constraints - `number` must be a non-negative integer (0 ≤ number ≤ 10^9). Examples 1. `sum_of_digits(123)` should return `6` (1 + 2 + 3). 2. `sum_of_digits(0)` should return `0`. 3. `sum_of_digits(9875)` should return `29` (9 + 8 + 7 + 5). 4. `sum_of_digits(1001)` should return `2` (1 + 0 + 0 + 1). Error Handling 1. If `number` is not a non-negative integer, raise a `ValueError` with a message indicating the expected type and the range constraint. Example Usage ```python try: print(sum_of_digits(123)) # Should output: 6 print(sum_of_digits(0)) # Should output: 0 print(sum_of_digits(9875)) # Should output: 29 print(sum_of_digits(1001)) # Should output: 2 except ValueError as e: print(str(e)) ``` Implement the `sum_of_digits` function according to the given requirements.","solution":"def sum_of_digits(number: int) -> int: Returns the sum of the digits of a non-negative integer number. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer (0 ≤ number ≤ 10^9)\\") if number == 0: return 0 if number < 10: return number return number % 10 + sum_of_digits(number // 10)"},{"question":"# Coding Assessment Question: **Objective**: Write a function that computes the sum of the squares of elements in a list, but only includes elements that are at even indices. This will test your ability to manipulate lists and use list indexing effectively. # Problem Statement: Implement the function `sum_of_squares_at_even_indices(nums: List[int]) -> int` that takes in a list of integers and returns the sum of the squares of the elements that are at even indices (i.e., indices 0, 2, 4, etc.). # Function Signature: ```python def sum_of_squares_at_even_indices(nums: List[int]) -> int: ``` # Input: - `nums` (List[int]): A list of integers. # Output: - int: The sum of the squares of the elements that are at even indices in the input list. # Constraints: - The input list can contain any integer values, including negative values and zero. - The input list can be of any length, including an empty list. # Examples: - `sum_of_squares_at_even_indices([1, 2, 3, 4, 5])` -> 35 - Calculation: 1² (index 0) + 3² (index 2) + 5² (index 4) = 1 + 9 + 25 = 35 - `sum_of_squares_at_even_indices([2, -3, 4, 5, -6])` -> 56 - Calculation: 2² (index 0) + 4² (index 2) + -6² (index 4) = 4 + 16 + 36 = 56 - `sum_of_squares_at_even_indices([-2, -3, -4, -5, -6])` -> 56 - Calculation: (-2)² (index 0) + (-4)² (index 2) + (-6)² (index 4) = 4 + 16 + 36 = 56 - `sum_of_squares_at_even_indices([])` -> 0 - Calculation: Since the list is empty, the sum is 0. - `sum_of_squares_at_even_indices([10])` -> 100 - Calculation: 10² (index 0) = 100 # Edge Cases to Consider: - The function should handle an empty list by returning 0. - The function should handle a list with only one element correctly. - Ensure the function can process large lists efficiently without unnecessary loops or operations.","solution":"from typing import List def sum_of_squares_at_even_indices(nums: List[int]) -> int: This function takes a list of integers and returns the sum of the squares of the elements that are at even indices. return sum(x**2 for i, x in enumerate(nums) if i % 2 == 0)"},{"question":"# Coding Assessment Question You are tasked with implementing two functions that handle and analyze sequences of integers with respect to prime numbers. Task **Function 1:** `is_prime_sequence(sequence: list) -> bool` Implement a function to verify if a given list consists solely of prime numbers. - **Input** - `sequence` (list): A list of positive integers to be checked if all elements are prime. - **Output** - Returns `True` if all elements in the sequence are prime numbers, and `False` otherwise. - **Constraints** - The `sequence` elements will be positive integers. - The `sequence` must be a non-empty list. - **Examples** ```python assert is_prime_sequence([2, 3, 5, 7, 11]) == True assert is_prime_sequence([2, 4, 6, 8]) == False ``` **Function 2:** `prime_count_upto(n: int) -> int` Implement a function to count how many prime numbers exist from 1 up to a given integer `n`. - **Input** - `n` (int): A positive integer up to which prime numbers are counted. - **Output** - Returns an integer as the count of prime numbers from 1 to `n`. - **Constraints** - `n` is a positive integer. - **Examples** ```python assert prime_count_upto(10) == 4 # Primes are: 2, 3, 5, 7 assert prime_count_upto(20) == 8 # Primes are: 2, 3, 5, 7, 11, 13, 17, 19 ``` Implement these functions considering the constraints and ensuring efficient performance for larger values of `n`.","solution":"import math def is_prime(num): if num < 2: return False for i in range(2, int(math.sqrt(num)) + 1): if num % i == 0: return False return True def is_prime_sequence(sequence: list) -> bool: Returns True if all elements in the sequence are prime numbers, False otherwise. return all(is_prime(num) for num in sequence) def prime_count_upto(n: int) -> int: Returns the count of prime numbers from 1 to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(math.sqrt(n)) + 1): if sieve[start]: for i in range(start * start, n + 1, start): sieve[i] = False return sum(sieve)"},{"question":"# Genetic Algorithm for Optimizing Ackley Function Context You are a graduate student working on optimization techniques in your computational mathematics course. Your project is to implement a Genetic Algorithm to optimize the Ackley function, which is a popular test case for optimization algorithms. The Ackley function is defined as: [ f(x, y) = -20 expleft(-0.2 sqrt{0.5(x^2 + y^2)}right) - expleft(0.5(cos(2pi x) + cos(2pi y))right) + e + 20 ] where (e) is the base of the natural logarithm. The domain for this function is defined as ( x, y in [-32, 32] ). Task Implement the Genetic Algorithm to find the minimum of the Ackley function. Your implementation will: 1. Initialize a population of candidate solutions. 2. Define the crossover, mutation, and selection mechanisms. 3. Perform iterations to evolve the population towards the minimum. 4. Validate the solution within the defined bounds. Function Signature ```python def genetic_algorithm_ackley_minimization( initial_population: list, population_size: int = 50, generations: int = 1000, crossover_rate: float = 0.7, mutation_rate: float = 0.001, max_x: float = 32, min_x: float = -32, max_y: float = 32, min_y: float = -32 ) -> Any: # your implementation here pass ``` Input * **initial_population**: A list of tuples with each tuple containing two floating-point values (x, y) indicating initial candidate solutions. * **population_size**: An integer specifying the size of the population (default 50). * **generations**: An integer indicating the number of generations to run the algorithm (default 1000). * **crossover_rate**: A floating-point value representing the probability of crossover (default 0.7). * **mutation_rate**: A floating-point value indicating the probability of mutation (default 0.001). * **max_x, min_x, max_y, min_y**: Floating-point values specifying the bounds of the search space (default [-32, 32]). Output * Returns a tuple containing the coordinates (x, y) of the local minimum found within the domain and the function value at that minimum. Constraints * Ensure the genetic operations (crossover and mutation) keep the offspring within the provided bounds. * Validate that the implemented algorithm works correctly and efficiently for the Ackley function. **Notes**: * Be mindful of edge cases where the genetic operations might produce invalid solutions. * Test your implementation with various initial populations to ensure robustness. Example ```python # Example function call minimum = genetic_algorithm_ackley_minimization( initial_population=[(20, 30), (-10, -20), (15, 25)], population_size=50, generations=1000, crossover_rate=0.7, mutation_rate=0.001 ) print(\\"Minimum:\\", minimum) ```","solution":"import random import math def ackley_function(x, y): return -20 * math.exp(-0.2 * math.sqrt(0.5 * (x**2 + y**2))) - math.exp(0.5 * (math.cos(2 * math.pi * x) + math.cos(2 * math.pi * y))) + math.e + 20 def crossover(parent1, parent2, crossover_rate): if random.random() < crossover_rate: return (parent1[0], parent2[1]), (parent2[0], parent1[1]) return parent1, parent2 def mutate(individual, mutation_rate, min_x, max_x, min_y, max_y): if random.random() < mutation_rate: individual = (individual[0] + (random.random() - 0.5) * 2, individual[1]) if random.random() < mutation_rate: individual = (individual[0], individual[1] + (random.random() - 0.5) * 2) individual = (max(min_x, min(max_x, individual[0])), max(min_y, min(max_y, individual[1]))) return individual def select(population, scores, k=3): selected = random.choices(population, k=k) selected_scores = [scores[population.index(ind)] for ind in selected] return selected[selected_scores.index(min(selected_scores))] def genetic_algorithm_ackley_minimization( initial_population, population_size=50, generations=1000, crossover_rate=0.7, mutation_rate=0.001, max_x=32, min_x=-32, max_y=32, min_y=-32 ): population = initial_population[:population_size] while len(population) < population_size: population.append((random.uniform(min_x, max_x), random.uniform(min_y, max_y))) for gen in range(generations): scores = [ackley_function(ind[0], ind[1]) for ind in population] new_population = [] for _ in range(population_size // 2): parent1 = select(population, scores) parent2 = select(population, scores) offspring1, offspring2 = crossover(parent1, parent2, crossover_rate) new_population.append(mutate(offspring1, mutation_rate, min_x, max_x, min_y, max_y)) new_population.append(mutate(offspring2, mutation_rate, min_x, max_x, min_y, max_y)) population = new_population final_scores = [ackley_function(ind[0], ind[1]) for ind in population] min_index = final_scores.index(min(final_scores)) return population[min_index], final_scores[min_index]"},{"question":"# Question You are tasked with implementing a function that will reverse the words in a given sentence but leave the words themselves intact. Your function must handle multiple spaces between words and leading or trailing spaces correctly. Function Signature ```python def reverse_sentence(sentence: str) -> str: ... ``` Input - **sentence** (str): A string containing the sentence to reverse. Output - (str): A string with the words in the reversed order, including the original spacing. Constraints - The sentence can contain upper and lower case letters, spaces, and punctuation. - The sentence length will be at most 1000 characters. Performance Requirement - Implement in O(n) time complexity where n is the length of the sentence. Examples ```python >>> reverse_sentence(\\" Hello world! \\") \' world! Hello \' >>> reverse_sentence(\\"Coding assessments are important.\\") \'important. are assessments Coding\' ``` # Explanation In the first example, the function keeps the multiple spaces as they are while reversing the order of the words. In the second example, the words are simply reversed, preserving their order relative to spaces and punctuation.","solution":"def reverse_sentence(sentence: str) -> str: # Split the sentence by spaces words = sentence.split(\' \') # Reverse the list of words reversed_words = words[::-1] # Join them back together with spaces return \' \'.join(reversed_words)"},{"question":"# Problem Statement You are tasked with creating a function that calculates the frequency of each word in a given sentence and returns the words in descending order of their frequency. Implement the function `word_frequency(sentence: str) -> List[Tuple[str, int]]` that processes a sentence, calculates the frequency of each word, and returns a sorted list of tuples. # Expected Behavior The function should: 1. Normalize the sentence by converting all characters to lowercase. 2. Remove any punctuation (.,!?). 3. Split the sentence into individual words. 4. Calculate the frequency of each word. 5. Return a list of tuples, each containing a word and its frequency, sorted in descending order of frequency. In case of a tie, sort words alphabetically. # Input and Output **Input**: - `sentence`: A single non-empty string representing a sentence. **Output**: - A list of tuples where each tuple contains a word (str) and its frequency (int), sorted by frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. # Constraints - The sentence will only contain alphabetic characters, spaces, and basic punctuation (.,!?). # Example ```python from typing import List, Tuple def word_frequency(sentence: str) -> List[Tuple[str, int]]: # Write your implementation here # Example Usage sentence = \\"This is a test. This test is only a test!\\" result = word_frequency(sentence) # Expected Output: # [ # (\'test\', 3), # (\'a\', 2), # (\'is\', 2), # (\'only\', 1), # (\'this\', 2) # ] ``` Implement the function according to the specified behavior and constraints.","solution":"from typing import List, Tuple import string def word_frequency(sentence: str) -> List[Tuple[str, int]]: # Convert to lowercase sentence = sentence.lower() # Remove punctuation sentence = sentence.translate(str.maketrans(\'\', \'\', string.punctuation)) # Split into words words = sentence.split() # Calculate frequencies freq_dict = {} for word in words: if word in freq_dict: freq_dict[word] += 1 else: freq_dict[word] = 1 # Convert to list of tuples and sort freq_list = sorted(freq_dict.items(), key=lambda item: (-item[1], item[0])) return freq_list"},{"question":"# Question You are required to implement a specific function related to graph traversal. Problem Statement Given an undirected graph represented as an adjacency list, implement a function `find_greatest_connected_component` that finds the size of the largest connected component in the graph. A connected component is a set of nodes in which there is a path between any two nodes. The size of a connected component is the number of nodes in that component. Function Signature ```python def find_greatest_connected_component(graph: dict[int, list[int]]) -> int: ``` Input - `graph` (dict[int, list[int]]): An adjacency list representing the undirected graph. The keys are node identifiers (integers), and the values are lists of integers representing the nodes directly connected to the key node. Output - `int`: Return the size (number of nodes) of the largest connected component in the graph. Constraints 1. The number of nodes in the graph is in the range [0, 10^4]. 2. Each node is represented by a unique integer identifier in the range [0, 10^4 - 1]. Example ```python # Graph structure: # 0 -- 1 2 -- 3 # | | | | # 4 -- 5 6 -- 7 graph = { 0: [1, 4], 1: [0, 5], 4: [0, 5], 5: [1, 4], 2: [3, 6], 3: [2, 7], 6: [2, 7], 7: [3, 6] } print(find_greatest_connected_component(graph)) # Output: 4 (nodes: 2, 3, 6, 7) ``` Requirements - Implement the `find_greatest_connected_component` function ensuring it handles edge cases like an empty graph, a graph with a single node, and unconnected nodes. - Consider performance: the function should efficiently handle the upper limit of the constraints.","solution":"def find_greatest_connected_component(graph): def dfs(node, visited): stack = [node] size = 0 while stack: current = stack.pop() if current not in visited: visited.add(current) size += 1 stack.extend(graph.get(current, [])) return size visited = set() max_component_size = 0 for node in graph: if node not in visited: component_size = dfs(node, visited) max_component_size = max(max_component_size, component_size) return max_component_size"},{"question":"# Bank Account Management System Context A bank requires a simple management system for its accounts. Each account should keep track of the account holder\'s name, account balance, and transaction history. The system should allow for creating new accounts, depositing and withdrawing funds, and retrieving transaction histories. Objective Write a Python class to implement a bank account management system. Your implementation should include methods for creating accounts, depositing and withdrawing money, and retrieving the balance and transaction history. Core Implementation Requirements 1. Implement a class `BankAccount` with the following methods: - `__init__(self, account_holder)`: Initializes the account with the given account holder\'s name and a zero balance. - `deposit(self, amount)`: Deposits the specified amount into the account and records the transaction. Ensure the amount is positive. - `withdraw(self, amount)`: Withdraws the specified amount from the account if sufficient funds are available and records the transaction. Ensure the amount is positive. - `get_balance(self)`: Returns the current account balance. - `get_transaction_history(self)`: Returns a list of transaction records. Transaction Record Details Each transaction record should be a dictionary with the following keys: - `\\"type\\"`: Either `\\"deposit\\"` or `\\"withdraw\\"` - `\\"amount\\"`: The amount of the transaction - `\\"balance\\"`: The account balance after the transaction Example Here\'s an example to illustrate the usage: ```python if __name__ == \\"__main__\\": account = BankAccount(\\"Alice\\") # Deposit money account.deposit(100) account.deposit(50) # Withdraw money account.withdraw(30) # Retrieve balance print(account.get_balance()) # Output: 120 # Retrieve transaction history print(account.get_transaction_history()) # Output: [{\'type\': \'deposit\', \'amount\': 100, \'balance\': 100}, {\'type\': \'deposit\', \'amount\': 50, \'balance\': 150}, {\'type\': \'withdraw\', \'amount\': 30, \'balance\': 120}] ``` Your task is to complete the `BankAccount` class meeting the specified requirements.","solution":"class BankAccount: def __init__(self, account_holder): Initializes the account with the given account holder\'s name and a zero balance. self.account_holder = account_holder self.balance = 0 self.transaction_history = [] def deposit(self, amount): Deposits the specified amount into the account and records the transaction. if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount self.transaction_history.append({ \\"type\\": \\"deposit\\", \\"amount\\": amount, \\"balance\\": self.balance }) def withdraw(self, amount): Withdraws the specified amount from the account if sufficient funds are available and records the transaction. if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount self.transaction_history.append({ \\"type\\": \\"withdraw\\", \\"amount\\": amount, \\"balance\\": self.balance }) def get_balance(self): Returns the current account balance. return self.balance def get_transaction_history(self): Returns a list of transaction records. return self.transaction_history"},{"question":"# Coding Assessment Question Scenario: You are working on a text-based game where the player interacts with various NPCs (Non-Player Characters). Each NPC can have a conversation with the player where each response is predetermined based on the player\'s input. To simplify, let\'s consider the responses are stored in a dictionary where the keys are player inputs and the values are the corresponding NPC responses. Your task is to implement a function that simulates the conversation with an NPC and returns the responses in the order they were encountered based on the player\'s inputs. Problem Statement: Write a function `npc_conversation(conversation_map: dict, player_inputs: list) -> list` that simulates the NPC conversation. Input: * A dictionary `conversation_map` where keys are strings representing the player\'s inputs and values are strings representing the NPC\'s responses. * A list `player_inputs` of strings representing the sequence of inputs by the player. Output: * A list of strings representing the NPC responses in the order they were encountered based on the player\'s inputs. Constraint: * If a player\'s input is not found in `conversation_map`, the NPC should respond with `\\"I don\'t understand you.\\"` Examples: * Given the conversation map and inputs: ```python conversation_map = { \\"hello\\": \\"Hi there!\\", \\"how are you?\\": \\"I\'m just a bunch of code, but I\'m doing great!\\", \\"goodbye\\": \\"See you next time!\\" } player_inputs = [\\"hello\\", \\"how are you?\\", \\"what\'s up?\\", \\"goodbye\\"] ``` The function should output: ```python [ \\"Hi there!\\", \\"I\'m just a bunch of code, but I\'m doing great!\\", \\"I don\'t understand you.\\", \\"See you next time!\\" ] ``` * If `player_inputs` is an empty list, the function should return an empty list. Implementation Notes: Ensure that the function handles edge cases such as empty `player_inputs` list and inputs that are not present in the `conversation_map`. The function should be efficient and handle various lengths of input lists gracefully. Write your implementation below: ```python def npc_conversation(conversation_map: dict, player_inputs: list) -> list: responses = [] for input_ in player_inputs: if input_ in conversation_map: responses.append(conversation_map[input_]) else: responses.append(\\"I don\'t understand you.\\") return responses # Function call for illustration if __name__ == \\"__main__\\": conversation_map = { \\"hello\\": \\"Hi there!\\", \\"how are you?\\": \\"I\'m just a bunch of code, but I\'m doing great!\\", \\"goodbye\\": \\"See you next time!\\" } player_inputs = [\\"hello\\", \\"how are you?\\", \\"what\'s up?\\", \\"goodbye\\"] print(npc_conversation(conversation_map, player_inputs)) ```","solution":"def npc_conversation(conversation_map: dict, player_inputs: list) -> list: Simulates conversation with an NPC based on player inputs. Parameters: - conversation_map (dict): A dictionary with player inputs as keys and NPC responses as values. - player_inputs (list): A list of strings representing the sequence of inputs by the player. Returns: - list: NPC responses in the order they were encountered based on the player\'s inputs. If a player\'s input is not found in conversation_map, the NPC should respond with \\"I don\'t understand you.\\" responses = [] for input_ in player_inputs: if input_ in conversation_map: responses.append(conversation_map[input_]) else: responses.append(\\"I don\'t understand you.\\") return responses"},{"question":"# Question: Finding the Longest Uncommon Subsequence **Context**: An uncommon subsequence between two strings is a subsequence that appears in one string but not in the other. Given two strings `str1` and `str2`, we want to find the length of the longest uncommon subsequence. **Task**: Write a Python function `longest_uncommon_subsequence(str1: str, str2: str) -> int` that computes the length of the longest uncommon subsequence between `str1` and `str2`. # Input * Two strings `str1` and `str2` of length not exceeding 100. # Output * An integer representing the length of the longest uncommon subsequence. # Constraints * The strings consist of lowercase English letters `a-z`. # Example ```python # Example 1 # Given str1 = \\"abcd\\" and str2 = \\"bdef\\" # The longest uncommon subsequence is \\"abcd\\" which is of length 4. print(longest_uncommon_subsequence(\\"abcd\\", \\"bdef\\")) # Output: 4 # Example 2 # Given str1 = \\"abc\\" and str2 = \\"abc\\" # There is no uncommon subsequence as both strings are identical. print(longest_uncommon_subsequence(\\"abc\\", \\"abc\\")) # Output: -1 ``` # Implementation Details 1. If `str1` and `str2` are identical, return `-1` because no uncommon subsequence exists. 2. Otherwise, the longest uncommon subsequence would be the longer of the two input strings. 3. Return the length of the longer string. By following this logic, we are ensuring that we handle both the simplest and more complex relationships between the two input strings effectively.","solution":"def longest_uncommon_subsequence(str1: str, str2: str) -> int: Finds the length of the longest uncommon subsequence between two strings. Args: str1 : str : The first string. str2 : str : The second string. Returns: int : The length of the longest uncommon subsequence. Returns -1 if the strings are identical. if str1 == str2: return -1 else: return max(len(str1), len(str2))"},{"question":"# Problem Statement You are tasked with implementing a function called `find_peak_element` that finds a peak element in a given list of integers. A peak element is an element that is greater than its neighbors. Assume that the list has more than one element and any non-edge element in the list always has two neighbors. Function Signature ```python def find_peak_element(nums: list[int]) -> int: pass ``` # Input * **nums**: A list of integers. # Output * **Return the index of any peak element**. If there are multiple peak elements, return the index of any one of them. # Constraints * The list `nums` contains at least 2 elements and at most `10^6` elements. * All integer values in the list are within the range of `[-10^9, 10^9]`. # Examples ```python # Input nums = [1, 2, 3, 1] # Output 2 # Input nums = [1, 2, 1, 3, 5, 6, 4] # Output 5 or 1 (either peak element index is correct) # Input nums = [10, 20, 15, 2, 23, 90, 67] # Output 1 or 5 ``` # Guidelines - You should aim for an efficient solution with a time complexity of O(log n). - It\'s acceptable to use binary search to find any peak element. # Context In several computational problems, especially those related to digital signal processing or optimization behaviors within an algorithm, identifying a peak or a globally/local maximum plays a crucial role. This problem helps understand the application of binary search in finding extrema in data arrays or signals efficiently.","solution":"def find_peak_element(nums: list[int]) -> int: Finds an index of a peak element in the list. A peak element is an element that is greater than its neighbors. Arguments: nums -- a list of integers Returns: An index of any peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"# Sorting by Frequency Context: You are given a list of integers where some elements may appear more than once. Your task is to write a function that sorts this list such that the numbers that appear more frequently come first. If two numbers have the same frequency, then the smaller number should come first. This sorting should be stable. Requirements: * Write a function `sort_by_frequency(nums: list) -> list` that takes a list of integers `nums` and returns a new list sorted by the criteria described. * The function should handle invalid inputs gracefully (e.g., empty list). * Ensure that your function can handle inputs efficiently and is appropriate for large lists. Input: * A list of integers `nums`. Output: * A new list of integers sorted by their frequency in descending order. If two numbers have the same frequency, the smaller number comes first. Constraints: * Each element of `nums` can be any integer within the range `[-10^6, 10^6]`. * The length of `nums` can be up to `10^6`. Examples: ```python # Example 1 sort_by_frequency([4, 5, 6, 5, 4, 3]) # Output: [4, 4, 5, 5, 3, 6] # Example 2 sort_by_frequency([9, 9, -3, -1, -1, -1, 3]) # Output: [-1, -1, -1, 9, 9, -3, 3] # Example 3 sort_by_frequency([1]) # Output: [1] # Example 4 sort_by_frequency([]) # Output: [] # Example 5 sort_by_frequency([3, 3, 3, 2, 2, 1]) # Output: [3, 3, 3, 2, 2, 1] ``` Your function should be efficient and capable of handling inputs up to the maximum constraint effectively.","solution":"from collections import Counter def sort_by_frequency(nums: list) -> list: Sorts the list by frequency in descending order. If two numbers have the same frequency, the smaller number comes first. if not nums: return [] counts = Counter(nums) sorted_nums = sorted(nums, key=lambda x: (-counts[x], x)) return sorted_nums"},{"question":"# Task: Sort Logs Based on Priority and Timestamp Scenario You are managing a system that generates logs with various priorities. Your task is to write a function that sorts these logs based on their priority levels and timestamps. Logs with the same priority should be ordered by their timestamps. Requirements 1. **Function Implementation**: Implement the function `sort_logs(logs: List[Tuple[int, str]]) -> List[Tuple[int, str]]` - **Input**: A list of logs, each represented as a tuple (priority, timestamp), where `priority` is an integer (with 1 being the highest priority and larger numbers indicating lower priority) and `timestamp` is a string in the format \\"YYYY-MM-DD HH:MM:SS\\". - **Output**: A list of logs sorted first by priority in ascending order, and then by timestamp in ascending order for logs with the same priority. 2. **Constraints**: - The priority value is between 1 and 10, inclusive. - The timestamp follows the format \\"YYYY-MM-DD HH:MM:SS\\". - There could be duplicate logs with the same priority and timestamp. 3. **Performance Requirements**: - The function should handle at least 10,000 logs efficiently. - Consider using stable sorting algorithms to maintain the order of logs with the same priority and timestamp. Example Usage ```python logs = [ (3, \\"2023-10-01 13:45:00\\"), (1, \\"2023-10-01 09:00:00\\"), (2, \\"2023-10-01 12:00:00\\"), (1, \\"2023-10-01 08:00:00\\"), (2, \\"2023-10-02 15:00:00\\") ] sorted_logs = sort_logs(logs) for log in sorted_logs: print(log) ``` Expected Output ```python (1, \\"2023-10-01 08:00:00\\") (1, \\"2023-10-01 09:00:00\\") (2, \\"2023-10-01 12:00:00\\") (2, \\"2023-10-02 15:00:00\\") (3, \\"2023-10-01 13:45:00\\") ``` # Additional Considerations - Ensure your implementation is efficient and correctly handles the sorting based on the requirements. - Test your function with various log sets to cover different scenarios including logs with the same priority and identical timestamps.","solution":"from typing import List, Tuple def sort_logs(logs: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sorts logs based on their priority and timestamp. Logs with the same priority are sorted by their timestamp in ascending order. :param logs: List of logs, each represented as a tuple (priority, timestamp) :return: List of sorted logs return sorted(logs, key=lambda x: (x[0], x[1]))"},{"question":"# Movie Recommendation System using Matrix Factorization Design a movie recommendation system using matrix factorization. You are given a dataset containing user ratings for various movies, and your task is to predict the missing ratings and recommend movies based on the predicted ratings. **Input**: - A `user_movie_matrix` list of lists, where each inner list contains user ratings for movies (with some ratings missing, represented by -1). - Two integers `num_factors` and `num_iterations` representing the number of latent factors and the number of iterations for the matrix factorization algorithm. - Two floating-point numbers `learning_rate` and `regularization` representing the learning rate and regularization strength for the algorithm. **Output**: - A `predicted_ratings` list of lists, where each inner list contains the predicted ratings for the corresponding user\'s movies. **Function Signature**: ```python def matrix_factorization(user_movie_matrix: list[list[float]], num_factors: int, num_iterations: int, learning_rate: float, regularization: float) -> list[list[float]]: # Function implementation ``` **Constraints**: - All ratings are floats. - The number of users and movies will be at most 1000. - `num_factors` will be a positive integer less than or equal to 50. - `num_iterations` will be a positive integer less than or equal to 1000. - `learning_rate` and `regularization` will be positive floats. **Example**: ```python # User-Movie Matrix (with -1 representing missing ratings) user_movie_matrix = [ [5, 3, -1, 1], [4, -1, 2, 1], [1, 1, -1, 5], [1, -1, 4, 4], [3, 3, 4, 5] ] # Parameters num_factors = 2 num_iterations = 5000 learning_rate = 0.01 regularization = 0.02 # Expected Output # Predicted ratings for the input matrix predicted_ratings = [ [5.00, 3.00, 3.12, 1.00], [4.00, 2.32, 2.00, 1.00], [1.00, 1.00, 3.44, 5.00], [1.00, 2.86, 4.00, 4.00], [3.00, 3.00, 4.00, 5.00] ] print(matrix_factorization(user_movie_matrix, num_factors, num_iterations, learning_rate, regularization)) # Output: [ # [5.00, 3.00, 3.12, 1.00], # [4.00, 2.32, 2.00, 1.00], # [1.00, 1.00, 3.44, 5.00], # [1.00, 2.86, 4.00, 4.00], # [3.00, 3.00, 4.00, 5.00] # ] ``` Ensure to incorporate strategies for optimizing the prediction accuracy and handle edge cases appropriately during the matrix factorization process.","solution":"import numpy as np def matrix_factorization(user_movie_matrix, num_factors, num_iterations, learning_rate, regularization): R = np.array(user_movie_matrix) num_users, num_items = R.shape # Initialize user and item latent factor matrices randomly P = np.random.rand(num_users, num_factors) Q = np.random.rand(num_items, num_factors) # Transpose Q for easier calculations Q = Q.T # Perform Gradient Descent for Matrix Factorization for iteration in range(num_iterations): for i in range(num_users): for j in range(num_items): if R[i][j] > 0: # Only consider existing ratings # Calculate the error of the element error_ij = R[i][j] - np.dot(P[i, :], Q[:, j]) # Update the latent factors for k in range(num_factors): P[i][k] += learning_rate * (2 * error_ij * Q[k][j] - regularization * P[i][k]) Q[k][j] += learning_rate * (2 * error_ij * P[i][k] - regularization * Q[k][j]) if iteration % 100 == 0: # Optional: Print loss every 100 iterations for monitoring error = 0 for i in range(num_users): for j in range(num_items): if R[i][j] > 0: error += (R[i][j] - np.dot(P[i, :], Q[:, j])) ** 2 for k in range(num_factors): error += (regularization / 2) * (P[i][k] ** 2 + Q[k][j] ** 2) print(f\'Iteration: {iteration}, error: {error}\') # Calculate the full predicted rating matrix predicted_ratings = np.dot(P, Q) # Replace the -1 values in user_movie_matrix with their corresponding predictions for i in range(num_users): for j in range(num_items): if user_movie_matrix[i][j] == -1: user_movie_matrix[i][j] = predicted_ratings[i][j] return user_movie_matrix"},{"question":"# Coding Assessment Question Problem Statement Write a function `evaluate_expression(expression: str) -> float` that evaluates a simple mathematical expression passed as a string. The expression will only contain non-negative integers, the operators `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), and parentheses `(` `)`. Requirements 1. The function should support operator precedence and handle nested parentheses properly. 2. Division should be treated as true division (floating-point division). 3. The function should handle invalid inputs gracefully and return `None` for the following cases: * Empty string. * Invalid characters apart from the operators and digits. * Mismatched parentheses. Input * A string `expression` representing the mathematical expression. Output * Return the evaluated result as a float if the expression is valid. * Return `None` if the input expression is invalid. Constraints * The length of the input string will not exceed 1000 characters. Example ```python >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"10 / 2 - 1\\") 4.0 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20.0 >>> evaluate_expression(\\"10 + 2 / (5 - 3)\\") 11.0 >>> evaluate_expression(\\"3 + (2 * (4 - 1))\\") 9.0 >>> evaluate_expression(\\"10 + a - 3\\") None >>> evaluate_expression(\\"10 + 5) - 3\\") None >>> evaluate_expression(\\"\\") None ``` Additional Notes * Use appropriate methods to ensure operator precedence and proper handling of parentheses. * Implement error-checking to handle invalid expressions effectively.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a simple mathematical expression passed as a string. The expression will contain non-negative integers, +, -, *, /, and parentheses ( ). Returns the evaluated result as a float if the expression is valid. Returns None if the input expression is invalid. # Check for empty string if not expression: return None # Check for invalid characters if not expression.replace(\' \', \'\').replace(\'+\', \'\').replace(\'-\', \'\').replace(\'*\', \'\').replace(\'/\', \'\').replace(\'(\', \'\').replace(\')\', \'\').isdigit(): return None # Check for mismatched parentheses open_parens = 0 for char in expression: if char == \'(\': open_parens += 1 elif char == \')\': open_parens -= 1 if open_parens < 0: return None if open_parens != 0: return None try: # Evaluate the expression result = eval(expression) return float(result) except Exception as e: # If an error occurs during evaluation return None"},{"question":"# Analyzing Social Media Engagement with Linear Regression You are asked to analyze the relationship between social media posts\' characteristics and their engagement level. You will use linear regression to model the engagement based on features such as the length of the post, the number of hashtags, and the time of posting. Instructions 1. Implement a function `analyze_engagement` that takes training data `features_train` and `engagement_train`, and test data `features_test` with actual engagement values `engagement_test`. This function should: * Fit a linear regression model using the training data. * Predict engagement for the test data. * Calculate and return the mean absolute error (MAE) between the predicted and actual engagement for the test set. 2. Test your implementation with a synthetic dataset. Include at least two different feature sets: (e.g., basic features [length and number of hashtags], and extended features [length, number of hashtags, time of posting, and sentiment score]). Compare their performance based on MAE. Plot the test data and predictions for visual analysis. Expected Input and Output * **Input**: * `features_train`: Training data with predictor values (list of numpy arrays where each array represents a feature). * `engagement_train`: Response values for the training data (numpy array). * `features_test`: Test data for evaluation (list of numpy arrays where each array represents a feature). * `engagement_test`: Actual engagement values for the test data (numpy array). * **Output**: * The function returns a single float value representing the mean absolute error (MAE) for the test data predictions. Performance Requirements * Ensure your function works within time constraints for typical datasets involving up to 1,000 data points with 4 features. Example ```python # Example usage of analyze_engagement function import numpy as np from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error def analyze_engagement(features_train, engagement_train, features_test, engagement_test): model = LinearRegression() model.fit(features_train, engagement_train) predictions = model.predict(features_test) mae = mean_absolute_error(engagement_test, predictions) return mae # Synthetic dataset creation # Features: [length of post, number of hashtags, time of posting, sentiment score] features_train = np.array([ [100, 3, 14, 0.8], [200, 5, 9, 0.2], # ... (more training data) ]) engagement_train = np.array([150, 200, # ... (corresponding engagement values)]) features_test = np.array([ [120, 2, 15, 0.5], [250, 1, 8, -0.3], # ... (more test data) ]) engagement_test = np.array([160, 220, # ... (corresponding engagement values)]) mae = analyze_engagement(features_train, engagement_train, features_test, engagement_test) print(f\\"Mean Absolute Error: {mae}\\") # For visual analysis import matplotlib.pyplot as plt plt.scatter(engagement_test, model.predict(features_test), label=\\"Predicted vs Actual\\") plt.xlabel(\\"Actual Engagement\\") plt.ylabel(\\"Predicted Engagement\\") plt.legend() plt.show() ``` You are expected to write your own `analyze_engagement` function and demonstrate its use with a synthetic dataset. Compare the performance of basic and extended feature sets.","solution":"import numpy as np from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error def analyze_engagement(features_train, engagement_train, features_test, engagement_test): Fit a linear regression model using the training data and predict engagement for the test data. Calculate and return the mean absolute error (MAE) between the predicted and actual engagement. # Fit linear regression model model = LinearRegression() model.fit(features_train, engagement_train) # Predict engagement for test data predictions = model.predict(features_test) # Calculate and return the mean absolute error mae = mean_absolute_error(engagement_test, predictions) return mae"},{"question":"# Question: Rotate Matrix by 90 Degrees Clockwise Context: You are given an `n x n` matrix of integers. Your task is to rotate the matrix by 90 degrees clockwise. The rotation should be done in-place, meaning you should not use any extra space for another matrix. Requirements: 1. Implement a function `rotate_matrix(matrix: list[list[int]]) -> None` that rotates the given `n x n` matrix by 90 degrees clockwise in-place. 2. The function should raise a `ValueError` if the input matrix is not a square matrix (i.e., `n x n`). Input: - `matrix`: A list of lists of integers representing an `n x n` matrix. Example: ```python [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: - The function should modify the matrix in-place and not return anything. Constraints: - The size of the matrix will not exceed `100 x 100`. - The integers in the matrix can be both positive and negative. - The input matrix is guaranteed to be a valid matrix with integer elements. Performance Requirements: - Time complexity should be O(n^2). - Space complexity should be O(1). Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # matrix should be modified to: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Scenario: Consider you are implementing a photo editing software that allows users to rotate their images. Each image can be represented as a matrix of pixel values. Using this function, you can efficiently rotate the image without consuming additional memory. Write your implementation in Python and make sure to handle edge cases as outlined.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. Arguments: matrix -- list of lists of integers representing an n x n matrix if not matrix or len(matrix) != len(matrix[0]): raise ValueError(\\"Input matrix must be square (n x n).\\") n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Design a Simple Cache with Time-Based Expiry You are required to implement a basic caching mechanism that supports time-based expiry. The cache should allow storing key-value pairs with an optional expiration time. When the expiration time is reached, the cache should automatically remove the expired entries. **Function Signatures:** ```python class SimpleCache: def __init__(self): # constructor code here def set(self, key: str, value: Any, expiry: Optional[int] = None) -> None: # your code here def get(self, key: str) -> Optional[Any]: # your code here def delete(self, key: str) -> None: # your code here def cleanup(self) -> None: # your code here ``` # Input Format - `set(key: str, value: Any, expiry: Optional[int] = None)`: Store the `key-value` pair in the cache. The `expiry` parameter, if provided, is the number of seconds after which the entry should expire. - `get(key: str)` : Retrieve the value associated with `key`. Return `None` if the key does not exist or has expired. - `delete(key: str)`: Remove the specified key from the cache. - `cleanup()`: This method is responsible for cleaning up expired entries. # Output Format - The `get` function should return the value associated with a key if it exists and has not expired, otherwise `None`. - The `cleanup` function does not return any value but ensures that all expired entries are removed from the cache. # Constraints - Efficient handling of key-value retrieval even with frequent expiry checks. - Assume that the cache will be operated in a multi-threaded environment, so syncing data access is not required. - The `expiry` parameter is in seconds if provided, else the entry does not expire. **Implementation Note:** Use any standard library or data structure that you consider suitable for implementing this cache. The focus is on correctness and efficiency. # Example ```python import time cache = SimpleCache() cache.set(\'a\', 1, 2) # set key \'a\' with value 1, expiry in 2 seconds assert cache.get(\'a\') == 1 # should return 1 time.sleep(3) cache.cleanup() # should remove expired keys assert cache.get(\'a\') is None # should return None since \'a\' has expired cache.set(\'b\', 2) # set key \'b\' with no expiry assert cache.get(\'b\') == 2 # should return 2 cache.delete(\'b\') assert cache.get(\'b\') is None # should return None since \'b\' is deleted ``` # Notes - Ensure that the `cleanup` method correctly handles the removal of expired entries. - The deletion and setting of keys must update the internal state of the cache correctly without causing race conditions or data inconsistency.","solution":"import time from typing import Any, Optional class SimpleCache: def __init__(self): self.cache = {} def set(self, key: str, value: Any, expiry: Optional[int] = None) -> None: expiry_time = time.time() + expiry if expiry else None self.cache[key] = (value, expiry_time) def get(self, key: str) -> Optional[Any]: if key not in self.cache: return None value, expiry_time = self.cache[key] if expiry_time and time.time() > expiry_time: del self.cache[key] return None return value def delete(self, key: str) -> None: if key in self.cache: del self.cache[key] def cleanup(self) -> None: current_time = time.time() keys_to_delete = [key for key, (_, expiry) in self.cache.items() if expiry and current_time > expiry] for key in keys_to_delete: del self.cache[key]"},{"question":"# Task To enhance your proficiency in working with sorting algorithms and demonstrate your understanding of priority queues, you are required to implement a function that finds the k-th largest element in an unsorted list. # Function Signature ```python def kth_largest(nums: List[int], k: int) -> int: Find the k-th largest element in the provided list. :param nums: A list of integers. :param k: An integer representing the k-th largest element to find. :return: The k-th largest element in the list. ``` # Description - **Input**: A list of integers `nums` and an integer `k`. - **Output**: Return the k-th largest element in the list. # Constraints - `1 <= len(nums) <= 10000` - `-10^5 <= nums[i] <= 10^5` - `1 <= k <= len(nums)` # Example ```python assert kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 # The 2nd largest element is 5 assert kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 # The 4th largest element is 4 assert kth_largest([1, 1, 1, 1, 1], 1) == 1 # The 1st largest element is 1 assert kth_largest([7, 10, 4, 3, 20, 15], 3) == 10 # The 3rd largest element is 10 ``` # Guideline 1. **Sorting Method**: An efficient way to find k-th largest element is to sort the list and then access the element at the appropriate position. 2. **Heap Implementation**: Alternatively, consider using a min-heap of size k to keep track of the k largest elements seen so far. 3. **Edge Cases**: Handle lists with duplicate elements and varying sizes to ensure comprehensive coverage. # Note Optimize for both time and space complexity to handle larger lists effectively.","solution":"def kth_largest(nums: list[int], k: int) -> int: Find the k-th largest element in the provided list. :param nums: A list of integers. :param k: An integer representing the k-th largest element to find. :return: The k-th largest element in the list. nums.sort(reverse=True) return nums[k-1]"},{"question":"# Problem Statement You are given a rectangular matrix of integers, where each row is sorted in ascending order. Implement a function that finds the number of distinct elements in the entire matrix. # Function Signature ```python def count_distinct_elements(matrix: list[list[int]]) -> int: pass ``` # Input - `matrix`: a list of lists of integers, where each sub-list represents a row of the matrix. Each row is sorted in ascending order. # Output - Returns an integer representing the number of distinct elements in the entire matrix. # Constraints - The number of rows in the matrix (`m`) will be between 1 and 100 inclusive. - The number of columns in the matrix (`n`) will be between 1 and 100 inclusive. - Each element in the matrix will be between `-10^4` and `10^4`. # Example ```python matrix = [ [1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12] ] print(count_distinct_elements(matrix)) # Expected Output: 8 ``` # Notes - Consider using a data structure that efficiently handles uniqueness, such as a set. - Focus on optimizing both time and space complexity given the constraints. - Ensure thorough testing with varying matrix sizes and value ranges, including edge cases where all elements are the same or all are different. # Guidelines - Iterate through the matrix efficiently without redundant checks. - Validate edge cases where the matrix might be empty or contain repeating rows.","solution":"def count_distinct_elements(matrix: list[list[int]]) -> int: Returns the number of unique elements in the given matrix. :param matrix: A list of lists of integers, where each sub-list represents a row of the matrix. :return: An integer representing the number of distinct elements in the entire matrix. distinct_elements = set() for row in matrix: for element in row: distinct_elements.add(element) return len(distinct_elements)"},{"question":"# Sorting and Searching Algorithm Challenge **Context**: You are tasked with implementing an efficient function for finding the `k`th smallest element in an unsorted list of integers. The function should make use of an efficient algorithm to accomplish this task. # Function Implementation Implement a function named `find_kth_smallest` that accepts two parameters: 1. `nums` (List[int]): A list of integers. 2. `k` (int): The position (1-based) of the smallest element to find. The function should perform the following: 1. Validate the inputs to ensure `nums` is not empty and `k` is a valid positive integer within the bounds of the list length. 2. Use an efficient algorithm (such as Quickselect) to find and return the `k`th smallest element in the list. 3. Aim to achieve an average time complexity of (O(n)). **Specifications**: - If `nums` is empty or `k` is out of bounds, return `None`. - Do not use built-in sorting functions (`sort`, `sorted`, etc.) to directly find the result. - Ensure efficient handling of large datasets. # Example ```python def find_kth_smallest(nums: list[int], k: int) -> int | None: # Your implementation here # Example Usage result = find_kth_smallest([3, 2, 1, 5, 4], 3) print(result) # Output should be 3 ``` **Test Cases**: 1. `find_kth_smallest([], 1)` should return `None` 2. `find_kth_smallest([5, 2, 9, 1, 5, 6], 2)` should return `2` 3. `find_kth_smallest([7, 10, 4, 3, 20, 15], 4)` should return `10` 4. `find_kth_smallest([7, 10, 4, 3, 20, 15], 7)` should return `None` **Notes**: - This problem requires understanding and implementing the Quickselect algorithm or a similar efficient selection algorithm. - Be mindful of edge cases where `k` is less than 1 or greater than the length of the list. - Ensure to handle cases where elements in the list are not unique.","solution":"def find_kth_smallest(nums, k): Returns the kth smallest element in the list nums using Quickselect algorithm. Args: nums (List[int]): List of integers. k (int): The position (1-based) of the smallest element to find. Returns: int | None: The kth smallest element or None if inputs are invalid. if not nums or k < 1 or k > len(nums): return None def quickselect(left, right, k_smallest): Helper function for Quickselect algorithm if left == right: return nums[left] pivot_index = partition(left, right) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) def partition(left, right): Helper function for partitioning the array. pivot = nums[right] store_index = left for i in range(left, right): if nums[i] < pivot: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[store_index], nums[right] = nums[right], nums[store_index] return store_index return quickselect(0, len(nums) - 1, k - 1)"},{"question":"# Scenario: You are building an e-commerce application where users can apply discount coupons to their shopping cart. Each coupon has a minimum purchase requirement that must be met before the discount is applied. Given a list of items in the cart and their respective prices, determine the maximum discount that can be applied based on the available coupons. # Problem Description: Implement the function `max_discount_for_cart(prices: List[int], coupons: List[Tuple[int, int]])` which determines the highest possible discount that can be applied to the total cart value. # Function Signature: ```python def max_discount_for_cart(prices: List[int], coupons: List[Tuple[int, int]]) -> int: ``` # Input: 1. `prices` (List[int]): A list of integers where each integer represents the price of an item in the cart. 2. `coupons` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the first representing the minimum purchase requirement and the second representing the discount amount. # Output: - Returns an integer value representing the maximum discount that can be applied to the cart. # Constraints: - 1 <= len(prices) <= 100 - 1 <= len(coupons) <= 100 - 0 <= prices[i] <= 1000 - 0 <= coupons[j][0], coupons[j][1] <= 1000 # Requirements: 1. Implement an efficient solution to find the best applicable discount. 2. Ensure that the function correctly handles edge cases such as empty cart or no applicable coupons. # Example: ```python from typing import List, Tuple def max_discount_for_cart(prices: List[int], coupons: List[Tuple[int, int]]) -> int: total_price = sum(prices) max_discount = 0 for min_purchase, discount in coupons: if total_price >= min_purchase: max_discount = max(max_discount, discount) return max_discount # Example usage: prices = [200, 150, 100] coupons = [(300, 50), (450, 100)] assert max_discount_for_cart(prices, coupons) == 100 ``` Use the provided unit test to verify your implementation.","solution":"from typing import List, Tuple def max_discount_for_cart(prices: List[int], coupons: List[Tuple[int, int]]) -> int: Calculate the maximum discount that can be applied to the total cart value based on given coupons. Parameters: prices (List[int]): List of integers representing item prices. coupons (List[Tuple[int, int]]): List of tuples where each tuple contains two integers: (minimum purchase amount, discount amount). Returns: int: The maximum discount that can be applied. total_price = sum(prices) max_discount = 0 for min_purchase, discount in coupons: if total_price >= min_purchase: max_discount = max(max_discount, discount) return max_discount"},{"question":"# Coding Assessment Question **Context:** Pathfinding algorithms often require evaluating the best route through a given grid while adhering to certain constraints. In this problem, you are tasked with finding the number of distinct paths on a grid, given specific movement restrictions. **Problem Statement:** Write a function `unique_paths_with_restriction(m: int, n: int, restrictions: List[Tuple[int, int]]) -> int` that calculates the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of an `m x n` grid. Movements are restricted to right or down directions. Additionally, certain cells contain obstacles that cannot be part of the path. The list `restrictions` contains tuples representing the coordinates of these restricted cells. **Input:** - An integer `m` representing the number of rows in the grid. - An integer `n` representing the number of columns in the grid. - A list of tuples `restrictions` where each tuple contains two integers representing the coordinates `(i, j)` of cells that are restricted. **Output:** - An integer representing the number of distinct paths from the top-left corner to the bottom-right corner, avoiding restricted cells. **Constraints:** - `1 <= m, n <= 100`. - The list `restrictions` will contain valid grid coordinates (i.e., `0 <= i < m` and `0 <= j < n`). - The number of restrictions will not exceed `max(1, m*n // 4)`. # Function Signature ```python def unique_paths_with_restriction(m: int, n: int, restrictions: List[Tuple[int, int]]) -> int: pass ``` # Examples ```python # Example 1: print(unique_paths_with_restriction(3, 3, [(1, 1)])) # Output: 2 # Example 2: print(unique_paths_with_restriction(3, 3, [(1, 1), (1, 2)])) # Output: 1 # Example 3: print(unique_paths_with_restriction(3, 3, [])) # Output: 6 ```","solution":"from typing import List, Tuple def unique_paths_with_restriction(m: int, n: int, restrictions: List[Tuple[int, int]]) -> int: # Initialize the grid with zeros grid = [[0 for _ in range(n)] for _ in range(m)] # Set restriction cells to -1 for (i, j) in restrictions: grid[i][j] = -1 # If the start or end cell is restricted, return 0 if grid[0][0] == -1 or grid[m-1][n-1] == -1: return 0 # Number of ways to reach the starting point is 1 grid[0][0] = 1 # Fill the grid with the number of paths to each cell for i in range(m): for j in range(n): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] # The bottom-right corner will contain the number of unique paths return grid[m-1][n-1]"},{"question":"# Compress Consecutive Characters Objective You will implement a function `compress_sequence` that compresses a sequence of consecutive characters in a string by replacing them with the character followed by the number of consecutive occurrences. Function Signature ```python def compress_sequence(s: str) -> str: ``` Input * A single string `s` containing only lowercase alphabetical characters. Output * A string where consecutive identical characters are compressed into the format `<character><count>`. For example, for the string `aaabb`, the output will be `a3b2`. Constraints * The input string `s` will contain 0 to 1000 characters. * The input string will only contain lowercase alphabetical characters. Performance Requirements * Your solution should handle the input efficiently within linear time complexity, O(n), where n is the length of the input string. Implementation Guidelines * Traverse the string and keep track of the current character and its consecutive occurrences. * Once a different character is encountered, append the current character and its count to the result string and reset the count. * Handle edge cases such as an empty string and strings with no consecutive characters. Example ```python assert compress_sequence(\\"aaabbccdddde\\") == \'a3b2c2d4e1\' assert compress_sequence(\\"abc\\") == \'a1b1c1\' assert compress_sequence(\\"a\\") == \'a1\' assert compress_sequence(\\"zzzzz\\") == \'z5\' assert compress_sequence(\\"\\") == \'\' assert compress_sequence(\\"abcdefghijklmnopqrstuvwxzy\\") == \'a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1\' ```","solution":"def compress_sequence(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 # Add the last sequence compressed.append(s[-1] + str(count)) return \'\'.join(compressed)"},{"question":"# Problem Statement: You are provided with a list of integers and your task is to find the maximum possible difference between any two elements in the list, but with a constraint: the smaller element must appear before the larger element in the list. Implement both a linear-time algorithm and a naive quadratic-time algorithm to solve this problem. Each solution should be encapsulated in a function with the following specifications: Functions Specifications: 1. **Using Linear-Time Algorithm** ```python def max_difference_linear(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a linear-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. ``` 2. **Using Naive Quadratic-Time Algorithm** ```python def max_difference_naive(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a naive quadratic-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. ``` Example: ```python >>> max_difference_linear([2, 3, 10, 2, 4, 8, 1]) 8 >>> max_difference_naive([2, 3, 10, 2, 4, 8, 1]) 8 >>> max_difference_linear([7, 9, 5, 6, 3, 2]) 2 >>> max_difference_naive([7, 9, 5, 6, 3, 2]) 2 >>> max_difference_linear([1]) Traceback (most recent call last): ... ValueError: the list must have at least 2 elements >>> max_difference_naive([1]) Traceback (most recent call last): ... ValueError: the list must have at least 2 elements ``` Constraints: * The input list will contain at least two integers, and the elements are within the range of typical 32-bit signed integers. * Performance is crucial for large lists, so ensure your linear-time solution is optimized for efficiency. * Your functions should raise a `ValueError` if the list contains fewer than two elements. # Requirements: * Carefully handle edge cases, such as lists with fewer than two elements. * Benchmark and compare the performance of both functions using large lists, and include your findings in your submission.","solution":"def max_difference_linear(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a linear-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. if len(arr) < 2: raise ValueError(\\"the list must have at least 2 elements\\") min_element = arr[0] max_diff = arr[1] - arr[0] for i in range(1, len(arr)): if arr[i] - min_element > max_diff: max_diff = arr[i] - min_element if arr[i] < min_element: min_element = arr[i] return max_diff def max_difference_naive(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a naive quadratic-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. if len(arr) < 2: raise ValueError(\\"the list must have at least 2 elements\\") max_diff = float(\'-inf\') n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[j] - arr[i] > max_diff: max_diff = arr[j] - arr[i] return max_diff"},{"question":"# Coding Assessment Question Objective Write a function to parse a given string containing arithmetic expressions in postfix notation (Reverse Polish Notation) and evaluate the result. Function Signature ```python def evaluate_postfix(expression: str) -> int: pass ``` Input * `expression`: A string representing an arithmetic expression in postfix notation. The expression contains integers and the operators `+`, `-`, `*`, and `/`, separated by spaces. Output * An integer representing the evaluation result of the postfix expression. Example ```python # Given the following expressions: expression = \\"3 4 + 2 * 7 /\\" result = evaluate_postfix(expression) ``` Should return: ``` 2 # Explanation: (3 + 4) * 2 / 7 = 14 / 7 = 2 ``` ```python expression = \\"10 2 8 * + 3 -\\" result = evaluate_postfix(expression) ``` Should return: ``` 23 # Explanation: 10 + (2 * 8) - 3 = 23 ``` Constraints * The input expression is guaranteed to be valid and integers are non-negative. * The division operation should be an integer division, discarding any remainder. * Assume the result of expression fits within the integer range. Implementation Notes 1. Use a stack to keep track of the intermediate results while parsing the expression. 2. Traverse the string, pushing operands onto the stack. 3. When encountering an operator, pop the necessary operands from the stack, perform the operation, and push the result back onto the stack. 4. At the end of the traversal, the stack should have exactly one element which is the result of the expression. Additional Considerations Students should be cautious of division by zero and other potential pitfalls in arithmetic calculations.","solution":"def evaluate_postfix(expression: str) -> int: Evaluates a given postfix expression. Args: expression (str): A string representing an arithmetic expression in postfix notation. Returns: int: The result of evaluating the postfix expression. stack = [] # Split the expression into tokens tokens = expression.split() # Define the operators and their corresponding lambda functions operators = { \'+\': lambda a, b: a + b, \'-\': lambda a, b: a - b, \'*\': lambda a, b: a * b, \'/\': lambda a, b: a // b # Integer division } for token in tokens: if token in operators: # Pop the last two operands from the stack b = stack.pop() a = stack.pop() # Calculate the result using the corresponding operator result = operators[token](a, b) # Push the result back onto the stack stack.append(result) else: # Push the operand onto the stack stack.append(int(token)) # There should be exactly one element in the stack, which is the result return stack[0]"},{"question":"# Question: String Compression You have been assigned the task to implement a function that performs basic string compression. The function takes a string and compresses it by counting consecutive repeating characters. If the compressed string is not smaller than the original string, the function should return the original string. # Function Signature ```python def compress_string(s: str) -> str: pass ``` # Input * `s`: A string of length `n` (1 ≤ `n` ≤ 1000) consisting of only lowercase English letters. # Output * Return the compressed version of the string or the original string if compression does not produce a shorter result. # Constraints * The string will consist of only lowercase alphabets. * You need to count each consecutive group of the same character and express this count in the compressed form. # Example Example 1 ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" ``` Example 2 ```python assert compress_string(\\"abcdef\\") == \\"abcdef\\" ``` Example 3 ```python assert compress_string(\\"a\\") == \\"a\\" ```","solution":"def compress_string(s: str) -> str: if not s: return s # Return empty string if input is empty compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \\"\\".join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"Optimal Route Planning for Delivery Drones You have been contracted to develop functionality for a delivery service utilizing drones to deliver packages within a city. The function should determine the shortest delivery route from the warehouse (starting point) to multiple delivery destinations and back to the warehouse. # Task Implement the function `calculate_optimal_route(start: tuple, destinations: list) -> list`. This function should find the shortest route using the nearest neighbor algorithm and return to the starting point after visiting all destinations. # Requirements: 1. **Function Signature**: ```python def calculate_optimal_route(start: tuple, destinations: list) -> list: ``` 2. **Input**: - `start (tuple)`: Coordinates of the starting location in the form of a tuple (latitude, longitude), e.g., (34.0522, -118.2437). - `destinations (list)`: A list of tuples, where each tuple represents the coordinates of a delivery destination. 3. **Output**: - A list of tuples representing the coordinates of the warehouse and destinations in the order they should be visited to minimize the travel distance, starting and ending at the warehouse. ```python example_output = [ (34.0522, -118.2437), # Starting point (34.0522, -118.2537), (34.0322, -118.2437), (34.0422, -118.2137), (34.0522, -118.2437) # Ending back at the starting point ] ``` 4. **Constraints and Optimizations**: - Calculate the distance between points using the Euclidean distance formula. - The total number of destinations will not exceed 10. - Ensure the function efficiently handles the combination and calculation of multiple points. # Additional Points to Consider: - Ensure the solution efficiently finds a near-optimal solution using the nearest neighbor heuristic. - Avoid excessive computational complexity for larger sets of coordinates by optimizing the distance calculations. # Example Usage: ```python start = (34.0522, -118.2437) destinations = [ (34.0522, -118.2537), (34.0322, -118.2437), (34.0422, -118.2137) ] result = calculate_optimal_route(start, destinations) print(result) ``` # Evaluation Criteria: - Correctness: Ensure the function accurately finds a short route satisfying all requirements. - Performance: Efficiently handles computations within reasonable time limits for the given constraints. - Code Quality: Maintainable, readable code with appropriate comments and documentation.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points in 2D space. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def calculate_optimal_route(start, destinations): Determine the optimal delivery route starting and ending at the warehouse. Parameters: start (tuple): Coordinates of the starting location (latitude, longitude). destinations (list): List of tuples representing the coordinates of the delivery destinations. Returns: list: List of coordinates representing the optimal delivery route. if not destinations: return [start, start] # Create a copy of the destinations to manipulate remaining_destinations = destinations.copy() # Start the route with the starting point route = [start] current_location = start while remaining_destinations: # Find the nearest neighbor nearest_neighbor = min(remaining_destinations, key=lambda x: euclidean_distance(current_location, x)) route.append(nearest_neighbor) current_location = nearest_neighbor remaining_destinations.remove(nearest_neighbor) # Return to the starting point route.append(start) return route"},{"question":"# Question: Booking System Overlapping Time Slots You are developing a simple booking system for a meeting room. The system currently stores a list of existing bookings, each represented by a start and end time. Your task is to implement a function in Python that checks if a new booking overlaps with any of the existing bookings. Function Signature ```python def is_booking_compatible(existing_bookings: list, new_booking: tuple) -> bool: Checks if the new booking overlaps with any existing bookings. :param existing_bookings: A list of tuples where each tuple contains two strings representing start and end times in the format \'HH:MM\'. :param new_booking: A tuple containing two strings representing the start and end times of the new booking. :return: A boolean indicating whether the new booking is compatible (True) or overlaps (False) with any existing bookings. pass ``` # Requirements 1. **Input**: - A list of tuples `existing_bookings` where each tuple contains two strings in \'HH:MM\' format representing the start and end times of an existing booking. - A tuple `new_booking` containing two strings in \'HH:MM\' format representing the start and end times of the new booking. 2. **Output**: - A boolean value indicating whether the new booking does not overlap with any of the existing bookings (True) or does overlap (False). 3. **Errors**: - Assume that all times are in a 24-hour format and valid. # Constraints - The start time is always less than the end time for all bookings. - Bookings and times are within a single day (00:00 to 23:59). - Consider bookings as inclusive of start time and exclusive of end time. # Example ```python # Example existing_bookings = [(\'09:00\', \'10:30\'), (\'12:00\', \'13:00\'), (\'16:00\', \'18:00\')] new_booking = (\'10:30\', \'11:30\') is_compatible = is_booking_compatible(existing_bookings, new_booking) print(is_compatible) # Output: True new_booking = (\'10:00\', \'11:00\') is_compatible = is_booking_compatible(existing_bookings, new_booking) print(is_compatible) # Output: False ``","solution":"def is_booking_compatible(existing_bookings: list, new_booking: tuple) -> bool: Checks if the new booking overlaps with any existing bookings. :param existing_bookings: A list of tuples where each tuple contains two strings representing start and end times in the format \'HH:MM\'. :param new_booking: A tuple containing two strings representing the start and end times of the new booking. :return: A boolean indicating whether the new booking is compatible (True) or overlaps (False) with any existing bookings. new_start, new_end = new_booking for booking in existing_bookings: existing_start, existing_end = booking # Check for overlap if not (new_end <= existing_start or new_start >= existing_end): return False return True"},{"question":"# Question: Implement a Book Search Function In this exercise, you are to implement a Python function that queries an online book database and returns a list of books matching a given search term and author. Function Signature ```python def search_books(query: str, author: str) -> list: ``` Input * A string `query` representing the search term for the book title. This term could be partial or full. * A string `author` representing the author\'s name. If an empty string is provided, the author\'s name will not be used in the search criteria. Output * A list of dictionaries, each representing a book. Each dictionary should contain the following keys: * `title`: The title of the book. * `author`: The name of the author. * `published_year`: The year the book was published. Constraints * You must use the provided URL template to fetch the books: ``` url = \\"https://api.example.com/books?query={query}&author={author}\\" ``` * You must handle network errors and invalid inputs gracefully. Requirements * The function must use the `requests` library to make an HTTP GET request. * It should parse the JSON content to extract the list of books. You can assume the API returns a JSON response containing a list of books with the fields `title`, `author`, and `published_year`. * You must handle cases where the JSON structure differs or the API is not reachable. * Validate the inputs and provide meaningful error messages for invalid inputs. * If the `author` input is an empty string, only the `query` should be used in the API request. # Example Usage ```python print(search_books(\\"Harry Potter\\", \\"J.K. Rowling\\")) ```","solution":"import requests def search_books(query: str, author: str) -> list: Queries an online book database and returns a list of books matching the given search term and author. Parameters: - query (str): The search term for the book title. - author (str): The author\'s name. If empty, search is only based on the query. Returns: - list: A list of dictionaries, each representing a book with keys \'title\', \'author\', and \'published_year\'. if not query: raise ValueError(\\"The search query must not be empty.\\") url = f\\"https://api.example.com/books?query={query}&author={\'\' if not author else author}\\" try: response = requests.get(url) response.raise_for_status() # Raises an HTTPError if the response was an HTTP error except requests.RequestException as e: raise ConnectionError(f\\"An error occurred while trying to fetch data: {e}\\") try: books = response.json() if not isinstance(books, list): raise ValueError(\\"The response is not in expected format.\\") return [ {\\"title\\": book.get(\\"title\\"), \\"author\\": book.get(\\"author\\"), \\"published_year\\": book.get(\\"published_year\\")} for book in books ] except (ValueError, TypeError) as e: raise ValueError(f\\"Error parsing the response: {e}\\")"},{"question":"# Enhanced String Matching with Wildcards You are given two strings, `source` and `pattern`. The pattern string may contain the wildcard characters `*` and `?`. The `*` wildcard matches zero or more characters of any kind, and the `?` wildcard matches exactly one character of any kind. Your task is to determine whether the pattern matches the entire `source` string. # Function Signature ```python def is_match(source: str, pattern: str) -> bool: ``` # Input - A string `source` representing the source text to be matched. - A string `pattern` representing the pattern to match against the source text. # Output - A boolean value `True` if the pattern matches the source string; otherwise, `False`. # Constraints - The length of `source` will be between `1` and `10^4`. - The length of `pattern` will be between `1` and `10^4`. - The `source` string contains only lowercase alphabets. - The `pattern` string contains only lowercase alphabets and the wildcards `*` and `?`. # Examples 1. Input: `source = \\"abcdef\\"`, `pattern = \\"a?c*f\\"` Output: `True` 2. Input: `source = \\"abcdef\\"`, `pattern = \\"a*d\\"` Output: `False` 3. Input: `source = \\"abcde\\"`, `pattern = \\"*e\\"` Output: `True` # Explanation - **Example 1**: The pattern `a?c*f` matches the source `abcdef`. Here, `a` matches `a`, `?` matches `b`, `c` matches `c`, `*` matches `de`, and finally `f` matches `f`. - **Example 2**: The pattern `a*d` does not match the source `abcdef` since the `d` in the pattern does not align with the `d` in the source string. - **Example 3**: The pattern `*e` matches the source `abcde`, as the `*` wildcard can match any sequence of characters (`abcd` in this case), followed by `e`. # Performance Requirements The implementation must be efficient in terms of time and space complexity, ideally handling input strings and patterns up to the maximum constraints within a time complexity close to O(m * n), where `m` is the length of `source` and `n` is the length of `pattern`. # Notes - Ensure to account for edge cases such as patterns that only contain wildcards and source strings of minimal and maximal lengths. - Consider leveraging dynamic programming or other optimal string matching algorithms to achieve the desired performance. Implement the function `is_match` to solve the string matching problem outlined above.","solution":"def is_match(source: str, pattern: str) -> bool: m, n = len(source), len(pattern) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == \'?\' or source[i - 1] == pattern[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Coding Assessment Question Context In computer science, a binary search tree (BST) is a data structure that maintains sorted order of elements, enabling efficient lookup, insertion, and deletion operations. By ensuring that the left subtree of a node contains only nodes with keys less than the node\'s key and the right subtree only nodes with keys greater than the node\'s key, BSTs maintain a manageable structure for these operations. Your task is to calculate the height of a binary search tree. Problem Statement You need to implement a Python function `calculate_bst_height(root: Optional[TreeNode]) -> int` that returns the height of the given binary search tree. The height of a binary tree is the number of edges from the root to the deepest leaf node. An empty tree has a height of -1. # Constraints * Each node in the tree contains a unique integer value. * The tree can have up to 10^5 nodes. * A node is represented using the `TreeNode` class as defined below. # Expected Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def calculate_bst_height(root: Optional[TreeNode]) -> int: ``` # Input * An optional `TreeNode` object representing the root of the binary search tree. This can be `None` if the tree is empty. # Output * An integer representing the height of the binary search tree. # Example ```python # Example 1: # The structure of the BST is as follows: # 2 # / # 1 3 # Output: 1 node1 = TreeNode(1) node2 = TreeNode(2) node3 = TreeNode(3) node2.left = node1 node2.right = node3 print(calculate_bst_height(node2)) # Output: 1 # Example 2: # The structure of the BST is as follows: # 4 # / # 3 # / # 2 # Output: 2 node2 = TreeNode(2) node3 = TreeNode(3) node4 = TreeNode(4) node4.left = node3 node3.left = node2 print(calculate_bst_height(node4)) # Output: 2 # Example 3: # Empty Tree # Output: -1 print(calculate_bst_height(None)) # Output: -1 ``` # Constraints 1. The function should handle an empty tree and return `-1` in that case. 2. The function should efficiently compute tree height even for large trees with up to 10^5 nodes. Additional Notes * Use recursion or iteration to traverse the tree and compute the height. * Ensure the solution is optimized for large input sizes.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def calculate_bst_height(root): if root is None: return -1 else: left_height = calculate_bst_height(root.left) right_height = calculate_bst_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Substring Anagram Checker Design an efficient algorithm to determine if any substring of a given input string is an anagram of a specified pattern string. An anagram of a string is another string that contains the same characters, only the order of characters can be different. # Requirements 1. Implement the function `is_anagram_substring` that takes two strings `s` and `pattern` as input and returns a boolean value indicating whether any substring of `s` is an anagram of `pattern`. 2. Optimize the solution for both time and space complexity. 3. Ensure that the function handles both upper and lower case letters correctly, but treat them as distinct (i.e., `a` is different from `A`). # Input and Output Specifications * **Input**: Two strings `s` and `pattern` where both consist of lowercase and/or uppercase alphabetic characters. * **Output**: A boolean value (`True` or `False`) indicating if any substring of `s` is an anagram of `pattern`. # Function Signature ```python def is_anagram_substring(s: str, pattern: str) -> bool: ``` # Constraints * The length of the string `s` is between 0 and 10^5. * The length of the string `pattern` is between 1 and 10^5. # Examples 1. `is_anagram_substring(\\"cbaebabacd\\", \\"abc\\")` - Expected Output: `True` - Explanation: There is a substring \\"cba\\" in `s` which is an anagram of `pattern`. 2. `is_anagram_substring(\\"af\\", \\"be\\")` - Expected Output: `False` - Explanation: `s` does not contain any substring that is an anagram of `pattern`. 3. `is_anagram_substring(\\"\\", \\"a\\")` - Expected Output: `False` - Explanation: An empty string cannot contain any substrings. 4. `is_anagram_substring(\\"a\\", \\"a\\")` - Expected Output: `True` - Explanation: The substring \\"a\\" is an anagram of `pattern` \\"a\\". # Instructions 1. Implement the function `is_anagram_substring` as specified. 2. Ensure the function handles the provided examples and additional edge cases gracefully. 3. The function should be tested for minimal execution time and memory usage.","solution":"def is_anagram_substring(s: str, pattern: str) -> bool: from collections import Counter # Length of the pattern pattern_len = len(pattern) if pattern_len > len(s): return False # Counter for the pattern string pattern_count = Counter(pattern) # Counter for the first window in string `s` window_count = Counter(s[:pattern_len]) if window_count == pattern_count: return True # Sliding window for i in range(pattern_len, len(s)): start_char = s[i - pattern_len] end_char = s[i] window_count[end_char] += 1 if window_count[start_char] == 1: del window_count[start_char] else: window_count[start_char] -= 1 if window_count == pattern_count: return True return False"},{"question":"# Number Spiral Generator Problem Description You have been hired as a software engineer at a company that specializes in visualization tools. Your current task is to develop a function that generates a number spiral for a given size. A number spiral is a square grid (n x n) filled with numbers from 1 to n^2 in a spiral order starting from the top-left corner and moving clockwise. Spiral Pattern - Start from the top-left corner and continue placing subsequent numbers in a clockwise spiral. - Move right across the top row, then go down the last column, left across the bottom row, and finally up the first column. - Continue this pattern inward until the entire grid is filled. # Task You need to implement a function `number_spiral(n: int) -> List[List[int]]` that generates a number spiral of size `n x n`. # Input and Output Formats * **Input**: - `n`: an integer representing the size of the spiral grid (1 ≤ n ≤ 10). * **Output**: - The function should return a list of lists (2D list) representing the number spiral. # Example: ```python number_spiral(3) ``` Output for the example: ```python [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] ``` # Constraints: * Ensure the function handles the smallest and largest values of `n` properly. # Performance: * The function should be optimized to handle the generation of the spiral efficiently. **Hint**: Use nested loops or direction vectors to control the movement within the grid.","solution":"def number_spiral(n): Generates a number spiral of size n x n. spiral = [[0]*n for _ in range(n)] current_num = 1 # Start with 1 top, left, bottom, right = 0, 0, n-1, n-1 while top <= bottom and left <= right: # Move right across the top row for i in range(left, right+1): spiral[top][i] = current_num current_num += 1 top += 1 # Move down the right column for i in range(top, bottom+1): spiral[i][right] = current_num current_num += 1 right -= 1 if top <= bottom: # Move left across the bottom row for i in range(right, left-1, -1): spiral[bottom][i] = current_num current_num += 1 bottom -= 1 if left <= right: # Move up the left column for i in range(bottom, top-1, -1): spiral[i][left] = current_num current_num += 1 left += 1 return spiral"},{"question":"# Question: Palindrome and Sub-palindrome Check You are tasked with writing two functions to: 1. **Check** if a given string is a palindrome. 2. **Find** the longest palindromic substring within a given string. Function 1 Requirements: `is_palindrome` Your function needs to: - Accept a string `s`. - Validate if the input string is a palindrome. - Return `True` if the string is a palindrome, otherwise `False`. # Input: - `s` (str): A non-empty string. # Output: - (bool): `True` if the string is a palindrome, otherwise `False`. # Example: ```python assert is_palindrome(\\"radar\\") == True assert is_palindrome(\\"hello\\") == False ``` Function 2 Requirements: `longest_sub_palindrome` Your function needs to: - Accept a string `s`. - Return the longest palindromic substring within the input string. # Input: - `s` (str): A non-empty string. # Output: - (str): The longest palindromic substring. # Example: ```python assert longest_sub_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_sub_palindrome(\\"cbbd\\") == \\"bb\\" ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python def is_palindrome(s: str) -> bool: # Add your solution here pass def longest_sub_palindrome(s: str) -> str: # Add your solution here pass # Test your implementation if __name__ == \\"__main__\\": assert is_palindrome(\\"radar\\") == True assert is_palindrome(\\"hello\\") == False assert longest_sub_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_sub_palindrome(\\"cbbd\\") == \\"bb\\" ```","solution":"def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, False otherwise. return s == s[::-1] def longest_sub_palindrome(s: str) -> str: Returns the longest palindromic substring in the given string s. def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest_palindrome): longest_palindrome = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(i, i+1) if len(even_palindrome) > len(longest_palindrome): longest_palindrome = even_palindrome return longest_palindrome"},{"question":"# Network Latency Simulation You are responsible for simulating network latency for messages sent between two systems over a specified duration. The goal is to calculate the average round-trip latency for a given number of messages sent within a defined time interval. Task You need to implement the `average_latency` function in Python, which simulates sending messages and measures the average round-trip latency over a specified duration. Function Signature ```python def average_latency( message_count: int, max_latency: int, min_latency: int = 10 ) -> float: ``` Input * `message_count`: An integer representing the total number of messages to be sent. * `max_latency`: An integer representing the maximum possible latency (in milliseconds) for a round-trip message. * `min_latency`: An integer representing the minimum possible latency (in milliseconds) for a round-trip message (default is 10ms). Output * Returns a float representing the average round-trip latency of the messages in milliseconds. Constraints * You may assume `message_count` is always a positive integer. * `max_latency` is always greater than or equal to `min_latency`. * Latency for each message is randomly generated between `min_latency` and `max_latency` inclusive. Examples ```python assert round(average_latency(100, 150), 2) == 80.0 # Example, actual output will vary due to random latency assert round(average_latency(50, 100, 20), 2) == 60.0 # Example, actual output will vary due to random latency assert round(average_latency(10, 50, 10), 2) == 30.0 # Example, actual output will vary due to random latency ``` Requirements * Use a random number generator to simulate the round-trip latencies. * Consider edge cases where `min_latency` and `max_latency` are equal. * Write the function efficiently to handle large values of `message_count`. # Note You may import necessary modules such as `random` for generating latency values. The goal is to focus on the simulation logic and correct calculation of the average latency.","solution":"import random def average_latency(message_count: int, max_latency: int, min_latency: int = 10) -> float: Simulates sending `message_count` messages and calculates the average round-trip latency. :param message_count: Total number of messages to be sent. :param max_latency: Maximum possible latency for a round-trip message in milliseconds. :param min_latency: Minimum possible latency for a round-trip message in milliseconds, default is 10ms. :return: Average round-trip latency in milliseconds. total_latency = 0 for _ in range(message_count): latency = random.randint(min_latency, max_latency) total_latency += latency average_latency = total_latency / message_count return average_latency"},{"question":"# Coding Question: Calculate Rotational Kinetic Energy You are given the task of implementing a function that computes the rotational kinetic energy of a rotating object. The rotational kinetic energy `E` can be calculated as: E = 0.5 * I * ω^2 Where: - `I`: Moment of inertia of the object (positive float). - `ω`: Angular velocity of the object (positive float). Your task is to implement the function `rotational_kinetic_energy(moment_of_inertia, angular_velocity)` that returns the rotational kinetic energy `E`. # Function Signature ```python def rotational_kinetic_energy(moment_of_inertia: float, angular_velocity: float) -> float: pass ``` # Input - `moment_of_inertia` (float): The moment of inertia of the object (positive). - `angular_velocity` (float): The angular velocity of the object (positive). # Output - Returns a single float: The rotational kinetic energy in joules. # Constraints - All numeric values will be provided within a physically meaningful range. # Edge Cases - Handle cases where the input parameters are invalid (e.g., negative values for moment of inertia or angular velocity) by raising a `ValueError` with an appropriate error message. # Example ```python >>> rotational_kinetic_energy(10, 5) 125.0 >>> rotational_kinetic_energy(3.5, 2) 7.0 >>> rotational_kinetic_energy(-5, 3) Traceback (most recent call last): ... ValueError: moment_of_inertia and angular_velocity must be positive ```","solution":"def rotational_kinetic_energy(moment_of_inertia: float, angular_velocity: float) -> float: if moment_of_inertia <= 0 or angular_velocity <= 0: raise ValueError(\\"moment_of_inertia and angular_velocity must be positive\\") return 0.5 * moment_of_inertia * angular_velocity ** 2"},{"question":"# Context You are given a navigational map represented as a 2D grid. Each cell in the grid contains a non-negative integer that indicates the cost to enter that cell. Your task is to find the minimum cost path from the top-left corner to the bottom-right corner of the grid. Only movements to the right or downward are allowed. # Task Implement a Python function named `min_cost_path` that takes a 2D list (grid) of integers and returns the minimum cost to travel from the top-left to the bottom-right cell. # Input 1. A 2D list `grid` where `grid[i][j]` is a non-negative integer representing the cost to enter the cell at row `i` and column `j`. # Output 1. An integer representing the minimum cost to travel from the top-left to the bottom-right cell. # Constraints 1. The number of rows (R) and columns (C) in the grid are at most (100). 2. All costs are non-negative integers and do not exceed (1000). # Performance Requirements 1. Ensure your solution works efficiently for the provided constraints. # Function Signature ```python def min_cost_path(grid: List[List[int]]) -> int: # Your implementation here pass ``` # Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(grid)) # Expected output: 7 grid = [ [1, 2, 3], [4, 5, 6] ] print(min_cost_path(grid)) # Expected output: 12 ``` Ensure your implementation adheres to the guidelines and performance constraints provided.","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Polygon Perimeter Calculator In this task, you will implement a function to calculate the perimeter of a regular polygon based on the given edge length and the number of edges. The regular polygon has all sides of equal length and all internal angles equal. The function should ensure valid inputs and handle the requirements precisely. Function Specification 1. `polygon_perimeter(num_edges: int, edge_length: float) -> float` This function should compute and return the perimeter of a regular polygon. - **Input**: - `num_edges (int)`: The number of edges (sides) of the polygon (must be an integer greater than 2). - `edge_length (float)`: The length of each edge of the polygon (must be a positive number). - **Output**: - `float`: Perimeter of the polygon. - **Constraints**: - Raise `ValueError` if the number of edges is not greater than 2. - Raise `ValueError` if the edge length is not positive. Example ```python >>> polygon_perimeter(5, 3) 15.0 >>> polygon_perimeter(6, 2) 12.0 >>> polygon_perimeter(3, 5) 15.0 >>> polygon_perimeter(1, 5) Traceback (most recent call last): ... ValueError: Number of edges must be greater than 2. >>> polygon_perimeter(4, -2) Traceback (most recent call last): ... ValueError: Edge length must be positive. ``` Notes - Ensure your code is efficient and handles the edge cases appropriately. - The number of edges must be greater than 2, and the edge length must be a positive number; exceptions should be thrown for invalid inputs.","solution":"def polygon_perimeter(num_edges: int, edge_length: float) -> float: Calculate and return the perimeter of a regular polygon. :param num_edges: The number of edges (sides) of the polygon (must be an integer greater than 2). :param edge_length: The length of each edge of the polygon (must be a positive number). :return: Perimeter of the polygon. if num_edges <= 2: raise ValueError(\\"Number of edges must be greater than 2.\\") if edge_length <= 0: raise ValueError(\\"Edge length must be positive.\\") return num_edges * edge_length"},{"question":"# Coding Assessment Question Context: Handling strings and ensuring the correct ordering of characters is a fundamental aspect of many text-processing applications, such as lexicographical sorting, encryption, and data normalization. Efficiently solving problems related to string manipulation is crucial in these domains. Problem Statement: Given a string ( s ) composed of lowercase alphabets, determine if it is possible to reorder the characters of the string such that no two adjacent characters are the same. If it is possible, return one such permutation. If it is not possible, return an empty string. Guidelines: 1. Analyze the frequency of each character in the string to determine if a valid reorder is possible. 2. Implement a function to generate a valid permutation where no two adjacent characters are the same. 3. Return the permutation as a string. If no valid permutation exists, return an empty string. Input Format: - A single string ( s ) composed of lowercase alphabets. Output Format: - A string representing one valid permutation with no two adjacent characters the same, or an empty string if no valid permutation exists. Example: Input: ```python s = \\"aabbc\\" ``` Output: ```python \\"ababc\\" ``` Input: ```python s = \\"aaab\\" ``` Output: ```python \\"\\" ``` Constraints: - The length of string ( s ) will be between 1 and ( 10^5 ). Function Signature: ```python def reorganize_string(s: str) -> str: pass ``` Performance Requirements: - The solution should efficiently process the input string and generate a valid permutation if possible within a reasonable time frame.","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: # Count frequency of each character char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) # If the most frequent character frequency is more than (len(s) + 1) // 2, return \\"\\" if any(-count > (len(s) + 1) // 2 for count, char in max_heap): return \\"\\" result = [] prev_count, prev_char = 0, \'\' # Start constructing the result by placing the most frequent characters first while max_heap: count, char = heapq.heappop(max_heap) # Add the previous character back into the heap if it exists if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) result.append(char) prev_count, prev_char = count + 1, char # Decrease count because it was used once return \'\'.join(result)"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},R={class:"card-container"},N={key:0,class:"empty-state"},L=["disabled"],z={key:0},Y={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",R,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const D=c(O,[["render",P],["__scopeId","data-v-eecce0a7"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/53.md","filePath":"quotes/53.md"}'),j={name:"quotes/53.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(D)]))}});export{B as __pageData,U as default};
