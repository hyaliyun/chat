import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},A={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-aba5588d"]]),S=JSON.parse('[{"question":"# Problem Statement As part of a data processing system, you need to implement a function that consolidates sales data from two different sources. The sales data from each source consists of product names and their respective sales figures. Your task is to merge these sales data, summing up the sales figures for products that appear in both sources. # Task Design a function `merge_sales_data(sales1: dict, sales2: dict) -> dict` that takes two dictionaries representing sales data from two different sources and returns a single dictionary with consolidated sales figures. # Input - Two dictionaries `sales1` and `sales2`. Each dictionary has keys as product names (strings) and values as sales figures (integers). # Output - A single dictionary with product names as keys and consolidated sales figures as values. If a product appears in both input dictionaries, its sales figures should be summed up. # Constraints - The keys (product names) in `sales1` and `sales2` are non-empty strings. - The values (sales figures) are non-negative integers. - The dictionaries have at most 1000 key-value pairs each. # Example ```python >>> merge_sales_data({\\"apple\\": 100, \\"banana\\": 150}, {\\"banana\\": 200, \\"cherry\\": 250}) {\'apple\': 100, \'banana\': 350, \'cherry\': 250} >>> merge_sales_data({\\"pen\\": 50}, {\\"pen\\": 30, \\"pencil\\": 20}) {\'pen\': 80, \'pencil\': 20} >>> merge_sales_data({}, {\\"eraser\\": 5}) {\'eraser\': 5} >>> merge_sales_data({\\"notebook\\": 70, \\"marker\\": 90}, {}) {\'notebook\': 70, \'marker\': 90} ``` # Detailed Requirements 1. The function should correctly sum the sales figures for products that are present in both dictionaries. 2. If a product appears in only one dictionary, it should appear in the resulting dictionary with its original sales figure. 3. The function should handle empty dictionaries correctly, including cases where one or both input dictionaries are empty. 4. Ensure your solution is efficient, considering both time complexity and memory usage.","solution":"def merge_sales_data(sales1, sales2): Merges two sales data dictionaries and sums the values for matching keys. Args: sales1 (dict): Sales data from source 1. sales2 (dict): Sales data from source 2. Returns: dict: Consolidated sales data. merged_sales = sales1.copy() for product, sales in sales2.items(): if product in merged_sales: merged_sales[product] += sales else: merged_sales[product] = sales return merged_sales"},{"question":"# Coding Assessment Question Scenario You are a software engineer working on a data aggregation service for e-commerce websites. One of the features of your service is to analyze sales data to identify trends. Specifically, your task is to determine the maximum sales difference between any two days within a given range. Task Implement a function `max_sales_difference` that calculates the maximum difference in sales between any two days within a specified range for a given list of daily sales amounts. Function Signature ```python def max_sales_difference(sales: Sequence[int], start_day: int, end_day: int) -> int: pass ``` Input * `sales`: A sequence of integers representing the daily sales amounts. * `start_day`: An integer representing the starting index (inclusive) of the range. * `end_day`: An integer representing the ending index (inclusive) of the range. Output * Returns an integer representing the maximum difference between the sales on any two days within the specified range. Constraints * `start_day` and `end_day` will always be valid indexes within the bounds of the `sales` list. * The list of sales amounts will have at least two elements. * `start_day` will always be less than or equal to `end_day`. Performance Requirement * Aim for (O(n)) time complexity within the specified range. Example ```python >>> max_sales_difference([120, 180, 90, 200, 150, 80, 250], 1, 5) 110 # Maximum difference is between 200 (index 3) and 90 (index 2). >>> max_sales_difference([100, 220, 150, 180, 90], 0, 2) 120 # Maximum difference is between 220 (index 1) and 100 (index 0). >>> max_sales_difference([50, 60, 70, 80, 90], 2, 4) 20 # Maximum difference is between 90 (index 4) and 70 (index 2). ``` Edge Cases * Verify behavior when `start_day` and `end_day` are the same (should return 0). * Verify handling of the smallest possible sales list with two elements.","solution":"from typing import Sequence def max_sales_difference(sales: Sequence[int], start_day: int, end_day: int) -> int: Calculates the maximum difference in sales between any two days within the given range. Args: sales (Sequence[int]): A sequence of integers representing daily sales amounts. start_day (int): The starting index (inclusive) of the range. end_day (int): The ending index (inclusive) of the range. Returns: int: The maximum difference between sales on any two days within the specified range. min_sales = sales[start_day] max_sales = sales[start_day] for i in range(start_day, end_day + 1): if sales[i] < min_sales: min_sales = sales[i] if sales[i] > max_sales: max_sales = sales[i] return max_sales - min_sales"},{"question":"# Directed Graph Pathfinding Problem Context You have been tasked with developing a pathfinding algorithm in a directed graph for a route planning application. Users should be able to find the shortest path between two locations if one exists. Task Implement a class `DirectedGraph` in Python that supports the following operations: 1. Initialization of an empty graph. 2. Adding nodes and directed edges with associated positive costs. 3. Finding the shortest path between two nodes using Dijkstra\'s algorithm. 4. String representation of the graph. Requirements 1. **Initialization**: - The constructor should start with an empty graph. ```python def __init__(self) -> None: ``` 2. **Adding a Node**: ```python def add_node(self, node: Any) -> None: ``` 3. **Adding a Directed Edge**: ```python def add_edge(self, from_node: Any, to_node: Any, cost: float) -> None: ``` 4. **Shortest Path (Dijkstra\'s Algorithm)**: ```python def shortest_path(self, start_node: Any, end_node: Any) -> Tuple[List[Any], float]: ``` 5. **String Representation**: ```python def __str__(self) -> str: ``` Input and Output Formats: - **Adding a Node**: `graph.add_node(\'A\')` should add node \'A\' to the graph. - **Adding a Directed Edge**: `graph.add_edge(\'A\', \'B\', 3.5)` should add a directed edge from \'A\' to \'B\' with a cost of 3.5. - **Shortest Path**: `graph.shortest_path(\'A\', \'C\')` should return ([\'A\', \'B\', \'C\'], 5.0) if the shortest path from \'A\' to \'C\' is A -> B -> C with a total cost of 5.0. Constraints: - Costs of the edges should always be positive real numbers. - Ensure that your algorithm can handle graphs with up to 10,000 nodes and 50,000 edges efficiently. - If there is no path between the start and end node, return ([], float(\'inf\')). - Use appropriate data structures to guarantee efficient performance. Example: ```python graph = DirectedGraph() graph.add_node(\'A\') graph.add_node(\'B\') graph.add_node(\'C\') graph.add_edge(\'A\', \'B\', 1) graph.add_edge(\'B\', \'C\', 2) graph.add_edge(\'A\', \'C\', 4) print(graph.shortest_path(\'A\', \'C\')) # Should return ([\'A\', \'B\', \'C\'], 3.0) print(graph) # Should display the graph with nodes and edges ```","solution":"import heapq from typing import Any, List, Dict, Tuple class DirectedGraph: def __init__(self) -> None: self.graph: Dict[Any, Dict[Any, float]] = {} def add_node(self, node: Any) -> None: if node not in self.graph: self.graph[node] = {} def add_edge(self, from_node: Any, to_node: Any, cost: float) -> None: if from_node in self.graph and to_node in self.graph: self.graph[from_node][to_node] = cost def shortest_path(self, start_node: Any, end_node: Any) -> Tuple[List[Any], float]: if start_node not in self.graph or end_node not in self.graph: return ([], float(\'inf\')) distances = {node: float(\'inf\') for node in self.graph} previous_nodes = {node: None for node in self.graph} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_node = end_node while previous_nodes[current_node] is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] if path: path.insert(0, start_node) if distances[end_node] == float(\'inf\'): return ([], float(\'inf\')) return (path, distances[end_node]) def __str__(self) -> str: result = \'\' for node in self.graph: for neighbor, cost in self.graph[node].items(): result += f\'{node} -> {neighbor} [cost={cost}]n\' return result"},{"question":"# Integer Sequence Analyzer You are provided with a list of integers representing a sequence. Your task is to analyze the sequence and determine specific properties such as its length, the maximum value, the minimum value, and whether the sequence is strictly increasing, strictly decreasing, or neither. Requirements: 1. **Analyze Sequence Properties**: Implement a function `analyze_sequence(sequence: List[int]) -> Dict[str, Union[int, bool]]` that returns a dictionary with the following information: - The length of the sequence. - The maximum value in the sequence. - The minimum value in the sequence. - A boolean indicating if the sequence is strictly increasing. - A boolean indicating if the sequence is strictly decreasing. # Input Specifications: 1. The function `analyze_sequence(sequence: List[int]) -> Dict[str, Union[int, bool]]` accepts a list of integers as input. # Output Specifications: 1. The function should return a dictionary with keys: `length`, `max_value`, `min_value`, `is_increasing`, and `is_decreasing`. # Constraints: 1. The input list will contain at least one integer. 2. Assume all list values are integers. # Scenarios and Examples: 1. **Simple Case**: - `analyze_sequence([1, 2, 3, 4, 5])` should return `{\'length\': 5, \'max_value\': 5, \'min_value\': 1, \'is_increasing\': True, \'is_decreasing\': False}`. 2. **Constant Sequence**: - `analyze_sequence([5, 5, 5, 5, 5])` should return `{\'length\': 5, \'max_value\': 5, \'min_value\': 5, \'is_increasing\': False, \'is_decreasing\': False}`. 3. **Decreasing Sequence**: - `analyze_sequence([5, 4, 3, 2, 1])` should return `{\'length\': 5, \'max_value\': 5, \'min_value\': 1, \'is_increasing\': False, \'is_decreasing\': True}`. 4. **Mixed Sequence**: - `analyze_sequence([3, 1, 4, 1, 5, 9, 2, 6, 5])` should return `{\'length\': 9, \'max_value\': 9, \'min_value\': 1, \'is_increasing\': False, \'is_decreasing\': False}`. # Boilerplate Code ```python from typing import List, Dict, Union def analyze_sequence(sequence: List[int]) -> Dict[str, Union[int, bool]]: length = len(sequence) max_value = max(sequence) min_value = min(sequence) is_increasing = all(x < y for x, y in zip(sequence, sequence[1:])) is_decreasing = all(x > y for x, y in zip(sequence, sequence[1:])) return { \'length\': length, \'max_value\': max_value, \'min_value\': min_value, \'is_increasing\': is_increasing, \'is_decreasing\': is_decreasing } if __name__ == \\"__main__\\": import doctest # Write doctests for analyze_sequence doctest.testmod() ```","solution":"from typing import List, Dict, Union def analyze_sequence(sequence: List[int]) -> Dict[str, Union[int, bool]]: length = len(sequence) max_value = max(sequence) min_value = min(sequence) is_increasing = all(x < y for x, y in zip(sequence, sequence[1:])) is_decreasing = all(x > y for x, y in zip(sequence, sequence[1:])) return { \'length\': length, \'max_value\': max_value, \'min_value\': min_value, \'is_increasing\': is_increasing, \'is_decreasing\': is_decreasing }"},{"question":"# Question: Implement Sparse Matrix-Vector Multiplication Given a potentially sparse matrix and a vector, your task is to write a function that performs matrix-vector multiplication using an efficient approach for sparse data. The matrix will be provided in Compressed Sparse Row (CSR) format. # Function Signature ```python def sparse_matrix_vector_multiplication(csr_matrix: Tuple[np.ndarray, np.ndarray, np.ndarray], vector: np.ndarray) -> np.ndarray: pass ``` # Input - `csr_matrix` (Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray): A tuple of three numpy arrays representing a matrix in CSR format: - `data` (numpy.ndarray): Non-zero values of the matrix. - `indices` (numpy.ndarray): Column indices of the non-zero values. - `indptr` (numpy.ndarray): Row pointer indicating the starting index of each row in `data` and `indices`. - `vector` (numpy.ndarray): A column vector with dimensions compatible with the matrix. # Output - Returns the result of the matrix-vector multiplication as a numpy array. # Constraints - Matrix dimensions: Matrix is of size `m x n` where `1 ≤ m, n ≤ 1000`. - Vector dimensions: `vector` is of size `n x 1`. - The matrix and vector will only contain real numbers. # Requirements - You should use the given CSR format data structures efficiently to perform the multiplication. - No external libraries other than numpy are allowed. # Performance - Aim for an efficient implementation with respect to time and space complexity, considering the given constraints. # Example ```python import numpy as np data = np.array([1, 2, 3, 4]) indices = np.array([0, 2, 2, 3]) indptr = np.array([0, 2, 3, 4]) csr_matrix = (data, indices, indptr) vector = np.array([1, 0, 2, 1]) print(sparse_matrix_vector_multiplication(csr_matrix, vector)) # Output: array([5, 6, 4]) ``` # Note - Ensure you thoroughly test your function with various edge cases and input sizes.","solution":"import numpy as np from typing import Tuple def sparse_matrix_vector_multiplication(csr_matrix: Tuple[np.ndarray, np.ndarray, np.ndarray], vector: np.ndarray) -> np.ndarray: data, indices, indptr = csr_matrix result = np.zeros(len(indptr) - 1) for i in range(len(result)): row_start = indptr[i] row_end = indptr[i + 1] for j in range(row_start, row_end): result[i] += data[j] * vector[indices[j]] return result"},{"question":"# Coding Assessment Question: Generate Permutations Objective: Develop a function to generate all possible permutations of a given string. Detailed Requirements: 1. **Function Signature**: `def generate_permutations(string: str) -> list:` 2. **Input**: A single string, `string`, which may consist of alphabetic characters (a-z, A-Z). 3. **Output**: A list of all unique permutations of the input string, sorted in lexicographical order. 4. **Constraints**: - The input string must only contain alphabetic characters. If it contains non-alphabetic characters, raise a `ValueError` with the message \\"String must only contain alphabetic characters.\\" - Treat the specific case of characters (\'A\' and \'a\') as distinct characters. - Ensure the function handles an empty string properly by returning an empty list. - The solution must handle the generation efficiently given the possible factorial growth of permutations. Performance: - Time complexity is expected to be O(n*n!) due to the nature of generating permutations. - Space complexity ideally within O(n*n!) to store all permutations. Example: ```python assert generate_permutations(\'a\') == [\'a\'] assert generate_permutations(\'ab\') == [\'ab\', \'ba\'] assert generate_permutations(\'abc\') == [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] assert generate_permutations(\'\') == [] # For invalid inputs try: generate_permutations(\'abc123\') except ValueError as e: assert str(e) == \\"String must only contain alphabetic characters\\" ``` Scenario: Create a function that helps in generating all permutations of a word. This can be useful in applications such as word games, anagram solvers, or password generators where every possible arrangement of characters needs to be considered. This problem requires an understanding of recursion, combinatorics, and efficient string handling in Python.","solution":"from itertools import permutations def generate_permutations(string: str) -> list: Generates all unique permutations of the input string and returns them sorted in lexicographical order. if any(not c.isalpha() for c in string): raise ValueError(\\"String must only contain alphabetic characters\\") if not string: return [] perm_set = set(permutations(string)) sorted_permutations = sorted([\'\'.join(p) for p in perm_set]) return sorted_permutations"},{"question":"# Sudoku Solver with Pre-filled Values Context: Sudoku is a popular puzzle game that involves filling a 9x9 grid such that each column, each row, and each of the nine 3x3 subgrids contain all of the digits from 1 to 9. In this advanced variation, you will write a solution that solves a partially filled Sudoku board using backtracking while respecting the given pre-filled values. Problem Statement: Write a function `solve_sudoku(board: List[List[int]]) -> List[List[int]]` that takes in a partially filled Sudoku board and returns a completed board that honors the rules of Sudoku. * The board is given as a 9x9 grid containing integers ranging from 0 to 9. * A value of 0 indicates an unfilled cell. Input: * `board` - a 9x9 list of lists, where each inner list represents a row in the Sudoku board. Output: * A completed 9x9 Sudoku board in the same format, which is now fully filled according to Sudoku rules. Example: ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solve_sudoku(board) ``` Expected Output: ```python [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ``` Constraints: 1. The given board will have at least 17 filled values. 2. The input will be such that the puzzle is always solvable. Function Signature: ```python from typing import List def solve_sudoku(board: List[List[int]]) -> List[List[int]]: pass ``` Notes: * Your solution should apply the backtracking technique to fill the puzzle. * Consider edge cases where the provided board is nearly complete or has minimal filled values. * Ensure your implementation is efficient to handle the worst-case scenario within a reasonable time for given constraints.","solution":"from typing import List def solve_sudoku(board: List[List[int]]) -> List[List[int]]: def is_valid(board, row, col, num): # Check the row for i in range(9): if board[row][i] == num: return False # Check the column for i in range(9): if board[i][col] == num: return False # Check the 3x3 subgrid start_row = row - row % 3 start_col = col - col % 3 for i in range(3): for j in range(3): if board[i + start_row][j + start_col] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = 0 return False return True solve() return board"},{"question":"# Implementing Softmax Function Context In machine learning, the Softmax function is often used in the context of classification problems, particularly for transforming the output of a neural network into probabilities that sum to one. It is crucial for tasks involving multi-class classification. Your task is to implement the Softmax function from scratch. Task Write a function `custom_softmax(vector: List[float]) -> List[float]` that returns a new list where the Softmax function has been applied to each element. Input - `vector`: A list of float numbers, representing the input to the Softmax function. Output - A list of float numbers, representing the transformed values after applying the Softmax function, where the values sum to one. Constraints - The elements of the `vector` will be in the range [-100, 100]. - The length of the `vector` will be between 1 and 1000 inclusive. Example ```python >>> custom_softmax([2.0, 1.0, 0.1]) [0.65900114, 0.24243297, 0.09856589] >>> custom_softmax([-1.0, -2.0, -3.0]) [0.66524096, 0.24472847, 0.09003057] ``` Instructions 1. Implement the function `custom_softmax(vector: List[float]) -> List[float]`. 2. Ensure numerical stability by applying tricks like subtracting the maximum value from the input vector. 3. Use efficient list operations to ensure the function can handle the input size within the provided constraints. 4. Thoroughly test your function to handle a variety of edge cases such as inputs containing large positive or negative values, and different range distributions.","solution":"import math from typing import List def custom_softmax(vector: List[float]) -> List[float]: Compute the softmax of a list of numbers. Args: vector : List[float] : A list of float numbers Returns: List[float] : A list of float numbers representing the softmax probabilities max_val = max(vector) # To prevent overflow exps = [math.exp(i - max_val) for i in vector] # Subtract max_val for numerical stability sum_exps = sum(exps) return [j / sum_exps for j in exps]"},{"question":"# Scenario You are developing a text processing application that aims to determine the sentiment of English sentences based on a simple scoring system using a predefined set of positive and negative words. The overall sentiment of a sentence is positive if the number of positive words outweighs the negative words, negative if the opposite is true, and neutral if they are equal. # Task Implement the following functions to support the sentiment analysis: 1. `load_sentiment_words`: Load positive and negative words from a file. 2. `preprocess_sentence`: Preprocess a given sentence by removing punctuation and converting to lowercase. 3. `score_sentence`: Calculate the sentiment score of a sentence. 4. `determine_sentiment`: Determine the sentiment based on the score. 5. `evaluate_accuracy`: Calculate the accuracy of your sentiment predictions. You will be given a dataset of sentences with their actual sentiments for evaluation. # Function Definitions **Function 1**: `load_sentiment_words(filepath: str) -> tuple` - **Input**: Filepath of a file containing positive and negative words. The first line contains positive words, and the second line contains negative words, separated by commas. - **Output**: A tuple containing two sets: the set of positive words and the set of negative words. - **Example**: ```python load_sentiment_words(\'sentiments.txt\') # Output: (set([\'happy\', \'joyful\']), set([\'sad\', \'angry\'])) ``` **Function 2**: `preprocess_sentence(sentence: str) -> list` - **Input**: A string containing the sentence. - **Output**: A list of words from the sentence, all in lowercase and without punctuation. - **Example**: ```python preprocess_sentence(\\"I\'m so happy, happy!\\") # Output: [\'im\', \'so\', \'happy\', \'happy\'] ``` **Function 3**: `score_sentence(sentence: list, positive_words: set, negative_words: set) -> int` - **Input**: A list of words representing the sentence, sets of positive and negative words. - **Output**: Sentiment score of the sentence. - **Example**: ```python words = [\'im\', \'so\', \'happy\', \'happy\'] positive_words = set([\'happy\']) negative_words = set([\'sad\']) score_sentence(words, positive_words, negative_words) # Output: 2 ``` **Function 4**: `determine_sentiment(score: int) -> str` - **Input**: Sentiment score of a sentence. - **Output**: Sentiment as a string (`\'positive\'`, `\'negative\'`, or `\'neutral\'`). - **Example**: ```python determine_sentiment(2) # Output: \'positive\' determine_sentiment(0) # Output: \'neutral\' ``` **Function 5**: `evaluate_accuracy(actual_sentiments: list, predicted_sentiments: list) -> float` - **Input**: List of actual sentiments and predicted sentiments. - **Output**: Accuracy of the predictions as a percentage. - **Example**: ```python actual = [\'positive\', \'negative\', \'neutral\'] predicted = [\'positive\', \'negative\', \'positive\'] evaluate_accuracy(actual, predicted) # Output: 66.67 ``` # Constraints - The dataset contains non-empty sentences. - The predefined positive and negative word lists are non-empty. - Assume a maximum of 1000 sentences for evaluation. - Handle potential edge cases such as sentences with no positive or negative words. # Expected Workflow 1. Load positive and negative words from a file. 2. Preprocess a dataset of sentences. 3. Calculate the sentiment score for each sentence. 4. Determine the overall sentiment based on the score. 5. Evaluate the accuracy of your sentiment predictions.","solution":"import string def load_sentiment_words(filepath: str) -> tuple: Load positive and negative words from a file. The first line contains positive words separated by commas. The second line contains negative words separated by commas. with open(filepath, \'r\') as file: lines = file.readlines() positive_words = set(lines[0].strip().split(\',\')) negative_words = set(lines[1].strip().split(\',\')) return positive_words, negative_words def preprocess_sentence(sentence: str) -> list: Preprocess a given sentence by removing punctuation and converting to lowercase. translator = str.maketrans(\'\', \'\', string.punctuation) clean_sentence = sentence.translate(translator).lower() words = clean_sentence.split() return words def score_sentence(sentence: list, positive_words: set, negative_words: set) -> int: Calculate the sentiment score of a sentence. The score is the difference between the counts of positive and negative words. score = 0 for word in sentence: if word in positive_words: score += 1 elif word in negative_words: score -= 1 return score def determine_sentiment(score: int) -> str: Determine the sentiment based on the score. if score > 0: return \'positive\' elif score < 0: return \'negative\' else: return \'neutral\' def evaluate_accuracy(actual_sentiments: list, predicted_sentiments: list) -> float: Calculate the accuracy of your sentiment predictions. correct_predictions = sum(1 for actual, predicted in zip(actual_sentiments, predicted_sentiments) if actual == predicted) accuracy = (correct_predictions / len(actual_sentiments)) * 100 if actual_sentiments else 0 return round(accuracy, 2)"},{"question":"# Balanced Binary Search Tree (BST) with Self-Balancing Operations Scenario A database indexing system relies on a self-balancing binary search tree (BST) to manage data efficiently. This structure dynamically maintains a balance between tree height and insertion/deletion/update operations, minimizing search times. Objective Enhance a given BST implementation to include self-balancing operations to maintain a balanced structure after each insertion and deletion. Implement the following additional operations: 1. `balance(self) -> None`: Adjusts the tree to maintain balance. This method is called automatically at the end of each insertion and deletion to ensure the tree remains balanced. 2. `height(self) -> int`: Returns the height of the tree. 3. `is_balanced(self) -> bool`: Checks if the tree is balanced, such that the height difference between left and right subtrees for any node does not exceed 1. Requirements * **Function Specifications**: * Implement self-balancing techniques, such as AVL or Red-Black Tree properties. * Ensure the balance and height checks are efficient. * **Constraints**: * Handle edge cases, such as insertions or deletions causing tree imbalance. * Trees with balanced subtrees will have reduced search times. * **Performance**: * Maintain O(log n) complexities for insertion, deletion, and search operations by balancing the tree appropriately. * Ensure the tree height remains logarithmic relative to the number of nodes. Implementation Given the following class template: ```python class BalancedBST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 # Necessary for balancing calculations def __init__(self): self.root = None def insert(self, key: int) -> None: Insert a key into the tree and balance it if necessary. >>> bst = BalancedBST() >>> bst.insert(30) >>> bst.insert(20) >>> bst.insert(40) >>> bst.insert(10) >>> bst.root.key 30 self.root = self._insert(self.root, key) self.balance() def _insert(self, node, key): # Basic BST insertion logic if not node: return self.Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) return node def delete(self, key: int) -> None: Delete a key from the tree and balance it if necessary. >>> bst = BalancedBST() >>> bst.insert(30) >>> bst.insert(20) >>> bst.insert(40) >>> bst.delete(20) >>> bst.root.left is None True self.root = self._delete(self.root, key) self.balance() def _delete(self, node, key): # Basic BST deletion logic if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self.get_min(node.right) node.key = min_larger_node.key node.right = self._delete(node.right, min_larger_node.key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) return node def get_min(self, node): while node.left: node = node.left return node def get_height(self, node) -> int: if not node: return 0 return node.height def balance(self) -> None: Balance the BST to maintain optimal height. >>> bst = BalancedBST() >>> bst.insert(30) >>> bst.insert(20) >>> bst.balance() >>> bst.is_balanced() True # Your implementation here def height(self) -> int: Returns the height of the tree. >>> bst = BalancedBST() >>> bst.insert(30) >>> bst.insert(20) >>> bst.height() 2 # Your implementation here def is_balanced(self) -> bool: Checks if the tree is balanced. >>> bst = BalancedBST() >>> bst.insert(30) >>> bst.insert(20) >>> bst.insert(40) >>> bst.is_balanced() True # Your implementation here ``` Complete the implementation of `balance`, `height`, and `is_balanced` methods. Ensure the tree automatically balances itself after each insertion and deletion, maintaining efficient search times and structural integrity.","solution":"class BalancedBST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) self.root = self.balance(self.root) def _insert(self, node, key): if not node: return self.Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) return node def delete(self, key: int) -> None: self.root = self._delete(self.root, key) if self.root: self.root = self.balance(self.root) def _delete(self, node, key): if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self.get_min(node.right) node.key = min_larger_node.key node.right = self._delete(node.right, min_larger_node.key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) return node def get_min(self, node): while node.left: node = node.left return node def get_height(self, node) -> int: if not node: return 0 return node.height def balance_factor(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def balance(self, node): if not node: return node node.left = self.balance(node.left) node.right = self.balance(node.right) balance = self.balance_factor(node) if balance > 1: if self.balance_factor(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1: if self.balance_factor(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def height(self) -> int: return self.get_height(self.root) def is_balanced(self) -> bool: def _is_balanced(node): if not node: return True left_balanced = _is_balanced(node.left) right_balanced = _is_balanced(node.right) node_balance = abs(self.balance_factor(node)) <= 1 return left_balanced and right_balanced and node_balance return _is_balanced(self.root)"},{"question":"# Question In digital circuit design, a flip-flop (FF) is a basic memory element that can store one bit of data. Among various types of flip-flops, the D flip-flop (data or delay flip-flop) is a type that captures the value of the input data line (D) at the rising edge of the clock signal (CLK) and then outputs this captured value. You are required to implement a simple D flip-flop function in Python. The function accepts two parameters: `D` and `CLK`, both of which are expected to be integers that are either `0` or `1`. The function maintains a state of the output Q. When `CLK` is `1`, the function should update Q to the value of `D`. When `CLK` is `0`, the function should retain the previous value of Q. Initially, Q is `0`. Your function should raise a `ValueError` if any of the inputs are not `0` or `1`. Function Signature: ```python def d_flip_flop(D: int, CLK: int) -> int: ``` Constraints: - `D` and `CLK` will always be integers. - Valid values for `D` and `CLK` are `0` and `1`. Input: - An integer `D` (0 or 1). - An integer `CLK` (0 or 1). Output: - An integer representing the stored value Q based on the input values of `D` and `CLK`. Example: ```python output = d_flip_flop(1, 1) # Output: 1 (Q is updated to 1) output = d_flip_flop(0, 0) # Output: 1 (Q retains its previous value 1) output = d_flip_flop(0, 1) # Output: 0 (Q is updated to 0) output = d_flip_flop(1, 0) # Output: 0 (Q retains its previous value 0) ``` Edge Cases: - If `D` or `CLK` is not within the range {0, 1}, the function should raise a `ValueError`. - Example: `d_flip_flop(2, 1)` should raise a ValueError with message \\"Inputs D and CLK must be 0 or 1\\". Implementation Details: Maintain an internal state for Q that initializes to 0. Based on the value of `CLK`, update the state of Q accordingly and return the current state of Q. Implement the following skeleton code: ```python class DFlipFlop: def __init__(self): self.Q = 0 def update(self, D: int, CLK: int) -> int: Implement a D flip-flop. :param D: The input value (0 or 1). :param CLK: The clock signal (0 or 1). Update Q when CLK is 1. :return: The current state of Q after processing the input D and CLK. If D or CLK is not 0 or 1, raise a ValueError. if D not in (0, 1) or CLK not in (0, 1): raise ValueError(\\"Inputs D and CLK must be 0 or 1\\") if CLK == 1: self.Q = D return self.Q # Usage example: dff = DFlipFlop() print(dff.update(1, 1)) # Output: 1 print(dff.update(0, 0)) # Output: 1 print(dff.update(0, 1)) # Output: 0 print(dff.update(1, 0)) # Output: 0 ```","solution":"class DFlipFlop: def __init__(self): self.Q = 0 def update(self, D: int, CLK: int) -> int: Implement a D flip-flop. :param D: The input value (0 or 1). :param CLK: The clock signal (0 or 1). Update Q when CLK is 1. :return: The current state of Q after processing the input D and CLK. If D or CLK is not 0 or 1, raise a ValueError. if D not in (0, 1) or CLK not in (0, 1): raise ValueError(\\"Inputs D and CLK must be 0 or 1\\") if CLK == 1: self.Q = D return self.Q"},{"question":"# Problem: Kth Smallest Element in an Array You are given an unsorted array of distinct integers and an integer `k`. Your task is to find the kth smallest element in this array. Write a function `kth_smallest_element(arr: list, k: int) -> int` that returns the k-th smallest element in the given array. Function Signature `def kth_smallest_element(arr: list, k: int) -> int:` Input - A list `arr` of distinct integers (1 ≤ len(arr) ≤ 10^5) - An integer `k` (1 ≤ k ≤ len(arr)) Output - An integer representing the k-th smallest element in the array. Constraints - The array contains distinct integers, so no repeated elements. - The input integer `k` is always a valid index within the array bounds. Example ```python >>> kth_smallest_element([3, 1, 5, 7, 2], 3) 3 >>> kth_smallest_element([10, 4, 5, 8, 6, 11, 26], 4) 8 >>> kth_smallest_element([12, 3, 5, 7, 19], 2) 5 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 ``` Explanation - For the input `[3, 1, 5, 7, 2]` with `k = 3`, the sorted array is `[1, 2, 3, 5, 7]` and the 3rd smallest element is `3`. - For the input `[10, 4, 5, 8, 6, 11, 26]` with `k = 4`, the sorted array is `[4, 5, 6, 8, 10, 11, 26]` and the 4th smallest element is `8`. - For the input `[12, 3, 5, 7, 19]` with `k = 2`, the sorted array is `[3, 5, 7, 12, 19]` and the 2nd smallest element is `5`. - For the input `[7, 10, 4, 3, 20, 15]` with `k = 3`, the sorted array is `[3, 4, 7, 10, 15, 20]` and the 3rd smallest element is `7`. This problem will test your understanding of array manipulation, sorting algorithms, and efficient selection algorithms.","solution":"def kth_smallest_element(arr, k): Returns the k-th smallest element in the given array. arr.sort() return arr[k - 1]"},{"question":"# Context Your task is to develop a `Queue` class which implements a double-ended queue (deque) using a doubly linked list. This queue should support operations to add and remove elements from both the front and the rear, providing efficient O(1) time complexity for these operations. # Task Implement the `Queue` class along with a supporting `Node` class to handle each element in the queue. Ensure that the `Queue` class can pass the given test scenarios. # Requirements 1. **Node Class**: * Constructor: `Node(value, prev=None, next=None)` initializes a node with the given value. 2. **Queue Class**: * Constructor: `Queue()` initializes an empty queue. * Methods: - `appendleft(self, value)`: Inserts an element at the front of the queue. - `append(self, value)`: Inserts an element at the end of the queue. - `popleft(self)`: Removes and returns the element from the front of the queue. - `pop(self)`: Removes and returns the element from the end of the queue. - `__len__(self)`: Returns the number of elements in the queue. - `__str__(self)`: Returns a string representation of the queue for debugging. # Example ```python # Example with basic operations q = Queue() q.append(1) q.append(2) q.appendleft(0) assert str(q) == \\"[0, 1, 2]\\" assert len(q) == 3 assert q.popleft() == 0 assert q.pop() == 2 assert len(q) == 1 q.appendleft(3) assert str(q) == \\"[3, 1]\\" assert q.popleft() == 3 assert q.popleft() == 1 assert len(q) == 0 ``` You must ensure your implementation handles edge cases such as adding and removing elements from an empty queue, as well as maintaining the correct order of elements.","solution":"class Node: def __init__(self, value, prev=None, next=None): self.value = value self.prev = prev self.next = next class Queue: def __init__(self): self.head = None self.tail = None self._size = 0 def appendleft(self, value): new_node = Node(value, next=self.head) if self.head: self.head.prev = new_node self.head = new_node if not self.tail: self.tail = new_node self._size += 1 def append(self, value): new_node = Node(value, prev=self.tail) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self._size += 1 def popleft(self): if not self.head: raise IndexError(\\"popleft from an empty queue\\") value = self.head.value self.head = self.head.next if self.head: self.head.prev = None else: self.tail = None self._size -= 1 return value def pop(self): if not self.tail: raise IndexError(\\"pop from an empty queue\\") value = self.tail.value self.tail = self.tail.prev if self.tail: self.tail.next = None else: self.head = None self._size -= 1 return value def __len__(self): return self._size def __str__(self): values = [] current = self.head while current: values.append(current.value) current = current.next return str(values)"},{"question":"# Scenario You are developing a system for a warehouse that manages the inventory of various products. Each product has a unique identifier and a certain amount of stock. Your task is to implement a function that helps warehouse staff determine whether an order can be fulfilled based on current stock levels. # Function Details Implement a function `can_fulfill_order` that takes two parameters: - `product_stock` (dictionary): A dictionary where keys are product identifiers (strings) and values are integers representing the current stock level of each product. - `order` (dictionary): A dictionary where keys are product identifiers (strings) and values are integers representing the amount of each product needed to fulfill the order. The function should return `True` if the order can be completely fulfilled with the available stock, and `False` otherwise. # Requirements - The function should handle cases where some products in the order are not present in the stock (consider the unavailable product\'s stock as zero). - The function does not modify the input dictionaries. # Input and Output - **Input**: - `product_stock` (dict): Current stock levels of products. - `order` (dict): Required quantities for the order. - **Output**: - Return a boolean value indicating if the order can be fulfilled. # Constraints - All product identifiers are non-empty strings. - Stock levels and order quantities are non-negative integers. # Example ```python # Example of a function call product_stock = {\'apple\': 10, \'banana\': 5, \'orange\': 8} order = {\'apple\': 4, \'banana\': 5, \'orange\': 10} print(can_fulfill_order(product_stock, order)) # Expected output: False order = {\'apple\': 4, \'banana\': 5} print(can_fulfill_order(product_stock, order)) # Expected output: True order = {\'apple\': 10, \'banana\': 2, \'orange\': 5} print(can_fulfill_order(product_stock, order)) # Expected output: True ``` # Notes Consider edge cases such as when the order is empty (should return `True`) or when the stock is empty (should return `False` for any non-empty order). The function should efficiently check the availability of each product in the order against the product stock.","solution":"def can_fulfill_order(product_stock, order): Determines if the order can be fulfilled with the available stock. Parameters: product_stock (dict): Current stock levels of products. order (dict): Required quantities for the order. Returns: bool: True if the order can be fulfilled with available stock, False otherwise. for product, quantity_needed in order.items(): if product_stock.get(product, 0) < quantity_needed: return False return True"},{"question":"# Sudoku Solver Scenario Your team is developing an AI-powered puzzle game that includes a variety of classic puzzles, one of which is Sudoku. As part of the backend, you need to implement a function that can solve any given Sudoku puzzle efficiently. Task Implement the function `solve_sudoku` which takes a partially filled 9x9 grid and solves it using backtracking algorithm. Requirements * **Function Signature**: ```python def solve_sudoku(board: list[list[int]]) -> bool: ``` * **Input**: - `board` (list[list[int]]): A 9x9 grid representing a Sudoku puzzle, where 0 indicates an empty cell. * **Output**: - (bool): Return `True` if the Sudoku puzzle is solvable and the board is modified in-place with the solution. Return `False` if the puzzle cannot be solved. * **Constraints**: - The board is a 9x9 list of lists containing integers between 0 and 9 (inclusive). - You must modify the puzzle grid in-place. * **Performance Requirements**: - The function should solve the puzzle in a reasonable time for typical puzzles. Example ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solve_sudoku(board) print(board) ``` Output: ```python [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ```","solution":"def solve_sudoku(board): Solves the Sudoku puzzle using backtracking. :param board: 9x9 grid representing the Sudoku board (0 indicates empty cell) :return: True if a solution is found, else False def is_valid(num, pos): # Check row for i in range(9): if board[pos[0]][i] == num and pos[1] != i: return False # Check column for i in range(9): if board[i][pos[1]] == num and pos[0] != i: return False # Check box box_x = pos[1] // 3 box_y = pos[0] // 3 for i in range(box_y*3, box_y*3 + 3): for j in range(box_x*3, box_x*3 + 3): if board[i][j] == num and (i, j) != pos: return False return True def solve(): for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(num, (i, j)): board[i][j] = num if solve(): return True board[i][j] = 0 return False return True return solve()"},{"question":"# Coding Assessment Question: Simulating Random Walk in a 2D Grid You are tasked with implementing a random walk simulation algorithm in Python. This algorithm involves moving a point randomly on a 2D grid and simulating the walk for a given number of steps. Objective: Write a function named `random_walk_2d` that accepts the number of steps as an integer and returns the final position on the 2D grid after completing the random walk. Function Signature: ```python def random_walk_2d(steps: int) -> Tuple[int, int]: pass ``` # Requirements 1. **Input**: * `steps` (int): The number of steps for the random walk. Must be a positive integer and less than or equal to 1000. 2. **Output**: * `Tuple[int, int]`: A tuple representing the final position `(x, y)` of the point on the 2D grid. 3. **Constraints**: * If `steps` is a non-integer, negative, or greater than 1000, raise an appropriate error (`TypeError` or `ValueError`). 4. **Performance**: * Ensure the function performs efficiently for the given constraints. * Make use of random.choice or similar methods to determine the direction of each step (up, down, left, right). # Guidelines: 1. **Initialization**: * Start the walk at the origin `(0, 0)`. 2. **Random Movement**: * For each step, choose a random direction from {up, down, left, right}. * Update the position accordingly: - Up: Increment y by 1 - Down: Decrement y by 1 - Left: Decrement x by 1 - Right: Increment x by 1 # Example: ```python >>> random_walk_2d(10) (3, -1) # Note: Output will vary as the walk is random. >>> random_walk_2d(-5) Traceback (most recent call last): ... ValueError: number of steps must be > 0. >>> random_walk_2d(\'a\') Traceback (most recent call last): ... TypeError: number of steps must be an integer. >>> random_walk_2d(1500) Traceback (most recent call last): ... ValueError: number of steps too large to simulate (>1000). ``` Make sure your implementation follows the error-checking and edge case handling as per the example outputs.","solution":"import random from typing import Tuple def random_walk_2d(steps: int) -> Tuple[int, int]: Simulate a random walk of \'steps\' steps in a 2D grid. :param steps: int - The number of steps for the random walk. :return: Tuple[int, int] - The final position (x, y) of the point on the 2D grid. if not isinstance(steps, int): raise TypeError(\\"number of steps must be an integer.\\") if steps <= 0: raise ValueError(\\"number of steps must be > 0.\\") if steps > 1000: raise ValueError(\\"number of steps too large to simulate (>1000).\\") x, y = 0, 0 for _ in range(steps): direction = random.choice([\'up\', \'down\', \'left\', \'right\']) if direction == \'up\': y += 1 elif direction == \'down\': y -= 1 elif direction == \'left\': x -= 1 elif direction == \'right\': x += 1 return x, y"},{"question":"# Temperature Converter (Advanced Version) In this task, you are required to design a temperature converter that can handle multiple temperature scales and convert between them with a high degree of precision. Implement a function `convert_temperature(value: float, from_scale: str, to_scale: str) -> float` that: 1. Takes a float `value` representing the temperature to be converted. 2. Takes two strings `from_scale` and `to_scale`, which indicate the scales to convert from and to, respectively. Valid scales are \\"C\\" for Celsius, \\"F\\" for Fahrenheit, and \\"K\\" for Kelvin. 3. Converts the temperature from the `from_scale` to the `to_scale` with high precision. **Requirements**: - **Input**: - `value`: A float representing the temperature. - `from_scale` and `to_scale`: Strings, each should be one of \\"C\\", \\"F\\", or \\"K\\". - **Output**: A float representing the converted temperature in the target scale. **Additional Constraints**: - Raise a `ValueError` if `from_scale` or `to_scale` is not among \\"C\\", \\"F\\", or \\"K\\". - Handle the absolute zero case in Kelvin correctly (e.g., do not allow converting below 0 Kelvin). **Conversion Formulas**: - Celsius to Fahrenheit: `(C * 9/5) + 32` - Fahrenheit to Celsius: `(F - 32) * 5/9` - Celsius to Kelvin: `C + 273.15` - Kelvin to Celsius: `K - 273.15` - Fahrenheit to Kelvin: `(F - 32) * 5/9 + 273.15` - Kelvin to Fahrenheit: `(K - 273.15) * 9/5 + 32` ```python def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: Convert temperature from one scale to another with precision. Args: value (float): Temperature value to be converted. from_scale (str): The scale to convert from (\\"C\\", \\"F\\", or \\"K\\"). to_scale (str): The scale to convert to (\\"C\\", \\"F\\", or \\"K\\"). Returns: float: Converted temperature value in the target scale. Raises: ValueError: If scales are not valid or if temperature is below absolute zero pass ``` # Example Cases: 1. `convert_temperature(100, \\"C\\", \\"F\\")` should return `212.0` for converting boiling point of water from Celsius to Fahrenheit. 2. `convert_temperature(32, \\"F\\", \\"C\\")` should return `0.0` for converting freezing point of water from Fahrenheit to Celsius. 3. `convert_temperature(0, \\"C\\", \\"K\\")` should return `273.15` for converting from Celsius to Kelvin. 4. `convert_temperature(273.15, \\"K\\", \\"C\\")` should return `0.0` for converting from Kelvin to Celsius. 5. `convert_temperature(373.15, \\"K\\", \\"F\\")` should return `212.0` for converting boiling point of water from Kelvin to Fahrenheit. 6. `convert_temperature(-40, \\"F\\", \\"C\\")` should return `-40.0` for converting -40 degrees (where Celsius and Fahrenheit scales converge).","solution":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: Convert temperature from one scale to another with precision. Args: value (float): Temperature value to be converted. from_scale (str): The scale to convert from (\\"C\\", \\"F\\", or \\"K\\"). to_scale (str): The scale to convert to (\\"C\\", \\"F\\", or \\"K\\"). Returns: float: Converted temperature value in the target scale. Raises: ValueError: If scales are not valid or if temperature is below absolute zero if from_scale not in {\\"C\\", \\"F\\", \\"K\\"} or to_scale not in {\\"C\\", \\"F\\", \\"K\\"}: raise ValueError(\\"Invalid temperature scale. Valid scales are \'C\', \'F\', or \'K\'.\\") if from_scale == \\"K\\" and value < 0: raise ValueError(\\"Temperature value cannot be below absolute zero (0 K).\\") if from_scale == to_scale: return value # Intermediate conversion to Celsius if from_scale == \\"C\\": celsius = value elif from_scale == \\"F\\": celsius = (value - 32) * 5/9 elif from_scale == \\"K\\": celsius = value - 273.15 # Convert from Celsius to target scale if to_scale == \\"C\\": return celsius elif to_scale == \\"F\\": return celsius * 9/5 + 32 elif to_scale == \\"K\\": return celsius + 273.15"},{"question":"# Coding Assessment Question Your task is to implement the following function: ```python def binary_to_ip(binary: str) -> str: Convert a binary string representing a 32-bit IP address to its standard dotted decimal format. A valid 32-bit IP address consists of four 8-bit sections. Each section is converted from binary to decimal and separated by a dot. Args: binary (str): A 32-bit string of \'0\'s and \'1\'s representing the IP address. Returns: str: The IP address in standard dotted decimal notation. # Your implementation here pass ``` # Detailed Specifications and Constraints: 1. **Inputs**: - `binary` (str): 32-bit binary string (length: 32, containing only \'0\'s and \'1\'s). 2. **Outputs**: - Returns a string representing the IP address in the format `xxx.xxx.xxx.xxx`. 3. **Edge Cases**: - Input with all \'0\'s representing the IP `0.0.0.0`. - Input with all \'1\'s representing the IP `255.255.255.255`. 4. **Performance Requirements**: - The function should run in O(1) time. - The function should use constant space O(1). # Testing: Use the following test cases to validate your implementation: ```python assert binary_to_ip(\\"00000000000000000000000000000000\\") == \\"0.0.0.0\\" assert binary_to_ip(\\"11111111111111111111111111111111\\") == \\"255.255.255.255\\" assert binary_to_ip(\\"11000000101010000000000100000001\\") == \\"192.168.1.1\\" assert binary_to_ip(\\"10101100000100000000001000000110\\") == \\"172.16.2.6\\" assert binary_to_ip(\\"01111111000000000000000100000001\\") == \\"127.0.1.1\\" ``` Feel free to add more test cases to thoroughly validate edge cases and ensure the accuracy of your implementation.","solution":"def binary_to_ip(binary: str) -> str: Convert a binary string representing a 32-bit IP address to its standard dotted decimal format. A valid 32-bit IP address consists of four 8-bit sections. Each section is converted from binary to decimal and separated by a dot. Args: binary (str): A 32-bit string of \'0\'s and \'1\'s representing the IP address. Returns: str: The IP address in standard dotted decimal notation. parts = [ str(int(binary[i:i+8], 2)) for i in range(0, 32, 8) ] return \'.\'.join(parts)"},{"question":"# Divisible Triangular Numbers A triangular number or triangle number is a number that can be represented in the form of a triangle with dots. The ( n )th triangular number ( T_n ) is the sum of the first ( n ) natural numbers, i.e., ( T_n = frac{n(n+1)}{2} ). You are tasked with writing a function that finds the smallest triangular number that has over ( D ) divisors. To solve this: * Compute triangular numbers iteratively. * Count the number of divisors for each triangular number. * Return the first triangular number with more than ( D ) divisors. Task: Implement the function `find_triangle_number_with_divisors(D: int) -> int` that: * Takes an integer ( D ) (( 1 leq D leq 500 )). * Returns the smallest triangular number that has more than ( D ) divisors. # Input: * An integer ( D ), the threshold for the number of divisors. # Output: * An integer representing the smallest triangular number with more than ( D ) divisors. # Examples: ```python assert find_triangle_number_with_divisors(5) == 28 assert find_triangle_number_with_divisors(100) == 73920 assert find_triangle_number_with_divisors(500) == 76576500 ``` # Constraints: * Use efficient methods to count divisors, considering the limit ( D leq 500 ). * Ensure the solution scales appropriately for larger values of ( D ). # Note: * Use the relationship ( T_n = frac{n(n+1)}{2} ) to generate triangular numbers. * Count the number of divisors efficiently to achieve the desired performance.","solution":"def count_divisors(n): Helper function to count the divisors of a given number n. count = 0 sqrt_n = int(n**0.5) for i in range(1, sqrt_n + 1): if n % i == 0: if i * i == n: count += 1 else: count += 2 return count def find_triangle_number_with_divisors(D): Finds the smallest triangular number with more than D divisors. n = 1 while True: triangle_number = n * (n + 1) // 2 if count_divisors(triangle_number) > D: return triangle_number n += 1"},{"question":"# Objective You are tasked with implementing a basic library management system. In this task, you need to create a system that keeps track of books and patrons who borrow them. Your task is to implement classes to simulate this system and define functions to get relevant information from it. # Task 1. Implement a class `Book` that has the following properties: - `title` (string) - `author` (string) - `year` (integer) - `borrowed_by` (string, which is None when the book is not borrowed) 2. Implement a class `Patron` with: - `name` (string) - `borrowed_books` (list of Book objects) 3. Implement a class `Library` with: - `books` (a list of Book objects) - `patrons` (a list of Patron objects) 4. Implement methods in the `Library` class: - `add_book(book: Book) -> None`: Adds a book to the library. - `register_patron(patron: Patron) -> None`: Registers a patron in the library. - `borrow_book(book_title: str, patron_name: str) -> str`: Lets a patron borrow a book by title. Returns a success message if the book was borrowed successfully; returns an error message if the book is not available. - `return_book(book_title: str, patron_name: str) -> str`: Lets a patron return a borrowed book by title. Returns a success message if the book was returned successfully; returns an error message if the book was not borrowed by the specified patron. - `list_available_books() -> List[str]`: Returns a list of titles of books that are currently available for borrowing. - `list_borrowed_books(patron_name: str) -> List[str]`: Returns a list of titles of books borrowed by a specific patron. # Input and Output Formats Method: `add_book` * **Input**: - `book` (Book): The book to add to the library. * **Output**: - None Method: `register_patron` * **Input**: - `patron` (Patron): The patron to register in the library. * **Output**: - None Method: `borrow_book` * **Input**: - `book_title` (str): The title of the book to borrow. - `patron_name` (str): The name of the patron borrowing the book. * **Output**: - A message indicating success or failure. Method: `return_book` * **Input**: - `book_title` (str): The title of the book to return. - `patron_name` (str): The name of the patron returning the book. * **Output**: - A message indicating success or failure. Method: `list_available_books` * **Input**: - None * **Output**: - A list of strings representing the titles of available books. Method: `list_borrowed_books` * **Input**: - `patron_name` (str): The name of the patron whose borrowed books should be listed. * **Output**: - A list of strings representing the titles of books borrowed by the patron. # Example ```python class Book: def __init__(self, title: str, author: str, year: int): self.title = title self.author = author self.year = year self.borrowed_by = None class Patron: def __init__(self, name: str): self.name = name self.borrowed_books = [] class Library: def __init__(self): self.books = [] self.patrons = [] def add_book(self, book: Book) -> None: self.books.append(book) def register_patron(self, patron: Patron) -> None: self.patrons.append(patron) def borrow_book(self, book_title: str, patron_name: str) -> str: for book in self.books: if book.title == book_title and book.borrowed_by is None: for patron in self.patrons: if patron.name == patron_name: book.borrowed_by = patron_name patron.borrowed_books.append(book) return f\\"{patron_name} successfully borrowed {book_title}.\\" return f\\"{book_title} is not available.\\" def return_book(self, book_title: str, patron_name: str) -> str: for patron in self.patrons: if patron.name == patron_name: for book in patron.borrowed_books: if book.title == book_title: patron.borrowed_books.remove(book) book.borrowed_by = None return f\\"{patron_name} successfully returned {book_title}.\\" return f\\"{patron_name} did not borrow {book_title}.\\" def list_available_books(self) -> list: return [book.title for book in self.books if book.borrowed_by is None] def list_borrowed_books(self, patron_name: str) -> list: for patron in self.patrons: if patron.name == patron_name: return [book.title for book in patron.borrowed_books] return [] # Example usage library = Library() book1 = Book(\\"1984\\", \\"George Orwell\\", 1949) book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) patron1 = Patron(\\"Alice\\") library.add_book(book1) library.add_book(book2) library.register_patron(patron1) print(library.borrow_book(\\"1984\\", \\"Alice\\")) # Alice successfully borrowed 1984. print(library.list_available_books()) # [\'To Kill a Mockingbird\'] print(library.return_book(\\"1984\\", \\"Alice\\")) # Alice successfully returned 1984. print(library.list_borrowed_books(\\"Alice\\")) # [] ``` In the example, you set up the library, add books, register a patron, borrow and return books, and list available and borrowed books as specified.","solution":"class Book: def __init__(self, title: str, author: str, year: int): self.title = title self.author = author self.year = year self.borrowed_by = None class Patron: def __init__(self, name: str): self.name = name self.borrowed_books = [] class Library: def __init__(self): self.books = [] self.patrons = [] def add_book(self, book: Book) -> None: self.books.append(book) def register_patron(self, patron: Patron) -> None: self.patrons.append(patron) def borrow_book(self, book_title: str, patron_name: str) -> str: for book in self.books: if book.title == book_title and book.borrowed_by is None: for patron in self.patrons: if patron.name == patron_name: book.borrowed_by = patron_name patron.borrowed_books.append(book) return f\\"{patron_name} successfully borrowed {book_title}.\\" return f\\"{book_title} is not available.\\" def return_book(self, book_title: str, patron_name: str) -> str: for patron in self.patrons: if patron.name == patron_name: for book in patron.borrowed_books: if book.title == book_title: patron.borrowed_books.remove(book) book.borrowed_by = None return f\\"{patron_name} successfully returned {book_title}.\\" return f\\"{patron_name} did not borrow {book_title}.\\" def list_available_books(self) -> list: return [book.title for book in self.books if book.borrowed_by is None] def list_borrowed_books(self, patron_name: str) -> list: for patron in self.patrons: if patron.name == patron_name: return [book.title for book in patron.borrowed_books] return [] # Example usage - Commented out for unit test automation # library = Library() # book1 = Book(\\"1984\\", \\"George Orwell\\", 1949) # book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) # patron1 = Patron(\\"Alice\\") # library.add_book(book1) # library.add_book(book2) # library.register_patron(patron1) # print(library.borrow_book(\\"1984\\", \\"Alice\\")) # Alice successfully borrowed 1984. # print(library.list_available_books()) # [\'To Kill a Mockingbird\'] # print(library.return_book(\\"1984\\", \\"Alice\\")) # Alice successfully returned 1984. # print(library.list_borrowed_books(\\"Alice\\")) # []"},{"question":"# KD-Tree Nearest Neighbor Search In this assessment, your task is to implement a function using the KD-Tree algorithm for finding the nearest neighbor of a given point in a set of points in a multi-dimensional space. You will complete the code snippet provided and ensure it meets the specifications detailed below. Task Description: Implement a function `find_nearest_neighbor` that constructs a KD-Tree from a given set of points and then finds the nearest neighbor to a query point. Function Signature: ```python def find_nearest_neighbor(points: list[list[float]], query: list[float]) -> list[float]: ``` Input: * `points` (List[List[float]]): A list of points where each point is a list of coordinates in multidimensional space. * `query` (List[float]): A list of coordinates representing the query point. Output: * Returns the point from the list of points that is nearest to the query point. The nearest distance is measured using Euclidean distance. Constraints: * 1 ≤ len(points) ≤ 10000 * 1 ≤ len(points[0]) ≤ 10 (i.e., the number of dimensions of each point is between 1 and 10) * The coordinates of points and the query point are floating-point numbers. Example: ```python points = [ [1.0, 2.0], [3.0, 4.0], [2.5, 5.0], [6.0, 1.0], [0.0, 1.0] ] query = [2.0, 2.0] print(find_nearest_neighbor(points, query)) # Output: [1.0, 2.0] ``` Key Directions: 1. Ensure the function `find_nearest_neighbor` constructs the KD-Tree efficiently and performs a nearest neighbor search. 2. Minimize memory usage and optimize performance. 3. Handle edge cases where the points are fewer than one or all points are equidistant to the query point. 4. Write efficient and readable code, and provide adequate inline comments for clarity. Hints: 1. You can use a recursive function to construct the KD-Tree. 2. Use a priority queue or a min-heap to manage potential nearest neighbors candidate during the search. 3. Consider edge cases where the points list contains only one point. ```python class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right def find_nearest_neighbor(points, query): def build_kd_tree(points, depth=0): if not points: return None k = len(points[0]) axis = depth % k points.sort(key=lambda x: x[axis]) median = len(points) // 2 return KDTreeNode( point=points[median], left=build_kd_tree(points[:median], depth+1), right=build_kd_tree(points[median+1:], depth+1) ) def euclidean_distance(point1, point2): return sum((a - b) ** 2 for a, b in zip(point1, point2)) ** 0.5 def closest_point(point1, point2, query): if point1 is None: return point2 if point2 is None: return point1 if euclidean_distance(point1, query) < euclidean_distance(point2, query): return point1 else: return point2 def search_kd_tree(node, query, depth=0): if node is None: return None k = len(query) axis = depth % k next_branch = None opposite_branch = None if query[axis] < node.point[axis]: next_branch = node.left opposite_branch = node.right else: next_branch = node.right opposite_branch = node.left best = closest_point( node.point, search_kd_tree(next_branch, query, depth+1), query ) if euclidean_distance(query, best) > abs(query[axis] - node.point[axis]): best = closest_point( best, search_kd_tree(opposite_branch, query, depth+1), query ) return best kd_tree = build_kd_tree(points) return search_kd_tree(kd_tree, query) ```","solution":"import math class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right def find_nearest_neighbor(points, query): def build_kd_tree(points, depth=0): if not points: return None k = len(points[0]) axis = depth % k points.sort(key=lambda x: x[axis]) median = len(points) // 2 return KDTreeNode( point=points[median], left=build_kd_tree(points[:median], depth+1), right=build_kd_tree(points[median+1:], depth+1) ) def euclidean_distance(point1, point2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def closest_point(point1, point2, query): if point1 is None: return point2 if point2 is None: return point1 if euclidean_distance(point1, query) < euclidean_distance(point2, query): return point1 else: return point2 def search_kd_tree(node, query, depth=0): if node is None: return None k = len(query) axis = depth % k next_branch = None opposite_branch = None if query[axis] < node.point[axis]: next_branch = node.left opposite_branch = node.right else: next_branch = node.right opposite_branch = node.left best = closest_point( node.point, search_kd_tree(next_branch, query, depth+1), query ) if euclidean_distance(query, best) > abs(query[axis] - node.point[axis]): best = closest_point( best, search_kd_tree(opposite_branch, query, depth+1), query ) return best kd_tree = build_kd_tree(points) return search_kd_tree(kd_tree, query)"},{"question":"# Binary Search Tree Reconstruction You are given an array that represents the level-order traversal of a Binary Search Tree (BST). Your task is to reconstruct the original BST from this traversal and implement functionalities to perform in-order, pre-order, and post-order traversals. Implement a class `BSTReconstructor` that supports: 1. **Reconstructing** the BST from the given level-order traversal. 2. **Printing the in-order traversal** of the BST. 3. **Printing the pre-order traversal** of the BST. 4. **Printing the post-order traversal** of the BST. Input and Output Formats * **Initialization**: - Input: `level_order`, a list of integers representing the level-order traversal of a BST. - Example: `level_order = [10, 5, 15, 2, 7, 12, 18]` * **Traversals**: - Method 1: `in_order()` - Output: Returns a list of integers representing the in-order traversal of the BST. - Example: Given `level_order = [10, 5, 15, 2, 7, 12, 18]`, the in-order traversal should return `[2, 5, 7, 10, 12, 15, 18]`. - Method 2: `pre_order()` - Output: Returns a list of integers representing the pre-order traversal of the BST. - Example: Given `level_order = [10, 5, 15, 2, 7, 12, 18]`, the pre-order traversal should return `[10, 5, 2, 7, 15, 12, 18]`. - Method 3: `post_order()` - Output: Returns a list of integers representing the post-order traversal of the BST. - Example: Given `level_order = [10, 5, 15, 2, 7, 12, 18]`, the post-order traversal should return `[2, 7, 5, 12, 18, 15, 10]`. Implementation Requirements 1. Ensure that the BST properties are maintained during reconstruction. 2. Each traversal method should operate in O(N) time. 3. Handle invalid or empty input gracefully. ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BSTReconstructor: def __init__(self, level_order): self.root = self.construct_bst(level_order) def construct_bst(self, level_order): # Reconstruct the BST based on level-order traversal # Implement the reconstruction method def in_order(self): # Perform in-order traversal and return the result as a list # Implement the in-order traversal method def pre_order(self): # Perform pre-order traversal and return the result as a list # Implement the pre-order traversal method def post_order(self): # Perform post-order traversal and return the result as a list # Implement the post-order traversal method ``` **Note**: Implement the `BSTReconstructor` class methods, ensuring that the BST is reconstructed and traversed correctly from the provided level-order input.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BSTReconstructor: def __init__(self, level_order): self.root = self.construct_bst(level_order) def construct_bst(self, level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [(root, float(\'-inf\'), float(\'inf\'))] i = 1 while i < len(level_order): node, lower, upper = queue.pop(0) if lower < level_order[i] < node.val: node.left = TreeNode(level_order[i]) queue.append((node.left, lower, node.val)) i += 1 if i < len(level_order) and node.val < level_order[i] < upper: node.right = TreeNode(level_order[i]) queue.append((node.right, node.val, upper)) i += 1 return root def in_order(self): result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, node, result): if node: self._in_order_helper(node.left, result) result.append(node.val) self._in_order_helper(node.right, result) def pre_order(self): result = [] self._pre_order_helper(self.root, result) return result def _pre_order_helper(self, node, result): if node: result.append(node.val) self._pre_order_helper(node.left, result) self._pre_order_helper(node.right, result) def post_order(self): result = [] self._post_order_helper(self.root, result) return result def _post_order_helper(self, node, result): if node: self._post_order_helper(node.left, result) self._post_order_helper(node.right, result) result.append(node.val)"},{"question":"# Coding Question Scenario You\'re building a tool to analyze the performance of athletes in a series of events. Each athlete competes in multiple events and you are given their scores for each event. You need to determine the athlete with the highest average score across all events. If there is a tie, select the athlete with the smallest numerical identifier. Objective Implement the `find_top_athlete` function that identifies the athlete with the highest average score and returns their identifier. Function Signature ```python def find_top_athlete(scores: dict[int, list[float]]) -> int: ``` Input * A dictionary where keys are athlete identifiers (integers) and values are lists of float numbers representing their scores in different events. Output * The identifier (integer) of the athlete with the highest average score. Constraints * The number of athletes can range from 1 to 10^5. * Each athlete can have between 1 and 1000 scores. * Scores are floating-point numbers and can range between 0.0 and 100.0 inclusive. * There will always be at least one athlete in the input dictionary. Example ```python assert find_top_athlete({1: [69.5, 70.0, 80.0], 2: [88.0, 78.5, 90.5], 3: [95.0, 90.0, 85.0]}) == 3 assert find_top_athlete({10: [100.0], 20: [99.9, 100.0], 30: [100.0, 100.0]}) == 30 assert find_top_athlete({5: [50.5, 40.0], 15: [100.0, 60.0], 25: [70.0, 85.0]}) == 15 ``` Constraints & Performance Requirements * The function should run efficiently even if the number of athletes or scores is large. * Ensure that the function handles edge cases, such as all athletes having the same average score. Instructions 1. Implement the function `find_top_athlete`. 2. Write your implementation to pass all the given example cases. 3. Make sure to handle ties by choosing the athlete with the smallest identifier. # Solution Approach: You can calculate the average score for each athlete and track the athlete with the highest average score. In case of a tie, update your result based on the smallest identifier.","solution":"def find_top_athlete(scores: dict[int, list[float]]) -> int: top_athlete = None highest_avg_score = float(\'-inf\') for athlete, score_list in scores.items(): avg_score = sum(score_list) / len(score_list) if avg_score > highest_avg_score or (avg_score == highest_avg_score and athlete < top_athlete): top_athlete = athlete highest_avg_score = avg_score return top_athlete"},{"question":"# Problem Statement You are developing a flight booking system that allows customers to find flights between cities based on direct connections. To accomplish this, you need to implement a function that determines if a direct flight exists between two cities using a given list of direct routes. Write a Python function named `find_flight()` that takes the following parameters: - `routes`: A list of lists where each sublist represents a direct route between two cities. Each sublist contains exactly two elements, representing the source and destination cities. - `source`: A string representing the starting city. - `destination`: A string representing the target city. The function should return `True` if there is a direct flight from the `source` city to the `destination` city, and `False` otherwise. # Input - `routes`: A list of lists where each sublist `[A, B]` denotes a direct flight from city A to city B. - `source`: A string representing the source city. - `destination`: A string representing the destination city. # Output - A boolean value `True` if a direct flight exists from `source` to `destination`, and `False` otherwise. # Constraints - The number of routes will be between (1) and (10^4). - Cities are represented as strings with lengths between (1) and (100) characters. - All routes are directed, meaning `[A, B]` does not imply `[B, A]`. # Example ```python # Example usage routes = [ [\\"New York\\", \\"Los Angeles\\"], [\\"Los Angeles\\", \\"Chicago\\"], [\\"Chicago\\", \\"Houston\\"], [\\"Houston\\", \\"Miami\\"], [\\"Miami\\", \\"New York\\"] ] print(find_flight(routes, \\"New York\\", \\"Los Angeles\\")) # Output: True print(find_flight(routes, \\"Los Angeles\\", \\"New York\\")) # Output: False print(find_flight(routes, \\"Miami\\", \\"Houston\\")) # Output: False print(find_flight(routes, \\"Chicago\\", \\"Houston\\")) # Output: True ``` # Note - Each city may appear in multiple routes. - It\'s guaranteed that cities and routes are case-sensitive (i.e., `\\"New York\\"` is different from `\\"new york\\"`).","solution":"def find_flight(routes, source, destination): Determines if there is a direct flight from source to destination. :param routes: List of lists where each inner list represents a route [source_city, destination_city] :param source: Source city :param destination: Destination city :return: True if a direct flight exists, False otherwise for route in routes: if route[0] == source and route[1] == destination: return True return False"},{"question":"# Problem Statement **Character Frequency Sort** You are tasked with creating a function that sorts a string based on the frequency of each character. Characters that appear more frequently should come before those with lower frequencies. If two characters have the same frequency, they should appear in the order of their first occurrence in the original string. # Task Write a function `frequency_sort(s: str) -> str` that takes a string `s` and returns a new string sorted by the frequency of each character, with ties broken by the order of first appearance. # Input Format * A string `s` ( (1 leq text{len}(s) leq 10^5 ) ). # Output Format * A string sorted by the frequency of characters in descending order, with ties broken by order of first appearance. # Constraints * The function should handle large strings efficiently. * All input strings will only contain printable ASCII characters. # Example *Example 1:* Input: ``` s = \\"tree\\" ``` Output: ``` eetr ``` *Example 2:* Input: ``` s = \\"cccaaa\\" ``` Output: ``` cccaaa ``` *Example 3:* Input: ``` s = \\"Aabb\\" ``` Output: ``` bbAa ``` # Notes * In the first example, \'e\' appears twice while \'t\' and \'r\' appear once. Hence, \'e\' is placed before \'t\' and \'r\', and \'t\' and \'r\' maintain their relative order. * In the second example, \'c\' and \'a\' both appear three times. Hence, they remain in their relative order. * In the third example, uppercase \'A\' appears once, while lowercase \'b\' appears twice, and lowercase \'a\' appears once. \'b\' appears before \'A\' and \'a\'. Implement the function `frequency_sort` as specified: ```python from collections import Counter def frequency_sort(s: str) -> str: pass ```","solution":"from collections import Counter def frequency_sort(s: str) -> str: Returns a string sorted by the frequency of characters in descending order, with ties broken by order of first appearance. # Count the frequency of each character freq = Counter(s) # Sort characters by frequency (high to low) and if same frequency by first appearance sorted_chars = sorted(freq, key=lambda x: (-freq[x], s.index(x))) # Concatenate the sorted characters based on their frequency return \'\'.join(char * freq[char] for char in sorted_chars)"},{"question":"# Dynamic Programming: Maximum Subarray Sum You are given an array of integers representing the profits or losses from a series of past trades. Your objective is to find the maximum possible profit (sum) you can achieve by selecting any contiguous subarray from this array. A contiguous subarray is a collection of elements that follow sequentially from one index to another in the array. Implement the function `max_subarray_sum` which takes a list of integers `profits` and returns the maximum sum of any contiguous subarray. # Function Signature ```python def max_subarray_sum(profits: list) -> int: ``` # Input Constraints - The list `profits` is not empty. - Elements of `profits` are integers within the range [-10^5, 10^5]. - The length of `profits` does not exceed 10^5. # Example ```python profits = [-2,1,-3,4,-1,2,1,-5,4] print(max_subarray_sum(profits)) # Expected Output: 6 # Explanation: The subarray [4,-1,2,1] has the largest sum = 6. ``` # Implementation Details - Utilize a dynamic programming approach, such as Kadane\'s algorithm, to achieve optimal time complexity. - Manage the cumulative sum of subarrays and track the maximum sum encountered. - Ensure edge cases, such as arrays with all negative numbers, are handled correctly.","solution":"def max_subarray_sum(profits): Returns the maximum sum of any contiguous subarray. # Initialize the maximum sum to the first element and the current sum to the first element. max_sum = current_sum = profits[0] # Iterate over the profits array starting from the second element for profit in profits[1:]: # Update the current_sum to the maximum of the current profit or the current_sum + profit. current_sum = max(profit, current_sum + profit) # Update the max_sum with the maximum of max_sum and current_sum. max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Coding Assessment Question **Context**: You are given a string representing a complex mathematical expression that may include nested parentheses. Your task is to evaluate the expression and return the result. The expression can include the basic arithmetic operators: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). **Task**: Write a function `evaluate_expression` that parses and evaluates a mathematical expression string with nested parentheses. **Requirements**: The function must: 1. Correctly handle operator precedence and associativity. 2. Evaluate nested parentheses from the innermost to the outermost. 3. Support both integer and floating-point number operations. Use the following function prototype: ```python def evaluate_expression(expression: str) -> float: pass ``` **Input**: - `expression`: A string representing a valid mathematical expression possibly containing nested parentheses. The expression length will not exceed 100 characters. **Output**: - A float representing the evaluated result of the expression. **Constraints**: - The input expression will always be a valid mathematical expression and only contain numbers, parentheses, and the operators `+`, `-`, `*`, `/`. - Division by zero will not occur. **Test Cases**: 1. **Input**: `\\"2 + (3 * (2 + 1))\\"` - Explanation: Evaluates to `2 + (3 * 3)`, which simplifies to `2 + 9`, resulting in `11.0`. - **Expected Output**: `11.0` 2. **Input**: `\\"10 / (2 + 3) * (7 - 4)\\"` - Explanation: Evaluates to `10 / 5 * 3`, which simplifies to `2 * 3`, resulting in `6.0`. - **Expected Output**: `6.0` 3. **Input**: `\\"(1 + 2) * (3 + 4) - 5\\"` - Explanation: Evaluates to `3 * 7 - 5`, which simplifies to `21 - 5`, resulting in `16.0`. - **Expected Output**: `16.0` **Hints**: - Use the Shunting-yard algorithm to parse the expression and handle operator precedence. - Use recursion or a stack to handle evaluations within nested parentheses. This problem assesses understanding of expression parsing, nested parentheses evaluation, and handling arithmetic operators with proper precedence and associativity.","solution":"def evaluate_expression(expression: str) -> float: def compute(ops, values): right = values.pop() left = values.pop() op = ops.pop() if op == \'+\': values.append(left + right) elif op == \'-\': values.append(left - right) elif op == \'*\': values.append(left * right) elif op == \'/\': values.append(left / right) def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def parse_expression(expression): ops = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': ops.append(expression[i]) elif expression[i].isdigit() or expression[i] == \'.\': val = 0 decimal = False fractional_part = 0.1 while i < len(expression) and (expression[i].isdigit() or expression[i] == \'.\'): if expression[i] == \'.\': decimal = True elif not decimal: val = (val * 10) + int(expression[i]) else: val += int(expression[i]) * fractional_part fractional_part /= 10 i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while ops and ops[-1] != \'(\': compute(ops, values) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(expression[i]): compute(ops, values) ops.append(expression[i]) i += 1 while ops: compute(ops, values) return values[0] return parse_expression(expression)"},{"question":"# Question: Merge Intervals and Count Overlaps Given a collection of intervals, merge all overlapping intervals. Additionally, count the number of intervals that were merged during the process. An interval is a pair of integers, where the first integer is always less than or equal to the second integer. Your task is to write a function that takes a list of intervals and returns the merged intervals and the count of merged overlaps. Input * A list of interval pairs `intervals` where each interval is represented as `[start, end]`, and (1 leq text{len(intervals)} leq 10^4) and (-10^3 leq text{start}, end leq 10^3). Output * Return a tuple containing two elements: 1. A list of merged intervals. 2. An integer representing the count of overlaps that were merged. Constraints * The input intervals are not necessarily sorted. * Intervals might be disjoint or fully/partially overlapping. Example ```python assert merge_intervals_and_count([[1, 3], [2, 6], [8, 10], [15, 18]]) == ([[1, 6], [8, 10], [15, 18]], 1) assert merge_intervals_and_count([[1, 4], [4, 5]]) == ([[1, 5]], 1) assert merge_intervals_and_count([[1, 2], [3, 4], [5, 6]]) == ([[1, 2], [3, 4], [5, 6]], 0) assert merge_intervals_and_count([[1, 4], [0, 4]]) == ([[0, 4]], 1) assert merge_intervals_and_count([]) == ([], 0) ``` Requirements * Your solution should handle intervals that are not sorted. * Provide a function `merge_intervals_and_count(intervals: list[list[int]]) -> (list[list[int]], int)`. * The function should achieve an optimal time complexity considering the sorting step (O(n log n)). * Handle edge cases, such as empty lists and single interval lists. Implement the `merge_intervals_and_count` function that adheres to the outlined requirements.","solution":"def merge_intervals_and_count(intervals): if not intervals: return [], 0 # Sort intervals by their start value intervals.sort(key=lambda x: x[0]) merged_intervals = [] merged_count = 0 # Initialize the first interval current_interval = intervals[0] for next_interval in intervals[1:]: if current_interval[1] >= next_interval[0]: # Overlapping intervals current_interval[1] = max(current_interval[1], next_interval[1]) merged_count += 1 else: merged_intervals.append(current_interval) current_interval = next_interval # Append the last interval merged_intervals.append(current_interval) return merged_intervals, merged_count"},{"question":"**Question:** You are given a list of integers representing stock prices for each day. You want to write a program to maximize your profit. You are allowed to make only two transactions (buy and sell) throughout this period. A transaction is defined as buying and then selling one unit of the stock. However, you cannot hold more than one unit of stock at any time, and you must sell the stock before you can buy it again. # Task: Implement a function `max_profit_two_transactions` that determines the maximum profit you can achieve with exactly two transactions. # Input: - **Type**: List of integers - **Name**: `prices` - **Description**: The prices of the stock for each day - **Constraints**: - 2 <= len(prices) <= 10^5 - 0 <= prices[i] <= 10^5 # Output: - **Return Type**: Integer - **Description**: The maximum profit achievable with exactly two transactions. # Examples: Example 1: ```python prices = [3, 3, 5, 0, 0, 3, 1, 4] print(max_profit_two_transactions(prices)) # Output: 6 ``` Example 2: ```python prices = [1, 2, 3, 4, 5] print(max_profit_two_transactions(prices)) # Output: 4 ``` Example 3: ```python prices = [7, 6, 4, 3, 1] print(max_profit_two_transactions(prices)) # Output: 0 ``` # Constraints and Notes: - To solve this problem optimally, consider the use of dynamic programming. - Implement solutions with consideration for time complexity and space efficiency. ```python def max_profit_two_transactions(prices) -> int: # Implement the function here pass if __name__ == \\"__main__\\": prices_example1 = [3, 3, 5, 0, 0, 3, 1, 4] prices_example2 = [1, 2, 3, 4, 5] prices_example3 = [7, 6, 4, 3, 1] print(max_profit_two_transactions(prices_example1)) # Output: 6 print(max_profit_two_transactions(prices_example2)) # Output: 4 print(max_profit_two_transactions(prices_example3)) # Output: 0 ```","solution":"def max_profit_two_transactions(prices): if not prices: return 0 n = len(prices) max_profit_1 = [0] * n max_profit_2 = [0] * n # First pass, calculate max profit if we only do 1 transaction min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) max_profit_1[i] = max(max_profit_1[i-1], prices[i] - min_price) # Second pass, calculate max profit from backwards if we only do 1 transaction max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) max_profit_2[i] = max(max_profit_2[i+1], max_price - prices[i]) # Now calculate max profit with at most 2 transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, max_profit_1[i] + max_profit_2[i]) return max_profit"},{"question":"# Scenario: You are part of a development team tasked with creating a new social media application. One of the essential features is to track user engagement by analyzing the usage patterns within the application. To start with, you need to calculate the longest streak of consecutive days a user has logged in. # Task: Implement a function named `longest_login_streak` that calculates the longest continuous streak of days a user has logged into the app, based on a list of login dates. # Requirements: 1. The function should accept a list of dates in the format `YYYY-MM-DD`, where each date represents a user\'s login. 2. The function should return an integer representing the maximum number of consecutive days the user has logged in. 3. Ensure the function handles empty lists gracefully by returning 0. 4. The dates in the input list are not guaranteed to be in any specific order. # Expected Input and Output: * **Input:** - `login_dates` (list of str): List of dates representing user logins. * **Output:** - Returns an integer representing the longest streak of consecutive login days. # Constraints: * The input list may contain duplicate dates, which should be counted as a single day. * Assume that the input dates are valid and follow the `YYYY-MM-DD` format. # Example: ```python >>> longest_login_streak([\\"2023-08-01\\", \\"2023-08-02\\", \\"2023-08-03\\", \\"2023-08-05\\"]) 3 >>> longest_login_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2022-12-31\\", \\"2022-12-30\\"]) 4 >>> longest_login_streak([\\"2023-05-01\\", \\"2023-06-01\\", \\"2023-07-01\\"]) 1 >>> longest_login_streak([]) 0 ``` # Hint: Consider converting the dates to a set for unique values, and then iterate over the dates to calculate the longest consecutive sequence. Use Python’s `datetime` module for date manipulation and comparison.","solution":"from datetime import datetime, timedelta def longest_login_streak(login_dates): Calculates the longest streak of consecutive days a user has logged in. Args: login_dates (list of str): List of dates in \'YYYY-MM-DD\' format. Returns: int: Longest streak of consecutive days logged in. if not login_dates: return 0 # Convert the dates to a set of datetime objects login_dates_set = set(datetime.strptime(date, \'%Y-%m-%d\') for date in login_dates) longest_streak = 0 for date in login_dates_set: current_streak = 1 current_date = date # Check for the next consecutive dates while current_date + timedelta(days=1) in login_dates_set: current_date += timedelta(days=1) current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Question: (Array Partitioning) You are given an array of integers and a partition number `k`. Your task is to partition the array into `k` contiguous subarrays such that the sum of the maximum sum of these subarrays is minimized. **Function Signature:** ```python def minimize_partition_sum(arr: List[int], k: int) -> int: ``` **Input:** * A list of integers `arr` (1 ≤ len(arr) ≤ 1000, 1 ≤ arr[i] ≤ 1000) - the array to be partitioned. * An integer `k` (1 ≤ k ≤ len(arr)) - the number of subarrays to partition into. **Output:** * An integer representing the minimized maximum sum of the partitioned subarrays. **Example:** ```python >>> minimize_partition_sum([1,2,3,4,5], 2) 9 >>> minimize_partition_sum([7,2,5,10,8], 2) 18 ``` **Constraints:** * The input will always be such that it is possible to partition the array into `k` contiguous subarrays. * The values within the list and the number of partitions will always be within the specified range. **Guidelines:** * Consider using dynamic programming to solve the problem efficiently within the given constraints. * Begin by defining a state representation that captures the subproblem to be solved. * Ensure your solution handles edge cases, such as small arrays and small values of `k`. **Scenario:** Imagine you are a software developer designing a feature to split large datasets for distributed processing systems. Your goal is to determine how to partition the data most effectively to balance the workload across the processors to minimize the processing time for the heaviest-loaded processor.","solution":"from typing import List def minimize_partition_sum(arr: List[int], k: int) -> int: n = len(arr) # If k is greater than or equal to the length of the array, each element can be its own subarray if k >= n: return max(arr) # Helper function to decide if it is possible to partition the array # into k contiguous subarrays with sum at most `max_sum` def can_partition(max_sum): count, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True # Binary search between the largest single element and the sum of all elements left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"# Coding Assessment Question **Objective**: Write a function named `word_permutations` that generates all possible unique permutations of the characters in a given string and returns them as a sorted list. The function signature should be: ```python def word_permutations(word: str) -> list: ``` # Input Format: - `word` (str): A string consisting of lowercase alphabetic characters (1 <= len(word) <= 6). # Output Format: - The function should return a list of strings, each representing a unique permutation of the input string, sorted in lexicographical order. # Constraints: - The input string length will always be between 1 and 6. - The input string will contain only lower-case alphabetic characters (a-z). # Example: ```python >>> word_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> word_permutations(\\"a\\") [\'a\'] >>> word_permutations(\\"aa\\") [\'aa\'] >>> word_permutations(\\"ab\\") [\'ab\', \'ba\'] ``` # Notes: 1. The output list should contain all unique permutations of the given string characters. 2. The permutations in the output list must be sorted in ascending lexicographical order.","solution":"from itertools import permutations def word_permutations(word: str) -> list: Generates all unique permutations of the characters in the given word and returns them as a sorted list. :param word: str: The input string consisting of lowercase alphabetic characters :return: list: A list of unique permutations sorted in lexicographical order # Generate all permutations perm = set(permutations(word)) # Join the tuples to form strings and sort them result = sorted(\'\'.join(p) for p in perm) return result"},{"question":"# Context: You have been working on a basic neural network framework as part of a new AI research project. One important feature is the ability to compute the loss and its gradient for various loss functions during the training process. One common loss function you\'ll need to support is the mean squared error (MSE). # Task: Extend the `Loss` class to include the mean squared error (MSE) loss function, ensuring it can compute both the value of the loss and its gradient with respect to the predicted output. # Requirements: 1. **Function Implementation:** - Add a method `mean_squared_error` to the `Loss` class which calculates the MSE between the predicted values and the true values. - Ensure the method returns both the loss value and its gradient. 2. **Edge Case Handling:** - Handle edge cases where the input arrays have different shapes or contain NaN/Inf values. 3. **Testing:** - Demonstrate the correctness of your implementation with several test cases, including some with edge cases. **Input and Output formats:** - **Input:** Two numpy arrays, `y_pred` and `y_true`. - **Output:** A tuple containing the mean squared error value and the gradient array. **Constraints:** - Ensure the computation is vectorized for efficiency. - Assume numpy is available for numerical operations. # Example: ```python class Loss: @staticmethod def mean_squared_error(y_pred, y_true): # Compute Mean Squared Error mse = np.mean((y_pred - y_true) ** 2) # Compute gradient gradient = 2 * (y_pred - y_true) / y_true.size return mse, gradient # Example usage y_pred = np.array([2.0, 3.0, 4.0]) y_true = np.array([1.0, 2.0, 3.0]) loss, grad = Loss.mean_squared_error(y_pred, y_true) # Expected output # loss = 1.0 # grad = [0.66666667, 0.66666667, 0.66666667] assert np.allclose(loss, 1.0) assert np.allclose(grad, [0.66666667, 0.66666667, 0.66666667]) ``` **Note:** Make sure the implementation handles invalid input appropriately and provides meaningful error messages where necessary.","solution":"import numpy as np class Loss: @staticmethod def mean_squared_error(y_pred, y_true): # Check for the same shape of input arrays if y_pred.shape != y_true.shape: raise ValueError(\\"Shape of y_pred and y_true must be the same.\\") # Check for NaN or Inf values if np.any(np.isnan(y_pred)) or np.any(np.isnan(y_true)): raise ValueError(\\"Input arrays contain NaN values.\\") if np.any(np.isinf(y_pred)) or np.any(np.isinf(y_true)): raise ValueError(\\"Input arrays contain Inf values.\\") # Compute Mean Squared Error mse = np.mean((y_pred - y_true) ** 2) # Compute gradient gradient = 2 * (y_pred - y_true) / y_true.size return mse, gradient"},{"question":"# **Coding Challenge: Subsequence Sum Analysis** You are given a problem inspired by sub-sequences within an array. The challenge is based on finding a sub-sequence whose sum is equal to a given target. This problem is pivotal in understanding dynamic programming and combinatorial search techniques. **Problem Statement**: Write a function `count_subsequences_with_sum(arr: List[int], target: int) -> int` that calculates the number of sub-sequences within the array `arr` that sum up to the `target` value. A sub-sequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # **Hint** Consider using dynamic programming or recursive backtracking to find all possible sub-sequences that meet the target sum. # **Input Format** * A list of integers `arr` where the length of `arr` is (1 leq len(arr) leq 20). * An integer `target`. # **Output Format** * Returns the count of sub-sequences (integer) whose sums equal the target value. # **Constraints** * The elements in `arr` are in the range (-10^3 leq arr[i] leq 10^3). * The `target` value is an integer within the range (-10^4 leq target leq 10^4). # **Example** * For `arr = [1, 2, 3]` and `target = 3`: ```python print(count_subsequences_with_sum([1, 2, 3], 3)) # Output: 2 ``` # **Explanation** - The sub-sequences of `[1, 2, 3]` that sum up to 3 are `[1, 2]` and `[3]`, hence the output is 2. Make sure to consider the edge cases when `arr` has negative numbers or zero values.","solution":"from typing import List def count_subsequences_with_sum(arr: List[int], target: int) -> int: def count_subsequences(index, current_sum): if index == len(arr): return 1 if current_sum == target else 0 return (count_subsequences(index + 1, current_sum + arr[index]) + count_subsequences(index + 1, current_sum)) return count_subsequences(0, 0)"},{"question":"# Word Ladder Generator You are required to implement a function that generates a word ladder, which is a sequence of words where each word differs by exactly one letter from the previous word. The goal is to find a sequence from a given start word to an end word using given dictionary words. **Input/Output:** - **Input**: The input consists of: 1. `start_word` - A string representing the start word. 2. `end_word` - A string representing the end word. 3. `dictionary` - A list of strings representing the dictionary of valid words. - **Output**: A list of strings representing the word ladder sequence from the `start_word` to the `end_word`. If no such sequence exists, return an empty list. # Requirements: 1. **Valid Transformations**: - Each word in the sequence must be a valid transformation present in the dictionary. - Only one letter can be changed at each step. 2. **Performance Considerations**: - Ensure the solution is optimized for performance, especially when dealing with large dictionaries. - Use efficient search techniques like Breadth-First Search (BFS) to find the shortest path. 3. **Edge Cases**: - Handle cases where the `start_word` is the same as the `end_word`. - Ensure proper handling of cases where no valid ladder exists due to missing words in the dictionary. # Function Signature: ```python def word_ladder_generator(start_word: str, end_word: str, dictionary: List[str]) -> List[str]: pass ``` # Example: ```python # Example usage: start_word = \\"hit\\" end_word = \\"cog\\" dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] ladder_sequence = word_ladder_generator(start_word, end_word, dictionary) print(ladder_sequence) # Possible Output: # [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] # If no valid ladder exists: start_word = \\"hit\\" end_word = \\"cog\\" dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] ladder_sequence = word_ladder_generator(start_word, end_word, dictionary) print(ladder_sequence) # Possible Output: # [] ``` # Constraints: - Assume all inputs consists of lowercase alphabetic characters only. - Dictionary words and the start/end words are of the same length. - Dictionary will not have duplicate words. # Notes: - You may use built-in data structures like sets, queues, and dictionaries to improve efficiency. - Provide clear error messages for any invalid inputs (although inputs are assumed valid unless stated otherwise). Good luck!","solution":"from collections import deque from typing import List def word_ladder_generator(start_word: str, end_word: str, dictionary: List[str]) -> List[str]: if start_word == end_word: return [start_word] word_set = set(dictionary) if end_word not in word_set: return [] queue = deque([(start_word, [start_word])]) visited = set(start_word) while queue: current_word, path = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end_word: return path + [end_word] if next_word in word_set and next_word not in visited: queue.append((next_word, path + [next_word])) visited.add(next_word) return []"},{"question":"# Question: Implement a Custom Priority Queue with Dynamic Update Capability Context You have been tasked with implementing a custom priority queue that supports dynamic priority updates. This custom queue should allow the insertion of items with associated priorities, the removal and retrieval of the highest priority item, and the capability to update the priority of any item already in the queue. Objective Write a Python class `CustomPriorityQueue` that supports the following operations: 1. Insert items with associated priorities. 2. Remove and return the highest priority item. 3. Update the priority of any item in the queue. # Requirements 1. **Class Definition**: Define a `CustomPriorityQueue` class to manage items and their priorities. 2. **Method Definitions**: Implement the following methods: ```python class CustomPriorityQueue: def __init__(self): # Constructor to initialize the queue def insert(self, item: Any, priority: int): # Method to insert an item with a given priority def remove_max(self) -> Any: # Method to remove and return the highest priority item def update_priority(self, item: Any, new_priority: int): # Method to update the priority of a specific item ``` Input Format - `item`: The item to be inserted, updated, or removed (could be of any type). - `priority`, `new_priority`: Integers representing the priority levels (higher integers indicate higher priority). Output Format - `remove_max`: Returns the item with the highest priority. If the queue is empty, return `None`. Implementation Constraints - Implement the priority queue using an appropriate data structure that allows efficient insertion, removal, and priority update operations. - Handle edge cases and ensure that all operations execute efficiently. - Assume that the priority queue contains unique items. Example Usage ```python class CustomPriorityQueue: def __init__(self): self.queue = [] self.entry_finder = {} self.counter = 0 def insert(self, item: Any, priority: int): if item in self.entry_finder: self.update_priority(item, priority) else: entry = [priority, self.counter, item] self.queue.append(entry) self.entry_finder[item] = entry self.queue.sort(key=lambda x:x[0], reverse=True) self.counter += 1 def remove_max(self) -> Any: while self.queue: priority, _, item = self.queue.pop(0) if item is not None: del self.entry_finder[item] return item return None def update_priority(self, item: Any, new_priority: int): if item in self.entry_finder: self.entry_finder[item][0] = new_priority self.queue.sort(key=lambda x:x[0], reverse=True) # Example Operations pq = CustomPriorityQueue() pq.insert(\'task1\', 3) pq.insert(\'task2\', 1) pq.insert(\'task3\', 2) # Removing max priority item print(pq.remove_max()) # Output: \'task1\' # Updating priority pq.update_priority(\'task2\', 4) print(pq.remove_max()) # Output: \'task2\' ``` # Guidelines: - Ensure that the `CustomPriorityQueue` efficiently handles the insert, remove, and update operations. - Consider using heapq or similar data structure for optimum performance (not shown in the example for simplicity). - Include appropriate error checks and validations.","solution":"import heapq class CustomPriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, item, priority): if item in self.entry_finder: self.update_priority(item, priority) else: entry = [-priority, self.counter, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_max(self): while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not None: del self.entry_finder[item] return item return None def update_priority(self, item, new_priority): if item in self.entry_finder: entry = self.entry_finder.pop(item) entry[-1] = None self.insert(item, new_priority)"},{"question":"# Problem Statement You are given a list of unique words which differ from one another by only one character. Your task is to implement an algorithm that transforms a start word into an end word by changing one letter at a time, ensuring that each intermediate word exists in the given list of words. Return the shortest transformation sequence length, or `0` if no such transformation is possible. # Function Signature ```python def word_ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int: ``` # Input - `begin_word`: A string representing the start word. - `end_word`: A string representing the end word. - `word_list`: A list of strings where each string is a unique word. # Output - An integer representing the number of transformations needed to convert `begin_word` to `end_word`, including the start and end words, or `0` if no such transformation is possible. # Example ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] print(word_ladder_length(begin_word, end_word, word_list)) # Output: 5 begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] print(word_ladder_length(begin_word, end_word, word_list)) # Output: 0 ``` # Constraints - All words, including `begin_word` and `end_word`, are of the same length. - `begin_word` and `end_word` are non-empty and consist only of lowercase English letters. - The length of `word_list` will be in the range ([1, 10^4]). - All words in `word_list` are unique. # Performance Requirements - Your solution should run efficiently within the given constraints, focusing on optimal use of data structures and algorithms. # Notes - Ensure your implementation considers all possible transformations and avoids cycles or redundant computations. - The algorithm should be robust against cases where the transformation is impossible within the provided word list.","solution":"from collections import deque def word_ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int: if end_word not in word_list: return 0 word_set = set(word_list) queue = deque([(begin_word, 1)]) while queue: current_word, level = queue.popleft() if current_word == end_word: return level for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, level + 1)) return 0"},{"question":"# Problem Statement You are tasked with writing a function that simulates a simplified version of a \\"bank transaction system\\" where customers can deposit, withdraw, or check their current balance. You need to process a series of transaction instructions and return the final balance of all customers. # Function Signature ```python def process_transactions(transactions: List[Tuple[str, int, int]]) -> Dict[int, int]: Process a list of transactions and return a dictionary representing the final balance of each customer. Parameters: - transactions (List[Tuple[str, int, int]]): A list of tuples where each tuple represents a transaction. The first element of the tuple is a string indicating the transaction type (\\"deposit\\", \\"withdraw\\" or \\"check\\"). The second element is an integer customer ID. The third element is an integer amount (applicable for \\"deposit\\" and \\"withdraw\\" types only). Returns: Dict[int, int]: A dictionary where the keys are customer IDs and the values are their final balances. ``` # Inputs * `transactions (List[Tuple[str, int, int]])`: A list of tuples representing the transactions where: * `transaction_type` is a string that can be \\"deposit\\", \\"withdraw\\", or \\"check\\". * `customer_id` is an integer representing the customer carrying out the transaction. * `amount` is an integer representing the transaction amount (for \\"deposit\\" and \\"withdraw\\" only, not required for \\"check\\"). # Outputs * A dictionary where keys are customer IDs and values are their final balances after processing all transactions. # Constraints * Each customer ID is a positive integer. * \\"Deposit\\" and \\"withdraw\\" transaction amounts will be non-negative integers. * There can be zero or more transactions. * IDs and transactions are valid. # Example ```python >>> transactions = [ (\\"deposit\\", 1, 100), (\\"deposit\\", 2, 200), (\\"withdraw\\", 1, 50), (\\"check\\", 1, 0), (\\"check\\", 2, 0), (\\"deposit\\", 1, 50) ] >>> process_transactions(transactions) {1: 100, 2: 200} >>> transactions = [ (\\"deposit\\", 1, 500), (\\"withdraw\\", 3, 100), (\\"withdraw\\", 1, 250), (\\"deposit\\", 2, 300), (\\"check\\", 1, 0), (\\"check\\", 3, 0) ] >>> process_transactions(transactions) {1: 250, 3: -100, 2: 300} ``` # Explanation 1. For the first example: - Customer 1 deposits 100, then withdraws 50, leaving a balance of 50, then deposits 50 again, resulting in a final balance of 100. - Customer 2 deposits 200 and performs no further transactions. 2. For the second example: - Customer 1 deposits 500, withdraws 250, leaving a balance of 250. - Customer 3 tries to withdraw 100 without any prior deposits, resulting in a negative balance of -100. - Customer 2 deposits 300 with no withdrawals, so the balance is 300. # Notes * Ensure the solution handles invalid or no transactions gracefully. * Assume all transactions are valid and focus on simulating their effects correctly. * It is possible for a customer to have a negative balance due to withdrawals exceeding deposits.","solution":"from typing import List, Tuple, Dict def process_transactions(transactions: List[Tuple[str, int, int]]) -> Dict[int, int]: Process a list of transactions and return a dictionary representing the final balance of each customer. Parameters: - transactions (List[Tuple[str, int, int]]): A list of tuples where each tuple represents a transaction. The first element of the tuple is a string indicating the transaction type (\\"deposit\\", \\"withdraw\\" or \\"check\\"). The second element is an integer customer ID. The third element is an integer amount (applicable for \\"deposit\\" and \\"withdraw\\" types only). Returns: Dict[int, int]: A dictionary where the keys are customer IDs and the values are their final balances. balances = {} for transaction in transactions: transaction_type, customer_id, amount = transaction if customer_id not in balances: balances[customer_id] = 0 if transaction_type == \\"deposit\\": balances[customer_id] += amount elif transaction_type == \\"withdraw\\": balances[customer_id] -= amount elif transaction_type == \\"check\\": # \\"check\\" does not modify the balance continue return balances"},{"question":"# Word Frequency Counter Given a text document, your task is to write a class `WordCounter` that reads the document, processes the text, and computes the frequency of each word. # Objectives - Write a class `WordCounter` that takes the file path of the text document as an input. - Implement a method `count_words` that reads the file and counts the frequency of each word. - Implement a method `top_k_words` that returns the top `k` most common words and their frequencies in descending order. # Input Format - A file path `file_path` pointing to the text document. - An integer `k` specifying the number of top frequent words to return. # Output Format - A list of tuples, where each tuple consists of a word and its frequency, ordered by frequency in descending order. # Constraints - The document will contain a maximum of 10^6 words. - Valid words consist of alphabetic characters (`a-z`, `A-Z`) and are case-insensitive. - Remove punctuation and handle special characters appropriately. - Ignore case (i.e., \'Word\' and \'word\' should be considered the same). # Performance Requirements - Aim for **O(n log m)** time complexity for counting words, where `n` is the total number of words, and `m` is the number of unique words. - Keep memory usage efficient while storing intermediate data. # Example ```python # Example text file contents: # \\"Hello world! Hello again, world. This is a test document. This document is for testing.\\" wc = WordCounter(\\"path/to/text/document.txt\\") wc.count_words() top_words = wc.top_k_words(3) # e.g., k=3 print(top_words) # Expected output: [(\'hello\', 2), (\'world\', 2), (\'this\', 2)] ``` # Notes - Be attentive to edge cases such as very short documents or documents with non-alphabetic characters. - Ensure your methods are efficient and handle large documents gracefully. ```python import re from collections import Counter class WordCounter: def __init__(self, file_path): self.file_path = file_path self.word_counts = Counter() def count_words(self): with open(self.file_path, \'r\') as file: text = file.read().lower() words = re.findall(r\'b[a-z]+b\', text) self.word_counts.update(words) def top_k_words(self, k): return self.word_counts.most_common(k) ``` Implement your solution in the provided classes and methods. Ensure you handle text preprocessing effectively and that your code is robust against various input cases.","solution":"import re from collections import Counter class WordCounter: def __init__(self, file_path): self.file_path = file_path self.word_counts = Counter() def count_words(self): with open(self.file_path, \'r\') as file: text = file.read().lower() words = re.findall(r\'b[a-z]+b\', text) self.word_counts.update(words) def top_k_words(self, k): return self.word_counts.most_common(k)"},{"question":"# Coding Question: Validate and Generate ISBN-13 An ISBN-13 (International Standard Book Number) is a 13-digit unique identifier for books. The 13th digit is a checksum which is calculated using a specific algorithm. Your task is to implement a function to validate a given ISBN-13 number and another function to generate the checksum for a given 12-digit partial ISBN. Function Signature: ```python def validate_isbn_13(isbn: str) -> bool: def generate_isbn_13(partial_isbn: str) -> str: ``` Parameters: * **isbn** (str): The ISBN-13 string to be validated. It should have exactly 13 digits. * **partial_isbn** (str): The 12-digit partial ISBN to generate the 13th checksum digit. Returns: * **validate_isbn_13** function should return a boolean indicating whether the given ISBN-13 is valid. * **generate_isbn_13** function should return a 13-digit ISBN. Constraints: * Each function will receive well-formed input strings containing only digits. * The input strings will always have the correct length (13 digits for validation, 12 digits for partial ISBN generation). # ISBN-13 Checksum Algorithm: 1. Take the 12-digit partial ISBN and calculate the checksum as follows: 1. Sum the digits in the odd positions together. 2. Sum the digits in the even positions and multiply the result by 3. 3. Sum the results of steps 1 and 2. 4. The checksum digit is the number that, when added to the result from step 3, makes it a multiple of 10 (i.e., the remainder when divided by 10 should be 0). Example: ```python assert validate_isbn_13(\\"9780306406157\\") == True assert validate_isbn_13(\\"9780306406158\\") == False assert generate_isbn_13(\\"978030640615\\") == \\"9780306406157\\" assert generate_isbn_13(\\"978030640616\\") == \\"9780306406164\\" ``` # Additional Notes: * Ensure your validation correctly checks the entire ISBN-13, including recalculating the checksum. * Your checksum generation function should correctly handle various partial ISBNs to always return the correct final digit. * Consider edge cases, such as when checksum is 0 or when it requires carrying over multiple times during addition.","solution":"def validate_isbn_13(isbn: str) -> bool: Validates a given 13-digit ISBN. if len(isbn) != 13: return False try: digits = [int(x) for x in isbn] except ValueError: return False checksum = 0 for i in range(12): if i % 2 == 0: checksum += digits[i] else: checksum += 3 * digits[i] checksum = (10 - (checksum % 10)) % 10 return checksum == digits[12] def generate_isbn_13(partial_isbn: str) -> str: Generates a 13-digit ISBN from a given 12-digit partial ISBN. if len(partial_isbn) != 12: raise ValueError(\'Partial ISBN must be exactly 12 digits long.\') try: digits = [int(x) for x in partial_isbn] except ValueError: raise ValueError(\'Partial ISBN must contain only digits.\') checksum = 0 for i in range(12): if i % 2 == 0: checksum += digits[i] else: checksum += 3 * digits[i] checksum = (10 - (checksum % 10)) % 10 return partial_isbn + str(checksum)"},{"question":"# Problem Statement You are in charge of managing a storage system that keeps track of digital files. Each file is represented by a unique ID and an access count, which indicates how many times the file has been accessed. You need to implement a system that efficiently retrieves the `k` most accessed files. Your task is to implement a function that returns a list of the IDs of the `k` most accessed files, sorted in descending order of their access counts. If two files have the same access count, the file with the smaller ID should appear first. # Function Signature ```python def top_k_accessed_files(files: List[Tuple[int, int]], k: int) -> List[int]: pass ``` # Input * `files` - a list of tuples, where each tuple contains two integers: * The first integer is the file ID (0 <= file ID <= 10^6). * The second integer is the access count (0 <= access count <= 10^9). * `k` - an integer (0 <= k <= len(files)) representing the number of top accessed files to retrieve. # Output * A list of `k` integers representing the IDs of the `k` most accessed files. # Constraints * The input list `files` can contain up to 10^6 elements. * The function should be efficient and able to handle large input sizes effectively. # Examples ```python >>> top_k_accessed_files([(1, 10), (2, 20), (3, 20), (4, 5)], 2) [2, 3] >>> top_k_accessed_files([(1, 15), (2, 15), (3, 10)], 1) [1] >>> top_k_accessed_files([], 0) [] >>> top_k_accessed_files([(5, 7), (1, 7), (6, 10)], 3) [6, 1, 5] ``` # Notes 1. You can utilize a heap or other efficient data structures to maintain the top `k` most accessed files. 2. Make sure that the function handles edge cases like an empty input list or `k` being zero gracefully.","solution":"from typing import List, Tuple import heapq def top_k_accessed_files(files: List[Tuple[int, int]], k: int) -> List[int]: Returns the IDs of the k most accessed files, sorted in descending order of their access counts. If two files have the same access count, the file with the smaller ID appears first. files: List of tuples, where each tuple (file_id, access_count) k: Number of top accessed files to retrieve if k == 0: return [] if not files: return [] # Using a min-heap to keep track of top k elements min_heap = [] for file_id, access_count in files: heapq.heappush(min_heap, (-access_count, file_id)) result = [] for _ in range(min(k, len(min_heap))): result.append(heapq.heappop(min_heap)[1]) return sorted(result, key=lambda x: (-next((access_count for fid, access_count in files if fid == x)), x))"},{"question":"# Coding Question Problem Statement You are given an unsorted array of integers and an integer `k`. Your task is to implement a function `findKthLargest(nums: List[int], k: int) -> int` that returns the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. # Input and Output Formats * **Input Format**: * `nums`: A List of integers where the number of elements (`n`) can vary. * `k`: An integer representing the rank of the largest element to find. * **Output Format**: * Return a single integer representing the k-th largest element in the array. # Constraints * `1 ≤ k ≤ n ≤ 10^5` * `-10^4 ≤ nums[i] ≤ 10^4` for all valid `i` # Performance Requirements * Your solution should be efficient and aim for a time complexity better than (O(n log n)). # Example Input ```python nums = [3, 2, 1, 5, 6, 4] k = 2 ``` Output ```python 5 ``` Input ```python nums = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 ``` Output ```python 4 ``` # Hints * Consider using a heap or quickselect algorithm to find the k-th largest element efficiently. Here\'s the function signature: ```python from typing import List def findKthLargest(nums: List[int], k: int) -> int: pass ```","solution":"from typing import List import heapq def findKthLargest(nums: List[int], k: int) -> int: Returns the k-th largest element in the given list of integers. It uses a min-heap to efficiently find the k-th largest element. if k < 1 or k > len(nums): raise ValueError(\\"k is out of the range of the number of elements in nums.\\") # Use a min-heap of size k heap = nums[:k] heapq.heapify(heap) # Iterate through the rest of the numbers and maintain a heap of size k for num in nums[k:]: if num > heap[0]: heapq.heappushpop(heap, num) # The root of the heap (smallest in the heap) is the k-th largest element return heap[0]"},{"question":"You are managing an ecommerce website. You need to develop a feature that suggests a promotion based on the user\'s previous purchases. Every user has a unique ID, and every transaction is recorded with a unique transaction ID. Each transaction contains an array of product IDs that were bought together. Write a function `suggest_promotion(user_transactions: Dict[int, List[List[int]]], product_id: int) -> int` that suggests the most frequently bought product along with the given `product_id` across all users\' transactions. # Input: * `user_transactions`: A dictionary where the key is a user ID, and the value is a list of transactions. Each transaction is represented by a list of product IDs. * `product_id`: An integer representing the product ID for which you want to find the most frequently bought product with. # Output: * An integer representing the product ID that is most frequently bought together with the given `product_id`. If there are multiple products with the same frequency, return the product with the smallest ID. # Constraints: * User IDs and transaction IDs are all integers. * Each product ID in transactions is an integer. * There will be at least one user transaction available in the `user_transactions`. * No transaction list will be empty. * The given `product_id` will appear in at least one transaction. # Example: ```python user_transactions = { 1: [[1, 2, 3], [2, 4, 5], [1, 3, 6]], 2: [[3, 4, 1], [2, 1, 3]], 3: [[2, 3, 4], [2, 3, 5]] } assert suggest_promotion(user_transactions, 2) == 3 assert suggest_promotion(user_transactions, 1) == 3 ``` # Notes: * This problem tests your ability to manipulate complex data structures like dictionaries and lists, and extract meaningful insights that satisfy the given constraints. * Make sure to handle cases where the given `product_id` shares the highest co-occurrence frequency with multiple products. * Consider time and space complexity while designing your solution as data can grow in real-world applications.","solution":"def suggest_promotion(user_transactions, product_id): from collections import Counter # Counter to store the count of products bought together with the given product_id co_purchase_counter = Counter() # Iterate through each user\'s transactions for transactions in user_transactions.values(): # Iterate through each transaction for transaction in transactions: if product_id in transaction: # Add products to the counter that are bought together with product_id for prod in transaction: if prod != product_id: co_purchase_counter[prod] += 1 # Find the product with the highest frequency, smallest ID in case of tie most_common_product = min(co_purchase_counter.items(), key=lambda x: (-x[1], x[0])) return most_common_product[0]"},{"question":"# Scenario A company is developing a recommendation engine for an e-commerce platform. A key component of this system is identifying the common items in multiple users\' wishlists and suggesting those items to other users with similar interests. # Task Implement a function `common_wishlist_items` that takes a dictionary where keys are user IDs and values are lists of items in each user\'s wishlist. The function should return a dictionary where keys are tuples of user IDs and the values are lists of common items in their wishlists. # Input - A dictionary where: - keys are user IDs (strings) - values are lists of items (strings) # Output - A dictionary with: - keys as tuples of user ID pairs (strings in each tuple) - values lists of items (strings) that are common in both users\' wishlists. # Constraints - The dictionary will contain at least 2 users. - Each list of items will contain at least 1 item and at most 100 items. - Each item is a non-empty string with no repeating items in any user\'s wishlist. # Example ```python wishlists = { \'user1\': [\'itemA\', \'itemB\', \'itemC\'], \'user2\': [\'itemB\', \'itemC\', \'itemD\'], \'user3\': [\'itemC\', \'itemE\', \'itemF\'] } ``` Calling `common_wishlist_items(wishlists)` should return: ```python { (\'user1\', \'user2\'): [\'itemB\', \'itemC\'], (\'user1\', \'user3\'): [\'itemC\'], (\'user2\', \'user3\'): [\'itemC\'] } ``` # Note Ensure your function handles cases with no common items appropriately by returning an empty list for that user pair. ```python def common_wishlist_items(wishlists): Identify common items in multiple users\' wishlists. Args: wishlists (dict): A dictionary where keys are user IDs and values are lists of items. Returns: dict: A dictionary where keys are tuples of user ID pairs and values are lists of common items. from itertools import combinations # Identify all unique pairs of users user_pairs = combinations(wishlists.keys(), 2) # Initialize the result dictionary result = {} # Iterate over each pair and find common items for user1, user2 in user_pairs: common_items = list(set(wishlists[user1]) & set(wishlists[user2])) result[(user1, user2)] = common_items return result ```","solution":"def common_wishlist_items(wishlists): Identify common items in multiple users\' wishlists. Args: wishlists (dict): A dictionary where keys are user IDs and values are lists of items. Returns: dict: A dictionary where keys are tuples of user ID pairs and values are lists of common items. from itertools import combinations # Identify all unique pairs of users user_pairs = combinations(wishlists.keys(), 2) # Initialize the result dictionary result = {} # Iterate over each pair and find common items for user1, user2 in user_pairs: common_items = list(set(wishlists[user1]) & set(wishlists[user2])) result[(user1, user2)] = common_items return result"},{"question":"# Unique Character String Determination You are required to implement a function to determine if all characters in a given string are unique. The function should return `True` if all characters are unique, and `False` otherwise. You may not use any additional data structures. # Function Signature ```python def is_unique(s: str) -> bool: pass ``` # Input - A single string `s` where `0 <= len(s) <= 100`. # Output - A boolean value `True` if all characters in the string are unique, `False` otherwise. # Constraints - The input string contains only ASCII characters. - You may not use any additional data structures (e.g., list or set). # Performance Requirements - The solution should be efficient with a time complexity of O(n) and space complexity of O(1), where n is the length of the string. # Examples ```python >>> is_unique(\\"abcdef\\") True >>> is_unique(\\"aabbcc\\") False >>> is_unique(\\"12345\\") True >>> is_unique(\\"\\") True >>> is_unique(\\"aa\\") False ``` # Notes - Consider edge cases, such as an empty string, where the result is naturally `True` since there are no characters to repeat. - Ensure that the function handles all valid ASCII characters appropriately.","solution":"def is_unique(s: str) -> bool: Determine if all characters in a given string are unique. if len(s) > 128: # There are only 128 unique ASCII characters return False for i in range(len(s)): for j in range(i + 1, len(s)): if s[i] == s[j]: return False return True"},{"question":"# Question: Matrix Transpose and Trace Calculation You are required to implement functions that will handle matrix operations: transposing a matrix and calculating the trace of a square matrix. The transpose of a matrix is an operator that flips a matrix over its diagonal, switching the row and column indices of the matrix. The trace of a square matrix is the sum of its diagonal elements (from the top left to the bottom right). Implement the Following Functions: **1. Function `transpose_matrix(matrix: list) -> list`:** * **Input**: A list of lists, where each inner list represents a row of the matrix (integers or floating-point numbers). * **Output**: A list of lists, representing the transposed matrix. * **Constraints**: * Raise a `ValueError` if the input is not a valid matrix (i.e., not all rows have the same length). **2. Function `calculate_trace(matrix: list) -> float`:** * **Input**: A list of lists, where each inner list represents a row of a square matrix (integers or floating-point numbers). * **Output**: A floating-point number representing the trace of the square matrix. * **Constraints**: * Raise a `ValueError` if the input matrix is not square or if it is not a valid matrix. Example ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[7, 8], [9, 10], [11, 12]]) [[7, 9, 11], [8, 10, 12]] >>> transpose_matrix([[1]]) [[1]] >>> calculate_trace([[1, 2], [3, 4]]) 5.0 >>> calculate_trace([[5, 7], [11, 13]]) 18.0 >>> calculate_trace([[2.5, 3.1], [4.7, 5.8]]) 8.3 >>> calculate_trace([[3]]) 3.0 ``` Notes: * Assume matrices contain at least one element. * Ensure proper error handling for invalid inputs, such as non-uniform row lengths or non-square matrices. * The trace of an empty matrix or invalid matrix should raise a `ValueError`. Performance Requirements * Your implementations should aim for simplicity and clarity, with an expected time complexity of O(n^2) for both functions, where n is the number of rows/columns. **Good Luck!**","solution":"def transpose_matrix(matrix: list) -> list: Transposes the given matrix. Args: matrix (list of list of int/float): The input matrix to be transposed. Returns: list of list of int/float: The transposed matrix. Raises: ValueError: If the input is not a valid matrix (i.e., not all rows have the same length). if not matrix or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") if any(len(row) != len(matrix[0]) for row in matrix): raise ValueError(\\"All rows must have the same length\\") return [list(row) for row in zip(*matrix)] def calculate_trace(matrix: list) -> float: Calculates the trace of the given square matrix. Args: matrix (list of list of int/float): The input square matrix. Returns: float: The trace of the square matrix. Raises: ValueError: If the input matrix is not square or if it is not a valid matrix. if not matrix or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Matrix must be square\\") return float(sum(matrix[i][i] for i in range(n)))"},{"question":"# Coding Assessment Question: Generate All Valid Parentheses Combinations Scenario: You are asked to generate all combinations of well-formed parentheses for a given number of pairs. This is a common problem in coding interviews which tests your understanding of recursion and depth-first search (DFS). Problem: Write a function called `generateParentheses` that generates all combinations of `n` pairs of well-formed parentheses. Input and Output Formats: * **generateParentheses(n: int) -> List[str]**: Returns a list of strings, where each string represents a valid combination of `n` pairs of parentheses. Constraints: * `1 <= n <= 8` (You can assume that the input will always be a positive integer within this range) Example Usage: ```python assert generateParentheses(3) == [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] assert generateParentheses(1) == [ \\"()\\" ] ``` Explanation: * For `n = 3`, there are 5 possible well-formed combinations. * For `n = 1`, there is only 1 possible well-formed combination. Implementation: Implement the function with the appropriate logic to satisfy the above requirements. Consider using a recursive approach to construct the combinations step by step, ensuring that at any point, the number of closing parentheses does not exceed the number of opening parentheses.","solution":"def generateParentheses(n: int): Generates all combinations of n pairs of well-formed parentheses. Args: n: The number of pairs of parentheses. Returns: A list of strings, where each string represents a valid combination of n pairs of parentheses. def backtrack(s, left, right): if len(s) == 2 * n: combinations.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) combinations = [] backtrack(\'\', 0, 0) return combinations"},{"question":"# Scenario As part of a consulting project for a logistics company, you are tasked with developing a function that helps in identifying routes within their transport network. The routes are represented as a directed acyclic graph (DAG). Each node in the graph represents a city, and an edge from node `u` to node `v` represents a direct route from city `u` to city `v`. To streamline the logistics, it\'s important to find all possible routes from a starting city to a destination city. # Task Write a function `find_all_routes(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]` that returns all possible routes from the start city to the end city. # Input - A dictionary `graph` representing the directed acyclic graph, where keys are city names (strings) and values are lists of city names (strings) representing direct routes. - Strings `start` and `end` representing the starting and ending cities respectively. # Output - A list of lists, where each list is a route from the start city to the end city, represented as a sequence of city names. # Example ```python input: { \'graph\': { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] }, \'start\': \'A\', \'end\': \'D\' } output: [[\'A\', \'B\', \'C\', \'D\'], [\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] ``` # Constraints - The input graph is a valid directed acyclic graph. - The cities\' names are unique. - The graph is non-empty and contains at least one route from the start city to the end city. - Assume there is at least one valid path from the start city to the end city. # Notes - Ensure to validate the input graph structure to be a DAG. - Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to explore all possible routes efficiently.","solution":"from typing import List, Dict def find_all_routes(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: def dfs(current, path): path.append(current) if current == end: result.append(path[:]) else: for next_city in graph.get(current, []): dfs(next_city, path) path.pop() result = [] dfs(start, []) return result"},{"question":"# Problem Statement You are tasked with implementing a word frequency counter that efficiently counts the frequency of each word from a given text file. This exercise will test your ability to read from files, utilize data structures for counting and storing, and handle text processing. # Goal Create a `WordFrequencyCounter` class that accomplishes the following: 1. Reads a text file and counts the occurrences of each word. 2. Ignores punctuation and is case-insensitive. 3. Provides a method to retrieve the top `n` most frequent words. # Implementation WordFrequencyCounter Class 1. **Read from File** * Implement a method `read_file(file_path)` to read the contents of a text file. 2. **Count Words** * Implement a method `count_words()` that processes the text, cleans it of punctuation, and counts each word\'s frequency. Use a suitable data structure such as a dictionary to store the word counts. 3. **Top N Words** * Implement a method `top_n_words(n)` that returns the `n` most frequent words sorted by frequency and then lexographically in case of ties. # Input and Output Format ```python class WordFrequencyCounter: def __init__(self): self.word_count = {} def read_file(self, file_path): # Implementation to read the file def count_words(self): # Implementation to count word frequency def top_n_words(self, n): # Implementation to get top n words ``` # Constraints and Performance Requirements 1. The text file can contain up to 1 million words. 2. The solution should handle large texts efficiently. 3. Punctuation should be ignored, and words should be counted in a case-insensitive manner. 4. Sort the words by their frequency in descending order, with ties broken by alphabetical order. # Example Scenario ```python # Example text file content: # \\"Hello, hello world! Hello everyone. Welcome to the world of programming.\\" # Create a WordFrequencyCounter instance wfc = WordFrequencyCounter() # Read file wfc.read_file(\'sample.txt\') # Count words wfc.count_words() # Get top 3 frequent words print(wfc.top_n_words(3)) # Expected Output: [(\'hello\', 3), (\'world\', 2), (\'everyone\', 1)] ``` # Write your WordFrequencyCounter class below: ```python import string class WordFrequencyCounter: def __init__(self): self.word_count = {} self.text = \\"\\" def read_file(self, file_path): with open(file_path, \'r\') as file: self.text = file.read() def count_words(self): if not self.text: raise ValueError(\\"Text is empty. Please read the file first.\\") # Remove punctuation and convert to lowercase translator = str.maketrans(\'\', \'\', string.punctuation) cleaned_text = self.text.translate(translator).lower() words = cleaned_text.split() for word in words: if word in self.word_count: self.word_count[word] += 1 else: self.word_count[word] = 1 def top_n_words(self, n): if not self.word_count: raise ValueError(\\"Word count is empty. Please count words first.\\") sorted_words = sorted(self.word_count.items(), key=lambda item: (-item[1], item[0])) return sorted_words[:n] ``` # Constraints and Performance Requirements 1. Ensure that the implementation can handle various input file sizes efficiently, up to 1 million words. 2. Use appropriate data structures and maintain an average time complexity of O(n log n) for sorting the word frequencies. Note: Save the example text in `sample.txt` for testing the implementation.","solution":"import string class WordFrequencyCounter: def __init__(self): self.word_count = {} self.text = \\"\\" def read_file(self, file_path): with open(file_path, \'r\') as file: self.text = file.read() def count_words(self): if not self.text: raise ValueError(\\"Text is empty. Please read the file first.\\") # Remove punctuation and convert to lowercase translator = str.maketrans(\'\', \'\', string.punctuation) cleaned_text = self.text.translate(translator).lower() words = cleaned_text.split() for word in words: if word in self.word_count: self.word_count[word] += 1 else: self.word_count[word] = 1 def top_n_words(self, n): if not self.word_count: raise ValueError(\\"Word count is empty. Please count words first.\\") sorted_words = sorted(self.word_count.items(), key=lambda item: (-item[1], item[0])) return sorted_words[:n]"},{"question":"Scenario: You are building a search module for a large dataset where objects have a hierarchical structure. Each object is associated with a category and subcategories in a tree format, and users can look up objects by specifying a category and/or subcategories. # Question: Implement a function to efficiently search for all objects that match a given category path in the hierarchy. The hierarchy is represented by a nested dictionary where the keys are categories, and the values are either further subcategory dictionaries or lists of objects. # Function Signature: * **function name**: `search_hierarchy` * **inputs**: - `hierarchy` (Dict[str, Any]): A nested dictionary representing the hierarchical structure. Categories are strings, and the lowest level dictionaries contain lists of objects. - `path` (List[str]): A list of strings representing the path of categories to search for. * **outputs**: - `List[Any]`: A list of all objects that match the given category path. # Constraints: 1. `path` may be empty, in which case return all objects in the hierarchy. 2. The `hierarchy` dictionary and all nested dictionaries will contain at most 100 categories. 3. Within each category, there are at most 1000 objects. # Examples: ```python # Example usage: hierarchy = { \\"Electronics\\": { \\"Computers\\": { \\"Laptops\\": [\\"Laptop1\\", \\"Laptop2\\"], \\"Desktops\\": [\\"Desktop1\\"] }, \\"Cameras\\": [\\"Camera1\\", \\"Camera2\\"] }, \\"Furniture\\": { \\"Chairs\\": [\\"Chair1\\", \\"Chair2\\"], \\"Tables\\": [\\"Table1\\"] } } path = [\\"Electronics\\", \\"Computers\\", \\"Laptops\\"] result = search_hierarchy(hierarchy, path) print(result) # Expected Output: [\\"Laptop1\\", \\"Laptop2\\"] path = [\\"Furniture\\"] result = search_hierarchy(hierarchy, path) print(result) # Expected Output: [\\"Chair1\\", \\"Chair2\\", \\"Table1\\"] path = [] result = search_hierarchy(hierarchy, path) print(result) # Expected Output: [\\"Laptop1\\", \\"Laptop2\\", \\"Desktop1\\", \\"Camera1\\", \\"Camera2\\", \\"Chair1\\", \\"Chair2\\", \\"Table1\\"] ``` # Additional Notes: - If the given path is not valid (does not exist in the hierarchy), return an empty list. - Ensure to handle edge cases where the input path might lead to an intermediate category with no objects. ```python def search_hierarchy(hierarchy, path): def search_helper(node, sub_path): if not sub_path: # Collect all objects from current node recursively if isinstance(node, list): return node elif isinstance(node, dict): objects = [] for key in node: objects.extend(search_helper(node[key], sub_path)) return objects else: return [] first, *rest = sub_path if first in node: return search_helper(node[first], rest) else: return [] return search_helper(hierarchy, path) ```","solution":"def search_hierarchy(hierarchy, path): def search_helper(node, sub_path): if not sub_path: # Collect all objects from current node recursively if isinstance(node, list): return node elif isinstance(node, dict): objects = [] for key in node: objects.extend(search_helper(node[key], sub_path)) return objects else: return [] first, *rest = sub_path if first in node: return search_helper(node[first], rest) else: return [] return search_helper(hierarchy, path)"},{"question":"# K-Nearest Neighbors Classification You are tasked with implementing a K-Nearest Neighbors (KNN) classification model from scratch. Your task is to: 1. Download and process a given dataset. 2. Implement the KNN algorithm to classify new data points based on the majority class of their k-nearest neighbors. 3. Evaluate the model using accuracy. Dataset The dataset contains three columns, `Feature1`, `Feature2`, and `Label`, with the first row containing headers. Each row represents two features of a data point and its corresponding class label. **Download URL**: ``` https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv ``` Note: For simplicity, consider only the first two features of the Iris dataset. Task Requirements 1. **Function to Collect Dataset**: - Read and return the dataset as a list of tuples where each tuple contains features and the corresponding label. - Parse the CSV data from the URL. 2. **Function to Implement KNN**: - Compute the distance between the input data point and all other data points in the dataset. - Identify the k-nearest neighbors and classify the input data point based on the majority class of these neighbors. 3. **Function to Compute Accuracy**: - Compare the predicted labels with the actual labels and calculate the accuracy of the model. 4. **Main Execution**: - Load the data, split it into training and test sets, and run the KNN algorithm. - Print the accuracy of the model. Function Signatures You should implement the following functions: 1. `collect_dataset() -> List[Tuple[float, float, int]]` 2. `knn_classify(k: int, train_data: List[Tuple[float, float, int]], test_point: Tuple[float, float]) -> int` 3. `calculate_accuracy(predictions: List[int], actual_labels: List[int]) -> float` 4. `run_knn_classification(k: int, train_data: List[Tuple[float, float, int]], test_data: List[Tuple[float, float, int]]) -> float` Input & Output Format - Input: **None**. The function should fetch the dataset and perform computations internally. - Output: **Accuracy of the KNN model**, printed in the console. Example ```python def main(): # Collect and process the dataset data = collect_dataset() # Split the dataset into training and test sets (e.g., 80/20 split) split_index = int(0.8 * len(data)) train_data = data[:split_index] test_data = data[split_index:] # Run KNN classification k = 5 accuracy = run_knn_classification(k, train_data, test_data) print(f\\"Model Accuracy: {accuracy:.2f}\\") if __name__ == \\"__main__\\": main() ``` Constraints - Ensure to handle network errors while fetching the dataset. - Validate numerical stability in distance calculations. - The model should run within a reasonable time frame for reasonably large datasets (e.g., up to 10,000 data points). This question maintains consistency with the provided sample concerning the dataset manipulation, algorithm implementation, and evaluation metric. It introduces a fresh context (KNN classification) while aligning well with the set\'s scope and complexity.","solution":"import csv import math import requests from typing import List, Tuple from collections import Counter def collect_dataset() -> List[Tuple[float, float, int]]: url = \\"https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv\\" response = requests.get(url) response.raise_for_status() data = [] lines = response.text.strip().split(\'n\') reader = csv.reader(lines) for row in reader: feature1 = float(row[0]) feature2 = float(row[1]) label = 0 if row[-1] == \'Iris-setosa\' else (1 if row[-1] == \'Iris-versicolor\' else 2) data.append((feature1, feature2, label)) return data def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def knn_classify(k: int, train_data: List[Tuple[float, float, int]], test_point: Tuple[float, float]) -> int: distances = [] for point in train_data: dist = euclidean_distance(point[:2], test_point) distances.append((dist, point[2])) distances.sort(key=lambda x: x[0]) k_nearest_labels = [label for _, label in distances[:k]] most_common = Counter(k_nearest_labels).most_common(1)[0][0] return most_common def calculate_accuracy(predictions: List[int], actual_labels: List[int]) -> float: correct_predictions = sum(p == a for p, a in zip(predictions, actual_labels)) accuracy = correct_predictions / len(actual_labels) * 100 return accuracy def run_knn_classification(k: int, train_data: List[Tuple[float, float, int]], test_data: List[Tuple[float, float, int]]) -> float: test_points = [point[:2] for point in test_data] actual_labels = [point[2] for point in test_data] predictions = [knn_classify(k, train_data, test_point) for test_point in test_points] accuracy = calculate_accuracy(predictions, actual_labels) return accuracy"},{"question":"# Problem Statement Given a list of non-negative integers and a target number, determine if there is a subset of the given numbers that sums to the target number. You are to return a boolean value indicating whether such a subset exists. # Function Signature ```python def subset_sum(nums: List[int], target: int) -> bool: pass ``` # Input * `nums`: A list of non-negative integers where the length of `nums` is between 1 and 1000, inclusive. * `target`: A non-negative integer between 0 and 10000, inclusive. # Output * Returns a boolean value `True` if there exists a subset of `nums` that sums to `target`, otherwise returns `False`. # Constraints * You should aim for an efficient solution considering both time and space complexity. * Each number in the list can be used only once. # Examples The function should operate as follows: ```python assert subset_sum([1, 2, 3, 7], 6) == True assert subset_sum([1, 2, 7, 1, 5], 10) == True assert subset_sum([1, 3, 4, 8], 6) == False ``` # Additional Notes * Consider edge cases where the target is zero, or where no combination of numbers can reach the target. * Dynamic programming could be a useful technique to solve this problem efficiently. # Hints 1. Use a dynamic programming approach to store results of subproblems. 2. Think of utilizing a 2D array `dp` where `dp[i][j]` represents whether a subset of the first `i` elements can sum to `j`. 3. Optimize space usage by reducing the number of states you need to track at any point in time.","solution":"from typing import List def subset_sum(nums: List[int], target: int) -> bool: Determine if there is a subset of the given numbers that sums to the target number. n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for t in range(target, num - 1, -1): dp[t] = dp[t] or dp[t - num] return dp[target]"},{"question":"# Coding Question: Longest Common Subsequence Given two sequences of integers, implement an algorithm to find the length of their longest common subsequence (LCS). Use dynamic programming to ensure efficiency. Function Signature ```python def longest_common_subsequence(seq1: List[int], seq2: List[int]) -> int: \'\'\' Params: - seq1: A list of integers representing the first sequence. - seq2: A list of integers representing the second sequence. Returns: - An integer representing the length of the longest common subsequence. \'\'\' ``` Example ```python # Sample sequences: seq1 = [1, 3, 4, 1, 2, 8] seq2 = [3, 4, 1, 2, 8, 5] # Expected LCS length: # The LCS is [3, 4, 1, 2, 8], thus the length should be 5. print(longest_common_subsequence(seq1, seq2)) # Output: 5 ``` Constraints - The length of each sequence does not exceed 1000. - Elements in the sequences are integers between -1000 and 1000. Detailed Description 1. **Dynamic Programming Table**: Use a 2D table where the cell dp[i][j] represents the length of the LCS of the sequences seq1[0..i-1] and seq2[0..j-1]. 2. **Table Initialization**: Initialize the first row and first column of the table with zeros, as the LCS of an empty sequence with any other sequence is zero. 3. **Filling the Table**: Iterate through each element of both sequences, and fill the table based on the following rules: - If seq1[i-1] == seq2[j-1], then dp[i][j] = dp[i-1][j-1] + 1. - Otherwise, dp[i][j] = max(dp[i-1][j], dp[i][j-1]). 4. **Result Extraction**: The value at dp[len(seq1)][len(seq2)] will be the length of the LCS. Good luck, and make sure to optimize your dynamic programming approach to handle the worst-case scenarios efficiently!","solution":"from typing import List def longest_common_subsequence(seq1: List[int], seq2: List[int]) -> int: Function to find the length of the longest common subsequence of two sequences. Uses dynamic programming for an efficient solution. Params: - seq1: A list of integers representing the first sequence. - seq2: A list of integers representing the second sequence. Returns: - An integer representing the length of the longest common subsequence. m, n = len(seq1), len(seq2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): if seq1[i] == seq2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) return dp[m][n]"},{"question":"# Coding Question **Problem Statement**: You\'re given a directory tree represented in a JSON-like format, where directories can contain other directories and files. A directory is represented with an object, and files are represented with strings. Write a function `flatten_directory` that flattens the directory structure into a list of paths to each file. Each path should be a string with directory names separated by `/` (Unix-like). **Function Signature**: ```python def flatten_directory(directory: dict, current_path: str = \'\') -> list[str]: ``` **Input**: - `directory`: A dictionary representing the directory structure. The keys are strings (directory or file names), and the values are either nested dictionaries (for directories) or `None` (for files). - `current_path`: A string representing the current path during recursion (default is an empty string). **Output**: - Return a list of strings, where each string is the path (from root) to a file. **Constraints**: - Directory and file names may contain alphanumeric characters, underscores, and dashes. - The directory parameter will always be a valid directory structure, without any cycles. **Examples**: ```python >>> flatten_directory({\'a\': {\'b\': {\'c\': None}}, \'d\': {\'e\': None}, \'f.txt\': None}) [\'a/b/c\', \'d/e\', \'f.txt\'] >>> flatten_directory({\'root\': {\'folder1\': {\'file1.txt\': None}, \'folder2\': {\'file2.txt\': None}}}) [\'root/folder1/file1.txt\', \'root/folder2/file2.txt\'] >>> flatten_directory({\'docs\': {\'readme.md\': None, \'tutorial\': {\'part1.md\': None, \'part2.md\': None}}, \'image.png\': None}) [\'docs/readme.md\', \'docs/tutorial/part1.md\', \'docs/tutorial/part2.md\', \'image.png\'] >>> flatten_directory({}) [] ``` # Notes: - Your function should utilize recursion to traverse the directory structure. - The order of the paths in the returned list does not matter. - If the directory is empty, return an empty list. - Handle edge cases, such as when the structure only contains files directly under the root. Ensure your function is efficient and handles all specified edge cases properly. Aim for clear and readable code.","solution":"def flatten_directory(directory: dict, current_path: str = \'\') -> list: paths = [] for name, content in directory.items(): new_path = f\'{current_path}/{name}\' if current_path else name if content is None: paths.append(new_path) else: paths.extend(flatten_directory(content, new_path)) return paths"},{"question":"# Scenario You are required to implement a function that computes the intersection of multiple lists, returning a list that contains only the elements that are present in all of the given lists. The elements should be returned in the order they appear in the first list. # Requirements **Function Signature**: ```python def intersection(*args: list[int]) -> list[int]: pass ``` # Input & Output Formats * **Input**: Arbitrary number of lists `*args`. Each list contains integer elements. * **Output**: A list `[int]` containing the intersection of elements in the order they appear in the first list. # Constraints * Each list can have up to 1,000 elements. * Elements in the lists are between 1 and 10,000. * The number of lists (`*args`) does not exceed 100. # Performance Requirements * Time Complexity: O(n * m) where n is the number of lists and m is the average length of the lists. * Space Complexity: O(m) where m is the number of common elements. # Example ```python >>> intersection([1, 2, 3, 4], [2, 3, 4, 5], [2, 4, 6, 8]) [2, 4] >>> intersection([10, 20, 30], [20, 30, 40], [5, 20, 25, 30]) [20, 30] ```","solution":"def intersection(*args: list[int]) -> list[int]: if not args: return [] common_elements = set(args[0]) for lst in args[1:]: common_elements.intersection_update(lst) result = [x for x in args[0] if x in common_elements] return result"},{"question":"# Problem Description You are given an array of integers. Your task is to write a function that rotates the array to the right by `k` steps, where `k` is a non-negative integer. Implement two versions of the function: one using an iterative approach and the other using a recursive approach. # Function Signature - **Iterative Version**: `def rotate_array_iteratively(nums: list[int], k: int) -> list[int]` - **Recursive Version**: `def rotate_array_recursively(nums: list[int], k: int) -> list[int]` # Input - `nums`: A list of integers. - `k`: A non-negative integer indicating the number of steps to rotate the array to the right. # Output Return the rotated array. # Constraints 1. The list will have at most (10^5) elements. 2. The elements in the list are between (-10^6) and (10^6). 3. (0 leq k leq 10^6) # Examples ```python assert rotate_array_iteratively([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_iteratively([-1, -100, 3, 99], 2) == [3, 99, -1, -100] assert rotate_array_recursively([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_recursively([1, 2], 0) == [1, 2] assert rotate_array_recursively([1], 10) == [1] ``` # Explanation - In the first example, rotating the array `[1, 2, 3, 4, 5, 6, 7]` by `3` steps to the right results in `[5, 6, 7, 1, 2, 3, 4]`. - In the second example, rotating the array `[-1, -100, 3, 99]` by `2` steps to the right results in `[3, 99, -1, -100]`. - In the recursive examples, the functions should produce the same results as the iterative ones. # Notes - Consider edge cases such as: - Rotations where `k` is greater than the length of the list, e.g., `k` can be reduced modulo the length of the list. - Empty lists should return an empty list. - Handling lists of length 1 or 2 gracefully. - Ensure that the recursive function does not lead to a stack overflow with large inputs.","solution":"def rotate_array_iteratively(nums: list[int], k: int) -> list[int]: if not nums or k == 0: return nums n = len(nums) k = k % n # If k is greater than the length of nums, reduce it return nums[-k:] + nums[:-k] def rotate_array_recursively(nums: list[int], k: int) -> list[int]: if not nums or k == 0: return nums n = len(nums) k = k % n def helper(arr, step): if step == 0: return arr return helper(arr[-1:] + arr[:-1], step - 1) return helper(nums, k)"},{"question":"# Coding Task: Extended Fibonacci Sequence Generator **Objective**: Implement an enhanced version of the Fibonacci sequence generator that includes finding the nth Fibonacci number, checking whether a given number is a Fibonacci number, and generating a list of the first `m` Fibonacci numbers in reverse order. Functions to Implement: 1. **`find_fibonacci(n: int) -> int`**: - **Input**: - `n` (Integer): The position (1-based) in the sequence for which to find the Fibonacci number. - **Output**: - Returns the nth Fibonacci number (Integer). - **Constraints**: - `n` must be a positive integer greater than 0. - **Exception Handling**: - Raise `ValueError` if `n <= 0`. - Raise `TypeError` if `n` is not an integer. 2. **`is_fibonacci(number: int) -> bool`**: - **Input**: - `number` (Integer): The number to check if it is a Fibonacci number. - **Output**: - Returns `True` if the given number is a Fibonacci number, otherwise `False`. - **Constraints**: - `number` must be a positive integer greater than 0. - **Exception Handling**: - Raise `ValueError` if `number <= 0`. - Raise `TypeError` if `number` is not an integer. 3. **`reverse_fibonacci_list(m: int) -> list`**: - **Input**: - `m` (Integer): The number of Fibonacci numbers to list starting from the latest one in reverse order. - **Output**: - Returns a list of the first `m` Fibonacci numbers in reverse order. - **Constraints**: - `m` must be a positive integer greater than 0. - **Exception Handling**: - Raise `ValueError` if `m <= 0`. - Raise `TypeError` if `m` is not an integer. **Example Usages**: ```python assert find_fibonacci(6) == 8 assert is_fibonacci(8) == True assert is_fibonacci(10) == False assert reverse_fibonacci_list(6) == [8, 5, 3, 2, 1, 1] ``` **Notes**: - The Fibonacci sequence is defined as: F(1) = 1, F(2) = 1, and F(n) = F(n-1) + F(n-2) for n > 2. - Ensure that your code handles large input efficiently. - Provide appropriate documentation and doctests for each function. - Optimize the implementation where possible to lower the time complexity.","solution":"def find_fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: The position in the sequence (must be greater than 0). :return: The nth Fibonacci number. :raises ValueError: If n is less than or equal to 0. :raises TypeError: If n is not an integer. if not isinstance(n, int): raise TypeError(\\"n must be an integer\\") if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(n - 2): a, b = b, a + b return b def is_fibonacci(number: int) -> bool: Checks if a given number is a Fibonacci number. :param number: The number to check (must be greater than 0). :return: True if the number is a Fibonacci number, otherwise False. :raises ValueError: If the number is less than or equal to 0. :raises TypeError: If the number is not an integer. if not isinstance(number, int): raise TypeError(\\"number must be an integer\\") if number <= 0: raise ValueError(\\"number must be a positive integer\\") a, b = 1, 1 if number == 1: return True while b < number: a, b = b, a + b return b == number def reverse_fibonacci_list(m: int) -> list: Generates a list of the first m Fibonacci numbers in reverse order. :param m: The number of Fibonacci numbers to list (must be greater than 0). :return: A list of the first m Fibonacci numbers in reverse order. :raises ValueError: If m is less than or equal to 0. :raises TypeError: If m is not an integer. if not isinstance(m, int): raise TypeError(\\"m must be an integer\\") if m <= 0: raise ValueError(\\"m must be a positive integer\\") fib_list = [1, 1] for _ in range(m - 2): fib_list.append(fib_list[-1] + fib_list[-2]) return fib_list[:m][::-1]"},{"question":"# Problem Statement You are given an encoded message containing digits only, and you need to decode it to count the total number of ways to decode it. Each digit or combination of digits can represent a letter A-Z (1=A, 2=B, ..., 26=Z). Example: ``` \'12\' can be decoded as \'AB\' (1 2) or \'L\' (12). The count is 2. \'226\' can be decoded as \'BZ\' (2 26) or \'VF\' (22 6) or \'BBF\' (2 2 6). The count is 3. \'0\' cannot be decoded. \'10\' can be decoded as \'J\'. The count is 1. ``` Write a function `count_decodings(message: str) -> int` that returns the number of ways to decode the given message. # Function Signature ```python def count_decodings(message: str) -> int: ``` # Input * `message`: A string `message` containing only digits (0-9). # Output * An integer representing the total number of ways to decode the message. # Constraints * The input message will only contain digits and its length will not exceed 100 digits. # Example Given the messages: ```python print(count_decodings(\\"12\\")) # Output: 2 print(count_decodings(\\"226\\")) # Output: 3 print(count_decodings(\\"0\\")) # Output: 0 print(count_decodings(\\"10\\")) # Output: 1 ``` # Requirements * Use dynamic programming to solve the problem efficiently. * Consider edge cases such as messages containing \'0\' and invalid sequences. # Note * The function should handle various input scenarios efficiently. * Think about how to handle a leading \'0\' or segments of the message where a valid letter representation is not possible (e.g., \'30\' or \'012\').","solution":"def count_decodings(message: str) -> int: if not message or message[0] == \'0\': return 0 n = len(message) dp = [0] * (n + 1) dp[0] = 1 # An empty message can be decoded in one way for i in range(1, n + 1): if message[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and (message[i - 2] == \'1\' or (message[i - 2] == \'2\' and message[i - 1] <= \'6\')): dp[i] += dp[i - 2] return dp[n]"},{"question":"# Caesar Cipher with Custom Shift **Context**: The Caesar Cipher is one of the simplest and most widely known encryption techniques. It involves shifting each letter in the plaintext by a fixed number of positions down or up the alphabet. This problem extends the concept by allowing a custom numerical shift to be applied to encrypt or decrypt the text. **Task**: Write a program that performs a custom Caesar Cipher encryption or decryption on a given text based on a specified numerical shift. The program should be able to handle both uppercase and lowercase letters, and ignore non-alphabetic characters. # Input: 1. An integer ( shift ), representing the number of positions each letter in the text will be shifted. A positive shift indicates forward direction, while a negative shift indicates backward direction. 2. A string ( option ) either \'Encrypt\' or \'Decrypt\' indicating the operation. 3. A string ( text ) representing the text to be encrypted or decrypted. # Output: - For \'Encrypt\', output the encrypted text. - For \'Decrypt\', output the decrypted text. # Example: ```python Input: shift = 3 option = \'Encrypt\' text = \\"Hello, World!\\" Output: Encrypted text: \\"Khoor, Zruog!\\" Input: shift = 3 option = \'Decrypt\' text = \\"Khoor, Zruog!\\" Output: Decrypted text: \\"Hello, World!\\" ``` **Constraints**: - The shift will be an integer between -25 and 25. - Encrypt and decrypt only alphabetic characters, ignoring punctuation and other non-alphabet characters. - The text can consist of any printable ASCII characters. **Note**: - Ensure your solution correctly maintains the case of each letter. - Validate the input to ensure proper formatting and acceptable range for shift.","solution":"def caesar_cipher(shift, option, text): Applies Caesar Cipher encryption or decryption based on the provided shift and option. Args: shift (int): The number of positions to shift the letters. option (str): \'Encrypt\' or \'Decrypt\' indicating the operation. text (str): The text to be encrypted or decrypted. Returns: str: The resulting encrypted or decrypted text. if not isinstance(shift, int) or abs(shift) > 25: raise ValueError(\\"Shift must be an integer between -25 and 25\\") if option not in [\'Encrypt\', \'Decrypt\']: raise ValueError(\\"Option must be \'Encrypt\' or \'Decrypt\'\\") if not isinstance(text, str): raise ValueError(\\"Text must be a string\\") shift_direction = shift if option == \'Encrypt\' else -shift result = [] for char in text: if char.isalpha(): shift_base = ord(\'A\') if char.isupper() else ord(\'a\') shifted_char = chr((ord(char) - shift_base + shift_direction) % 26 + shift_base) result.append(shifted_char) else: result.append(char) return \'\'.join(result)"},{"question":"# String Manipulation and Dictionary Usage Question You are tasked with writing a function that takes a string and a dictionary of substring replacements, and returns a new string with all the specified substrings replaced according to the dictionary. # Problem Statement Write a Python function `replace_substrings(s: str, replacements: dict) -> str` that takes a string `s` and a dictionary `replacements`, and returns a new string where all occurrences of the substrings specified in the dictionary keys are replaced with their corresponding values. Implement: ```python def replace_substrings(s: str, replacements: dict) -> str: pass ``` # Constraints: * The input must be a string; otherwise, raise a `TypeError`. * The replacements dictionary keys and values must all be strings; otherwise, raise a `TypeError`. * The function should perform replacements in a way that prevents overlapping of substrings. # Example: ```python >>> replace_substrings(\\"hello world\\", {\\"hello\\": \\"hi\\", \\"world\\": \\"earth\\"}) \'hi earth\' >>> replace_substrings(\\"foo bar foo\\", {\\"foo\\": \\"baz\\", \\"bar\\": \\"qux\\"}) \'baz qux baz\' >>> replace_substrings(\\"aabbcc\\", {\\"aa\\": \\"x\\", \\"bb\\": \\"y\\", \\"cc\\": \\"z\\"}) \'xyz\' >>> replace_substrings(\\"\\", {\\"any\\": \\"thing\\"}) \'\' >>> replace_substrings(\\"test\\", []) Traceback (most recent call last): ... TypeError: Replacements must be a dictionary >>> replace_substrings(\\"test\\", {\\"test\\": 123}) Traceback (most recent call last): ... TypeError: Replacement values must be strings >>> replace_substrings(123, {\\"test\\": \\"xyz\\"}) Traceback (most recent call last): ... TypeError: Input must be a string ``` # Notes: 1. You are not allowed to use any library functions like `str.replace` for direct string substitution. 2. Ensure replacements do not overlap and do not affect subsequent replacements for other substrings. 3. Handle edge cases and error conditions as shown in the examples. # Performance Requirements: * The function should be efficient with a time complexity of O(n * m) where n is the length of the input string and m is the size of the replacements dictionary.","solution":"def replace_substrings(s: str, replacements: dict) -> str: Replace substrings in the input string `s` according to the replacements dictionary. Args: s (str): Input string. replacements (dict): Dictionary where keys are substrings to be replaced and values are the replacements. Returns: str: The string with specified replacements. Raises: TypeError: If input s is not a string or replacements is not a dict, or if any key/value in the dictionary is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if not isinstance(replacements, dict): raise TypeError(\\"Replacements must be a dictionary\\") for key, value in replacements.items(): if not isinstance(key, str) or not isinstance(value, str): raise TypeError(\\"Replacement keys and values must be strings\\") # Build a list to process the replacements result = [] i = 0 while i < len(s): replaced = False for key in replacements: if s[i:i+len(key)] == key: result.append(replacements[key]) i += len(key) replaced = True break if not replaced: result.append(s[i]) i += 1 return \'\'.join(result)"},{"question":"# Coding Assessment Question Context and Scenario: You are developing a ridesharing application and need to manage a dynamic list of drivers based on their ratings. To optimize the driver assignment process, the drivers are arranged in descending order of their ratings. You will frequently need to insert new ratings and perform rank lookups to find a driver\'s position in the sorted list. Task: 1. **Function 1: Sorted Insertion** Write a function `sorted_insertion_desc(collection, rating)` that inserts a `rating` into a sorted collection `collection` such that the descending order is maintained. Implement the functionality without using Python\'s built-in sorting functions. ```python def sorted_insertion_desc(collection: list[float], rating: float) -> None: Insert a rating into the sorted collection while maintaining descending order. :param collection: A list of floats representing driver ratings in descending order. :param rating: The float rating to be inserted. pass ``` **Example:** ```python collection = [4.8, 4.5, 4.2, 3.9] sorted_insertion_desc(collection, 4.3) print(collection) # Output: [4.8, 4.5, 4.3, 4.2, 3.9] ``` 2. **Function 2: Binary Search** Write a function `binary_search_desc(collection, rating)` to find the index of a `rating` in a sorted collection using binary search. If the rating is not found, return -1. The function should also check whether the collection is sorted in descending order before performing the search. ```python def binary_search_desc(collection: list[float], rating: float) -> int: Searches for a rating in a sorted collection using binary search. :param collection: A list of floats representing driver ratings in descending order. :param rating: The float rating to search for. :return: The index of the rating if found, otherwise -1. pass ``` **Example:** ```python collection = [4.8, 4.5, 4.2, 3.9, 3.5] index = binary_search_desc(collection, 4.2) print(index) # Output: 2 index = binary_search_desc(collection, 4.1) print(index) # Output: -1 ``` Constraints: - Elements in the input collection are comparable and follow the same data type. - Your implementation should ensure that the input collection remains sorted after insertion. - You must handle edge cases (empty list, single-element list, rating absent from the collection). - You are not allowed to use Python’s built-in `bisect` module functions directly in your implementation. Performance Requirements: - Your solution should efficiently handle large data sets up to ( 10^6 ) elements for both the search and insert functions. - Ensure that searching and insertion operations run within logarithmic and linear time complexities respectively.","solution":"def sorted_insertion_desc(collection, rating): Insert a rating into the sorted collection while maintaining descending order. :param collection: A list of floats representing driver ratings in descending order. :param rating: The float rating to be inserted. # Initialize the position where the rating should be inserted position = len(collection) # Default to the end of the list # Traverse the list and find correct position for i, r in enumerate(collection): if rating > r: position = i break collection.insert(position, rating) def binary_search_desc(collection, rating): Searches for a rating in a sorted collection using binary search. :param collection: A list of floats representing driver ratings in descending order. :param rating: The float rating to search for. :return: The index of the rating if found, otherwise -1. left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == rating: return mid elif collection[mid] < rating: # Move left if the mid value is smaller (since list is DESC) right = mid - 1 else: # Move right if the mid value is larger left = mid + 1 return -1"},{"question":"# Coding Assessment Question **Context**: Parsing and analyzing numerical data from strings is a common task in data processing. One particular operation involves extracting and summing integers from a given text. **Question**: Implement a function `sum_of_integers_in_string(text: str) -> int` that calculates the sum of all integers present in the input text. **Function Signature**: ```python def sum_of_integers_in_string(text: str) -> int: ``` **Input**: * `text` (str): A string that may contain alphabetical characters, digits, and other non-numeric characters. **Output**: * An integer representing the sum of all the integer numbers found within the input string. **Constraints**: * The input string will contain only ASCII characters. * Integers in the input string are non-negative. * The input parameters are valid and do not require additional validation. * The function should handle input strings up to a length of 10,000 characters. **Performance Requirements**: * The solution should run with time complexity O(n), where n is the length of the input string. * The solution should use O(1) additional space for processing. **Examples**: 1. `sum_of_integers_in_string(\\"abc123xyz45\\") -> 168` 2. `sum_of_integers_in_string(\\"no1number2here345\\") -> 348` 3. `sum_of_integers_in_string(\\"5 apples and 10 oranges\\") -> 15` 4. `sum_of_integers_in_string(\\"large0zero\\") -> 0` 5. `sum_of_integers_in_string(\\"\\") -> 0` **Notes**: * The function should ignore non-digit characters while extracting integers. * Consecutive digits should be treated as a single integer (e.g., \\"123\\" should be interpreted as the integer 123). * The function should be efficient and handle edge cases such as empty strings or strings with no numeric content.","solution":"def sum_of_integers_in_string(text: str) -> int: Function to calculate the sum of all integers present in the input text. Parameters: text (str): A string containing alphabetical characters, digits, and other non-numeric characters. Returns: int: The sum of all integer numbers found within the input string. import re numbers = re.findall(r\'d+\', text) return sum(map(int, numbers))"},{"question":"# Kadane\'s Algorithm for Maximum Subarray Sum **Objective**: Write a function that implements Kadane\'s Algorithm to find the maximum sum of a contiguous subarray within a given list of integers. Function Signature ```python def max_subarray_sum(arr: list) -> int: ``` Input * A list of integers `arr` where: * `arr` contains `1 <= len(arr) <= 1000` elements. * Elements of `arr` are within the range `-10^6 <= arr[i] <= 10^6`. Output * An integer representing the maximum sum of a contiguous subarray. Constraints * The function should handle both positive and negative values in `arr`. * The function should return the correct result for all edge cases, including arrays with all negative numbers or all positive numbers. Example ```python >>> max_subarray_sum([4, -1, 2, 1]) 6 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-4, -2, -3, -1]) -1 >>> max_subarray_sum([5]) 5 ``` Scenario You are tasked with analyzing the financial performance of your company over time by examining changes in stock prices. By implementing Kadane\'s Algorithm, you can efficiently determine the most profitable period for investment by identifying the maximum sum of a contiguous subarray within the given list of daily changes in stock prices. Performance Requirements * The function should run in O(n) time complexity to ensure it handles the upper limit of input size effectively. * Consider optimizing the implementation to minimize auxiliary space usage.","solution":"def max_subarray_sum(arr: list) -> int: Implements Kadane\'s Algorithm to find the maximum sum of a contiguous subarray within a given list of integers. Parameters: arr (list): A list of integers. Returns: int: The maximum sum of a contiguous subarray. if not arr: return 0 max_current = max_global = arr[0] for number in arr[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"Question # Scenario You are given a problem related to analyzing substrings in sequences. Specifically, you need to determine the number of unique contiguous substrings of a given length that can be found in a larger input string. # Problem Statement Given a string (s) composed of lowercase English letters and an integer (k), your task is to count all unique substrings of length (k) in (s). Write a function to solve this problem. # Function Signature ```python def count_unique_substrings(s: str, k: int) -> int: ``` # Input * A string, `s` (1 ≤ len(s) ≤ 100,000), consisting solely of lowercase English letters. * An integer, `k` (1 ≤ k ≤ len(s)), representing the length of the substrings. # Output * An integer representing the number of unique substrings of length `k` found in `s`. # Example ```python >>> count_unique_substrings(\\"abcdefg\\", 3) 5 >>> count_unique_substrings(\\"abacab\\", 2) 4 >>> count_unique_substrings(\\"aaaaa\\", 2) 1 ``` # Constraints * The substrings are considered contiguous segments of the input string. * Pay attention to the efficiency of your solution since the input string can be quite large. * Use appropriate data structures to store and check for uniqueness efficiently. # Implementation Reminder * Consider the use of sets or hashmaps to track unique substrings. * Ensure to handle cases where (k) is equal to or larger than the length of the string properly. * Optimize your solution to achieve a time complexity suitable for large input sizes.","solution":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of unique substrings of length k in the given string s. :param s: The input string consisting of lowercase English letters. :param k: The length of the substrings to consider. :return: The number of unique substrings of length k. if k > len(s): return 0 unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"# Data Structures & Algorithms You have been assigned a task to help a company analyze their customer transactions. The company wants to identify the top `k` most frequent customers based on the amount of transactions they made. Task: Implement a function `top_k_customers(transactions: list[tuple[str, int]], k: int) -> list[str]` that returns a list of the top `k` customers who made the most transactions. Requirements: 1. **Input:** * `transactions` (list of tuples) - A list where each element is a tuple indicating a customer and their transaction amount. Example: `[(\\"Alice\\", 50), (\\"Bob\\", 20), (\\"Alice\\", 30), (\\"Charles\\", 40)]` * `k` (integer) - The number of top customers to retrieve. 2. **Output:** A list of strings representing the `k` top customers sorted by the number of transactions in descending order. * In case of a tie, return the customers in alphabetical order. 3. The function should handle the following edge cases: * When `transactions` list is empty or `k` is zero. * When `k` is greater than the number of unique customers. Constraints: * `1 <= len(transactions) <= 10^5` * `1 <= len(transactions[i][1]) <= 10^9` * `1 <= k <= 1000` Example: ```python transactions = [(\\"Alice\\", 50), (\\"Bob\\", 20), (\\"Alice\\", 30), (\\"Charles\\", 40), (\\"Bob\\", 70), (\\"Alice\\", 10)] k = 2 print(top_k_customers(transactions, k)) # Output: [\\"Alice\\", \\"Bob\\"] ``` This should return the top 2 customers, \\"Alice\\" and \\"Bob\\", based on their transaction frequency. Note: To solve this problem, consider using collections such as dictionaries to count the transactions per customer and then sort them accordingly to derive the top `k` customers. If applicable, make use of efficient data structures and algorithms to ensure performance for large datasets.","solution":"from collections import defaultdict import heapq def top_k_customers(transactions, k): Returns the top k customers sorted by the number of transactions in descending order. if not transactions or k == 0: return [] # Count the number of transactions for each customer transaction_count = defaultdict(int) for customer, amount in transactions: transaction_count[customer] += 1 # Use a heap to get the top k frequent customers heap = [(-v, k) for k, v in transaction_count.items()] heapq.heapify(heap) top_customers = [] for _ in range(min(k, len(heap))): top_customers.append(heapq.heappop(heap)[1]) return top_customers"},{"question":"# Palindrome Checker - Bitwise Optimization You are required to write a function that checks whether a given unsigned integer is a palindrome in its binary representation. Your solution should leverage bitwise operations to ensure efficiency. **Function Signature**: ```python def is_binary_palindrome(number: int) -> bool: ``` **Parameters**: - `number (int)`: The unsigned integer to be checked. **Returns**: - `bool`: `True` if the binary representation of the input integer is a palindrome, `False` otherwise. # Example: ```python assert is_binary_palindrome(5) == True # Binary 101 is a palindrome assert is_binary_palindrome(9) == True # Binary 1001 is a palindrome assert is_binary_palindrome(10) == False # Binary 1010 is not a palindrome assert is_binary_palindrome(1) == True # Binary 1 is a palindrome assert is_binary_palindrome(0) == True # Binary 0 is a palindrome assert is_binary_palindrome(8) == False # Binary 1000 is not a palindrome ``` # Constraints: * You must use bitwise operations to perform the palindrome check. * Avoid converting the integer to a string or other non-bitwise manipulation methods. * Handle edge cases like `0` and very large integers appropriately. * Your implementation should be efficient, ideally with a time complexity close to O(log n), where n is the number of bits required to represent the integer. # Additional Information: In binary, a number is a palindrome if it reads the same forwards and backwards. For example: * `5` in binary is `101`, which is a palindrome. * `9` in binary is `1001`, which is a palindrome. * `10` in binary is `1010`, which is not a palindrome. Utilize bitwise operations to reverse the binary digits and check for equality to achieve this.","solution":"def is_binary_palindrome(number: int) -> bool: Checks if the binary representation of an unsigned integer is a palindrome. if number == 0: return True original_number = number reversed_number = 0 while number > 0: reversed_number = (reversed_number << 1) | (number & 1) number >>= 1 return original_number == reversed_number"},{"question":"# Coding Assessment Question **Scenario**: You are developing a system for processing large text data efficiently. One common task is to find the longest common prefix (LCP) among multiple strings in the dataset. This has applications in various areas such as DNA sequencing, data compression, and more. To ensure efficient processing, you need to implement an algorithm to compute the LCP for an array of strings. **Task**: Implement the `LongestCommonPrefix` class by completing the following method: 1. **find_lcp**: ```python def find_lcp(self, strs: list[str]) -> str: ``` - **Input**: - `strs` (list[str]): A list of strings. - **Output**: - (str): The longest common prefix shared by all strings in the list. If there is no common prefix, return an empty string. **Constraints**: - The length of the list `strs` will not exceed `200`. - The length of any single string in `strs` will not exceed `200`. - All strings contain only lowercase English letters. **Example**: ```python strs1 = [\\"flower\\", \\"flow\\", \\"flight\\"] lcp_solver = LongestCommonPrefix() print(lcp_solver.find_lcp(strs1)) # Output: \\"fl\\" strs2 = [\\"dog\\", \\"racecar\\", \\"car\\"] print(lcp_solver.find_lcp(strs2)) # Output: \\"\\" strs3 = [\\"interspecies\\", \\"interstellar\\", \\"interstate\\"] print(lcp_solver.find_lcp(strs3)) # Output: \\"inters\\" ```","solution":"class LongestCommonPrefix: def find_lcp(self, strs: list[str]) -> str: if not strs: return \\"\\" min_length = min(len(s) for s in strs) common_prefix = [] for i in range(min_length): current_char = strs[0][i] if all(s[i] == current_char for s in strs): common_prefix.append(current_char) else: break return \\"\\".join(common_prefix)"},{"question":"# Animal Population Growth Simulator You are tasked with simulating the growth of an animal population with given initial conditions and constant growth rates over a specified number of years. The population increases according to an exponential growth model, defined by the formula: [ P(t) = P_0 times (1 + r)^t ] Where: - ( P(t) ) is the population after ( t ) years. - ( P_0 ) is the initial population. - ( r ) is the annual growth rate (as a decimal). - ( t ) is the number of years. Write a function `simulate_population_growth` that calculates the population after a certain number of years based on the initial population and the growth rate. # Function Signature ```python def simulate_population_growth(initial_population: int, growth_rate: float, years: int) -> int: ``` # Parameters - `initial_population (int)`: The initial population at the start of the simulation; must be a positive integer. - `growth_rate (float)`: The annual growth rate (as a decimal); must be a non-negative value. - `years (int)`: The number of years to simulate; must be a non-negative integer. # Returns - `final_population (int)`: The estimated population after the specified number of years. # Constraints - `initial_population > 0` - `growth_rate >= 0` - `years >= 0` # Errors Raise appropriate errors if any of the parameters do not meet the constraints. # Examples Test your function with the following cases: ```python >>> simulate_population_growth(initial_population=1000, growth_rate=0.05, years=10) 1628 >>> simulate_population_growth(initial_population=500, growth_rate=0.10, years=5) 805 >>> simulate_population_growth(initial_population=1000, growth_rate=-0.05, years=10) Traceback (most recent call last): ... ValueError: Growth rate must be non-negative >>> simulate_population_growth(initial_population=0, growth_rate=0.05, years=10) Traceback (most recent call last): ... ValueError: Initial population must be positive >>> simulate_population_growth(initial_population=1000, growth_rate=0.05, years=-5) Traceback (most recent call last): ... ValueError: Years must be non-negative ``` Write your implementation of the function `simulate_population_growth`, ensuring it handles all the given examples and edge cases.","solution":"def simulate_population_growth(initial_population: int, growth_rate: float, years: int) -> int: Simulates the growth of an animal population over a number of years using an exponential growth model. Parameters: - initial_population (int): The initial population at the start of the simulation. Must be positive. - growth_rate (float): The annual growth rate (as a decimal). Must be non-negative. - years (int): The number of years to simulate. Must be non-negative. Returns: - int: The estimated population after the specified number of years. Raises: - ValueError: If any of the parameters do not meet their respective constraints. if initial_population <= 0: raise ValueError(\\"Initial population must be positive\\") if growth_rate < 0: raise ValueError(\\"Growth rate must be non-negative\\") if years < 0: raise ValueError(\\"Years must be non-negative\\") final_population = initial_population * (1 + growth_rate) ** years return int(final_population)"},{"question":"# Task List Sorting Context: In task management systems, sorting tasks by priority and due date helps users manage their workload effectively. Your task is to implement a function that sorts a list of tasks based on their priority and due date. Tasks: 1. Implement a function `sort_tasks(tasks: List[Tuple[str, str, str]]) -> List[Tuple[str, str, str]]` that takes a list of tasks and sorts them in order of priority and due date. Input: - `tasks`: A list of tuples, where each tuple contains three elements: - Task name as a string. - Priority as a string (\\"Low\\", \\"Medium\\", \\"High\\"). - Due date as a string in the format \\"YYYY-MM-DD\\". Output: - A list of tuples sorted first by priority (\\"High\\" > \\"Medium\\" > \\"Low\\") and then by due date (earlier dates first). Constraints: - The due date strings will always be in the format \\"YYYY-MM-DD\\". - There will not be any invalid dates. - All tasks will have a valid priority level (\\"Low\\", \\"Medium\\", \\"High\\"). Example: ```python def sort_tasks(tasks): priority_map = {\\"High\\": 1, \\"Medium\\": 2, \\"Low\\": 3} # Your implementation # Example Usage: tasks = [ (\\"Task1\\", \\"Medium\\", \\"2023-05-10\\"), (\\"Task2\\", \\"High\\", \\"2023-05-01\\"), (\\"Task3\\", \\"Low\\", \\"2023-06-20\\"), (\\"Task4\\", \\"Medium\\", \\"2023-04-15\\"), (\\"Task5\\", \\"High\\", \\"2023-05-02\\") ] sorted_tasks = sort_tasks(tasks) # Expected Output: # [ # (\\"Task2\\", \\"High\\", \\"2023-05-01\\"), # (\\"Task5\\", \\"High\\", \\"2023-05-02\\"), # (\\"Task4\\", \\"Medium\\", \\"2023-04-15\\"), # (\\"Task1\\", \\"Medium\\", \\"2023-05-10\\"), # (\\"Task3\\", \\"Low\\", \\"2023-06-20\\") # ] ``` Your task is to implement the function `sort_tasks` that sorts the given list of tasks based on the described rules.","solution":"def sort_tasks(tasks): priority_map = {\\"High\\": 1, \\"Medium\\": 2, \\"Low\\": 3} return sorted(tasks, key=lambda task: (priority_map[task[1]], task[2])) # Example usage: tasks = [ (\\"Task1\\", \\"Medium\\", \\"2023-05-10\\"), (\\"Task2\\", \\"High\\", \\"2023-05-01\\"), (\\"Task3\\", \\"Low\\", \\"2023-06-20\\"), (\\"Task4\\", \\"Medium\\", \\"2023-04-15\\"), (\\"Task5\\", \\"High\\", \\"2023-05-02\\") ] sorted_tasks = sort_tasks(tasks) print(sorted_tasks) # Expected Output: # [ # (\\"Task2\\", \\"High\\", \\"2023-05-01\\"), # (\\"Task5\\", \\"High\\", \\"2023-05-02\\"), # (\\"Task4\\", \\"Medium\\", \\"2023-04-15\\"), # (\\"Task1\\", \\"Medium\\", \\"2023-05-10\\"), # (\\"Task3\\", \\"Low\\", \\"2023-06-20\\") # ]"},{"question":"# Question Suppose you are handling a list of log entries, where each entry consists of a unique `log_id` and the `timestamp` when the event was logged. Your task is to write a function that merges two sorted lists of log entries into a single sorted list. Each log entry should be represented as a tuple `(log_id, timestamp)`. The input lists are already sorted by timestamp, and the output should also be sorted by timestamp. Function Signature ```python def merge_logs(logs1: List[Tuple[int, str]], logs2: List[Tuple[int, str]]) -> List[Tuple[int, str]]: ``` Input - `logs1` (List[Tuple[int, str]]): The first sorted list of log entries, with length `0 <= len(logs1) <= 1000`. - `logs2` (List[Tuple[int, str]]): The second sorted list of log entries, with length `0 <= len(logs2) <= 1000`. Output - `List[Tuple[int, str]]`: A single merged list of log entries, sorted by timestamp. Constraints - All timestamps are in the format `YYYY-MM-DD HH:MM:SS` and are guaranteed to be unique. - The log entries in both input lists are already sorted by timestamp. Example ```python log_list_1 = [(101, \\"2023-01-01 10:00:00\\"), (102, \\"2023-01-02 12:00:00\\")] log_list_2 = [(201, \\"2023-01-01 09:00:00\\"), (202, \\"2023-01-03 11:00:00\\")] assert merge_logs(log_list_1, log_list_2) == [(201, \\"2023-01-01 09:00:00\\"), (101, \\"2023-01-01 10:00:00\\"), (102, \\"2023-01-02 12:00:00\\"), (202, \\"2023-01-03 11:00:00\\")] log_list_1 = [(301, \\"2024-05-20 09:23:45\\")] log_list_2 = [(401, \\"2024-05-19 10:34:56\\"), (402, \\"2024-05-21 14:45:00\\")] assert merge_logs(log_list_1, log_list_2) == [(401, \\"2024-05-19 10:34:56\\"), (301, \\"2024-05-20 09:23:45\\"), (402, \\"2024-05-21 14:45:00\\")] log_list_1 = [] log_list_2 = [(501, \\"2025-01-01 00:00:01\\")] assert merge_logs(log_list_1, log_list_2) == [(501, \\"2025-01-01 00:00:01\\")] ``` In your implementation, consider the following key points: - Use a two-pointer technique to efficiently merge the two sorted lists. - Compare the timestamps of the current elements in both lists to decide which element to append to the merged list. - Ensure the merged list maintains the sorted order by timestamp.","solution":"from typing import List, Tuple def merge_logs(logs1: List[Tuple[int, str]], logs2: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Merges two sorted lists of log entries into a single sorted list by timestamp. Args: - logs1 (List[Tuple[int, str]]): The first sorted list of log entries. - logs2 (List[Tuple[int, str]]): The second sorted list of log entries. Returns: - List[Tuple[int, str]]: A single merged list of log entries, sorted by timestamp. merged_logs = [] i, j = 0, 0 while i < len(logs1) and j < len(logs2): if logs1[i][1] <= logs2[j][1]: merged_logs.append(logs1[i]) i += 1 else: merged_logs.append(logs2[j]) j += 1 # Append remaining elements while i < len(logs1): merged_logs.append(logs1[i]) i += 1 while j < len(logs2): merged_logs.append(logs2[j]) j += 1 return merged_logs"},{"question":"Implement a function `subset_sum_count(nums: List[int], target: int) -> int` that counts the number of ways to select a subset of the given list `nums` that sums up exactly to `target`. Ensure that your solution is optimized for both time and space complexity, especially for larger input sizes. Input - `nums` (List[int]): A list of positive integers. - `target` (int): A positive integer representing the target sum. Output - Returns an integer representing the number of subsets whose sum is exactly equal to `target`. Constraints - 1 ≤ len(nums) ≤ 1,000 - 1 ≤ nums[i] ≤ 1,000 - 1 ≤ target ≤ 1,000 Performance Requirements The solution should be optimized to handle large lists and large target values efficiently. # Example ```python >>> subset_sum_count([1, 2, 3, 4, 5], 10) 3 # The possible subsets are [1, 2, 3, 4], [1, 4, 5], and [2, 3, 5] >>> subset_sum_count([3, 34, 4, 12, 5, 2], 9) 2 # The possible subsets are [4, 5] and [3, 4, 2] >>> subset_sum_count([1, 1, 1, 1], 2) 6 # The possible subsets are [1, 1] (6 combinations) ``` Additional Notes - Aim to use dynamic programming techniques to balance the time and space complexity. - Consider edge cases where two or more elements may be required to form the target sum. - Pay special attention to ensure that subsets are counted correctly, even when elements are repeated.","solution":"def subset_sum_count(nums, target): Returns the count of subsets of nums that sum up to target. dp = [0] * (target + 1) dp[0] = 1 # There\'s one way to make a target sum of 0 - using the empty subset. for num in nums: for j in range(target, num - 1, -1): dp[j] += dp[j - num] return dp[target]"},{"question":"# Problem Statement: Your task is to implement a function to check if a given string is a palindrome by recursively comparing characters from the beginning and the end of the string. The function should be efficient in handling both small and large input strings, and you should also implement a set of unit tests to verify the correctness of your solution. # Function Signature: ```python def is_palindrome(s: str) -> bool: Check if a string is a palindrome. :param s: Input string. :return: True if the string is a palindrome, False otherwise. # Unit test function def test_is_palindrome(): Test the is_palindrome function with various inputs. ``` # Requirements: 1. **Input**: A string consisting of lowercase and uppercase alphabets. 2. **Output**: Boolean value - True if the string is a palindrome, False if it is not. 3. **Constraints**: The length of the input string will be in the range [1, 10^5]. 4. **Performance**: Your solution should efficiently handle large strings within reasonable time limits. # Examples: ```python assert is_palindrome(\\"level\\") == True assert is_palindrome(\\"OpenAI\\") == False assert is_palindrome(\\"AbaCaba\\") == False # This is treated as case-sensitive assert is_palindrome(\\"madam\\") == True ``` # Guidelines: 1. A palindrome is a string that reads the same forward and backward, e.g., \\"madam\\", \\"racecar\\". 2. Implement the function using recursion to compare characters at corresponding positions from the beginning and the end. 3. The base case should handle empty strings and single-character strings. 4. Implement the test function to cover different cases, including edge cases. # Note: - This function treats the string as case-sensitive, meaning \\"Abba\\" and \\"abba\\" are not considered palindromes.","solution":"def is_palindrome(s: str) -> bool: def helper(start: int, end: int) -> bool: # Base case when the pointers have crossed each other or are the same if start >= end: return True # Check if characters at start and end are the same if s[start] != s[end]: return False # Recur for the next pair of characters return helper(start + 1, end - 1) return helper(0, len(s) - 1)"},{"question":"# Coding Question: Median and Geometric Progression Analysis Objective: You need to enhance your mathematical analysis skills by working with median calculations and geometric progression checks. Your task is to write a new function that utilizes both to solve a given problem. Problem Statement: Write a function `analyze_geometric_series(series: list) -> tuple` that takes as input a list of numbers. This function should return a tuple containing: 1. A boolean indicating whether the series is a geometric progression. 2. The median of the series. Function Signature: ```python def analyze_geometric_series(series: list) -> tuple: pass ``` Expected Input and Output: - **Input**: A list of integers (e.g., [3, 9, 27]) - **Output**: A tuple (boolean, float) where the first element is True if the series is geometric and False otherwise, and the second element is the median of the series. Constraints: - The input list will contain at least one integer. - If the input list contains only one integer, it should be considered a geometric series. Performance Requirements: - Time complexity should be O(n log n) due to sorting required for median calculation. - Space complexity should be O(1) additional space. Example: ```python >>> analyze_geometric_series([3, 9, 27]) (True, 9.0) >>> analyze_geometric_series([2, 4, 8, 16]) (True, 6.0) >>> analyze_geometric_series([2, 4, 7, 8]) (False, 5.5) ``` Additional Requirements: - Implement helper functions `median` and `is_geometric_series`. - Ensure your implementation raises appropriate ValueErrors for improper input with descriptive messages. ```python def is_geometric_series(series): if len(series) <= 1: return True ratio = series[1] / series[0] for i in range(1, len(series)): if series[i] / series[i - 1] != ratio: return False return True def median(lst): sorted_lst = sorted(lst) n = len(sorted_lst) mid = n // 2 if n % 2 == 0: return (sorted_lst[mid - 1] + sorted_lst[mid]) / 2 else: return sorted_lst[mid] def analyze_geometric_series(series): if not series: raise ValueError(\\"The input series must contain at least one number.\\") return is_geometric_series(series), median(series) ```","solution":"def is_geometric_series(series): if len(series) <= 1: return True ratio = series[1] / series[0] for i in range(1, len(series)): if series[i] / series[i - 1] != ratio: return False return True def median(lst): sorted_lst = sorted(lst) n = len(sorted_lst) mid = n // 2 if n % 2 == 0: return (sorted_lst[mid - 1] + sorted_lst[mid]) / 2 else: return sorted_lst[mid] def analyze_geometric_series(series): if not series: raise ValueError(\\"The input series must contain at least one number.\\") return is_geometric_series(series), median(series)"},{"question":"# Count Complete Tree Nodes You are given a complete binary tree and need to count the number of nodes present in it. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Objective: Implement a function to count the number of nodes in a given complete binary tree. # Input Format: An object of type `TreeNode` representing the root of the binary tree. # Output Format: An integer representing the number of nodes in the binary tree. # Constraints: - The binary tree will have at most `5 * 10^4` nodes. - TreeNode is a class with attributes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Performance Requirements: - The function should efficiently handle the constraints provided. # Function Signature: ```python def count_complete_tree_nodes(root: TreeNode) -> int: ``` # Example: ```python # Example 1 # Input: [1, 2, 3, 4, 5, 6] # The tree structure: # 1 # / # 2 3 # / / # 4 5 6 output: 6 # Example 2 # Input: [1] # The tree structure: # 1 output: 1 ``` # Notes: - You should handle edge cases, such as an empty tree, gracefully. - Ensure the implemented function is optimal and meets the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_complete_tree_nodes(root: TreeNode) -> int: if not root: return 0 def get_depth(node): depth = 0 while node: node = node.left depth += 1 return depth left_depth = get_depth(root.left) right_depth = get_depth(root.right) if left_depth == right_depth: return (1 << left_depth) + count_complete_tree_nodes(root.right) else: return (1 << right_depth) + count_complete_tree_nodes(root.left)"},{"question":"Here is another question for the coding assessment: 1. **Caching**: - Implement an in-memory cache to store the results of recent API calls. - Cache entries should expire after a specified time duration. 2. **Functionality**: - Create a function that fetches the weather data for a given city. The function should first check the cache for existing data before making a network request. 3. **Concurrency**: - Ensure that the function is thread-safe, avoiding race conditions when accessing or updating the cache. Write the function `get_weather_data` with the following signature: ```python import aiohttp # You are allowed to use aiohttp for this task import asyncio from typing import Dict, Optional class WeatherCache: def __init__(self, expiration_time: int = 300): # Your implementation here async def get_weather_data(self, city: str) -> Dict: # Your implementation here ``` # Input: - `city` (str): The name of the city to query. - `expiration_time` (int, optional): Time in seconds for which the cache entry is valid. Defaults to 300 seconds (5 minutes). # Output: - Returns a dictionary containing weather data for the specified city. # Constraints: - Assume you have access to a weather API endpoint and an API key. Implement the URL and key usage in the function. - Handle API rate limiting and errors gracefully. # Example: ```python import asyncio cache = WeatherCache(expiration_time=600) result = asyncio.run(cache.get_weather_data(\\"New York\\")) print(result) ``` This code should print a dictionary containing weather data for the city of New York. Subsequent calls within 10 minutes should return the cached data.","solution":"import aiohttp import asyncio import time from typing import Dict, Optional from threading import Lock class WeatherCache: def __init__(self, expiration_time: int = 300): self.cache = {} self.expiration_time = expiration_time self.lock = Lock() def _is_expired(self, timestamp: float) -> bool: return (time.time() - timestamp) > self.expiration_time async def _fetch_weather_data(self, city: str) -> Dict: api_key = \'your_api_key_here\' url = f\'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\' async with aiohttp.ClientSession() as session: async with session.get(url) as response: if response.status == 200: return await response.json() else: response.raise_for_status() async def get_weather_data(self, city: str) -> Dict: with self.lock: if city in self.cache and not self._is_expired(self.cache[city][\'timestamp\']): return self.cache[city][\'data\'] weather_data = await self._fetch_weather_data(city) with self.lock: self.cache[city] = { \'data\': weather_data, \'timestamp\': time.time() } return weather_data"},{"question":"# Scenario You are developing a text processing tool where it is necessary to perform sentiment analysis on movie reviews. Sentiment analysis usually involves classifying the text as positive, negative, or neutral based on the words and phrases used. Your task is to implement a function that assigns a sentiment score to a review by counting the occurrences of certain positive and negative words. # Coding Task Write a function `calculate_sentiment(review: str, positive_words: List[str], negative_words: List[str]) -> int` that calculates the sentiment score of a review. # Input 1. `review` (str): A string representing the movie review. 2. `positive_words` (List[str]): A list of words that are considered positive. 3. `negative_words` (List[str]): A list of words that are considered negative. # Output 1. An integer representing the sentiment score of the review. Positive words add +1 to the score, and negative words subtract -1 from the score. # Constraints 1. The review will have a maximum length of 1000 characters. 2. Words in `positive_words` and `negative_words` list are lowercase and alphabetic. 3. Words in the review are separated by spaces and may include punctuations. 4. The review is case insensitive, so \\"Good\\" and \\"good\\" should be treated the same. # Example ```python review = \\"This movie was absolutely amazing, I loved every part of it. However, some parts were a bit dull.\\" positive_words = [\\"amazing\\", \\"loved\\", \\"good\\", \\"fantastic\\", \\"great\\"] negative_words = [\\"dull\\", \\"boring\\", \\"bad\\", \\"terrible\\", \\"awful\\"] # Expected output: 1 # Explanation: \\"amazing\\" (+1), \\"loved\\" (+1), \\"dull\\" (-1). Total score is +1. print(calculate_sentiment(review, positive_words, negative_words)) ``` # Starter Code ```python from typing import List import string def calculate_sentiment(review: str, positive_words: List[str], negative_words: List[str]) -> int: table = str.maketrans(\\"\\", \\"\\", string.punctuation) review = review.translate(table).lower() words = review.split() score = 0 for word in words: if word in positive_words: score += 1 elif word in negative_words: score -= 1 return score # Example: # review = \\"This movie was absolutely amazing, I loved every part of it. However, some parts were a bit dull.\\" # positive_words = [\\"amazing\\", \\"loved\\", \\"good\\", \\"fantastic\\", \\"great\\"] # negative_words = [\\"dull\\", \\"boring\\", \\"bad\\", \\"terrible\\", \\"awful\\"] # print(calculate_sentiment(review, positive_words, negative_words)) # Expected output: 1 ``` # Evaluation Criteria * Correctness: The function correctly calculates the sentiment score based on the given input. * Case Insensitivity: The implementation correctly handles different cases (upper and lower) in the review. * Punctuation Handling: The solution properly removes punctuation from the review.","solution":"from typing import List import string def calculate_sentiment(review: str, positive_words: List[str], negative_words: List[str]) -> int: # Remove punctuation and convert the text to lowercase table = str.maketrans(\\"\\", \\"\\", string.punctuation) review = review.translate(table).lower() # Split the review into words words = review.split() # Initialize the sentiment score score = 0 # Calculate the score based on the positive and negative words for word in words: if word in positive_words: score += 1 elif word in negative_words: score -= 1 return score"},{"question":"**Context**: You have been tasked with implementing a function to perform topological sorting on a directed acyclic graph (DAG). The graph will be represented as an adjacency list in a dictionary. **Task**: Write a Python function to perform topological sorting on a given directed acyclic graph using Depth-First Search (DFS). **Requirements**: - Write a class `TopologicalSort` that: - Initializes with an adjacency list. - Implements a `dfs` method to perform a depth-first search and record the nodes in post-order. - Implements a `topo_sort` method to return the nodes in topologically sorted order. **Function Signatures**: ```python class TopologicalSort: def __init__(self, graph: dict[str, list[str]]) -> None: ... def dfs(self, node: str, visited: set[str], stack: list[str]) -> None: ... def topo_sort(self) -> list[str]: ... ``` **Input Format**: - `graph`: A dictionary where keys are node labels and values are lists of adjacent nodes. **Output Format**: - A list of node labels representing the topologically sorted order. **Example**: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } t = TopologicalSort(graph) print(t.topo_sort()) # Output: [\'A\', \'C\', \'B\', \'D\', \'E\'] (or another valid topological order) ``` **Constraints**: - All node labels are unique. - The graph is a directed acyclic graph (DAG). **Performance Notes**: - Your solution should efficiently handle large graphs in terms of both time and space complexity.","solution":"class TopologicalSort: def __init__(self, graph: dict[str, list[str]]) -> None: self.graph = graph def dfs(self, node: str, visited: set[str], stack: list[str]) -> None: visited.add(node) for neighbor in self.graph.get(node, []): if neighbor not in visited: self.dfs(neighbor, visited, stack) stack.append(node) def topo_sort(self) -> list[str]: visited = set() stack = [] for node in self.graph: if node not in visited: self.dfs(node, visited, stack) stack.reverse() return stack"},{"question":"# Problem Statement You are building a data processing function to calculate the cumulative sum of an array, but only for a specified range of indices, inclusive. The function should efficiently handle multiple queries for different ranges. # Function Specification Implement the function `range_cumulative_sum`: ```python def range_cumulative_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: pass ``` # Input * `arr`: A list of integers. * `queries`: A list of tuples, where each tuple contains two integers representing the start and end indices of the range (inclusive) for which the cumulative sum is to be calculated. # Output * Returns a list of integers, where each integer is the cumulative sum of the specified subarray for a corresponding query. # Constraints * (1 le text{len(arr)} le 10^5) * (0 le text{start, end} < text{len(arr)}) * (1 le text{len(queries)} le 10^4) * (text{start} le text{end}) # Examples ```python >>> range_cumulative_sum([1, 2, 3, 4, 5], [(0, 2), (1, 3), (2, 4)]) [6, 9, 12] >>> range_cumulative_sum([10, 20, 30, 40], [(0, 1), (1, 2), (0, 3)]) [30, 50, 100] >>> range_cumulative_sum([-1, -2, 3, 4, -5], [(0, 4), (1, 3), (2, 2)]) [-1, 5, 3] ``` # Notes * Ensure to handle large arrays and multiple queries efficiently. * Consider preprocessing the input array to speed up query calculations.","solution":"from typing import List, Tuple def range_cumulative_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns a list of cumulative sums for the given ranges in the array. # Precompute the prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Generate the result for each query result = [] for start, end in queries: result.append(prefix_sums[end + 1] - prefix_sums[start]) return result"},{"question":"# Question: Efficient Fibonacci Sequence Calculation Context You need to implement an optimized version of the Fibonacci sequence calculator. The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it, starting with 0 and 1. Problem Statement Implement an efficient version of the `fibonacci` function that can compute large Fibonacci numbers without running into performance issues related to time or space complexity. # Function Signature ```python def efficient_fibonacci(n: int) -> int: Calculate the n-th number in the Fibonacci sequence efficiently. Parameters: - n (int): The position in the Fibonacci sequence to compute (0 ≤ n ≤ 1000). Returns: - int: The n-th Fibonacci number. Raises: - ValueError: If input n is out of the specified range. ``` # Constraints - `0 ≤ n ≤ 1000` - Your solution should be optimized for performance, avoiding excessive recursion and ensuring linear space complexity. # Requirements 1. Validate the input to ensure it meets the constraints. 2. Utilize an efficient algorithm to compute Fibonacci numbers, such as dynamic programming or matrix exponentiation. 3. Ensure the solution works within reasonable time and space limits. # Examples ```python >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(50) 12586269025 >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 ```","solution":"def efficient_fibonacci(n: int) -> int: Calculate the n-th number in the Fibonacci sequence efficiently. Parameters: - n (int): The position in the Fibonacci sequence to compute (0 ≤ n ≤ 1000). Returns: - int: The n-th Fibonacci number. Raises: - ValueError: If input n is out of the specified range. if not (0 <= n <= 1000): raise ValueError(\\"Input n must be in the range 0 to 1000 inclusive.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Matrix Zeroing Function Develop a function that modifies a given MxN matrix based on the rule that if an element is 0, its entire row and column are set to 0. # Objective Implement a function that takes an MxN matrix and updates it in place such that if an element is 0 in the original matrix, its entire row and column in the resulting matrix are set to 0. # Implementation Details 1. Identify all cells containing 0s and store their row and column indices. 2. Traverse the identified indices and set the corresponding rows and columns to 0 in the matrix. 3. Ensure the solution works efficiently on large matrices. # Function Signature ```python def zero_matrix(matrix: list[list[int]]) -> None: ... ``` # Input - **matrix**: a list of lists representing the MxN matrix of integers. # Expected Output The function should modify the input matrix such that all rows and columns containing a 0 in the original matrix are set to 0 in the resulting matrix. # Constraints - Matrix dimensions M and N will not exceed 200. # Example Given the following matrix: ```plaintext 1 2 3 4 0 6 7 8 9 ``` The transformed matrix would be: ```plaintext 1 0 3 0 0 0 7 0 9 ``` The function should modify the input matrix in place and should not return anything. # Additional Notes - Avoid using additional space beyond O(M + N) for storage. - The function should handle edge cases, such as matrices with no zeros or matrices completely filled with zeros, gracefully.","solution":"def zero_matrix(matrix: list[list[int]]) -> None: rows_to_zero = set() cols_to_zero = set() # Identify the rows and columns that need to be zeroed for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: rows_to_zero.add(i) cols_to_zero.add(j) # Zero out the identified rows and columns for i in rows_to_zero: for j in range(len(matrix[0])): matrix[i][j] = 0 for j in cols_to_zero: for i in range(len(matrix)): matrix[i][j] = 0"},{"question":"# Problem Statement Design and implement a function that determines if a given sequence of numbers forms an arithmetic progression. An arithmetic progression is a sequence of numbers where the difference between consecutive terms is constant. # Function Signature ```python def is_arithmetic_progression(sequence: list) -> bool: Returns True if the given sequence forms an arithmetic progression; otherwise, False. Parameters: - sequence (list): A list of integers representing the sequence of numbers. Returns: bool: True if the sequence is an arithmetic progression, False otherwise. ``` # Inputs * `sequence (list)`: A list of integers where the length of the list is between 1 and 10000 inclusive. # Outputs * A boolean value representing whether the sequence forms an arithmetic progression. # Constraints * The sequence list will have at least one integer and at most 10,000 integers. * All integers in the sequence are between -10^9 and 10^9 inclusive. # Example ```python >>> is_arithmetic_progression([3, 6, 9, 12]) True >>> is_arithmetic_progression([1, 4, 7, 10, 13]) True >>> is_arithmetic_progression([1, 2, 4, 8, 16]) False >>> is_arithmetic_progression([5]) True >>> is_arithmetic_progression([5, 5, 5, 5]) True ``` # Explanation 1. The sequence `[3, 6, 9, 12]` is an arithmetic progression with a common difference of 3. 2. The sequence `[1, 4, 7, 10, 13]` is an arithmetic progression with a common difference of 3. 3. The sequence `[1, 2, 4, 8, 16]` is not an arithmetic progression as the difference between consecutive elements is not constant. 4. A single-element sequence is considered an arithmetic progression. 5. A sequence with all elements the same is considered an arithmetic progression with a common difference of 0. # Notes * The solution should efficiently handle sequences at the upper constraint limit. * Ensure all edge cases are considered, including very short sequences and sequences with large integers.","solution":"def is_arithmetic_progression(sequence: list) -> bool: Returns True if the given sequence forms an arithmetic progression; otherwise, False. Parameters: - sequence (list): A list of integers representing the sequence of numbers. Returns: bool: True if the sequence is an arithmetic progression, False otherwise. if len(sequence) <= 1: return True common_diff = sequence[1] - sequence[0] for i in range(2, len(sequence)): if sequence[i] - sequence[i - 1] != common_diff: return False return True"},{"question":"# Problem Statement Implement a data structure called `MinStack` that supports the following operations efficiently: - `push(x)` -- Push element `x` onto stack. - `pop()` -- Removes the element on top of the stack. - `top()` -- Get the top element. - `getMin()` -- Retrieve the minimum element in the stack. `MinStack` should perform each of the operations in constant time, O(1). # Input Format: - The operations will be performed in sequence, and input will be provided as a list of tuples. Each tuple will contain: 1. A string specifying the operation (i.e., \\"push\\", \\"pop\\", \\"top\\", \\"getMin\\") 2. An integer argument for the \\"push\\" operation; nil (None) for the rest. # Output Format: - For each operation, return any output if applicable as a list of results. If the operation does not return any result (such as \\"push\\" and \\"pop\\"), append None to the result list. # Example: ```python ops = [(\\"push\\", 5), (\\"push\\", 3), (\\"getMin\\", None), (\\"pop\\", None), (\\"getMin\\", None), (\\"pop\\", None), (\\"getMin\\", None)] # Output: [None, None, 3, None, 5, None, None] ``` # Constraints: - All inputs are valid operations. - The number of operations is constrained by 1 ≤ len(ops) ≤ 10^5. - The integer `x` for the `push` operation will be within the range of a 32-bit signed integer. # Task Requirements: - Implement the `MinStack` class that supports all the above operations. - Ensure each method has O(1) time complexity. ```python class MinStack: def __init__(self): Initialize your data structure here. pass def push(self, x: int) -> None: Push element x onto stack. pass def pop(self) -> None: Removes the element on top of the stack. pass def top(self) -> int: Get the top element. pass def getMin(self) -> int: Retrieve the minimum element in the stack. pass # You will create an instance of MinStack and handle the operations accordingly def perform_operations(ops): stack = MinStack() results = [] for op in ops: if op[0] == \\"push\\": stack.push(op[1]) results.append(None) elif op[0] == \\"pop\\": stack.pop() results.append(None) elif op[0] == \\"top\\": results.append(stack.top()) elif op[0] == \\"getMin\\": results.append(stack.getMin()) return results ``` # Implementation Hints: - Use two stacks: one for tracking the elements and another for tracking the minimum elements at each state.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] return None def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] return None def perform_operations(ops): stack = MinStack() results = [] for op in ops: if op[0] == \\"push\\": stack.push(op[1]) results.append(None) elif op[0] == \\"pop\\": stack.pop() results.append(None) elif op[0] == \\"top\\": results.append(stack.top()) elif op[0] == \\"getMin\\": results.append(stack.getMin()) return results"},{"question":"# Matrix Transposition Checker Context In matrix algebra, a matrix transposition is a simple concept where the rows of the matrix become the columns and vice versa. Understanding and verifying the transposition of a matrix is a fundamental skill which can be essential in various applications in computer science and data processing. Problem Statement You are given two matrices represented as two-dimensional lists of numbers. Your task is to write a function `is_transposition` that takes these two matrices and checks if the second matrix is the transposition of the first matrix. Function Signature ```python def is_transposition(matrix1: list[list[int]], matrix2: list[list[int]]) -> bool: pass ``` Parameters - `matrix1`: A two-dimensional list of integers representing the first matrix. - `matrix2`: A two-dimensional list of integers representing the second matrix. Constraints - The number of rows and columns in each matrix can range from 1 to 1000. - Each integer in the matrices can range from -1000 to 1000. Expected Output - The function should return a boolean value (`True` or `False`) indicating whether the second matrix is the transposition of the first matrix. Examples ```python >>> is_transposition([[1, 2, 3], [4, 5, 6]], [[1, 4], [2, 5], [3, 6]]) True >>> is_transposition([[1, 2], [3, 4], [5, 6]], [[1, 3], [2, 4], [7, 5]]) False >>> is_transposition([[0, -1, 2], [-2, 3, 4]], [[0, -2], [-1, 3], [2, 4]]) True ``` Performance Requirements - Your implementation should handle the maximum input size efficiently within reasonable time and space limits. Notes - Assume that valid matrices will be provided (rectangular matrices). - Focus on creating a solution that is easy to understand and efficient, handling edge cases appropriately.","solution":"def is_transposition(matrix1, matrix2): Check if matrix2 is the transposition of matrix1. if len(matrix1) != len(matrix2[0]) or len(matrix1[0]) != len(matrix2): return False for i in range(len(matrix1)): for j in range(len(matrix1[0])): if matrix1[i][j] != matrix2[j][i]: return False return True"},{"question":"# Text Preprocessing for Sentiment Analysis As a junior data scientist, your current project involves preparing text data for a sentiment analysis model. Before feeding the data into the model, you will need to preprocess the text by removing punctuation, converting all text to lowercase, and removing stopwords. Your task involves the following steps: 1. **Text Preprocessing Function**: Write a function `preprocess_text(text, stopwords)` that: * Takes as input: * `text`, a string containing the text to be preprocessed. * `stopwords`, a list of words to be removed from the text. * Returns: * A string that represents the preprocessed text. 2. **Preprocessing Requirements**: The preprocessing should involve: * Removing all punctuation from the text. * Converting all characters in the text to lowercase. * Removing all words from the text that are present in the provided `stopwords`. 3. **Text Handling**: Ensure that your function handles edge cases, such as empty strings or text containing only stopwords, gracefully. **Input and Output Format:** Input: ```python text = \\"Hello, World! This is a test.\\" stopwords = [\\"this\\", \\"is\\", \\"a\\"] ``` Output: ```python \\"hello world test\\" ``` Function Signature: ```python def preprocess_text(text, stopwords): Preprocess the input text by removing punctuation, converting to lowercase, and removing stopwords. Args: text (str): Text to be preprocessed. stopwords (list of str): List of stopwords to remove from the text. Returns: str: Preprocessed text. # Your implementation here return preprocessed_text # Example usage (you can use this for testing your function): text = \\"Hello, World! This is a test.\\" stopwords = [\\"this\\", \\"is\\", \\"a\\"] preprocessed_text = preprocess_text(text, stopwords) print(preprocessed_text) # Expected output: \\"hello world test\\" ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently.","solution":"import string def preprocess_text(text, stopwords): Preprocess the input text by removing punctuation, converting to lowercase, and removing stopwords. Args: text (str): The text to be preprocessed. stopwords (list of str): List of stopwords to remove from the text. Returns: str: Preprocessed text. # Remove punctuation text_no_punct = text.translate(str.maketrans(\'\', \'\', string.punctuation)) # Convert to lowercase text_lower = text_no_punct.lower() # Remove stopwords words = text_lower.split() filtered_words = [word for word in words if word not in stopwords] # Join the words back into a string preprocessed_text = \' \'.join(filtered_words) return preprocessed_text # Example usage: text = \\"Hello, World! This is a test.\\" stopwords = [\\"this\\", \\"is\\", \\"a\\"] preprocessed_text = preprocess_text(text, stopwords) print(preprocessed_text) # Expected output: \\"hello world test\\""},{"question":"# Problem Description You are required to create a function that simulates a simple banking system where customers can deposit or withdraw money. Your function should maintain the account balance and validate each transaction to ensure it does not result in a negative balance. If a withdrawal would result in a negative balance, the function should raise an `InsufficientFundsError`. # Function Signature ```python class InsufficientFundsError(Exception): pass class BankAccount: def __init__(self, initial_balance: float): self.balance = initial_balance def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> None: pass def get_balance(self) -> float: pass ``` # Input * **initial_balance** (float): A positive float number representing the initial balance of the account when it is created. * **amount** (float): A positive float number for each deposit or withdrawal operation. # Output * **get_balance** (float): A floating-point number representing the current balance of the account. # Constraints * All input parameters must be positive float numbers. * If a deposit or withdrawal amount is non-positive, the function should raise a `ValueError`. * If a withdrawal would result in a negative balance, the function should raise an `InsufficientFundsError`. # Examples ```python # Create an account with an initial balance of 1000.00 >>> account = BankAccount(1000.00) >>> account.get_balance() 1000.00 # Deposit 500.00 to the account >>> account.deposit(500.00) >>> account.get_balance() 1500.00 # Withdraw 200.00 from the account >>> account.withdraw(200.00) >>> account.get_balance() 1300.00 # Attempt to withdraw 1500.00, which would result in an error >>> account.withdraw(1500.00) Traceback (most recent call last): ... InsufficientFundsError # Attempt to deposit a negative amount, which would result in an error >>> account.deposit(-100.00) Traceback (most recent call last): ... ValueError: Deposit amount must be positive. ``` # Note - Ensure to run and pass the provided examples and edge cases. - Your class should encapsulate all relevant state and behavior for the bank account.","solution":"class InsufficientFundsError(Exception): pass class BankAccount: def __init__(self, initial_balance: float): if initial_balance < 0: raise ValueError(\\"Initial balance must be non-negative.\\") self.balance = initial_balance def deposit(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise InsufficientFundsError(\\"Insufficient funds for this withdrawal.\\") self.balance -= amount def get_balance(self) -> float: return self.balance"},{"question":"# Matrix Rotation Validation You are tasked with creating a function that verifies whether a given matrix can be obtained by rotating another matrix by 90 degrees in clockwise direction. # Objective Write a function `is_rotated_matrix(original: List[List[int]], rotated: List[List[int]]) -> bool` that: - Takes two 2D lists (matrices) as input, `original` and `rotated`. - Returns `True` if `rotated` can be obtained by rotating `original` by 90 degrees clockwise, otherwise returns `False`. # Input/Output - **Input**: - `original` (List[List[int]]): The original matrix. - `rotated` (List[List[int]]): The matrix that may be a 90-degree clockwise rotation of the original matrix. - **Output**: - `bool`: `True` if the `rotated` is a 90-degree rotation of the `original`, otherwise `False`. # Constraints: - Both matrices are non-empty and have a size of `NxN` (where `N` is the number of rows/columns). - Elements of the matrices are integers. # Performance Requirement: - The function should run efficiently for typical matrix sizes (up to 50x50). # Example Here is an example of how your function might be used: ```python original = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] print(is_rotated_matrix(original, rotated)) # Output: True rotated_invalid = [ [1, 2, 3], [4, 5, 6], [9, 6, 3] ] print(is_rotated_matrix(original, rotated_invalid)) # Output: False ``` # Context Matrix rotation is a common operation in computer graphics and image processing. This task assesses your understanding of matrix manipulations and ensures that you can validate transformations correctly. # Note You do not need to handle input or output via user input, just implement the function `is_rotated_matrix`.","solution":"from typing import List def is_rotated_matrix(original: List[List[int]], rotated: List[List[int]]) -> bool: n = len(original) # Create a new matrix for rotated result rotated_check = [[0] * n for _ in range(n)] # Rotate the original matrix by 90 degrees clockwise for i in range(n): for j in range(n): rotated_check[j][n-1-i] = original[i][j] # Check if the manually rotated matrix matches the given rotated matrix return rotated_check == rotated"},{"question":"# Question: You are required to develop a function that evaluates the minimum number of edits (operations) needed to transform one string into another string using dynamic programming. The possible operations are insert a character, delete a character, or replace a character. # Function Signature ```python def min_edit_distance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Parameters: word1 (str): The first word. word2 (str): The second word. Returns: int: The minimum number of edits required. ``` # Input - Two strings `word1` and `word2` such that (1 leq text{len(word1)}, text{len(word2)} leq 500). # Output - An integer representing the minimum number of edits required to transform `word1` into `word2`. # Examples 1. `min_edit_distance(\\"horse\\", \\"ros\\")` should return `3`. 2. `min_edit_distance(\\"intention\\", \\"execution\\")` should return `5`. 3. `min_edit_distance(\\"sea\\", \\"eat\\")` should return `2`. 4. `min_edit_distance(\\"kitten\\", \\"sitting\\")` should return `3`. # Additional Constraints - Your solution should handle the edge cases like converting an empty string to a non-empty string and vice versa. - Aim for a time complexity of (O(NM)) where (N) is the length of `word1` and (M) is the length of `word2`. # Hints - You may use a two-dimensional list to store the results of subproblems. - Use dynamic programming principles by breaking the problem into smaller subproblems and iteratively building up the solution. - Consider initializing your memo table carefully, particularly the base cases where one string is empty.","solution":"def min_edit_distance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Parameters: word1 (str): The first word. word2 (str): The second word. Returns: int: The minimum number of edits required. len1, len2 = len(word1), len(word2) # Initialize DP table with (len1 + 1) x (len2 + 1) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Base cases: converting to/from an empty string for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j # Fill the DP table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement return dp[len1][len2]"},{"question":"# Coding Assessment Question Context and Scenario: You are building a hospital management system where patient records are stored based on their unique identifiers. The list of patient IDs is sorted in ascending order. To ensure efficient data retrieval and updating, you need to implement search and modification capabilities for these sorted collections. Task: 1. **Function 1: Binary Search** Write a function `binary_search(collection, item)` to search for a patient\'s ID within the sorted collection using the binary search algorithm. If the `item` is found, return its index, otherwise return -1. ```python def binary_search(collection: list[int], item: int) -> int: Searches for an item in a sorted collection using binary search. :param collection: A list of integers in ascending order. :param item: The integer item to search for. :return: The index of the item if found, otherwise -1. pass ``` **Example:** ```python collection = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] index = binary_search(collection, 14) print(index) # Output: 6 index = binary_search(collection, 5) print(index) # Output: -1 ``` 2. **Function 2: Sorted Deletion** Write a function `sorted_deletion(collection, item)` to remove a patient\'s ID from the sorted collection while maintaining the order. If the `item` is not found, raise a `ValueError`. ```python def sorted_deletion(collection: list[int], item: int) -> None: Remove an item from the sorted collection while maintaining sort order. :param collection: A list of integers in ascending order. :param item: The integer item to be removed. pass ``` **Example:** ```python collection = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] sorted_deletion(collection, 8) print(collection) # Output: [2, 4, 6, 10, 12, 14, 16, 18, 20] sorted_deletion(collection, 5) # Raises ValueError ``` Constraints: - Elements in the input collection are comparable and follow the same data type. - You should ensure that the input collection remains sorted after a deletion. - Your implementation should handle edge cases like an empty array, a single-element array, and an item absent from the collection. Performance Requirements: - Your solution should efficiently handle collections with up to (10^6) elements. - Ensure that the search operation runs in logarithmic time complexity and the deletion operation runs in linear time complexity.","solution":"def binary_search(collection, item): Searches for an item in a sorted collection using binary search. :param collection: A list of integers in ascending order. :param item: The integer item to search for. :return: The index of the item if found, otherwise -1. left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == item: return mid elif collection[mid] < item: left = mid + 1 else: right = mid - 1 return -1 def sorted_deletion(collection, item): Remove an item from the sorted collection while maintaining sort order. :param collection: A list of integers in ascending order. :param item: The integer item to be removed. :raises ValueError: If the item is not found in the collection. index = binary_search(collection, item) if index == -1: raise ValueError(\\"Item not found in the collection\\") # Remove the item at the found index collection.pop(index)"},{"question":"# Problem Statement You are tasked with implementing a function that rotates the elements of a given list to the right by a specified number of steps. The rotation should be performed in-place, modifying the original list without using extra space for another list of the same size. Implement the function `rotate_right(arr: List[int], k: int) -> None` in Python, which takes a list of integers and an integer `k`, and rotates the list to the right by `k` steps. # Function Signature ```python def rotate_right(arr: List[int], k: int) -> None: pass ``` # Input - `arr`: List of integers which can have length (0 ≤ len(arr) ≤ 10^5). - `k`: An integer (0 ≤ k ≤ 10^9). # Output - The function should not return anything. Instead, it should modify the input list in-place. # Constraints - You are not allowed to use extra space for another list of the same size as the input. - The function should handle cases where `k` is larger than the length of the list efficiently. - Your solution should have an optimal time complexity. # Examples ```python >>> arr = [1, 2, 3, 4, 5] >>> rotate_right(arr, 2) >>> print(arr) [4, 5, 1, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> rotate_right(arr, 5) >>> print(arr) [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate_right(arr, 7) >>> print(arr) [4, 5, 1, 2, 3] >>> arr = [] >>> rotate_right(arr, 3) >>> print(arr) [] >>> arr = [1] >>> rotate_right(arr, 3) >>> print(arr) [1] ``` # Notes 1. The function should handle cases where `k` is greater than the length of the list by using the modulo operation (`k % len(arr)`). 2. Ensure that your implementation runs efficiently and respects the constraints. 3. Do not return anything from the function; instead modify the list in-place. # Additional Tests ```python >>> arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> rotate_right(arr, 3) >>> print(arr) [8, 9, 10, 1, 2, 3, 4, 5, 6, 7] >>> arr = [1] >>> rotate_right(arr, 0) >>> print(arr) [1] >>> arr = [1, 2] >>> rotate_right(arr, 999999) >>> print(arr) [2, 1] ```","solution":"from typing import List def rotate_right(arr: List[int], k: int) -> None: Rotates the elements of the given list to the right by \'k\' steps in-place. :param arr: List of integers to be rotated. :param k: Number of steps to rotate. if not arr or k == 0: return n = len(arr) k %= n # find effective rotations needed # Function to reverse a segment of the list def reverse(start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the entire list reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the remaining elements reverse(k, n - 1)"},{"question":"Shortest Path in a Weighted Directed Graph with Dijkstra\'s Algorithm You are given a weighted directed graph with nodes and edges. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given source node to all other nodes. You need to return a list of distances from the source node to each other node. # Input Format - An integer `N` representing the number of nodes in the graph. - An integer `start` representing the source node. - A list of tuples `edges` of size `E`, where each tuple `(u, v, w)` represents an edge from node `u` to node `v` with weight `w`. # Output Format - A list of integers representing the shortest distances from the source node to each other node. If a node is unreachable, the distance should be `float(\'inf\')`. # Constraints - 1 ≤ N ≤ 1000 - 1 ≤ E ≤ 10000 - 0 ≤ w ≤ 1000 - 0 ≤ start < N - The graph may contain cycles. # Function Signature ```python def dijkstra_shortest_paths(N: int, start: int, edges: List[Tuple[int, int, int]]) -> List[int]: ``` # Example ```python # Example 1 N = 5 start = 0 edges = [ (0, 1, 10), (0, 3, 5), (1, 2, 1), (1, 3, 2), (2, 4, 4), (3, 1, 3), (3, 2, 9), (3, 4, 2), (4, 0, 7), (4, 2, 6) ] assert dijkstra_shortest_paths(N, start, edges) == [0, 8, 9, 5, 7] # Example 2 N = 6 start = 1 edges = [ (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15), (2, 3, 11), (2, 5, 2), (3, 4, 6), (4, 5, 9) ] assert dijkstra_shortest_paths(N, start, edges) == [float(\'inf\'), 0, 10, 15, 21, 12] ``` # Notes 1. Ensure to handle the graph correctly even if some nodes are not reachable from the source node. 2. Focus on using an efficient implementation of Dijkstra\'s algorithm, typically using a priority queue (min-heap) to achieve O((N + E) log N) time complexity. 3. Account for edge cases such as graphs with no edges or having multiple components.","solution":"import heapq from typing import List, Tuple def dijkstra_shortest_paths(N: int, start: int, edges: List[Tuple[int, int, int]]) -> List[int]: graph = [[] for _ in range(N)] for u, v, w in edges: graph[u].append((v, w)) # Distance to all nodes initialized to infinity dist = [float(\'inf\')] * N dist[start] = 0 # Min-heap priority queue pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist"},{"question":"# Question You are given a problem to list all the pairs of prime numbers (p1, p2) such that p1 and p2 are twin primes and both lie within the range from 2 up to a specified limit. Twin primes are pairs of prime numbers that differ by 2 (e.g., (3, 5), (11, 13)). Problem Statement Write a function `list_twin_primes(limit: int) -> List[Tuple[int, int]]` that finds all the twin prime pairs with both numbers less than or equal to `limit`. Input * `limit` (integer): A single integer representing the upper bound for the primes. Output * Returns a list of tuples, where each tuple contains a pair of twin prime numbers. Constraints - `2 <= limit <= 1,000,000` Example ```python >>> list_twin_primes(20) [(3, 5), (5, 7), (11, 13), (17, 19)] >>> list_twin_primes(50) [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43)] ``` Note * You are expected to implement the Sieve of Eratosthenes to efficiently find all prime numbers up to the limit. Then, iterate through the primes to check for twin primes.","solution":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[bool]: Generates a list of boolean values corresponding to the primality of numbers from 0 to limit. is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers p = 2 while (p * p <= limit): if (is_prime[p]): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return is_prime def list_twin_primes(limit: int) -> List[Tuple[int, int]]: Returns a list of all pairs of twin primes less than or equal to the specified limit. sieve = sieve_of_eratosthenes(limit) twin_primes = [] for number in range(2, limit - 1): if sieve[number] and sieve[number + 2]: twin_primes.append((number, number + 2)) return twin_primes"},{"question":"# Problem Statement Write a function to rotate elements in a list to the right by a given number of steps, k. The function should modify the list in-place and maintain the order of elements that are rotated out to the beginning. # Requirements: * Your function should take two inputs: a list of integers and an integer k representing the number of steps to rotate. * The function should modify the input list in place. * You are not allowed to use any extra space (i.e., you should not use auxiliary arrays or collections). * k can be greater than the length of the list. # Input Format: * `nums: List[int]`: A list of integers. * `k: int`: An integer representing the number of steps to rotate to the right. # Output Format: * The function does not need to return any value; it should modify the input list in-place. # Constraints: * The list can contain up to 1000 integers. * k can be any non-negative integer. # Examples: ```python def rotate_list(nums: List[int], k: int) -> None: # Your implementation here pass # Example usage: nums = [1, 2, 3, 4, 5, 6, 7] rotate_list(nums, 3) print(nums) # Output: [5, 6, 7, 1, 2, 3, 4] nums = [1, 2, 3, 4] rotate_list(nums, 9) print(nums) # Output: [4, 1, 2, 3] nums = [1] rotate_list(nums, 0) print(nums) # Output: [1] ``` # Edge Cases to Consider: * k is greater than the length of the list. * The list is empty. * k is zero. * k is equal to the length of the list. # Function Signature: ```python from typing import List def rotate_list(nums: List[int], k: int) -> None: # Implementation goes here pass ```","solution":"from typing import List def rotate_list(nums: List[int], k: int) -> None: if not nums: return n = len(nums) k = k % n nums[:] = nums[-k:] + nums[:-k]"},{"question":"# Coding Assessment Question Problem Description You are tasked with creating a function that determines the maximum depth (or height) of a binary tree. The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Write a function `max_depth` that takes the root of a binary tree and returns its maximum depth. Requirements 1. The function should take a single parameter `root`, which is the root node of a binary tree. 2. The function should return an integer representing the maximum depth of the tree. Input Format - The input is the root node of a binary tree where the node is defined as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` - Each node in the binary tree contains: - `value`: An integer value of the node. - `left`: A pointer to the left child node, or None if there is no child. - `right`: A pointer to the right child node, or None if there is no child. Output Format - A single integer representing the maximum depth of the binary tree. Example ```python # Example 1: # Input tree: # 3 # / # 9 20 # / # 15 7 # Function call: max_depth(TreeNode with above structure) # Returns: 3 # Example 2: # Input tree: # 1 # / # 2 # Function call: max_depth(TreeNode with above structure) # Returns: 2 ``` Additional Notes - Ensure your solution is efficient and can handle large trees within reasonable time limits. - You can use a recursive or iterative approach to solve this problem. The goal is to determine the path that traverses the maximum number of nodes from the root to any leaf. ```python # Example TreeNode class definition class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: # Your implementation here ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of a binary tree. :param root: The root of the binary tree. :return: The maximum depth of the binary tree. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Coding Question The Least Recently Used (LRU) page replacement algorithm is designed to manage memory efficiently by removing the least recently used pages when new pages need to be loaded into memory. Your task is to implement a function that simulates the LRU page replacement algorithm and calculates the number of page faults that occur for a given sequence of page requests and a specified number of page frames. Function Implementation 1. `calculate_page_faults(page_requests: list, frame_count: int) -> int` # Input - `page_requests`: A list of integers representing the sequence of page requests. - `frame_count`: An integer representing the number of page frames available. # Output - An integer representing the number of page faults that occur. # Constraints - Page requests will be positive integers. - Frame count will be a positive integer. - The length of the page requests list will be at least 1 and at most 1000. Example ```python # Input page_requests = [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1] frame_count = 3 # Function Call page_faults = calculate_page_faults(page_requests, frame_count) # Output print(f\\"Number of Page Faults: {page_faults}\\") # Expected: 10 ``` Your task is to correctly implement the `calculate_page_faults` function to simulate the LRU page replacement algorithm and compute the number of page faults for the given page requests and frame count.","solution":"def calculate_page_faults(page_requests, frame_count): Simulates the LRU page replacement algorithm and calculates the number of page faults. :param page_requests: List of integers representing the sequence of page requests. :param frame_count: Integer representing the number of page frames available. :return: Integer representing the number of page faults that occur. frame = [] page_faults = 0 page_map = {} # To store the index of the pages in the frame for i, page in enumerate(page_requests): if page not in page_map: if len(frame) < frame_count: frame.append(page) else: # Remove the least recently used page lru_page = frame[0] frame.remove(lru_page) del page_map[lru_page] frame.append(page) page_map[page] = len(frame) - 1 page_faults += 1 else: # Update the usage frame.remove(page) frame.append(page) page_map[page] = len(frame) - 1 return page_faults"},{"question":"# Question: Find the Common Elements in Sorted Arrays You are asked to implement a function that takes two sorted arrays and returns a new array containing the common elements between the two arrays. The output array should also be sorted. Function Signature ```python def common_elements(arr1: list[int], arr2: list[int]) -> list[int]: Returns a sorted array of the common elements between two input sorted arrays. ``` Input * Two lists of integers `arr1` and `arr2`, both sorted in non-decreasing order. Output * A list of integers containing the common elements from `arr1` and `arr2`, sorted in non-decreasing order. Constraints * All elements in `arr1` and `arr2` are unique. * Both `arr1` and `arr2` contain at most 10,000 integers. # Example ```python # Example usage arr1 = [1, 2, 3, 4, 5] arr2 = [3, 4, 5, 6, 7] print(common_elements(arr1, arr2)) # Should print [3, 4, 5] ``` Performance Requirements * The function should have a time complexity of O(n + m), where n is the length of `arr1` and m is the length of `arr2`. * The implementation should utilize the fact that both arrays are already sorted to optimize the search for common elements. # Additional Requirements * Your solution should handle edge cases, such as one or both arrays being empty, properly.","solution":"def common_elements(arr1: list[int], arr2: list[int]) -> list[int]: Returns a sorted array of the common elements between two input sorted arrays. common = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: common.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return common"},{"question":"# Convert Temperature Between Celsius and Fahrenheit Write a Python function `convert_temperature(value: float, unit: str) -> float` that: 1. Accepts a temperature value and the unit of the temperature (`\'C\'` for Celsius or `\'F\'` for Fahrenheit) as input parameters. 2. Converts the temperature to the opposite unit (Celsius to Fahrenheit or Fahrenheit to Celsius). 3. Returns the converted temperature value. 4. Handles the following constraints: - If the unit is not `\'C\'` or `\'F\'`, an appropriate exception with a meaningful message should be raised. The formulas for conversion are: - From Celsius to Fahrenheit: ( F = frac{9}{5}C + 32 ) - From Fahrenheit to Celsius: ( C = frac{5}{9}(F - 32) ) # Input * A floating-point number representing the temperature value. * A string representing the unit of the temperature, either `\'C\'` or `\'F\'`. # Output * A floating-point number representing the converted temperature value in the opposite unit. # Example ```python >>> convert_temperature(0, \'C\') 32.0 >>> convert_temperature(32, \'F\') 0.0 >>> convert_temperature(100, \'C\') 212.0 >>> convert_temperature(-40, \'F\') -40.0 ``` # Constraints * -273.15 ≤ value ≤ 10^5 if unit is `\'C\'` * -459.67 ≤ value ≤ 10^5 if unit is `\'F\'` Create the function `convert_temperature` to meet the specifications above and include input validation to handle incorrect input values.","solution":"def convert_temperature(value: float, unit: str) -> float: Converts the given temperature from one unit to the other. - If the input unit is \'C\', converts from Celsius to Fahrenheit. - If the input unit is \'F\', converts from Fahrenheit to Celsius. Parameters: value (float): The temperature value to be converted. unit (str): The unit of the given temperature (\'C\' or \'F\'). Returns: float: The converted temperature value. Raises: ValueError: If the unit is not \'C\' or \'F\'. if unit == \'C\': return (value * 9/5) + 32 elif unit == \'F\': return (value - 32) * 5/9 else: raise ValueError(\\"Invalid unit. Unit must be either \'C\' for Celsius or \'F\' for Fahrenheit.\\")"},{"question":"```markdown # Magical Permutations Finder Given the following problem: A permutation of the first n integers (1 through n) is considered \\"magical\\" if no integer is in its original position. This is often known as a \\"derangement\\". **Task**: Implement a function `count_magical_permutations(n: int) -> int` that computes the number of \\"magical\\" permutations (derangements) of the sequence ( [1, 2, ldots, n] ). Function Signature ```python def count_magical_permutations(n: int) -> int: ``` Input * `n`: An integer representing the length of the sequence. ( 1 leq n leq 12 ) Output * Return an integer denoting the total number of derangements of the sequence. Constraints * The permutations should not place any element at its \\"natural\\" index. * Consider efficient computation techniques to handle large (n ) values within the given constraints. Example ```python assert count_magical_permutations(1) == 0 assert count_magical_permutations(2) == 1 assert count_magical_permutations(3) == 2 assert count_magical_permutations(4) == 9 assert count_magical_permutations(5) == 44 ``` Additional Notes * Leverage mathematical properties of derangements to derive the count. * Utilize dynamic programming or recursive computations to optimize the solution. * Validate handling of boundary cases and ensure the solution performs efficiently for all valid ranges. ```","solution":"def count_magical_permutations(n: int) -> int: Returns the number of derangements of n items. A derangement is a permutation where no element appears in its original position. # Base cases for the recurrence relation if n == 1: return 0 if n == 2: return 1 # Initialize memoization table derangements = [0] * (n + 1) # Base cases derangements[1] = 0 derangements[2] = 1 # Fill the table using the recursive relation for i in range(3, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) return derangements[n]"},{"question":"String Pattern Matching # Context You are developing a utility to help users identify specific patterns in text data. This is useful for applications in search engines, data validation, and text analysis tools. The goal is to implement a function that identifies if a given pattern string appears in a text string, considering wildcard characters. # Task Implement a function `pattern_match` that checks if a pattern string matches a text string. The pattern string can contain wildcard characters: 1. `?`: Matches any single character. 2. `*`: Matches any sequence of characters (including the empty sequence). The function should return a boolean indicating whether the pattern matches the entire text string. # Function Signature ```python def pattern_match(text: str, pattern: str) -> bool: pass ``` # Inputs and Outputs - **Input**: - `text`: A string representing the text to be searched. - `pattern`: A string representing the pattern that may contain wildcard characters. - **Output**: - A boolean indicating whether the pattern matches the entire text string. # Constraints - `text` and `pattern` are guaranteed to be non-empty strings. - Wildcard characters `?` and `*` are case-sensitive. # Example Usage ```python assert pattern_match(\\"abcdef\\", \\"a?c*ef\\") == True assert pattern_match(\\"hello world\\", \\"h*o w?rld\\") == True assert pattern_match(\\"python\\", \\"pyth?n\\") == True assert pattern_match(\\"text\\", \\"t?xt*\\") == True assert pattern_match(\\"data\\", \\"d*t?\\") == False assert pattern_match(\\"example\\", \\"ex*mp?e\\") == False ``` # Implementation Notes 1. Consider edge cases where the pattern only contains wildcards. 2. Efficiently manage the matching process to handle long text and pattern strings. 3. The pattern should match from the start to the end of the text string, not just as a substring. This task will help evaluate the candidate\'s ability to work with strings, handle special characters, and implement pattern matching logic.","solution":"def pattern_match(text: str, pattern: str) -> bool: Checks if the pattern matches the entire text string, considering wildcard characters \'?\' and \'*\'. m, n = len(text), len(pattern) # DP table to store results of subproblems dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern can match with empty text dp[0][0] = True # Only \'*\' can match with an empty text for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the table in a bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == \'?\' or text[i - 1] == pattern[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Sorting Letters and Numbers Separately You need to create a function `sort_letters_and_numbers(string: str) -> str` that takes an alphanumeric string and returns a string where the letters are sorted in alphabetical order and the numbers are sorted in ascending order. The positions of letters and numbers in the original string should be preserved in the output. For example, if the input string is `\\"a1c3b2\\"`, the output should be `\\"a1b2c3\\"`. Input: - `string` (str): A string containing a mix of letters and numbers. Output: - A string with letters sorted alphabetically and numbers sorted in ascending order, while maintaining their positions in the original string. # Example ```python sort_letters_and_numbers(\\"d4a3c2b1\\") # Output # \\"a1b2c3d4\\" ``` ```python sort_letters_and_numbers(\\"h6e3f7g2\\") # Output # \\"e2f3g6h7\\" ``` # Constraints 1. The input string contains only lowercase letters and digits. 2. The input string will have at least one letter and one digit. 3. The length of the input string will not exceed 1000 characters.","solution":"def sort_letters_and_numbers(string): Sorts the letters and numbers in the given string separately while preserving their original positions. Parameters: string (str): The alphanumeric input string. Returns: str: The sorted string with letters and numbers sorted separately. letters = sorted([c for c in string if c.isalpha()]) numbers = sorted([c for c in string if c.isdigit()]) result = [] l_idx = 0 n_idx = 0 for char in string: if char.isalpha(): result.append(letters[l_idx]) l_idx += 1 else: result.append(numbers[n_idx]) n_idx += 1 return \'\'.join(result)"},{"question":"# Question **Context**: As a software engineer at a financial tech company, part of your job involves processing streams of financial transactions to detect potential fraud. A common tactic involves the rapid transfer of funds between accounts. To aid in detection, you have been tasked with implementing a rolling window algorithm that evaluates the sum of transactions over a specified time window. **Task**: Implement the function `rolling_window_sum` that computes the sum of transaction amounts over a rolling window of a specified size. **Function Signature**: ```python def rolling_window_sum(transactions: list[int], window_size: int) -> list[int]: Args: - transactions: A list of integers representing transaction amounts. - window_size: An integer representing the size of the rolling window. Returns: - A list of integers representing the rolling window sums. ``` **Requirements**: 1. Implement the function `rolling_window_sum` that takes in: * `transactions`: A list of integers where each integer represents a transaction amount. * `window_size`: An integer representing the size of the rolling window. 2. The function should return a list of integers, where each integer is the sum of the elements in the current window. 3. If the window size exceeds the number of available transactions, the sum should only consider the available elements. **Examples**: ```python >>> rolling_window_sum([10, 20, 30, 40, 50], 3) [60, 90, 120] >>> rolling_window_sum([5, 15, 25, 35], 2) [20, 40, 60] >>> rolling_window_sum([8, 16, 24], 5) [48] ``` **Constraints**: * The list of transactions can contain up to (10^5) elements. * Each transaction amount is a non-negative integer not exceeding (10^5). * The window size will always be a positive integer. Good luck, and happy coding!","solution":"def rolling_window_sum(transactions, window_size): Computes the sum of transaction amounts over a rolling window of specified size. Args: - transactions: A list of integers representing transaction amounts. - window_size: An integer representing the size of the rolling window. Returns: - A list of integers representing the rolling window sums. if not transactions: return [] rolling_sum = [] current_window_sum = sum(transactions[:window_size]) rolling_sum.append(current_window_sum) for i in range(1, len(transactions) - window_size + 1): current_window_sum += transactions[i + window_size - 1] - transactions[i - 1] rolling_sum.append(current_window_sum) return rolling_sum"},{"question":"# Bitwise AND Range: Efficient Computation Background: Computing bitwise AND of a range of numbers can become inefficient for large ranges. Instead of performing AND operations in a brute-force manner, it is possible to derive the result using bit manipulation techniques, which can offer substantial performance improvements. Task: You are tasked with implementing an efficient function `range_bitwise_and` that computes the bitwise AND of all integers in a given range [m, n] (both inclusive). Requirements: - Write a method `range_bitwise_and` that takes two integers `m` and `n`, and returns the bitwise AND of all numbers in the range [m, n]. Function Signature: ```python def range_bitwise_and(m: int, n: int) -> int: # Your code here ``` Input: - Two integers, `m` and `n` where 0 <= m <= n <= 2^31 - 1. Output: - An integer representing the bitwise AND result of all numbers in the range [m, n]. Example: ```python # Example 1 m = 5 n = 7 print(range_bitwise_and(m, n)) # Output should be 4 # Example 2 m = 0 n = 1 print(range_bitwise_and(m, n)) # Output should be 0 ``` Constraints / Assumptions: - Ensure that the implementation is efficient and avoids the brute-force approach of individually ANDing every number in the range, especially for large ranges. - Consider bit manipulation techniques to achieve the result efficiently. # Notes: - Pay attention to the shift and mask operations that can help in identifying the common significant bits between m and n during the computation. ```python def range_bitwise_and(m: int, n: int) -> int: shift = 0 # Find the common prefix while m != n: m >>= 1 n >>= 1 shift += 1 return m << shift ``` This example illustrates the efficient approach for computing the bitwise AND over a range by determining the common prefix of the numbers in binary representation. The solution aligns with performance optimization expectations for large input ranges.","solution":"def range_bitwise_and(m: int, n: int) -> int: Computes the bitwise AND of all numbers in the range [m, n]. shift = 0 while m != n: m >>= 1 n >>= 1 shift += 1 return m << shift"},{"question":"# Fibonacci Sequence and Efficient Computation Problem Statement: You need to implement a program that calculates the `n`-th Fibonacci number. The direct recursive algorithm may not be efficient for large `n`, so you are also required to write an optimized version that performs significantly better on large inputs by leveraging techniques such as matrix exponentiation or memoization. Requirements: 1. Implement a basic function `fibonacci_basic(n: int) -> int` that computes the `n`-th Fibonacci number using a direct recursive method. 2. Implement an optimized function `fibonacci_optimized(n: int) -> int` that computes the `n`-th Fibonacci number efficiently using techniques like memoization or matrix exponentiation. Function Signatures: ```python def fibonacci_basic(n: int) -> int: pass def fibonacci_optimized(n: int) -> int: pass ``` Constraints: * For `fibonacci_basic`, input `n` will be in the range of 0 ≤ n ≤ 30. * For `fibonacci_optimized`, input `n` will be in the range of 0 ≤ n ≤ 10^5. * Both functions must raise a `ValueError` if the input is not a positive integer. Example: ```python assert fibonacci_basic(0) == 0 assert fibonacci_basic(10) == 55 assert fibonacci_optimized(50) == 12586269025 assert fibonacci_optimized(100000) # Should return a large number within a few seconds ``` Performance Requirements: * `fibonacci_basic` should complete within a second for any valid `n` within its constraint. * `fibonacci_optimized` should complete within a few seconds for any valid `n` within its constraint.","solution":"def fibonacci_basic(n: int) -> int: Returns the n-th Fibonacci number using a direct recursive method. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 return fibonacci_basic(n - 1) + fibonacci_basic(n - 2) def fibonacci_optimized(n: int) -> int: Returns the n-th Fibonacci number using memoization. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") fib_cache = {0: 0, 1: 1} def helper(x): if x in fib_cache: return fib_cache[x] fib_cache[x] = helper(x - 1) + helper(x - 2) return fib_cache[x] return helper(n)"},{"question":"# Problem Statement You are given a list of integers representing the scores of players in a competition. Your task is to write a function `top_three_average` that calculates the average score of the top three distinct highest scores from this list. If there are fewer than three distinct scores, the function should return the average of the available distinct scores. Input - A list of integers, where each integer represents a player\'s score in the competition. Output - A float representing the average of the top three distinct highest scores rounded to two decimal places. Constraints - The list may have between 1 and 10^6 integers. - Each integer in the list is between 1 and 10^6. Function Signature ```python def top_three_average(scores: List[int]) -> float: ``` Example Suppose the list of scores is: ```text scores = [90, 85, 90, 95, 80, 95, 85, 70, 95] ``` The distinct highest scores are [95, 90, 85]. The average of the top three distinct highest scores is: ```text (95 + 90 + 85) / 3 = 270 / 3 = 90.00 ``` So, the output should be `90.00`. Another example: ```text scores = [50, 75] ``` There are only two distinct scores, so the average of 75 and 50 is: ```text (75 + 50) / 2 = 125 / 2 = 62.50 ``` So, the output should be `62.50`. Requirements - Implement the function in Python. - Ensure the function efficiently handles large input sizes within the given constraints. - The function should correctly handle the case when there are fewer than three distinct scores.","solution":"from typing import List def top_three_average(scores: List[int]) -> float: Calculates the average score of the top three distinct highest scores from the list. If there are fewer than three distinct scores, return the average of the available distinct scores. distinct_scores = sorted(set(scores), reverse=True) # Sort distinct scores in descending order top_three_scores = distinct_scores[:3] # Get the top three distinct scores average_of_top_three = sum(top_three_scores) / len(top_three_scores) # Calculate the average return round(average_of_top_three, 2) # Return the average rounded to two decimal places"},{"question":"**Introduction**: You are given an unsorted array of integers, and your task is to find the kth smallest element in the array. This problem will test your understanding of sorting algorithms and data manipulation techniques. **Problem**: Implement the function `find_kth_smallest(arr: List[int], k: int) -> int`. The function should return the kth smallest element in the input array `arr`. **Input**: - A list of integers `arr`. - An integer `k` which specifies the order of the smallest element to find. **Output**: - An integer which is the kth smallest element in the array. **Constraints**: - The length of the array `arr` is at most 10^5. - The values of the elements in the array can be both negative and positive. - Any technique to achieve the result is allowed, but achieving O(n log n) or better time complexity is encouraged. **Example**: ```python >>> find_kth_smallest([3, 2, 1, 5, 6, 4], 2) 2 >>> find_kth_smallest([1, 1, 1, 1, 1], 3) 1 >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 4) 10 ``` **Requirements**: - Handle edge cases such as arrays with duplicate elements, large arrays, and invalid `k` values (like `k` being larger than the array). - Ensure the implementation is efficient and can handle the upper limits of the constraints. **Additional**: - You may utilize standard library functions or sorting algorithms. - Consider different approaches if possible (e.g., quickselect algorithm).","solution":"from typing import List def find_kth_smallest(arr: List[int], k: int) -> int: Finds the kth smallest element in the array. if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds\\") def quickselect(left, right, k_smallest): if left == right: # If the list contains only one element, return arr[left] # return that element pivot_index = partition(left, right) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) def partition(left, right): pivot = arr[right] i = left for j in range(left, right): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[right] = arr[right], arr[i] return i return quickselect(0, len(arr) - 1, k - 1)"},{"question":"# Coding Question on String Manipulation and Pattern Matching Context In text processing, identifying and extracting specific patterns within a string is a common requirement. Regular expressions are powerful tools that allow for flexible and efficient pattern matching. Problem Design a function `extract_phone_numbers(text)`, which receives a single string `text` and extracts all phone numbers found within the text. A phone number is defined as having the format `(XXX) XXX-XXXX`, where `X` is a digit from 0 to 9. Your function should return a list of all valid phone numbers found in the input string in the order they appeared. Requirements To achieve this: 1. Utilize regular expressions to define the pattern of a valid phone number. 2. Use the pattern to search through the `text` and extract all matching phone numbers. 3. Return the matched phone numbers as a list. Input and Output * **Input**: - A single string `text` which may contain multiple phone numbers embedded within other text. * **Output**: - A list of strings, where each string is a valid phone number extracted from the input text. Example ```python def extract_phone_numbers(text): # Your code here # Example: print(extract_phone_numbers(\\"Contact us at (123) 456-7890 or (987) 654-3210 for more information.\\")) # Expected output: [\'(123) 456-7890\', \'(987) 654-3210\'] ``` Provide the implementation for `extract_phone_numbers(text)` ensuring it correctly finds all phone numbers within the given text according to the specified format. Optimize for performance and consider edge cases where text may not contain any phone numbers or includes invalid patterns that should not be matched.","solution":"import re def extract_phone_numbers(text): Extracts all phone numbers in the format (XXX) XXX-XXXX from the given text. Parameters: text (str): Input text containing potential phone numbers. Returns: list: List of extracted phone numbers in the format (XXX) XXX-XXXX. phone_pattern = re.compile(r\'(d{3}) d{3}-d{4}\') return phone_pattern.findall(text)"},{"question":"# Problem Statement You are given two integers `num1` and `num2`. Your task is to write a function `common_factors(num1: int, num2: int) -> int` that computes the number of common factors between `num1` and `num2`. A factor of a number is a positive integer that divides the number without leaving a remainder. # Input Format - The function will accept two integer parameters: `num1` and `num2`. Both integers will be positive. # Output Format - The function should return an integer representing the number of common factors. # Examples ```python assert common_factors(12, 18) == 4 # The common factors are 1, 2, 3, 6 assert common_factors(100, 10) == 3 # The common factors are 1, 2, 5, 10 assert common_factors(7, 13) == 1 # The only common factor is 1 ``` # Constraints - `1 <= num1, num2 <= 10^6` # Requirements 1. Implement an efficient solution to handle the given constraints. 2. Optimize the solution to avoid unnecessary computations.","solution":"def common_factors(num1, num2): Returns the number of common factors between num1 and num2. def gcd(a, b): while b: a, b = b, a % b return a gcd_value = gcd(num1, num2) common_factors_count = 0 for i in range(1, gcd_value + 1): if gcd_value % i == 0: common_factors_count += 1 return common_factors_count"},{"question":"# Question: Digit Power Sum You are given a positive integer `n`. Your task is to implement a function `digit_power_sum(n: int) -> int` which calculates the sum of each digit raised to the power of its position (1-indexed) in the number. Function Signature ```python def digit_power_sum(n: int) -> int: pass ``` Input * A single integer `n` where `1 <= n <= 10^9`. Output * The sum of each digit raised to the power of its position in the integer as an integer. Constraints * The input ( n ) will always be a positive integer within the range specified. * The function should raise a `ValueError` if the input is not a positive integer or raise a `TypeError` if the input is not an integer. Example ```python >>> digit_power_sum(123) 1^1 + 2^2 + 3^3 = 1 + 4 + 27 = 32 32 >>> digit_power_sum(4567) 4^1 + 5^2 + 6^3 + 7^4 = 4 + 25 + 216 + 2401 = 2646 2646 >>> digit_power_sum(987) 9^1 + 8^2 + 7^3 = 9 + 64 + 343 = 416 416 >>> digit_power_sum(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> digit_power_sum(-123) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> digit_power_sum(123.45) Traceback (most recent call last): ... TypeError: Input value of [number=123.45] must be an integer ``` # Scenario Consider you are building a feature for a numeric analysis tool where users can explore various mathematical properties of integers. This feature specifically calculates a unique sum based on the positional powers of the digits in the number. Your task is to implement the calculating function accurately to facilitate this process, adhering to the constraints, edge cases, and requirements provided.","solution":"def digit_power_sum(n: int) -> int: Calculate the sum of each digit raised to the power of its position (1-indexed) in the number. if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") digit_str = str(n) total_sum = 0 for idx, digit in enumerate(digit_str): power = idx + 1 # 1-indexed position total_sum += int(digit) ** power return total_sum"},{"question":"# Coding Challenge: Maze Solver Background: A maze is represented as a 2D grid consisting of cells, where cells can either be passable (True) or blocked (False). You need to start from the upper-left corner of the maze (0, 0) and determine if there\'s a path to the lower-right corner of the maze (width-1, height-1), using only horizontal and vertical movements. Task: Implement a function `is_path_in_maze` that determines if a path exists from the top-left corner to the bottom-right corner of a given maze. Function Signature: ```python def is_path_in_maze(maze: List[List[bool]]) -> bool: pass ``` Input: * A list of lists of booleans `maze` of dimensions `width` x `height`, representing the maze. True signifies a passable cell, and False signifies a blocked cell. Output: * A boolean representing whether or not there is a path from the top-left corner to the bottom-right corner. Constraints: * 1 <= width, height <= 1000 * The maze will have at least 1 row and 1 column. * The cells (0, 0) and (width-1, height-1) will always be passable. Example: ```python assert is_path_in_maze([ [True, False, True], [True, True, False], [False, True, True] ]) == True assert is_path_in_maze([ [True, False, False], [False, False, False], [False, True, True] ]) == False ``` **Note**: The function should correctly determine if a path exists according to the rules stated, ensuring the complexity and scope match the provided guidelines.","solution":"def is_path_in_maze(maze): This function determines if there is a path from the top-left corner to the bottom-right corner of the maze. :param maze: List[List[bool]] - A 2D list representing the maze with True for passable cells and False for blocked. :return: bool - True if there is a path, False otherwise. if not maze or not maze[0]: return False height = len(maze) width = len(maze[0]) # Using BFS for path finding from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == width - 1 and y == height - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < width and 0 <= ny < height and maze[ny][nx] and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Problem Statement You are developing a program that helps users manage and analyze their daily expenses. As part of this program, you need to write a function that calculates the total expense for a given list of transactions and groups them by their categories. # Requirements 1. Implement a function `calculate_expenses(transactions: list) -> dict` that: - Takes a list of transaction entries as input. - Groups the transactions by categories and sums the expenses for each category. - Returns a dictionary where keys are categories and values are the respective total expenses. # Input - `transactions`: A list of dictionaries, where each dictionary represents a single transaction with the following keys: - `\\"amount\\"`: A floating-point number representing the expense amount. - `\\"category\\"`: A string representing the expense category (e.g., \\"food\\", \\"transportation\\"). # Output - Returns a dictionary containing the total expenses grouped by categories: ```python { \\"category1\\": total_expense1, \\"category2\\": total_expense2, ... } ``` # Constraints - The function must handle at least 1 and up to 1000 transactions. - Each `amount` is guaranteed to be a positive floating-point number. - The `category` will be a non-empty string consisting of alphabetic characters and possibly spaces. # Example ```python transactions = [ {\\"amount\\": 12.50, \\"category\\": \\"food\\"}, {\\"amount\\": 20.00, \\"category\\": \\"transportation\\"}, {\\"amount\\": 5.00, \\"category\\": \\"food\\"}, {\\"amount\\": 8.75, \\"category\\": \\"entertainment\\"} ] result = calculate_expenses(transactions) print(result) # Expected Output # { # \\"food\\": 17.50, # \\"transportation\\": 20.00, # \\"entertainment\\": 8.75 # } ``` # Function Signature ```python def calculate_expenses(transactions: list) -> dict: # Your implementation here pass ```","solution":"def calculate_expenses(transactions: list) -> dict: Calculate the total expenses grouped by categories. Args: transactions (list): A list of transaction dictionaries with keys \'amount\' and \'category\'. Returns: dict: A dictionary where keys are categories and values are the respective total expenses. expenses_by_category = {} for transaction in transactions: amount = transaction[\'amount\'] category = transaction[\'category\'] if category not in expenses_by_category: expenses_by_category[category] = 0.0 expenses_by_category[category] += amount return expenses_by_category"},{"question":"# Question: Average Speed Calculator Problem Statement: You are required to implement a Python function that calculates the average speed of a vehicle. The average speed is computed using the formula `average_speed = total_distance / total_time`. The `total_distance` is the total distance covered in meters (m), and the `total_time` is the total time taken in seconds (s). Function Signature: ```python def average_speed(total_distance: float, total_time: float) -> float: ``` Input: - **total_distance** (float): The total distance covered in meters (m). (0 ≤ total_distance ≤ 10^7) - **total_time** (float): The total time taken in seconds (s). (0 < total_time ≤ 10^6) Output: - Returns the average speed (float) in meters per second (m/s). Constraints: - If `total_distance` is negative, raise a `ValueError` with the message \\"Total distance cannot be negative\\". - If `total_time` is non-positive, raise a `ValueError` with the message \\"Total time must be positive\\". Examples: ```python >>> average_speed(1000, 500) 2.0 >>> average_speed(1500, 300) 5.0 >>> average_speed(0, 1) 0.0 >>> average_speed(3000, 600) 5.0 >>> average_speed(0, 15) 0.0 >>> average_speed(1200, 400) 3.0 >>> average_speed(500, 1000) 0.5 ``` Implementation: Use Python, making sure the function handles edge cases and properly processes input that may raise exceptions as defined above.","solution":"def average_speed(total_distance: float, total_time: float) -> float: Calculate the average speed given the total distance and total time. Parameters: total_distance (float): The total distance covered in meters (m). total_time (float): The total time taken in seconds (s). Returns: float: The average speed in meters per second (m/s). Raises: ValueError: If `total_distance` is negative or `total_time` is non-positive. if total_distance < 0: raise ValueError(\\"Total distance cannot be negative\\") if total_time <= 0: raise ValueError(\\"Total time must be positive\\") return total_distance / total_time"},{"question":"# Polynomial Evaluation In this task, you are required to implement a function that evaluates the value of a polynomial given the coefficients and the point at which the polynomial should be evaluated. The polynomial is represented by a list of coefficients, where the i-th element corresponds to the coefficient of the (x^i) term. **Function Signature:** ```python def evaluate_polynomial(coefficients: list[float], x: float) -> float: pass ``` **Parameters:** - `coefficients` (list of floats): A list of coefficients for the polynomial, where the i-th element represents the coefficient of (x^i). - `x` (float): The point at which the polynomial should be evaluated. **Returns:** - `result` (float): The value of the polynomial evaluated at `x`. **Constraints:** 1. The coefficients list must contain at least one element. 2. The point `x` is a valid float. **Examples:** 1. `evaluate_polynomial([1, 0, -2, 3], 2)` → (1 - 0 cdot 2 - 2 cdot 2^2 + 3 cdot 2^3 = 1 - 0 - 8 + 24 = 17) 2. `evaluate_polynomial([2, 0, 3], -1)` → (2 + 0 cdot (-1)^1 + 3 cdot (-1)^2 = 2 + 0 + 3 = 5) 3. `evaluate_polynomial([4], 3)` → (4) 4. `evaluate_polynomial([1, -1, 1, -1], 1)` → (1 - 1 cdot 1 + 1 cdot 1 - 1 cdot 1 = 0) **Your task is to implement the `evaluate_polynomial` function described above. Be sure to handle edge cases and ensure that the computation is correct for polynomials of various lengths and at different points.**","solution":"def evaluate_polynomial(coefficients, x): Evaluate the value of a polynomial at a given point x. :param coefficients: List of floats where the i-th element is the coefficient of x^i. :param x: The point at which the polynomial is evaluated. :return: The value of the polynomial evaluated at x. result = 0 for i, coef in enumerate(coefficients): result += coef * (x ** i) return result"},{"question":"# Your Task You are to write a function that performs a special type of string sorting based on the frequency of characters. The goal is to sort the characters in decreasing order of their frequency. If two characters have the same frequency, they are sorted in increasing lexicographical order. # Detailed Requirements 1. **Frequency Calculation**: * Count the occurrences of each character in the given string. 2. **Sorting by Frequency**: * Sort the characters by their frequency in descending order. * In case of a tie in frequency, the characters should be sorted in ascending lexicographical order. 3. **Reconstruct the Sorted String**: * Construct a new string based solely on the sorted characters and their frequencies. # Function Signature ```python def sort_by_frequency(s: str) -> str: Sorts the characters in the string based on their frequency in descending order. Characters with the same frequency are sorted in ascending lexicographical order. :param s: str - The input string :return: str - The string with characters sorted by their frequency pass ``` # Input and Output Format Constraints * Input string `s` can contain any characters, including alphabetic letters, digits, and special symbols. * The length of the string `s` is up to 10^5 characters. Examples ```python >>> sort_by_frequency(\\"tree\\") \\"eert\\" >>> sort_by_frequency(\\"cccaaa\\") \\"aaaccc\\" >>> sort_by_frequency(\\"Aabb\\") \\"bbAa\\" ``` # Performance Requirements * Your solution should efficiently handle strings of up to 10^5 characters.","solution":"from collections import Counter def sort_by_frequency(s: str) -> str: Sorts the characters in the string based on their frequency in descending order. Characters with the same frequency are sorted in ascending lexicographical order. :param s: str - The input string :return: str - The string with characters sorted by their frequency # Count frequencies of characters frequency = Counter(s) # Sort by frequency (descending), and by character (ascending) when frequencies are same sorted_chars = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # Reconstruct the sorted string result = \'\'.join(char * freq for char, freq in sorted_chars) return result"},{"question":"# Question: Employee Hierarchy Level Calculation **Context:** A company employs a layered hierarchical structure where employees are assigned levels based on their reporting hierarchy. Your task is to develop a function that identifies the hierarchical level of a given employee based on their direct report relationships. **Problem Statement:** Write a function `calculate_employee_level` that determines the hierarchical level of an employee based on a list of direct report relationships. The level of the topmost employee (CEO) is 0, and the level increases by 1 for every layer down the hierarchy. **Function Signature:** ```python def calculate_employee_level(employee: str, report_list: List[Tuple[str, str]]) -> int: pass ``` **Input:** * `employee`: A string representing the name of the employee whose level needs to be calculated. * `report_list`: A list of tuples, where each tuple contains two strings. The first string in the tuple is the name of one employee reporting to the second string (e.g., `(\\"employee1\\", \\"employee2\\")` means `employee1` reports to `employee2`). **Output:** * An integer representing the hierarchical level of the specified employee. **Constraints:** * All employee names are unique. * The input list `report_list` represents a valid hierarchy without cycles. * If the employee does not exist in the report_list, an appropriate level of -1 should be returned. **Examples:** ```python # Example 1: calculate_employee_level(\\"Alice\\", [(\\"Bob\\", \\"Alice\\"), (\\"Charlie\\", \\"Bob\\"), (\\"David\\", \\"Alice\\")]) # Expected Output: 0 # Example 2: calculate_employee_level(\\"Bob\\", [(\\"Bob\\", \\"Alice\\"), (\\"Charlie\\", \\"Bob\\"), (\\"David\\", \\"Alice\\")]) # Expected Output: 1 # Example 3: calculate_employee_level(\\"Charlie\\", [(\\"Bob\\", \\"Alice\\"), (\\"Charlie\\", \\"Bob\\"), (\\"David\\", \\"Alice\\")]) # Expected Output: 2 # Example 4: calculate_employee_level(\\"Tom\\", [(\\"Bob\\", \\"Alice\\"), (\\"Charlie\\", \\"Bob\\"), (\\"David\\", \\"Alice\\")]) # Expected Output: -1 ``` **Notes:** * Hierarchical relationships are provided without any cycles or invalid structures. * Ensure that your implementation is efficient and properly handles various edge cases. Provide a working code implementation that adheres to the above specifications.","solution":"from typing import List, Tuple def calculate_employee_level(employee: str, report_list: List[Tuple[str, str]]) -> int: # Create a dictionary to store each employee\'s manager manager_dict = {} employees_set = set() for emp, mgr in report_list: manager_dict[emp] = mgr employees_set.update([emp, mgr]) if employee not in employees_set: return -1 # Initialize level counter level = 0 # Traverse up the hierarchy until we cannot find a manager while employee in manager_dict: employee = manager_dict[employee] level += 1 return level"},{"question":"# Coding Assessment Question Scenario You are developing a test suite for an arithmetic library that needs to verify the correct implementation of integer addition. As part of this, you\'d like to create a function that computes the sum of two integers without using the `+` operator. You can utilize bitwise operations to achieve this. Task Write a function `add_without_plus` that takes in two integers and returns their sum, using only bitwise operations. Function Signature ```python def add_without_plus(a: int, b: int) -> int: ``` Input * `a`: An integer. * `b`: An integer. Output * An integer representing the sum of `a` and `b`. Constraints * -1000 <= `a`, `b` <= 1000 Examples ```python >>> add_without_plus(1, 2) 3 >>> add_without_plus(-1, 1) 0 >>> add_without_plus(3, 5) 8 >>> add_without_plus(-3, -7) -10 ``` Explanation of Examples * For `add_without_plus(1, 2)`, the function computes the sum of 1 and 2 which is 3, without using the `+` operator. * For `add_without_plus(-1, 1)`, the function computes the sum of -1 and 1 which is 0, without using the `+` operator. * For `add_without_plus(3, 5)`, the function computes the sum of 3 and 5 which is 8, without using the `+` operator. * For `add_without_plus(-3, -7)`, the function computes the sum of -3 and -7 which is -10, without using the `+` operator. Performance Requirements * The function should execute in constant time O(1).","solution":"def add_without_plus(a: int, b: int) -> int: Returns the sum of a and b using bitwise operations. # Use 32 bits integer max MASK = 0xFFFFFFFF INT_MAX = 0x7FFFFFFF while b != 0: # Calculate carry carry = (a & b) & MASK # Sum without carry a = (a ^ b) & MASK # Carry shifted left by one b = (carry << 1) & MASK # If a is negative, convert to 32-bit signed integer if a > INT_MAX: a = ~(a ^ MASK) return a"},{"question":"# Problem Statement A popular movie streaming platform wants to predict which movies a user might like based on their viewing history. They categorize movies into five genres: Action, Comedy, Drama, Romance, and Sci-Fi. To create a recommendation algorithm, they require a function to calculate a genre score based on the viewing history of a user. The genre score is determined as the sum of all ratings for movies of that genre divided by the total number of movies rated by the user in that genre. Function Signature ```python def calculate_genre_scores(viewing_history: List[Tuple[str, int]]) -> Dict[str, float]: ``` # Input - `viewing_history`: A list of tuples where each tuple contains a genre (string) and a rating (integer). The genres are guaranteed to be one of [\'Action\', \'Comedy\', \'Drama\', \'Romance\', \'Sci-Fi\'], and the ratings are integers from 1 to 5. # Output - Returns a dictionary where each key is a genre and each value is the calculated genre score (a float rounded to two decimal places). The dictionary should contain all five genres, even if the user has not viewed any movies in some genres. # Constraints - The viewing history can be empty, in which case all genre scores should be 0.0. # Example ```python assert calculate_genre_scores([(\'Action\', 5), (\'Comedy\', 3), (\'Action\', 4)]) == { \'Action\': 4.50, \'Comedy\': 3.00, \'Drama\': 0.00, \'Romance\': 0.00, \'Sci-Fi\': 0.00 } assert calculate_genre_scores([(\'Drama\', 5), (\'Romance\', 1), (\'Drama\', 2), (\'Sci-Fi\', 4), (\'Sci-Fi\', 2)]) == { \'Action\': 0.00, \'Comedy\': 0.00, \'Drama\': 3.50, \'Romance\': 1.00, \'Sci-Fi\': 3.00 } assert calculate_genre_scores([]) == { \'Action\': 0.00, \'Comedy\': 0.00, \'Drama\': 0.00, \'Romance\': 0.00, \'Sci-Fi\': 0.00 } ``` # Explanation 1. For the first example, the genre \\"Action\\" has two movie ratings (5 + 4), so the score is (5+4)/2 = 4.50. The genre \\"Comedy\\" has one movie rating (3), so the score is 3. The other genres have no movies watched, hence their scores are 0.0. 2. For the second example, the genre scores are calculated similarly, based on the average ratings per genre. 3. The third example shows the edge case where the viewing history is empty, resulting in all genre scores being 0.0. Implement the function to ensure accurate and efficient calculation of the genre scores, taking into account edge cases and correct rounding of float values.","solution":"from typing import List, Tuple, Dict def calculate_genre_scores(viewing_history: List[Tuple[str, int]]) -> Dict[str, float]: genres = [\'Action\', \'Comedy\', \'Drama\', \'Romance\', \'Sci-Fi\'] genre_ratings = {genre: [] for genre in genres} for genre, rating in viewing_history: genre_ratings[genre].append(rating) genre_scores = {} for genre in genres: if genre_ratings[genre]: genre_scores[genre] = round(sum(genre_ratings[genre]) / len(genre_ratings[genre]), 2) else: genre_scores[genre] = 0.0 return genre_scores"},{"question":"# Coding Assessment Question You need to implement a function `find_shortest_path` that computes the shortest distance between two nodes in an undirected, weighted graph using Dijkstra\'s algorithm. # Function Signature ```python def find_shortest_path(edges: List[Tuple[int, int, float]], start_node: int, end_node: int) -> float: pass ``` # Input * `edges` (List of Tuples): A list of edges in the graph, where each edge is represented as a tuple (node1, node2, weight). * `start_node` (int): The starting node for the path. * `end_node` (int): The target node for the path. # Output * Returns a float representing the shortest distance from `start_node` to `end_node`. # Constraints * Each node is represented by a unique integer. * The graph has at least one node and one edge, and no negative weights. * If `start_node` equals `end_node`, return 0.0. * If there is no path from `start_node` to `end_node`, return float(\'inf\'). # Performance Requirements * Solution should efficiently handle large graphs with thousands of nodes and edges. * Optimal algorithmic efficiency is expected. # Example ```python edges = [ (0, 1, 4.0), (0, 2, 1.0), (2, 1, 2.0), (1, 3, 1.0), (2, 3, 5.0) ] start_node = 0 end_node = 3 result = find_shortest_path(edges, start_node, end_node) print(result) ``` Expected output: ```python 4.0 ``` # Note * You can use any data structures and libraries that may help achieve the optimal solution. * Make sure the function handles edge cases e.g., no path exists, the node does not exist in the graph, etc.","solution":"import heapq from typing import List, Tuple def find_shortest_path(edges: List[Tuple[int, int, float]], start_node: int, end_node: int) -> float: if start_node == end_node: return 0.0 # Build the graph as an adjacency list graph = {} for node1, node2, weight in edges: if node1 not in graph: graph[node1] = [] if node2 not in graph: graph[node2] = [] graph[node1].append((weight, node2)) graph[node2].append((weight, node1)) # Dijkstra\'s algorithm priority_queue = [(0, start_node)] shortest_paths = {start_node: 0} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end_node: return current_distance for weight, neighbor in graph.get(current_node, []): distance = current_distance + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return float(\'inf\')"},{"question":"# Coding Assessment Question Scenario: You are working on implementing an inventory management system for a warehouse. The inventory system needs to handle entry and exit logs of items. Each item is identified by a name and has an associated quantity. Implement a function to process the logs and return the current inventory levels. Task: Write a function `manage_inventory(logs: List[Tuple[str, str, int]]) -> Dict[str, int]` that processes the given logs and returns a dictionary representing the current inventory levels of the items. Input: 1. `logs`: A list of tuples where each tuple represents a log entry. Each tuple contains three elements: - `action`: A string that can either be \\"IN\\" (indicating an incoming item) or \\"OUT\\" (indicating an outgoing item). - `item`: A string representing the name of the item. - `quantity`: An integer representing the quantity of the item. Output: - A dictionary where keys are item names and values are the current quantities of the items. Constraints: - The quantity for \\"IN\\" actions is guaranteed to be a positive integer. - The quantity for \\"OUT\\" actions is guaranteed to be a non-negative integer and not greater than the current available inventory for the item. Example: ```python logs = [ (\\"IN\\", \\"widget\\", 10), (\\"OUT\\", \\"widget\\", 5), (\\"IN\\", \\"gadget\\", 7), (\\"OUT\\", \\"gadget\\", 2), (\\"IN\\", \\"widget\\", 3) ] print(manage_inventory(logs)) # Output: {\'widget\': 8, \'gadget\': 5} ``` # Performance Requirements: - The function should handle up to 50,000 log entries efficiently. Note: - Ensure to handle cases where no logs exist for an item, which means it should not appear in the final inventory dictionary. - Order of logs matters, process them sequentially as they appear in the input list.","solution":"from typing import List, Tuple, Dict def manage_inventory(logs: List[Tuple[str, str, int]]) -> Dict[str, int]: inventory = {} for action, item, quantity in logs: if action == \\"IN\\": if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif action == \\"OUT\\": if item in inventory: inventory[item] -= quantity if inventory[item] <= 0: del inventory[item] return inventory"},{"question":"# Coding Assessment Question Scenario You are tasked with managing a warehouse inventory system. Each product in the warehouse has an associated stock level and a restocking threshold. When the stock level of any product falls below its restocking threshold, a restocking alert should be triggered. Implement a function to process a series of transactions on the inventory and determine which products need restocking at the end of the series. Task Implement a function `process_transactions` that, given an inventory and a series of transactions, updates the inventory and returns a list of product IDs that need restocking. Function Signature ```python def process_transactions(inventory: List[Tuple[str, int, int]], transactions: List[Tuple[str, int]]) -> List[str]: ``` Input * `inventory (List[Tuple[str, int, int]])`: A list of tuples where each tuple represents a product with: * `product_id (str)`: The unique identifier of the product. * `stock_level (int)`: The current stock level of the product. * `threshold (int)`: The restocking threshold for the product. * `transactions (List[Tuple[str, int]])`: A list of tuples where each tuple represents a transaction with: * `product_id (str)`: The unique identifier of the product. * `quantity (int)`: The quantity sold in the transaction. Output * Returns a list of `product_id`(str) that need restocking at the end of the transactions. Constraints * The `product_id` in `transactions` will always exist in the `inventory`. * Initial `stock_level` and `quantity` are non-negative integers. * The quantity in `transactions` represents items sold and should be subtracted from the corresponding `stock_level`. Example ```python Consider the following inventory and transactions: inventory = [ (\\"A100\\", 50, 20), (\\"B200\\", 30, 10), (\\"C300\\", 5, 5) ] transactions = [ (\\"A100\\", 20), (\\"B200\\", 30), (\\"C300\\", 1) ] The function call process_transactions(inventory, transactions) should return [\\"B200\\", \\"C300\\"] because: - Product B200\'s stock level will be 0, which is below its threshold of 10. - Product C300\'s stock level will be 4, which is below its threshold of 5. inventory = [ (\\"A100\\", 50, 20), (\\"B200\\", 30, 10), (\\"C300\\", 5, 5) ] transactions = [ (\\"A100\\", 20), (\\"B200\\", 30), (\\"C300\\", 1) ] restock_list = process_transactions(inventory, transactions) print(restock_list) # Output should be [\\"B200\\", \\"C300\\"] ``` Notes * Focus on the correctness and efficiency of the solution. * Ensure to handle potential edge cases, such as multiple transactions for the same product.","solution":"def process_transactions(inventory, transactions): Process a series of transactions on the inventory and return a list of product IDs that need restocking. Parameters: inventory (List[Tuple[str, int, int]]): List of tuples with product_id, stock_level, threshold. transactions (List[Tuple[str, int]]): List of tuples with product_id, quantity sold. Returns: List[str]: List of product IDs that need restocking. # Create a dictionary to facilitate quick lookup and update of stock levels. inventory_dict = {product_id: [stock_level, threshold] for product_id, stock_level, threshold in inventory} # Process each transaction for product_id, quantity in transactions: if product_id in inventory_dict: inventory_dict[product_id][0] -= quantity # Collect the product IDs that need restocking restock_list = [product_id for product_id, (stock_level, threshold) in inventory_dict.items() if stock_level < threshold] return restock_list"},{"question":"Fibonacci Sequence with Optimized Iteration You are required to implement a Python function to compute the nth number in the Fibonacci sequence using an optimized iterative approach that minimizes space complexity. The function should only use a constant amount of extra space. # Problem Statement Design a function `optimized_fibonacci` that takes an integer `n` and returns the nth Fibonacci number. The function should be optimized to use O(1) additional space. **Function Signature**: ```python def optimized_fibonacci(n: int) -> int: pass ``` # Input - `n`: An integer representing the position in the Fibonacci sequence to retrieve. (0 <= n <= 1000) # Output - An integer representing the nth Fibonacci number. # Example ```python assert optimized_fibonacci(5) == 5 assert optimized_fibonacci(10) == 55 assert optimized_fibonacci(0) == 0 assert optimized_fibonacci(1) == 1 ``` # Constraints - The function should handle edge cases where `n` is 0 or 1 appropriately. - It must be noted that you cannot use extra space proportional to `n`. # Clarifications - For `n = 0`, the function should return 0. - For `n = 1`, the function should return 1. - For `n > 1`, the function should compute the sequence iteratively using only two variables to track the necessary previous values.","solution":"def optimized_fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement You are given an unsorted array of integers. Your task is to find the length of the longest consecutive elements sequence. The consecutive sequence must be made up of elements that follow one another in strict consecutive order without any gaps. # Function Signature ```python def longest_consecutive_sequence(nums: list[int]) -> int: pass ``` # Input - `nums`: A list of integers where each integer ranges from -10^9 to 10^9. # Output - Return an integer representing the length of the longest consecutive elements sequence. # Constraints - The number of elements (N) in the list will be at most 10^5. - The elements in the list are unique. # Example ```python nums = [100, 4, 200, 1, 3, 2] output = longest_consecutive_sequence(nums) # Expected output: 4 ``` # Implementation Details - Implement the `longest_consecutive_sequence` function using a set to achieve O(n) complexity. - Ensure to handle cases with an empty list or lists with a single element. --- This new question fits seamlessly with the provided sample question by matching the desired style, complexity, and scope. Both questions focus on fundamental data structure operations, such as traversal and searching, but approach different problem domains (matrix graph traversal vs array manipulation).","solution":"def longest_consecutive_sequence(nums: list[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # start of a new sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Palindrome Permutation Check You are working on a text-processing application, and you\'ve been assigned the task of checking whether any permutation of a given string can form a palindrome. A palindrome is a string that reads the same forward and backward. For example, \\"madam\\" and \\"racecar\\" are palindromes. Task: Write a function: `def can_form_palindrome(s: str) -> bool:` **Parameters**: - `s` (str): The input string to be checked. **Return**: - (bool): Return `True` if any permutation of the input string can form a palindrome, otherwise return `False`. Constraints: - The input string can have both uppercase and lowercase letters, but for the purpose of this task, consider the characters case-insensitive. - The input string can be empty. - The input string may only contain alphabetic characters (a-z, A-Z). **Example**: ```python print(can_form_palindrome(\\"Tact Coa\\")) # prints True, as \\"Tact Coa\\" can be permuted to form \\"tacocat\\" or \\"atcocta\\", both of which are palindromes print(can_form_palindrome(\\"hello\\")) # prints False, as no permutation of \\"hello\\" forms a palindrome ``` Performance Requirements: - Aim for O(n) time complexity, where n is the length of the input string. - Use O(1) additional space complexity (excluding the input and the space required for the counter).","solution":"def can_form_palindrome(s: str) -> bool: Check if any permutation of the given string can form a palindrome. :param s: The input string to be checked. :return: True if any permutation can form a palindrome, otherwise False. from collections import Counter # Normalize the string to lowercase as the problem is case-insensitive normalized_str = s.lower().replace(\\" \\", \\"\\") # Count the frequency of each character char_count = Counter(normalized_str) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd count is allowed for a palindrome return odd_count <= 1"},{"question":"# Substring Repetition Given a string `s` consisting of lowercase English letters, write a function to determine the length of the shortest substring that can be repeated one or more times to recreate the entire string. If the entire string cannot be constructed by repeating any of its substrings, return the length of the string itself. Function Specification **Function**: `shortest_repeated_substring_length(s: str) -> int` **Input**: - A single string `s` composed of lowercase English letters. **Output**: - An integer representing the length of the shortest repeating substring. Examples ```python >>> shortest_repeated_substring_length(\\"ababab\\") 2 >>> shortest_repeated_substring_length(\\"abcdef\\") 6 >>> shortest_repeated_substring_length(\\"aaa\\") 1 >>> shortest_repeated_substring_length(\\"xyzxyzxyz\\") 3 >>> shortest_repeated_substring_length(\\"water\\") 5 ``` Constraints 1. The string length will be at least 1 and at most 10^5. 2. The solution should be efficient, ideally O(n) in time complexity. Explanation To solve this problem, one would need to identify substrings that could potentially repeat to form the entire given string. The approach involves checking the divisors of the string length and verifying if the string can be constructed by repeating the substring of that length. The shortest valid repeating substring\'s length should be returned.","solution":"def shortest_repeated_substring_length(s: str) -> int: Returns the length of the shortest substring that can be repeated to recreate the entire string s. n = len(s) # Check lengths from 1 to half the string length for i in range(1, n // 2 + 1): if n % i == 0: # Only check if the current length is a divisor of n if s[:i] * (n // i) == s: return i # If no repeating pattern is found, return the length of the string itself return n"},{"question":"# Employee Task Tracker You work for a company that wants to build an internal tool to monitor and manage employee tasks. Each task has a unique identifier, a description, a completion status, and a priority level. Employees can add new tasks, mark tasks as completed, and list tasks based on certain criteria. **Your task** is to implement a class `TaskTracker` that represents a simple task management system for employees. **Class Definition:** ```python class TaskTracker: def __init__(self): Initializes a new TaskTracker instance with an empty task list. pass def add_task(self, task_id: str, description: str, priority: int): Adds a new task to the tracker. :param task_id: The unique identifier for the task. :param description: A brief description of the task. :param priority: The priority level of the task (1-5). pass def complete_task(self, task_id: str): Marks a task as completed. :param task_id: The unique identifier of the task to be marked as completed. pass def get_pending_tasks(self) -> list: Returns a list of pending tasks sorted by priority (highest priority first). :return: A list of pending tasks (each task represented as a tuple). pass def get_completed_tasks(self) -> list: Returns a list of completed tasks. :return: A list of completed tasks (each task represented as a tuple). pass ``` **Task Representation:** - Each task can be represented as a tuple of the form `(task_id, description, priority, completed)`, where: - `task_id` (str): The unique identifier for the task. - `description` (str): A brief description of the task. - `priority` (int): The priority level of the task (1-5). - `completed` (bool): The completion status of the task. **Example Usage:** ```python # Example demonstrating the use of TaskTracker tracker = TaskTracker() tracker.add_task(\\"T1\\", \\"Fix bug in module\\", 3) tracker.add_task(\\"T2\\", \\"Implement new feature\\", 1) tracker.add_task(\\"T3\\", \\"Write documentation\\", 2) print(tracker.get_pending_tasks()) # Should output: [(\'T2\', \'Implement new feature\', 1, False), (\'T3\', \'Write documentation\', 2, False), (\'T1\', \'Fix bug in module\', 3, False)] tracker.complete_task(\\"T1\\") print(tracker.get_completed_tasks()) # Should output: [(\'T1\', \'Fix bug in module\', 3, True)] ``` **Notes:** - Adding a task with a duplicate `task_id` should be handled appropriately (e.g., ignoring the new task, or updating the existing one). - The method `get_pending_tasks` should return tasks sorted by priority (highest priority first). The priority is represented by an integer where `1` is the highest priority and `5` is the lowest. - The method `get_completed_tasks` should return the list of tasks that have been marked as completed. Implement the `TaskTracker` class based on the specifications provided above.","solution":"class TaskTracker: def __init__(self): Initializes a new TaskTracker instance with an empty task list. self.tasks = {} def add_task(self, task_id: str, description: str, priority: int): Adds a new task to the tracker. :param task_id: The unique identifier for the task. :param description: A brief description of the task. :param priority: The priority level of the task (1-5). if task_id not in self.tasks: self.tasks[task_id] = (description, priority, False) else: self.tasks[task_id] = (description, priority, self.tasks[task_id][2]) def complete_task(self, task_id: str): Marks a task as completed. :param task_id: The unique identifier of the task to be marked as completed. if task_id in self.tasks: description, priority, _ = self.tasks[task_id] self.tasks[task_id] = (description, priority, True) def get_pending_tasks(self) -> list: Returns a list of pending tasks sorted by priority (highest priority first). :return: A list of pending tasks (each task represented as a tuple). pending_tasks = [(task_id, desc, prio, completed) for task_id, (desc, prio, completed) in self.tasks.items() if not completed] return sorted(pending_tasks, key=lambda x: x[2]) def get_completed_tasks(self) -> list: Returns a list of completed tasks. :return: A list of completed tasks (each task represented as a tuple). return [(task_id, desc, prio, completed) for task_id, (desc, prio, completed) in self.tasks.items() if completed]"},{"question":"# Array Manipulation: Efficient Minimum Range Query Background: You are given an array of integers and a series of range queries. Each query asks for the minimum value in a specific subarray. The naive approach would be to iterate through the subarray for each query, which can be inefficient for large datasets and many queries. Task: Enhance the algorithm to handle multiple range queries more efficiently by preprocessing the array. Requirements: 1. **Preprocessing**: - Implement a preprocessing step to prepare the array for quick minimum range queries. - Use an appropriate data structure, such as a Segment Tree or Sparse Table, to facilitate efficient query processing. 2. **Query Handling**: - Implement a function to handle range queries that, given the preprocessed data, returns the minimum value in the specified subarray. Function Implementation: Define and implement the following methods: - `preprocess(array: List[int]) -> None`: preprocess the input array. - `range_minimum(array: List[int], left: int, right: int) -> int`: return the minimum value in the subarray from index `left` to `right` (inclusive). Input and Output **Function Signatures**: ```python def preprocess(array: List[int]) -> None: # Implement preprocessing for efficient range minimum queries def range_minimum(array: List[int], left: int, right: int) -> int: # Implement range minimum query using preprocessed data ``` **Example**: ```python # Sample usage array = [1, 3, 2, 7, 9, 11] preprocess(array) assert range_minimum(array, 1, 4) == 2 # Min value in subarray [3, 2, 7, 9] is 2 assert range_minimum(array, 0, 2) == 1 # Min value in subarray [1, 3, 2] is 1 assert range_minimum(array, 3, 5) == 7 # Min value in subarray [7, 9, 11] is 7 ``` **Constraints**: - The array length n: 1 <= n <= 10^5 - Each range query is defined by indices 0 <= left <= right < n. - The number of queries q: 1 <= q <= 10^4 **Performance Requirements**: - Preprocessing step should be efficient. - Each range query should be handled in O(log n) time complexity or better.","solution":"from typing import List import math # Global sparse table and array length st = [] n = 0 def preprocess(array: List[int]) -> None: global st, n n = len(array) # Initialize sparse table with maximum dimensions k = int(math.log2(n)) + 1 st = [[0] * k for _ in range(n)] # Preprocessing step to build sparse table for i in range(n): st[i][0] = array[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = min(st[i][j-1], st[i + (1 << (j-1))][j-1]) i += 1 j += 1 def range_minimum(array: List[int], left: int, right: int) -> int: global st j = int(math.log2(right - left + 1)) return min(st[left][j], st[right - (1 << j) + 1][j])"},{"question":"# Circular Linked List Insertion and Traversal You are asked to manage a circular singly linked list by implementing two functions: one to insert a node at the end of the list and another to traverse the list and return all its elements. **Function 1: insert_at_end** - **Input**: An integer representing the value to be added to the end of the list. - **Output**: None. The function should modify the list in place. **Function 2: traverse** - **Input**: None. - **Output**: A list of integers representing the elements of the circular linked list in the order they are linked, starting from the head node. # Constraints: 1. The list can have a maximum of 1000 elements. 2. When the `insert_at_end` function is called for the first time, it initializes the list with a single node which is the head of the list. 3. The list should maintain its circular property at all times. 4. The `traverse` function should return an empty list if the circular linked list is not initialized (no elements have been added yet). # Example Cases: Input/Output: **Example 1:** ```python # Initialize and insert elements circular_list = CircularLinkedList() circular_list.insert_at_end(10) circular_list.insert_at_end(20) circular_list.insert_at_end(30) # Traverse and get elements circular_list.traverse() -> [10, 20, 30] ``` **Example 2:** ```python # Initialize and insert elements circular_list = CircularLinkedList() circular_list.insert_at_end(5) # Traverse and get elements circular_list.traverse() -> [5] ```","solution":"class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def insert_at_end(self, value): new_node = Node(value) if not self.head: self.head = new_node self.head.next = self.head else: current = self.head while current.next != self.head: current = current.next current.next = new_node new_node.next = self.head def traverse(self): elements = [] if not self.head: return elements current = self.head while True: elements.append(current.data) current = current.next if current == self.head: break return elements"},{"question":"# Scenario You are required to build a simple inventory management system to help track a store\'s products and their available quantities. Implement the `Inventory` class with methods to add products, remove products, update quantities, and get a list of all products. # Requirements **Class Signature**: ```python class Inventory: def __init__(self): pass def add_product(self, product_name: str, quantity: int): pass def remove_product(self, product_name: str): pass def update_quantity(self, product_name: str, quantity: int): pass def list_products(self) -> dict: pass ``` # Input & Output Formats - `add_product`: * **Input**: A string `product_name` and an integer `quantity`. * **Behavior**: Adds a new product with the given quantity. If the product already exists, update its quantity to the new value. - `remove_product`: * **Input**: A string `product_name`. * **Behavior**: Removes the product from the inventory if it exists. - `update_quantity`: * **Input**: A string `product_name` and an integer `quantity`. * **Behavior**: Updates the quantity of the specified product. If the product does not exist, it raises a ValueError. - `list_products`: * **Output**: A dictionary where each key is a product name and each value is the quantity of that product. # Constraints - All product names are unique strings. - Quantities are non-negative integers. - If a product being updated or removed does not exist, appropriate error handling (like ValueError) should be implemented. - Use a dictionary to store product names as keys and their quantities as values within the Inventory class. # Performance Requirements * Time Complexity for add, remove, and update operations: O(1). * Space Complexity: O(n) where n is the number of unique products. # Example ```python >>> inv = Inventory() >>> inv.add_product(\'apple\', 10) >>> inv.add_product(\'banana\', 5) >>> inv.update_quantity(\'banana\', 15) >>> inv.list_products() {\'apple\': 10, \'banana\': 15} >>> inv.remove_product(\'apple\') >>> inv.list_products() {\'banana\': 15} >>> inv.update_quantity(\'orange\', 5) Traceback (most recent call last): ... ValueError: Product \'orange\' does not exist. ```","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_name: str, quantity: int): Adds a product with the specified quantity. If the product already exists, update its quantity. self.products[product_name] = quantity def remove_product(self, product_name: str): Removes the product from the inventory if it exists. if product_name in self.products: del self.products[product_name] else: raise ValueError(f\\"Product \'{product_name}\' does not exist.\\") def update_quantity(self, product_name: str, quantity: int): Updates the quantity of the specified product. Raises ValueError if the product does not exist. if product_name in self.products: self.products[product_name] = quantity else: raise ValueError(f\\"Product \'{product_name}\' does not exist.\\") def list_products(self) -> dict: Returns the dictionary of products and their quantities. return self.products"},{"question":"# Question: Design a Stack That Supports Increment Operations Scenario You are developing a specialized stack implementation that, in addition to the standard push and pop operations, supports an \\"increment\\" operation. This stack allows you to add a certain value to the bottom `k` elements of the stack. Task Implement a class `CustomStack` with the following methods: 1. **`__init__(self, maxSize: int):`** * Initializes the stack with a given maximum size. 2. **`push(self, x: int) -> None:`** * Adds the element `x` to the top of the stack if the stack has not reached maxSize. 3. **`pop(self) -> int:`** * Removes and returns the element on the top of the stack. Returns `-1` if the stack is empty. 4. **`increment(self, k: int, val: int) -> None:`** * Increments the bottom `k` elements of the stack by `val`. If there are fewer than `k` elements in the stack, increment all the elements. Constraints * All operations should run in O(1) or O(k) time complexity. * The methods will be called as follows: * `stack = CustomStack(maxSize)` * `stack.push(x)` * `param_2 = stack.pop()` * `stack.increment(k, val)` Example ```python stack = CustomStack(3) stack.push(1) stack.push(2) print(stack.pop()) # returns 2 stack.push(2) stack.push(3) stack.push(4) stack.increment(5, 100) # stack becomes [101, 102, 103] stack.increment(2, 100) # stack becomes [201, 202, 103] print(stack.pop()) # returns 103 print(stack.pop()) # returns 202 print(stack.pop()) # returns 201 print(stack.pop()) # returns -1 (stack is empty) ```","solution":"class CustomStack: def __init__(self, maxSize: int): self.stack = [] self.maxSize = maxSize def push(self, x: int) -> None: if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self) -> int: if not self.stack: return -1 return self.stack.pop() def increment(self, k: int, val: int) -> None: for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"# Problem Statement You are given a list of dictionaries representing employees in a company. Each dictionary contains two keys: `name` and `salary`. Your task is to write a function `get_top_earner` that returns the name of the employee with the highest salary. If there are multiple employees with the same highest salary, return the name that appears first in the list. # Function Signature ```python def get_top_earner(employees: list) -> str: pass ``` # Input - `employees`: A list of dictionaries, where each dictionary has the following structure: - `name`: A string representing the employee\'s name. - `salary`: An integer representing the employee\'s salary (0 <= salary <= 10^6). # Output - A string representing the name of the employee with the highest salary. # Examples ```python assert get_top_earner([{\'name\': \'Alice\', \'salary\': 50000}, {\'name\': \'Bob\', \'salary\': 70000}, {\'name\': \'Charlie\', \'salary\': 70000}]) == \'Bob\' assert get_top_earner([{\'name\': \'Alice\', \'salary\': 50000}, {\'name\': \'Bob\', \'salary\': 50000}]) == \'Alice\' assert get_top_earner([{\'name\': \'Alice\', \'salary\': 100000}]) == \'Alice\' assert get_top_earner([]) == \'\' assert get_top_earner([{\'name\': \'Alice\', \'salary\': 0}]) == \'Alice\' ``` # Constraints - Ensure your solution handles the case where the list is empty; in such cases, return an empty string. - Assume that each dictionary in the list is well-formed and contains the \'name\' and \'salary\' keys with appropriate values. - Avoid using external libraries to solve this problem. # Notes - Consider how your approach can efficiently find the top earner without unnecessary computation. - Make sure to handle edge cases such as an empty list or all employees having the same salary correctly.","solution":"def get_top_earner(employees: list) -> str: if not employees: return \'\' top_earner = employees[0][\'name\'] max_salary = employees[0][\'salary\'] for employee in employees[1:]: if employee[\'salary\'] > max_salary: top_earner = employee[\'name\'] max_salary = employee[\'salary\'] return top_earner"},{"question":"**Greatest Common Divisor using Euclid\'s Algorithm** In this exercise, you are required to implement a function to calculate the Greatest Common Divisor (GCD) of two given non-negative integers. The GCD of two numbers is the largest number that divides both of them without leaving a remainder. To accomplish this task efficiently, you will use Euclid\'s algorithm. # Function Signature ```python def gcd(a: int, b: int) -> int: pass ``` # Input * `a` (int): A non-negative integer. * `b` (int): A non-negative integer. # Output * **Returns** (int): The GCD of the input numbers. * **Raises**: `ValueError` if either `a` or `b` is negative. # Constraints * The function should handle values up to at least `10^9`. * GCD computation should be efficient enough to process inputs in a reasonable timeframe. * You should use an iterative implementation of Euclid\'s algorithm for this task. # Examples ```python >>> gcd(54, 24) 6 >>> gcd(0, 0) 0 >>> gcd(10, 0) 10 >>> gcd(-4, 12) Traceback (most recent call last): ... ValueError: Inputs should be non-negative. >>> gcd(48, 18) 6 ``` # Guidelines 1. **Euclid\'s Algorithm**: The algorithm is based on the principle that the GCD of two numbers also divides their difference. It can be implemented iteratively by repeatedly applying the formula: `gcd(a, b) = gcd(b, a % b)` until `b` becomes 0. 2. **Input Handling**: Ensure your implementation properly handles edge cases, such as when either or both inputs are zero. **Tasks**: 1. Implement the `gcd` function based on the provided specifications. 2. Ensure your implementation handles special cases gracefully and efficiently.","solution":"def gcd(a: int, b: int) -> int: Returns the Greatest Common Divisor (GCD) of two non-negative integers using Euclid\'s Algorithm. :param a: a non-negative integer :param b: a non-negative integer :return: the GCD of a and b :raises ValueError: if either a or b is negative if a < 0 or b < 0: raise ValueError(\\"Inputs should be non-negative.\\") while b != 0: a, b = b, a % b return a"},{"question":"# Binary Search Tree (BST) Reconstruction **Scenario**: As a data scientist in a tech company, you work with data sets that require restructuring and verification processes. One essential task is to reconstruct Binary Search Trees (BSTs) from given traversal orders. BSTs are fundamental for various operations like searching, sorting, and in-memory database indexing. Your task is crucial for ensuring data integrity and facilitating efficient data retrieval. **Task**: Implement a function `reconstruct_bst` that reconstructs a BST from its given preorder traversal and validates the reconstruction against the properties of BST. **Specifications**: * You will write a function `reconstruct_bst(preorder: List[int]) -> TreeNode`. * `preorder`: A list of integer values representing the preorder traversal sequence of the BST. * You are provided with a class definition for `TreeNode` as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Constraints**: * The input list contains unique values and represents a valid preorder traversal of a BST. * The function should handle edge cases like an empty list, where it should return `None`. **Expected Output**: * Return the root node of the reconstructed BST. **Examples**: ```python # Example 1: Simple BST reconstruction preorder = [8, 5, 1, 7, 10, 12] root = reconstruct_bst(preorder) # Expected: A BST where root.val = 8, root.left.val = 5, and so on # Example 2: A single node tree preorder = [1] root = reconstruct_bst(preorder) # Expected: A BST where root.val = 1 and both children are None # Example 3: Empty input preorder = [] root = reconstruct_bst(preorder) # Expected: None ``` Implement the `reconstruct_bst` function to meet these requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reconstruct_bst(preorder): if not preorder: return None # Helper function to insert a value into the BST def insert_into_bst(root, val): if not root: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root root = TreeNode(preorder[0]) for val in preorder[1:]: insert_into_bst(root, val) return root"},{"question":"Coding Assessment Question # Objective Implement a function that performs k-means clustering on a set of data points in a 2D plane. This will test your understanding of clustering algorithms and your prowess with numerical operations. # Problem Statement You are given a set of data points in a 2D plane represented as a list of tuples, where each tuple contains the x and y coordinates of a point. Your task is to write a function `k_means_clustering` that performs the k-means clustering algorithm to group the points into `k` clusters. # Requirements 1. **Function Signature**: ```python def k_means_clustering(points: list[tuple[float, float]], k: int, num_iter: int) -> list[int]: ``` 2. **Input Format**: - `points` (list of tuples): A list of tuples representing the data points in the 2D space. Each tuple contains the x and y coordinates (e.g., [(x1, y1), (x2, y2), ...]). - `k` (int): The number of clusters to form. - `num_iter` (int): The number of iterations for the k-means algorithm. 3. **Output Format**: - Returns a list of integers where each integer represents the cluster assignment for the corresponding point in the input list. 4. **Constraints**: - Each tuple in `points` will have two float values representing the x and y coordinates. - The number of points, `len(points)`, will satisfy 1 ≤ len(points) ≤ 1000. - The number of clusters `k` will be a positive integer less than or equal to the number of points (1 ≤ k ≤ len(points)). - The number of iterations `num_iter` will be a positive integer (1 ≤ num_iter ≤ 100). # Additional Notes 1. Initially, randomly select `k` points from the dataset as the initial centroids. 2. During each iteration, assign each point to the nearest centroid. 3. Compute new centroids based on the mean of the points assigned to each cluster. 4. Continue this process for the specified number of iterations. # Example ```python points = [(1.0, 2.0), (2.0, 3.0), (5.0, 5.0), (8.0, 8.0), (1.5, 1.8), (6.0, 6.5), (8.5, 9.0)] k = 2 num_iter = 3 cluster_assignments = k_means_clustering(points, k, num_iter) print(\\"Cluster Assignments:\\", cluster_assignments) ``` In the above code snippet, the function `k_means_clustering` takes a list of 2D points, the number of clusters `k`, and the number of iterations as input. The output is a list of integers representing the cluster assignment for each point in the input list.","solution":"import random from typing import List, Tuple def k_means_clustering(points: List[Tuple[float, float]], k: int, num_iter: int) -> List[int]: def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5 def get_new_centroids(clusters: List[List[Tuple[float, float]]]) -> List[Tuple[float, float]]: new_centroids = [] for cluster in clusters: if cluster: mean_x = sum([point[0] for point in cluster]) / len(cluster) mean_y = sum([point[1] for point in cluster]) / len(cluster) new_centroids.append((mean_x, mean_y)) else: # If a cluster is empty, append a random point as new centroid new_centroids.append(random.choice(points)) return new_centroids def assign_points_to_clusters(points: List[Tuple[float, float]], centroids: List[Tuple[float, float]]) -> List[List[Tuple[float, float]]]: clusters = [[] for _ in range(k)] for point in points: min_distance = float(\\"inf\\") cluster_index = 0 for i, centroid in enumerate(centroids): distance = euclidean_distance(point, centroid) if distance < min_distance: min_distance = distance cluster_index = i clusters[cluster_index].append(point) return clusters # Step 1: Initialize centroids centroids = random.sample(points, k) for _ in range(num_iter): # Step 2: Assign points to the nearest centroid clusters = assign_points_to_clusters(points, centroids) # Step 3: Calculate new centroids centroids = get_new_centroids(clusters) # Final assignment of points to clusters, after num_iter iterations final_clusters = [0] * len(points) final_clusters_list = assign_points_to_clusters(points, centroids) for cluster_index, cluster in enumerate(final_clusters_list): for point in cluster: final_clusters[points.index(point)] = cluster_index return final_clusters"},{"question":"# Question: Optimizing a Simple Genetic Algorithm for Function Minimization Context You have been provided with a simple Genetic Algorithm (GA) framework to find the minimum value of a given mathematical function f(x). Your task is to optimize this GA by implementing crucial components and adjusting key parameters. Task 1. Implement the following methods in the `GeneticAlgorithm` class: - A `selection()` method that uses roulette wheel selection to choose parents. - A `crossover()` method that performs one-point crossover on parent pairs. - A `mutation()` method that mutates an individual\'s genes with a given probability. 2. Tune the GA parameters for effective performance on the function f(x) = x^2 - 4x + 4. Requirements * **Algorithm Specification**: - Population size: 20 individuals. - Number of generations: 50. - Mutation probability: 0.01. - Gene values: binary representation of the individual. * **Input/Output**: - The GA will start with a random initial population. - The function to be minimized is given and its minimum value should be approached through generations. * **Performance**: - The GA should converge to the minimum value of the function efficiently. - Parameters should be tuned to ensure quick convergence and diversity maintenance. # Example ```python import random def f(x: float) -> float: return x ** 2 - 4 * x + 4 class GeneticAlgorithm: def __init__(self, pop_size: int, num_generations: int, mutation_prob: float): self.pop_size = pop_size self.num_generations = num_generations self.mutation_prob = mutation_prob self.population = self._initialize_population() def _initialize_population(self) -> list: return [random.uniform(-10, 10) for _ in range(self.pop_size)] def selection(self) -> tuple: weights = [1 / (f(ind) + 1) for ind in self.population] parents = random.choices(self.population, weights, k=2) return parents def crossover(self, parent1: float, parent2: float) -> tuple: alpha = random.random() child1 = alpha * parent1 + (1 - alpha) * parent2 child2 = alpha * parent2 + (1 - alpha) * parent1 return child1, child2 def mutation(self, individual: float) -> float: if random.random() < self.mutation_prob: return individual + random.uniform(-1, 1) return individual def run(self) -> float: for _ in range(self.num_generations): new_population = [] for _ in range(self.pop_size // 2): parent1, parent2 = self.selection() child1, child2 = self.crossover(parent1, parent2) child1 = self.mutation(child1) child2 = self.mutation(child2) new_population.extend([child1, child2]) self.population = new_population best_individual = min(self.population, key=f) return best_individual # Initialize and optimize the genetic algorithm ga = GeneticAlgorithm(pop_size=20, num_generations=50, mutation_prob=0.01) best_solution = ga.run() print(f\\"The best solution found is: {best_solution:.4f}, with value: {f(best_solution):.4f}\\") ```","solution":"import random def f(x: float) -> float: return x ** 2 - 4 * x + 4 class GeneticAlgorithm: def __init__(self, pop_size: int, num_generations: int, mutation_prob: float): self.pop_size = pop_size self.num_generations = num_generations self.mutation_prob = mutation_prob self.population = self._initialize_population() def _initialize_population(self) -> list: return [random.uniform(-10, 10) for _ in range(self.pop_size)] def selection(self) -> tuple: total_fitness = sum(1 / (f(ind) + 1) for ind in self.population) probabilities = [(1 / (f(ind) + 1)) / total_fitness for ind in self.population] parents = random.choices(self.population, probabilities, k=2) return parents def crossover(self, parent1: float, parent2: float) -> tuple: alpha = random.random() child1 = alpha * parent1 + (1 - alpha) * parent2 child2 = alpha * parent2 + (1 - alpha) * parent1 return child1, child2 def mutation(self, individual: float) -> float: if random.random() < self.mutation_prob: return individual + random.uniform(-1, 1) return individual def run(self) -> float: for _ in range(self.num_generations): new_population = [] for _ in range(self.pop_size // 2): parent1, parent2 = self.selection() child1, child2 = self.crossover(parent1, parent2) child1 = self.mutation(child1) child2 = self.mutation(child2) new_population.extend([child1, child2]) self.population = new_population best_individual = min(self.population, key=f) return best_individual"},{"question":"**Context:** You are developing a feature for a numerical analysis application that identifies prime factors of given numbers. Prime factorization can be crucial for various computational problems, from cryptography to number theory. **Objective:** Write a program that performs prime factorization on a list of integers. Your solution should use efficient algorithms to determine the prime factors for each number and return the results. **Task:** Create a function `prime_factors_of_numbers(numbers: list[int]) -> list[list[int]]` that takes a list of integers and returns a list of lists. Each sublist should contain the prime factors of the corresponding integer in the input list, sorted in ascending order. # Expected Input and Output: * **Input**: - `numbers`: A list of integers. - Each integer will be a positive number greater than or equal to 2 and up to 100,000. * **Output**: - A list of lists, where each sublist contains the prime factors of the given integer, sorted in ascending order. # Constraints: - The implementation should be efficient, leveraging optimized algorithms for prime factorization. - Consider edge cases such as repeated factors and the smallest primes. **Example:** ```python numbers = [ 10, # Prime factors: [2, 5] 11, # Prime factors: [11] 28, # Prime factors: [2, 2, 7] 625, # Prime factors: [5, 5, 5, 5] ] assert prime_factors_of_numbers(numbers) == [ [2, 5], [11], [2, 2, 7], [5, 5, 5, 5], ] ```","solution":"def prime_factors_of_numbers(numbers): def prime_factors(n): i = 2 factors = [] while i * i <= n: while (n % i) == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) return factors return [prime_factors(num) for num in numbers]"},{"question":"# Context String manipulation and validation are common tasks in programming. Ensuring that a string follows specific rules or formats is an essential skill, especially in applications involving data input and processing. You are required to implement a function that validates a given email address based on a set of predefined rules. # Problem You are required to implement a function `validate_email(email: str) -> bool` that takes a string as input and returns `True` if the email is valid according to the following rules, otherwise `False`: # Email Validation Rules 1. The email must contain exactly one \'@\' symbol. 2. The local part (the part before \'@\') must: - Be non-empty. - Consist only of alphanumeric characters (a-z, A-Z, 0-9) and periods (\'.\'). - Not start or end with a period. - Not contain consecutive periods. 3. The domain part (the part after \'@\') must: - Be non-empty. - Consist only of alphanumeric characters. - Contain at least one period \'.\' that separates the domain name and the top-level domain (e.g., \'example.com\'). # Function Signature ```python def validate_email(email: str) -> bool: ``` # Example ```python >>> validate_email(\\"user.name@example.com\\") True >>> validate_email(\\"user..name@example.com\\") False >>> validate_email(\\".username@example.com\\") False >>> validate_email(\\"username@examplecom\\") False >>> validate_email(\\"username@.com\\") False >>> validate_email(\\"username@example.\\") False >>> validate_email(\\"username@\\") False >>> validate_email(\\"username@domain.com\\") True ``` # Constraints 1. The input string will have at most 100 characters. 2. The input string can contain any ASCII characters. # Notes - The implementation should handle edge cases like leading/trailing periods and multiple \'@\' symbols. - Ensure the code is clean, efficient, and easy to understand.","solution":"import re def validate_email(email: str) -> bool: Validates the given email based on specific rules. # Email must contain exactly one \'@\' symbol if email.count(\'@\') != 1: return False local, domain = email.split(\'@\') # Validate local part if not local or local[0] == \'.\' or local[-1] == \'.\' or \'..\' in local: return False if not re.match(r\'^[a-zA-Z0-9.]+\', local): return False # Validate domain part if not domain or \'.\' not in domain: return False if not re.match(r\'^[a-zA-Z0-9.]+\', domain) or domain[0] == \'.\' or domain[-1] == \'.\': return False return True"},{"question":"# Problem Statement You are required to implement a function that determines the longest subsequence of characters in a given string such that every character in the subsequence appears in increasing alphabetical order. The subsequence does not have to be contiguous within the original string. Write a function `longest_increasing_subsequence` that returns the longest increasing alphabetical subsequence from the input string. Function Signature ```python def longest_increasing_subsequence(text: str) -> str: pass ``` # Input * `text` (str): The input string from which to find the longest increasing alphabetical subsequence. The text will consist of lower-case English letters. # Output * (str): The longest increasing alphabetical subsequence. # Constraints * The length of the `text` will not exceed `10^5` characters. # Example ```python print(longest_increasing_subsequence(\'abcbdab\')) # Output: \'abcd\' print(longest_increasing_subsequence(\'zyxwv\')) # Output: \'z\' print(longest_increasing_subsequence(\'abcdz\')) # Output: \'abcdz\' ``` # Note * If there are multiple valid subsequences of the same length, any of them can be returned. * Uppercase and special characters do not appear in the input. **Performance Requirements**: The implemented function should be able to handle large input sizes efficiently, aiming for a time complexity close to O(n), where n is the length of the input text.","solution":"def longest_increasing_subsequence(text: str) -> str: Returns the longest increasing alphabetical subsequence from the input string. if not text: return \'\' # Initialize the longest increasing subsequence lis = [] for char in text: # If the character is greater than the last character in the LIS, append it if not lis or char > lis[-1]: lis.append(char) return \'\'.join(lis)"},{"question":"# Tic-Tac-Toe Outcome Checker Objective Create a function to determine the outcome of a given Tic-Tac-Toe game board. The outcome can be a win for a player (either \'X\' or \'O\'), a draw, or an unfinished game. Problem Scenario Tic-Tac-Toe is a simple game played on a 3x3 grid. There are two players, each taking turns to place their respective markers (\'X\' or \'O\') on the grid. The game ends when one player gets three of their markers in a row, column, or diagonal, or when there are no more empty cells on the grid. Task Write a function `tic_tac_toe_outcome(board)` that determines the outcome of the game based on the current state of the `board`. Function Signature ```python def tic_tac_toe_outcome(board: List[List[str]]) -> str: pass ``` Input * `board`: a 3x3 list of lists representing the Tic-Tac-Toe grid, where each element is either \'X\', \'O\', or \'\' (an empty string). Output * Returns a string indicating the outcome of the game. Possible returns are: - \'X wins\' - \'O wins\' - \'Draw\' - \'Unfinished\' Constraints * The board will always be a 3x3 grid. * Each cell will contain either \'X\', \'O\', or \'\'. Examples ```python board1 = [[\'X\', \'O\', \'X\'], [\'X\', \'X\', \'O\'], [\'O\', \'\', \'O\']] print(tic_tac_toe_outcome(board1)) # Should print: \'Unfinished\' board2 = [[\'X\', \'X\', \'X\'], [\'O\', \'O\', \'\'], [\'\', \'\', \'\']] print(tic_tac_toe_outcome(board2)) # Should print: \'X wins\' board3 = [[\'X\', \'O\', \'X\'], [\'O\', \'O\', \'X\'], [\'X\', \'X\', \'O\']] print(tic_tac_toe_outcome(board3)) # Should print: \'Draw\' ``` Constraints & Edge Cases * Consider the case where there are still empty cells but there\'s a winner. * Ensure correct detection of wins by checking all rows, columns, and diagonals. * Handle the case where the board is full but there\'s no winner, which should return \'Draw\'. * If neither player has won and there are still empty cells, return \'Unfinished\'. Good luck!","solution":"from typing import List def tic_tac_toe_outcome(board: List[List[str]]) -> str: def check_winner(marker): # Check rows and columns for i in range(3): if all([cell == marker for cell in board[i]]) or all([board[j][i] == marker for j in range(3)]): return True # Check diagonals if all([board[i][i] == marker for i in range(3)]) or all([board[i][2-i] == marker for i in range(3)]): return True return False if check_winner(\'X\'): return \'X wins\' if check_winner(\'O\'): return \'O wins\' # Check for empty cells if any(cell == \'\' for row in board for cell in row): return \'Unfinished\' return \'Draw\'"},{"question":"Task: [Question 2]: **Course Prerequisite Checker** In a university course registration system, each course has a set of pre-requisite courses that need to be completed before enrolling in that particular course. These prerequisites form a directed acyclic graph (DAG), where each node represents a course, and each directed edge represents a prerequisite requirement. Write a function `can_enroll` that takes in two arguments: a list of tuples representing prerequisite pairs and the target course. The function should determine whether it’s possible to enroll in the target course given the prerequisite structure. The function should return `True` if the target course is reachable (i.e., can be enrolled in), and `False` otherwise. # Function Signature ```python def can_enroll(prerequisites: list[tuple[str, str]], target_course: str) -> bool: ``` # Input - `prerequisites`: A list of tuples where each tuple contains two strings representing a prerequisite relationship `(course, prerequisite)`. For example, `(\'AdvancedAlgorithms\', \'DataStructures\')` indicates that \'DataStructures\' must be completed before \'AdvancedAlgorithms\'. - `target_course`: A string representing the course for which we want to check enrollment eligibility. # Output - Returns a boolean value — `True` if it is possible to enroll in the `target_course`, otherwise `False`. # Constraints - The length of `prerequisites` list will be between 1 and 100. - No course will have a self-dependence (e.g., `(\'course\', \'course\')`). - There will be no circular dependencies in the prerequisites (the prerequisite graph is a DAG). # Example ```python >>> can_enroll([(\'AdvancedAlgorithms\', \'DataStructures\'), (\'DataStructures\', \'ProgrammingBasics\')], \'AdvancedAlgorithms\') True >>> can_enroll([(\'MachineLearning\', \'LinearAlgebra\'), (\'LinearAlgebra\', \'Calculus\'), (\'Calculus\', \'Algebra\')], \'ArtificialIntelligence\') False ``` # Notes - You may use topological sorting or any other feasible graph traversal algorithms to determine if the target course is reachable. - Ensure to validate input and handle potential errors gracefully.","solution":"def can_enroll(prerequisites, target_course): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) indegree = defaultdict(int) all_courses = set() for course, prereq in prerequisites: graph[prereq].append(course) indegree[course] += 1 all_courses.add(course) all_courses.add(prereq) # Initialize queue with courses having zero indegree (i.e., no prerequisites) queue = deque([c for c in all_courses if indegree[c] == 0]) visited = set(queue) # Process the graph while queue: course = queue.popleft() for next_course in graph[course]: indegree[next_course] -= 1 if indegree[next_course] == 0: if next_course not in visited: queue.append(next_course) visited.add(next_course) # Check if target course is in visited set return target_course in visited"},{"question":"# Question: Implement and Optimize Quick Sort You are provided with an implementation of the Quick Sort algorithm. Your task is to optimize the given algorithm to improve its performance using a hybrid approach. Specifically, modify the Quick Sort to switch to a more efficient sorting algorithm for small subarrays. # Implementation Details: - **Function Signature**: `def quick_sort_optimized(arr: list[int]) -> list[int]:` - **Input**: - `arr`: A list of integers to be sorted. - **Output**: - A new list containing the elements from `arr` sorted in non-decreasing order. - **Constraints**: - The array can contain up to (10^5) elements. - You can assume the elements are in the range of (-10^9) to (10^9). # Requirements: 1. Switch to Insertion Sort for subarrays with size <= 10. 2. Implement the optimization to choose a better pivot (e.g., median-of-three). 3. Ensure the final result is a stable sort if applicable. 4. The function must handle all edge cases properly. # Example: ```python def quick_sort_optimized(arr: list[int]) -> list[int]: pass # Example Test Cases assert quick_sort_optimized([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert quick_sort_optimized([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert quick_sort_optimized([10, 22, 1, 2, 3, 9, 15, 23]) == [1, 2, 3, 9, 10, 15, 22, 23] assert quick_sort_optimized([100]) == [100] assert quick_sort_optimized([]) == [] ``` Note: Ensure that the function is thoroughly tested with different edge cases and adheres to the switching condition between Quick Sort and Insertion Sort effectively.","solution":"def quick_sort_optimized(arr: list[int]) -> list[int]: Optimized Quick Sort implementation that switches to Insertion Sort for small subarrays and uses the median-of-three method for pivot selection. def insertion_sort(subarray): for i in range(1, len(subarray)): key = subarray[i] j = i - 1 while j >= 0 and subarray[j] > key: subarray[j + 1] = subarray[j] j -= 1 subarray[j + 1] = key return subarray def median_of_three(a, b, c): # Returns the median value of the three values. return sorted([a, b, c])[1] def quick_sort_internal(array, low, high): if high - low <= 10: array[low:high+1] = insertion_sort(array[low:high+1]) return if low < high: pivot_index = partition(array, low, high) quick_sort_internal(array, low, pivot_index - 1) quick_sort_internal(array, pivot_index + 1, high) def partition(array, low, high): mid = (low + high) // 2 pivot = median_of_three(array[low], array[mid], array[high]) pivot_index = array.index(pivot) array[pivot_index], array[high] = array[high], array[pivot_index] pivot = array[high] i = low - 1 for j in range(low, high): if array[j] <= pivot: i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1 result = arr[:] quick_sort_internal(result, 0, len(result) - 1) return result"},{"question":"# Coding Assessment Question Scenario: You are working on a text processing application that needs to summarize texts by extracting unique words and sorting them alphabetically. To achieve this, your task is to create a function that takes a string of text and returns a sorted list of unique words. Problem Statement: Write a function `extract_unique_words(text: str) -> List[str]` to extract and sort unique words from a given string. Input: * A string `text` containing words separated by spaces. Words may include various punctuation and case variations. Output: * A list of unique words sorted alphabetically. The words should be in lowercase and should exclude any punctuation. Constraints: * The input string may contain up to 10,000 characters. * Words are delimited by spaces. * Words may contain punctuation such as periods, commas, exclamations, etc. Examples: * For `text = \\"Hello, world! Hello everyone.\\"`, the function should return: ``` [\'everyone\', \'hello\', \'world\'] ``` * For `text = \\"This is a test. This is only a test.\\"`, the function should return: ``` [\'a\', \'is\', \'only\', \'test\', \'this\'] ``` # Implementation Notes: * The function `extract_unique_words` should handle punctuation by removing it from the words before processing. * The function should convert all words to lowercase to ensure uniqueness. * Efficiently handle the extraction and sorting process to cater to the upper limit of input size. Write your implementation below: ```python import re from typing import List def extract_unique_words(text: str) -> List[str]: # Use regex to remove punctuation and split by spaces words = re.findall(r\'bw+b\', text.lower()) # Create a set to store unique words unique_words = set(words) # Return the sorted list of unique words return sorted(unique_words) # Function call for illustration if __name__ == \\"__main__\\": print(extract_unique_words(\\"Hello, world! Hello everyone.\\")) print(extract_unique_words(\\"This is a test. This is only a test.\\")) print(extract_unique_words(\\"\\")) ```","solution":"import re from typing import List def extract_unique_words(text: str) -> List[str]: Extracts unique words from the input text, converts them to lowercase, removes punctuation, and returns them sorted alphabetically. # Use regex to remove punctuation and split by spaces words = re.findall(r\'bw+b\', text.lower()) # Create a set to store unique words unique_words = set(words) # Return the sorted list of unique words return sorted(unique_words)"},{"question":"# Coding Assessment Question: Custom XOR Encryption and Decryption You\'ve recently learned about basic encryption techniques and XOR operations in computer science. Now, your task is to apply this knowledge in creating a custom encryption-decryption algorithm using the XOR operation. Scenario You are working on a lightweight encryption protocol that exchanges messages securely between clients over an insecure network. To ensure efficiency and simplicity, you\'ve decided to use a custom XOR-based encryption algorithm. The communication protocol requires that both encryption and decryption are implemented. Task Implement two functions: `custom_xor_encrypt(message: bytes, key: bytes) -> bytes` and `custom_xor_decrypt(encrypted_message: bytes, key: bytes) -> bytes`. These functions should use XOR to encrypt and decrypt the message with a given key. Specifications 1. **Input and Output Formats**: * `custom_xor_encrypt(message: bytes, key: bytes) -> bytes`: Takes a byte string of the original message and a byte string key, and returns the encrypted byte string. * `custom_xor_decrypt(encrypted_message: bytes, key: bytes) -> bytes`: Takes an encrypted byte string and a byte string key, and returns the decrypted original message as bytes. 2. **Constraints and Limitations**: * The input message and key can be of any length. For simplicity, if the message is longer than the key, the key should be repeated to match the message length. * The same key must be used for both encryption and decryption. 3. **Edge Cases**: * Handle empty input for both functions. * Ensure the functions correctly handle messages where the message length is not a multiple of the key length. 4. **Performance Requirements**: * Ensure the implementation runs efficiently within O(n) time complexity where n is the length of the input data for both encryption and decryption. Examples ```python # Example cases assert custom_xor_encrypt(b\\"\\", b\\"key\\") == b\\"\\" assert custom_xor_encrypt(b\\"hello\\", b\\"key\\") != b\\"hello\\" # Ensure encryption and decryption are consistent message = b\\"this is a secret message\\" key = b\\"mykey\\" encrypted_message = custom_xor_encrypt(message, key) assert custom_xor_decrypt(encrypted_message, key) == message # Handle key repetition correctly assert custom_xor_encrypt(b\\"longer message\\", b\\"key\\") != b\\"longer message\\" assert custom_xor_decrypt(custom_xor_encrypt(b\\"longer message\\", b\\"key\\"), b\\"key\\") == b\\"longer message\\" # Edge case with empty message and key assert custom_xor_encrypt(b\\"\\", b\\"\\") == b\\"\\" assert custom_xor_decrypt(b\\"\\", b\\"\\") == b\\"\\" ``` Implement the custom_xor_encrypt and custom_xor_decrypt functions ensuring compliance with the aforementioned requirements.","solution":"def custom_xor_encrypt(message: bytes, key: bytes) -> bytes: Encrypts the message using XOR with the provided key. if not key: return message encrypted_message = bytearray() key_length = len(key) for i, byte in enumerate(message): encrypted_message.append(byte ^ key[i % key_length]) return bytes(encrypted_message) def custom_xor_decrypt(encrypted_message: bytes, key: bytes) -> bytes: Decrypts the message that was encrypted using XOR with the provided key. # Since XOR encryption is symmetric, decryption is the same as encryption return custom_xor_encrypt(encrypted_message, key)"},{"question":"Weather Data Analysis and Forecasting You are tasked with analyzing a weather dataset and implementing a machine learning model to forecast future temperatures. The dataset contains past weather data with multiple features such as temperature, humidity, wind speed, and more. You will need to preprocess the data, train a machine learning model, and evaluate its performance. Function Specifications 1. **data_preprocessing(data: pd.DataFrame) -> tuple**: - **Input**: A pandas DataFrame containing historical weather data with various features including a \'temperature\' column. - **Output**: A tuple containing preprocessed features and target variables (temperature). 2. **train_model(features: np.ndarray, target: np.ndarray, model_type:str, params: dict) -> object**: - **Input**: - `features`: numpy array of shape `(n_samples, n_features)` containing the feature data. - `target`: numpy array of shape `(n_samples,)` containing the temperature values. - `model_type`: String specifying the type of model to be trained (e.g., \'linear_regression\', \'random_forest\'). - `params`: Dictionary of hyperparameters for the model. - **Output**: Trained machine learning model. 3. **evaluate_model(model: object, features: np.ndarray, target: np.ndarray) -> float**: - **Input**: - `model`: Trained machine learning model. - `features`: numpy array of shape `(n_samples, n_features)`. - `target`: numpy array of shape `(n_samples,)`. - **Output**: Mean absolute error of the model’s predictions. 4. **forecast_future_temperatures(model: object, future_features: np.ndarray) -> np.ndarray**: - **Input**: - `model`: Trained machine learning model. - `future_features`: numpy array of shape `(n_future_samples, n_features)` containing future feature data. - **Output**: Numpy array of predicted future temperatures. Additional Requirements - The `data_preprocessing` function should handle missing values, normalize/standardize the data, and create appropriate feature-target splits. - The `train_model` function should support training at least two types of models: Linear Regression and Random Forest. Hyperparameters specific to each model type should be handled in `params`. - Utilize cross-validation in the `evaluate_model` function to provide a robust evaluation metric. - Provide examples of usage for training, evaluating, and forecasting. # Example ```python # Expected usage example: import numpy as np import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.ensemble import RandomForestRegressor # Load weather dataset weather_data = pd.read_csv(\'weather_data.csv\') # Process data features, targets = data_preprocessing(weather_data) # Split data into training and test sets x_train, x_test, y_train, y_test = train_test_split(features, targets, test_size=0.2, random_state=42) # Define initial hyperparameters for RandomForest params = {\'n_estimators\': 100, \'max_depth\': 10} # Train the model model = train_model(x_train, y_train, \\"random_forest\\", params) # Evaluate model mae = evaluate_model(model, x_test, y_test) print(f\'Model Mean Absolute Error: {mae:.2f}\') # Forecast future temperatures future_weather_data = pd.read_csv(\'future_weather_data.csv\') future_features = data_preprocessing(future_weather_data)[0] # Preprocess future data predicted_temperatures = forecast_future_temperatures(model, future_features) print(f\'Predicted Future Temperatures: {predicted_temperatures}\') ``` # Constraints - Assume the dataset is a CSV file with a \'temperature\' column among other weather features. - Your solution should handle real-world data issues such as missing values and scaling of features. - Write clean, readable, and well-documented code. # Bonus - Implement feature engineering to create new features that could potentially improve the model\'s performance. - Visualize the original and predicted temperature series to provide insights into the model\'s accuracy.","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split, cross_val_score from sklearn.linear_model import LinearRegression from sklearn.ensemble import RandomForestRegressor from sklearn.preprocessing import StandardScaler from sklearn.metrics import mean_absolute_error from sklearn.impute import SimpleImputer def data_preprocessing(data): Handle missing values, normalize/standardize the data, and create appropriate feature-target splits. # Handle missing values by imputing with mean imputer = SimpleImputer(strategy=\'mean\') data_imputed = pd.DataFrame(imputer.fit_transform(data), columns=data.columns) # Separate features and target variable features = data_imputed.drop(columns=[\\"temperature\\"]) target = data_imputed[\\"temperature\\"] # Standardize the features scaler = StandardScaler() features_scaled = scaler.fit_transform(features) return features_scaled, target def train_model(features, target, model_type, params): Train a machine learning model based on the specified type with given parameters. if model_type == \\"linear_regression\\": model = LinearRegression(**params) elif model_type == \\"random_forest\\": model = RandomForestRegressor(**params) else: raise ValueError(\\"Unsupported model type\\") model.fit(features, target) return model def evaluate_model(model, features, target): Evaluate the model\'s performance using cross-validation and return the mean absolute error. predictions = model.predict(features) mae = mean_absolute_error(target, predictions) return mae def forecast_future_temperatures(model, future_features): Forecast future temperatures using the trained model. future_predictions = model.predict(future_features) return future_predictions"},{"question":"# Question: Implement Merge Sort for Linked Lists Problem Statement Your task is to implement the merge sort algorithm for sorting a singly linked list. Merge sort is a divide and conquer algorithm that splits the list into halves, recursively sorts each half, and then merges the sorted halves. You need to define the `ListNode` class that represents the nodes of the linked list, and a function `merge_sort` that takes the head of the linked list and returns the head of the sorted linked list. Input and Output * **Input**: A singly linked list `head` where each node contains an integer value. * **Output**: The head of the singly linked list sorted in ascending order. Constraints 1. The linked list can contain up to 10,000 nodes. 2. The values stored in the nodes are integers and can be negative or positive, ranging from (-10^9) to (10^9). 3. The implementation should have an average time complexity of (O(n log n)) and use O(log n) auxiliary space for recursion stack. Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sort(head: ListNode) -> ListNode: pass # Implement the merge sort algorithm for linked list here def print_linked_list(head: ListNode): while head: print(head.val, end=\\" -> \\") head = head.next print(\\"None\\") # Example usage if __name__ == \\"__main__\\": # Creating linked list 4 -> 2 -> 1 -> 3 node1 = ListNode(4) node2 = ListNode(2) node3 = ListNode(1) node4 = ListNode(3) node1.next = node2 node2.next = node3 node3.next = node4 sorted_head = merge_sort(node1) print_linked_list(sorted_head) # Expected output: 1 -> 2 -> 3 -> 4 -> None ``` Important Notes - You should handle edge cases such as an empty list (where head is `None`) or a list with only one node. - The merge function should efficiently combine two sorted sublists into one sorted list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sort(head: ListNode) -> ListNode: if not head or not head.next: return head def find_middle(head): slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow # Split list into two halves middle = find_middle(head) next_to_middle = middle.next middle.next = None # Recursively sort each half left = merge_sort(head) right = merge_sort(next_to_middle) # Merge the sorted halves return merge(left, right) def merge(left, right): dummy = ListNode(0) tail = dummy while left and right: if left.val <= right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next # Attach the remaining elements if left: tail.next = left if right: tail.next = right return dummy.next"},{"question":"# Problem Statement You are working on a cybersecurity project to develop an encryption system. One of the fundamental tasks is to transpose a given text by shifting each character by a certain number of positions in the alphabet. This is known as the Caesar Cipher. Write a Python function `caesar_cipher` that takes a string and an integer and returns the encrypted version of the string by shifting each letter by the given integer value in the alphabet. The encryption should be case-sensitive and preserve the case of each letter. Non-alphabet characters should remain unchanged. # Input Format - A string `text`, which represents the input text to be encrypted. - An integer `shift`, which represents the number of positions by which to shift each letter (1 ≤ |shift| ≤ 25). # Output Format - A single string representing the encrypted text. # Constraints - The input string `text` length will be between 1 and 1000 characters. - The shift value will be an integer between -25 and 25 (inclusive). # Example ```python # Example 1 text = \\"Hello, World!\\" shift = 3 print(caesar_cipher(text, shift)) # Output: \\"Khoor, Zruog!\\" # Example 2 text = \\"abcdef\\" shift = 1 print(caesar_cipher(text, shift)) # Output: \\"bcdefg\\" # Example 3 text = \\"XYZ\\" shift = 2 print(caesar_cipher(text, shift)) # Output: \\"ZAB\\" # Example 4 text = \\"Python 101\\" shift = -3 print(caesar_cipher(text, shift)) # Output: \\"Mupqhk 101\\" ``` # Implementation Below is the provided code snippet for the function definition: ```python def caesar_cipher(text: str, shift: int) -> str: Encrypt the given text using the Caesar Cipher technique. result = [] for char in text: if char.isupper(): result.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) elif char.islower(): result.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) else: result.append(char) return \'\'.join(result) ``` Your task is to write the function `caesar_cipher` as specified above, ensuring the correct handling of shift values and preserving the case sensitivity of the input text.","solution":"def caesar_cipher(text: str, shift: int) -> str: Encrypt the given text using the Caesar Cipher technique. Parameters: text (str): the input text to be encrypted. shift (int): the shift number (1 ≤ |shift| ≤ 25). Returns: str: the encrypted text. result = [] for char in text: if char.isupper(): result.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) elif char.islower(): result.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) else: result.append(char) return \'\'.join(result)"},{"question":"# Coding Assessment Question: Group Anagrams You are given a list of strings. Your task is to group the strings that are anagrams of each other. Two strings are anagrams if they can be formed by rearranging the letters of each other. Write a Python function `group_anagrams` that groups the anagrams together. Function Signature ```python def group_anagrams(strs: List[str]) -> List[List[str]]: ``` Input - `strs`: A list of strings (0 <= len(strs) <= 10^4, len(strs[i]) <= 100) Output - A list of lists, where each sublist contains strings that are anagrams of each other. Example ```python assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\",\\"tea\\",\\"ate\\"],[\\"tan\\",\\"nat\\"],[\\"bat\\"]] assert group_anagrams([\\"\\"]) == [[\\"\\"]] assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] ``` Constraints 1. If the input list is empty, the return should be an empty list. 2. Each string consists of lowercase English letters. Scenario You are developing a system to detect duplicate messages. To reduce storage, you want to group messages that are anagrams of each other, as they convey the same information. By efficiently grouping these anagrams, you can improve your system\'s performance and data handling capabilities.","solution":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. anagram_map = defaultdict(list) for s in strs: # Sort the string to get the anagram key key = \'\'.join(sorted(s)) anagram_map[key].append(s) # Return all the grouped anagrams as a list of lists return list(anagram_map.values())"},{"question":"# Question: Implement a BFS-based Path Finder in a Grid In a given rectangular grid, you are required to find the shortest path from a start position to an end position following the rules of Breadth-First Search (BFS). The grid is represented as a 2D list of integers, where `0` represents a walkable cell and `1` represents a wall that cannot be traversed. Function Signature ```python def bfs_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: # your code here ``` Input - `grid` (List[List[int]]): A 2D list representing the grid. - `start` (Tuple[int, int]): A tuple representing the starting position in the grid (row, col). - `end` (Tuple[int, int]): A tuple representing the ending position in the grid (row, col). Output - (int): The length of the shortest path from start to end, or `-1` if no path exists. Constraints - The maximum size of the grid is 1000x1000. - The start and end positions are within the bounds of the grid. - The start and end positions are always walkable (`0`). - There is no guarantee that a path between start and end exists. Examples ```python grid = [ [0, 0, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) end = (4, 3) bfs_shortest_path(grid, start, end) # Returns 7 grid = [ [0, 1], [0, 0] ] start = (0, 0) end = (1, 1) bfs_shortest_path(grid, start, end) # Returns 2 grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] start = (1, 1) end = (1, 1) bfs_shortest_path(grid, start, end) # Returns 0 grid = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] start = (0, 0) end = (2, 2) bfs_shortest_path(grid, start, end) # Returns -1 ``` Explanation - Begin by initializing a queue with the start position and distance `0`. - Use BFS to explore each walkable cell, marking the cells as visited to avoid reprocessing. - Maintain distance from the start node and update it as you progress. - If you reach the end node, return the distance, otherwise return `-1` if no path is found.","solution":"from typing import List, Tuple from collections import deque def bfs_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # If no path is found"},{"question":"# Coding Challenge: Implement a Basic Version of the Disjoint Set Union-Find Data Structure **Context**: The Disjoint Set Union-Find data structure is a fundamental structure in computer science, widely used in network connectivity, image processing, and Kruskal’s Minimum Spanning Tree algorithm. Your task is to implement a basic version of this structure with path compression and union by rank. **Task**: You need to implement the core functions required to manage the disjoint sets, including initializing the sets, finding the representative of a set, and uniting two sets. **Input**: - Two integers `n` and `q`, where `n` is the number of elements (0 to n-1), and `q` is the number of queries. - A list of `q` queries where each query is either: - `(\'union\', x, y)` to unite the sets containing elements `x` and `y`. - `(\'find\', x)` to find the representative of the set containing element `x`. **Output**: - A list of results for each \'find\' query, representing the representative of the set containing the element. **Constraints**: - (1 leq n, q leq 10^5) - (0 leq x, y < n) **Function Signature**: ```python def disjoint_set_union_find(n: int, queries: List[Tuple[str, int, int]]) -> List[int]: pass ``` **Requirements**: 1. Initialize `n` disjoint sets. 2. Implement the `find` function with path compression. 3. Implement the `union` function with union by rank. 4. Handle the queries as specified and return results for \'find\' queries. **Example**: ```python assert disjoint_set_union_find(5, [ (\'union\', 0, 1), (\'union\', 1, 2), (\'find\', 0), (\'find\', 2), (\'union\', 3, 4), (\'find\', 3), (\'union\', 2, 4), (\'find\', 1) ]) == [0, 0, 3, 0] ``` **Note**: Your solution should focus on efficiently handling large numbers of elements and queries using path compression and union by rank techniques to ensure optimal performance.","solution":"def disjoint_set_union_find(n, queries): parent = list(range(n)) rank = [1] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) # path compression return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 result = [] for query in queries: if query[0] == \'union\': _, x, y = query union(x, y) elif query[0] == \'find\': _, x = query result.append(find(x)) return result"},{"question":"# Coding Question: Longest Common Subsequence (LCS) **Scenario**: You are working on a bioinformatics tool that helps compare DNA sequences. One of the tasks involves computing the longest common subsequence (LCS) between two DNA sequences. The LCS is the longest sequence that can be derived from both original sequences by deleting some characters without changing the order of the remaining characters. **Function Signature**: ```python def longest_common_subsequence(seq1: str, seq2: str) -> str: pass ``` **Expected Input and Output**: * **Input**: - `seq1` (str): The first DNA sequence containing only characters A, C, G, and T. - `seq2` (str): The second DNA sequence containing only characters A, C, G, and T. * **Output**: - A string representing the longest common subsequence between the two input sequences. If there are multiple common subsequences with the same length, return any one of them. **Example**: ```python >>> seq1 = \\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\" >>> seq2 = \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\" >>> result = longest_common_subsequence(seq1, seq2) >>> print(result) \\"GTCGTCGGAAGCCGGCCGAA\\" >>> seq1 = \\"AGGTAB\\" >>> seq2 = \\"GXTXAYB\\" >>> result = longest_common_subsequence(seq1, seq2) >>> print(result) \\"GTAB\\" ``` **Constraints**: * The length of each DNA sequence will not exceed 1000 characters. * The input sequences will only contain characters A, C, G, and T. # Requirements: 1. Implement a dynamic programming solution to find the LCS. 2. Build and return the LCS string based on the computed optimal subproblems. 3. Handle edge cases such as empty sequences or no common subsequence. # Tips: * Use a 2D array to store lengths of LCS subproblems. * Trace back through the 2D array to construct the LCS string. * Ensure your solution runs efficiently within the given constraints.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> str: Returns the longest common subsequence between two given DNA sequences. # Get the length of the sequences m, n = len(seq1), len(seq2) # Create a 2D array to store lengths of LCS sub-problems lcs_length = [[0] * (n + 1) for _ in range(m + 1)] # Fill lcs_length array in bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: lcs_length[i][j] = lcs_length[i - 1][j - 1] + 1 else: lcs_length[i][j] = max(lcs_length[i - 1][j], lcs_length[i][j - 1]) # Initialize the LCS string lcs = [] # Start from the bottom-right corner of the matrix i, j = m, n while i > 0 and j > 0: if seq1[i - 1] == seq2[j - 1]: lcs.append(seq1[i - 1]) i -= 1 j -= 1 elif lcs_length[i - 1][j] > lcs_length[i][j - 1]: i -= 1 else: j -= 1 return \'\'.join(reversed(lcs))"},{"question":"# Question Context A developer is creating a software that needs to handle and manipulate dates in various formats. One specific requirement is to calculate the number of days between two given dates. The dates are provided in a specific string format and your task is to create a function that calculates the exact number of days between these dates. Task Write a function `days_between_dates` that computes the number of days between two given dates. Function Signature ```python def days_between_dates(date1: str, date2: str) -> int: ``` Input * `date1` (str): The start date in the format \\"YYYY-MM-DD\\". * `date2` (str): The end date in the format \\"YYYY-MM-DD\\". Output * (int): The number of days between the two dates. If `date2` is earlier than `date1`, return a negative integer. Example ```python >>> days_between_dates(\\"2021-01-01\\", \\"2021-01-10\\") 9 >>> days_between_dates(\\"2020-02-20\\", \\"2020-03-01\\") 10 >>> days_between_dates(\\"2023-12-25\\", \\"2023-12-24\\") -1 ``` Constraints * You can assume the input dates are valid and in the correct format. * You\'ll need to handle leap years correctly. * Assume the date format will always be provided in \\"YYYY-MM-DD\\". Notes * You may use Python\'s `datetime` module to handle date operations. * Consider the case where `date1` is later than `date2` and ensure to return the correct (negative) number of days.","solution":"from datetime import datetime def days_between_dates(date1: str, date2: str) -> int: Calculates the number of days between two dates. Args: date1 (str): The start date in the format \\"YYYY-MM-DD\\". date2 (str): The end date in the format \\"YYYY-MM-DD\\". Returns: int: The number of days between date1 and date2. Negative if date2 is earlier than date1. date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) delta = d2 - d1 return delta.days"},{"question":"# Context: You have been hired by a company working on a custom data analysis pipeline. As part of their requirements, they need a feature that allows for efficient row-wise normalization of data in a 2D array (matrix), where each row should be normalized to have unit norm. # Task: Extend the `Matrix` class to support row-wise normalization, ensuring the implementation is efficient and correctly handles edge cases such as zero rows without crashing. # Requirements: 1. **Function Implementation:** - Add a method `normalize_rows` to the `Matrix` class which returns a new `Matrix` object where each row of the original matrix is normalized to have a unit norm. - Ensure the method preserves the original matrix structure and creates a new matrix with normalized rows. - Implement the necessary adjustments to handle rows with zero norm by leaving them unchanged. 2. **Edge Case Handling:** - Ensure that rows with zero norm (i.e., all elements are zero) remain unchanged in the output matrix. 3. **Testing:** - Demonstrate the correctness of your implementation with several test cases including matrices with zero rows and varied numerical values. **Input and Output formats:** - **Input:** A `Matrix` object represented as a 2D numpy array. - **Output:** A new `Matrix` object with rows normalized to have unit norm. **Constraints:** - Consider using numpy for any numerical operations. - Assume the `Matrix` class is initialized with a 2D numpy array representing the data. # Example: ```python import numpy as np class Matrix: def __init__(self, data): self.data = np.array(data) def normalize_rows(self): norms = np.linalg.norm(self.data, axis=1, keepdims=True) norms[norms == 0] = 1 # To avoid division by zero normalized_data = self.data / norms return Matrix(normalized_data) # Usage Example: matrix = Matrix([[1, 2, 2], [0, 0, 0], [3, 4, 0]]) normalized_matrix = matrix.normalize_rows() expected_output = np.array([[0.33333333, 0.66666667, 0.66666667], [0, 0, 0], [0.6, 0.8, 0]]) assert np.allclose(normalized_matrix.data, expected_output) ``` **Note:** Ensure to handle necessary imports and avoid referencing the example code directly in your implementation.","solution":"import numpy as np class Matrix: def __init__(self, data): Initialize the Matrix with a 2D numpy array. self.data = np.array(data) def normalize_rows(self): Return a new Matrix object with rows normalized to have unit norm. Rows with zero norm remain unchanged. norms = np.linalg.norm(self.data, axis=1, keepdims=True) norms[norms == 0] = 1 # To avoid division by zero normalized_data = self.data / norms return Matrix(normalized_data)"},{"question":"# Question Description Given a list of strings, your task is to write a Python function that returns a list of all possible permutations of the strings. Use recursion to solve this problem and ensure your implementation handles edge cases gracefully. # Function Signature ```python def generate_permutations(strings: list[str]) -> list[list[str]]: Generates all possible permutations of a given list of strings. Parameters: strings (list[str]): A list of strings to generate permutations for. Returns: list[list[str]]: A list containing all possible permutations. Constraints: - The length of the strings list will be between 0 and 6. ``` # Input - A list of strings where the number of strings ranges from `0` to `6`. # Output - A list of permutations where each permutation is a list of strings rearranged in a new order. # Example ```python >>> generate_permutations([\\"a\\", \\"b\\"]) [[\'a\', \'b\'], [\'b\', \'a\']] >>> generate_permutations([\\"cat\\", \\"dog\\", \\"bird\\"]) [[\'cat\', \'dog\', \'bird\'], [\'cat\', \'bird\', \'dog\'], [\'dog\', \'cat\', \'bird\'], [\'dog\', \'bird\', \'cat\'], [\'bird\', \'cat\', \'dog\'], [\'bird\', \'dog\', \'cat\']] >>> generate_permutations([]) [[]] >>> generate_permutations([\\"apple\\"]) [[\'apple\']] ``` # Constraints - Ensure the list of strings and its elements are properly validated. - Handle edge cases like an empty list or a list with one string. # Notes You are not allowed to use any built-in permutation generating functions (like `itertools.permutations`).","solution":"def generate_permutations(strings): Generates all possible permutations of a given list of strings. Parameters: strings (list[str]): A list of strings to generate permutations for. Returns: list[list[str]]: A list containing all possible permutations. # Base case: If the list is empty, return an empty list if len(strings) == 0: return [[]] # Recursive case: Generate permutations result = [] for i, s in enumerate(strings): remaining_elements = strings[:i] + strings[i+1:] for p in generate_permutations(remaining_elements): result.append([s] + p) return result"},{"question":"# Binary Search Algorithm Implementation Background Binary search is a classic algorithm for finding the position of a target value within a sorted array. It is highly efficient, reducing the average time complexity to O(log n). Task Write a function `binary_search` that implements the binary search algorithm. Implementation Details * **Function Signature**: `def binary_search(arr: list[int], target: int) -> int` * **Input**: * `arr`: A list of integers sorted in ascending order (1 ≤ |arr| ≤ 10^6). * `target`: An integer value to search for within the array. * **Output**: The index of the target value within the array. If the target is not found, return -1. Function Specifics 1. Initialize two pointers to keep track of the search region: `left` at the start (index 0) and `right` at the end (index len(arr) - 1). 2. Loop until the `left` pointer exceeds the `right` pointer: * Calculate the middle index: `mid = (left + right) // 2`. * Compare the target value with the element at the middle index: * If they are equal, return `mid`. * If the target is less, move the `right` pointer to `mid - 1`. * If the target is greater, move the `left` pointer to `mid + 1`. 3. Return -1 if the target value is not found after exiting the loop. Edge Cases * Handle an empty array by returning -1. * Ensure the function efficiently handles arrays with up to maximum length constraint. Example ```python def binary_search(arr: list[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 # Example Usage print(binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5)) # Output: 4 print(binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 10)) # Output: -1 ``` **Constraints**: * Time Complexity: O(log n), where n is the length of the input array. * Space Complexity: O(1). Note Binary search requires that the input array must be sorted before the search is conducted. Ensure the input satisfies this condition, or sort the array beforehand if necessary. This algorithm efficiently handles large datasets and is a fundamental technique in computer science.","solution":"def binary_search(arr: list[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question You are tasked with implementing a function `number_of_pairs` that finds the number of unique pairs (i, j) in an array such that `arr[i] + arr[j] == target`, where `i < j`. # Inputs * `arr`: A list of integers. * `target`: An integer representing the target sum. # Outputs * `count`: An integer representing the number of unique pairs that sum up to the target. # Constraints * Each input list will contain between 1 and 10,000 integers. * Each integer in the list will be between -10,000 and 10,000. * Assume there are no duplicate values in the list. # Example ```python arr = [1, 3, 2, 2, 4, 3] target = 5 # Corresponding pairs satisfying arr[i] + arr[j] == target are: # (1, 4), (3, 2), (3, 2) # Output should be: 2 ``` # Implementation You need to complete the implementation of the `number_of_pairs` function: ```python def number_of_pairs(arr, target): count = 0 seen = set() complements = set() for number in arr: complement = target - number if complement in complements and (complement, number) not in seen: count += 1 seen.add((number, complement)) seen.add((complement, number)) complements.add(number) return count ``` Test your implementation with multiple cases to ensure correctness and performance.","solution":"def number_of_pairs(arr, target): Finds the number of unique pairs (i, j) in an array such that arr[i] + arr[j] == target, where i < j. Args: arr: List of integers. target: The target sum, an integer. Returns: Integer representing the count of unique pairs that sum up to the target. count = 0 seen = set() complements = set() for number in arr: complement = target - number if complement in complements and (complement, number) not in seen: count += 1 seen.add((number, complement)) seen.add((complement, number)) complements.add(number) return count"},{"question":"# Scenario You are developing a text editor that features an automatic spelling correction system. One of the most critical components of this system is identifying the most probable correct spelling of a given misspelled word from a provided dictionary of words. # Task Implement a function that, given a misspelled word and a dictionary of valid words, finds the word in the dictionary that has the smallest Levenshtein distance to the misspelled word. In case of a tie (multiple words with the same smallest distance), return the word that appears first in the dictionary. # Function Signature ```python def spell_correct(misspelled_word: str, dictionary: List[str]) -> str: Finds the word in the dictionary with the smallest Levenshtein distance to the misspelled word. :param misspelled_word: The misspelled word as a string. :param dictionary: A list of valid words as strings. :return: The best guess for the correct spelling as a string. ``` # Input * `misspelled_word`: a string representing the misspelled word. * `dictionary`: a list of strings, where each string is a word in the dictionary. # Output Returns a string from the dictionary that has the smallest Levenshtein distance to the misspelled word. # Constraints * The length of the misspelled word and all dictionary words will be between 1 and 100 inclusive. * The size of the dictionary will be between 1 and 10,000 inclusive. # Example ```python >>> spell_correct(\\"recieve\\", [\\"receive\\", \\"recite\\", \\"recede\\", \\"recycle\\"]) \\"receive\\" >>> spell_correct(\\"speling\\", [\\"spelling\\", \\"spieling\\", \\"spewing\\"]) \\"spelling\\" >>> spell_correct(\\"adress\\", [\\"address\\", \\"dressed\\", \\"adorned\\"]) \\"address\\" >>> spell_correct(\\"bookkeper\\", [\\"bookkeeper\\", \\"bookstore\\", \\"housekeeper\\"]) \\"bookkeeper\\" ``` # Notes * The Levenshtein distance is the number of single-character edits (insertions, deletions or substitutions) required to change one word into another. * Your implementation should handle edge cases efficiently and adhere to the given constraints. * Libraries for computing Levenshtein distance can be used if needed, otherwise, an implementation must be provided within the function.","solution":"from typing import List def levenshtein_distance(a: str, b: str) -> int: Compute the Levenshtein distance between two strings. if len(a) < len(b): return levenshtein_distance(b, a) if len(b) == 0: return len(a) previous_row = range(len(b) + 1) for i, c1 in enumerate(a): current_row = [i + 1] for j, c2 in enumerate(b): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def spell_correct(misspelled_word: str, dictionary: List[str]) -> str: Finds the word in the dictionary with the smallest Levenshtein distance to the misspelled word. min_distance = float(\'inf\') closest_word = None for word in dictionary: distance = levenshtein_distance(misspelled_word, word) if distance < min_distance: min_distance = distance closest_word = word elif distance == min_distance: # In case of tie, retain the first word that appears pass return closest_word"},{"question":"# Scenario You are tasked with creating a program for a library that keeps track of book rentals. The library system needs to calculate the total rental cost based on the duration of the rental period in days and apply any late fees if applicable. # Problem Statement Implement the `calculate_rental_cost` function which calculates the total rental cost given the daily rental rate, the number of days the book is rented, and any applicable late fees for overdue books. # Function Signature ```python def calculate_rental_cost(daily_rate: float, days_rented: int, late_fee_rate: float, deadline_days: int) -> float: ``` # Input * `daily_rate` (float): The standard daily rental rate for the book. * `days_rented` (int): The total number of days the book has been rented out. * `late_fee_rate` (float): The daily late fee rate applied for each day the book is overdue. * `deadline_days` (int): The allowed rental period without incurring late fees. # Output * Returns a float representing the total rental cost. # Exception Handling * Raise a `ValueError` if `daily_rate`, `days_rented`, or `late_fee_rate` are negative. * Raise a `ValueError` if `deadline_days` is negative. * Display an appropriate error message on invalid inputs. # Constraints * The function must handle various durations of rental periods including non-overdue and overdue cases. * Ensure precision in calculations, especially when handling floating point numbers. # Example ```python # Example usage of calculate_rental_cost print(calculate_rental_cost(2.0, 5, 1.0, 3)) # 11.0 print(calculate_rental_cost(3.0, 10, 2.0, 7)) # 36.0 ``` # Test Cases Ensure your function passes the following test cases: 1. `calculate_rental_cost(1.5, 4, 0.5, 2)` should return `6.5` 2. `calculate_rental_cost(2.5, 7, 1.0, 6)` should return `18.5` 3. `calculate_rental_cost(2.0, 3, 1.0, 3)` should return `6.0` 4. `calculate_rental_cost(1.0, 5, 0.5, -1)` should raise a `ValueError`","solution":"def calculate_rental_cost(daily_rate: float, days_rented: int, late_fee_rate: float, deadline_days: int) -> float: Calculate the total rental cost based on daily rate, days rented, late fee rate, and deadline days. Parameters: daily_rate (float): The standard daily rental rate. days_rented (int): The total number of days the book is rented out. late_fee_rate (float): The daily late fee rate applied after the deadline days. deadline_days (int): The allowed rental period without incurring late fees. Returns: float: The total rental cost. Raises: ValueError: If any of the input values are negative. if daily_rate < 0 or days_rented < 0 or late_fee_rate < 0 or deadline_days < 0: raise ValueError(\\"All inputs must be non-negative values.\\") if days_rented <= deadline_days: total_cost = daily_rate * days_rented else: normal_cost = daily_rate * deadline_days late_days = days_rented - deadline_days late_cost = (daily_rate + late_fee_rate) * late_days total_cost = normal_cost + late_cost return total_cost"},{"question":"# Merge K Sorted Arrays Challenge You are required to implement a function `merge_k_sorted_arrays` that merges `k` sorted arrays into a single sorted array. The function should efficiently merge the arrays while maintaining the overall sorting order. # Function Signature: ```python def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: pass ``` # Input: - A list of `k` sorted arrays, where each array contains integers in non-decreasing order. # Output: - A single sorted array that contains all the elements of the input arrays in non-decreasing order. # Example: ```python arrays = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] print(merge_k_sorted_arrays(arrays)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Constraints: - Each array within the list `arrays` is sorted in non-decreasing order. - The total number of elements across all arrays will not exceed 10^5. - The function should be time-efficient, leveraging appropriate data structures as needed (e.g., heap). # Testing: 1. Ensure the function can handle a variable number of input arrays. 2. Test edge cases such as arrays with different lengths, including empty arrays. 3. Confirm the function works for large input sizes close to the constraint limit. # Implementation Tips: - Consider using a heap data structure to manage the merging process efficiently. - Handle edge cases by checking if the list of arrays is empty or contains only empty arrays.","solution":"from heapq import heappush, heappop from typing import List def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. min_heap = [] result = [] # Initialize the heap with the first element of each array for arr_index, array in enumerate(arrays): if array: heappush(min_heap, (array[0], arr_index, 0)) # (element, array index, element index) while min_heap: val, arr_index, ele_index = heappop(min_heap) result.append(val) # If the array has more elements, push the next element into the heap if ele_index + 1 < len(arrays[arr_index]): next_element = arrays[arr_index][ele_index + 1] heappush(min_heap, (next_element, arr_index, ele_index + 1)) return result"},{"question":"# Problem Statement You have been given a list of employee IDs along with their direct managers. Each employee either directly manages other employees or reports to another employee. You are tasked with figuring out the hierarchy\'s depth, i.e., the length of the longest chain of command in the company. # Requirements 1. **Function Implementation**: Implement the function `find_hierarchy_depth(employee_manager_pairs: list[tuple[str, str]]) -> int` to compute the depth of the managerial hierarchy. - **Parameters**: - `employee_manager_pairs`: A `list` of `tuple`s where each tuple consists of two `str` values representing the employee and their direct manager (`employee, manager`). - **Return**: An `int` representing the depth of the longest chain of command. 2. **Constraints**: - It is guaranteed that there will be no cycles (i.e., no employee directly or indirectly manages themselves). - There could be multiple top-level managers (those who do not report to anyone). - Assume all IDs are unique. - The input list can have at most 10^3 pairs. 3. **Example**: ```python employee_manager_pairs = [ (\'A\', \'B\'), (\'B\', \'C\'), (\'C\', \'D\'), (\'E\', \'F\'), (\'F\', \'G\') ] result = find_hierarchy_depth(employee_manager_pairs) print(result) # Output: 4 (A -> B -> C -> D) ``` 4. **Edge Cases**: - Consider scenarios where some employees do not report to anyone (they are top-level managers). - Cases with a single employee without any reportees. # Hints - Use a graph structure to represent employees and their managers. - Perform a Depth-First Search (DFS) or Breadth-First Search (BFS) to find the longest path in the graph. - Utilize recursion or iteration to traverse the hierarchical structure.","solution":"def find_hierarchy_depth(employee_manager_pairs): from collections import defaultdict, deque # Create an adjacency list to represent our graph manager_to_employees = defaultdict(list) employees = set() managers = set() for employee, manager in employee_manager_pairs: manager_to_employees[manager].append(employee) employees.add(employee) managers.add(manager) # Identify top-level managers top_managers = managers - employees def dfs(manager): if manager not in manager_to_employees: return 1 max_depth = 0 for emp in manager_to_employees[manager]: max_depth = max(max_depth, dfs(emp)) return 1 + max_depth # Calculate maximum depth starting from each top-level manager global_max_depth = 0 for top_manager in top_managers: global_max_depth = max(global_max_depth, dfs(top_manager)) return global_max_depth"},{"question":"# Question: Implement String Permutation with Repetition Counts **Context**: You are required to write a function that generates all the permutations of a given string and counts the number of unique permutations generated. **Objective**: Given a string that may contain duplicate characters, your task is to generate all unique permutations of that string and return a list of these permutations along with their count. **Function Signature**: ```python def string_permutations(s: str) -> tuple[list[str], int]: Args: - s: A string, which may contain duplicate characters. Returns: - A tuple containing: * A list of unique permutations of the input string. * An integer count of the unique permutations. Constraints: - The string length will be between 1 and 10 inclusive. - The string will only contain lowercase English alphabet characters. Example: >>> string_permutations(\\"aabb\\") ([\'aabb\', \'abab\', \'abba\', \'baab\', \'baba\', \'bbaa\'], 6) >>> string_permutations(\\"abc\\") ([\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'], 6) pass ``` **Instructions**: 1. Implement a function to generate all possible permutations of the input string. 2. Ensure that each permutation is unique; avoid duplicates resulting from repeated characters. 3. Return the list of unique permutations and their count as a tuple. **Performance Requirements**: * Your solution should handle up to the maximum string length efficiently. **Hint**: Using a suitable library can help handle permutations, but ensure to filter out duplicate permutations. Sorting or using a set might be useful to avoid duplicates.","solution":"from itertools import permutations def string_permutations(s: str) -> tuple[list[str], int]: Generate all unique permutations of the input string and return the list of these permutations along with their count. Args: - s: A string, which may contain duplicate characters. Returns: - A tuple containing: * A list of unique permutations of the input string. * An integer count of the unique permutations. unique_permutations = set(permutations(s)) unique_permutations_list = [\'\'.join(p) for p in unique_permutations] return unique_permutations_list, len(unique_permutations_list)"},{"question":"# Transpose a Matrix **Scenario**: In a linear algebra system, you need to transpose a matrix for various operations such as transforming coordinates or changing the structure of data for easier manipulation. **Task**: Write a function `transpose_matrix` that takes a 2-dimensional list (matrix) and returns its transpose. The transpose of a matrix is obtained by swapping the rows with columns. **Function Signature**: ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` **Input**: - `matrix`: A non-empty 2-dimensional list (list of lists) where each inner list represents a row of integers. All rows have the same number of elements. **Output**: - Return a new 2-dimensional list representing the transposed matrix. **Constraints**: - The number of rows and columns of the input matrix will be at least 1 and at most 100. - Each element of the matrix will be an integer between -10^9 and 10^9. **Examples**: ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert transpose_matrix([[7]]) == [[7]] ``` In this question, students need to correctly implement the algorithm to transpose the given matrix. They should ensure that the function handles the transformation properly and efficiently, taking into account the constraints provided.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given 2D matrix. Parameters: matrix (list[list[int]]): A 2D list of integers. Returns: list[list[int]]: A 2D list representing the transposed matrix. # Using zip to unpack and transpose the matrix return [list(row) for row in zip(*matrix)]"},{"question":"# Sorting Even Indices in a List Background You have been tasked with writing a function that sorts only the elements that are at even indices in a list of integers, while keeping the elements at odd indices unchanged. This requires a selective sorting algorithm. Task Create a function `sort_even_indices` that takes a list of integers and sorts the elements at even indices. The elements at odd indices should remain in their original positions. Function Signature ```python def sort_even_indices(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers, where the length of the list is between 1 and 10^5, inclusive. Output * A list of integers where only the elements at even indices are sorted in ascending order. Constraints * The list can contain any integers within the range of standard 32-bit signed integers. * The length of the list will be between 1 and 10^5, inclusive. Performance Requirements * Your implementation should handle the sorting and merging operations efficiently. Example ```python >>> sort_even_indices([10, 5, 8, 3, 7, 2]) [7, 5, 8, 3, 10, 2] >>> sort_even_indices([4, 1, 3, 9, 2]) [2, 1, 3, 9, 4] ``` In the first example, elements at even indices are `[10, 8, 7]`. When sorted, these become `[7, 8, 10]`, resulting in the list: * Element at index 0 changes from 10 to 7 * Element at index 2 remains 8 * Element at index 4 changes from 7 to 10 So, the resultant list is `[7, 5, 8, 3, 10, 2]`. In the second example, elements at even indices are `[4, 3, 2]`. When sorted, these become `[2, 3, 4]`, resulting in the list: * Element at index 0 changes from 4 to 2 * Element at index 2 remains 3 * Element at index 4 changes from 2 to 4 So, the resultant list is `[2, 1, 3, 9, 4]`. **Note**: Ensure your function sorts only the elements at even indices and the function runs within the desired time complexity constraints.","solution":"from typing import List def sort_even_indices(arr: List[int]) -> List[int]: even_indices_vals = [arr[i] for i in range(0, len(arr), 2)] even_indices_vals.sort() sorted_arr = arr[:] even_index = 0 for i in range(0, len(arr), 2): sorted_arr[i] = even_indices_vals[even_index] even_index += 1 return sorted_arr"},{"question":"# Question: **Efficient Prime Counting in a Range** Given two integers `a` and `b`, write a function to count the number of prime numbers within this inclusive range `[a, b]`. The goal is to implement an efficient algorithm that handles large ranges effectively. # Requirements: 1. **Input**: Two integers `a` and `b` (1 <= a <= b <= 10^6). 2. **Output**: An integer representing the count of prime numbers within the range `[a, b]`. 3. **Constraints**: Your solution should efficiently count the primes in the range even for the upper limits. # Hint: Use the Sieve of Eratosthenes to precompute the primes up to the largest possible value of `b`, and then count the primes within the range `[a, b]`. # Example: ```python def count_primes_in_range(a: int, b: int) -> int: pass # Example Test Cases print(count_primes_in_range(10, 20)) # Output: 4 (primes are 11, 13, 17, 19) print(count_primes_in_range(1, 10)) # Output: 4 (primes are 2, 3, 5, 7) ``` This question aligns with the existing set in terms of style, complexity, and scope, involving efficient algorithm design and number theory concepts.","solution":"def count_primes_in_range(a: int, b: int) -> int: Counts the number of prime numbers in the inclusive range [a, b]. if b < 2: return 0 # Sieve of Eratosthenes to find all primes up to b sieve = [True] * (b + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= b: if sieve[p]: for i in range(p * p, b + 1, p): sieve[i] = False p += 1 # Count primes in range [a, b] prime_count = sum(1 for i in range(a, b + 1) if sieve[i]) return prime_count"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase English letters. Your task is to write a function `min_operations_to_uniform` that computes the minimum number of operations required to make all the characters in the string equal. In one operation, you can choose any character from the string and change it to any other character. # Input - A string `s` (1 ≤ |s| ≤ 100) consisting of lowercase English letters. # Output - An integer representing the minimum number of operations required to make all the characters in the string equal. # Constraints - The input string will have at least one character and only include lowercase English letters. # Example ```python def min_operations_to_uniform(s: str) -> int: # Your implementation here # Example Usage s = \\"aabb\\" print(min_operations_to_uniform(s)) # Output: 2 s = \\"abc\\" print(min_operations_to_uniform(s)) # Output: 2 ``` # Note - For the string \\"aabb\\", you can convert the two \'b\'s to \'a\' in two operations to get \\"aaaa\\". - For the string \\"abc\\", you can either convert both \'b\' and \'c\' to \'a\' or convert \'a\' and \'c\' to \'b\', or convert \'a\' and \'b\' to \'c\', each requiring 2 operations.","solution":"def min_operations_to_uniform(s: str) -> int: Returns the minimum number of operations required to make all the characters in the string equal. from collections import Counter # Get the frequency of each character in the string char_count = Counter(s) # Find the maximum frequency of any single character max_freq = max(char_count.values()) # The minimum operations needed is the length of the string # minus the maximum frequency of any single character return len(s) - max_freq"},{"question":"# Scenario You are developing a software tool for a retail company to help manage their inventory. The tool will track product quantities and update stocks when sales occur. The current system uses a simple dictionary to store product information, but it lacks functionality to handle bulk operations efficiently. # Question Implement a function that processes a list of sales transactions to update the inventory. Each transaction indicates a sale of a specific product and the quantity sold. Your task is to ensure that the inventory reflects the correct stock levels after all the transactions are processed. # Specifications 1. **Initial Inventory:** - You are given an initial inventory represented as a dictionary where keys are product names, and values are the quantities available. 2. **Transaction List:** - You are given a list of tuples, where each tuple contains the name of the product sold and the quantity sold. 3. **Function Operations:** - For each transaction, deduct the sold quantity from the corresponding product in the inventory. - If a product in a transaction does not exist in the inventory, raise a `KeyError` with the message \\"Product not found in inventory\\". - If a transaction attempts to sell more than the available quantity, raise a `ValueError` with the message \\"Insufficient stock for product\\". # Function Signature ```python def update_inventory(inventory, transactions): pass ``` # Input - `inventory`: A dictionary representing the initial inventory, e.g., `{\'apple\': 50, \'banana\': 100, \'orange\': 75}` - `transactions`: A list of tuples representing sales transactions, e.g., `[(\'apple\', 10), (\'banana\', 50), (\'apple\', 5)]` # Output - The function should return the updated inventory dictionary after processing all transactions. # Constraints - The inventory dictionary and transactions list are both non-empty. - The product names in the transactions are case-sensitive and must match exactly with the names in the inventory. # Examples ```python # Example 1 inventory = {\'apple\': 50, \'banana\': 100, \'orange\': 75} transactions = [(\'apple\', 10), (\'banana\', 50), (\'apple\', 5)] updated_inventory = update_inventory(inventory, transactions) # updated_inventory should be {\'apple\': 35, \'banana\': 50, \'orange\': 75} # Example 2 inventory = {\'laptop\': 10, \'mouse\': 25} transactions = [(\'laptop\', 2), (\'mouse\', 10), (\'keyboard\', 1)] # Raises KeyError: \'Product not found in inventory\' ``` # Notes - Pay close attention to constraints and error handling to ensure robustness. - Assume input types are always correct (no need to validate types).","solution":"def update_inventory(inventory, transactions): Updates the inventory dictionary based on the list of given sales transactions. Args: inventory (dict): Dictionary with product names as keys and quantities as values. transactions (list): List of tuples where each tuple contains a product name and quantity sold. Returns: dict: Updated inventory dictionary after processing transactions. Raises: KeyError: If a product in transactions does not exist in inventory. ValueError: If a transaction tries to sell more than the available quantity. for product, quantity in transactions: if product not in inventory: raise KeyError(\'Product not found in inventory\') if inventory[product] < quantity: raise ValueError(\'Insufficient stock for product\') inventory[product] -= quantity return inventory"},{"question":"# Substring Repetition You need to implement a function that checks if a given string can be constructed by taking a substring of it and repeating the substring one or more times. If it can, return `True`, otherwise return `False`. This function will help to quickly identify repetitive patterns in strings, which can be useful in various text processing tasks. Function Signature ```python def can_construct_from_repeated_substring(s: str) -> bool: Checks if a string can be constructed by repeating a substring of it. :param s: Input string to check for repetition. :return: A boolean indicating whether the input string can be constructed from a repeated substring. :raises ValueError: If the input is not a string. ``` Input & Output **Input**: - a string `s`. **Output**: - a boolean value indicating if the string can be constructed by repeating a substring. Constraints: - The function should raise a `ValueError` for non-string inputs. - Strings considered should have a minimum length of 1. Example ```python assert can_construct_from_repeated_substring(\\"abab\\") == True assert can_construct_from_repeated_substring(\\"aba\\") == False assert can_construct_from_repeated_substring(\\"abcabcabc\\") == True assert can_construct_from_repeated_substring(\\"aaaa\\") == True assert can_construct_from_repeated_substring(\\"xyz\\") == False try: can_construct_from_repeated_substring(123) except ValueError as e: assert str(e) == \\"Input must be a string\\" ``` Implement the `can_construct_from_repeated_substring` function to effectively determine if a string can be made up of a repeating substring, while ensuring comprehensive error handling.","solution":"def can_construct_from_repeated_substring(s: str) -> bool: Checks if a string can be constructed by repeating a substring of it. :param s: Input string to check for repetition. :return: A boolean indicating whether the input string can be constructed from a repeated substring. :raises ValueError: If the input is not a string. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") n = len(s) for i in range(1, n//2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"# Question: String Character Shifts Given the problem of shifting characters in a string to create new combinations, let\'s examine a more complex scenario. Problem Statement Write a function `shift_string` that shifts each character in a given string by a specified number of positions in the alphabet. The alphabet wraps around such that shifting \'z\' by one position results in \'a\'. The shift operation should consider both uppercase and lowercase letters independently, and non-alphabet characters should remain unchanged. Function Signature ```python def shift_string(s: str, shift: int) -> str: ``` Input - `s` (str): The input string consisting of alphabetic and non-alphabetic characters. - `shift` (int): The number of positions each character in the string `s` should be shifted. Output - `str`: The resultant string after shifting each character in `s` by `shift` positions. Constraints - `0 <= len(s) <= 10^5` - `-100 <= shift <= 100` - Edge cases: Consider the behavior when `shift` results in wrapping around the alphabet, and when the string is empty. Performance Requirements - The implemented solution should run efficiently for the maximum string length of 100,000 characters. Example ```python >>> shift_string(\\"abc\\", 1) \\"bcd\\" >>> shift_string(\\"XYZ\\", 2) \\"ZAB\\" >>> shift_string(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> shift_string(\\"shift123\\", 0) \\"shift123\\" ``` Notes - Ensure the case of each letter (uppercase or lowercase) is preserved. - Non-alphabetic characters should remain unchanged in their positions. - Handle both positive and negative shift values correctly, accounting for wrapping around the alphabet.","solution":"def shift_string(s: str, shift: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, shift) for c in s)"},{"question":"Graph Cycle Detection Using Depth-First Search (DFS) Objective You need to implement a function to detect if a given directed graph contains any cycles using Depth-First Search (DFS). Cycle detection in directed graphs is crucial for identifying problems such as deadlocks in operating systems or checking if tasks can be scheduled in computer science. Problem Statement Implement a function `is_cyclic(graph: Dict[int, List[int]]) -> bool` that: 1. Uses Depth-First Search (DFS) to determine if there is at least one cycle in the directed graph. 2. Efficiently handles large graphs and edge cases. Input * A dictionary where the key is an integer representing a node and the value is a list of integers representing the adjacent nodes (directed edges). Output * Returns `True` if there is at least one cycle in the graph. * Returns `False` otherwise. Constraints * A node can have zero or more outgoing edges. * The graph does not have to be connected. * Nodes are represented by unique integers. Example ```python >>> is_cyclic({0: [1], 1: [2], 2: [0]}) True >>> is_cyclic({0: [1], 1: [2], 2: [3], 3: []}) False >>> is_cyclic({0: [1, 2], 1: [2], 2: [3], 3: [1]}) True >>> is_cyclic({0: [], 1: []}) False ``` Requirements * Do not use external libraries for the cycle detection algorithm. * Utilize comments to improve code clarity. * Handle edge cases such as empty graphs or single-node graphs without edges. * Ensure the implementation efficiently handles large graphs.","solution":"def is_cyclic(graph): Uses Depth-First Search (DFS) to determine if there is at least one cycle in the directed graph. :param graph: Dictionary where key is a node and value is a list of adjacent nodes (directed edges) :return: True if there is at least one cycle in the graph, False otherwise visited = set() # Set to keep track of visited nodes rec_stack = set() # Set to keep track of the recursion stack (nodes in the current path) def dfs(v): if v in rec_stack: # A cycle is found if a node is encountered which is already in the recursion stack return True if v in visited: # If the node is already visited, no need to process again return False # Mark the current node as visited and add it to the recursion stack visited.add(v) rec_stack.add(v) # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(v, []): if dfs(neighbor): # If any adjacent node has a cycle, return True return True # Remove the vertex from recursion stack rec_stack.remove(v) return False # Check each node in the graph for node in graph.keys(): if dfs(node): # If the starting node of any DFS call finds a cycle, return True return True return False"},{"question":"# Question: Rotate Matrix by 90 Degrees **Problem Description:** Given a square matrix, rotate it in-place by 90 degrees (clockwise). Your task is to write a function `rotate_matrix(matrix: List[List[int]]) -> None` that performs this rotation. The function should modify the matrix in-place and not return anything. **Function Signature:** ```python def rotate_matrix(matrix: List[List[int]]) -> None: ``` **Input:** - `matrix` (n x n): A 2D list representing a square matrix, where 1 ≤ n ≤ 1000 and each element of the matrix is an integer in the range [−1000, 1000]. **Output:** - The function does not return anything. It modifies the input matrix in-place. **Example:** ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Expected output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) print(matrix2) # Expected output: [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` **Constraints:** - The function should rotate the matrix in-place. Do not allocate another 2D array for the rotation. - The solution should be optimized for both time and space. **Notes:** - The primary steps to perform the rotation involve transposing the matrix and then reversing each row. - Ensure your function handles more significant matrices efficiently to meet performance requirements for larger input sizes.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given square matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Question: Valid Palindrome with Alphanumeric Characters Design a function `is_valid_palindrome(s: str) -> bool` that determines whether a given string ( s ) is a palindrome, considering only alphanumeric characters and ignoring cases. Function Signature ```python def is_valid_palindrome(s: str) -> bool: pass ``` Input * The input string ( s ) which may contain special characters, spaces, and mixed case letters. Output * Returns `True` if ( s ) is a valid palindrome considering only alphanumeric characters and ignoring cases. * Returns `False` otherwise. Constraints * The input type should be strictly a string. If an invalid type is provided, the function must raise a `TypeError` with the message `\\"is_valid_palindrome() only accepts strings\\"`. Examples ```python >>> is_valid_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\"No \'x\' in Nixon\\") True >>> is_valid_palindrome(\\"\\") True >>> is_valid_palindrome(\\"Hello!\\") False >>> is_valid_palindrome(12321) Traceback (most recent call last): ... TypeError: is_valid_palindrome() only accepts strings ``` *Note: Ignore spaces and punctuation when determining if the string is a palindrome. You can assume that the input string length is within a reasonable limit.* Validation Ensure your solution is thoroughly tested with various cases, including but not limited to different types of characters, varying lengths, and edge cases.","solution":"def is_valid_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"is_valid_palindrome() only accepts strings\\") # Filter out non-alphanumeric characters and convert to lower case filtered_chars = \'\'.join(c.lower() for c in s if c.isalnum()) # Check if the filtered list of characters is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"**Problem Statement: Implement a Custom `round` Function with Enhanced Precision** You are tasked to implement a custom version of the `round` function that enhances precision and handles edge cases involving special floating-point values. # Function Signature ```python def round_extended(x: float, n: int) -> float: Round a floating-point number x to n decimal places accurately, handling edge cases. Parameters: x (float): The input floating-point number. n (int): The number of decimal places to round to. Returns: float: Number rounded to n decimal places. ``` # Requirements 1. The function should handle rounding of very large and very small floating-point numbers accurately. 2. It should correctly handle edge cases like rounding halfway cases up to the nearest even number. 3. The function must not use any external libraries (no `round`, `decimal` module, or similar). 4. Provide documentation and at least 5 test cases demonstrating the correctness, including edge cases. # Input Format - A single float, ( x le 10^{18} ) or ( x ge -10^{18} ). - An integer ( n ) indicating the number of decimal places ( 0 le n le 10 ). # Output Format - A floating-point number rounded to the specified number of decimal places. # Constraints - The function should work within the float precision limits of Python. # Example ```python >>> round_extended(1.2345, 2) 1.23 >>> round_extended(-1.2345, 2) -1.23 >>> round_extended(1.2355, 3) 1.236 >>> round_extended(-1.2355, 3) -1.236 >>> round_extended(123456789.987654321, 5) 123456789.98765 ``` Ensure to clearly document your function to enlighten the readers about your approach and edge cases considered. # Problem Statement Implement a custom `round` function that provides stable and predictable rounding for floating point numbers. The function should be capable of rounding to a specified number of decimal places and correctly handle the edge cases. By carefully crafting the rounding logic without relying on built-in functions, the custom function ensures better control and accuracy over the rounding behavior. The handling of halfway cases should adhere to the round half to even, also known as \\"bankers\' rounding,\\" where ties are rounded to the nearest even number. # Constraints and Edge Cases Your implementation should be robust enough to handle: - Large integers and very small numbers - Negative and positive values - Halfway cases (e.g., when rounding 2.5 to zero decimal places, it should result in 2) Develop a set of comprehensive test cases to validate that the function behaves as expected for various inputs, demonstrating the ability to handle common and edge case scenarios effectively.","solution":"def round_extended(x: float, n: int) -> float: Round a floating-point number x to n decimal places accurately, handling edge cases. Parameters: x (float): The input floating-point number. n (int): The number of decimal places to round to. Returns: float: Number rounded to n decimal places. factor = 10 ** n if x < 0: sign = -1 else: sign = 1 x_abs = abs(x) temp = (x_abs * factor) if (temp - int(temp) == 0.5): if int(temp) % 2 == 0: rounded = int(temp) / factor else: rounded = (int(temp) + 1) / factor else: rounded = round(x_abs * factor) / factor return sign * rounded"},{"question":"# Scenario You are developing a file system monitoring tool that tracks the changes in file sizes within a specific directory. The tool is intended to help users understand how their files are growing or shrinking over time. One of the core features is to compute the difference in file sizes between two consecutive checks. # Task Write a function `calculate_size_differences` that takes two dictionaries representing the file sizes at two different points in time and returns a dictionary with the file names as keys and the difference in size as values. The function should also handle cases where files are newly created or deleted between the two checks. # Function Signature ```python def calculate_size_differences(time1: dict[str, int], time2: dict[str, int]) -> dict[str, int]: ``` # Input - `time1`: A dictionary where keys are file names (strings) and values are file sizes (integers) at the first point in time. - `time2`: A dictionary with the same format as `time1`, representing file sizes at the second point in time. # Output - Returns a dictionary with file names as keys and the size difference (time2 - time1) as values. If a file was deleted, the difference should be negative, indicating how much space was freed. If a file was newly created, the difference should be positive. # Constraints - File names will be unique strings. - File sizes are non-negative integers. # Examples ```python # Example 1: Simple size update time1 = {\'file_a.txt\': 100, \'file_b.txt\': 200} time2 = {\'file_a.txt\': 120, \'file_b.txt\': 180} print(calculate_size_differences(time1, time2)) # Output: {\'file_a.txt\': 20, \'file_b.txt\': -20} # Example 2: New file creation and deletion time1 = {\'file_a.txt\': 100, \'file_b.txt\': 200} time2 = {\'file_a.txt\': 100, \'file_b.txt\': 200, \'file_c.txt\': 50} print(calculate_size_differences(time1, time2)) # Output: {\'file_a.txt\': 0, \'file_b.txt\': 0, \'file_c.txt\': 50} # Example 3: File deletion time1 = {\'file_a.txt\': 100, \'file_b.txt\': 200} time2 = {\'file_a.txt\': 100} print(calculate_size_differences(time1, time2)) # Output: {\'file_a.txt\': 0, \'file_b.txt\': -200} ``` # Notes - The function should correctly handle the creation of new files and the deletion of existing files between the two time points. - The function must ensure that only the relevant changes (additions, deletions, size differences) are captured in the output dictionary. - Consider using comprehensions and dictionary operations to keep the solution clean and efficient.","solution":"def calculate_size_differences(time1: dict[str, int], time2: dict[str, int]) -> dict[str, int]: size_diff = {} all_files = set(time1.keys()).union(set(time2.keys())) for file in all_files: size1 = time1.get(file, 0) size2 = time2.get(file, 0) size_diff[file] = size2 - size1 return size_diff"},{"question":"Problem Statement # Problem Statement You are given an array of positive integers representing coin denominations and a target sum. Your task is to compute the number of unique combinations that can make up the target sum using any number of coins in any order. Assume each denomination can be used an unlimited number of times. # Function Signature ```python def coin_combinations(denominations: List[int], target: int) -> int: ``` # Input - **denominations** (List[int]): A list of unique positive integers representing the coin denominations. - **target** (int): A positive integer representing the target sum. # Output - **Returns** (int): The number of unique combinations that can make up the target sum. # Constraints - 1 ≤ len(denominations) ≤ 50 - 1 ≤ denominations[i] ≤ 100 - 1 ≤ target ≤ 10,000 # Example Example 1 ```python denominations = [1, 2, 5] target = 5 print(coin_combinations(denominations, target)) # Should output 4 ``` **Explanation**: - The unique combinations for target sum 5 are: - [1, 1, 1, 1, 1] - [1, 1, 1, 2] - [1, 2, 2] - [5] Example 2 ```python denominations = [2, 3, 6, 7] target = 7 print(coin_combinations(denominations, target)) # Should output 2 ``` **Explanation**: - The unique combinations for target sum 7 are: - [2, 2, 3] - [7] # Notes To solve this problem, consider using a dynamic programming approach where you build up the solution to the target sum using previously computed results for smaller sums. # Example Call ```python result = coin_combinations([1, 2, 5], 5) print(result) # Outputs 4 ```","solution":"from typing import List def coin_combinations(denominations: List[int], target: int) -> int: Returns the number of unique combinations that can make up the target sum using the given denominations. # Initialize a list to store the number of ways to achieve each amount dp = [0] * (target + 1) dp[0] = 1 # There\'s one way to have a target sum of 0: use no coins # For each coin, update the dp array for coin in denominations: for amount in range(coin, target + 1): dp[amount] += dp[amount - coin] return dp[target]"},{"question":"# Reverse Dictionary Lookup You are tasked with creating a function that performs a reverse dictionary lookup. Given a dictionary and a target value, the function should return all the keys that map to the target value. If no keys map to the target value, return an empty list. The function should handle string and integer values only. Function Signature: ```python def reverse_lookup(d: Dict[Any, Any], target: Any) -> List[Any]: ``` Input: - `d` (Dict[Any, Any]): A dictionary where the keys are strings or integers, and the values are strings or integers. - `target` (Any): The value to find keys for. Output: - A list of dictionary keys that map to the `target` value. If no keys map to the target value, return an empty list. Constraints: - The dictionary can contain up to 10,000 key-value pairs. - Keys and values in the dictionary are unique. - The `target` value is guaranteed to be either a string or an integer. Examples: ```python >>> reverse_lookup({\'a\': 1, \'b\': 2, \'c\': 1}, 1) [\'a\', \'c\'] >>> reverse_lookup({1: \'apple\', 2: \'orange\', 3: \'apple\'}, \'apple\') [1, 3] >>> reverse_lookup({\'x\': 42, \'y\': 100, \'z\': 42}, 100) [\'y\'] >>> reverse_lookup({9: \'banana\', 10: \'grape\', 11: \'kiwi\'}, \'pear\') [] ``` Description: 1. Implement the `reverse_lookup` function to iterate through the dictionary and check each key-value pair. 2. Collect all keys that map to the target value and return them as a list. 3. Ensure your function handles the specified constraints efficiently.","solution":"from typing import Dict, Any, List def reverse_lookup(d: Dict[Any, Any], target: Any) -> List[Any]: Returns all keys from the dictionary that map to the target value. If no keys map to the target value, returns an empty list. return [key for key, value in d.items() if value == target]"},{"question":"# Question: Data Aggregation and Transformation You are tasked with writing a function that processes sales data from multiple regions to compile a comprehensive report for further analysis. Each region\'s sales data is provided as a list of dictionaries, where each dictionary contains the month and sales figures. Your function should aggregate the monthly sales data and return the total sales per month across all regions. Instructions 1. Implement a function `aggregate_sales(data: List[List[Dict[str, int]]]) -> Dict[str, int]`: * The function takes a list of lists, where each sublist contains dictionaries with sales data. * Each dictionary has two keys: \\"month\\" (a string) and \\"sales\\" (an integer). * The function aggregates the sales data across all regions and returns a dictionary with the total sales per month. 2. Ensure that your solution handles cases where some months may not be present in all regions. Constraints * Although the months provided might vary, you can assume they are always valid month names. * The input lists may contain up to 1000 entries. Example ```python sales_data = [ [ {\\"month\\": \\"January\\", \\"sales\\": 100}, {\\"month\\": \\"February\\", \\"sales\\": 150}, {\\"month\\": \\"March\\", \\"sales\\": 200} ], [ {\\"month\\": \\"January\\", \\"sales\\": 80}, {\\"month\\": \\"March\\", \\"sales\\": 220}, {\\"month\\": \\"April\\", \\"sales\\": 130} ] ] output = aggregate_sales(sales_data) print(output) ``` Expected Output: ```python { \\"January\\": 180, \\"February\\": 150, \\"March\\": 420, \\"April\\": 130 } ``` Write your solution in Python.","solution":"from typing import List, Dict def aggregate_sales(data: List[List[Dict[str, int]]]) -> Dict[str, int]: Aggregates sales data from multiple regions and returns total sales per month. :param data: List of lists containing dictionaries with sales data. :return: A dictionary with the total sales per month. sales_aggregation = {} for region_data in data: for entry in region_data: month = entry[\\"month\\"] sales = entry[\\"sales\\"] if month in sales_aggregation: sales_aggregation[month] += sales else: sales_aggregation[month] = sales return sales_aggregation"},{"question":"# Problem Statement Implement a function to find the longest palindrome substring within a given string. The palindrome must be contiguous within the given input string. Additionally, implement a function that counts all distinct sub-palindromes (substrings that are palindromes) within the given string. # Requirements 1. **Longest Palindrome Substring**: - Function Name: `longest_palindrome_substring` - Input: Single string `s` - Output: String representing the longest palindrome substring - Constraints: * Assume the input string will contain only alphanumeric characters and have a length of at least 1. 2. **Count Distinct Sub-Palindromes**: - Function Name: `count_distinct_sub_palindromes` - Input: Single string `s` - Output: Integer representing the count of distinct sub-palindromes - Constraints: * Assume the input string will contain only alphanumeric characters and have a length of at least 1. # Example For example, the implementation should yield the following outputs: ```python assert longest_palindrome_substring(\\"babad\\") == \\"bab\\" or longest_palindrome_substring(\\"babad\\") == \\"aba\\" assert longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" assert count_distinct_sub_palindromes(\\"ababa\\") == 5 # \\"a\\", \\"b\\", \\"aba\\", \\"bab\\", \\"ababa\\" assert count_distinct_sub_palindromes(\\"abc\\") == 3 # \\"a\\", \\"b\\", \\"c\\" ``` # Function Definitions **Longest Palindrome Substring** ```python def longest_palindrome_substring(s: str) -> str: n = len(s) if n < 2: return s start, max_length = 0, 1 def expand_around_center(left: int, right: int) -> None: nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 for i in range(n - 1): expand_around_center(i, i) # Odd length palindrome expand_around_center(i, i + 1) # Even length palindrome return s[start:start + max_length] ``` **Count Distinct Sub-Palindromes** ```python def count_distinct_sub_palindromes(s: str) -> int: n = len(s) palindromes = set() def expand_around_center(left: int, right: int): while left >= 0 and right < n and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindrome expand_around_center(i, i + 1) # Even length palindrome return len(palindromes) ``` Implement these functions and ensure they pass the provided example cases.","solution":"def longest_palindrome_substring(s: str) -> str: n = len(s) if n < 2: return s start, max_length = 0, 1 def expand_around_center(left: int, right: int) -> None: nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 for i in range(n - 1): expand_around_center(i, i) # Odd length palindrome expand_around_center(i, i + 1) # Even length palindrome return s[start:start + max_length] def count_distinct_sub_palindromes(s: str) -> int: n = len(s) palindromes = set() def expand_around_center(left: int, right: int): while left >= 0 and right < n and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindrome expand_around_center(i, i + 1) # Even length palindrome return len(palindromes)"},{"question":"# Problem Statement You are given a list of integers representing the heights of trees. You need to determine the maximum amount of water that can be trapped between the trees after a rain. Implement a function `max_water_trapped` that takes a list of integers and returns the maximum volume of trapped water. # Input: - A list of integers `heights` of length between 1 and 1000, where each integer represents the height of a tree. # Output: - An integer representing the maximum volume of water trapped between the trees. # Constraints: - Each integer in the list will be between 0 and 1000. Function Signature: ```python def max_water_trapped(heights: List[int]) -> int: pass ``` # Example: ```python assert max_water_trapped([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_water_trapped([1, 1]) == 1 assert max_water_trapped([4, 3, 2, 1, 4]) == 16 assert max_water_trapped([1, 2, 1]) == 2 ``` # Additional Context: This problem tests the understanding of the two-pointer technique to efficiently calculate the trapped water volume. The idea is to use two pointers to traverse the list from both ends towards the center and calculate the volume iteratively. # Notes: - Consider edge cases where the heights list might be very short (e.g., length 1 or 2) and ensure the function handles such inputs gracefully. - Think about how to optimize your solution to handle the upper limit of the constraints efficiently.","solution":"from typing import List def max_water_trapped(heights: List[int]) -> int: Calculates the maximum amount of water that can be trapped between the trees. Parameters: heights (List[int]): List of integers representing the heights of trees. Returns: int: The maximum volume of trapped water. left, right = 0, len(heights) - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_water = max(max_water, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Coding Assessment Question Problem Statement You are tasked with extending a class that represents a singly linked list. The linked list is implemented with basic functionalities such as adding nodes and traversing the list. Your objective is to add a new function that performs an important operation on the list. Objective 1. Write a function `find_nth_from_end` that finds and returns the n-th node from the end of the singly linked list. If the position is invalid (e.g., n is greater than the length of the list), return `None`. Implementation Details Add the function to the provided singly linked list class with the following signature: ```python def find_nth_from_end(self, n: int) -> ListNode: ``` - **Input**: - `n`: The position (1-based index) from the end of the list (type `int`). - **Output**: - Returns the node at the n-th position from the end (type `ListNode`). - If `n` is greater than the length of the list or less than 1, return `None`. Constraints - Assume the linked list nodes contain integer values. - The singly linked list has no cycles. Performance Requirements - The solution should run in O(L) time complexity, where L is the length of the linked list. - The solution should use O(1) additional space. Example ```python # Example usage: list = SinglyLinkedList() list.add(1) list.add(2) list.add(3) list.add(4) list.add(5) # The list is now: 1 -> 2 -> 3 -> 4 -> 5 # This should return the node with value 4 (since it\'s the 2nd from the end) nth_node = list.find_nth_from_end(2) print(nth_node.val) # Output: 4 # This should return None since there is no 6th element from the end nth_node = list.find_nth_from_end(6) print(nth_node) # Output: None ``` Notes - You may use helper functions to keep the implementation clean and manageable. - Handle edge cases such as an empty list or invalid position values effectively.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class SinglyLinkedList: def __init__(self): self.head = None def add(self, val): new_node = ListNode(val) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def find_nth_from_end(self, n: int) -> ListNode: if n <= 0: return None first = self.head second = self.head # Move first pointer `n` steps ahead for _ in range(n): if not first: return None first = first.next # Move both pointers until first reaches the end while first: first = first.next second = second.next return second"},{"question":"Problem Statement: You are provided with a string. Your task is to implement a function that finds and returns all the distinct permutations of the string using backtracking. The function should handle strings efficiently and avoid generating duplicate permutations. # Function Signature: ```python def find_all_permutations(s: str) -> list[str]: ``` # Input: - A string `s` consisting of lowercase alphabetic characters (0 ≤ len(s) ≤ 8) # Output: - A list of strings where each string is a unique permutation of the input string. The permutations can be returned in any order, but all unique permutations must be included. # Constraints: - The input string can contain duplicate characters. - The function should handle empty string cases. # Performance Requirements: - Ensure that the solution avoids generating duplicate permutations through optimization techniques such as sorting and skipping of repeated characters during recursion. # Example: Example 1: Input: ```python s = \\"abc\\" ``` Output: ```python [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] ``` Example 2: Input: ```python s = \\"aab\\" ``` Output: ```python [\\"aab\\", \\"aba\\", \\"baa\\"] ``` Example 3: Input: ```python s = \\"\\" ``` Output: ```python [\\"\\"] ``` # Notes: - The order of permutations in the output list does not matter. - Make sure to handle any edge cases, such as an empty string.","solution":"def find_all_permutations(s: str) -> list[str]: Returns all distinct permutations of the input string `s`. def backtrack(path, used, res): if len(path) == len(s): res.append(\\"\\".join(path)) return for i in range(len(s)): if used[i]: continue # Avoid duplicates by skipping over duplicates if i > 0 and s[i] == s[i - 1] and not used[i - 1]: continue used[i] = True path.append(s[i]) backtrack(path, used, res) path.pop() used[i] = False if not s: return [\\"\\"] s = sorted(s) res = [] used = [False] * len(s) backtrack([], used, res) return res"},{"question":"**Title**: Implement a Min-Heap Insertion Function **Objective**: Write a function to insert a given integer into a min-heap and maintain the min-heap property. **Function Signature**: ```python def insert_into_min_heap(heap: List[int], value: int) -> List[int]: pass ``` **Input**: * heap (List[int]): A list of integers representing a min-heap. * value (int): An integer value to be inserted into the min-heap. **Output**: * List[int]: The updated list representing the min-heap after the insertion of the given value. **Constraints**: * The initial heap list may contain between 1 and 10^4 integers. * All integers in the heap list are within the range [-10^5, 10^5]. * The value to be inserted is within the range [-10^5, 10^5]. **Performance Requirements**: * Time Complexity: `O(log N)` where `N` is the number of elements in the heap. * Space Complexity: `O(N)` **Context**: You are given a list that represents a min-heap where the smallest element is always at the root. Your task is to insert a new integer value into this heap while maintaining the heap property. **Example**: ```python # Example heap usage heap = [1, 3, 6, 5, 9, 8] value = 4 updated_heap = insert_into_min_heap(heap, value) print(updated_heap) # Output: [1, 3, 4, 5, 9, 8, 6] ``` **Note**: * Follow the min-heap property where the parent node is always less than or equal to the child nodes. * Ensure that the insertion operation is efficient and correctly maintains the heap structure.","solution":"def insert_into_min_heap(heap, value): Insert a given value into a min-heap and maintain the min-heap property. :param heap: List[int] - A list representing a min-heap. :param value: int - An integer value to be inserted into the min-heap. :return: List[int] - The updated min-heap. # Insert the value at the end of the heap heap.append(value) # Get the index of the newly inserted value index = len(heap) - 1 # Bubble up the value to maintain the min-heap property while index > 0: parent_index = (index - 1) // 2 if heap[index] < heap[parent_index]: # Swap the value with its parent heap[index], heap[parent_index] = heap[parent_index], heap[index] index = parent_index else: break return heap"},{"question":"Task Design and implement a system to generate a unique identifier for users based on their username. # Scenario You are building a web application that requires unique identifiers for each registered user. These identifiers should be derived from the users\' usernames to maintain simplicity and avoid the need for an additional database call. Your task is to create a function that generates a unique identifier for a username by hashing it. # Implementation Write a function called `generate_user_id` that takes in a username and generates a unique identifier using the SHA-256 hash function. ```python def generate_user_id(username: str) -> str: Generates a unique identifier for the given username. Parameters: - username (str): The username for which to generate the identifier. Returns: - str: The hexadecimal representation of the SHA-256 hash of the username. ``` # Requirements 1. Implement the SHA-256 hash function to generate the unique identifier. 2. Ensure the function handles empty strings gracefully. 3. The output should be the hexadecimal representation of the hash. # Constraints - The input username `username` will be a non-empty string containing alphanumeric characters, but may include other typical username characters like underscores and periods. - The function should handle usernames of varying lengths efficiently, running in O(n) time complexity where n is the length of the username. # Example Usage ```python print(generate_user_id(\'alice\')) # Example output: \'3bc51062973c458d5d4aaffe6201cfc6\' print(generate_user_id(\'alice_smith\')) # Example output: \'f5e9fa20d38b9c7a5a1e3ef7b55ee2b3\' print(generate_user_id(\'user123\')) # Example output: \'ba6f95cf39df11fbb2b7cbc2bd5d12a4\' print(generate_user_id(\'\')) # Should handle empty username gracefully, e.g., \'\' ``` # Notes - Use Python\'s `hashlib` library to implement the SHA-256 hash function. - Ensure to test your implementation with various usernames to verify its correctness and uniqueness. - Consider discussing any potential improvements or assumptions made while implementing the function.","solution":"import hashlib def generate_user_id(username: str) -> str: Generates a unique identifier for the given username using SHA-256 hash. Parameters: - username (str): The username for which to generate the identifier. Returns: - str: The hexadecimal representation of the SHA-256 hash of the username. # Create a SHA-256 hash object sha256_hash = hashlib.sha256() # Encode the username to bytes and update the hash object sha256_hash.update(username.encode(\'utf-8\')) # Return the hexadecimal representation of the hash return sha256_hash.hexdigest()"},{"question":"# Scenario: In a web application, it\'s often necessary to filter items based on various criteria selected by the user. For example, consider an online bookstore where users can search for books by title, author, genre, and publication year. Your task is to implement a function that filters a list of book dictionaries based on multiple criteria provided in a filter dictionary. # Task: Write a function `filter_books(books: List[dict], criteria: dict) -> List[dict]` that takes in two parameters: a list of book dictionaries and a filter dictionary containing the criteria. The function should return a list of books that match all the criteria specified in the filter dictionary. # Requirements: 1. The `books` parameter is a list of dictionaries where each dictionary contains information about a single book with these keys: `title`, `author`, `genre`, and `year`. 2. The `criteria` parameter is a dictionary where the keys are any subset of `title`, `author`, `genre`, and `year`, and the values are the corresponding values to filter by. 3. The function should return a list of dictionaries representing books that match all the criteria. 4. The filtering should be case-insensitive. 5. Handle cases where the filter dictionary is empty, meaning no filter should be applied. # Example: ```python def filter_books(books: List[dict], criteria: dict) -> List[dict]: pass # Implement the function here # Example usage: books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Literature\\", \\"year\\": 1925}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Literature\\", \\"year\\": 1960} ] criteria = {\\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\"} result = filter_books(books, criteria) ``` Input: - `books`: A list of dictionaries, each representing a book with keys `title`, `author`, `genre`, and `year`. - `criteria`: A dictionary with keys being any subset of `title`, `author`, `genre`, and `year`, and the values being the desired values for filtering. Output: - Returns a list of dictionaries representing books that match all the criteria in the `criteria` dictionary. Constraints: - The function should handle up to 1000 books. - The function should handle up to 4 criteria elements in the filter dictionary.","solution":"def filter_books(books, criteria): Filters a list of books based on various criteria. Args: books (List[dict]): A list of dictionaries, each representing a book with keys: \'title\', \'author\', \'genre\', and \'year\'. criteria (dict): A dictionary with keys being any subset of \'title\', \'author\', \'genre\', and \'year\', and the values being the corresponding values to filter by. Returns: List[dict]: A list of dictionaries representing books that match all the criteria. def matches(book, criteria): for key, value in criteria.items(): if key in book and book[key].lower() != str(value).lower(): return False return True return [book for book in books if matches(book, criteria)]"},{"question":"# Question: Implement a Cache System with Expiration Time Design and implement a Cache class that allows for key-value storage with a time-to-live (TTL) expiration mechanism. The class should support the following methods: 1. **put(self, key: str, value: any, ttl: int)**: Add a key-value pair to the cache with a specified time-to-live (in seconds). 2. **get(self, key: str) -> any**: Retrieve the value associated with the specified key. If the key doesn\'t exist or has expired, return `None`. 3. **delete(self, key: str)**: Remove the specified key and its associated value from the cache. # Implementation: Class and Method Definitions: ```python import time class CacheNode: def __init__(self, value, ttl): self.value = value self.expiration_time = time.time() + ttl class Cache: def __init__(self): self.cache: dict[str, CacheNode] = {} def put(self, key: str, value: any, ttl: int) -> None: Add a key-value pair to the cache with a TTL (time-to-live). :param key: Key to be added :param value: Value to be associated with the key :param ttl: Time-to-live in seconds for the key-value pair self.cache[key] = CacheNode(value, ttl) def get(self, key: str) -> any: Retrieve the value associated with the specified key. :param key: Key to look up :return: Value if key exists and is not expired, otherwise None if key in self.cache: node = self.cache[key] if node.expiration_time > time.time(): return node.value else: del self.cache[key] return None def delete(self, key: str) -> None: Remove the specified key and its value from the cache. :param key: Key to be deleted if key in self.cache: del self.cache[key] ``` Expected Input/Output: 1. **put(self, key: str, value: any, ttl: int) -> None** - **Input**: A key string, a value of any type, and a TTL (time-to-live) in seconds. - **Output**: None - **Example**: ```python cache.put(\\"username\\", \\"john_doe\\", 10) ``` 2. **get(self, key: str) -> any** - **Input**: A key string. - **Output**: The value associated with the key if the key exists and has not expired, otherwise `None`. - **Example**: ```python cache.get(\\"username\\") ``` Considering a previous `put` call with key \\"username,\\" value \\"john_doe,\\" and a TTL of 10 seconds, the output should be `\\"john_doe\\"` if within the 10-second window. If the TTL has expired, the output should be `None`. 3. **delete(self, key: str) -> None** - **Input**: A key string. - **Output**: None - **Example**: ```python cache.delete(\\"username\\") ``` This would remove the key \\"username\\" and its associated value from the cache. # Constraints: 1. The key is a non-empty string. 2. The value can be of any type. 3. The TTL is a non-negative integer. # Performance Requirements: 1. Ensure that get operations are efficient, considering potential cache expiry checks. 2. Aim for minimal overhead in managing the expiration times of cache entries.","solution":"import time class CacheNode: def __init__(self, value, ttl): self.value = value self.expiration_time = time.time() + ttl class Cache: def __init__(self): self.cache = {} def put(self, key, value, ttl): Add a key-value pair to the cache with a TTL (time-to-live). :param key: Key to be added :param value: Value to be associated with the key :param ttl: Time-to-live in seconds for the key-value pair self.cache[key] = CacheNode(value, ttl) def get(self, key): Retrieve the value associated with the specified key. :param key: Key to look up :return: Value if key exists and is not expired, otherwise None if key in self.cache: node = self.cache[key] if node.expiration_time > time.time(): return node.value else: del self.cache[key] return None def delete(self, key): Remove the specified key and its value from the cache. :param key: Key to be deleted if key in self.cache: del self.cache[key]"},{"question":"# Problem Statement Implement a Basic Multithreaded File Downloader Overview You are required to implement a basic multithreaded file downloader that can download parts of a file simultaneously and then combine them into one file. This could help in speeding up the file download process, especially for large files. Task Develop a class `FileDownloader` that can perform the following tasks: 1. Divide the file download into multiple parts. 2. Download each part using a separate thread. 3. Combine the downloaded parts into a single file. Requirements 1. **Initialization Parameters**: - `url`: The URL of the file to be downloaded. - `num_threads`: The number of threads to use for downloading. 2. **Methods**: - `download`: This method should perform the download operation. - `combine_parts`: This method should combine the downloaded parts into a single file named `downloaded_file`. Input - **Initialization Parameters**: ```python FileDownloader(url: str, num_threads: int) ``` - **Method Call**: ```text FileDownloader.download() ``` Output - A file named `downloaded_file` which is the combined result of all the parts downloaded by the threads. Constraints - The URL will be valid and the server will support range requests (partial downloads). - The number of threads `num_threads` will be a positive integer and not greater than 10. Example ```python # Sample usage url = \\"http://example.com/largefile.zip\\" num_threads = 4 downloader = FileDownloader(url, num_threads) downloader.download() # The result should be a file named `downloaded_file` # containing the complete content of the file from the provided URL. ``` **Note**: Your solution should handle threading and file I/O operations efficiently. Ensure that the parts are properly combined in the order they were downloaded. # Solution Template ```python import os import threading import requests class FileDownloader: def __init__(self, url: str, num_threads: int): self.url = url self.num_threads = num_threads self.parts = [] def download(self): response = requests.head(self.url) file_size = int(response.headers[\'Content-Length\']) part_size = file_size // self.num_threads threads = [] for i in range(self.num_threads): start = i * part_size end = file_size if i == self.num_threads - 1 else start + part_size - 1 thread = threading.Thread(target=self.download_part, args=(i, start, end)) threads.append(thread) thread.start() for thread in threads: thread.join() self.combine_parts() def download_part(self, part_num: int, start: int, end: int): headers = {\'Range\': f\'bytes={start}-{end}\'} response = requests.get(self.url, headers=headers) part_filename = f\'part_{part_num}\' with open(part_filename, \'wb\') as part_file: part_file.write(response.content) self.parts.append(part_filename) def combine_parts(self): with open(\'downloaded_file\', \'wb\') as output_file: for part_file in sorted(self.parts, key=lambda x: int(x.split(\'_\')[1])): with open(part_file, \'rb\') as pf: output_file.write(pf.read()) os.remove(part_file) # Uncomment the following lines to test the implementation: # url = \\"http://example.com/largefile.zip\\" # num_threads = 4 # downloader = FileDownloader(url, num_threads) # downloader.download() ``` **Instructions**: Implement the `download_part` and `combine_parts` methods to ensure the file parts are downloaded correctly and combined into the final file.","solution":"import os import threading import requests class FileDownloader: def __init__(self, url: str, num_threads: int): self.url = url self.num_threads = num_threads self.parts = [] self.lock = threading.Lock() def download(self): response = requests.head(self.url) file_size = int(response.headers[\'Content-Length\']) part_size = file_size // self.num_threads threads = [] for i in range(self.num_threads): start = i * part_size end = file_size - 1 if i == self.num_threads - 1 else start + part_size - 1 thread = threading.Thread(target=self.download_part, args=(i, start, end)) threads.append(thread) thread.start() for thread in threads: thread.join() self.combine_parts() def download_part(self, part_num: int, start: int, end: int): headers = {\'Range\': f\'bytes={start}-{end}\'} response = requests.get(self.url, headers=headers) part_filename = f\'part_{part_num}\' with open(part_filename, \'wb\') as part_file: part_file.write(response.content) with self.lock: self.parts.append(part_filename) def combine_parts(self): with open(\'downloaded_file\', \'wb\') as output_file: for part_file in sorted(self.parts, key=lambda x: int(x.split(\'_\')[1])): with open(part_file, \'rb\') as pf: output_file.write(pf.read()) os.remove(part_file)"},{"question":"# Coding Assessment Question You have been tasked with writing a function that calculates the monthly payment on a loan using the formula for an amortizing loan. The formula to calculate the monthly payment is: [ M = frac{P cdot r(1 + r)^n}{(1 + r)^n - 1} ] where: - ( M ) is the monthly payment - ( P ) is the principal loan amount - ( r ) is the monthly interest rate (annual interest rate divided by 12) - ( n ) is the number of monthly payments (loan term in years multiplied by 12) Your Task Write a function `calculate_monthly_payment` that calculates and returns the monthly payment for a loan. Additionally, incorporate input validation checks and raise appropriate exceptions for the following cases: 1. Negative or zero values for the principal loan amount. 2. Negative or zero values for the annual interest rate. 3. Negative or zero values for the loan term in years. # Function Specifications `calculate_monthly_payment` - **Input**: `principal` (float), `annual_rate` (float), `term_years` (int) - **Output**: `float` (monthly payment) - **Exceptions**: - Raise `ValueError` if any of the inputs are zero or negative. # Example Usage ```python try: payment = calculate_monthly_payment(10000, 5.0, 15) print(payment) # Expected Output: ~79.08 payment = calculate_monthly_payment(200000, 3.5, 30) print(payment) # Expected Output: ~898.09 except ValueError as e: print(e) ``` # Constraints - Input values for `principal` and `annual_rate` are floating-point numbers. - Input value for `term_years` is an integer. - Ensure the function handles the input validations mentioned above. Good luck, and ensure your function is thoroughly tested with both valid and invalid inputs!","solution":"def calculate_monthly_payment(principal, annual_rate, term_years): Calculate the monthly payment for an amortizing loan. Parameters: - principal (float): The principal loan amount - annual_rate (float): The annual interest rate (percentage) - term_years (int): The loan term in years Returns: - float: The monthly payment Raises: - ValueError: If any of the inputs are zero or negative. if principal <= 0: raise ValueError(\\"Principal amount must be greater than zero.\\") if annual_rate <= 0: raise ValueError(\\"Annual interest rate must be greater than zero.\\") if term_years <= 0: raise ValueError(\\"Loan term in years must be greater than zero.\\") # Convert annual interest rate to monthly and convert it to decimal monthly_rate = annual_rate / 100 / 12 # Total number of monthly payments total_payments = term_years * 12 # Monthly payment formula numerator = principal * monthly_rate * (1 + monthly_rate) ** total_payments denominator = (1 + monthly_rate) ** total_payments - 1 monthly_payment = numerator / denominator return monthly_payment"},{"question":"# Coding Question: Optimizing Database Access for Article Retrieval Context You are developing a large-scale application that needs to fetch articles from a database efficiently. Articles are stored with a unique identifier, a publication timestamp, and a popularity score. To ensure the best user experience, the application retrieves the top articles based on popularity within a given time range. Task Using the provided `ArticleDatabase` class, write a function `fetch_top_articles` that selects and returns the identifiers of the top articles based on their popularity score, published within a specified timestamp range as given in the input list of retrieval requests. Function Signature ```python def fetch_top_articles(queries: list[tuple[int, int, int]]) -> list[list[int]]: Fetches top articles based on retrieval queries. Args: queries: List of tuples where each tuple represents a retrieval query in the format (start_timestamp, end_timestamp, top_n) - start_timestamp: Start of the publication timestamp range (integer) - end_timestamp: End of the publication timestamp range (integer) - top_n: Number of top articles to retrieve based on popularity (integer) Returns: List of lists, where each sublist contains the top N articles\' identifiers for each query, sorted by their popularity score in descending order. Example: fetch_top_articles([ (1609459200, 1612137600, 3), (1609459200, 1612137600, 1), (1625097600, 1627776000, 2) ]) => [[345, 123, 789], [345], [567, 234]] ``` Requirements * Implement an efficient retrieval mechanism for articles using the ArticleDatabase class. * The input list `queries` consists of multiple tuples where each tuple represents a retrieval query. * The first element in the tuple (`start_timestamp`) is the beginning of the publication timestamp range, the second (`end_timestamp`) is the end of the range, and the third (`top_n`) is the number of articles to retrieve based on their popularity. * You can assume the `ArticleDatabase` class is pre-defined and available with methods to fetch articles based on time range and sort them by popularity. * The function should return a list of lists, where each sublist contains the identifiers of the top N articles for each query, sorted by their popularity score in descending order. Constraints - The tuple elements will always follow the format (start_timestamp, end_timestamp, top_n). - The publication timestamps and popularity scores are positive integers. - The database may contain a large number of articles, so optimize for efficiency in retrieval and sorting. - Ensure that the articles within the specified timestamps are returned in descending order of popularity. In case of ties in popularity, the articles should be returned in ascending order of their identifiers.","solution":"class ArticleDatabase: def __init__(self): # Mock data for demonstration purposes self.articles = [ {\\"id\\": 1, \\"timestamp\\": 1609459201, \\"popularity\\": 10}, {\\"id\\": 2, \\"timestamp\\": 1609545600, \\"popularity\\": 30}, {\\"id\\": 3, \\"timestamp\\": 1612137600, \\"popularity\\": 20}, {\\"id\\": 4, \\"timestamp\\": 1625097601, \\"popularity\\": 15}, {\\"id\\": 5, \\"timestamp\\": 1625184000, \\"popularity\\": 25}, {\\"id\\": 6, \\"timestamp\\": 1609545600, \\"popularity\\": 25}, {\\"id\\": 7, \\"timestamp\\": 1625184001, \\"popularity\\": 5} ] def fetch_articles_by_time_range(self, start_timestamp, end_timestamp): # Return articles within the time range return [article for article in self.articles if start_timestamp <= article[\\"timestamp\\"] <= end_timestamp] def fetch_top_articles(queries): Fetches top articles based on retrieval queries. Args: queries: List of tuples where each tuple represents a retrieval query in the format (start_timestamp, end_timestamp, top_n) Returns: List of lists, where each sublist contains the top N articles\' identifiers for each query, sorted by their popularity score in descending order. database = ArticleDatabase() results = [] for start_timestamp, end_timestamp, top_n in queries: # Fetch articles within the given time range articles = database.fetch_articles_by_time_range(start_timestamp, end_timestamp) # Sort articles by popularity in descending order, then by ID in ascending order if popularity is the same sorted_articles = sorted(articles, key=lambda x: (-x[\\"popularity\\"], x[\\"id\\"])) # Get the top N article IDs top_articles = [article[\\"id\\"] for article in sorted_articles[:top_n]] results.append(top_articles) return results"},{"question":"# Binary Tree Level Order Traversal Scenario You are required to implement an algorithm to traverse a binary tree level by level. This traversal method is known as level-order traversal or breadth-first traversal. During level-order traversal, the nodes are visited level by level from top to bottom and from left to right within each level. Your task is to complete the function `level_order_traversal` that accepts the root node of a binary tree and returns a list of lists, where each inner list contains the values of the nodes at that level in the binary tree. Task Implement the function `level_order_traversal` using a queue to achieve the level-order traversal. Function Details 1. `level_order_traversal(root)` - **Parameters:** - `root`: The root node of a binary tree. The node is defined with the class `TreeNode` where `TreeNode` has attributes `val`, `left`, and `right`. - **Functionality:** Perform a level-order traversal of the binary tree and return the values of nodes at each level as a list of lists. 2. `TreeNode(val, left=None, right=None)` - **Parameters:** - `val`: The integer value of the node. - `left`: A reference to the left child node (default is `None`). - `right`: A reference to the right child node (default is `None`). - **Functionality:** Represents a node in the binary tree. Input and Output - **Input Format**: The input is the root node of a binary tree. - **Output Format**: A list of lists, where each list contains the values of the nodes at that level. Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-1000 <= Node.val <= 1000` - If the tree is empty, return an empty list. Example Usage ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result # Example test case root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert level_order_traversal(root) == [[1], [2, 3], [4, 5]] ``` Ensure your implementation is efficient and handles edge cases such as an empty tree appropriately.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Array and String Manipulation You are given the task of implementing functions that manipulate and analyze arrays and strings. Each function must correctly perform the specified operations and return the appropriate result. Implement the following functions: 1. `find_longest_palindromic_substring(s: str) -> str`: Finds the longest palindromic substring in the given string. 2. `spiral_order(matrix: List[List[int]]) -> List[int]`: Returns all elements of the given 2D matrix in spiral order. # Expected Input and Output - `find_longest_palindromic_substring` - **Input constraint**: The string `s` will have a length between 1 and 2000. - **Output**: A single string representing the longest palindromic substring. If there are multiple substrings of the same length, return the first one encountered. - `spiral_order` - **Input constraint**: The matrix will have dimensions m x n, with 1 ≤ m, n ≤ 100. - **Output**: A list of integers representing the elements of the matrix in spiral order. # Example Suppose you have the following input for `find_longest_palindromic_substring`: # Example 1: ``` Input: s = \\"babad\\" Output: \\"bab\\" or \\"aba\\" (both are valid answers) ``` # Example 2: ``` Input: s = \\"cbbd\\" Output: \\"bb\\" ``` For `spiral_order`, suppose you have the following matrix: ``` Input: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` # Example 2: ``` Input: matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] ``` # Constraints: - For `find_longest_palindromic_substring`, ensure that your solution handles the possible string length efficiently. - For `spiral_order`, ensure you properly handle various matrix dimensions, including edge cases like single rows or columns. - Optimize the time complexity for both functions as much as possible. Implement the functions ensuring they adhere to the above specifications and handle the given constraints effectively.","solution":"def find_longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string. def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] if not s or len(s) == 1: return s longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest def spiral_order(matrix: list[list[int]]) -> list[int]: Returns all elements of the given 2D matrix in spiral order. result = [] while matrix: # Take the first row result += matrix.pop(0) # Take the last element of each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Take the last row in reverse order if matrix: result += matrix.pop()[::-1] # Take the first element of each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"# Find the Longest Word in Each Sentence You are given a function `longest_word(sentence)` that returns the longest word in a given sentence. Your task is to implement the function `longest_words(sentences: list)` which accepts a list of sentences and returns a list of the longest words for each sentence. # Constraints: * The main list will contain between 1 and 100 sentences. * Each sentence will contain between 1 and 1000 characters. * Words in a sentence are separated by spaces. * Sentences will only contain alphabetic characters and spaces, with no punctuation. # Input Format: * A list of sentences, where each sentence is a string. # Output Format: * A list of strings, where each string is the longest word from the corresponding sentence. * If two or more words have the same maximum length within a sentence, return the first occurring one. ```python def longest_word(sentence: str) -> str: words = sentence.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word elif len(word) == len(longest): continue # continue to ensure first occurrence is taken return longest def longest_words(sentences: list[str]) -> list[str]: Find the longest word in each sentence. :param sentences: List of sentences :return: List of the longest words from each sentence >>> longest_words([\\"The quick brown fox\\", \\"jumps over the lazy dog\\", \\"Hello world!\\"]) [\'quick\', \'jumps\', \'Hello\'] >>> longest_words([\\"This is a sentence\\", \\"I love programming\\", \\"Python devs are cool\\"]) [\'sentence\', \'programming\', \'Python\'] >>> longest_words([\\"Single\\", \\"Word\\"]) [\'Single\', \'Word\'] >>> longest_words([]) [] >>> longest_words([\\"Equal size words have first\\", \\"Another set of equal\\", \\"Last but not least\\"]) [\'Equal\', \'Another\', \'least\'] result = [] for sentence in sentences: result.append(longest_word(sentence)) return result ```","solution":"def longest_word(sentence: str) -> str: words = sentence.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word elif len(word) == len(longest): continue # continue to ensure first occurrence is taken return longest def longest_words(sentences: list[str]) -> list[str]: Find the longest word in each sentence. :param sentences: List of sentences :return: List of the longest words from each sentence result = [] for sentence in sentences: result.append(longest_word(sentence)) return result"},{"question":"# Coding Assessment Question **Context**: Array manipulation is a common task in programming and data analysis. Being able to effectively transform, filter, and rearrange arrays is crucial for solving various computational problems. **Question**: Implement a function `filter_and_multiply(arr: List[int], k: int) -> List[int]` that filters out numbers from the array not divisible by `k` and multiplies the remaining numbers by a factor of `k`. **Function Signature**: ```python def filter_and_multiply(arr: List[int], k: int) -> List[int]: ``` **Input**: * `arr` (List[int]): A list of integers. * `k` (int): A positive integer. **Output**: * A list of integers, which includes numbers from the input array that are divisible by `k`, each multiplied by `k`. **Constraints**: * The input array will have at most 10,000 elements. * The integers in the array and `k` are within the range [-10^6, 10^6]. * The input parameters are valid and do not require additional validation. **Performance Requirements**: * The solution should run with time complexity O(n), where n is the number of elements in the input array. * The solution should use O(n) additional space at most. **Examples**: 1. `filter_and_multiply([3, 6, 9, 12, 15], 3) -> [9, 18, 27, 36, 45]` 2. `filter_and_multiply([2, 4, 5, 8, 10], 2) -> [4, 8, 16, 20]` 3. `filter_and_multiply([1, 2, 3, 4, 5], 1) -> [1, 2, 3, 4, 5]` 4. `filter_and_multiply([10, 20, 30, 40, 50], 4) -> [80, 160]` 5. `filter_and_multiply([], 5) -> []` **Notes**: * Ensure your function efficiently handles edge cases, such as an empty array. * The function should not alter the order of elements other than described. ---","solution":"from typing import List def filter_and_multiply(arr: List[int], k: int) -> List[int]: Filters out numbers from the array not divisible by k and multiplies the remaining numbers by a factor of k. Parameters: arr (List[int]): A list of integers. k (int): A positive integer. Returns: List[int]: A new list where each element is divisible by k and multiplied by k. return [x * k for x in arr if x % k == 0]"},{"question":"# Odd and Even Array Partition You need to write a function that partitions an array into two separate arrays: one containing even numbers and the other containing odd numbers. Each resultant array should maintain the relative order of the elements from the original array. Scenario Imagine you are working on a ticketing system where tickets have numeric identifiers. Some operations require the separation of even and odd ticket identifiers for processing in different queues. Implement a utility function that fulfills this requirement. Function Signature ```python def partition_even_odd(arr: list) -> tuple: This function receives a list of integers and partitions it into two lists: one containing even integers and the other containing odd integers, while maintaining the original order of elements. Args: arr (list): A list of integers to be partitioned. Returns: tuple: A tuple containing two lists, the first list with even integers and the second list with odd integers. ``` Input - A list of integers `arr`, which can be empty or contain positive and negative numbers. Output - A tuple containing two lists: - The first list contains all the even integers from the original list in the same order. - The second list contains all the odd integers from the original list in the same order. Examples ```python >>> partition_even_odd([1, 2, 3, 4, 5, 6]) ([2, 4, 6], [1, 3, 5]) >>> partition_even_odd([11, 22, 33, 44, 55]) ([22, 44], [11, 33, 55]) >>> partition_even_odd([0, -1, -2, 3, -4]) ([0, -2, -4], [-1, 3]) >>> partition_even_odd([]) ([], []) ``` Requirements - The function should run in linear time O(n), where n is the length of the input list. - Do not use additional space for the output other than the two resultant lists. Tips - Iterate through the list and separate numbers into even and odd lists based on their divisibility by 2. - Ensure to handle edge cases like empty input list. Implement the function `partition_even_odd` and test it with appropriate inputs.","solution":"def partition_even_odd(arr): Partitions an array into two arrays: one with even numbers and one with odd numbers. Args: arr (list): A list of integers to be partitioned. Returns: tuple: A tuple containing two lists; the first list with even integers and the second list with odd integers. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return (even, odd)"},{"question":"# Problem Statement Given a string containing only the characters \'a\', \'b\', and \'c\', transform the string so that no two neighboring characters are the same. Write a function `transform_string(s: str) -> str` that modifies the string according to this rule. If it is not possible to transform the string in such a way, return the string \\"Impossible\\". Input - `s`: A string consisting only of the characters \'a\', \'b\', and \'c\'. The length of the string will be between `1` and `10^5`. Output - A string where no two adjacent characters are the same. If it is not possible to create such a string, return \\"Impossible\\". Constraints - The string length is in the range `1 <= len(s) <= 100000`. - The string contains only the characters \'a\', \'b\', and \'c\'. Example 1 ```python s = \\"abba\\" print(transform_string(s)) # Output: \\"abab\\" ``` Example 2 ```python s = \\"aa\\" print(transform_string(s)) # Output: \\"Impossible\\" ``` Example 3 ```python s = \\"abcabc\\" print(transform_string(s)) # Output: \\"abcabc\\" ``` Requirements - Your solution should be efficient in terms of time complexity to handle strings up to length 100000. Explanation For Example 1, the string \\"abba\\" can be transformed to \\"abab\\" or \\"baba\\", where no two adjacent characters are the same. Hence, \\"abab\\" is a valid transformation. For Example 2, there is no way to rearrange \\"aa\\" such that no two adjacent characters are the same, so the solution is \\"Impossible\\".","solution":"def transform_string(s: str) -> str: from collections import Counter import heapq # Count the occurrences of each character count = Counter(s) # If any character count is more than (n+1)/2, it\'s impossible to rearrange n = len(s) if any(v > (n + 1) // 2 for v in count.values()): return \\"Impossible\\" # Create a max heap max_heap = [(-v, k) for k, v in count.items()] heapq.heapify(max_heap) result = [] prev_char = None prev_count = 0 while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Add the previous char back to the heap if it still has remains if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the prev_char and prev_count prev_char = char prev_count = count + 1 return \'\'.join(result)"},{"question":"# Coding Assessment Question Context: You are tasked with developing a feature for a company\'s e-commerce platform, which involves determining the optimal arrangement of items to be displayed on the homepage. The goal is to maximize the visibility of high-priority items. Each item has a priority level, and the homepage has a limited number of slots. Higher priority items should be displayed before lower priority ones. If two items have the same priority, they should be displayed in the order they appear in the input list. Task: Implement a function `optimal_display(items, slots)` that takes a list of tuples, where each tuple contains an item\'s ID and its priority level, and an integer representing the number of available slots on the homepage. The function should return a list of item IDs that maximizes the visibility, following the above rules. Function Signature: ```python def optimal_display(items: list[tuple[int, int]], slots: int) -> list[int]: ``` Input: - `items`: A list of tuples, where each tuple contains two integers: the item\'s ID (`1 ≤ ID ≤ 10^5`) and its priority level (`1 ≤ priority ≤ 10^4`). - `slots`: An integer representing the number of available slots on the homepage (`0 ≤ slots ≤ len(items)`). Output: - A list of integers representing the IDs of the items that should be displayed on the homepage. Examples: ```python assert optimal_display([(1, 5), (2, 3), (3, 10), (4, 1)], 2) == [3, 1] assert optimal_display([(10, 2), (11, 4), (12, 4), (13, 1)], 3) == [11, 12, 10] assert optimal_display([(5, 9), (6, 8), (7, 6)], 1) == [5] assert optimal_display([(15, 3), (16, 3)], 2) == [15, 16] assert optimal_display([], 0) == [] ``` Constraints: - The function should have a time complexity of ( O(n log n) ) due to sorting and a space complexity of ( O(n) ). **Performance Considerations**: Ensure that the function efficiently handles large lists of items and correctly prioritizes and orders items based on the given criteria. Notes: - Use a stable sorting algorithm to ensure the relative order of items with the same priority is maintained. - Consider edge cases such as an empty list of items or when the number of slots is zero.","solution":"def optimal_display(items, slots): Returns a list of item IDs to be displayed on the homepage, maximizing visibility by priority. # Sort items by priority in descending order, and by their appearance order if priorities are same. sorted_items = sorted(items, key=lambda x: (-x[1], items.index(x))) # Get the top \'slots\' number of items result = [item[0] for item in sorted_items[:slots]] return result"},{"question":"# Question You are tasked with implementing a function that compresses a list of strings by eliminating redundant characters while maintaining readability and decompression capability. Your goal is to provide a lossless compression method that reduces the amount of repetitive data in a given list of strings. # Function Specification **Task**: * Write a function `compress_strings` that compresses a list of strings. * Implement another function `decompress_strings` that decompresses it back to the original list. **Functions to Implement**: ```python def compress_strings(string_list: list) -> list: pass def decompress_strings(compressed_list: list) -> list: pass ``` **Parameters**: * `compress_strings`: * `string_list` (list): A list of strings to be compressed. * `decompress_strings`: * `compressed_list` (list): A list of strings that have been compressed using the `compress_strings` method. **Returns**: * `compress_strings`: * A compressed list of strings. * `decompress_strings`: * The original list of strings recovered from the `compressed_list`. # Constraints: * The functions should handle lists of up to 10,000 strings efficiently. * Assume all strings consist of printable ASCII characters. * Ensure that the original list is accurately reconstructed by `decompress_strings`. # Examples: ```python # Compressing strings orig_list = [\\"hello\\", \\"heeeeellloooooo\\", \\"h-e-l-l-o\\"] compressed_list = compress_strings(orig_list) # Output to a compressed representation that reduces redundancy while maintaining readability assert compressed_list == [\'h1e4l2o6\', \'h-e-l-l-o\'] # Decompressing strings assert decompress_strings(compressed_list) == orig_list ``` # Implementation Notes: * Design a compression method that effectively captures repetitive patterns in strings without compromising decompression integrity. * Consider using character counts to represent repeated sequences (e.g., \'aaaaa\' compresses to \'a5\'). * For single characters or non-repetitive sequences, maintain the readability of the string in the compressed output. * Ensure the decompression method reverses the compression correctly and efficiently. # Performance Considerations: * Optimize the compression operation by minimizing the complexity of repeated character detection. * Optimize the decompression operation to accurately reconstruct the original list in linear time.","solution":"def compress_strings(string_list): def compress_string(s): if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: compressed.append(f\\"{s[i - 1]}{count}\\") else: compressed.append(s[i - 1]) count = 1 if count > 1: compressed.append(f\\"{s[-1]}{count}\\") else: compressed.append(s[-1]) return \'\'.join(compressed) return [compress_string(s) for s in string_list] def decompress_strings(compressed_list): def decompress_string(s): decompressed = [] i = 0 while i < len(s): if i + 1 < len(s) and s[i + 1].isdigit(): j = i + 1 count = 0 while j < len(s) and s[j].isdigit(): count = count * 10 + int(s[j]) j += 1 decompressed.append(s[i] * count) i = j else: decompressed.append(s[i]) i += 1 return \'\'.join(decompressed) return [decompress_string(s) for s in compressed_list]"},{"question":"# Coding Assessment Question Scenario You are given a database of users where each user record consists of a unique user identifier and the number of minutes they have been active on a platform. The data is structured in a dictionary where keys are the user IDs and values are the number of minutes active. Your task is to determine the top `k` users based on their activity (number of minutes active). Problem Statement Implement a function, `top_k_users(activity_data: Dict[int, int], k: int) -> List[int]`, that returns a list of user IDs corresponding to the top `k` users with the highest activity. Constraints * `activity_data` dictionary will contain between `1` and `1000` users. * Each user ID is a unique integer. * Each activity count is a non-negative integer. * `k` will always be a positive integer and `1 <= k <= len(activity_data)`. Input * A dictionary `activity_data` where keys are user IDs (integers) and values are minutes active (non-negative integers). * An integer `k` specifying the number of top users to return. Output * A list of integers representing user IDs of the top `k` users by activity. Example ```python def top_k_users(activity_data: Dict[int, int], k: int) -> List[int]: # Your implementation here # Example Usages: activity_data = {1: 300, 2: 599, 3: 150, 4: 470, 5: 690} print(top_k_users(activity_data, 3)) # Output: [5, 2, 4] or [2, 5, 4] depending on the sorting order of users with same minutes activity_data = {101: 120, 202: 85, 303: 400, 404: 150} print(top_k_users(activity_data, 2)) # Output: [303, 404] or [404, 303] depending on the implementation ``` Requirements Your solution should handle ties properly by ensuring that when multiple users have the same activity time, their order in the result is consistent with how they appeared in the input initially (stable sorting). Additionally, aim to provide an efficient solution that can handle the upper limits of the input constraints.","solution":"from typing import Dict, List def top_k_users(activity_data: Dict[int, int], k: int) -> List[int]: Returns a list of user IDs corresponding to the top k users with the highest activity. :param activity_data: Dictionary where keys are user IDs and values are minutes active :param k: Number of top users to return :return: List of user IDs of the top k users by activity # Sort the dictionary items by minutes active in descending order while maintaining stability for ties sorted_users = sorted(activity_data.items(), key=lambda item: item[1], reverse=True) # Extract the top k user IDs top_k_user_ids = [user_id for user_id, _ in sorted_users[:k]] return top_k_user_ids"},{"question":"# Problem Statement: You are provided with an undirected graph represented by an adjacency list. Your task is to implement a function that finds all connected components of the graph and returns each component as a list of vertices. A connected component is a set of vertices in which each pair of vertices is connected by paths. # Function Signature: ```python def find_connected_components(graph): :param graph: A dictionary where the keys are vertex identifiers and the values are lists of adjacent vertices. :return: A list of lists, where each inner list represents a connected component containing vertex identifiers. # Example graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: [] } print(find_connected_components(graph)) # Expected Output: # [[0, 1, 2], [3, 4], [5]] ``` # Input: 1. **graph**: A dictionary where the keys are vertices and the values are lists of adjacent vertices. # Output: 1. A list of lists, where each inner list represents one of the connected components in the graph. # Constraints: 1. 1 <= number of vertices <= 1000 2. The vertex identifiers will be integers starting from 0 up to (number of vertices - 1). # Notes: - Each vertex identifier is unique within the input graph. - Ensure to account for graphs that may be entirely disconnected (i.e., each vertex is its own component). - The order of vertices in the connected components is not important, but each component should be distinct and contain all its respective vertices.","solution":"def find_connected_components(graph): Finds all connected components in an undirected graph. :param graph: A dictionary where the keys are vertex identifiers and the values are lists of adjacent vertices. :return: A list of lists, where each inner list represents a connected component containing vertex identifiers. def dfs(node, visited, component): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, component) visited = set() components = [] for vertex in graph: if vertex not in visited: component = [] dfs(vertex, visited, component) components.append(component) return components"},{"question":"# Matrix Perimeter Sum Calculation You are given a square matrix, and your task is to calculate the sum of the elements along its perimeter. # Objectives - Write a function `matrix_perimeter_sum` that computes the sum of the elements on the perimeter of a given square matrix. - The function should take a single two-dimensional array (list of lists in Python) representing the matrix as input and return an integer representing the perimeter sum. # Input Format - A single argument: `matrix` (a list of lists of integers), where `matrix` is a square matrix with dimensions `n x n`. # Output Format - An integer representing the sum of the perimeter elements of the given matrix. # Constraints - `1 <= n <= 1000` - Each element of the matrix is an integer within the Python integer range. # Performance Requirements - Ensure your solution has a time complexity of approximately O(n). # Example ```python def matrix_perimeter_sum(matrix): n = len(matrix) # Sum elements in the first and last rows perimeter_sum = sum(matrix[0]) + sum(matrix[-1]) # Sum elements in the first and last columns, excluding the corners perimeter_sum += sum(matrix[i][0] for i in range(1, n - 1)) + sum(matrix[i][-1] for i in range(1, n - 1)) return perimeter_sum # Example usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(matrix_perimeter_sum(matrix)) # Output: 30 ``` # Notes - The corners of the matrix (top-left, top-right, bottom-left, bottom-right) should be included only once in the perimeter sum. - Consider edge cases such as a single-element matrix (1x1), where the perimeter sum is the single element itself.","solution":"def matrix_perimeter_sum(matrix): n = len(matrix) if n == 1: return matrix[0][0] # Sum elements in the first and last rows perimeter_sum = sum(matrix[0]) + sum(matrix[-1]) # Sum elements in the first and last columns, excluding the corners perimeter_sum += sum(matrix[i][0] for i in range(1, n - 1)) + sum(matrix[i][-1] for i in range(1, n - 1)) return perimeter_sum"},{"question":"# Context You are building a small command-line application for maintaining tasks. Each task has a name, a priority level (from 1 to 5), and a completion status. You need to implement functionality to add, list, and mark tasks as completed. # Task Create a class `TaskManager` that helps in managing tasks. Implement methods to add new tasks, list all tasks, and mark tasks as completed. # Requirements * Your class should include: - An `__init__` method to initialize an empty list of tasks. - An `add_task` method that takes two parameters: the task name (a string) and the priority level (an integer). It should raise a `ValueError` if the priority level is not between 1 and 5 inclusive. - A `list_tasks` method that returns a list of all tasks with their name, priority level, and completion status. - A `complete_task` method that takes the task name and marks it as completed. It should raise a `ValueError` if the task does not exist. # Class Signature ```python class TaskManager: def __init__(self): pass def add_task(self, name: str, priority: int): pass def list_tasks(self) -> list: pass def complete_task(self, name: str): pass ``` # Example Usage ```python >>> task_manager = TaskManager() >>> task_manager.add_task(\\"Buy groceries\\", 3) >>> task_manager.add_task(\\"Complete assignment\\", 5) >>> task_manager.list_tasks() [{\'name\': \'Buy groceries\', \'priority\': 3, \'completed\': False}, {\'name\': \'Complete assignment\', \'priority\': 5, \'completed\': False}] >>> task_manager.complete_task(\\"Buy groceries\\") >>> task_manager.list_tasks() [{\'name\': \'Buy groceries\', \'priority\': 3, \'completed\': True}, {\'name\': \'Complete assignment\', \'priority\': 5, \'completed\': False}] >>> task_manager.complete_task(\\"Go to gym\\") Traceback (most recent call last): ... ValueError: Task not found >>> task_manager.add_task(\\"Walk the dog\\", 6) Traceback (most recent call last): ... ValueError: Priority level should be between 1 and 5 ``` # Constraints and Considerations * Ensure appropriate docstrings and error handling. * Use appropriate data structures to handle the tasks efficiently. * Consider edge cases such as marking already completed tasks or adding duplicate tasks.","solution":"class TaskManager: def __init__(self): Initializes a new TaskManager instance with an empty task list. self.tasks = [] def add_task(self, name: str, priority: int): Adds a new task with the given name and priority level. Arguments: name -- the name of the task priority -- the priority level of the task (must be between 1 and 5 inclusive) Raises: ValueError -- if the priority level is not between 1 and 5 if priority < 1 or priority > 5: raise ValueError(\\"Priority level should be between 1 and 5\\") self.tasks.append({\'name\': name, \'priority\': priority, \'completed\': False}) def list_tasks(self) -> list: Returns a list of all tasks with their name, priority level, and completion status. Returns: A list of dictionaries where each dictionary represents a task. return self.tasks def complete_task(self, name: str): Marks a task as completed by its name. Arguments: name -- the name of the task to be marked as completed Raises: ValueError -- if the task with the given name does not exist for task in self.tasks: if task[\'name\'] == name: task[\'completed\'] = True return raise ValueError(\\"Task not found\\")"},{"question":"# Question: Design a function that, given a series of times when stock prices were recorded and the corresponding prices, determines the maximum profit that can be made by buying and then subsequently selling the stock within a given range of times. Function Signature ```python def max_profit_within_range(prices: dict, start_time: str, end_time: str) -> float: pass ``` Input - `prices` (dict): A dictionary where keys are time stamps in \'HH:MM\' format (24-hour clock) and values are the stock prices (positive floats) at those times. - `start_time` (str): A time stamp in \'HH:MM\' format denoting the start of the time range. - `end_time` (str): A time stamp in \'HH:MM\' format denoting the end of the time range. Output - `float`: The maximum profit that can be achieved by buying and then subsequently selling the stock within the given range of times. Constraints - The `start_time` will always be less than or equal to `end_time`. - All time stamps in `prices` will be within a single day. - There will be at least 2 time stamps within the specified range. Example Input: ```python prices = {\'09:00\': 100.0, \'10:00\': 105.0, \'11:00\': 102.0, \'12:00\': 110.0, \'13:00\': 107.0} start_time = \'09:00\' end_time = \'12:00\' ``` Output: ```python profit = 10.0 ``` Input: ```python prices = {\'09:00\': 100.0, \'10:30\': 98.0, \'11:45\': 102.0, \'12:30\': 105.0, \'14:00\': 106.0} start_time = \'10:00\' end_time = \'12:30\' ``` Output: ```python profit = 7.0 ``` Notes - Ensure the function considers only the time stamps within the specified range (inclusive). - If no profit can be made, the function should return 0.0. - Handle edge cases where prices do not fluctuate or where the highest price occurs before the lowest price within the range.","solution":"def max_profit_within_range(prices: dict, start_time: str, end_time: str) -> float: Determines the maximum profit that can be made by buying and then subsequently selling the stock within a given range of times. Parameters: prices (dict): A dictionary where keys are time stamps in \'HH:MM\' format (24-hour clock) and values are the stock prices (positive floats) at those times. start_time (str): A time stamp in \'HH:MM\' format denoting the start of the time range. end_time (str): A time stamp in \'HH:MM\' format denoting the end of the time range. Returns: float: The maximum profit that can be achieved by buying and then subsequently selling the stock within the given range of times. filtered_prices = {time: price for time, price in prices.items() if start_time <= time <= end_time} times_sorted = sorted(filtered_prices.keys()) if not times_sorted or len(times_sorted) < 2: return 0.0 min_price = float(\'inf\') max_profit = 0.0 for time in times_sorted: current_price = filtered_prices[time] if current_price < min_price: min_price = current_price else: max_profit = max(max_profit, current_price - min_price) return max_profit"},{"question":"# Coding Assessment Question: Longest Increasing Subsequence Scenario As a software engineer at a tech company, you are required to develop a feature that can identify trends in data over time. Specifically, your task is to implement a function that finds the longest increasing subsequence within a list of data points, which is crucial for trend analysis and forecasting. Problem Statement Write a function `longest_increasing_subsequence(arr: List[int]) -> int` that takes a list of integers and returns the length of the longest increasing subsequence. Use dynamic programming to achieve an optimal solution. Expected Input and Output Formats * **Input**: - List of integers `arr` (0 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6) * **Output**: - Single integer representing the length of the longest increasing subsequence. Constraints 1. The list can be empty, in which case the function should return 0. 2. Use dynamic programming or an optimized approach to ensure efficient computation. 3. The solution must handle large lists within a reasonable time frame. Examples ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 # Explanation: The longest increasing subsequence is [2, 3, 7, 101]. >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 # Explanation: The longest increasing subsequence is [0, 1, 2, 3]. >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 # Explanation: The longest increasing subsequence is [7]. >>> longest_increasing_subsequence([]) 0 # Explanation: The list is empty, so the longest increasing subsequence length is 0. ``` Performance Requirements * Your solution should execute efficiently for lists with lengths up to 10^4. Instructions * Define the function `longest_increasing_subsequence(arr: List[int]) -> int` in a code block. * Ensure the function handles the constraints and edge cases effectively. * Optimize for performance to meet the execution time requirement. Implementation Plan 1. **Dynamic Programming**: Use a dynamic programming approach to build the solution. 2. **Edge Cases**: Handle edge cases such as an empty list and list with all identical elements. 3. **Testing**: Provide example test cases to validate the implementation.","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will be storing the length of LIS ending at index i max_len = 1 for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) max_len = max(max_len, dp[i]) return max_len"},{"question":"# Zoo Inventory Management System You are given an incomplete implementation of a class to manage a zoo\'s inventory. Your task is to complete this class to handle animals and their quantities in the zoo with appropriate methods. Class Definition ```python class ZooInventory: A class to manage the zoo\'s inventory of animals. def __init__(self): Initialize an empty inventory. self.inventory = {} def add_animal(self, species: str, count: int) -> None: Add animals of a particular species to the inventory. Parameters: species (str): The species of the animal. count (int): The number of animals being added. Returns: None def get_count(self, species: str) -> int: Retrieve the count of a particular species in the inventory. Parameters: species (str): The species of the animal. Returns: int: The count of animals of the specified species in the inventory. def total_animals(self) -> int: Compute the total number of animals in the zoo. Returns: int: The total number of animals. ``` Tasks 1. Implement the `add_animal` method to add animals to the inventory. If the species already exists, increment its count by the provided number. If it doesn\'t exist, add the species with the given count. 2. Implement the `get_count` method to return the count of a specified species. If the species does not exist, return 0. 3. Implement the `total_animals` method to return the total number of animals in all species combined. Example Usage ```python zoo = ZooInventory() zoo.add_animal(\\"Lion\\", 4) zoo.add_animal(\\"Tiger\\", 2) zoo.add_animal(\\"Lion\\", 1) print(zoo.get_count(\\"Lion\\")) # Output: 5 print(zoo.get_count(\\"Tiger\\")) # Output: 2 print(zoo.get_count(\\"Bear\\")) # Output: 0 print(zoo.total_animals()) # Output: 7 ``` Implement the `ZooInventory` class with the provided specifications.","solution":"class ZooInventory: A class to manage the zoo\'s inventory of animals. def __init__(self): Initialize an empty inventory. self.inventory = {} def add_animal(self, species: str, count: int) -> None: Add animals of a particular species to the inventory. Parameters: species (str): The species of the animal. count (int): The number of animals being added. Returns: None if species in self.inventory: self.inventory[species] += count else: self.inventory[species] = count def get_count(self, species: str) -> int: Retrieve the count of a particular species in the inventory. Parameters: species (str): The species of the animal. Returns: int: The count of animals of the specified species in the inventory. return self.inventory.get(species, 0) def total_animals(self) -> int: Compute the total number of animals in the zoo. Returns: int: The total number of animals. return sum(self.inventory.values())"},{"question":"# Encrypting and Decrypting Messages You have been asked to create a pair of functions that can encrypt and decrypt messages using a simple substitution cipher. For the encryption, each letter in the input text should be replaced by the letter that is `n` positions forward in the alphabet. The decryption should reverse this process. Function Signatures ```python def encrypt_message(message: str, n: int) -> str: def decrypt_message(encrypted_message: str, n: int) -> str: ``` Input: - `message` (str): The message to be encrypted, consisting of lowercase letters only. - `n` (int): The number of positions to shift each letter in the alphabet, an integer between 1 and 25. Output: - `encrypt_message` returns the encrypted message as a string. - `decrypt_message` returns the original message by reversing the encryption. Constraints: - Only lowercase English alphabet letters (`a-z`) should be handled, no spaces or punctuation. - Each letter should be shifted by exactly `n` positions. Examples: ```python encrypt_message(\\"hello\\", 3) # Returns \\"khoor\\" decrypt_message(\\"khoor\\", 3) # Returns \\"hello\\" ``` Notes: - Remember to handle the wrap-around from \'z\' to \'a\' appropriately when shifting letters. - Your functions should be efficient and maintain the original order of letters while only shifting their positions.","solution":"def encrypt_message(message: str, n: int) -> str: encrypted_message = \'\' for char in message: new_position = (ord(char) - ord(\'a\') + n) % 26 new_char = chr(new_position + ord(\'a\')) encrypted_message += new_char return encrypted_message def decrypt_message(encrypted_message: str, n: int) -> str: decrypted_message = \'\' for char in encrypted_message: new_position = (ord(char) - ord(\'a\') - n) % 26 new_char = chr(new_position + ord(\'a\')) decrypted_message += new_char return decrypted_message"},{"question":"# Implementation Question: Validate and Extract Unique Emails **Problem Statement**: You are given a list of email addresses that might contain duplicates and invalid formats. Write a function `extract_unique_valid_emails` that performs the following tasks: 1. Validate each email address using the general pattern `local_part@domain`. 2. Ignore the case of the email addresses while searching for duplicates. 3. Retain only unique and valid email addresses in the output. 4. An email is considered valid if it contains only alphanumeric characters, dots (`.`), or plus signs (`+`) in the local part, and only alphanumeric characters and dots in the domain. **Function Signature**: ```python def extract_unique_valid_emails(email_list: list) -> list: Extracts and validates unique emails from a provided list. Parameters: email_list (list): The list of email addresses to be validated and cleaned. Returns: list: A list of unique, valid email addresses in their original case. Raises: ValueError: When the input is not a list or contains non-string elements. pass ``` **Input/Output Examples**: ```python >>> extract_unique_valid_emails([\\"user@example.com\\", \\"user@example.com\\", \\"USER@EXAMPLE.com\\", \\"admin@site.com\\", \\"admin@site.com\\"]) [\'user@example.com\', \'admin@site.com\'] >>> extract_unique_valid_emails([\\"invalidemail@\\", \\"valid.email@domain.com\\", \\"Valid.Email@DOMAIN.COM\\", \\"another@valid.com\\"]) [\'valid.email@domain.com\', \'another@valid.com\'] >>> extract_unique_valid_emails([\\"local@domain\\", \\"1234@5678.com\\", \\"John.Doe@example.com\\", \\"john.doe@example.com\\"]) [\'local@domain\', \'1234@5678.com\', \'John.Doe@example.com\'] >>> extract_unique_valid_emails([\\"person+test@domain.com\\", \\"person@domain.com\\"]) [\'person+test@domain.com\', \'person@domain.com\'] >>> extract_unique_valid_emails([\\"Invalid.OPEN@\\", \\"valid@domain.COM\\"]) [\'valid@domain.COM\'] >>> extract_unique_valid_emails([]) [] ``` **Constraints**: * The input must be a list of strings. * The length of the input list will be between 0 and 10^4 email addresses. * An email\'s domain can only contain alphanumeric characters and dots. * An email\'s local part can contain alphanumeric characters, dots, and plus signs. * Except for the alphanumeric validation, avoid strict email format validation rules to ensure simplicity. * The function should be case-insensitive for duplicates but case-sensitive for output order. # Hints: 1. Use regular expressions to validate the format of email addresses. 2. Use a set to track unique emails in a case-insensitive manner. 3. Ensure proper handling of non-string elements in the input if present.","solution":"import re def extract_unique_valid_emails(email_list): Extracts and validates unique emails from a provided list. Parameters: email_list (list): The list of email addresses to be validated and cleaned. Returns: list: A list of unique, valid email addresses in their original case. Raises: ValueError: When the input is not a list or contains non-string elements. if not isinstance(email_list, list): raise ValueError(\\"Input must be a list\\") for email in email_list: if not isinstance(email, str): raise ValueError(\\"All elements in the input list must be strings\\") # Regular expression pattern for validating email addresses email_pattern = re.compile(r\'^[a-zA-Z0-9.+]+@[a-zA-Z0-9.]+\') # To keep track of unique emails in a case-insensitive manner seen_emails = set() unique_emails = [] for email in email_list: # Convert email to lower case for comparison lower_case_email = email.lower() if email_pattern.match(email) and lower_case_email not in seen_emails: seen_emails.add(lower_case_email) unique_emails.append(email) return unique_emails"},{"question":"Graph Traversal and Shortest Path # Background: Graph traversal algorithms such as Breadth-First Search (BFS) and Depth-First Search (DFS) are fundamental approaches to exploring all the vertices and edges of a graph. These algorithms form the basis for more complex graph algorithms, including those used to find the shortest path between nodes. # Problem Statement: You are required to implement a function that finds the shortest path between two nodes in an unweighted graph using the Breadth-First Search (BFS) algorithm. The graph is represented as an adjacency list. # Function Signature: ```python def shortest_path(graph: dict, start: int, end: int) -> list: :param graph: A dictionary representing the adjacency list of the graph. Keys are nodes, and values are lists of adjacent nodes. :param start: The starting node for the path. :param end: The target node for the path. :return: A list representing the shortest path from the start node to the end node, including both. If no path exists, return an empty list. ``` # Requirements: 1. Implement the `shortest_path` function that: - Uses the BFS algorithm to find the shortest path from `start` to `end`. - Returns the nodes in the path as a list, starting with the `start` node and ending with the `end` node. - Returns an empty list if there is no path between `start` and `end`. 2. Handle cases where either the `start` or `end` nodes do not exist in the graph. 3. Ensure the function handles cyclical and disconnected graphs efficiently. # Constraints: - The graph is represented as an adjacency list where each node is a key, and the value is a list of its adjacent nodes. - Nodes are unique integers. - The graph does not contain parallel edges or self-loops. - The graph may be disconnected. # Example: ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4, 5], 4: [2, 3, 5], 5: [3, 4] } path = shortest_path(graph, 1, 5) print(path) # Output: [1, 3, 5] ``` This function should find the shortest path `[1, 3, 5]` in the given graph from node `1` to node `5` using the BFS algorithm. # Note: * Ensure the implementation efficiently handles large graphs. * Consider edge cases such as nodes that do not exist, empty graphs, and situations where no path exists between the given nodes.","solution":"from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Uses BFS to find the shortest path in an unweighted graph. :param graph: A dictionary representing the adjacency list of the graph. Keys are nodes, and values are lists of adjacent nodes. :param start: The starting node for the path. :param end: The target node for the path. :return: A list representing the shortest path from the start node to the end node, including both. If no path exists, return an empty list. if start not in graph or end not in graph: return [] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Problem Statement: Factorial with Input Validation You are required to implement a function `validated_factorial` that calculates the factorial of a given non-negative integer. The function should handle invalid inputs by raising appropriate errors. The function signature is as follows: ```python def validated_factorial(n: int) -> int: pass ``` # Function Signature: ```python def validated_factorial(n: int) -> int: Computes the factorial of a non-negative integer. Parameters: n (int): The input non-negative integer whose factorial is to be calculated. Returns: int: The factorial of the input integer n. Raises: ValueError: If the input is a negative integer. TypeError: If the input is not an integer. pass ``` # Input: - A single parameter `n`, which is a non-negative integer. # Output: - Returns the factorial of the given integer `n`. # Constraints: - The function should only accept non-negative integers as input. - The function should raise a `TypeError` if the input is not an integer. - The function should raise a `ValueError` if the input is a negative integer. # Examples: ```python >>> validated_factorial(5) 120 >>> validated_factorial(0) 1 >>> validated_factorial(3) 6 >>> validated_factorial(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> validated_factorial(1.5) Traceback (most recent call last): ... TypeError: Input must be an integer >>> validated_factorial(\\"10\\") Traceback (most recent call last): ... TypeError: Input must be an integer ``` # Additional Notes: - Ensure the solution is implemented using an iterative approach. - Include test cases that cover typical, boundary, and invalid input scenarios.","solution":"def validated_factorial(n: int) -> int: Computes the factorial of a non-negative integer. Parameters: n (int): The input non-negative integer whose factorial is to be calculated. Returns: int: The factorial of the input integer n. Raises: ValueError: If the input is a negative integer. TypeError: If the input is not an integer. if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Question: Implementation of a Robust Algorithm to Balance Resource Allocation in Cloud Infrastructure **Context**: You are overseeing a cloud-based application that dynamically allocates computational resources (like CPU, GPU, and RAM) to multiple running services based on their usage patterns. Each service has these resources allocated and needs to maximize the performance within its allocated budget. You need to implement an algorithm that distributes the total available resources optimally to the services to achieve the best overall performance. Assume that each service\'s performance can be calculated based on a predefined function dependent on the resource allocation. **Task**: 1. Write a class `Service` that represents an individual service. It should have properties for `name`, `cpu_budget`, `gpu_budget`, `ram_budget`, and a method `performance(self)` that returns the performance generated by this service based on its allocated resources using a predefined function. 2. Write the method `optimize_resource_allocation` that performs the optimization to distribute the total available resources (CPU, GPU, RAM) across the given services to maximize the total performance generated. **Implementation**: 1. Define the `Service` class: - `__init__(self, name: str, cpu_budget: float, gpu_budget: float, ram_budget: float, performance_function)`, where `performance_function` is a function to compute the performance based on the resource allocation. - `performance(self)` method to calculate and return the performance. 2. Define the function `optimize_resource_allocation`: - `optimize_resource_allocation(services: List[Service], total_cpu: float, total_gpu: float, total_ram: float, epsilon: float) -> List[Service]` - Perform optimization by distributing the total available resources to maximize the total performance. **Constraints**: - The resources (CPU, GPU, RAM) allocated to each service should always be between 0 and their respective totals (total_cpu, total_gpu, total_ram). - The total of all individual services\' resources should not exceed their respective total allocations. - Assume the `performance_function` for each service is bounded and continuous. **Expected Input/Output**: - **Input**: - A list of `Service` objects. - `total_cpu`: A float representing the total CPU resources available. - `total_gpu`: A float representing the total GPU resources available. - `total_ram`: A float representing the total RAM resources available. - `epsilon`: A float representing the allowable error margin for the optimization. - **Output**: - A list of `Service` objects with updated resource allocations maximizing the total performance. ```python from typing import List, Callable class Service: def __init__(self, name: str, cpu_budget: float, gpu_budget: float, ram_budget: float, performance_function: Callable[[float, float, float], float]): self.name = name self.cpu_budget = cpu_budget self.gpu_budget = gpu_budget self.ram_budget = ram_budget self.performance_function = performance_function def performance(self) -> float: return self.performance_function(self.cpu_budget, self.gpu_budget, self.ram_budget) def optimize_resource_allocation(services: List[Service], total_cpu: float, total_gpu: float, total_ram: float, epsilon: float) -> List[Service]: # Implementation goes here pass # Example performance functions def performance_function_1(cpu: float, gpu: float, ram: float) -> float: return 2 * cpu ** 0.5 + 3 * gpu ** 0.5 + 1 * ram ** 0.5 def performance_function_2(cpu: float, gpu: float, ram: float) -> float: return 4 * (cpu / (cpu + 1)) + 5 * (gpu / (gpu + 1)) + 2 * (ram / (ram + 1)) # Main function to test code if __name__ == \\"__main__\\": services = [ Service(\\"Service A\\", 10, 5, 15, performance_function_1), Service(\\"Service B\\", 20, 10, 30, performance_function_2), Service(\\"Service C\\", 15, 8, 25, performance_function_1) ] optimized_services = optimize_resource_allocation(services, total_cpu=50, total_gpu=25, total_ram=70, epsilon=0.01) for service in optimized_services: print(f\\"Service: {service.name}, CPU: {service.cpu_budget}, GPU: {service.gpu_budget}, RAM: {service.ram_budget}, Performance: {service.performance()}\\") ``` This question assesses the understanding of resource allocation optimization within the context of cloud infrastructure, incorporating object-oriented design, optimizing algorithms, and performance evaluation.","solution":"from typing import List, Callable import numpy as np from scipy.optimize import minimize class Service: def __init__(self, name: str, cpu_budget: float, gpu_budget: float, ram_budget: float, performance_function: Callable[[float, float, float], float]): self.name = name self.cpu_budget = cpu_budget self.gpu_budget = gpu_budget self.ram_budget = ram_budget self.performance_function = performance_function def performance(self) -> float: return self.performance_function(self.cpu_budget, self.gpu_budget, self.ram_budget) def optimize_resource_allocation(services: List[Service], total_cpu: float, total_gpu: float, total_ram: float, epsilon: float) -> List[Service]: num_services = len(services) def total_performance(x): performance = 0 for i in range(num_services): cpu = x[3*i] gpu = x[3*i + 1] ram = x[3*i + 2] performance += services[i].performance_function(cpu, gpu, ram) return -performance # to maximize performance, minimize the negative of performance constraints = [] # Constraints for the total resource allocations constraints.append({\'type\': \'eq\', \'fun\': lambda x: np.sum(x[::3]) - total_cpu}) constraints.append({\'type\': \'eq\', \'fun\': lambda x: np.sum(x[1::3]) - total_gpu}) constraints.append({\'type\': \'eq\', \'fun\': lambda x: np.sum(x[2::3]) - total_ram}) # Constraints for the individual resource bounds bounds = [(0, total_cpu) for _ in range(num_services)] + [(0, total_gpu) for _ in range(num_services)] + [(0, total_ram) for _ in range(num_services)] initial_guess = [service.cpu_budget for service in services] + [service.gpu_budget for service in services] + [service.ram_budget for service in services] result = minimize(total_performance, initial_guess, constraints=constraints, bounds=bounds, tol=epsilon) optimized_x = result.x for i in range(num_services): services[i].cpu_budget = optimized_x[3*i] services[i].gpu_budget = optimized_x[3*i + 1] services[i].ram_budget = optimized_x[3*i + 2] return services"},{"question":"# Problem Statement You have been provided with a partially implemented `Matrix` class, designed to efficiently perform matrix multiplication and querying the sum of all elements in the matrix. Your task is to complete the implementation of this class. The class should support the following operations: * **Initialization**: Create a matrix with given dimensions and initialize elements to zero. * **`update(x: int, y: int, value: int) -> None`**: Set the value at position `(x, y)` to `value`. * **`multiply(other: Matrix) -> Matrix`**: Return a new `Matrix` which is the result of multiplying the current matrix by another matrix `other`. * **`sum() -> int`**: Return the sum of all elements in the matrix. # Function Signature Here\'s the function signature you should implement: ```python class Matrix: def __init__(self, rows: int, cols: int) -> None: pass def update(self, x: int, y: int, value: int) -> None: pass def multiply(self, other: \'Matrix\') -> \'Matrix\': pass def sum(self) -> int: pass ``` # Input/Output Format * The constructor takes two integers `rows` and `cols` representing the dimensions of the matrix. * The `update` method takes three integers `x`, `y`, and `value`, to set the element at position (x, y) to `value`. * The `multiply` method takes another `Matrix` object and returns a new `Matrix` object which is the result of the matrix multiplication. * The `sum` method returns an integer which is the sum of all elements in the matrix. # Constraints * `1 <= rows, cols <= 100` * `0 <= x < rows` * `0 <= y < cols` * `-10^9 <= value <= 10^9` * Matrix multiplication is only defined if the number of columns in the first matrix is equal to the number of rows in the second matrix. # Examples ```python # Example 1 m1 = Matrix(2, 2) m1.update(0, 0, 1) m1.update(0, 1, 2) m1.update(1, 0, 3) m1.update(1, 1, 4) print(m1.sum()) # Output: 10 m2 = Matrix(2, 2) m2.update(0, 0, 5) m2.update(0, 1, 6) m2.update(1, 0, 7) m2.update(1, 1, 8) result = m1.multiply(m2) print(result.update(0, 0, 0)) # Output: None (function update does not return) print(result.sum()) # Output: 70 (resulting matrix is [[19, 22], [43, 50]]) # Example 2 m3 = Matrix(1, 3) m3.update(0, 0, 1) m3.update(0, 1, 1) m3.update(0, 2, 1) m4 = Matrix(3, 1) m4.update(0, 0, 1) m4.update(1, 0, 1) m4.update(2, 0, 1) result = m3.multiply(m4) print(result.sum()) # Output: 3 (resulting matrix is [[3]]) ``` **Performance Requirement** Your solution should be efficient and handle matrix operations with reasonable performance given the constraints, targeting a solution that works within `O(N^3)` time per matrix multiplication where (N) is the matrix dimension.","solution":"class Matrix: def __init__(self, rows: int, cols: int) -> None: self.rows = rows self.cols = cols self.data = [[0 for _ in range(cols)] for _ in range(rows)] def update(self, x: int, y: int, value: int) -> None: self.data[x][y] = value def multiply(self, other: \'Matrix\') -> \'Matrix\': if self.cols != other.rows: raise ValueError(\\"Matrix dimensions do not allow multiplication\\") result = Matrix(self.rows, other.cols) for i in range(self.rows): for j in range(other.cols): cell_sum = 0 for k in range(self.cols): cell_sum += self.data[i][k] * other.data[k][j] result.update(i, j, cell_sum) return result def sum(self) -> int: return sum(sum(row) for row in self.data)"},{"question":"# Matrix Manipulation You need to implement a `Matrix` class that represents a 2D matrix and supports various matrix operations. Your implementation should be efficient and well-structured. Problem Statement Implement the `Matrix` class with the following capabilities: 1. **Initialization**: - A constructor that initializes the matrix with a given list of lists. Each sub-list should represent a row in the matrix. - If the input list is empty or rows have different lengths, raise a `ValueError`. 2. **Addition**: - Support addition of two matrices using the `+` operator. If the dimensions do not match, raise a `ValueError`. 3. **Subtraction**: - Support subtraction of two matrices using the `-` operator. If the dimensions do not match, raise a `ValueError`. 4. **Multiplication**: - Support multiplication of two matrices using the `*` operator. If the inner dimensions do not match, raise a `ValueError`. 5. **Transpose**: - Return the transpose of the matrix. 6. **Determinant**: - Calculate the determinant of the matrix if it is square. If the matrix is not square, raise a `ValueError`. 7. **Inverse**: - Compute the inverse of the matrix if it is square. If the matrix is not square or not invertible, raise a `ValueError`. 8. **String Representation**: - Return a human-readable string representation of the matrix. 9. **Equality**: - Support comparison of two matrices using `==` and `!=`. Example ```python m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) print(m1 + m2) # [[6, 8], [10, 12]] print(m1 - m2) # [[-4, -4], [-4, -4]] print(m1 * m2) # [[19, 22], [43, 50]] print(m1.transpose()) # [[1, 3], [2, 4]] print(m1.determinant()) # -2.0 print(m1.inverse()) # [[-2.0, 1.0], [1.5, -0.5]] print(m1 == Matrix([[1, 2], [3, 4]])) # True print(m1 != m2) # True ``` Constraints - Each element of the matrix can be any real number. - Matrix should be represented as a list of lists, where each sub-list represents a row and all rows must have the same number of columns. Implement the `Matrix` class with the described methods and properties.","solution":"class Matrix: def __init__(self, matrix): if not matrix or any(len(row) != len(matrix[0]) for row in matrix): raise ValueError(\\"Matrix must be non-empty and all rows must have the same length\\") self.matrix = matrix def __repr__(self): return \\"n\\".join(\\" \\".join(map(str, row)) for row in self.matrix) def __eq__(self, other): return self.matrix == other.matrix def __ne__(self, other): return not self == other def __add__(self, other): if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices dimensions do not match for addition\\") result = [ [ self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0])) ] for i in range(len(self.matrix)) ] return Matrix(result) def __sub__(self, other): if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices dimensions do not match for subtraction\\") result = [ [ self.matrix[i][j] - other.matrix[i][j] for j in range(len(self.matrix[0])) ] for i in range(len(self.matrix)) ] return Matrix(result) def __mul__(self, other): if len(self.matrix[0]) != len(other.matrix): raise ValueError(\\"Matrices dimensions do not match for multiplication\\") result = [ [ sum(self.matrix[i][k] * other.matrix[k][j] for k in range(len(self.matrix[0]))) for j in range(len(other.matrix[0])) ] for i in range(len(self.matrix)) ] return Matrix(result) def transpose(self): transposed = [ [self.matrix[j][i] for j in range(len(self.matrix))] for i in range(len(self.matrix[0])) ] return Matrix(transposed) def determinant(self): if len(self.matrix) != len(self.matrix[0]): raise ValueError(\\"Matrix is not square\\") def _determinant(matrix): if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): minor = [[matrix[i][j] for j in range(len(matrix)) if j != c] for i in range(1, len(matrix))] det += ((-1) ** c) * matrix[0][c] * _determinant(minor) return det return _determinant(self.matrix) def inverse(self): det = self.determinant() if det == 0: raise ValueError(\\"Matrix is not invertible\\") def _minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def _cofactor(matrix): cofactor_matrix = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor = _minor(matrix, r, c) cofactor = ((-1) ** (r + c)) * Matrix(minor).determinant() cofactor_row.append(cofactor) cofactor_matrix.append(cofactor_row) return cofactor_matrix cofactor_matrix = _cofactor(self.matrix) adjugate = Matrix(cofactor_matrix).transpose() return Matrix([[adjugate.matrix[i][j] / det for j in range(len(adjugate.matrix[0]))] for i in range(len(adjugate.matrix))])"},{"question":"Additional Question for Coding Assessment To test your understanding of dynamic programming and string manipulation, your function should meet the following requirements: # Function Signature ```python def find_common_subsequence(s1: str, s2: str) -> str: ``` # Input - `s1`: A string of arbitrary length. - `s2`: Another string of arbitrary length. # Output - Returns a string representing the longest common subsequence of `s1` and `s2`. # Constraints - Both input strings will contain only ASCII characters. - Focus on optimizing time and space complexity for potentially large inputs. # Example ```python assert find_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == \\"GTAB\\" assert find_common_subsequence(\\"ABCDGH\\", \\"AEDFHR\\") == \\"ADH\\" assert find_common_subsequence(\\"ABC\\", \\"AC\\") == \\"AC\\" ``` **Note**: The solution should handle various edge cases, such as one or both strings being empty, strings with no common subsequences, and varying string lengths. Ensure that your code is optimized for performance while maintaining readability and correctness.","solution":"def find_common_subsequence(s1: str, s2: str) -> str: Returns the longest common subsequence of s1 and s2 using dynamic programming. m, n = len(s1), len(s2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom-up for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence from dp array. i, j = m, n lcs = [] while i > 0 and j > 0: if s1[i - 1] == s2[j - 1]: lcs.append(s1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return \'\'.join(reversed(lcs))"},{"question":"# Balanced Binary Search Tree Verification You are given a Binary Search Tree (BST) and tasked with verifying if it is height-balanced. A height-balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Your job is to implement the necessary functionalities to: 1. **Determine if the BST is height-balanced**: Add a method to check if the BST is height-balanced. 2. **Provide the height of the BST**: Add a method to calculate the height of the BST. Function Specifications 1. **is_balanced(self) -> bool**: - Checks whether the BST is height-balanced. - Returns `True` if the BST is height-balanced, otherwise `False`. 2. **get_height(self) -> int**: - Calculates the height of the BST. - Returns an integer representing the height of the BST. Input and Output - Both functions are member functions of the `TreeNode` class, representing the root of the BST. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(tree: TreeNode) -> bool: # Your code here pass def get_height(tree: TreeNode) -> int: # Your code here pass # Example usage root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert is_balanced(root) == True assert get_height(root) == 3 unbalanced_tree = TreeNode(1) unbalanced_tree.right = TreeNode(2) unbalanced_tree.right.right = TreeNode(3) assert is_balanced(unbalanced_tree) == False assert get_height(unbalanced_tree) == 3 ``` Constraints - The number of nodes in the BST will not exceed 10^4. - The value of each node in the BST is unique. - Assume the BST is correctly constructed and does not contain duplicate values. **Note**: Do not change the existing methods\' signatures in the provided `TreeNode` class. Only add new methods or helper functions as required.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(self) -> bool: def check_balance_and_height(node): if not node: return True, 0 left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = 1 + max(left_height, right_height) return balanced, height balanced, _ = check_balance_and_height(self) return balanced def get_height(self) -> int: def compute_height(node): if not node: return 0 left_height = compute_height(node.left) right_height = compute_height(node.right) return 1 + max(left_height, right_height) return compute_height(self)"},{"question":"# Coding Assessment Question Scenario You are a software developer working on a data processing application. One of the tasks you need to complete involves verifying and transforming date strings in various formats into a consistent format. Task Write a function `standardize_date_format(dates)` that takes a list of date strings in various formats and returns a list of them all transformed into the \\"YYYY-MM-DD\\" format. The date formats you need to handle include: - \\"MM/DD/YYYY\\" - \\"MM-DD-YYYY\\" - \\"DD/MM/YYYY\\" - \\"DD-MM-YYYY\\" Ensure that any invalid date strings in the input list are converted to `\\"Invalid Date\\"` in the output list. Function Signature ```python def standardize_date_format(dates: list[str]) -> list[str]: ``` Input - `dates` (list of str): A list of date strings to be standardized. Each string can be in one of the specified formats or might be invalid. Output - (list of str): A list of date strings all converted to the \\"YYYY-MM-DD\\" format or `\\"Invalid Date\\"` for strings that were not valid dates. Constraints - The function should raise a `ValueError` if `dates` is not a list of strings. - Ensure the function performs adequately for a list containing up to 1,000 date strings. Example ```python >>> standardize_date_format([\\"12/31/2021\\", \\"31-12-2021\\", \\"2021/12/31\\", \\"15/08/2022\\", \\"08-15-2022\\"]) [\'2021-12-31\', \'2021-12-31\', \'Invalid Date\', \'2022-08-15\', \'Invalid Date\'] >>> standardize_date_format([\\"01/01/2020\\", \\"01-01-2020\\", \\"2020-01-01\\", \\"31/02/2020\\", \\"31-02-2020\\"]) [\'2020-01-01\', \'2020-01-01\', \'Invalid Date\', \'Invalid Date\', \'Invalid Date\'] >>> standardize_date_format(\\"01/01/2020\\") Traceback (most recent call last): ... ValueError: Input must be a list of strings >>> standardize_date_format([123, \\"01/01/2020\\"]) Traceback (most recent call last): ... ValueError: Input must be a list of strings ``` Note that your implementation should correctly handle invalid inputs and edge cases as demonstrated in the example.","solution":"from datetime import datetime def standardize_date_format(dates): Transforms given date strings in various formats to the \\"YYYY-MM-DD\\" format. Invalid date strings are converted to \\"Invalid Date\\". if not isinstance(dates, list) or not all(isinstance(date, str) for date in dates): raise ValueError(\\"Input must be a list of strings\\") output = [] date_formats = [\\"%m/%d/%Y\\", \\"%m-%d-%Y\\", \\"%d/%m/%Y\\", \\"%d-%m-%Y\\"] for date_str in dates: standardized = \\"Invalid Date\\" for date_format in date_formats: try: parsed_date = datetime.strptime(date_str, date_format) standardized = parsed_date.strftime(\\"%Y-%m-%d\\") break except ValueError: continue output.append(standardized) return output"},{"question":"# Implement a Simple Cache Mechanism Caching is an essential technique used to temporarily store frequently accessed data for quick retrieval, which significantly improves the performance of applications. In this task, you are required to implement a simple cache mechanism for efficient data storage and retrieval. Implement a class `SimpleCache` that provides the following functionalities: 1. **Initializing the Cache**: - `__init__(self, capacity: int)`: Initializes the cache with a given capacity. The cache should use a dictionary to store key-value pairs and maintain the order of insertion. 2. **Inserting and Retrieving Data**: - `put(self, key: int, value: int) -> None`: Inserts a key-value pair into the cache. If the cache exceeds its capacity, it should evict the least recently added key-value pair. - `get(self, key: int) -> int`: Retrieves the value associated with the given key from the cache. Returns `-1` if the key is not found. 3. **Additional Constraints**: - Raise a `ValueError` if the capacity specified during initialization is less than or equal to 0. - Ensure the cache maintains the Least Recently Added (LRA) order during eviction. **Requirements**: - **Input**: - `capacity` is an integer (capacity > 0) specified during the initialization of the `SimpleCache`. - `put` and `get` have integer parameters (`key` and `value`). - **Output**: - `put` returns `None`. - `get` returns an integer value associated with the key or `-1` if the key does not exist. ```python class SimpleCache: def __init__(self, capacity: int): Initialize the cache with a given capacity. Args: capacity (int): The maximum number of items the cache can hold. Raises: ValueError: If the capacity is less than or equal to 0. pass def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. Evict the least recently added item if the cache exceeds its set capacity. Args: key (int): Key identifying the item. value (int): Value to be associated with the key. pass def get(self, key: int) -> int: Retrieve the value associated with the given key. Args: key (int): Key for which to retrieve the value. Returns: int: Value associated with the key, or -1 if the key does not exist. pass ``` # Example Usage: ```python cache = SimpleCache(capacity=2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Returns 1 cache.put(3, 3) # Evicts key 2 since capacity is 2 and cache is full print(cache.get(2)) # Returns -1 (not found as it was evicted) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` Write the implementation of the class `SimpleCache` and ensure it handles edge cases and maintains the specified constraints effectively.","solution":"class SimpleCache: def __init__(self, capacity: int): Initialize the cache with a given capacity. Args: capacity (int): The maximum number of items the cache can hold. Raises: ValueError: If the capacity is less than or equal to 0. if capacity <= 0: raise ValueError(\\"Capacity must be greater than 0.\\") self.capacity = capacity self.cache = {} self.order = [] def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. Evict the least recently added item if the cache exceeds its set capacity. Args: key (int): Key identifying the item. value (int): Value to be associated with the key. if key in self.cache: # Remove the old occurrence of the key self.order.remove(key) elif len(self.cache) >= self.capacity: # Evict the least recently added (first in the order list) oldest_key = self.order.pop(0) del self.cache[oldest_key] self.cache[key] = value self.order.append(key) def get(self, key: int) -> int: Retrieve the value associated with the given key. Args: key (int): Key for which to retrieve the value. Returns: int: Value associated with the key, or -1 if the key does not exist. return self.cache.get(key, -1)"},{"question":"Context: You are given a **Matrix** class, and you need to extend its functionality with additional operations that are often required in matrix computations. This will test your knowledge of working with 2D arrays and your ability to implement these operations efficiently. # Task: 1. Implement a method `transpose(self) -> \'Matrix\'` that returns the transpose of the matrix. 2. Implement a method `trace(self) -> Any` that returns the trace of the matrix. Assuming that it\'s square, the trace is defined as the sum of the main diagonal elements. 3. Implement a method `multiply_by_factor(self, factor: Any) -> \'Matrix\'` that returns a new matrix with each element multiplied by the given factor. # Function Signature: ```python def transpose(self) -> \'Matrix\': Returns the transpose of the matrix. def trace(self) -> Any: Returns the trace of the matrix. def multiply_by_factor(self, factor: Any) -> \'Matrix\': Returns a new matrix with each element multiplied by the given factor. ``` # Input & Output Formats: * The `transpose` method returns a new instance of the Matrix class that is the transpose of the original. * The `trace` method returns a numeric value representing the sum of the diagonal elements. * The `multiply_by_factor` method takes a numeric factor and returns a new instance of the Matrix class with each element multiplied by that factor. # Constraints: * The `transpose` method should work for non-square matrices as well. * The `trace` method should enforce that the matrix is square and handle non-square matrices gracefully by raising a suitable exception. * The `multiply_by_factor` method should handle different numeric types consistently and return a matrix of the same type as the input. # Performance Requirements: * Transposing should have a time complexity of O(m * n), where m is the number of rows and n is the number of columns. * Calculating the trace should have a time complexity of O(n), with n being the size of the main diagonal. * Multiplying by a factor should iterate through the matrix elements only once, maintaining an O(m * n) complexity. # Example: ```python # Initialize matrix mtx = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) # Transpose the matrix transposed = mtx.transpose() print(transposed) # Expected Output: Matrix([ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ]) # Get the trace of the matrix trace_value = mtx.trace() print(trace_value) # Expected Output: 15 # Multiply matrix by 2 multiplied = mtx.multiply_by_factor(2) print(multiplied) # Expected Output: Matrix([ # [2, 4, 6], # [8, 10, 12], # [14, 16, 18] # ]) ```","solution":"class Matrix: def __init__(self, data): self.data = data def transpose(self) -> \'Matrix\': transposed_data = list(map(list, zip(*self.data))) return Matrix(transposed_data) def trace(self) -> int: if len(self.data) != len(self.data[0]): raise ValueError(\\"Trace can only be calculated for square matrices.\\") return sum(self.data[i][i] for i in range(len(self.data))) def multiply_by_factor(self, factor: int) -> \'Matrix\': multiplied_data = [[element * factor for element in row] for row in self.data] return Matrix(multiplied_data)"},{"question":"# Problem Statement You are given a string word. Your task is to check if the word can be spelled out using characters from a given list of allowable characters. Each character in the given list can only be used once. # Function Signature ```python def can_spell_word(word: str, characters: List[str]) -> bool: pass ``` # Input * `word`: A string consisting of lowercase English letters (a-z). The length of the string is between 1 and 100, inclusive. * `characters`: A list of lowercase English letters (a-z). The length of the list is between 1 and 100, inclusive. # Output * The function should return a boolean value: * `True` if the word can be spelled out using the characters in the given list (each character can be used only once). * `False` otherwise. # Constraints * The length of the string `word` will be in the range `[1, 100]`. * The length of the list `characters` will be in the range `[1, 100]`. * Only lowercase English letters (a-z) are used in both the string and the list. # Examples Example 1: ```python word = \\"apple\\" characters = [\\"e\\", \\"l\\", \\"p\\", \\"a\\", \\"p\\"] assert can_spell_word(word, characters) == True ``` Example 2: ```python word = \\"banana\\" characters = [\\"b\\", \\"a\\", \\"n\\"] assert can_spell_word(word, characters) == False ``` Example 3: ```python word = \\"hello\\" characters = [\\"o\\", \\"l\\", \\"h\\", \\"e\\", \\"l\\", \\"w\\"] assert can_spell_word(word, characters) == True ``` # Important Considerations * **Character Usage**: Ensure that each character in the list of `characters` can only be used once when attempting to spell out the `word`. * **Edge Cases**: Verify behavior when the list of `characters` does not contain sufficient characters to form the `word`, or when characters are repeated within `word` and must appear the correct number of times in `characters`. Your implementation must handle all edge cases effectively and return correct results based on the provided constraints.","solution":"from typing import List def can_spell_word(word: str, characters: List[str]) -> bool: char_count = {} # Count the number of each character in the list of characters for char in characters: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check if we can form the word using the characters for char in word: if char not in char_count or char_count[char] == 0: return False char_count[char] -= 1 return True"},{"question":"# Coding Question: File Synchronization with Retry Mechanism **Scenario**: You are developing an automation script that synchronizes a local directory with a remote server. The script should copy new or updated files from the local directory to the corresponding location on the remote server. Your synchronization function must be resilient to transient errors, such as temporary network outages or server issues. **Requirements**: 1. Implement a function `sync_files_with_retry(local_dir: str, remote_dir: str, max_retries: int = 3) -> None` that synchronizes files from a local directory to a remote directory. 2. The function should retry the file copy operation up to `max_retries` times if it encounters any network-related issues or server errors. 3. If all attempts fail, the function should raise a `RuntimeError` with a message indicating the failure to synchronize the files. **Input**: * `local_dir` - The path to the local directory containing the files to be synchronized (a non-empty string). * `remote_dir` - The path to the remote directory where the files should be copied (a non-empty string). * `max_retries` - The maximum number of retry attempts (an integer, default is 3). **Output**: * None if all files are synchronized successfully. * Raises a `RuntimeError` with an appropriate message after unsuccessful attempts. **Constraints**: * Both `local_dir` and `remote_dir` are valid directory paths. * The environment has necessary permissions and access to both local and remote directories. * Network-related errors should be simulated using a custom exception `NetworkError` during development and testing. **Example**: ```python import os import shutil class NetworkError(Exception): Custom exception for simulating network errors. pass def sync_files_with_retry(local_dir: str, remote_dir: str, max_retries: int = 3) -> None: # Your implementation here pass # Example use case try: sync_files_with_retry(\\"/path/to/local/dir\\", \\"/path/to/remote/dir\\") print(\\"Files synchronized successfully\\") except RuntimeError as e: print(e) ``` **Hints**: * Use Python\'s `os` and `shutil` libraries for file operations. * Consider implementing a simple delay between retries using `time.sleep`. * Network-related errors can be simulated by raising the `NetworkError`. This question assesses the ability to implement resilient file synchronization with retry logic, appropriate for testing file handling, error processing, and robust automation scripting techniques.","solution":"import os import shutil import time class NetworkError(Exception): Custom exception for simulating network errors. pass def sync_files_with_retry(local_dir: str, remote_dir: str, max_retries: int = 3) -> None: def sync_files(): try: for root, _, files in os.walk(local_dir): for file in files: local_file_path = os.path.join(root, file) rel_path = os.path.relpath(local_file_path, local_dir) remote_file_path = os.path.join(remote_dir, rel_path) remote_file_dir = os.path.dirname(remote_file_path) if not os.path.exists(remote_file_dir): os.makedirs(remote_file_dir) shutil.copy2(local_file_path, remote_file_path) except Exception as e: raise NetworkError(\\"Network error occurred while copying files\\") from e attempt = 0 while attempt < max_retries: try: sync_files() return except NetworkError: attempt += 1 if attempt >= max_retries: raise RuntimeError(f\\"Failed to synchronize files after {max_retries} attempts.\\") time.sleep(1) # Test example if __name__ == \\"__main__\\": try: sync_files_with_retry(\\"local_test_dir\\", \\"remote_test_dir\\") print(\\"Files synchronized successfully\\") except RuntimeError as e: print(e)"},{"question":"# Problem Statement You are given a collection of words and a list of characters with a specified frequency for each character. Your task is to implement a function `max_word_construct(words, characters)` that finds the word from the list that can be constructed using the given characters the most number of times. If multiple words have the same maximum possible constructs, return the lexicographically smallest word. # Function Signature ```python def max_word_construct(words: List[str], characters: Dict[str, int]) -> str: ... ``` # Input * `words`: A list of strings where each string is a word. * `characters`: A dictionary where the keys are characters and values are integers representing the frequency of each character available. # Output * A string representing the word that can be assembled the most number of times based on the given characters. If no words can be formed, return an empty string. # Constraints * The `words` list can contain between 0 and 1000 words. * Each word in the `words` list has a length between 1 and 20 characters. * The `characters` dictionary can have between 0 and 26 keys (one for each letter) with integer values ranging from 1 to 1000. * All characters in the words and dictionary are lowercase English letters. # Example ```python words = [\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"] characters = {\'a\': 6, \'p\': 2, \'l\': 1, \'e\': 2, \'b\': 1, \'n\': 2, \'o\': 1, \'r\': 1, \'g\': 1} print(max_word_construct(words, characters)) # Output: \\"apple\\" words = [\\"cat\\", \\"hat\\", \\"bat\\"] characters = {\'a\': 2, \'c\': 1, \'h\': 1, \'t\': 1} print(max_word_construct(words, characters)) # Output: \\"cat\\" ``` # Guidelines * Your function should include error handling for the case where the `characters` dictionary is empty. * For each word in the `words` list, calculate how many times it can be formed with the given characters. * Ensure your function efficiently handles the maximum constraints.","solution":"from collections import Counter from typing import List, Dict def max_word_construct(words: List[str], characters: Dict[str, int]) -> str: def word_count(word, char_count): word_counter = Counter(word) construct_count = float(\'inf\') for char, count in word_counter.items(): if char in char_count: construct_count = min(construct_count, char_count[char] // count) else: return 0 return construct_count max_constructs = 0 best_word = \\"\\" for word in words: constructs = word_count(word, characters) if constructs > max_constructs: max_constructs = constructs best_word = word elif constructs == max_constructs: best_word = min(best_word, word) return best_word"},{"question":"# Coding Assessment Question Problem Context: You are given an array of integers and a target sum. Your task is to check if there are two different numbers in the array that add up to the target sum. Task: Write a function that checks if any two distinct elements in the array sum up to the target value and return them as a tuple. If multiple pairs exist, return any one of them. If no such pair exists, return an empty tuple. Function Signature: ```python def find_pair_with_sum(arr: List[int], target: int) -> Tuple[int, int]: ``` Input: * A list of integers `arr` (1 ≤ len(arr) ≤ 10^4, -10^9 ≤ arr[i] ≤ 10^9): The array of integers. * An integer `target` (-10^9 ≤ target ≤ 10^9): The target sum. Output: * A tuple of two integers that add up to the target sum if such a pair exists, otherwise an empty tuple. Constraints: * Ensure the solution is efficient and runs in reasonable time for large values within the constraint. Example: ```python >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([3, 2, 4], 6) (2, 4) >>> find_pair_with_sum([3, 3], 6) (3, 3) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) () ``` Notes: * The function should return the two numbers in ascending order, i.e., the smaller number should come first in the tuple. * It\'s important to optimize the solution for better performance. * Handle edge cases such as single-element arrays and arrays where no pairs sum up to the target.","solution":"from typing import List, Tuple def find_pair_with_sum(arr: List[int], target: int) -> Tuple[int, int]: Finds two distinct elements in arr that sum up to target. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that add up to the target sum if such a pair exists, otherwise an empty tuple. seen = {} for num in arr: complement = target - num if complement in seen: return (min(num, complement), max(num, complement)) seen[num] = True return ()"},{"question":"# Sentence Reversal Function You have been given the task to implement a function that reverses the order of words in a given sentence but maintains the order of characters within the words themselves. The goal is to create a sentence where the words appear in the opposite sequence of the input sentence. Requirements 1. Implement the `reverse_sentence` function with the following signature: ```python def reverse_sentence(sentence: str) -> str: ``` 2. The function should take a single string `sentence` as input. 3. The function should return a new string where the words appear in the reverse order of the original sentence. 4. Ensure that there is exactly one space between each word in the output and no leading or trailing spaces. Example Scenarios ```python # Example usage of the reverse_sentence function. # Scenario 1 assert reverse_sentence(\\"Hello World\\") == \\"World Hello\\" # Scenario 2 assert reverse_sentence(\\"Data Science is amazing\\") == \\"amazing is Science Data\\" # Scenario 3 assert reverse_sentence(\\"Coding assessments are challenging but fun\\") == \\"fun but challenging are assessments Coding\\" # Scenario 4 assert reverse_sentence(\\"SingleWordTest\\") == \\"SingleWordTest\\" # Scenario 5 assert reverse_sentence(\\"\\") == \\"\\" ``` Testing Ensure your implementation passes the provided test cases to validate correctness.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence but maintains the order of characters within the words themselves. # Split the sentence into words words = sentence.split() # Reverse the order of words reversed_words = words[::-1] # Join the reversed words back into a sentence reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"# Question: Advanced Data Analysis on Time Series Data You are provided with a partially implemented `TimeSeries` class that supports various fundamental operations on time-series data. Enhance the `TimeSeries` class by adding the following features: 1. **Moving Average Calculation**: Implement a method `moving_average(self, window_size: int) -> list[float]` to calculate and return the moving average of the time-series data using a specified window size. 2. **Trend Detection**: Implement a method `detect_trend(self) -> str` to detect the overall trend of the time-series data. Return \\"upward\\" if the data shows an increasing trend, return \\"downward\\" if the data shows a decreasing trend, and return \\"no trend\\" if there is no clear trend. 3. **Seasonality Detection**: Implement a method `detect_seasonality(self) -> bool` to detect whether the time-series data exhibits seasonality. Return `True` if seasonality is detected, else return `False`. Input: - The provided `TimeSeries` class and its instance methods. Output: - For `moving_average(window_size)`, return a list of floats representing the moving averages. - For `detect_trend()`, return a string indicating the trend (\\"upward\\", \\"downward\\", or \\"no trend\\"). - For `detect_seasonality()`, return a boolean indicating the presence of seasonality. Constraints: - The time-series data is a list of up to 1000 float values. - The window size for moving average must be a positive integer less than or equal to the length of the time-series data. Example: ```python # Example usage: time_series = TimeSeries([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) # Moving Average with window size 3 print(time_series.moving_average(3)) # Output: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] # Detect Trend print(time_series.detect_trend()) # Output: \\"upward\\" # Detect Seasonality print(time_series.detect_seasonality()) # Output: False ``` Enhance the `TimeSeries` class to support advanced data analysis by implementing these methods.","solution":"class TimeSeries: def __init__(self, data: list[float]): self.data = data def moving_average(self, window_size: int) -> list[float]: if window_size <= 0 or window_size > len(self.data): raise ValueError(\\"window_size must be a positive integer less than or equal to the length of the data\\") moving_averages = [] for i in range(len(self.data) - window_size + 1): window = self.data[i:i + window_size] window_average = sum(window) / window_size moving_averages.append(window_average) return moving_averages def detect_trend(self) -> str: if len(self.data) < 2: return \\"no trend\\" increasing = all(x < y for x, y in zip(self.data, self.data[1:])) decreasing = all(x > y for x, y in zip(self.data, self.data[1:])) if increasing: return \\"upward\\" elif decreasing: return \\"downward\\" else: return \\"no trend\\" def detect_seasonality(self) -> bool: if len(self.data) < 4: return False quarter_length = len(self.data) // 4 seasonality_detected = False for i in range(quarter_length): season = [self.data[j] for j in range(i, len(self.data), quarter_length)] if len(season) > 1 and len(set(season)) == 1: seasonality_detected = True break return seasonality_detected"},{"question":"# Scenario You are developing a text processing tool that needs to efficiently find and count specified words in large documents. Implementing a robust search and counting algorithm is essential for maintaining the tool\'s performance. # Task You are required to write a function called `count_occurrences` that counts the number of times each target word appears in a given document. Your implementation must handle large data sets efficiently and use best coding practices. # Requirements * **Input**: - A string `document` (0 <= len(document) <= 10^6), e.g., `\\"hello world, hello\\"` - A list of target words `words` (0 <= len(words) <= 10^3), e.g., `[\\"hello\\", \\"world\\"]` * **Output**: - A dictionary with the target words as keys and their respective counts as values, e.g., `{\\"hello\\": 2, \\"world\\": 1}` * **Constraints**: - Avoid using Python built-in count functions directly for the primary logic. Here\'s the function signature: ```python def count_occurrences(document, words): pass ``` # Example ```python >>> count_occurrences(\\"hello world, hello\\", [\\"hello\\", \\"world\\"]) {\'hello\': 2, \'world\': 1} >>> count_occurrences(\\"\\", [\\"test\\"]) {\'test\': 0} ``` # Notes 1. Consider edge cases such as an empty document, targets not found in the document, and repeated words. 2. Implement helper functions if needed to keep your code clean and modular. 3. Ensure your code handles large inputs efficiently and provide inline documentation explaining your logic and approach.","solution":"def count_occurrences(document, words): Counts the occurrences of each word in the list `words` within the given `document`. Parameters: - document (str): The text to be searched. - words (list): List of words to count in the document. Returns: dict: Dictionary with words as keys and their counts as values. # Initialize a dictionary to store the counts of each word word_counts = {word: 0 for word in words} # Convert the document into individual words, ignoring punctuation and case sensitivity import re document_words = re.findall(r\'bw+b\', document.lower()) # Count each word in the document for word in document_words: if word in word_counts: word_counts[word] += 1 return word_counts"},{"question":"# Matrix Transposition Function Implement a function to transpose a given NxM matrix. The function should handle edge cases and follow performance constraints as detailed below. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose the given NxM matrix. ``` Input * A list of lists of integers `matrix` representing the NxM matrix. The dimensions of the input matrix could range from 0x0 to 1000x1000. Output * A new list of lists of integers representing the transpose of the input matrix. Constraints and Requirements * The function should perform the transpose operation in O(NxM) time complexity, where \'N\' is the number of rows and \'M\' is the number of columns in the matrix. * Space complexity should be O(NxM) to store the transposed matrix. * The function should handle cases where the input matrix is empty or has one or more dimensions of size zero. Example ```python # Example 1: matrix = [ [1, 2], [3, 4] ] # Expected Output: # [ # [2, 4], # [1, 3] # ] # Example 2: matrix = [ [] ] # Expected Output: # [ # [] # ] ``` Testing Design and include unittests to verify your implementation, ensuring to cover edge cases and validations for the specified requirements. ```python import unittest class TestTransposeMatrix(unittest.TestCase): def test_regular_matrix(self): self.assertEqual(transpose_matrix([[1, 2], [3, 4]]), [[2, 4], [1, 3]]) def test_single_element(self): self.assertEqual(transpose_matrix([[1]]), [[1]]) def test_empty_matrix(self): self.assertEqual(transpose_matrix([[]]), [[]]) def test_non_square_matrix(self): self.assertEqual(transpose_matrix([[1, 2, 3], [4, 5, 6]]), [[4, 5, 6], [1, 2, 3]]) if __name__ == \'__main__\': unittest.main() ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [[]] * len(matrix) num_rows = len(matrix) num_cols = len(matrix[0]) transposed_matrix = [[0] * num_rows for _ in range(num_cols)] for i in range(num_rows): for j in range(num_cols): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"# Remove K-digits to Form Smallest Number Background You are working as a software engineer on a project that involves processing large numeric strings. One of the tasks you have is to remove a certain number of digits from a string representation of a non-negative integer, in such a way that the remaining digits form the smallest possible number. Objective Implement a function `remove_k_digits` which, given a string representing a non-negative integer and an integer `k`, removes `k` digits from the string so that the resulting string is the smallest possible number. Input Format * A string `num` representing a non-negative integer (without any leading zeros) of length (1 leq |num| leq 10^5). * An integer `k` where (0 leq k leq |num|). Output Format * A string representing the smallest possible number after removing `k` digits. There should be no leading zeros in the output unless the resulting number is zero. Constraints * The solution must run in linear time (O(n)) where (n) is the length of the string. * Use at most linear space. Examples ```plaintext Example 1: Input: \\"1432219\\", 3 Output: \\"1219\\" Example 2: Input: \\"10200\\", 1 Output: \\"200\\" Example 3: Input: \\"10\\", 2 Output: \\"0\\" Example 4: Input: \\"7654321\\", 3 Output: \\"4321\\" ``` Implementation Requirements Write the function `remove_k_digits(num: str, k: int) -> str` which follows the specified input and output format. Implement an efficient algorithm leveraging a monotonic stack to achieve optimal performance.","solution":"def remove_k_digits(num: str, k: int) -> str: stack = [] for digit in num: while k and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still remaining removals to do while k: stack.pop() k -= 1 # Remove leading zeros and join stack to form result result = \'\'.join(stack).lstrip(\'0\') return result if result else \\"0\\""},{"question":"# Question: Rotate List Elements Given a list of integers and a non-negative integer `k`, write a function to rotate the list to the right by `k` steps. The operation should be performed in-place with O(1) extra space complexity if possible. The rotation means that each element of the list is shifted right by `k` positions. If `k` is greater than the length of the list, the rotation should be equivalent to `k % n` rotations, where `n` is the length of the list. # Function Signature ```python def rotate_list(nums: list, k: int) -> None: Arguments: nums: A list of integers. k: A non-negative integer representing the number of positions to rotate the list. Returns: The function returns nothing. The input list is modified in place. ``` # Expected Input and Output * **Input**: * `nums`: A list of integers (length n). * `k`: A non-negative integer. * **Output**: * The modified list will be returned in place. * **Constraints**: * The list of integers can have any length (0 ≤ n ≤ 10^5). * `k` is guaranteed to be a non-negative integer. # Example ```python >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> k = 3 >>> rotate_list(nums, k) >>> nums [5, 6, 7, 1, 2, 3, 4] ``` ```python >>> nums = [-1, -100, 3, 99] >>> k = 2 >>> rotate_list(nums, k) >>> nums [3, 99, -1, -100] ``` # Algorithm 1. Compute the effective number of rotations needed using `k % len(nums)` if `len(nums)` > 0. 2. If `k` is 0 or if `len(nums)` <= 1, the list remains unchanged. 3. Reverse the entire list. 4. Reverse the first `k` elements. 5. Reverse the remaining `n-k` elements to achieve the desired rotation. # Notes * Ensure your implementation efficiently handles edge cases, such as empty lists or `k` being zero. * The list should be modified in place with minimal additional space usage.","solution":"def rotate_list(nums: list, k: int) -> None: Rotates the list `nums` to the right by `k` steps. The operation is performed in-place. Arguments: nums: A list of integers. k: A non-negative integer representing the number of positions to rotate the list. Returns: The function returns nothing. The input list is modified in place. if not nums or k == 0: return n = len(nums) k = k % n # Reverse the entire list nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the remaining n - k elements nums[k:] = reversed(nums[k:])"},{"question":"# Problem Statement An array is said to be \\"rotated\\" if it is sorted in ascending order, then rotated from some pivot point. Therefore, a \\"rotated sorted array\\" is a sorted array that has been rotated. Your goal is to find the index of the smallest element in such an array. # Function Signature ```python def find_min_index(nums: list) -> int: Find the index of the smallest element in a rotated sorted array. Args: nums (list): A list of integers representing the rotated sorted array. Returns: int: The index of the smallest element in the array. ``` # Input * `nums`: A list of integers which represents the rotated sorted array. The array will contain at least one element and all elements are unique. # Output * An integer representing the index of the smallest element in the array. # Constraints * You need to implement an algorithm with O(log n) time complexity. # Examples ```python assert find_min_index([4, 5, 6, 7, 0, 1, 2]) == 4 assert find_min_index([10, 1, 2, 3, 4, 6, 8]) == 1 assert find_min_index([3, 4, 5, 1, 2]) == 3 assert find_min_index([11, 13, 15, 17]) == 0 ``` # Explanation * The first example\'s rotated sorted array `([4, 5, 6, 7, 0, 1, 2])` has the smallest element `0` at index `4`. * The second example\'s rotated sorted array `([10, 1, 2, 3, 4, 6, 8])` has the smallest element `1` at index `1`. * The third example\'s rotated sorted array `([3, 4, 5, 1, 2])` has the smallest element `1` at index `3`. * The fourth example\'s array `([11, 13, 15, 17])` does not appear rotated and the first element `11` is the smallest. # Additional Context To achieve the required O(log n) time complexity, consider using a modified binary search algorithm to find the index of the minimum element efficiently.","solution":"def find_min_index(nums: list) -> int: Find the index of the smallest element in a rotated sorted array. Args: nums (list): A list of integers representing the rotated sorted array. Returns: int: The index of the smallest element in the array. left, right = 0, len(nums) - 1 # If the array is not rotated (the smallest is at the start) if nums[left] <= nums[right]: return left while left <= right: mid = (left + right) // 2 # Check if mid+1 element is the smallest if nums[mid] > nums[mid + 1]: return mid + 1 # Check if mid element is the smallest if nums[mid - 1] > nums[mid]: return mid # If mid element is greater than the leftmost element, the smallest is on the right side if nums[mid] > nums[left]: left = mid + 1 else: right = mid - 1"},{"question":"# Coding Question You are given an array of integers and a target sum. Your task is to determine if there are two distinct integers in the array that add up to the target sum. If such a pair exists, return the indices of the two numbers. If no such pair exists, return an empty list. **Objective**: Create a function `two_sum(nums: List[int], target: int) -> List[int]` that takes a list of integers `nums` and a target integer `target`, and returns a list of two indices of the numbers in `nums` that add up to `target`. Input/Output Format * **Input**: - `nums` (list of integers): An array of integers (1 ≤ len(nums) ≤ 10^4). - `target` (integer): The target sum. * **Output**: - Return a list of two integers representing the indices of the numbers that add up to the target sum. If no such pair exists, return an empty list. Constraints - 1 ≤ len(nums) ≤ 10^4 - -10^9 ≤ nums[i] ≤ 10^9 - -10^9 ≤ target ≤ 10^9 **Performance Requirement**: - The solution should be efficient and ideally run in O(n) time complexity. Example ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) [] ``` **Instructions**: - Implement the function `two_sum(nums: List[int], target: int) -> List[int]` - The function should adhere to the input/output requirements and handle edge cases properly.","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in `nums` that add up to `target`. If no such numbers exist, returns an empty list. Parameters: nums (List[int]): A list of integers. target (int): The target sum. Returns: List[int]: A list containing two indices of the elements in `nums` that add up to `target`. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"**Context**: Matrix multiplication is a fundamental operation in many numerical and scientific computing applications, including graphics, machine learning, and high-performance computing. Efficiently implementing matrix multiplication can significantly improve the performance of these applications. **Objective**: Your task is to implement a function that performs matrix multiplication. Given two 2D matrices, compute the product of these matrices. Matrix multiplication involves the dot product of rows and columns from the input matrices. Implementing this function will help you understand the basics of linear algebra operations and the importance of optimizing such computations for large datasets. # Task Description: Implement the function `matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray` that takes in two 2D numpy arrays `A` and `B`, and returns the product matrix `C`, where C = A * B. # Input Format: *A single call of the function `matrix_multiplication` with two arguments: `A` and `B` (type: `numpy.ndarray`). Each input array is a 2D matrix with floating-point numbers. # Output Format: * Returns a `numpy.ndarray` which is the result of multiplying matrices `A` and `B`. # Constraints: 1. Each input matrix can have up to (10^6) elements. 2. The number of columns in matrix `A` should be equal to the number of rows in matrix `B`. # Examples: ```python import numpy as np # Example 1 A = np.array([[1, 2], [3, 4]]) B = np.array([[2, 0], [1, 3]]) print(matrix_multiplication(A, B)) # Output: [[4 6] # [10 12]] # Example 2 A = np.array([[1, 0, 2], [-1, 3, 1]]) B = np.array([[3, 1], [2, 1], [1, 0]]) print(matrix_multiplication(A, B)) # Output: [[5 1] # [4 2]] ``` ```python def matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: return np.dot(A, B) import numpy as np A = np.array([[1, 2], [3, 4]]) B = np.array([[2, 0], [1, 3]]) print(matrix_multiplication(A, B)) # Output: [[ 4 6] # [10 12]] A = np.array([[1, 0, 2], [-1, 3, 1]]) B = np.array([[3, 1], [2, 1], [1, 0]]) print(matrix_multiplication(A, B)) # Output: [[5 1] # [4 2]] ```","solution":"import numpy as np def matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: Returns the product of two 2D matrices A and B. Parameters: A (np.ndarray): 2D array representing matrix A B (np.ndarray): 2D array representing matrix B Returns: np.ndarray: The resulting matrix product of A and B return np.dot(A, B)"},{"question":"Array Manipulation Utility In many applications, you need to manipulate arrays efficiently. One common requirement is to perform a series of bulk addition operations on segments of an array, updating the array\'s values within specified ranges. Your task is to implement a class `ArrayManipulator` with a method that processes a series of range addition operations on an array. Specifically, this method should handle the following operations: 1. **range_add(arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]**: Given an array `arr` of integers and a list of operations, each represented as a tuple `(start, end, increment)`, perform the increment operation on all elements between the `start` and `end` indices, inclusive. The function should return the updated array. # Requirements: * The input `arr` will be a list of integers, representing the initial state of the array. * The input `operations` will be a list of tuples, where each tuple contains three integers: `start`, `end`, and `increment`. * You may assume that `start` and `end` are valid indices within the array. * The array will have at least one element, and the `operations` list will have at least one operation. # Example: ```python class ArrayManipulator: @staticmethod def range_add(arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: # Implement this method pass # Example Usage: initial_array = [1, 2, 3, 4, 5] operations = [(1, 3, 2), (0, 2, 1)] # After the first operation, the array becomes [1, 4, 5, 6, 5] # After the second operation, the array becomes [2, 5, 6, 6, 5] assert ArrayManipulator.range_add(initial_array, operations) == [2, 5, 6, 6, 5] ``` Implement the class `ArrayManipulator` with the specified method, ensuring that the operations are applied efficiently.","solution":"from typing import List, Tuple class ArrayManipulator: @staticmethod def range_add(arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: # Create a difference array initialized to zero diff = [0] * (len(arr) + 1) # Apply operations to the difference array for start, end, increment in operations: diff[start] += increment if end + 1 < len(arr): diff[end + 1] -= increment # Convert the difference array back to the original array current_increment = 0 for i in range(len(arr)): current_increment += diff[i] arr[i] += current_increment return arr"},{"question":"# Escape the Maze with Dijkstra Implement the Dijkstra algorithm in Python to find the shortest path through a maze represented by a grid. The maze consists of open cells and blocked cells. You will be provided with a 2D list representing the maze grid, where 0 represents an open cell that can be traversed, and 1 represents a blocked cell that cannot be traversed. Your task is to write a function `escape_maze` that finds the optimal path from the start cell to the goal cell. Function Signature ```python def escape_maze(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: ``` Input * `grid`: A 2D list of integers where 0 represents an open cell and 1 represents a blocked cell. * `start`: A tuple of integers representing the starting position `(x, y)` in the grid. * `goal`: A tuple of integers representing the goal position `(x, y)` in the grid. Output * A list of tuples representing the sequence of positions `(x, y)` from the start to the goal, forming the shortest path, or an empty list if no path is found. Constraints * The grid dimensions are `n x m`, where 1 ≤ n, m ≤ 1000. * The start and goal positions are guaranteed to be open cells (i.e., contain a 0). * The path can only move up, down, left, or right (no diagonal movement). Example ```python >>> grid = [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ] >>> start = (0, 0) >>> goal = (3, 3) >>> escape_maze(grid, start, goal) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (3, 3)] ``` Performance Requirements * The function should handle grids up to 1000x1000 efficiently. * Optimize for both time and space complexity to ensure the function can run on upper edge case inputs. Ensure the implemented function adheres to the constraints and efficiently finds the shortest path in the maze or determines that no path exists if it\'s impossible to reach the goal.","solution":"import heapq from typing import List, Tuple def is_valid_position(position, grid): r, c = position return 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 0 def escape_maze(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start_x, start_y = start goal_x, goal_y = goal dist = {start: 0} prev = {start: None} pq = [(0, start)] # (distance, (x, y)) while pq: current_distance, current_position = heapq.heappop(pq) if current_position == goal: path = [] while current_position: path.append(current_position) current_position = prev[current_position] return path[::-1] for direction in directions: neighbor = (current_position[0] + direction[0], current_position[1] + direction[1]) if is_valid_position(neighbor, grid): distance = current_distance + 1 if neighbor not in dist or distance < dist[neighbor]: dist[neighbor] = distance priority = distance heapq.heappush(pq, (priority, neighbor)) prev[neighbor] = current_position return [] # If there\'s no path to the goal"},{"question":"# Scenario Data analysis often involves performing cumulative operations on sequences of numbers. One common task is to accumulate the sum of values as they are processed. This is useful in scenarios like running totals in sales, cumulative distances in travel logs, and progressive total scores in games. # Task Write a Python function `cumulative_sum(numbers: List[int]) -> List[int]` that takes a list of integers and returns a new list where each element at index `i` is the sum of the numbers from index `0` to `i` of the input list. # Input Specifications * `numbers`: A list of integers, which can contain positive, zero, or negative values. # Output Specifications * Returns a list of integers where each element is the cumulative sum up to that index. # Constraints * The length of the list `numbers` will be between 0 and 10^5. * Each integer in the list will be between -10^9 and 10^9. # Example ```python >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([-1, -1, -1]) [-1, -2, -3] >>> cumulative_sum([]) [] >>> cumulative_sum([5, -2, 8]) [5, 3, 11] ``` # Requirements * Ensure the function handles an empty list by returning an empty list. * Take care of performance to handle the upper constraint efficiently.","solution":"from typing import List def cumulative_sum(numbers: List[int]) -> List[int]: Returns a list where each element at index `i` is the sum of the numbers from index `0` to `i` of the input list. if not numbers: return [] result = [0] * len(numbers) result[0] = numbers[0] for i in range(1, len(numbers)): result[i] = result[i-1] + numbers[i] return result"},{"question":"# Maze Solver with DFS **Scenario**: You are a software developer tasked with building a navigation system for an automated robot in a warehouse. The robot needs to find its way from a starting point to a target point in a predefined grid. The warehouse grid can have obstacles which the robot needs to navigate around. You need to implement a solution to find a path from the start point to the target point. # Problem Statement Implement a function `find_path` that uses the Depth-First Search (DFS) algorithm to determine a path from a starting point to a target point in a grid. If a path exists, the function should return a list of coordinates representing the path from the start to the target. If no path exists, return an empty list. **Function Signature** ```python def find_path(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]: pass ``` **Input/Output Format** * **Input**: - A 2D list `grid` representing the warehouse layout where `0` indicates an open cell and `1` indicates an obstacle. - A tuple `start` representing the starting coordinates (row, column). - A tuple `target` representing the target coordinates (row, column). * **Output**: - A list of tuples representing the path from the start to the target. Each tuple represents coordinates (row, column) in the grid. If no path exists, return an empty list. **Constraints** * The grid can be up to 100x100 cells in size. * The start and target coordinates are always within the grid bounds. * There will always be a start and a target point provided. * The grid may have multiple obstacles. # Constraints/Edge Cases to Consider 1. Path exists 2. No path exists 3. The start point is the same as the target point 4. Grid with no obstacles # Requirements Implement the `find_path` function using a Depth-First Search approach. Discuss any potential optimizations that could improve the efficiency of the pathfinding, especially for larger grids or grids with many obstacles. Consider the impact of different DFS strategies, such as iterative versus recursive implementations, on performance and stack overflow risks.","solution":"def find_path(grid, start, target): def dfs(current, path): if current == target: return path + [current] x, y = current visited.add(current) # Try all four directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] == 0: result = dfs((nx, ny), path + [current]) if result: return result visited.remove(current) return [] visited = set() return dfs(start, [])"},{"question":"# String Calculator Objective Implement a class `StringCalculator` to perform arithmetic operations on potentially large non-negative integers represented as strings. Background Computations involving very large integers can exceed the maximum limit that a typical integer type can handle. To circumvent this issue, we represent large numbers as strings and implement basic arithmetic operations manually. Task 1. Create a class `StringCalculator`. 2. Implement methods to: * Add two non-negative integers represented as strings. * Subtract one non-negative integer from another represented as strings, with the result being non-negative. * Multiply two non-negative integers represented as strings. 3. Consider leading zeros in results and eliminate them. Implementation Requirements 1. **Class Definition**: - `class StringCalculator:` 2. **Methods to Implement**: - `add(self, num1: str, num2: str) -> str` - `subtract(self, num1: str, num2: str) -> str` - `multiply(self, num1: str, num2: str) -> str` Function Signatures ```python class StringCalculator: def add(self, num1: str, num2: str) -> str: pass def subtract(self, num1: str, num2: str) -> str: pass def multiply(self, num1: str, num2: str) -> str: pass ``` Constraints 1. The input strings will represent non-negative integers with no leading zeros unless the string is \\"0\\". 2. The results should not contain leading zeros. 3. For subtract method, `num1` will be greater than or equal to `num2`. Example ```python string_calculator = StringCalculator() # Addition # num1 = \\"123\\" # num2 = \\"456\\" # result: \\"579\\" result = string_calculator.add(\\"123\\", \\"456\\") # Subtraction # num1 = \\"500\\" # num2 = \\"123\\" # result: \\"377\\" result = string_calculator.subtract(\\"500\\", \\"123\\") # Multiplication # num1 = \\"123\\" # num2 = \\"456\\" # result: \\"56088\\" result = string_calculator.multiply(\\"123\\", \\"456\\") ``` Notes - Ensure to handle varying lengths of input strings appropriately. - Provide appropriate error checking and handling where necessary. - You may assume both input strings are valid representations of non-negative integers.","solution":"class StringCalculator: def add(self, num1: str, num2: str) -> str: max_len = max(len(num1), len(num2)) num1 = num1.zfill(max_len) num2 = num2.zfill(max_len) carry = 0 result = [] for i in range(max_len - 1, -1, -1): digit_sum = int(num1[i]) + int(num2[i]) + carry carry = digit_sum // 10 result.append(str(digit_sum % 10)) if carry: result.append(str(carry)) return \'\'.join(result[::-1]) def subtract(self, num1: str, num2: str) -> str: max_len = max(len(num1), len(num2)) num1 = num1.zfill(max_len) num2 = num2.zfill(max_len) carry = 0 result = [] for i in range(max_len - 1, -1, -1): diff = int(num1[i]) - int(num2[i]) - carry if diff < 0: carry = 1 diff += 10 else: carry = 0 result.append(str(diff)) # Remove leading zeros while len(result) > 1 and result[-1] == \'0\': result.pop() return \'\'.join(result[::-1]) def multiply(self, num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): product = int(num1[i]) * int(num2[j]) p1 = i + j p2 = i + j + 1 sum_ = product + result[p2] result[p1] += sum_ // 10 result[p2] = sum_ % 10 # Stripping leading zeros while len(result) > 1 and result[0] == 0: result.pop(0) return \'\'.join(map(str, result))"},{"question":"# Implementation Question: Optimize Repeated String Concatenation **Problem Statement**: You are given a function `repeat_string_concatenation` that repeats and concatenates a given string `n` times. However, the current implementation uses the `+` operator inside a loop, which is inefficient for large values of `n`. Optimize this function to improve its performance for larger inputs by using a more efficient method of string concatenation. **Function Signature**: ```python def repeat_string_concatenation(s: str, n: int) -> str: Repeats and concatenates the input string `n` times efficiently. Parameters: s (str): The string to be repeated. n (int): The number of times to repeat the string. Returns: str: The resulting concatenated string. Raises: ValueError: When the input parameters are not of the expected types. pass ``` **Input/Output Examples**: ```python >>> repeat_string_concatenation(\\"abc\\", 3) \'abcabcabc\' >>> repeat_string_concatenation(\\"xyz\\", 0) \'\' >>> repeat_string_concatenation(\\"hello\\", 1) \'hello\' >>> repeat_string_concatenation(\\"a\\", 100000) <output is a string with \\"a\\" repeated 100000 times> >>> repeat_string_concatenation(123, 3) Traceback (most recent call last): ... ValueError: Expected string as first input, found <class \'int\'> >>> repeat_string_concatenation(\\"xyz\\", -1) Traceback (most recent call last): ... ValueError: The repeat count must be a non-negative integer. ``` **Constraints**: * The first input must be a string. * The second input must be a non-negative integer. * The length of the resulting string will be between 0 and 10^7 characters. # Hints: 1. Consider using the `str.join()` method or string multiplication for better performance. 2. Ensure to validate the input types and handle edge cases such as an empty string or a zero repetition count.","solution":"def repeat_string_concatenation(s: str, n: int) -> str: Repeats and concatenates the input string `n` times efficiently. Parameters: s (str): The string to be repeated. n (int): The number of times to repeat the string. Returns: str: The resulting concatenated string. Raises: ValueError: When the input parameters are not of the expected types. if not isinstance(s, str): raise ValueError(f\\"Expected string as first input, found {type(s)}\\") if not isinstance(n, int) or n < 0: raise ValueError(\\"The repeat count must be a non-negative integer.\\") return s * n"},{"question":"# Problem Statement A numeric string is said to have a balanced sum if the sum of its digits is the same for every possible substring of length `k`. Write a function that determines whether a given numeric string is a balanced sum string for any valid length `k`. # Detailed Requirements * Define a function `is_balanced_sum(s: str, k: int) -> bool` that checks if the given numeric string `s` has this property for the specified length `k`. * Iterate through all possible substrings of length `k` in `s`, calculate their digit sums, and compare them. * If all substrings have the same sum, return `True`; otherwise, return `False`. # Input and Output - **Input**: - `s`: A string consisting of numeric characters (1-9) with a length of `1 <= len(s) <= 1000`. - `k`: An integer representing the length of the substrings, where `1 <= k <= len(s)`. - **Output**: - A boolean value `True` or `False`. **Constraints**: 1. The function should handle: * Substring extraction and digit sum calculation efficiently * Comparisons of sums across multiple substrings * Large input lengths # Example Cases **Case 1:** ``` is_balanced_sum(\\"123123\\", 3) -> True ``` *Explanation*: The substrings of length `3` are \\"123\\", \\"231\\", and \\"312\\", all of which have the same sum of digits, 6. **Case 2:** ``` is_balanced_sum(\\"1234512345\\", 5) -> True ``` *Explanation*: The substrings of length `5` are \\"12345\\", \\"23451\\", \\"34512\\", and \\"45123\\". Each of these substrings has a sum of digits equal to 15. **Case 3:** ``` is_balanced_sum(\\"111222\\", 2) -> False ``` *Explanation*: The substrings of length `2` are \\"11\\", \\"11\\", \\"12\\", \\"22\\", and \\"22\\". The sums of digits are 2, 2, 3, 4, and 4 respectively, which are not the same. # Additional Notes: - Consider edge cases where `k` is 1 or equal to the length of the string `s`. Adjust sum comparison accordingly. - Ensure your implementation handles various input ranges and sizes efficiently.","solution":"def is_balanced_sum(s: str, k: int) -> bool: Checks if every possible substring of length `k` in the given numeric string `s` has the same sum of digits. if k == 1: return True # Calculate the sum of the first substring of length `k` first_sum = sum(int(s[i]) for i in range(k)) # Traverse the string and compare sums of other substrings of length `k` for i in range(1, len(s) - k + 1): current_sum = sum(int(s[j]) for j in range(i, i + k)) if current_sum != first_sum: return False return True"},{"question":"**Scenario**: You have been tasked with developing a module for a hotel management system that optimizes room bookings. The hotel has a limited number of rooms, and each booking request has a specific check-in and check-out date. The objective is to maximize the number of bookings while ensuring no overlap in room assignments for any given day. **Task**: Create a function `optimize_bookings(bookings: List[Tuple[int, int]], total_rooms: int) -> List[int]` that returns the indices of the booking requests that can be accommodated without overlaps, maximizing the total number of bookings. # Input * A list of tuples `bookings`: Each tuple contains two integers `(check_in, check_out)` representing the check-in and check-out dates (exclusive) of booking requests. The list may have up to 2000 booking requests. * An integer `total_rooms`: The total number of rooms available in the hotel. # Output * A list of integers representing the indices of the booking requests that can be accommodated without overlaps and maximizing the number of bookings. # Example ```python bookings = [(1, 4), (2, 5), (3, 6), (5, 8)] total_rooms = 2 optimized_requests = optimize_bookings(bookings, total_rooms) # Example Output: [0, 3, 1] or any other combination that fits the constraints ``` # Constraints: * Assume check-in and check-out dates are non-negative integers. * Check-out date is exclusive, meaning the room becomes available on the check-out date. * The function should effectively handle the input size and constraints to provide an optimal solution. # Note: - The booking indices should be returned in the same order as they appear in the original input list. - Ensure your solution is efficient, utilizing appropriate algorithms and data structures. Implement the function to display your comprehension and ability to handle complex booking schedules within given constraints.","solution":"from typing import List, Tuple def optimize_bookings(bookings: List[Tuple[int, int]], total_rooms: int) -> List[int]: Function to maximize the number of bookings for a hotel given a limited number of rooms. Inputs: - bookings: A list of tuples, where each tuple contains two integers (check_in, check_out) - total_rooms: An integer representing the total number of rooms available in the hotel Outputs: - A list of indices representing the booking requests that can be accommodated without overlaps. # Sort bookings by check-out time primarily and then by check-in time sorted_bookings = sorted(enumerate(bookings), key=lambda x: (x[1][1], x[1][0])) # Priority queue to keep track of active bookings (min-heap by check-out date) active_bookings = [] # Result list to store selected booking indices result = [] for idx, (check_in, check_out) in sorted_bookings: # Maintain only the bookings that are still active while active_bookings and active_bookings[0][0] <= check_in: active_bookings.pop(0) # Add the current booking if we have rooms available if len(active_bookings) < total_rooms: result.append(idx) active_bookings.append((check_out, idx)) active_bookings.sort() # Re-sort to maintain order by check-out dates return result"},{"question":"# Sorting a List of Tuples Based on a Custom Key You are given a list of tuples, where each tuple contains an integer and a string. Your task is to implement a function that sorts this list based on two criteria: 1. Sort by the string in alphabetical order. 2. If two tuples have the same string, sort them by the integer in ascending order. Function Definition: 1. **sort_tuples(data: list[tuple[int, str]]) -> list[tuple[int, str]]** This function should sort the input list of tuples based on the specified criteria. - **Input**: `data` (list of tuples) – Each tuple contains an integer and a string. - **Output**: A list of tuples sorted according to the specified rules. Constraints: - The integer values will be within the range -10^6 to 10^6. - The strings will consist of lowercase English letters and have lengths between 1 and 100. Example: ``` input_data = [(10, \'apple\'), (5, \'banana\'), (10, \'banana\'), (8, \'apple\'), (3, \'cherry\')] sorted_data = sort_tuples(input_data) print(sorted_data) ``` The expected output should be: ``` [(8, \'apple\'), (10, \'apple\'), (5, \'banana\'), (10, \'banana\'), (3, \'cherry\')] ``` Context: This sorting function could be used in scenarios such as organizing data records, arranging items for display, or any system where a combination of textual and numerical sorting is required.","solution":"def sort_tuples(data): Sort a list of tuples first by string in alphabetical order, and then by integer in ascending order if the strings are the same. return sorted(data, key=lambda x: (x[1], x[0]))"},{"question":"# Question: Balanced Binary Search Tree (BST) Operations Context You are tasked with designing a data structure that ensures a Binary Search Tree (BST) remains balanced after insertion of elements. This data structure should also include functionalities to search for elements efficiently. Requirements 1. **Balanced Binary Search Tree Class (`BalancedBST`)**: - Should support insertion of new elements. - Should keep the tree balanced (e.g., using AVL or Red-Black Tree properties). 2. **Tree Operations**: - Implement a method `insert` within the `BalancedBST` class to add elements while maintaining balance. - Implement a method `search` within the `BalancedBST` class to find an element in the tree. 3. **Tree Traversal**: - Implement a method `inorder_traversal` within the `BalancedBST` class to return elements of the tree in ascending order. - Implement a method `display_tree` to visualize the tree structure at any given point. Implementation Details - **Input Format**: - Elements to be inserted: a list of integers. - Element to search: a single integer. - **Output Format**: - Returns a boolean indicating the presence of the searched element. - Returns a list of integers in ascending order from `inorder_traversal`. - **Constraints**: - Your insert and search functionalities should handle up to 10,000 elements. - Ensure the tree remains balanced after each insertion. Function Signature ```python from typing import List class BalancedBST: def __init__(self): pass # Initialize the root of the BST def insert(self, element: int) -> None: pass # Insert the element and balance the tree def search(self, element: int) -> bool: pass # Search for the element in the tree def inorder_traversal(self) -> List[int]: pass # Return elements in ascending order def display_tree(self) -> None: pass # Visualize the tree structure # Example Usage: # bst = BalancedBST() # bst.insert(10) # bst.insert(20) # bst.insert(5) # found = bst.search(20) # True # elements_in_order = bst.inorder_traversal() # [5, 10, 20] # bst.display_tree() # Visual representation of the tree ``` Performance Requirements - Ensure that insertions and searches are performed in logarithmic time complexity to maintain efficiency, especially for large input sizes.","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1 return x def left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def insert_node(self, node, key): if not node: return TreeNode(key) elif key < node.val: node.left = self.insert_node(node.left, key) else: node.right = self.insert_node(node.right, key) node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 balance = self.get_balance(node) if balance > 1 and key < node.left.val: return self.right_rotate(node) if balance < -1 and key > node.right.val: return self.left_rotate(node) if balance > 1 and key > node.left.val: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and key < node.right.val: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def insert(self, element: int) -> None: self.root = self.insert_node(self.root, element) def search_node(self, node, key): if not node or node.val == key: return node if key < node.val: return self.search_node(node.left, key) return self.search_node(node.right, key) def search(self, element: int) -> bool: return bool(self.search_node(self.root, element)) def inorder_traversal_node(self, node, res): if not node: return self.inorder_traversal_node(node.left, res) res.append(node.val) self.inorder_traversal_node(node.right, res) def inorder_traversal(self) -> list: res = [] self.inorder_traversal_node(self.root, res) return res def display_tree_node(self, node, level=0, pref=\\"Root: \\"): if not node: return print(\\" \\" * (level * 4) + pref + str(node.val)) if node.left: self.display_tree_node(node.left, level + 1, \\"L--- \\") if node.right: self.display_tree_node(node.right, level + 1, \\"R--- \\") def display_tree(self): self.display_tree_node(self.root)"},{"question":"# Scenario You are developing a text editor and need to implement a feature that identifies and highlights all keywords in the text. Keywords are defined as words that appear in a given list. Your task is to write a function that processes the given text and highlights the keywords by enclosing them within asterisks (`*`). Additionally, the text should remain unchanged except for the highlighted keywords. # Task Implement the function `highlight_keywords(text: str, keywords: List[str]) -> str` that highlights all occurrences of each keyword in the text. The match should be case-insensitive, meaning \\"Keyword\\" and \\"keyword\\" should both be considered highlights. # Details 1. Implement the `highlight_keywords` function: - Identify and highlight all occurrences of each keyword in the text. - Case-insensitive matching for keywords. - Ensure that only whole words are matched. - Ignore punctuation attached to the words. # Input * `text`: A single string representing the text to be processed. * `keywords`: A list of strings containing the keywords to highlight. # Output * Returns a string with all keywords highlighted by enclosing them within asterisks (`*`). # Constraints * `text` can be up to 10,000 characters long. * `keywords` list can contain up to 100 words, each up to 20 characters long. * Keywords are alphanumeric strings. # Example ```python text = \\"Python is amazing. I love coding in Python because it is so versatile.\\" keywords = [\\"python\\", \\"coding\\"] # Expected Output: \\"*Python* is amazing. I love *coding* in *Python* because it is so versatile.\\" print(highlight_keywords(text, keywords)) ``` # Notes 1. Ensure proper handling of punctuation and word boundaries. 2. Maintain the original casing for the text but apply case-insensitive matching when highlighting. 3. Provide error checking/messages for invalid input types where applicable.","solution":"import re from typing import List def highlight_keywords(text: str, keywords: List[str]) -> str: Highlights all occurrences of each keyword in the text. Keywords are highlighted by enclosing them within asterisks (*). The matching is case-insensitive and only whole words are matched. Parameters: text (str): The text to be processed. keywords (List[str]): The list of keywords to highlight. Returns: str: The text with highlighted keywords. def replacer(match): word = match.group(0) return f\\"*{word}*\\" for keyword in keywords: pattern = re.compile(r\'b\' + re.escape(keyword) + r\'b\', re.IGNORECASE) text = pattern.sub(replacer, text) return text"},{"question":"As an engineer working on signal processing, you often need to smooth out noisy data. One common technique for smoothing data is through a moving average, which helps reveal the underlying trends by averaging each set of data over a particular window. Your task is to implement a function that computes the moving average of a series of data points using a specified window size. # Function Description You are required to implement the function `moving_average(data_points, window_size)`. # Input - `data_points`: A list of floats representing the data points. - `window_size`: An integer representing the number of data points to consider in each moving average calculation. # Output - Returns a list of floats containing the moving averages. Each element in the output list is the average of the previous `window_size` data points from the input list. # Constraints - Consider realistic practical limits on the size of the data: - The `data_points` list may be large, but should fit into available memory. - `window_size` must be a positive integer and should be less than or equal to the length of the `data_points` list. - Handle edge cases effectively: - If `data_points` is empty, return an empty list. - If `window_size` is greater than the length of `data_points`, return an empty list. - If `window_size` is less than or equal to zero, return an empty list. # Examples ```python moving_average([1, 2, 3, 4, 5], 2) # Output: [1.5, 2.5, 3.5, 4.5] moving_average([10, 20, 30, 40], 3) # Output: [20.0, 30.0] moving_average([1, 2, 3, 4, 5], 1) # Output: [1, 2, 3, 4, 5] moving_average([1, 2, 3, 4, 5], 5) # Output: [3.0] moving_average([1, 2, 3, 4, 5], 6) # Output: [] moving_average([], 2) # Output: [] moving_average([1, 2, 3, 4, 5], 0) # Output: [] ``` During the implementation, consider the efficiency of your approach to ensure the function performs well with large datasets and varying window sizes.","solution":"def moving_average(data_points, window_size): Compute the moving average of a series of data points using a specified window size. :param data_points: List of floats representing the data points. :param window_size: Integer representing the number of data points to consider in each moving average calculation. :return: List of floats containing the moving averages. if not data_points or window_size <= 0 or window_size > len(data_points): return [] moving_averages = [] window_sum = sum(data_points[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(data_points)): window_sum += data_points[i] - data_points[i - window_size] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"# Problem Statement You have been assigned a task to process a list of integers and perform two primary computations: checking for a palindromic sequence and calculating the mode of the sequence. The tasks are described as follows: 1. **Check if a Sequence is a Palindrome**: Write a function named `is_palindrome_sequence` that takes a list of integers as input and returns a boolean indicating whether the sequence is a palindrome. A palindromic sequence reads the same backward as forward. If the input is not a list or is an empty list, your function should raise a `ValueError`. 2. **Calculate the Mode of the Sequence**: Write a function named `calculate_mode` that takes a list of integers as input and returns the mode of the sequence. The mode is the value that appears most frequently in the list. If there is more than one value with the highest frequency, return the smallest one. If the input is not a list or is an empty list, your function should raise a `ValueError`. # Requirements * Implement the functions as per the provided function prototypes: ```python def is_palindrome_sequence(seq: list) -> bool: # Your code here def calculate_mode(seq: list) -> int: # Your code here ``` * **Input Constraints**: * `seq` is a list of integers. * A valid input `seq` consists of at least one integer. # Examples The `is_palindrome_sequence` function should work as follows: * `is_palindrome_sequence([1, 2, 3, 2, 1])` should return `True`. * `is_palindrome_sequence([1, 2, 3, 4, 5])` should return `False`. * `is_palindrome_sequence([7])` should return `True`. * `is_palindrome_sequence([])` should raise a `ValueError`. The `calculate_mode` function should work as follows: * `calculate_mode([2, 2, 3, 3, 3, 4])` should return `3`. * `calculate_mode([1, 1, 2, 2, 3])` should return `1`. * `calculate_mode([4])` should return `4`. * `calculate_mode([])` should raise a `ValueError`. # Notes: * Ensure that your code is efficient and handles edge cases effectively. * Use appropriate error handling to manage invalid inputs.","solution":"def is_palindrome_sequence(seq: list) -> bool: Checks if the given sequence is a palindrome. Args: seq: A list of integers. Returns: A boolean value indicating whether the sequence is a palindrome. Raises: ValueError: If the input is not a list or is an empty list. if not isinstance(seq, list) or not seq: raise ValueError(\\"Input must be a non-empty list of integers.\\") return seq == seq[::-1] def calculate_mode(seq: list) -> int: Calculates the mode of the given sequence. Args: seq: A list of integers. Returns: An integer value representing the mode of the list. Raises: ValueError: If the input is not a list or is an empty list. if not isinstance(seq, list) or not seq: raise ValueError(\\"Input must be a non-empty list of integers.\\") from collections import Counter freq = Counter(seq) mode_freq = max(freq.values()) modes = [key for key, val in freq.items() if val == mode_freq] return min(modes)"},{"question":"# Context You are given an undirected graph represented as an adjacency list. The graph may contain cycles, and you need to determine whether it is a bipartite graph or not. A bipartite graph is a graph in which you can split the set of vertices into two distinct sets such that no two vertices within the same set are adjacent. # Task Implement a function in Python to check if the given graph is bipartite using Breadth-First Search (BFS). Your function should return `True` if the graph is bipartite, and `False` otherwise. # Requirements - Function Name: `is_bipartite` - **Input**: A dictionary representing the adjacency list of the graph. The keys are nodes, and the values are lists of adjacent nodes. - **Output**: A boolean value `True` if the graph is bipartite, and `False` otherwise. - **Constraints**: - The maximum number of nodes in the graph will be 10^4. - The values in the adjacency list are integers representing nodes. # Example ```python # Example usage graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } print(is_bipartite(graph)) # Output should be: True graph = { 1: [2], 2: [1, 3, 4], 3: [2, 4], 4: [2, 3] } print(is_bipartite(graph)) # Output should be: False ``` # Notes: - Be sure to handle edge cases such as disconnected graphs, single-node graphs, etc. - Consider the efficiency of your approach to handle the upper constraint near 10^4 nodes. **Implement the Function Below:** ```python from collections import deque def is_bipartite(graph): # your code here ```","solution":"from collections import deque def is_bipartite(graph): # Initialize color map, -1 means uncolored, 0 and 1 are the two colors color = {} for node in graph: if node not in color: # BFS to check the component of the graph starting from the current node queue = deque([node]) color[node] = 0 # Start coloring with color 0 while queue: u = queue.popleft() for v in graph[u]: if v not in color: # Assign the opposite color to the adjacent node color[v] = 1 - color[u] queue.append(v) elif color[v] == color[u]: # If the adjacent node has the same color, then it\'s not bipartite return False return True"},{"question":"# Problem Statement You are required to write a function that calculates the number of distinct anagrams of a given string `s` that are also valid words present in a provided dictionary. An anagram is a rearrangement of the letters in the original string. Additionally, implement a function to identify the longest word in the dictionary that can be created as an anagram of a given string `s`. # Input 1. A string `s` consisting of lowercase letters. 2. A list of strings representing the dictionary, where each string consists of lowercase letters. # Output 1. For the anagram count function: An integer representing the number of distinct anagram words from `s` that are present in the dictionary. 2. For the longest anagram function: The longest word from the dictionary that is an anagram of `s`. If there are multiple longest words, return any one of them. If no valid anagram word exists, return an empty string. # Function Signature ```python def count_valid_anagrams(s: str, dictionary: List[str]) -> int: # Your code here def longest_valid_anagram(s: str, dictionary: List[str]) -> str: # Your code here ``` # Example ```python dictionary = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"abc\\", \\"cba\\"] # Example 1 assert count_valid_anagrams(\\"listen\\", dictionary) == 3 assert count_valid_anagrams(\\"abc\\", dictionary) == 2 # Example 2 assert longest_valid_anagram(\\"google\\", dictionary) == \\"google\\" # or \\"glooge\\" if it were in the dictionary assert longest_valid_anagram(\\"silent\\", dictionary) == \\"silent\\" # or \\"listen\\" or \\"enlist\\" assert longest_valid_anagram(\\"abcd\\", dictionary) == \\"\\" ``` # Constraints 1. ( 1 leq len(s) leq 10^5 ) 2. ( 1 leq len(dictionary) leq 10^5 ) 3. Each word in dictionary has a length ( 1 leq len(word) leq 10^5 ) # Notes - Ensure efficiency in handling large inputs within given constraints. - Consider optimizing the approach by leveraging hashing or frequency counter techniques for anagram detection.","solution":"from collections import Counter from typing import List def count_valid_anagrams(s: str, dictionary: List[str]) -> int: Returns the count of valid anagrams of `s` present in the dictionary. s_counter = Counter(s) valid_count = 0 for word in dictionary: if Counter(word) == s_counter: valid_count += 1 return valid_count def longest_valid_anagram(s: str, dictionary: List[str]) -> str: Returns the longest anagram of `s` present in the dictionary. s_counter = Counter(s) longest_word = \\"\\" for word in dictionary: if Counter(word) == s_counter and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Scenario: You are optimizing a file processing application that needs to handle large logs efficiently. To improve performance, you decide to implement a function that reads the log file in chunks and processes each chunk incrementally. # Task: Implement a Python function `process_log_file(filepath, chunk_size)` that reads a large text log file in specified chunk sizes and processes each chunk to count the number of times each IP address appears in the log entry. # Function Specification: Input: - `filepath`: A string representing the path to the log file. - `chunk_size`: An integer representing the size (in bytes) of each chunk to be read. Output: - A dictionary where the keys are IP addresses (as strings) and the values are the counts of occurrences (as integers). Constraints: - Ensure efficient memory usage by reading the file in chunks. - The function should manage cases where an IP address may split across chunks. - Handle edge cases like empty or malformed log entries gracefully. - The log file format is assumed to have IP addresses at the beginning of each line. Log File Format Example: ``` 192.168.1.1 - User1 [01/Jan/2021:12:00:00 -0700] \\"GET /index.html HTTP/1.1\\" 200 1234 192.168.1.2 - User2 [01/Jan/2021:12:01:00 -0700] \\"POST /submit HTTP/1.1\\" 200 5678 192.168.1.1 - User1 [01/Jan/2021:12:02:00 -0700] \\"GET /about.html HTTP/1.1\\" 200 2345 ... ``` # Example: ```python # Example usage result = process_log_file(\'path_to_log_file.log\', 1024) print(result) ``` Expected Output: ```python { \'192.168.1.1\': 2, \'192.168.1.2\': 1, ... } ```","solution":"def process_log_file(filepath, chunk_size): Reads a log file in chunks and counts the occurrences of each IP address. Parameters: filepath (str): The path to the log file. chunk_size (int): The size (in bytes) of each chunk to be read. Returns: dict: A dictionary where the keys are IP addresses and the values are the counts of occurrences. ip_counts = {} buffer = \\"\\" with open(filepath, \\"r\\") as file: while True: chunk = file.read(chunk_size) if not chunk: break lines = (buffer + chunk).splitlines() # If the last character is not a newline, then the last line is incomplete if chunk and chunk[-1] != \'n\': buffer = lines.pop() else: buffer = \\"\\" for line in lines: if line: ip_address = line.split(\\" \\")[0] if ip_address in ip_counts: ip_counts[ip_address] += 1 else: ip_counts[ip_address] = 1 # Process any remaining buffer if exists if buffer: ip_address = buffer.split(\\" \\")[0] if ip_address in ip_counts: ip_counts[ip_address] += 1 else: ip_counts[ip_address] = 1 return ip_counts"},{"question":"# Coding Challenge: Matrix Path Sum You are given a 2D grid of numbers representing a matrix, where each number represents the cost of stepping onto that cell. Your task is to find the minimum cost path from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. Task Implement a function `min_cost_path` that calculates the minimum cost to travel from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) of a given matrix `grid`. Function Signature ```python def min_cost_path(grid: List[List[int]]) -> int: pass ``` Input Description - `grid` - A list of lists of integers representing a 2D grid of costs. The dimensions of the grid are n x m, where `1 <= n, m <= 100` and `1 <= grid[i][j] <= 100`. Output Description - Return an integer representing the minimum cost to travel from the top-left to the bottom-right corner of the matrix. Constraints - Ensure that the path is calculated efficiently. - Consider edge cases such as the smallest and largest grid dimensions. Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(grid)) # Output: 7 ``` Points to Consider - Utilize dynamic programming for an efficient solution. - Carefully handle the initialization and boundary conditions in your algorithm. - Ensure valid transitions between cells in the matrix.","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Create a dp array with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the minimum cost path return dp[n-1][m-1]"},{"question":"# Problem Statement You are managing a library system, and one of your tasks is to keep track of overdue books. The overdue fees are calculated based on the number of days a book is overdue. Your task is to write a function that computes the total overdue fees for a given list of books. # Task Create a function `calculate_overdue_fees(due_dates, return_dates, daily_fee)` that calculates the total overdue fees for all books. # Input * `due_dates` (List[str]): A list of due dates in the format \'YYYY-MM-DD\'. * `return_dates` (List[str]): A list of actual return dates in the format \'YYYY-MM-DD\'. * `daily_fee` (float): The fee charged per overdue day. # Output * (float): The total overdue fees for all books. # Constraints * 1 ≤ len(due_dates) ≤ 10^3 * len(due_dates) == len(return_dates) * Dates are valid Gregorian calendar dates between \'2000-01-01\' and \'9999-12-31\'. * `0 ≤ daily_fee ≤ 100`. # Example ```python assert calculate_overdue_fees([\'2023-05-01\', \'2023-06-15\'], [\'2023-05-03\', \'2023-06-14\'], 1.50) == 3.0 assert calculate_overdue_fees([\'2022-01-01\'], [\'2021-12-31\'], 2.0) == 0.0 ``` # Notes * If a book is returned on or before its due date, there is no fee for that book. * If a book is returned after its due date, the fee is calculated based on the number of days it is overdue. * Return the total fee rounded to two decimal places.","solution":"from datetime import datetime def calculate_overdue_fees(due_dates, return_dates, daily_fee): Calculate the total overdue fees for all books. Parameters: due_dates (list of str): A list of due dates in the format \'YYYY-MM-DD\'. return_dates (list of str): A list of actual return dates in the format \'YYYY-MM-DD\'. daily_fee (float): The fee charged per overdue day. Returns: float: The total overdue fees for all books rounded to two decimal places. total_fees = 0.0 for due_date, return_date in zip(due_dates, return_dates): due_date_obj = datetime.strptime(due_date, \\"%Y-%m-%d\\") return_date_obj = datetime.strptime(return_date, \\"%Y-%m-%d\\") overdue_days = (return_date_obj - due_date_obj).days if overdue_days > 0: total_fees += overdue_days * daily_fee return round(total_fees, 2)"},{"question":"# Problem Statement: You are given a string `s` containing alphabetical characters and a non-negative integer `k`. The task requires you to shift every character in the string by `k` positions in the alphabet and return the resulting string. If the shift takes you past \'z\', it wraps around to the beginning of the alphabet. The operation is case-sensitive, meaning \'a\' and \'A\' are treated as different characters and shifting them results in \'a\' → \'b\' and \'A\' → \'B\'. # Function Signature: ```python def shift_string(s: str, k: int) -> str: ``` # Input: - A string `s` containing only alphabetical characters (both lowercase and uppercase). - A non-negative integer `k` where ( 0 leq k leq 10^4 ). # Output: - A string representing the shifted characters. # Constraints: - The input string `s` is guaranteed to contain at least one character and at most 100 characters. - Time complexity should be O(n), where n is the length of the string. - You can assume valid input, no need to handle invalid cases. # Examples: 1. `shift_string(\\"Hello\\", 1)` should return `\\"Ifmmp\\"` 2. `shift_string(\\"abcXYZ\\", 2)` should return `\\"cdeZAB\\"` 3. `shift_string(\\"Python\\", 13)` should return `\\"Clguba\\"` # Explanation: Given `s = \\"Hello\\"` and `k = 1`: - Shift \'H\' by 1: \'H\' → \'I\' - Shift \'e\' by 1: \'e\' → \'f\' - Shift \'l\' by 1: \'l\' → \'m\' - Shift \'l\' by 1: \'l\' → \'m\' - Shift \'o\' by 1: \'o\' → \'p\' - The resulting string is `\\"Ifmmp\\"`. Implement the function considering both the wrapping around from \'z\' to \'a\' and maintaining the case sensitivity of the characters.","solution":"def shift_string(s: str, k: int) -> str: Shifts every character in the given string `s` by `k` positions in the alphabet. If the shift takes a character past \'z\' or \'Z\', it wraps around to the beginning of the alphabet. shifted_s = [] for char in s: if \'a\' <= char <= \'z\': # Handle lowercase letters new_char = chr(((ord(char) - ord(\'a\') + k) % 26) + ord(\'a\')) elif \'A\' <= char <= \'Z\': # Handle uppercase letters new_char = chr(((ord(char) - ord(\'A\') + k) % 26) + ord(\'A\')) shifted_s.append(new_char) return \'\'.join(shifted_s)"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing a function to generate all possible combinations of a given list of characters, of a specific length. This function should return combinations in lexicographical order. Task Implement a function `combinations` that generates all unique combinations of a given list of characters of a specified length. Your implementation should output the combinations in lexicographical order. Function Signature ```python def combinations(char_list: list, combination_length: int) -> list: Generate combinations of a specified length from the given list of characters. :param char_list: Input list of characters. :param combination_length: The length of each combination to be generated. :return: A list of lexicographically sorted combinations. ``` Input * `char_list`: A list of characters. Length of the list is between 0 and 20. * `combination_length`: An integer representing the length of each combination. It\'s less than or equal to the length of `char_list`. Output * A list of strings, each representing a combination of characters from `char_list` in lexicographical order. Constraints * The characters in `char_list` are ASCII characters. * The combination length is a non-negative integer and does not exceed the length of `char_list`. Examples ```python assert combinations([\'a\', \'b\', \'c\'], 2) == [\'ab\', \'ac\', \'bc\'] assert combinations([\'a\', \'b\', \'c\', \'d\'], 1) == [\'a\', \'b\', \'c\', \'d\'] assert combinations([\'x\', \'y\', \'z\'], 3) == [\'xyz\'] assert combinations([\'a\', \'b\', \'c\'], 3) == [\'abc\'] assert combinations([\'a\', \'b\'], 2) == [\'ab\'] assert combinations([], 0) == [] ``` Notes * Ensure that your implementation handles edge cases, such as empty lists and when the combination length is zero. * Consider using combinations from `itertools` module to simplify your implementation. * The output list should be empty if the combination length is greater than the length of the input list. This question assesses your ability to work with combinatorial logic, recursive thinking, and handling edge cases effectively.","solution":"from itertools import combinations as itertools_combinations def combinations(char_list, combination_length): Generate combinations of a specified length from the given list of characters. :param char_list: Input list of characters. :param combination_length: The length of each combination to be generated. :return: A list of lexicographically sorted combinations. if not char_list or combination_length == 0: return [] # Sort the list to ensure combinations are in lexicographical order char_list.sort() # Use itertools.combinations to get all possible combinations of specified length combs = [\'\'.join(c) for c in itertools_combinations(char_list, combination_length)] return combs"},{"question":"# Coding Assessment Question Scenario You are developing an application for managing playlists of songs. One of the key features is the ability to calculate the total duration of a playlist. Each song has a duration given in a particular format (hours:minutes:seconds). Your task is to implement a function that will accurately compute the total duration of an entire playlist. Task Implement a Python function to calculate the total duration of a playlist of songs. Function Signature ```python def total_playlist_duration(playlist: List[str]) -> str: ``` Input - `playlist`: A list of strings, where each string represents the duration of a song in the format \\"HH:MM:SS\\". Output - A string representing the total duration of the playlist in the format \\"HH:MM:SS\\". Constraints - Each song duration is guaranteed to be in a valid \\"HH:MM:SS\\" format. - The number of songs in the playlist can be between 1 and 1000. - The values for hours, minutes, and seconds will be non-negative integers. Example ```python assert total_playlist_duration([\\"00:03:45\\", \\"01:00:30\\", \\"00:23:15\\"]) == \\"01:27:30\\" assert total_playlist_duration([\\"00:00:30\\", \\"00:00:30\\"]) == \\"00:01:00\\" assert total_playlist_duration([\\"12:30:30\\", \\"00:00:00\\", \\"00:15:15\\", \\"02:45:45\\"]) == \\"15:31:30\\" ``` Note Your implementation should correctly handle the conversion of minutes and seconds to hours and ensure that the resulting format is valid and normalized (e.g., \\"01:65:70\\" should be correctly converted to \\"02:06:10\\"). Include appropriate methods to handle and validate the input format and sum the durations accurately.","solution":"from typing import List def total_playlist_duration(playlist: List[str]) -> str: total_seconds = 0 for duration in playlist: hours, minutes, seconds = map(int, duration.split(\':\')) total_seconds += hours * 3600 + minutes * 60 + seconds total_hours = total_seconds // 3600 total_seconds %= 3600 total_minutes = total_seconds // 60 total_seconds %= 60 return f\\"{total_hours:02}:{total_minutes:02}:{total_seconds:02}\\""},{"question":"# Coding Question Problem Statement You are given a list of integers `nums` and an integer `target`. Your task is to write a Python function called `two_sum` to find indices of the two numbers such that they add up to `target`. Assume that each input would have exactly one solution, and you may not use the same element twice. The function should return the indices in a list, and the indices must be in ascending order. Your solution must handle invalid inputs gracefully by throwing a `ValueError` with the message \\"Invalid input\\". Requirements - Function Signature: `def two_sum(nums: List[int], target: int) -> List[int]:` - **Input**: A list of integers `nums` and an integer `target`. - **Output**: A list of two integers representing the indices of the two elements in the `nums` list that add up to `target`. - **Constraints**: The input list `nums` will have between 2 and 10^4 elements. Example ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([2, 5, 5, 12], 10) [1, 2] >>> two_sum([], 7) Traceback (most recent call last): ... ValueError: Invalid input >>> two_sum([1, 2], \\"target\\") Traceback (most recent call last): ... ValueError: Invalid input >>> two_sum([1, 2], 3.5) Traceback (most recent call last): ... ValueError: Invalid input ``` Constraints - The function should handle input errors by raising `ValueError` with the message \\"Invalid input\\". - The function should be efficient and optimized for large inputs. Additional Notes - Consider using a hash map for optimization to achieve a time complexity of O(n). - Make sure your implementation correctly validates inputs and handles possible edge cases.","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: # Validate input if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums) or not isinstance(target, int): raise ValueError(\\"Invalid input\\") if not 2 <= len(nums) <= 10**4: raise ValueError(\\"Invalid input\\") # Dictionary to store values and their indices num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return sorted([num_dict[complement], i]) num_dict[num] = i # If no solution is found (though per problem statement there should always be a valid solution) raise ValueError(\\"No solution found\\")"},{"question":"# Problem Statement You are given a function `nearest_smaller_elements(arr: List[int]) -> List[int]` which takes in an array of integers and returns a new array where each element is replaced with the nearest smaller element to its left in the original array. If there is no smaller element to the left, the position should be replaced with -1. Implement an optimized version of this function. # Objective Your task is to optimize the nearest_smaller_elements function to handle large inputs efficiently. # Input and Output * **Input**: An array of integers `arr` where 1 ≤ len(arr) ≤ 100,000 and -10^9 ≤ arr[i] ≤ 10^9. * **Output**: A list of integers representing the nearest smaller elements to the left. # Constraints - Utilize data structures and algorithms that minimize the time complexity. - Ensure the function handles edge cases such as large inputs or arrays with repeating elements. - Aim for an efficient solution with an overall time complexity of O(n). # Example ```python >>> nearest_smaller_elements([2, 1, 4, 3, 6, 5]) [-1, -1, 1, 1, 3, 3] >>> nearest_smaller_elements([1, 2, 3, 4]) [-1, 1, 2, 3] >>> nearest_smaller_elements([4, 3, 2, 1]) [-1, -1, -1, -1] ``` # Notes - Optimize your solution by using appropriate data structures like stacks to maintain efficient access to potential smaller elements. - Ensure the implementation is robust and handles a wide range of integer inputs efficiently. - Focus on reducing unnecessary computations and leverage the properties of the input array for optimization. Good luck, and remember, efficiency is key!","solution":"def nearest_smaller_elements(arr): Returns a list where each element is replaced with the nearest smaller element to its left in the original array. If there is no smaller element to the left, the position is replaced with -1. result = [] stack = [] for num in arr: while stack and stack[-1] >= num: stack.pop() if stack: result.append(stack[-1]) else: result.append(-1) stack.append(num) return result"},{"question":"Scenario In a data science application, you are required to handle and manipulate large datasets without using extra space inefficiently. One task involves rearranging a list of integers in-place such that all even numbers appear before all odd numbers while maintaining the relative order of the even and odd numbers. Task Write a Python function that rearranges the given list of integers in-place to move all even numbers to the front and all odd numbers to the back, maintaining their relative order. Function Signature ```python def reorder_even_odd(arr: list[int]) -> None: ``` Expected Input/Output * **Input**: A list `arr` of integers where the length of the list can be up to 10,000. * **Output**: The function should modify the list `arr` in-place without returning anything. Constraints * `1 <= len(arr) <= 10000` * The list `arr` may contain both positive and negative integers. Example ```python arr = [1, 2, 3, 4, 5, 6] reorder_even_odd(arr) assert arr == [2, 4, 6, 1, 3, 5] arr = [12, 34, 45, 9, 8, 90, 3] reorder_even_odd(arr) assert arr == [12, 34, 8, 90, 45, 9, 3] arr = [1, 3, 5, 7, 9] reorder_even_odd(arr) assert arr == [1, 3, 5, 7, 9] arr = [2, 4, 6, 8] reorder_even_odd(arr) assert arr == [2, 4, 6, 8] ``` Hints 1. Use two pointers to traverse the array and rearrange elements in-place. 2. Ensure the solution maintains the relative order of the even and odd elements. 3. Consider using auxiliary space to temporarily hold elements if it helps to maintain relative order effectively while rearranging.","solution":"def reorder_even_odd(arr: list[int]) -> None: Rearranges the given list of integers in-place to move all even numbers to the front and all odd numbers to the back, while maintaining their relative order. even = [x for x in arr if x % 2 == 0] odd = [x for x in arr if x % 2 != 0] arr[:] = even + odd"},{"question":"# Intersection of Two Sets - Programming Question You are provided with two sets of integers. Your task is to implement a function that calculates the intersection of these two sets. The intersection is defined as a set containing all the elements that are present in both sets. **Function Signature**: ```python def intersection(set_a: set, set_b: set) -> set: :param set_a: set of integers :param set_b: set of integers :return: A set containing elements that are present in both set_a and set_b >>> intersection({1, 2, 3}, {2, 3, 4}) {2, 3} >>> intersection({1, 2, 3}, {4, 5, 6}) set() >>> intersection({1, 2, 3, 4}, set()) set() >>> intersection({2, 4, 6}, {2, 4, 8, 10}) {2, 4} >>> intersection(3, {2, 3, 4}) Traceback (most recent call last): ... AssertionError: The input value of [set_a=3] is not a set pass ``` # Constraints: 1. Both inputs must be of set type containing integers. 2. The resultant set should contain only unique elements that are present in both input sets. 3. If input is not of set type, the function should raise an assertion error with a specific message. # Edge Cases to Consider: - One or both input sets are empty. - Large sets with a considerable number of elements. - Non-integer values within the sets. # Inputs: - `set_a` and `set_b`: Two sets of integers. # Outputs: - A set containing all unique elements that are present in both `set_a` and `set_b`. Implement the function `intersection` to compute the result based on the provided template and constraints.","solution":"def intersection(set_a: set, set_b: set) -> set: Returns the intersection of two sets. :param set_a: set of integers :param set_b: set of integers :return: A set containing elements that are present in both set_a and set_b >>> intersection({1, 2, 3}, {2, 3, 4}) {2, 3} >>> intersection({1, 2, 3}, {4, 5, 6}) set() >>> intersection({1, 2, 3, 4}, set()) set() >>> intersection({2, 4, 6}, {2, 4, 8, 10}) {2, 4} >>> intersection(3, {2, 3, 4}) Traceback (most recent call last): ... AssertionError: The input value of [set_a=3] is not a set assert isinstance(set_a, set), f\\"The input value of [set_a={set_a}] is not a set\\" assert isinstance(set_b, set), f\\"The input value of [set_b={set_b}] is not a set\\" return set_a & set_b"},{"question":"# Question: Data Structures Implementation Challenge - Advanced Operations on Binary Search Tree Context: Consider a Binary Search Tree (BST) implemented to handle basic operations like insertion, deletion, and traversal (in-order, pre-order, and post-order). The BST should support values being integers. Task: Extend the functionality of the existing BST class with the following new methods: 1. `lowest_common_ancestor(node1, node2)`: Find and return the lowest common ancestor of two nodes in the BST. 2. `in_order_successor(node)`: Find and return the in-order successor of a given node in the BST. 3. `kth_smallest(k)`: Find and return the k-th smallest element in the BST. Implementation Details: - **lowest_common_ancestor(node1, node2)**: - Input: `node1` and `node2` (both as integer values) - Output: Integer value representing the lowest common ancestor of `node1` and `node2` in the BST. - **in_order_successor(node)**: - Input: `node` (as an integer value) - Output: Integer value representing the in-order successor of the given node in the BST. - **kth_smallest(k)**: - Input: `k` (as an integer value, where `1 <= k <= n` and `n` is the number of nodes in the BST) - Output: Integer value representing the k-th smallest element in the BST. Constraints: - The BST will have at most 5000 nodes. - Node values are unique and are represented using integers. - Input integers for operations will be valid and guaranteed to exist in the BST where appropriate. Example: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) # Requirements print(bst.lowest_common_ancestor(2, 4)) # Output: 3 print(bst.in_order_successor(5)) # Output: 6 print(bst.kth_smallest(3)) # Output: 4 ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def lowest_common_ancestor(self, node1, node2): return self._lowest_common_ancestor(self.root, node1, node2).val def _lowest_common_ancestor(self, root, node1, node2): if root is None: return None if root.val > node1 and root.val > node2: return self._lowest_common_ancestor(root.left, node1, node2) if root.val < node1 and root.val < node2: return self._lowest_common_ancestor(root.right, node1, node2) return root def in_order_successor(self, node): target = self._find(self.root, node) if target and target.right: return self._min_value_node(target.right).val else: succ = None root = self.root while root: if node < root.val: succ = root root = root.left elif node > root.val: root = root.right else: break if succ: return succ.val return None def _find(self, root, node): if root is None or root.val == node: return root if node < root.val: return self._find(root.left, node) return self._find(root.right, node) def _min_value_node(self, root): current = root while current.left is not None: current = current.left return current def kth_smallest(self, k): self.k = k self.result = None self._kth_smallest_helper(self.root) return self.result def _kth_smallest_helper(self, root): if root is None: return self._kth_smallest_helper(root.left) self.k -= 1 if self.k == 0: self.result = root.val return self._kth_smallest_helper(root.right)"},{"question":"# Problem Statement You are assigned to implement a function to analyze network communication logs. Each log entry records the communication between two nodes in a network. You need to determine the node with the maximum communication weight, which is calculated as the sum of weights of all communication logs involving that node. # Function to Implement Implement the function `max_communication_node(logs: List[Tuple[str, str, int]]) -> Tuple[str, int]` which: * Analyzes the communication logs and computes the communication weight for each node. * Returns the node that has the maximum communication weight along with the weight. # Input Format 1. `logs` (List[Tuple[str, str, int]]): A list of tuples where each tuple consists of: - `start_node` (str): The node where the communication started. - `end_node` (str): The node where the communication ended. - `weight` (int): The weight of the communication between the nodes. # Output Format * Returns a tuple containing: * `node` (str): The node with the maximum communication weight. * `weight` (int): The total communication weight for that node. # Constraints * Communication weights will be positive integers. * Nodes in the logs are represented as non-empty strings. * In case of a tie in communication weight, return the node which appears first in lexicographical order. # Example Given the following input: ```python logs = [ (\\"A\\", \\"B\\", 5), (\\"A\\", \\"C\\", 3), (\\"B\\", \\"A\\", 2), (\\"C\\", \\"A\\", 8), (\\"A\\", \\"D\\", 1) ] ``` The expected output is: ```python (\\"A\\", 19) ``` # Notes * Each communication weight should be counted for both the start and end nodes. * The function should handle a varied number of log entries and nodes efficiently. * Take care of edge cases like empty logs, identical node names, and large input data.","solution":"from typing import List, Tuple from collections import defaultdict def max_communication_node(logs: List[Tuple[str, str, int]]) -> Tuple[str, int]: node_weights = defaultdict(int) for start, end, weight in logs: node_weights[start] += weight node_weights[end] += weight max_node = None max_weight = -1 for node, weight in node_weights.items(): if weight > max_weight or (weight == max_weight and node < max_node): max_node = node max_weight = weight return max_node, max_weight"},{"question":"# Coding Question: Generate Permutations without Repetition **Objective**: Implement a function that generates all permutations of a given string without repetition in Python. The implemented solution should handle various input scenarios and edge cases efficiently. Problem Statement: Design a function `generate_permutations(s: str) -> List[str]` that takes a string `s` and returns a list of all possible permutations of the string without repetition. Function Signature: ```python def generate_permutations(s: str) -> List[str]: :param s: A string for which permutations need to be generated :return: A list of all possible permutations of the string without repetition ``` Input: - The function `generate_permutations` accepts a single string `s`. The input string must not be empty and can contain any characters. Output: - The function `generate_permutations` should return a list of strings, each representing a unique permutation of the input string. Constraints: 1. The string `s` must be a non-empty string. 2. All generated permutations must be unique. 3. Ensure the function handles large inputs gracefully to avoid performance bottlenecks. Examples: ```python print(generate_permutations(\\"ABC\\")) # Expected output: [\'ABC\', \'ACB\', \'BAC\', \'BCA\', \'CAB\', \'CBA\'] print(generate_permutations(\\"AAB\\")) # Expected output: [\'AAB\', \'ABA\', \'BAA\'] print(generate_permutations(\\"A\\")) # Expected output: [\'A\'] ``` Notes: - For ease of testing, provide clear doctests or inline examples. - Remember to document your functions and handle edge cases as described. - Make sure to manage the computations efficiently and verify correctness using varied test cases.","solution":"from typing import List from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all permutations of a given string without repetition. :param s: A string for which permutations need to be generated :return: A list of all possible permutations of the string without repetition perm_set = set(permutations(s)) return [\'\'.join(p) for p in perm_set]"},{"question":"# Binary Search Tree Validation **Context**: Binary search trees (BST) are fundamental data structures in computer science, providing efficient lookup, insertion, and deletion operations. In this exercise, you will write functions to verify if a given binary tree satisfies the properties of a BST. **Task**: 1. Implement a function to validate if a given binary tree is a binary search tree. 2. Write a supporting function to traverse the tree in an in-order manner. 3. Ensure the validation function handles edge cases such as empty trees or trees with a single node. **Requirements**: 1. **Function 1**: `is_valid_bst(root: Optional[TreeNode]) -> bool` - Verify if the provided binary tree is a BST. - Consider BST properties: - The left subtree of a node contains only nodes with keys less than the node\'s key. - The right subtree of a node contains only nodes with keys greater than the node\'s key. - Both the left and right subtrees must also be BSTs. 2. **Function 2**: `in_order_traverse(root: Optional[TreeNode], elements: List[int]) -> None` - Perform an in-order traversal of the tree and store the elements in the given list. - The traversal should populate the list in a sorted order if the tree is a BST. **Performance Requirements**: - The `is_valid_bst` function should perform in ( O(n) ) time complexity, where ( n ) is the number of nodes in the tree. **Constraints**: - The tree node values will be integers within the range of ([-10^6, 10^6]). - Use the following class to represent a node in the binary tree: ```python class TreeNode: def __init__(self, value: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.value = value self.left = left self.right = right ``` ```python from typing import Optional, List class TreeNode: def __init__(self, value: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.value = value self.left = left self.right = right def in_order_traverse(root: Optional[TreeNode], elements: List[int]) -> None: if root: in_order_traverse(root.left, elements) elements.append(root.value) in_order_traverse(root.right, elements) def is_valid_bst(root: Optional[TreeNode]) -> bool: def validate(node: Optional[TreeNode], low: float, high: float) -> bool: if not node: return True if not (low < node.value < high): return False return validate(node.left, low, node.value) and validate(node.right, node.value, high) return validate(root, float(\'-inf\'), float(\'inf\')) # Example Usage: # Creating a Binary Search Tree # 4 # / # 2 5 # / # 1 3 tree = TreeNode(4) tree.left = TreeNode(2) tree.right = TreeNode(5) tree.left.left = TreeNode(1) tree.left.right = TreeNode(3) # Validate if the tree is a BST print(is_valid_bst(tree)) # Output: True ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, value: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.value = value self.left = left self.right = right def in_order_traverse(root: Optional[TreeNode], elements: List[int]) -> None: if root: in_order_traverse(root.left, elements) elements.append(root.value) in_order_traverse(root.right, elements) def is_valid_bst(root: Optional[TreeNode]) -> bool: def validate(node: Optional[TreeNode], low: float, high: float) -> bool: if not node: return True if not (low < node.value < high): return False return validate(node.left, low, node.value) and validate(node.right, node.value, high) return validate(root, float(\'-inf\'), float(\'inf\'))"},{"question":"# Problem Context Compression algorithms take various forms and are essential in the storage and transmission of data, enabling significant reductions in data size. One common algorithm is Run-Length Encoding (RLE), which is simple yet effective for texts with many consecutive repeating characters. The RLE works by converting redundant sequences of repeating characters in the input string into a count followed by the character itself. For instance, \'AAA\' becomes \'3A\'. # Task Write two functions: `encode_rle` to compress an input string using Run-Length Encoding, and `decode_rle` to revert an RLE-encoded string back to its original form. # Requirements 1. **Encode Function**: This function should: * Compress the string by replacing sequences of the same character with the count followed by the character. * Example: `\\"AAABBBCCDAA\\"` should be compressed to `\\"3A3B2C1D2A\\"`. 2. **Decode Function**: This function should: * Decode the string back to the original form by expanding each count-character pair to the sequence of characters. * Example: `\\"3A3B2C1D2A\\"` should be decompressed back to `\\"AAABBBCCDAA\\"`. # Input and Output Format 1. `encode_rle` function: * **Input**: A single parameter, `input_string (str)`, containing the string to be encoded. * **Output**: The RLE-compressed string (str). 2. `decode_rle` function: * **Input**: A single parameter, `encoded_string (str)`, containing the RLE-encoded string to be decoded. * **Output**: The decompressed original string (str). # Constraints * `input_string` for the encode function and `encoded_string` for the decode function will both contain only uppercase English letters. * There should be no non-alphabetic characters in the input strings. * The functions should handle strings of varying lengths efficiently. # Edge Cases * Empty strings. * Strings without any repeating characters. * Very long strings. # Example Implement the `encode_rle` and `decode_rle` functions and test their correctness with different scenarios. **Sample Test** ```python def encode_rle(input_string): if not input_string: return \\"\\" encoded = [] prev_char = input_string[0] count = 1 for char in input_string[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded) def decode_rle(encoded_string): if not encoded_string: return \\"\\" decoded = [] count = 0 for char in encoded_string: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded) assert encode_rle(\\"AAABBBCCDAA\\") == \\"3A3B2C1D2A\\" assert decode_rle(\\"3A3B2C1D2A\\") == \\"AAABBBCCDAA\\" assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"\\") == \\"\\" assert encode_rle(\\"AABBCC\\") == \\"2A2B2C\\" assert decode_rle(\\"2A2B2C\\") == \\"AABBCC\\" assert encode_rle(\\"ABCD\\") == \\"1A1B1C1D\\" assert decode_rle(\\"1A1B1C1D\\") == \\"ABCD\\" print(\\"All tests passed!\\") ```","solution":"def encode_rle(input_string): if not input_string: return \\"\\" encoded = [] prev_char = input_string[0] count = 1 for char in input_string[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded) def decode_rle(encoded_string): if not encoded_string: return \\"\\" decoded = [] count = 0 for char in encoded_string: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"# Problem Statement You are tasked with writing a function to determine if a sequence of operations on a stack results in a valid series of outputs. Given an initial empty stack and a sequence of operations, you must implement functions to simulate the stack operations and validate the final state based on the given sequence of outputs. # Function Signature ```python def validate_stack_operations(operations: list[str], expected_output: list[int]) -> bool: Validates the sequence of stack operations against the expected output. :param operations: List of stack operations to perform. Each operation is \'PUSH x\' or \'POP\'. :param expected_output: List of integers representing the expected sequence of outputs from the \'POP\' operations. :return: True if the stack operations produce the expected sequence of outputs, False otherwise. ``` # Input * `operations`: A list of stack operations as strings. Each operation is either \'PUSH x\' (where x is an integer) or \'POP\'. * `expected_output`: A list of integers representing the expected sequence of outputs from the \'POP\' operations. # Output * A boolean value indicating whether the series of operations results in the expected output sequence. # Constraints * The operations list contains at least one and at most 10000 operations. * Each \'PUSH x\' operation is followed by an integer `x` (-10^6 <= x <= 10^6). * The expected output list contains at least one and at most 10000 integers. * The number of \'PUSH x\' operations will always be greater than or equal to the number of \'POP\' operations. # Example ```python operations = [\'PUSH 1\', \'PUSH 2\', \'POP\', \'POP\'] expected_output = [2, 1] # Output should be True as the sequence of operations results in the expected output assert validate_stack_operations(operations, expected_output) == True operations = [\'PUSH 1\', \'PUSH 2\', \'POP\', \'PUSH 3\', \'POP\'] expected_output = [2, 3] # Output should be True as the sequence of operations results in the expected output assert validate_stack_operations(operations, expected_output) == True operations = [\'PUSH 1\', \'PUSH 2\', \'POP\', \'PUSH 3\', \'POP\'] expected_output = [2, 1] # Output should be False as the sequence of operations does not match the expected output assert validate_stack_operations(operations, expected_output) == False ``` # Note - Implement the helper functions to handle the \'PUSH\' and \'POP\' operations on the stack. - Verify the sequence of \'POP\' operations against the expected output list. - Ensure the function returns a boolean indicating the correctness of the stack operations relative to the expected output.","solution":"def validate_stack_operations(operations: list[str], expected_output: list[int]) -> bool: Validates the sequence of stack operations against the expected output. :param operations: List of stack operations to perform. Each operation is \'PUSH x\' or \'POP\'. :param expected_output: List of integers representing the expected sequence of outputs from the \'POP\' operations. :return: True if the stack operations produce the expected sequence of outputs, False otherwise. stack = [] output_index = 0 for operation in operations: if operation.startswith(\'PUSH \'): _, value = operation.split() stack.append(int(value)) elif operation == \'POP\': if not stack: return False popped_value = stack.pop() if output_index < len(expected_output) and expected_output[output_index] == popped_value: output_index += 1 else: return False return output_index == len(expected_output)"},{"question":"# Scenario You are a software developer tasked with optimizing the functioning of a database system. One aspect of this task involves ensuring that row configurations in a specific table adhere to a unique series of requirements. These requirements focus on prime numbers in relation to their positions within sequences. # Task Write a function `nth_prime_difference_series(n: int) -> List[int]` that returns a list containing the first `n` terms of a sequence where each term is the difference between the nth prime and the (n+1)th prime. # Input * **n**: A positive integer `1 <= n <= 10,000`, representing the number of terms required in the sequence. # Output * Return a list of `n` integers, where the ith term is the difference between the (i+1)th prime and the (i+2)th prime. # Function Signature ```python def nth_prime_difference_series(n: int) -> List[int]: pass ``` # Examples * `nth_prime_difference_series(5)` should return `[1, 2, 2, 4, 2]` because the primes are [2, 3, 5, 7, 11, 13] and their differences are [1, 2, 2, 4, 2]. * `nth_prime_difference_series(10)` should return `[1, 2, 2, 4, 2, 4, 2, 4, 6, 2]`. # Constraints * Ensure the implementation is efficient, as generating a large number of primes can be computationally intensive. * Make use of prime number generation techniques such as the Sieve of Eratosthenes to handle the upper constraint limits. # Notes * Consider both time and space complexity when designing the solution. * Pay attention to the edge cases where `n` may be very small. * Use mathematical libraries such as `sympy` to facilitate prime number computations if necessary.","solution":"from typing import List import sympy def nth_prime_difference_series(n: int) -> List[int]: Returns a list containing the first \'n\' terms of a sequence where each term is the difference between the (i+1)th prime and the (i+2)th prime. # Generate the first n+1 primes. primes = list(sympy.primerange(2, sympy.prime(n + 2))) differences = [primes[i+1] - primes[i] for i in range(n)] return differences"},{"question":"# Substring Search with KMP Algorithm Background: String matching algorithms are crucial in various applications such as text editors, search engines, and DNA sequencing. One of the efficient string matching algorithms is the Knuth-Morris-Pratt (KMP) algorithm, which preprocesses the pattern to identify the longest prefix which is also a suffix. Objective: Write a function `kmp_search(pattern: str, text: str) -> List[int]` to find all occurrences of a given pattern in a text using the KMP algorithm. Requirements: * Implement the function using the following signature: ```python def kmp_search(pattern: str, text: str) -> List[int]: ``` * Your function should follow the KMP algorithm for pattern matching. * It should return a list of starting indices where the pattern is found in the text. Input and Output: * **Input**: Two strings, `pattern` and `text`. * **Output**: A list of integers representing the starting indices in `text` where `pattern` is found. If the pattern is not found, return an empty list. Constraints: * The pattern and the text will contain only lowercase English letters. * The length of the pattern will be between 1 and 100. * The length of the text will be between 1 and 10000. Performance Expectations: * Your implementation should efficiently process the text and pattern according to the KMP algorithm. Example: ```python print(kmp_search(\\"abc\\", \\"abcabcabc\\")) # Expected output: [0, 3, 6] print(kmp_search(\\"a\\", \\"aaaaa\\")) # Expected output: [0, 1, 2, 3, 4] print(kmp_search(\\"abcd\\", \\"abcabc\\")) # Expected output: [] ``` Explanation: * In the first example, the pattern \\"abc\\" is found at indices 0, 3, and 6 of the text \\"abcabcabc\\". * In the second example, the pattern \\"a\\" is found at every index of the text \\"aaaaa\\". * In the third example, the pattern \\"abcd\\" is not found in the text \\"abcabc\\". Edge cases to consider: * The text or pattern being empty. * The pattern is larger than the text. * All characters in the text and pattern are the same. Note: Your function should prioritize efficiency and accuracy, ensuring that it leverages the preprocessing step of the KMP algorithm to avoid redundant comparisons.","solution":"from typing import List def kmp_search(pattern: str, text: str) -> List[int]: Function to find all occurrences of a pattern in a text using the KMP algorithm. if not pattern or not text or len(pattern) > len(text): return [] def compute_lps(pattern: str) -> List[int]: Function to compute the Longest Prefix Suffix (LPS) array for a given pattern. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Sorting Subarrays Given an unsorted array of integers, determine the minimum length subarray which, if sorted, results in the whole array being sorted. Your task is to find the starting and ending indices of such a subarray. # Problem Statement 1. Implement the function `find_unsorted_subarray(nums: List[int]) -> Tuple[int, int]` that returns the start and end indices of the minimum length subarray which, if sorted, sorts the entire array. If the array is already sorted, return `(-1, -1)`. # Function Signature: ```python from typing import List, Tuple def find_unsorted_subarray(nums: List[int]) -> Tuple[int, int]: Returns the starting and ending indices of the minimum length subarray. If the array is already sorted, return (-1, -1). ``` # Requirements: * The function should handle input validation, ensuring the input is a list of integers. * The function should handle edge cases such as empty list and list with one element. * The function should run efficiently to handle large inputs within a reasonable runtime. # Examples: ```python >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) (1, 5) >>> find_unsorted_subarray([1, 2, 3, 4]) (-1, -1) >>> find_unsorted_subarray([1, 3, 2, 4, 5]) (1, 2) >>> find_unsorted_subarray([5, 4, 3, 2, 1]) (0, 4) ``` # Constraints: * The length of the input list will be between 1 and 10^4. * Each element of the list will be a valid integer within the range of -10^5 to 10^5. Use these guidelines to implement your solution, ensuring it efficiently identifies the minimum length subarray that needs sorting to make the whole array sorted.","solution":"from typing import List, Tuple def find_unsorted_subarray(nums: List[int]) -> Tuple[int, int]: n = len(nums) start, end = -1, -1 # Find the first out-of-order element from the beginning for i in range(1, n): if nums[i] < nums[i-1]: start = i - 1 break # If no such element found, array is sorted if start == -1: return -1, -1 # Find the first out-of-order element from the end for i in range(n-1, 0, -1): if nums[i] < nums[i-1]: end = i break # Find the min and max in the target section which needs to be sorted subarray_min = min(nums[start:end+1]) subarray_max = max(nums[start:end+1]) # Extend the start to the left if there are bigger elements than subarray_min while start > 0 and nums[start-1] > subarray_min: start -= 1 # Extend the end to the right if there are smaller elements than subarray_max while end < n-1 and nums[end+1] < subarray_max: end += 1 return start, end"},{"question":"# Question: You need to design a system that logs error messages and retrieves them efficiently based on a given range of time. Specifically, you will be implementing an `ErrorLogger` class that supports recording error messages with timestamps and fetching logs within a specified time frame. The system should be able to perform the following operations: - `log_message(timestamp, message)`: Record a new error message with the given `timestamp`. - `get_messages(start, end)`: Retrieve all error messages recorded within the inclusive time range between `start` and `end`. **Requirements**: - Implement the `ErrorLogger` class to support the above functionalities. - Ensure `log_message` operates in O(1) time complexity and `get_messages` operates in O(n) where n is the number of messages in the time range. - The timestamps will be provided in an increasing order for the `log_message` method. - Develop an efficient data structure to manage the timestamps and associated messages. **Input/Output**: - `log_message(timestamp: int, message: str) -> None` - `get_messages(start: int, end: int) -> List[str]` **Constraints**: - The number of calls to `log_message` and `get_messages` will be in the range [1, 10^5]. - Timestamps and provided numbers will be in the range of [1, 10^9]. - Message strings will have a maximum length of 100 characters. **Example**: ```python logger = ErrorLogger() logger.log_message(1, \\"Error at 1\\") logger.log_message(2, \\"Error at 2\\") logger.log_message(5, \\"Error at 5\\") logger.log_message(7, \\"Error at 7\\") print(logger.get_messages(2, 5)) # returns [\\"Error at 2\\", \\"Error at 5\\"] print(logger.get_messages(1, 3)) # returns [\\"Error at 1\\", \\"Error at 2\\"] print(logger.get_messages(6, 8)) # returns [\\"Error at 7\\"] # Assume further operations... ``` Your task is to implement the `ErrorLogger` class efficiently to manage the error logging and retrieval operations as specified. Ensure the program can handle a large number of entries and queries within the constraints.","solution":"class ErrorLogger: def __init__(self): self.logs = [] def log_message(self, timestamp, message): self.logs.append((timestamp, message)) def get_messages(self, start, end): # Using list comprehension for retrieving messages in O(n) return [message for (timestamp, message) in self.logs if start <= timestamp <= end] # Example usage logger = ErrorLogger() logger.log_message(1, \\"Error at 1\\") logger.log_message(2, \\"Error at 2\\") logger.log_message(5, \\"Error at 5\\") logger.log_message(7, \\"Error at 7\\") print(logger.get_messages(2, 5)) # returns [\\"Error at 2\\", \\"Error at 5\\"] print(logger.get_messages(1, 3)) # returns [\\"Error at 1\\", \\"Error at 2\\"] print(logger.get_messages(6, 8)) # returns [\\"Error at 7\\"]"},{"question":"# Coding Assessment: Implementing K-Means Clustering Algorithm **Objective**: Implement the K-Means clustering algorithm to group a set of instances into specified clusters. You will use the provided utility functions as a reference to create new components to demonstrate your understanding. # Problem Statement Given a series of steps and predefined functions for K-Means, implement the functionality to assign instances to clusters and calculate the final cluster centroids. Your task is to complete the K-Means process, follow a given standard, and handle edge cases appropriately. # Scenario A company wants to use K-Means clustering to segment their customers into different groups based on purchasing behavior. They have historical data on customer purchases. Your role is to implement the clustering model and use it to group customers into clusters based on their purchase features. # Requirements 1. **Function to Initialize Centroids**: * Input: `features` (2D list of feature values), `k` (number of clusters). * Output: List of `k` initial centroids (each centroid is a list of feature values). 2. **Function to Assign Clusters**: * Input: `features` (2D list of feature values), `centroids` (list of current centroids). * Output: List of cluster indices for each instance (same length as `features`). 3. **Function to Update Centroids**: * Input: `features` (2D list of feature values), `assignments` (list of cluster indices). * Output: Updated list of centroids. 4. **Utility Function to Execute K-Means**: * Input: `features` (2D list of feature values), `k` (number of clusters), `max_iterations` (maximum iterations). * Output: Final centroids and cluster assignments. # Input and Output Format **Function 1: initialize_centroids** ```python def initialize_centroids(features: list[list[float]], k: int) -> list[list[float]]: pass ``` **Function 2: assign_clusters** ```python def assign_clusters(features: list[list[float]], centroids: list[list[float]]) -> list[int]: pass ``` **Function 3: update_centroids** ```python def update_centroids(features: list[list[float]], assignments: list[int]) -> list[list[float]]: pass ``` **Utility Function: k_means** ```python def k_means(features: list[list[float]], k: int, max_iterations: int) -> tuple[list[list[float]], list[int]]: pass ``` # Constraints * Input features are numeric. * The number of clusters `k` is a positive integer less than the number of instances. * The `max_iterations` is a positive integer. # Example ```python # Example data features = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.2, 2.5], [8.2, 8.1] ] # Execute K-Means centroids, assignments = k_means(features, k=2, max_iterations=100) # Example output (actual results may vary due to random initialization) print(centroids) # Expected output: [[1.23, 2.32], [7.73, 8.03]] print(assignments) # Expected output: [0, 0, 1, 1, 0, 1] ``` * **Edge Cases**: * Handle cases where instances cannot be reasonably grouped into `k` clusters. * Ensure the algorithm terminates if centroids stop changing significantly before reaching max iterations. # Submission Complete the missing functions to initialize centroids, assign clusters, update centroids, and execute the K-Means algorithm. Ensure your solution passes provided examples and edge cases effectively.","solution":"import random import math def initialize_centroids(features, k): Randomly initialize the centroids by selecting \'k\' random features as initial centroids. return random.sample(features, k) def assign_clusters(features, centroids): Assign each feature to the nearest centroid. assignments = [] for feature in features: distances = [euclidean_distance(feature, centroid) for centroid in centroids] assignments.append(distances.index(min(distances))) return assignments def update_centroids(features, assignments, k): Update centroids based on the current cluster assignments. new_centroids = [] for i in range(k): cluster_features = [features[j] for j in range(len(features)) if assignments[j] == i] if cluster_features: new_centroids.append([sum(x)/len(x) for x in zip(*cluster_features)]) else: new_centroids.append(random.choice(features)) return new_centroids def euclidean_distance(point1, point2): return math.sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2))) def k_means(features, k, max_iterations): centroids = initialize_centroids(features, k) for _ in range(max_iterations): assignments = assign_clusters(features, centroids) new_centroids = update_centroids(features, assignments, k) if new_centroids == centroids: break centroids = new_centroids return centroids, assignments"},{"question":"# Reorganizing Files You have been hired to work on a file management system that organizes files into different folders based on their extensions. Your task is to create a function that will take a list of file names and return a dictionary where the keys are the file extensions and the values are lists of file names with that extension, sorted alphabetically. Task Write a function `organize_files` that categorizes a list of file names based on their extensions. Function Signature ```python def organize_files(files: List[str]) -> Dict[str, List[str]]: ``` Input - `files` (List[str]): A list of file names (strings). Each file has a name and an extension, and the extension is separated from the name by a dot (`.`). (1 ≤ list length ≤ 10^4). Output - A dictionary where the keys are file extensions (strings) and the values are lists of file names (strings) with that extension, sorted alphabetically by file name. Constraints - All file names will contain exactly one dot (`.`). - The file names and extensions will only contain alphanumeric characters. Example ```python organize_files([\\"notes.txt\\", \\"report.pdf\\", \\"image.jpg\\", \\"document.pdf\\", \\"data.txt\\", \\"archive.zip\\"]) ``` Output ```python { \\"txt\\": [\\"data.txt\\", \\"notes.txt\\"], \\"pdf\\": [\\"document.pdf\\", \\"report.pdf\\"], \\"jpg\\": [\\"image.jpg\\"], \\"zip\\": [\\"archive.zip\\"] } ``` Explanation 1. For the input list of file names, the function categorizes files based on their extensions. 2. It groups file names with the same extension and sorts them alphabetically within each group. Make sure to handle large inputs efficiently and ensure the sorting of file names is done correctly.","solution":"from typing import List, Dict def organize_files(files: List[str]) -> Dict[str, List[str]]: file_dict = {} for file in files: name, extension = file.rsplit(\'.\', 1) if extension not in file_dict: file_dict[extension] = [] file_dict[extension].append(file) for extension in file_dict: file_dict[extension].sort() return file_dict"},{"question":"**Title**: Implement a Breadth-First Search (BFS) Function for a Binary Tree **Objective**: Write a function to perform a breadth-first search (BFS) traversal on a given binary tree and return the list of node values in the order they are visited. **Function Signature**: ```python def bfs_traversal(root: TreeNode) -> List[int]: pass ``` **Input**: * root (TreeNode): The root node of the binary tree. **Output**: * List[int]: A list of integers representing the node values in the order they are visited. **Constraints**: * The binary tree may contain between 1 and 10^3 nodes. * Node values are integers and can be positive or negative. **Performance Requirements**: * Time Complexity: `O(N)` where `N` is the number of nodes. * Space Complexity: `O(N)` **Context**: You are given a `TreeNode` class, where each node has a value (`val`), a left child (`left`), and a right child (`right`). Your task is to complete the function `bfs_traversal` that initiates a BFS traversal from the root node and returns the list of node values in the order they are visited. **TreeNode Class** (for reference): ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Example**: ```python # Example tree usage root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) result = bfs_traversal(root) print(result) # Output: [1, 2, 3, 4, 5] ``` **Note**: * Ensure your function handles empty trees gracefully (returns an empty list if the root is `None`). * Use a queue data structure to facilitate the BFS traversal efficiently. * Consider edge cases like binary trees with only left or right subtrees.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bfs_traversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) result = [] while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"# Question You are asked to extend an inventory management system by implementing a function to manage product stock levels efficiently. The system should maintain a record of current stock levels and allow for stock adjustments, sales processing, and restocking. # Function to Implement Function Signature ```python def inventory_manager(starting_stock: dict[str, int]) -> (str -> int, str -> int, str -> None, str -> int) ``` Input * `starting_stock` (dict): A dictionary representing the initial stock levels of various products. Keys are product names (strings), and values are integers representing stock levels. Output * A tuple containing four functions: * `get_stock`: Takes a product name (string) and returns the current stock level (int). * `sell_product`: Takes a product name (string) and returns the number of items sold (int). It should decrease the stock level by one if there is stock available; otherwise, it should return 0. * `restock_product`: Takes a product name (string) and restocks it by adding an additional five items. * `current_stock`: Takes no arguments and returns the entire stock dictionary updated to the current state. # Examples ```python # Example 1 get_stock, sell_product, restock_product, current_stock = inventory_manager({\'apple\': 10, \'banana\': 5}) assert get_stock(\'apple\') == 10 assert sell_product(\'apple\') == 1 assert get_stock(\'apple\') == 9 restock_product(\'banana\') assert get_stock(\'banana\') == 10 assert current_stock() == {\'apple\': 9, \'banana\': 10} # Example 2 get_stock, sell_product, restock_product, current_stock = inventory_manager({\'widget\': 15, \'gadget\': 8}) assert sell_product(\'widget\') == 1 assert get_stock(\'widget\') == 14 assert sell_product(\'widget\') == 1 assert get_stock(\'widget\') == 13 restock_product(\'gadget\') assert get_stock(\'gadget\') == 13 assert current_stock() == {\'widget\': 13, \'gadget\': 13} ``` # Constraints * Each `sell_product` call decrements stock by exactly one if stock is available; otherwise, no change occurs. * Each `restock_product` call increments stock by exactly five. * The `starting_stock` dictionary will have between 1 and 100 products, with product stock levels ranging between 0 and 1000. * All product names are non-empty alphanumeric strings.","solution":"def inventory_manager(starting_stock): stock = starting_stock def get_stock(product): return stock.get(product, 0) def sell_product(product): if stock.get(product, 0) > 0: stock[product] -= 1 return 1 return 0 def restock_product(product): stock[product] = stock.get(product, 0) + 5 def current_stock(): return stock return get_stock, sell_product, restock_product, current_stock"},{"question":"# Context: You are developing a program to analyze the social network of a company. The program needs to identify the most influential employees based on the number of direct connections. An employee with more direct connections is considered more influential. # Task: Implement a function `most_influential_employee(connections: List[Tuple[int, int]]) -> int` that determines the employee with the most direct connections. # Specifications: - **Input**: A list of tuples where each tuple `(a, b)` represents a direct connection between employees `a` and `b`. - **Output**: The employee ID with the most direct connections. If there are multiple employees with the same highest number of connections, return the smallest employee ID. - **Constraints**: - The total number of employees ( n ) is between `1` and ( 10^4 ). - Each employee is identified by a unique integer ID starting from `0`. # Implementation: - **Function**: ```python def most_influential_employee(connections: List[Tuple[int, int]]) -> int: pass ``` - Be sure to handle common edge cases, such as no connections or multiple employees with the same number of connections. # Example: Input: ```python connections = [(0, 1), (0, 2), (1, 2), (1, 3)] ``` In this example, the graph represents the following connections: - Employee 0 is connected to employees 1 and 2. - Employee 1 is connected to employees 0, 2, and 3. - Employee 2 is connected to employees 0 and 1. - Employee 3 is connected to employee 1. Output: ```python 1 ``` Employee 1 has 3 direct connections, which is the highest number of connections, making them the most influential.","solution":"from collections import defaultdict from typing import List, Tuple def most_influential_employee(connections: List[Tuple[int, int]]) -> int: connection_count = defaultdict(int) for a, b in connections: connection_count[a] += 1 connection_count[b] += 1 if not connection_count: return -1 max_connections = -1 most_influential = None for employee, count in connection_count.items(): if count > max_connections or (count == max_connections and employee < most_influential): max_connections = count most_influential = employee return most_influential"},{"question":"# Problem Statement: You are given a list of integers. Your task is to implement the `max_distinct_subarray` function that identifies the length of the longest contiguous subarray where each element appears at most twice. # Function Signature: ```python def max_distinct_subarray(arr: List[int]) -> int: pass ``` # Input: - `arr`: a list of integers (1 <= len(arr) <= 100,000, 1 <= arr[i] <= 1,000,000) # Output: - An integer representing the length of the longest contiguous subarray where each element appears at most twice. # Example: ```python assert max_distinct_subarray([1, 2, 2, 3, 3, 3, 4]) == 5 # The subarray [2, 2, 3, 3, 3] or [3, 3, 3, 4] assert max_distinct_subarray([1, 1, 1, 2, 2, 3, 3, 3, 4, 4]) == 6 # The subarray [1, 2, 2, 3, 3, 3] assert max_distinct_subarray([1, 2, 3, 4, 5]) == 5 # The subarray [1, 2, 3, 4, 5] since all elements appear only once. ``` # Constraints: - The function must be efficient, ideally with a time complexity of O(n). # Considerations: - Consider the use of sliding window or two-pointer technique to solve this problem efficiently. - Ensure the function correctly handles edge cases, such as when all elements in `arr` are the same or when all elements are unique.","solution":"from typing import List def max_distinct_subarray(arr: List[int]) -> int: if not arr: return 0 count = {} left = 0 max_length = 0 for right in range(len(arr)): if arr[right] in count: count[arr[right]] += 1 else: count[arr[right]] = 1 while count[arr[right]] > 2: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Word Count Function **Problem Statement**: Write a function that counts the number of occurrences of each word in a given string. Words are defined as sequences of alphabetic characters, and should be considered case-insensitive. Your task is to implement the function `word_count` which will return a dictionary with words as keys and their counts as values. **Function Signature**: ```python def word_count(text: str) -> dict: pass ``` **Requirements**: 1. The function should convert the input string to lowercase for case-insensitive comparison. 2. It should ignore punctuation and handle special characters gracefully. 3. Words are considered to be sequences of contiguous alphabetic characters. Non-alphabetic characters should act as delimiters. 4. The function should return a dictionary where each key is a unique word from the input string, and the corresponding value is the count of occurrences. **Input**: * `text` (str): The input string containing the text to analyze. **Output**: * `dict`: A dictionary mapping words to their frequency counts in the input text. **Constraints**: * The input string `text` will contain at most 10,000 characters. **Examples**: ```python >>> word_count(\\"Hello world! Hello!\\") {\'hello\': 2, \'world\': 1} >>> word_count(\\"Python programming is fun. Isn\'t it? Programming, python!\\") {\'python\': 2, \'programming\': 2, \'is\': 1, \'fun\': 1, \'isn\': 1, \'t\': 1, \'it\': 1} >>> word_count(\\"Data science is the future. Data science, AI, and ML.\\") {\'data\': 2, \'science\': 2, \'is\': 1, \'the\': 1, \'future\': 1, \'ai\': 1, \'and\': 1, \'ml\': 1} ``` **Note**: - You may use regular expressions to identify and split words, ignoring punctuation and spaces. - The function should handle large input efficiently within the given constraints.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Returns a dictionary of word counts from the input text. Words are defined as sequences of alphabetic characters, and the function is case-insensitive. # Convert the text to lowercase text = text.lower() # Use regex to find all words (sequences of alphabetic characters) words = re.findall(r\'b[a-z]+b\', text) # Use defaultdict to count occurrences of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Context As a software developer, you need to write a method for a custom logging system within an application. The logs are stored in a list, and to manage them efficiently, you need to implement a function that handles the logging of new entries and the retrieval of the most recent logs. # Task Implement a class `LogSystem` with two main functionalities: adding a log entry and retrieving the most recent log entries up to a specified number. The log entries include a timestamp and a message. # Class Signature ```python class LogSystem: def __init__(self): pass def addLog(self, timestamp: str, message: str) -> None: pass def getRecentLogs(self, n: int) -> list: pass ``` # Methods - **addLog(timestamp: str, message: str) -> None**: - Adds a new log entry to the log system. - `timestamp` (string): A string representing the time the log entry was created, in the format \\"YYYY-MM-DD HH:MM:SS\\". - `message` (string): A string containing the log message. - **getRecentLogs(n: int) -> list**: - Retrieves the most recent `n` log entries, in descending order of timestamps. - Returns a list of tuples, where each tuple contains a timestamp and a message. # Examples ```python # Example usage: log_system = LogSystem() log_system.addLog(\'2023-05-15 10:00:00\', \'System started\') log_system.addLog(\'2023-05-15 10:05:00\', \'User logged in\') log_system.addLog(\'2023-05-15 10:10:00\', \'Error encountered\') assert log_system.getRecentLogs(2) == [(\'2023-05-15 10:10:00\', \'Error encountered\'), (\'2023-05-15 10:05:00\', \'User logged in\')] assert log_system.getRecentLogs(5) == [(\'2023-05-15 10:10:00\', \'Error encountered\'), (\'2023-05-15 10:05:00\', \'User logged in\'), (\'2023-05-15 10:00:00\', \'System started\')] ``` # Constraints 1. You can assume that the timestamps provided are always in the correct format and are unique. 2. The method `getRecentLogs` should handle cases where `n` is greater than the number of log entries available. In such cases, it should return all available logs. 3. Performance should be efficient, ensuring that the log retrieval process works seamlessly even for extended log histories. # Edge Cases 1. Adding and retrieving logs from an empty log system should be handled appropriately. 2. The `getRecentLogs` method should accurately return logs in descending order of timestamps, considering the possibility of retrieving fewer logs if `n` exceeds the current number of entries. Your goal is to implement the `LogSystem` class with the specified functionalities to ensure that log entries are managed and retrieved as required.","solution":"class LogSystem: def __init__(self): self.logs = [] def addLog(self, timestamp: str, message: str) -> None: Add a new log entry to the log system. self.logs.append((timestamp, message)) def getRecentLogs(self, n: int) -> list: Retrieve the most recent n log entries in descending order of timestamps. return sorted(self.logs, key=lambda x: x[0], reverse=True)[:n]"},{"question":"# Scenario You are tasked with developing a simplified e-commerce system that manages a collection of products, each having a name and a price. Your goal is to implement a class that allows for adding new products, updating prices, and retrieving the product with the highest price. # Task Description Implement a `ProductCatalog` class based on a max-heap data structure. The `ProductCatalog` class should provide the following functionalities: 1. Add a new product. 2. Update the price of an existing product. 3. Retrieve the product with the highest price. # Input and Output Formats `ProductCatalog` class should have the following methods: - `add_product(name: str, price: float)`: Adds a new product with the given name and price. - `update_price(name: str, new_price: float)`: Updates the price of the specified product. - `get_highest_price() -> str`: Returns the name of the product with the highest price. # Constraints - Product names are unique. - Price values are floating-point numbers. - The number of products (`n`) will not exceed (10^5). # Example ```python catalog = ProductCatalog() catalog.add_product(\\"ProductA\\", 99.99) catalog.add_product(\\"ProductB\\", 249.95) catalog.add_product(\\"ProductC\\", 199.99) assert catalog.get_highest_price() == \\"ProductB\\" catalog.update_price(\\"ProductA\\", 299.99) assert catalog.get_highest_price() == \\"ProductA\\" catalog.add_product(\\"ProductD\\", 150.50) assert catalog.get_highest_price() == \\"ProductA\\" catalog.update_price(\\"ProductB\\", 349.49) assert catalog.get_highest_price() == \\"ProductB\\" ``` # Requirements Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"import heapq class ProductCatalog: def __init__(self): self.products = {} # To store product name to price mapping. self.heap = [] # To store negated prices and product names for max-heap property. def add_product(self, name: str, price: float): self.products[name] = price heapq.heappush(self.heap, (-price, name)) def update_price(self, name: str, new_price: float): if name in self.products: self.products[name] = new_price heapq.heappush(self.heap, (-new_price, name)) def get_highest_price(self) -> str: while self.heap: highest_price, name = heapq.heappop(self.heap) if -highest_price == self.products[name]: heapq.heappush(self.heap, (highest_price, name)) # Push it back as we confirm it\'s correct. return name # Example usage # catalog = ProductCatalog() # catalog.add_product(\\"ProductA\\", 99.99) # catalog.add_product(\\"ProductB\\", 249.95) # catalog.add_product(\\"ProductC\\", 199.99) # print(catalog.get_highest_price()) # Should be \\"ProductB\\" # catalog.update_price(\\"ProductA\\", 299.99) # print(catalog.get_highest_price()) # Should be \\"ProductA\\""},{"question":"# Fibonacci Sequence Checker You are tasked with implementing a function to check if a given number belongs to the Fibonacci sequence. Based on the properties of the Fibonacci sequence, design a function named `is_fibonacci(n: int) -> bool`. Requirements: 1. The function should return `True` if `n` is a Fibonacci number. 2. The function should return `False` if `n` is not a Fibonacci number. 3. Consider using properties or mathematical approaches to identify Fibonacci numbers efficiently. Constraints: - `0 <= n <= 10^6` Expected Input and Output: ```python >>> is_fibonacci(0) True >>> is_fibonacci(1) True >>> is_fibonacci(4) False >>> is_fibonacci(5) True >>> is_fibonacci(13) True >>> is_fibonacci(14) False >>> is_fibonacci(233) True >>> is_fibonacci(1000000) False ```","solution":"import math def is_fibonacci(n: int) -> bool: Checks if the given number n is a Fibonacci number. :param n: The number to check :return: True if n is a Fibonacci number, False otherwise if n < 0: return False # A number is a Fibonacci number if and only if one of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. def is_perfect_square(x): s = int(math.isqrt(x)) return s * s == x return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)"},{"question":"# Problem Statement You are tasked with implementing a function to manage a library\'s inventory of books. Your function should be able to add new books, update book quantities, and remove books from the inventory. Each book is represented by its ISBN, title, and quantity. # Requirements: Implement the function `library_inventory` with the following signature: ```python def library_inventory(operation: str, book_info: dict, inventory: dict) -> dict: ``` # Parameters: - `operation` (str): Represents the type of operation to perform. Valid values are `\'add\'`, `\'update\'`, and `\'remove\'`. - `book_info` (dict): Provides details about the book. Contains the following keys: - `isbn` (str): The ISBN of the book. - `title` (str): The title of the book. - `quantity` (int): The quantity of the book to add, update, or remove. - `inventory` (dict): The current inventory of books. Keys are ISBNs, and values are dictionaries with keys `title` and `quantity`. # Returns: - A dictionary representing the updated inventory. # Constraints: - The `operation` must be one of `\'add\'`, `\'update\'`, or `\'remove\'`. - The `isbn` must be a non-empty string. - The `title` must be a non-empty string. - The `quantity` must be a non-negative integer. - For the `\'remove\'` operation, if the book is not in the inventory or the specified quantity is greater than the available quantity, the function should raise a `ValueError`. # Example Usage: ```python >>> inventory = { ... \\"978-0-13-468599-1\\": {\\"title\\": \\"Effective Python\\", \\"quantity\\": 10}, ... \\"978-0-18-468599-2\\": {\\"title\\": \\"Learning Python\\", \\"quantity\\": 5} ... } >>> book_info = {\\"isbn\\": \\"978-0-13-468599-1\\", \\"title\\": \\"Effective Python\\", \\"quantity\\": 5} >>> library_inventory(\\"add\\", book_info, inventory) { \\"978-0-13-468599-1\\": {\\"title\\": \\"Effective Python\\", \\"quantity\\": 15}, \\"978-0-18-468599-2\\": {\\"title\\": \\"Learning Python\\", \\"quantity\\": 5} } >>> book_info = {\\"isbn\\": \\"978-0-13-468599-3\\", \\"title\\": \\"Python Cookbook\\", \\"quantity\\": 3} >>> library_inventory(\\"add\\", book_info, inventory) { \\"978-0-13-468599-1\\": {\\"title\\": \\"Effective Python\\", \\"quantity\\": 15}, \\"978-0-18-468599-2\\": {\\"title\\": \\"Learning Python\\", \\"quantity\\": 5}, \\"978-0-13-468599-3\\": {\\"title\\": \\"Python Cookbook\\", \\"quantity\\": 3} } >>> book_info = {\\"isbn\\": \\"978-0-18-468599-2\\", \\"title\\": \\"Learning Python\\", \\"quantity\\": 2} >>> library_inventory(\\"update\\", book_info, inventory) { \\"978-0-13-468599-1\\": {\\"title\\": \\"Effective Python\\", \\"quantity\\": 15}, \\"978-0-18-468599-2\\": {\\"title\\": \\"Learning Python\\", \\"quantity\\": 2}, \\"978-0-13-468599-3\\": {\\"title\\": \\"Python Cookbook\\", \\"quantity\\": 3} } >>> book_info = {\\"isbn\\": \\"978-0-13-468599-1\\", \\"title\\": \\"Effective Python\\", \\"quantity\\": 15} >>> library_inventory(\\"remove\\", book_info, inventory) { \\"978-0-18-468599-2\\": {\\"title\\": \\"Learning Python\\", \\"quantity\\": 2}, \\"978-0-13-468599-3\\": {\\"title\\": \\"Python Cookbook\\", \\"quantity\\": 3} } ``` Ensure your solution handles edge cases and adheres to the constraints provided.","solution":"def library_inventory(operation: str, book_info: dict, inventory: dict) -> dict: isbn = book_info[\'isbn\'] title = book_info[\'title\'] quantity = book_info[\'quantity\'] if isbn == \'\' or title == \'\' or quantity < 0: raise ValueError(\\"Invalid book information provided.\\") if operation == \'add\': if isbn in inventory: inventory[isbn][\'quantity\'] += quantity else: inventory[isbn] = {\'title\': title, \'quantity\': quantity} elif operation == \'update\': if isbn in inventory: inventory[isbn][\'quantity\'] = quantity else: raise ValueError(f\\"ISBN {isbn} not found in inventory.\\") elif operation == \'remove\': if isbn in inventory: if inventory[isbn][\'quantity\'] >= quantity: inventory[isbn][\'quantity\'] -= quantity if inventory[isbn][\'quantity\'] == 0: del inventory[isbn] else: raise ValueError(\\"Not enough quantity to remove.\\") else: raise ValueError(f\\"ISBN {isbn} not found in inventory.\\") else: raise ValueError(\\"Invalid operation.\\") return inventory"},{"question":"# Task Write a function `reverse_integer_with_constraints` that reverses the digits of a given integer while handling specific constraints. # Scenarios Your function will be used in a financial application where it\'s crucial to handle large sums accurately by reversing digits of account numbers. # Input - One integer `num` which can be positive or negative. # Output - An integer which is the reversed digits of `num`. # Constraints 1. If reversing `num` causes it to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, return 0. 2. You must handle negative numbers correctly in terms of their reversed sign. # Requirements - The function must preserve the sign of the input integer. - Return the reversed integer if it\'s within the 32-bit signed integer range, otherwise return 0. # Hints - Pay special attention to overflow and underflow conditions. - Ensure the function handles numbers with leading zeros correctly after reversal. # Example ```python def reverse_integer_with_constraints(num: int) -> int: # Your implementation here pass # Example Test Cases: print(reverse_integer_with_constraints(123)) # Expected output: 321 print(reverse_integer_with_constraints(-123)) # Expected output: -321 print(reverse_integer_with_constraints(120)) # Expected output: 21 print(reverse_integer_with_constraints(0)) # Expected output: 0 print(reverse_integer_with_constraints(1534236469)) # Expected output: 0 (since reversed number is outside 32-bit range) ```","solution":"def reverse_integer_with_constraints(num: int) -> int: Reverses the digits of the given integer while handling the 32-bit signed integer constraints. sign = -1 if num < 0 else 1 num = abs(num) reversed_num = int(str(num)[::-1]) * sign if reversed_num < -2**31 or reversed_num > 2**31 - 1: return 0 return reversed_num"},{"question":"# Question Write a Python function that takes an integer `n` and returns a list of all unique pairs of factors of `n` (excluding (1, n) and (n, 1)). A pair (a, b) is considered a factor pair of `n` if: - `a * b = n` - `1 < a <= b < n` The pairs should be listed in ascending order based on the first element of the pair. If there are no such pairs, return an empty list. Function Signature ```python def factor_pairs(n: int) -> List[Tuple[int, int]]: ``` Input - A single integer `n` (2 ≤ n ≤ 10^6). Output - A list of tuples, where each tuple contains two integers, representing unique pairs of factors of `n`. Example ```python print(factor_pairs(12)) # Should return [(2, 6), (3, 4)] print(factor_pairs(28)) # Should return [(2, 14), (4, 7)] print(factor_pairs(13)) # Should return [] ``` # Additional Notes - Ensure the solution performs efficiently even for large values of `n`. - Consider edge cases such as `n` being a prime number, where no pairs should be returned.","solution":"from typing import List, Tuple def factor_pairs(n: int) -> List[Tuple[int, int]]: Returns a list of all unique pairs of factors of `n` excluding (1, n) and (n, 1). result = [] for a in range(2, int(n**0.5) + 1): if n % a == 0: b = n // a if a <= b: result.append((a, b)) return result"},{"question":"# Sum of Unique Values in a List Scenario: You are working on an analytical software that processes a list of numerical values. One of the tasks involves calculating the sum of unique values in a list, where unique values are those that appear exactly once. Task: Implement a function `sumOfUniqueValues(nums: list[int]) -> int` that computes the sum of all values in the given list that occur exactly once. Function Signature: ```python def sumOfUniqueValues(nums: list[int]) -> int: ``` Input: - `nums`: List of integers. Output: - An integer representing the sum of all unique values in the list. Constraints: - 1 <= len(nums) <= 10^4 - -10^4 <= nums[i] <= 10^4 Example: ```python >>> sumOfUniqueValues([1, 2, 3, 2, 5]) 9 >>> sumOfUniqueValues([4, 4, 7, 8, 8]) 7 >>> sumOfUniqueValues([10, 20, 30, 40, 50]) 150 ``` Notes: - Handle edge cases like an empty list or a list with no unique values. - Ensure the solution is efficient for larger lists due to the constraints.","solution":"def sumOfUniqueValues(nums: list[int]) -> int: Returns the sum of unique values in the list. Unique values are those that appear exactly once. from collections import Counter # Count the occurrences of each number num_counts = Counter(nums) # Sum the values that occur exactly once unique_sum = sum(num for num, count in num_counts.items() if count == 1) return unique_sum"},{"question":"# Binary Tree Level Order Traversal Given a binary tree, implement a function `level_order_traversal(root: TreeNode) -> List[List[int]]` that returns the level order traversal of its nodes\' values. In a level order traversal, the nodes are visited level by level from left to right. Input * The input will consist of a single `TreeNode` object `root`, which represents the root of a binary tree. Output * The function should return a list of lists, where each sublist contains the values of the nodes at that level, from top to bottom. Constraints * The binary tree can have up to 10,000 nodes. * The values of the nodes can be any integer within the range of -2^31 to 2^31 - 1. * The tree might be unbalanced and contain null nodes. Examples # Example 1 Input: ```plaintext 3 / 9 20 / 15 7 ``` Output: ```python assert level_order_traversal(root) == [[3], [9, 20], [15, 7]] ``` # Example 2 Input: ```plaintext 1 / 2 3 / 4 ``` Output: ```python assert level_order_traversal(root) == [[1], [2, 3], [4]] ``` # Example 3 Input: ```plaintext 5 / 1 4 / 3 6 / 2 ``` Output: ```python assert level_order_traversal(root) == [[5], [1, 4], [3, 6], [2]] ``` Guidelines 1. Use a queue to facilitate the breadth-first search (BFS) necessary for level order traversal. 2. Consider edge cases such as an empty tree. 3. The solution should efficiently handle trees up to the maximum size constraint.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Question: Develop a function that calculates the total amount of rainfall collected in a 2D landscape represented by an array of non-negative integers. Each integer represents the height of the ground at that point in the landscape. Your function should compute how much water is stored between the heights after a rainstorm. Function Signature ```python def calculate_rainwater(heights: list) -> int: pass ``` Input - `heights` (list): A list of non-negative integers representing the height of the ground at each point. Output - `int`: The total amount of water collected between the heights. Constraints - The input list `heights` will have a length between 1 and 100,000. - Each height in the list will be a non-negative integer less than or equal to 1000. Example Input: ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] ``` Output: ```python 6 ``` Input: ```python heights = [4, 2, 0, 3, 2, 5] ``` Output: ```python 9 ``` Notes - Ensure your solution is efficient in terms of time and space complexity. - Water can only be stored between two higher bars. - Make sure to handle edge cases such as an empty list or all heights being zero.","solution":"def calculate_rainwater(heights: list) -> int: if not heights: return 0 n = len(heights) left_max, right_max = [0] * n, [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Coding Assessment Question: Context A financial services company needs to analyze transaction data to detect suspicious activities quickly. They\'ve identified that duplicate transaction records can sometimes cause confusion and inaccuracies in their analysis. To resolve this, they have devised a time-efficient deduplication method to handle incoming transaction IDs. Task Implement a function `deduplicate_transaction_ids(transaction_ids: list[int]) -> list[int]` that removes any duplicate transaction IDs from the list while maintaining the order of first occurrences. The function should cater to potentially massive datasets experienced by the company. Constraints * The input list can contain both positive and negative integers. * The list length can go up to (10^7). * Each transaction ID is a unique integer identifier within the range of (-10^9) to (10^9). Input & Output Format * Input: `transaction_ids` — a list of integers representing transaction IDs. * Output: A list of integers with duplicates removed, maintaining original order of their first occurrence. Examples: * `deduplicate_transaction_ids([1, 2, 3, 2, 1, 4, 5])` should return `[1, 2, 3, 4, 5]` * `deduplicate_transaction_ids([5, 5, 5, 2, 3, 4, 2])` should return `[5, 2, 3, 4]` * `deduplicate_transaction_ids([7, -1, 7, -1, 2])` should return `[7, -1, 2]` Performance Requirements * The implementation needs to handle very large input lists efficiently, with linear time complexity. * Memory usage should be optimized to ensure handling of the maximum constraint.","solution":"def deduplicate_transaction_ids(transaction_ids): Removes duplicate transaction IDs from the list while maintaining their order of first occurrences. Args: transaction_ids (list[int]): A list of integers representing transaction IDs. Returns: list[int]: A list of integers with duplicates removed. seen = set() deduplicated_list = [] for transaction_id in transaction_ids: if transaction_id not in seen: seen.add(transaction_id) deduplicated_list.append(transaction_id) return deduplicated_list"},{"question":"# Problem Statement You are part of a software development team creating a new 2D chess game application. One of the fundamental operations in the game is to validate potential moves of a bishop, a piece that moves diagonally any number of squares. To achieve this, you need to write a function that determines all valid positions a bishop can move to from a given starting position on an 8x8 chess board. The chessboard is represented using an 8x8 grid of coordinates with the top-left corner as (0, 0) and the bottom-right corner as (7, 7). # Function Signature ```python def valid_bishop_moves(start_position): Calculates all valid moves for a bishop from a given starting position on an 8x8 chess board. Arguments: start_position -- a tuple (x, y) representing the starting position of the bishop. Returns: A list of tuples representing all valid positions the bishop can move to. pass ``` # Input * `start_position` (tuple): A tuple (x, y) representing the starting position of the bishop on the chessboard. * (0 leq x leq 7) * (0 leq y leq 7) # Output * List of tuples: Each tuple represents a valid position (x, y) the bishop can move to. * (0 leq x leq 7) * (0 leq y leq 7) # Constraints * The function should account for all the physical limits of an 8x8 chess board. # Example ```python # Define the parameters start_position = (3, 3) # Call the function bishop_moves = valid_bishop_moves(start_position) # Example output # [(2, 2), (1, 1), (0, 0), (4, 4), (5, 5), (6, 6), (7, 7), (2, 4), (1, 5), (0, 6), (4, 2), (5, 1), (6, 0)] ``` # Explanation The function calculates all valid positions for a bishop starting from (3, 3) and returns a list of tuples representing these positions. The bishop can move diagonally in all four possible directions until it reaches the border of the board. Each move is represented as a tuple of (x, y) coordinates.","solution":"def valid_bishop_moves(start_position): Calculates all valid moves for a bishop from a given starting position on an 8x8 chess board. Arguments: start_position -- a tuple (x, y) representing the starting position of the bishop. Returns: A list of tuples representing all valid positions the bishop can move to. x, y = start_position moves = [] # Up-Left diagonal x_temp, y_temp = x, y while x_temp > 0 and y_temp > 0: x_temp -= 1 y_temp -= 1 moves.append((x_temp, y_temp)) # Up-Right diagonal x_temp, y_temp = x, y while x_temp < 7 and y_temp > 0: x_temp += 1 y_temp -= 1 moves.append((x_temp, y_temp)) # Down-Left diagonal x_temp, y_temp = x, y while x_temp > 0 and y_temp < 7: x_temp -= 1 y_temp += 1 moves.append((x_temp, y_temp)) # Down-Right diagonal x_temp, y_temp = x, y while x_temp < 7 and y_temp < 7: x_temp += 1 y_temp += 1 moves.append((x_temp, y_temp)) return moves"},{"question":"# Problem Statement You are asked to implement a text editor program that keeps track of text history, allowing users to perform undo and redo operations efficiently. The text editor should support the following commands: 1. **TYPE**: Add a new string of characters to the end of the current text. 2. **UNDO**: Revert the last change made to the text. 3. **REDO**: Reapply the last undone change. # Function to Implement `class TextEditor: def __init__(self): ... def type(self, text: str) -> None: ... def undo(self) -> None: ... def redo(self) -> None: ... def get_text(self) -> str: ...` Requirements * **type**: - **Input**: `text` (str): String to be appended to the current text. - **Output**: None * **undo**: - **Input**: None - **Output**: None * **redo**: - **Input**: None - **Output**: None * **get_text**: - **Input**: None - **Output**: Current text in the editor (str) Constraints - The text and operations can vary in length, but the total number of commands (type, undo, redo) will not exceed 1000. - Ensure the editor maintains history efficiently and all operations run in optimal time complexity. Example ```python def test_text_editor_operations(): editor = TextEditor() # Type some text editor.type(\'hello\') assert editor.get_text() == \'hello\', \\"Test Case 1 Failed\\" # Type more text editor.type(\' world\') assert editor.get_text() == \'hello world\', \\"Test Case 2 Failed\\" # Undo the last operation editor.undo() assert editor.get_text() == \'hello\', \\"Test Case 3 Failed\\" # Redo the last undone operation editor.redo() assert editor.get_text() == \'hello world\', \\"Test Case 4 Failed\\" # Undo twice editor.undo() editor.undo() assert editor.get_text() == \'\', \\"Test Case 5 Failed\\" # Redo twice editor.redo() editor.redo() assert editor.get_text() == \'hello world\', \\"Test Case 6 Failed\\" test_text_editor_operations() ``` # Explanation - The `TextEditor` class should maintain an internal representation of the text, along with the history of changes to support undo and redo operations. - The `type` method appends new text to the current string. - The `undo` method reverts the most recent operation. - The `redo` method reapplies the most recently undone operation. - The `get_text` method returns the current text in the editor. Ensure that your implementation maintains efficient handling of commands and adheres to the constraints mentioned above.","solution":"class TextEditor: def __init__(self): self.current_text = \'\' self.history = [] self.undo_stack = [] def type(self, text: str) -> None: self.history.append(self.current_text) self.current_text += text self.undo_stack.clear() def undo(self) -> None: if self.history: self.undo_stack.append(self.current_text) self.current_text = self.history.pop() def redo(self) -> None: if self.undo_stack: self.history.append(self.current_text) self.current_text = self.undo_stack.pop() def get_text(self) -> str: return self.current_text"},{"question":"# Implement Circular Queue You are to implement a circular queue using an array, which will support the following operations: `enqueue`, `dequeue`, `Front`, and `Rear`. The queue should have a fixed size and when it reaches its maximum capacity, the next element to be added will overwrite the oldest one (i.e., it functions in a circular manner). Function Signature ```python class CircularQueue: def __init__(self, k: int): # Initializes the circular queue with a fixed size of k pass def enqueue(self, value: int) -> bool: # Adds an element value to the circular queue # Returns True if the operation is successful, False otherwise pass def dequeue(self) -> bool: # Removes an element from the circular queue # Returns True if the operation is successful, False otherwise pass def Front(self) -> int: # Gets the front item from the queue # Returns -1 if the queue is empty pass def Rear(self) -> int: # Gets the last item from the queue # Returns -1 if the queue is empty pass def isEmpty(self) -> bool: # Checks whether the circular queue is empty or not pass def isFull(self) -> bool: # Checks whether the circular queue is full or not pass ``` Input * `k` (int): The maximum size of the circular queue, with (1 leq k leq 1000). * `value` (int): The integer value to be enqueued, with ( -10^3 leq value leq 10^3 ). Output * The return type of the methods should be as described in their definitions. Requirements * If the queue is full, and another item is enqueued, the oldest item in the queue is overwritten. * The enqueue, dequeue, Front, Rear, isEmpty, and isFull must all operate in O(1) time complexity. Example ```python # Initialize circular queue of size 3 circularQueue = CircularQueue(3) # Enqueue elements circularQueue.enqueue(1) # Returns True circularQueue.enqueue(2) # Returns True circularQueue.enqueue(3) # Returns True circularQueue.enqueue(4) # Returns True - Overwrites the oldest element (1) # Get front and rear elements circularQueue.Front() # Returns 2 circularQueue.Rear() # Returns 4 # Check if the circular queue is full circularQueue.isFull() # Returns True # Dequeue elements circularQueue.dequeue() # Returns True # Get front and rear elements after dequeue circularQueue.Front() # Returns 3 circularQueue.Rear() # Returns 4 # Check if the circular queue is empty circularQueue.isEmpty() # Returns False ``` Explanation 1. The queue is initialized with a size of 3. 2. The elements 1, 2, and 3 are enqueued successfully. 3. When the 4th element is enqueued, it overwrites the oldest element (which is 1) since the queue is full. 4. After enqueueing the 4th element, the front is the 2nd element (2) and the rear is the last enqueued element (4). 5. After dequeuing an element, the front becomes 3, and the rear remains 4. 6. The queue is checked for full capacity and emptiness as required. Both checks return the expected results. Implement the `CircularQueue` class to solve the problem efficiently. Make sure to handle all edge cases and optimize your solution to avoid redundant computations.","solution":"class CircularQueue: def __init__(self, k: int): self.queue = [None] * k self.head = -1 self.tail = -1 self.size = k def enqueue(self, value: int) -> bool: if self.isFull(): self.head = (self.head + 1) % self.size # Move head forwards in a circular manner elif self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: # Queue becomes empty after dequeue self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return not self.isEmpty() and (self.tail + 1) % self.size == self.head"},{"question":"# Context You are developing a text processing application that helps in analyzing word frequency in documents. One of the features requested is the ability to count exact occurrences of words while considering common punctuation as delimiters. # Problem Statement Write a function `count_word_occurrences(text: str) -> dict` that counts the occurrences of each word in a given text. Your implementation should: 1. Convert all words to lower case to ensure case-insensitivity. 2. Strip leading and trailing whitespace from the text. 3. Consider common punctuation (.,!?:;\\"\') as word boundaries and remove them. 4. Return a dictionary where the keys are unique words and the values are their counts. # Input * A string `text` (length <= 5000) which may include numbers, letters, and common punctuation. # Output * A dictionary with words as keys and their corresponding counts as values. # Constraints * The word delimiters are: space, period (.), comma (,), exclamation mark (!), question mark (?), colon (:), semicolon (;), quotation mark (\\"), and apostrophe (\'). # Examples ```python >>> count_word_occurrences(\\"Hello, World! Hello, world.\\") {\'hello\': 2, \'world\': 2} >>> count_word_occurrences(\\"Python\'s syntax is clear and simple; Python is powerful.\\") {\'python\': 2, \'s\': 1, \'syntax\': 1, \'is\': 2, \'clear\': 1, \'and\': 1, \'simple\': 1, \'powerful\': 1} >>> count_word_occurrences(\\"No punctuation\\") {\'no\': 1, \'punctuation\': 1} >>> count_word_occurrences(\\"\\") {} ``` # Detailed Requirements 1. Convert the entire text to lower case. 2. Remove any leading or trailing whitespace. 3. Remove common punctuation marks (.,!?:;\\"\') from each word. 4. Split the text by spaces to extract individual words. 5. Count the occurrences of each word and store them in a dictionary.","solution":"import re from collections import defaultdict def count_word_occurrences(text: str) -> dict: Counts the occurrences of each word in the input text while considering common punctuation as delimiters. :param text: A string which may include numbers, letters, and common punctuation. :return: A dictionary where the keys are unique words and the values are their counts. # Convert text to lower case text = text.lower() # Remove leading and trailing whitespace text = text.strip() # Remove common punctuation and split by spaces words = re.findall(r\'bw+b\', text) # Count occurrences of each word word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Question: Array Frequency Operations You are required to implement two functions to analyze the frequency of elements in an array of integers. Implement the Following Functions: **1. Function `element_frequency(arr: list) -> dict`:** * **Input**: A list of integers. * **Output**: A dictionary where keys are the unique elements in the array and values are the counts of their occurrences. * **Constraints**: * The input list should contain only integers. * Raise a `ValueError` if the input is empty or contains non-integer elements. **2. Function `most_frequent_element(arr: list) -> int`:** * **Input**: A list of integers. * **Output**: An integer representing the most frequently occurring element in the array. If there is a tie, return the smallest element. * **Constraints**: * The input list should contain only integers. * Raise a `ValueError` if the input is empty or contains non-integer elements. Example ```python >>> element_frequency([1, 2, 2, 3, 3, 3, 4]) {1: 1, 2: 2, 3: 3, 4: 1} >>> element_frequency([5, 5, 5, 5, 5]) {5: 5} >>> element_frequency([1, \'a\', 3]) ValueError: Input list contains non-integer elements. >>> most_frequent_element([1, 2, 2, 3, 3, 3, 4]) 3 >>> most_frequent_element([5, 1, 1, 5, 2, 2, 1]) 1 >>> most_frequent_element([7, 7, 7, 7]) 7 >>> most_frequent_element([]) ValueError: Input list is empty. ``` Notes: * Consider edge cases, such as ties in frequency and single-element lists. * Your implementations should consider performance with respect to large input sizes. Performance Requirements * Your implementations should aim for O(n) in time complexity and O(n) in space complexity. **Good Luck!**","solution":"def element_frequency(arr): Returns a dictionary where the keys are unique integers in the input list and the values are the counts of their occurrences. if not arr: raise ValueError(\\"Input list is empty.\\") frequency = {} for element in arr: if not isinstance(element, int): raise ValueError(\\"Input list contains non-integer elements.\\") if element in frequency: frequency[element] += 1 else: frequency[element] = 1 return frequency def most_frequent_element(arr): Returns the most frequently occurring integer in the input list. In case of a tie, returns the smallest integer among the most frequent ones. if not arr: raise ValueError(\\"Input list is empty.\\") frequency = element_frequency(arr) most_frequent = None max_count = 0 for element, count in frequency.items(): if count > max_count or (count == max_count and (most_frequent is None or element < most_frequent)): most_frequent = element max_count = count return most_frequent"},{"question":"# Reverse Words in a Sentence In this task, you are required to write a function that takes a sentence as input and returns a new sentence where each word is reversed, but the order of the words remains the same. Pay special attention to punctuation and capitalization. Requirements: - Reverse each word in the input sentence while keeping the order of words unchanged. - Retain the capitalization and punctuation in their respective positions relative to their words. Function Signature: ```python def reverse_words_in_sentence(sentence: str) -> str: Reverse each word in a sentence, keeping the order of the words unchanged. Parameters: sentence (str): The input sentence to be processed. Returns: str: A new sentence with each word reversed. ``` Constraints: - Sentence contains only alphanumeric characters and standard punctuation (e.g., commas, periods, exclamation marks). - Sentence length does not exceed 1000 characters. - Each word consists of alphabetic characters only; punctuation marks are not considered part of a word but should remain at their positions around the word. - Input sentence is guaranteed to have at least one word. Example Usage: ```python # Example 1 sentence = \\"Hello, world!\\" print(reverse_words_in_sentence(sentence)) # Output should be: \\"olleH, dlrow!\\" # Example 2 sentence = \\"The quick brown fox jumps over the lazy dog.\\" print(reverse_words_in_sentence(sentence)) # Output should be: \\"ehT kciuq nworb xof spmuj revo eht yzal god.\\" ``` Performance Requirements: - The function should complete in linear time, O(n), where n is the length of the input sentence. - The function should not use any external libraries beyond Python\'s standard library.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverse each word in a sentence, keeping the order of the words unchanged. Parameters: sentence (str): The input sentence to be processed. Returns: str: A new sentence with each word reversed. words = sentence.split() reversed_words = [] for word in words: start, end = 0, len(word) - 1 while start < len(word) and not word[start].isalpha(): start += 1 while end >= 0 and not word[end].isalpha(): end -= 1 reversed_word = list(word) while start < end: reversed_word[start], reversed_word[end] = reversed_word[end], reversed_word[start] start += 1 end -= 1 reversed_words.append(\'\'.join(reversed_word)) return \' \'.join(reversed_words)"},{"question":"# Binary Search Tree - AVL Tree Enhancement You are required to enhance the provided Binary Search Tree (BST) implementation to include features of an AVL Tree, a self-balancing binary search tree. 1. **Node Balancing Factor**: Implement a method to calculate and maintain the balance factor for each node in the tree. The balance factor is calculated as the height difference between the left and right subtrees. 2. **Rotation Methods**: Introduce methods for the four types of rotations needed to balance an AVL tree: left rotation, right rotation, left-right rotation, and right-left rotation. 3. **Insertion and Auto-Balancing**: Modify the insertion method to ensure that the tree remains balanced after each insertion by using the balance factors and rotation methods. # Input and Output Format * Implement three distinct methods in the AVLTree class: * `insert_data(self, key: int) -> None`: Inserts a node and balances the tree. * `delete_data(self, key: int) -> None`: Deletes a node and balances the tree. * `display(self) -> None`: Prints the tree in an in-order traversal format. # Constraints * The tree should store integer keys only. * Assume no duplicate keys will be inserted. # Examples ```python # Example usage: avl = AVLTree() # Insert elements and ensure self-balancing avl.insert_data(10) avl.insert_data(20) avl.insert_data(30) avl.display() # Should be balanced and print an in-order traversal # Node deletion and balancing avl.delete_data(20) avl.display() # Should re-balance and print an in-order traversal # Additional complex scenario avl.insert_data(25) avl.insert_data(5) avl.delete_data(10) avl.display() # Should show a self-balanced AVL Tree in in-order ``` Implement the updated AVLTree class based on the above requirements and guidelines.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def _get_height(self, node): if not node: return 0 return node.height def _get_balance_factor(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rebalance(self, node): balance = self._get_balance_factor(node) if balance > 1: if self._get_balance_factor(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1: if self._get_balance_factor(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def insert_data(self, key): self.root = self._insert(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def delete_data(self, key): self.root = self._delete(self.root, key) def _in_order_traversal(self, node, result): if not node: return self._in_order_traversal(node.left, result) result.append(node.key) self._in_order_traversal(node.right, result) def display(self): result = [] self._in_order_traversal(self.root, result) print(result)"},{"question":"# Problem Statement **Unique Chars Swapping Check** You have been assigned a task by the software engineering department of a leading tech company. Your goal is to write a Python function that checks if it is possible to make two strings identical by swapping exactly one pair of characters in one of the strings. Write a Python function `can_swap_to_match(s1: str, s2: str) -> bool` that determines if the two given strings can be made identical by swapping exactly one pair of characters in `s1`. **Input Format:** - Two strings `s1` and `s2` of the same length, consisting of lowercase alphabetical characters. **Output Format:** - Returns `True` if it is possible to make the two strings identical by swapping exactly one pair of characters in `s1`; otherwise, returns `False`. **Constraints:** - Both `s1` and `s2` are non-empty and have the same length. - The function should handle incorrect input types by raising a `ValueError` with an appropriate message. **Examples:** ```python >>> can_swap_to_match(\\"converse\\", \\"converse\\") True >>> can_swap_to_match(\\"ab\\", \\"ba\\") True >>> can_swap_to_match(\\"abcd\\", \\"abdc\\") True >>> can_swap_to_match(\\"abcd\\", \\"abcd\\") True >>> can_swap_to_match(\\"abcd\\", \\"abcc\\") False >>> can_swap_to_match(\\"aaaa\\", \\"aaab\\") False >>> can_swap_to_match(123, \\"abc\\") Traceback (most recent call last): ... ValueError: Both inputs must be strings >>> can_swap_to_match(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) Traceback (most recent call last): ... ValueError: Both inputs must be strings >>> can_swap_to_match(\\"abc\\", \\"ab\\") Traceback (most recent call last): ... ValueError: Both strings must be of the same length ``` Implement the function using the criteria described in the problem.","solution":"def can_swap_to_match(s1: str, s2: str) -> bool: Determine if two strings can be made identical by swapping exactly one pair of characters in s1. Parameters: s1 (str): First string s2 (str): Second string Returns: bool: True if one swap can make the strings identical, False otherwise. # Validate inputs if not isinstance(s1, str) or not isinstance(s2, str): raise ValueError(\\"Both inputs must be strings\\") if len(s1) != len(s2): raise ValueError(\\"Both strings must be of the same length\\") # If the strings are already identical if s1 == s2: return True # Find the indices where the characters differ diff = [] for i in range(len(s1)): if s1[i] != s2[i]: diff.append(i) # If there are exactly 2 differences, check if swapping them makes the strings match if len(diff) == 2: i, j = diff swapped_s1 = list(s1) swapped_s1[i], swapped_s1[j] = swapped_s1[j], swapped_s1[i] return \'\'.join(swapped_s1) == s2 # In all other cases, it\'s not possible to make them identical with one swap return False"},{"question":"# Scenario: You are developing a data analysis library and need to create a function that can compute the moving average of a sequence of numbers. Your task is to write a function that, given a list of integers and a window size, returns a new list containing the moving average of the given numbers. # Function Requirements: * Implement a function `calculate_moving_average` that takes a list of integers and a window size (an integer) and returns the moving averages as a list of floats. * Ensure the output list maintains the same length as the input list by padding the start with `None` where necessary to make up for the lack of preceding elements. * The window size will always be a positive integer less than or equal to the length of the list. # Constraints: * Input list will be non-empty. * The window size will be greater than zero and less than or equal to the length of the input list. # Function Signature: ```python def calculate_moving_average(numbers: List[int], window_size: int) -> List[Optional[float]]: pass ``` # Example: ```python assert calculate_moving_average([1, 2, 3, 4, 5], 3) == [None, None, 2.0, 3.0, 4.0] assert calculate_moving_average([10, 20, 30, 40, 50], 2) == [None, 15.0, 25.0, 35.0, 45.0] assert calculate_moving_average([1, 4, 7, 9, 10], 5) == [None, None, None, None, 6.2] ``` # Input: - `numbers` (List[int]): A list of integers. - `window_size` (int): The size of the moving average window. # Output: - (List[Optional[float]]): A list of moving average values as floats where the first `window_size-1` elements are `None`. **Good luck!**","solution":"from typing import List, Optional def calculate_moving_average(numbers: List[int], window_size: int) -> List[Optional[float]]: if window_size <= 0 or window_size > len(numbers): raise ValueError(\\"Invalid window size\\") moving_averages = [] for i in range(len(numbers)): # For the first (window_size - 1) elements, append None if i < window_size - 1: moving_averages.append(None) else: # Calculate the moving average for the window window = numbers[i-window_size+1:i+1] average = sum(window) / window_size moving_averages.append(average) return moving_averages"},{"question":"# Task: Write a function `largest_square_submatrix(matrix: List[List[int]]) -> int` that finds the size of the largest square submatrix with all 1s in a given binary matrix. # Function Signature: ```python def largest_square_submatrix(matrix: List[List[int]]) -> int: ... ``` # Input: 1. `matrix` (List of Lists): A binary matrix (list of lists) where each element is either 0 or 1. # Output: * An integer representing the size of the largest square submatrix with all 1s. # Constraints: * The number of rows and columns in the matrix is between 1 and 1000. * Each element in the matrix is either 0 or 1. # Example: ```python # Example 1: matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] print(largest_square_submatrix(matrix)) # Expected output: 2 # Example 2: matrix = [ [0, 1], [1, 1] ] print(largest_square_submatrix(matrix)) # Expected output: 1 # Example 3: matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] print(largest_square_submatrix(matrix)) # Expected output: 3 ``` # Hint: 1. Use dynamic programming to maintain a table where `dp[i][j]` represents the size of the largest square submatrix whose bottom-right corner is at `matrix[i][j]`. 2. If `matrix[i][j]` is 1, then `dp[i][j]` can be computed as the minimum of `dp[i-1][j]`, `dp[i][j-1]`, and `dp[i-1][j-1]` plus 1. 3. Initialize the table and iterate through the matrix to fill up this table based on the relation derived in hint 2. 4. The maximum value in the `dp` table would be the size of the largest square submatrix with all 1s.","solution":"from typing import List def largest_square_submatrix(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_size = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"# Matrix Path Finder with Dynamic Programming You are given a matrix of dimensions M x N with non-negative integers. Your task is to find the path from the top-left corner to the bottom-right corner of the matrix that minimizes the sum of the values on the path. You can only move either down or right at any point in time. # Problem Statement Implement a function `min_path_sum(matrix: List[List[int]]) -> int` that takes a 2D list representing the matrix and returns the minimum path sum from the top-left corner to the bottom-right corner. # Requirements Write a function `min_path_sum(matrix: List[List[int]]) -> int` that computes the minimum path sum, returning an integer representing the smallest sum of values among all possible paths. # Input * A 2D list `matrix` of size MxN (1 ≤ M, N ≤ 100) - `matrix[i][j]` is a non-negative integer (0 ≤ matrix[i][j] ≤ 100). # Output * A single integer representing the minimum path sum from the top-left to the bottom-right corner. # Constraints * M and N are each between 1 and 100, inclusive. * The values in the matrix are non-negative integers. * You can only travel to the right or down at any step. # Performance Requirements * The implementation should efficiently solve the problem for the maximum constraints using dynamic programming. # Scenario/Context Finding the minimum path in a matrix is a common problem in dynamic programming, often applied in optimization scenarios such as robotics, game development, and network routing. # Example ```python matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] result = min_path_sum(matrix) print(result) # Output: 7 ``` In this example, the path 1 → 3 → 1 → 1 → 1 yields the minimum path sum of 7. The function should efficiently compute the same for larger matrices.","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) # Initialize a 2D list for storing the minimum path sum at each cell dp = [[0] * N for _ in range(M)] # Set the value for the top-left cell dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, M): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = matrix[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The bottom-right cell contains the minimum path sum return dp[M - 1][N - 1]"},{"question":"# Problem Statement You have been given the task of analyzing and compressing text to save storage space. One common text compression method is Run-Length Encoding (RLE), where consecutive repeats of the same character are replaced by the character and the number of times it appears consecutively. # Task Design a function `run_length_encode(text: str) -> str` that takes a string `text` and returns its Run-Length Encoded (RLE) format. # Input - A string `text` containing only alphabetic characters (both uppercase and lowercase). # Output - A string representing the Run-Length Encoded format of the input text. # Constraints - `1 <= len(text) <= 1000`, the text will have at least one character and at most 1000 characters. # Example ```python >>> run_length_encode(\\"aaaabbbcca\\") \'a4b3c2a1\' >>> run_length_encode(\\"wwwwaaadexxxxxxywww\\") \'w4a3d1e1x6y1w3\' >>> run_length_encode(\\"a\\") \'a1\' >>> run_length_encode(\\"abbbc\\") \'a1b3c1\' ``` # Detailed Requirements 1. Read and process the input string `text` to generate its Run-Length Encoded form. 2. The function should operate efficiently considering both runtime and memory usage. 3. Ensure the function passes the provided example test cases. 4. The encoded format should concatenate each character followed by its count, providing a compact representation.","solution":"def run_length_encode(text: str) -> str: Encode the given text using Run-Length Encoding (RLE). :param text: The input string containing only alphabetic characters. :return: The Run-Length Encoded format of the input text. if not text: return \'\' encoded = [] current_char = text[0] count = 1 for char in text[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded.append(f\\"{current_char}{count}\\") return \'\'.join(encoded)"},{"question":"# [New Question] Prime Number and Matrix Manipulation Objective Given a matrix of integers, your task is to write a function that identifies all prime numbers within this matrix and replaces each prime number with its corresponding prime index, where the prime index of a prime number `p` is the count of prime numbers less than or equal to `p`. Problem Statement Write a function `replace_primes_with_indices` which takes a 2D numpy array of integers as input, identifies all prime numbers in this matrix, and replaces each prime number with its prime index. A prime number is defined as a number greater than 1 that has no positive divisors other than 1 and itself. The prime index of a prime number `p` is defined as the number of prime numbers less than or equal to `p`. The required function signature in Python: ```python def replace_primes_with_indices(matrix: np.ndarray) -> np.ndarray: ``` Constraints * The function should handle numpy arrays of any size. * The replacement should be done in place. * You should ensure that your implementation is efficient, particularly for large matrices. * Aim for an optimized solution using numpy operations and avoid nested loops where possible. Input * `matrix`: A 2D numpy array of shape (m, n), where `m` and `n` can be any positive integers. Output * Returns a 2D numpy array of the same shape (m, n) after replacing all prime numbers with their prime indices. Examples ```python import numpy as np def is_prime(n: int) -> bool: if n <= 1: return False for i in range(2, int(np.sqrt(n)) + 1): if n % i == 0: return False return True def prime_index(n: int) -> int: count = 0 for i in range(2, n + 1): if is_prime(i): count += 1 return count def replace_primes_with_indices(matrix: np.ndarray) -> np.ndarray: # Implement your function here. pass # Test Example matrix = np.array([ [2, 3, 4], [5, 6, 7], [8, 9, 10] ]) print(replace_primes_with_indices(matrix)) # Expected Output: # array([ # [1, 2, 4], # [3, 6, 4], # [8, 9, 10] # ]) ``` In the example provided, the prime numbers 2, 3, 5, and 7 are replaced with their prime indices 1, 2, 3, and 4 respectively.","solution":"import numpy as np def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False for i in range(2, int(np.sqrt(n)) + 1): if n % i == 0: return False return True def prime_index(n: int) -> int: Find number of primes less than or equal to n. count = 0 for i in range(2, n + 1): if is_prime(i): count += 1 return count def replace_primes_with_indices(matrix: np.ndarray) -> np.ndarray: Replace all prime numbers in a 2D numpy matrix with their prime indices. result = matrix.copy() for i in range(matrix.shape[0]): for j in range(matrix.shape[1]): if is_prime(matrix[i, j]): result[i, j] = prime_index(matrix[i, j]) return result"},{"question":"**Problem Description**: You need to write a function that returns the first `n` prime numbers. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. The function should return the list of first `n` primes. **Function Signature**: ```python def first_n_primes(n: int) -> List[int]: Returns the first n prime numbers. :param n: Integer, the number of prime numbers to return :return: List of integers that are the first n primes ``` **Input and Output**: - **Input**: An integer `n` (1 ≤ n ≤ 10^5), representing the number of prime numbers to return. - **Output**: A list of `n` prime numbers in increasing order. **Constraints**: - The function should handle finding primes up to the nth prime efficiently. **Example**: ```python assert first_n_primes(5) == [2, 3, 5, 7, 11] assert first_n_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert first_n_primes(1) == [2] ``` **Requirements**: - You should implement an efficient prime-finding algorithm, such as the Sieve of Eratosthenes or a similar optimized approach. - Focus on performance: it should handle large inputs quickly. **Scenario**: A client is developing a number theory module for educational purposes that needs to provide quick access to prime numbers. This method will be crucial for generating prime numbers dynamically based on user input for further studies and analysis. **Note**: Ensure your implementation is optimized for larger values of `n` to maintain efficiency and minimize execution time.","solution":"from typing import List def first_n_primes(n: int) -> List[int]: Returns the first n prime numbers. :param n: Integer, the number of prime numbers to return :return: List of integers that are the first n primes if n == 0: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > candidate: break if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes"},{"question":"# Problem Description A group of people arranged a relay race. Each participant receives a baton and must run a specified distance before handing the baton to the next participant. The challenge is to calculate the minimum time required for all participants to complete the race given that each participant runs at their own constant speed. You are provided with two lists: `distances` and `speeds`. The `distances[i]` represents the distance that the `i`-th participant needs to run, and the `speeds[i]` represents the speed at which the `i`-th participant runs. Find the minimum time for the race to be completed considering all participants run their segments sequentially. # Function Signature ```python def min_race_time(distances: List[int], speeds: List[int]) -> float: pass ``` # Input * `distances: List[int]` - A list of integers where `distances[i]` is the distance the `i`-th participant needs to run. (`1 <= len(distances) <= 10^3`, `1 <= distances[i] <= 10^6`) * `speeds: List[int]` - A list of integers where `speeds[i]` is the speed of the `i`-th participant. (`1 <= len(speeds) <= 10^3`, `1 <= speeds[i] <= 100`) # Output * Return a float value representing the minimum time required for the race to be completed. # Example 1. `distances = [400, 800, 1200], speeds = [4, 8, 6]` returns `432.0`: * The first participant runs 400 meters at 4 m/s, taking `400/4 = 100` seconds. * The second participant runs 800 meters at 8 m/s, taking `800/8 = 100` seconds. * The third participant runs 1200 meters at 6 m/s, taking `1200/6 = 200` seconds. * The total time is `100 + 100 + 200 = 400` seconds. 2. `distances = [500, 300], speeds = [5, 6]` returns `136.67` (rounded to two decimal places): * The first participant runs 500 meters at 5 m/s, taking `500/5 = 100` seconds. * The second participant runs 300 meters at 6 m/s, taking `300/6 = 50` seconds. * The total time is `100 + 50 = 150` seconds. # Constraints * Compute time should handle large datasets efficiently. # Note You should aim to process the calculations with precise floating-point arithmetic to ensure accuracy of the result.","solution":"from typing import List def min_race_time(distances: List[int], speeds: List[int]) -> float: total_time = 0.0 for distance, speed in zip(distances, speeds): total_time += distance / speed return total_time"},{"question":"# LCS Character Count Context The Longest Common Subsequence (LCS) is a classic problem in computer science concerning the comparison of two sequences to find the longest subsequence common to both. For example, the LCS of \\"AGGTAB\\" and \\"GXTXAYB\\" is \\"GTAB\\". Task Given two strings `s1` and `s2`, implement a function `lcs_char_count(s1, s2)` that returns the count of characters in the longest common subsequence of the two strings. ```python def lcs_char_count(s1: str, s2: str) -> int: Given two strings `s1` and `s2`, return the number of characters in the longest common subsequence of the strings. :param s1: First input string :type s1: str :param s2: Second input string :type s2: str :return: The count of characters in the longest common subsequence of `s1` and `s2` :rtype: int Examples: >>> lcs_char_count(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> lcs_char_count(\\"ABC\\", \\"AC\\") 2 >>> lcs_char_count(\\"ABCD\\", \\"XYZ\\") 0 pass ``` Constraints - (1 leq text{len}(s1), text{len}(s2) leq 10^3) - Strings `s1` and `s2` consist of uppercase English letters. Requirements - Ensure the function handles edge cases such as no common subsequence or very short input strings. - Optimize the function for both time and space efficiency where applicable.","solution":"def lcs_char_count(s1: str, s2: str) -> int: Given two strings `s1` and `s2`, return the number of characters in the longest common subsequence of the strings. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) return dp[m][n]"},{"question":"# Coding Assessment Question Context In software development, sometimes we need to process text data for various NLP (Natural Language Processing) tasks such as text summarization, keyword extraction, or analysis of text data patterns. One common task is to find the frequency of specific words in documents. Task Implement a function `most_frequent_words` in Python that takes a list of documents (each document is a string of words) and returns the most frequent word for each document. If there are multiple words with the highest frequency in a single document, return the word that appears first lexicographically. Function Signature ```python def most_frequent_words(documents: list[str]) -> list[str]: pass ``` Input * **documents**: a list of strings where each string represents a document consisting of words separated by space. Each word contains only alphabetic characters and is in lowercase. Output * **result**: a list of strings where each string represents the most frequent word of the corresponding document. If there are multiple words with the same highest frequency, return the word that appears first in lexicographical order. Constraints * You can assume that all words in the documents are separated by a single space. * Each document in the list will consist of at least one word. * The length of `documents` will be in the range [1, 10^5]. * The length of each document string will not exceed 10^5 characters. * Each word in a document will have a length in the range [1, 100]. Examples ```python >>> most_frequent_words([\\"apple banana apple\\", \\"cat bat cat dog bat\\"]) [\\"apple\\", \\"bat\\"] >>> most_frequent_words([\\"the quick brown fox\\", \\"jumped over the lazy dog\\"]) [\\"the\\", \\"dog\\"] >>> most_frequent_words([\\"hello world hello\\", \\"test test test\\", \\"word\\"]) [\\"hello\\", \\"test\\", \\"word\\"] ``` Additional Requirement * Your function must be optimized to handle the upper constraint limits efficiently. * Ensure proper error handling for edge cases such as documents with single words or no repetitions. The question above fits well with a coding assessment focusing on string manipulation, efficient counting algorithms, and handling large datasets, aligning well with the sample question\'s style and complexity.","solution":"def most_frequent_words(documents: list[str]) -> list[str]: from collections import Counter result = [] for doc in documents: words = doc.split() word_count = Counter(words) most_frequent = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) result.append(most_frequent[0][0]) return result"},{"question":"# Question Context You are working on a data validation system for a large e-commerce platform. The system needs to ensure that user input, particularly email addresses, is valid before proceeding to account creation or checkout processes. An email address is considered valid if it meets the following criteria: 1. It contains exactly one \'@\' character. 2. The local part (portion before \'@\') has only alphanumeric characters and may contain dots (\'.\'), underscores (\'_\'), and hyphens (\'-\'). 3. The domain part (portion after \'@\') has only alphanumeric characters and may contain dots (\'.\') and hyphens (\'-\'), but every dot should be followed by at least one alphanumeric character. Task Write a function: 1. `validate_email(email: str) -> bool`: Given a string `email`, return `True` if the email is valid according to the criteria, and `False` otherwise. - **Input**: A string `email` representing an email address. - **Output**: A boolean value indicating whether the email is valid (`True`) or not (`False`). Constraints * A valid email should follow the standard format outlined above. * The input string may contain uppercase and lowercase letters. * Assume the input string has a maximum length of 320 characters. Examples ```python assert validate_email(\\"john.doe@example.com\\") == True assert validate_email(\\"jane.doe@ex-ample.com\\") == True assert validate_email(\\"user.name@domain.co.in\\") == True assert validate_email(\\"user@domain\\") == False # Invalid because the domain part must have at least one dot. assert validate_email(\\"user@.domain.com\\") == False # Invalid because the domain part starts with a dot. assert validate_email(\\"user@@domain.com\\") == False # Invalid because of double \'@\' character. assert validate_email(\\"user@domain..com\\") == False # Invalid because of consecutive dots in domain. ``` Implement the function ensuring correctness and efficient validation of email inputs. You are not allowed to use any external libraries for this validation, except for basic string operations.","solution":"import re def validate_email(email: str) -> bool: Validate the email address. :param email: A string representing an email address. :return: True if the email is valid, otherwise False. # Regex for validating email regex = r\'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' # Check if the email matches the regex pattern if not re.match(regex, email): return False # Split the email into local part and domain part local, domain = email.split(\'@\', 1) # Check if the local part contains only allowed characters if not re.match(r\'^[a-zA-Z0-9._-]+\', local): return False # Check if the domain is valid if not re.match(r\'^[a-zA-Z0-9.-]+.[a-zA-Z]+\', domain): return False # Check if domain follows the rules for part in domain.split(\'.\'): if not part: # Empty parts are not allowed return False return True"},{"question":"# Circular Array Rotation Background: A circular array rotation allows for the elements at the end of an array to wrap around to the front of the array. This creates a new array where elements have shifted positions with boundary conditions managed properly. Task: You are required to implement the function `circular_array_rotation` as described in the code snippet provided to perform a specified number of rotations on an array. Your function should correctly handle edge cases and scenarios including zero rotations. Function Signature: ```python def circular_array_rotation(arr: list, rotations: int) -> list: Rotate the elements of an array to the right by a specified number of rotations. Input Parameters: arr (list): A list of integer elements to be rotated. rotations (int): The number of times to rotate the array to the right. Returns: list: A new list with the elements rotated to the right. Raises: TypeError: If `arr` is not a list or `rotations` is not an integer. ValueError: If `arr` contains non-integer elements. ``` Example Tests: ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 2) # rotating twice to the right [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3, 4, 5], 5) # rotating same length as array [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 7) # rotating more than array length [4, 5, 1, 2, 3] >>> circular_array_rotation([], 3) # empty array [] >>> circular_array_rotation([1], 3) # single element array [1] >>> circular_array_rotation([\\"a\\", 2, 3], 1) # non-integer element in array Traceback (most recent call last): ... ValueError: arr must contain only integer elements. >>> circular_array_rotation([1, 2, 3], \\"3\\") # rotations is not an integer Traceback (most recent call last): ... TypeError: rotations must be an integer. ``` Constraints: * The function should handle empty arrays and arrays with a single element seamlessly. * Ensure the `rotations` parameter is a non-negative integer. * Array elements should be integers. This new question focuses on the practical array manipulation concept of circular rotations, ensuring the complexity, scope, and structure align with the provided Doppler Effect frequency calculation question.","solution":"def circular_array_rotation(arr: list, rotations: int) -> list: Rotate the elements of an array to the right by a specified number of rotations. Input Parameters: arr (list): A list of integer elements to be rotated. rotations (int): The number of times to rotate the array to the right. Returns: list: A new list with the elements rotated to the right. Raises: TypeError: If `arr` is not a list or `rotations` is not an integer. ValueError: If `arr` contains non-integer elements. if not isinstance(arr, list): raise TypeError(\\"arr must be a list\\") if not isinstance(rotations, int): raise TypeError(\\"rotations must be an integer\\") for element in arr: if not isinstance(element, int): raise ValueError(\\"arr must contain only integer elements\\") if len(arr) == 0: return [] rotations %= len(arr) # To handle cases where rotations is greater than array length return arr[-rotations:] + arr[:-rotations]"},{"question":"# Problem Statement Given a collection of words and a specific word, find the longest word in the collection that can be constructed by deleting some characters of the specific word without rearranging the characters. # Function Signature ```python def find_longest_word(s: str, dictionary: List[str]) -> str: ``` # Input - `s`: A string consisting of lowercase letters with a length between 1 and 500. - `dictionary`: A list of strings representing the collection of words. Each word only contains lowercase letters and has a length between 1 and 500. The length of the list does not exceed 1000. # Output - The longest word from the dictionary that can be constructed by deleting some characters of `s` without rearranging the characters. If there are multiple results, return the one which is lexicographically smallest. # Example ```python s = \\"abpcplea\\" dictionary = [\\"ale\\",\\"apple\\",\\"monkey\\",\\"plea\\"] print(find_longest_word(s, dictionary)) # Output: \\"apple\\" ``` # Constraints - Aim for an efficient solution that prunes unnecessary checks early. - Consider edge cases such as the dictionary being empty or no possible words matching the criteria. - Make sure your function handles multiple potential answers by returning the lexicographically smallest word. # Notes 1. You might find it helpful to consider two pointers or similar methods to efficiently check if a word can be formed from `s`. 2. Ensure the function performs well even with the maximum input sizes specified.","solution":"from typing import List def can_form_by_deleting(s: str, word: str) -> bool: it = iter(s) return all(char in it for char in word) def find_longest_word(s: str, dictionary: List[str]) -> str: possible_words = [ word for word in dictionary if can_form_by_deleting(s, word) ] # Sort primarily by -length, and lexicographically as a secondary criteria possible_words.sort(key=lambda x: (-len(x), x)) return possible_words[0] if possible_words else \\"\\""},{"question":"# Fibonacci Sequence with Memoization **Context**: You’re working on a system with resource constraints, and you need to compute Fibonacci numbers efficiently. A naive recursive approach is too slow due to redundant calculations, so you decide to use memoization to optimize the process. **Task**: Implement the Fibonacci sequence generator provided in the code snippet using memoization to complete the function. Ensure that you handle various edge cases, including improper inputs, and optimize for both time and space where necessary. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input * A single integer `n` (0 ≤ n ≤ 10^5). Output * An integer representing the `n`-th Fibonacci number. Constraints * The function should raise a `ValueError` if `n` is negative or not an integer value. Examples ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: Number -1 must instead be a non-negative integer >>> fibonacci(22.2) Traceback (most recent call last): ... ValueError: Number 22.2 must instead be a non-negative integer ``` **Performance Requirements**: * Ensure your implementation runs within reasonable time limits for the largest input size (up to 10^5). * Optimize space usage when possible while maintaining correctness. **Edge Cases**: * Handle inputs that are not non-negative integers (including negative numbers and floating-point numbers) by raising appropriate exceptions. Please implement the function `fibonacci` as described above.","solution":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using memoization. Parameters: n (int): A non-negative integer representing the position in the Fibonacci sequence. Returns: int: The nth Fibonacci number. Raises: ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(f\\"Number {n} must instead be a non-negative integer\\") memo = {0: 0, 1: 1} def fib_memo(n): if n not in memo: memo[n] = fib_memo(n - 1) + fib_memo(n - 2) return memo[n] return fib_memo(n)"},{"question":"# Question **Context**: Tribonacci numbers are a sequence of numbers similar to the Fibonacci sequence, but each term is the sum of the three preceding ones, starting with three predetermined terms. The sequence is defined as follows: - `T(0) = 0, T(1) = 1, T(2) = 1` - `T(n) = T(n-1) + T(n-2) + T(n-3)` for `n >= 3` Write a function that computes the nth Tribonacci number. This sequence has applications in various combinatorial problems. **Task**: You need to write a function that calculates the nth Tribonacci number. Your function should handle edge cases and optimize performance for larger inputs. **Function Signature**: ```python def tribonacci(n: int) -> int: pass ``` **Input**: * An integer `n` such that ( n geq 0 ). **Output**: * An integer that represents the nth Tribonacci number. **Constraints**: 1. ( 0 leq n leq 35 ). **Requirements**: 1. Your implementation should handle invalid inputs gracefully, raising appropriate errors. 2. Optimize performance to handle the upper limit of the constraints efficiently. **Example**: ```python >>> tribonacci(0) 0 >>> tribonacci(4) 4 >>> tribonacci(10) 149 ``` Explanation: 1. The initial terms of the sequence are `0, 1, 1`. 2. The fourth term is calculated as `1 + 1 + 0 = 2`. 3. The tenth term can be computed using the previously defined relation. **Edge cases to consider**: * Handling negative and non-integer inputs. * Ensuring that the function does not exceed expected computation times for larger values of `n`. **Hints**: - Consider using dynamic programming approaches or memoization to store already calculated values. - Ensure input validation to handle erroneous cases.","solution":"def tribonacci(n: int) -> int: Returns the nth Tribonacci number. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t3 = t0 + t1 + t2 t0, t1, t2 = t1, t2, t3 return t3"},{"question":"# Finding the Second Largest Element in a List In many applications, you may need to determine the second largest element in a list of numbers. You are required to implement a function in Python that identifies the second largest element in a list. # Function Signature ```python def second_largest(nums: list) -> int: pass ``` # Input: - `nums` (list): A list of integers. # Output: - Return the second largest integer in the list. # Constraints: - The list `nums` must contain at least two unique elements. - If the list does not contain at least two unique elements, raise a `ValueError` with a message saying \\"The list must contain at least two unique elements.\\" - Do not use the in-built `sorted()` function. # Implementation Notes: 1. You should traverse the list at least once to determine the second largest element. 2. Handle cases where there may be duplicates, but still ensure the second largest unique value is returned. 3. Optimize for both time and space where possible. # Example Usage: ```python second_largest([1, 3, 4, 5, 0, 2]) # => 4 second_largest([10, 20, 4, 45, 99]) # => 45 second_largest([-10, -20, -4, -5, -9]) # => -5 ``` # Unit Testing: Ensure your solution is thoroughly tested with the following sample cases as well as edge cases: - `second_largest([1, 2, 3, 4, 5])` should return `4`. - `second_largest([5, 5, 5, 5, 5, 6])` should return `5`. - `second_largest([100, 90])` should return `90`. - `second_largest([1, 1, 1, 1, 1])` should raise a `ValueError`. - `second_largest([5])` should raise a `ValueError`.","solution":"def second_largest(nums: list) -> int: Returns the second largest integer in the list nums. Raises a ValueError if the list does not contain at least two unique elements. if len(set(nums)) < 2: raise ValueError(\\"The list must contain at least two unique elements.\\") first, second = float(\'-inf\'), float(\'-inf\') for num in nums: if num > first: first, second = num, first elif first > num > second: second = num return second"},{"question":"# Coding Question Context You are developing a system to manage tasks based on their priorities. Each task can be represented with an \\"id\\" and a \\"priority\\". Higher priority tasks are served first, and tasks with the same priority are served in the order they were added. Implement a priority queue to handle this scenario. Problem Statement Implement a `TaskPriorityQueue` class that provides the following functionalities: 1. `add_task(task_id, priority)`: Adds a new task with a specific priority to the queue. 2. `get_task()`: Retrieves and removes the task with the highest priority. If multiple tasks have the same priority, it retrieves and removes the one that was added earliest. 3. `peek()`: Returns the task with the highest priority without removing it from the queue. ```python class TaskPriorityQueue: def __init__(self): self.queue = [] def add_task(self, task_id, priority): Adds a new task with the specific priority to the queue. Parameters: task_id (str): The ID of the task. priority (int): The priority of the task. pass def get_task(self): Retrieves and removes the task with the highest priority. Returns: (str): The ID of the task with the highest priority. pass def peek(self): Returns the task with the highest priority without removing it. Returns: (str): The ID of the task with the highest priority. pass ``` # Constraints 1. Each task has a unique `task_id`. 2. Priorities are represented as integers, where higher values denote higher priorities. 3. Assume there will be at least one task in the queue when `get_task` or `peek` is called. Example ```python pq = TaskPriorityQueue() pq.add_task(\\"task1\\", 5) pq.add_task(\\"task2\\", 1) pq.add_task(\\"task3\\", 3) # Since \\"task1\\" has the highest priority (5), it should be retrieved first assert pq.get_task() == \\"task1\\" # Now \\"task3\\" has the highest priority (3) and should be the next task assert pq.peek() == \\"task3\\" # After retrieving \\"task3\\", the queue should have only \\"task2\\" assert pq.get_task() == \\"task3\\" assert pq.get_task() == \\"task2\\" ``` # Performance Requirements Your implementations for `add_task`, `get_task`, and `peek` should each have a time complexity of O(log n), where n is the number of tasks in the queue.","solution":"import heapq class TaskPriorityQueue: def __init__(self): self.queue = [] self.counter = 0 # This counter will help to maintain the order of insertion def add_task(self, task_id, priority): Adds a new task with the specific priority to the queue. Parameters: task_id (str): The ID of the task. priority (int): The priority of the task. # Use negative priority to simulate a max-heap with heapq which is a min-heap by default. heapq.heappush(self.queue, (-priority, self.counter, task_id)) self.counter += 1 def get_task(self): Retrieves and removes the task with the highest priority. Returns: (str): The ID of the task with the highest priority. return heapq.heappop(self.queue)[2] def peek(self): Returns the task with the highest priority without removing it. Returns: (str): The ID of the task with the highest priority. return self.queue[0][2]"},{"question":"# Problem Statement Write a function to determine the minimum number of points that must be removed from a 2D integer grid so that no two remaining points have the same x-coordinate or the same y-coordinate. You need to ensure efficient handling of grid parsing and removal logic, especially for large grids. # Function Signature ```python def min_removals_to_unique_coordinates(grid: List[List[int]]) -> int: ``` # Input - **grid**: A list of lists where each sublist `[x, y]` represents a point on the 2D grid with integer coordinates. # Output - Returns an integer denoting the minimum number of points that need to be removed. # Constraints - Each point on the grid has distinct coordinates. - The grid will not be empty and can contain up to 10^4 points. # Example ```python grid = [[1, 2], [2, 2], [3, 4], [5, 3], [1, 3]] print(min_removals_to_unique_coordinates(grid)) # Output: 2 ``` # Requirements 1. Parse through the grid to collect occurrences of each x-coordinate and y-coordinate. 2. Identify conflicts where coordinates are not unique. 3. Implement a strategy to minimize removals, removing points causing most conflicts. **Note**: Your solution must effectively parse the grid, handle potential large input sizes, and include clear logic for conflict resolution and removal to ensure remaining points have unique x and y coordinates.","solution":"from collections import defaultdict from typing import List def min_removals_to_unique_coordinates(grid: List[List[int]]) -> int: x_count = defaultdict(int) y_count = defaultdict(int) # Count occurrences of each x and y coordinate for x, y in grid: x_count[x] += 1 y_count[y] += 1 removal_count = 0 # Go through the grid and count necessary removals for conflicts for x, y in grid: if x_count[x] > 1 or y_count[y] > 1: removal_count += 1 x_count[x] -= 1 y_count[y] -= 1 return removal_count"},{"question":"# Reverse Words in a String Overview You are developing a feature to process text input for a messaging app. As a part of this feature, you need to implement a function that reverses the order of words in a given string. Problem Statement Implement a function `reverse_words(sentence: str) -> str` that reverses the order of words in the input string `sentence`. Words are defined as sequences of characters separated by spaces. Any leading or trailing spaces should be removed, and multiple spaces between words should be reduced to a single space in the output. Input - `sentence`: A string `sentence` that may contain multiple spaces between words and possibly leading or trailing spaces. Output - A string representing the input string with the words in reverse order, where words are separated by a single space. Constraints - The input string `sentence` will contain only alphabetical characters and spaces. - The input string will have at least one word. Example ```python sentence = \\" the sky is blue \\" output = \\"blue is sky the\\" assert reverse_words(\\" the sky is blue \\") == \\"blue is sky the\\" ``` ```python sentence = \\"hello world\\" output = \\"world hello\\" assert reverse_words(\\"hello world\\") == \\"world hello\\" ``` ```python sentence = \\"a good example\\" output = \\"example good a\\" assert reverse_words(\\"a good example\\") == \\"example good a\\" ``` Notes - Ensure to handle cases with multiple spaces correctly. - Avoid using excessive memory to store words during processing.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in the input string `sentence`. Parameters: - sentence (str): The input sentence that may contain multiple spaces. Returns: - str: The sentence with words in reversed order and single spaces between words. # Split the sentence by whitespace to get words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list with a single space reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"# Coding Question: Highest Average Test Scores You are given a set of student\'s test scores, where each entry consists of a student\'s name and their score for a particular test. Your task is to determine which student has the highest average test score. # Function Signature ```python def highest_average_score(scores: List[Tuple[str, int]]) -> str: pass ``` # Input * A list of tuples `scores` where each tuple contains: * a string representing the student\'s name ((1 leq len(name) leq 100)) * an integer representing their test score ((0 leq score leq 100)) # Output * A string representing the name of the student with the highest average test score. If multiple students have the same highest average score, return any one of them. # Example ```python assert highest_average_score([(\\"Alice\\", 90), (\\"Bob\\", 85), (\\"Alice\\", 95), (\\"Bob\\", 90)]) == \\"Alice\\" assert highest_average_score([(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Alice\\", 70), (\\"Bob\\", 85)]) == \\"Bob\\" ``` # Constraints * You may assume there is at least one student\'s test score in the list. * All names are unique per student, but a student can appear multiple times in the list. * Minimize the time complexity as much as possible. # Guidelines for Implementation: 1. Use a dictionary to store the sum of scores and count of scores for each student. 2. Calculate the average score for each student. 3. Determine the student with the highest average score. 4. Handle edge cases meticulously, such as lists with only one student\'s scores or lists where multiple students have the same highest average.","solution":"from typing import List, Tuple def highest_average_score(scores: List[Tuple[str, int]]) -> str: student_scores = {} for name, score in scores: if name not in student_scores: student_scores[name] = [] student_scores[name].append(score) highest_avg = -1 top_student = \\"\\" for name, score_list in student_scores.items(): avg_score = sum(score_list) / len(score_list) if avg_score > highest_avg: highest_avg = avg_score top_student = name return top_student"},{"question":"# Question: You are to implement a function that finds the smallest window in a string containing all the characters of another given string. **Objective:** Write the function `find_smallest_window`. 1. `find_smallest_window(s: str, t: str) -> str`: - Finds the smallest substring in `s` that contains all the characters in `t` (including duplicates). **Constraints:** - If there is no such window, return an empty string. - The length of `s` and `t` will each be in the range of [1, 10^5]. - The input strings `s` and `t` consist only of lowercase alphabetic characters. **Input and Output:** - **Input**: Two strings `s` and `t`. - **Output**: The smallest substring of `s` that contains all the characters of `t`. **Examples:** 1. **Example 1:** ```python >>> find_smallest_window(\\"ADOBECODEBANC\\", \\"ABC\\") \'BANC\' ``` 2. **Example 2:** ```python >>> find_smallest_window(\\"a\\", \\"a\\") \'a\' ``` 3. **Example 3:** ```python >>> find_smallest_window(\\"a\\", \\"aa\\") \'\' ``` **Function Signature:** ```python def find_smallest_window(s: str, t: str) -> str: pass ``` **Performance Requirements:** - The solution should handle inputs efficiently within the provided constraints. --- In **Example 1**, the smallest substring of `\\"ADOBECODEBANC\\"` containing all the characters from `\\"ABC\\"` is `\\"BANC\\"`. The approach typically involves using the sliding window technique and a hashmap to track character counts for an efficient solution. Vertical and horizontal movements of the window are managed to find the optimal small window while ensuring it contains all required characters.","solution":"def find_smallest_window(s: str, t: str) -> str: from collections import Counter, defaultdict if not s or not t or len(s) < len(t): return \\"\\" count_t = Counter(t) required = len(count_t) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) min_len = float(\'inf\') min_window = \\"\\" while right < len(s): char = s[right] window_counts[char] += 1 if char in count_t and window_counts[char] == count_t[char]: formed += 1 while left <= right and formed == required: char = s[left] if right - left + 1 < min_len: min_len = right - left + 1 min_window = s[left:right + 1] window_counts[char] -= 1 if char in count_t and window_counts[char] < count_t[char]: formed -= 1 left += 1 right += 1 return min_window"},{"question":"# Question Context Working with strings and pattern matching is a common task in coding environments, particularly useful for tasks that involve parsing or analyzing text data. Efficient pattern matching algorithms are essential for performing such operations optimally. Problem Statement You are given a string `s` and a string `p` which is a pattern. Implement a function that checks whether the pattern `p` matches the entire string `s`. The pattern `p` can include the special characters `?` and `*`, where `?` matches any single character and `*` matches any sequence of characters (including the empty sequence). # Function Signature ```python def is_match(s: str, p: str) -> bool: Checks if the given pattern matches the entire string. :param s: A string to be matched. :param p: A pattern string which may contain the special characters \'?\' and \'*\'. :return: True if the pattern matches the entire string; otherwise, False. Example: >>> is_match(\\"adceb\\", \\"*a*b\\") True >>> is_match(\\"acdcb\\", \\"a*c?b\\") False ``` # Constraints: * The input strings `s` and `p` are non-empty and have a length of at most 2000 characters. * The pattern `p` consists of lowercase letters, `?`, and `*`. # Requirements: 1. **Function Implementation:** Correctly implement the pattern matching based on the special characters `?` and `*`. 2. **Edge Case Handling:** Proper handling of patterns that lead or end with special characters. 3. **Input Validation:** Ensure the input strings follow the given constraints. # Example: ```python >>> is_match(\\"aa\\", \\"a\\") False >>> is_match(\\"aa\\", \\"*\\") True >>> is_match(\\"cb\\", \\"?a\\") False >>> is_match(\\"adceb\\", \\"*a*b\\") True ``` # Additional Notes: * You may use dynamic programming techniques to solve the problem efficiently. * Consider optimizing the solution to avoid unnecessary computations, especially given the constraint on the length of the input strings.","solution":"def is_match(s: str, p: str) -> bool: Checks if the given pattern matches the entire string. :param s: A string to be matched. :param p: A pattern string which may contain the special characters \'?\' and \'*\'. :return: True if the pattern matches the entire string; otherwise, False. m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Coding Assessment Question Context In computer science, dynamic programming is a technique for solving problems by breaking them down into simpler subproblems and storing the results of subproblems to avoid redundant work. One classic problem that can be approached via dynamic programming is the \\"Longest Increasing Subsequence\\" problem. A subsequence is derived from an array by deleting some or no elements without changing the order of the remaining elements. The \\"Longest Increasing Subsequence (LIS)\\" problem is to find the length of the longest subsequence of the given array such that all elements of the subsequence are sorted in increasing order. We will assess your understanding of dynamic programming by solving the LIS problem. Task You need to write a function `longest_increasing_subsequence` that takes in a list of integers and returns the length of the longest increasing subsequence. Input - `arr` (1 <= len(arr) <= 10^4): A list of integers, where each integer can be negative, zero, or positive. The maximum absolute value of any integer in the list will be 10^4. Output - An integer representing the length of the longest increasing subsequence in the given list. Constraints - The function should handle both small and large arrays efficiently. - It should provide an optimized solution to ensure performance within the provided constraints. # Function Signature ```python def longest_increasing_subsequence(arr: list[int]) -> int: pass ``` # Performance Requirements: - Aim for a time complexity of O(n log n). - Ensure memory usage is efficient. # Example ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 ``` # Notes - Make sure to handle edge cases where arrays might have a single element or be sorted in descending order. - Consider using binary search to optimize the subsequence extension process.","solution":"import bisect def longest_increasing_subsequence(arr: list[int]) -> int: Returns the length of the longest increasing subsequence in the given list of integers. if not arr: return 0 subsequence = [] for num in arr: pos = bisect.bisect_left(subsequence, num) if pos == len(subsequence): subsequence.append(num) else: subsequence[pos] = num return len(subsequence)"},{"question":"# Problem Statement **Background**: Matrix transposition is a basic operation which involves swapping the rows and columns of the matrix. It has practical applications in various domains like computer graphics and data formatting. # Description Implement a function `transpose_matrix` that transposes a given 2D square matrix (n x n). The function should: 1. Modify the given matrix in place. 2. Ensure that the resulting matrix is the transpose of the original. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> None: pass ``` # Input - `matrix`: A 2D list of integers representing a square matrix (i.e., the number of rows is equal to the number of columns), where 1 <= len(matrix) <= 500 and 0 <= matrix[i][j] <= 10^9. # Output - The function modifies the input matrix in place, so there is no return value. # Constraints - The function should handle matrices with dimensions up to 500 x 500 efficiently. - Matrix values range from 0 to 10^9. # Performance Requirements - The function should have a time complexity of O(n^2), where n is the number of rows (or columns) of the matrix. - Use O(1) additional space (modify the matrix in place). # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transpose_matrix(matrix) assert matrix == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] matrix = [ [1] ] transpose_matrix(matrix) assert matrix == [ [1] ] matrix = [ [3, 4], [1, 8] ] transpose_matrix(matrix) assert matrix == [ [3, 1], [4, 8] ] ``` # Constraints and Notes - Use helper functions if required. - Ensure that your implementation handles edge cases, including single element matrices and very large values. - The transpose of a matrix is achieved by swapping the element at position (i, j) with the element at position (j, i).","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transposes the given n x n square matrix in place. :param matrix: A 2D list representing the square matrix to be transposed. n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Context You are responsible for developing a task scheduling module that can manage a list of tasks with varying priorities and execution times. This module should efficiently schedule tasks based on their priority and provide a method to execute them in the correct order. # Objective Implement a priority-based task scheduler that orders tasks by priority and manages their execution. Your implementation should ensure that the highest priority tasks are executed first, and if two tasks have the same priority, they should be executed in the order they were added. # Function Definitions 1. `add_task(name: str, priority: int, time: int)`: - Adds a new task with a given `name`, `priority`, and `execution time`. 2. `remove_task(name: str)`: - Removes the task with the specified `name`. 3. `execute_tasks() -> list[str]`: - Executes all tasks in order of their priority and returns a list of task names in the order they were executed. # Input and Output Formats - **add_task(name: str, priority: int, time: int)** * `name`: String, name of the task. * `priority`: Integer, priority of the task (higher number indicates higher priority). * `time`: Integer, the execution time of the task in milliseconds. - **remove_task(name: str)** * `name`: String, name of the task to be removed. - **execute_tasks() -> list[str]** * Returns: List of strings, task names in the order they were executed. # Constraints - `1 <= priority <= 100` - `1 <= time <= 1000` - Task names are unique and consist of alphanumeric characters. # Example Usage ```python # Add tasks add_task(\\"task1\\", 5, 200) add_task(\\"task2\\", 10, 300) add_task(\\"task3\\", 5, 150) # Remove a task remove_task(\\"task1\\") # Execute tasks print(execute_tasks()) # Example output: [\\"task3\\", \\"task2\\"] ``` # Task Implement the functions `add_task`, `remove_task`, and `execute_tasks` following the detailed guidelines and constraints.","solution":"import heapq class TaskScheduler: def __init__(self): self.tasks_heap = [] self.task_dict = {} def add_task(self, name: str, priority: int, time: int): if name in self.task_dict: raise ValueError(\\"Task with this name already exists.\\") task = (-priority, len(self.task_dict), name, time) heapq.heappush(self.tasks_heap, task) self.task_dict[name] = task def remove_task(self, name: str): if name not in self.task_dict: raise ValueError(\\"Task with this name does not exist.\\") task = self.task_dict.pop(name) self.tasks_heap.remove(task) heapq.heapify(self.tasks_heap) def execute_tasks(self) -> list[str]: result = [] while self.tasks_heap: priority, idx, name, time = heapq.heappop(self.tasks_heap) result.append(name) del self.task_dict[name] return result"},{"question":"# Detect Cycles in a Directed Graph # Problem Statement You are given a directed graph represented by a set of vertices and edges. Your task is to detect if there is a cycle in the graph. Implement an algorithm to identify whether any cycle exists in the graph. For this task, implement the `CycleDetector` class with the following methods: - `__init__(self, num_vertices: int)`: Initializes the graph with the given number of vertices. - `add_edge(self, from_vertex: int, to_vertex: int)`: Adds a directed edge in the graph. Raises a `ValueError` for invalid vertex indices. - `has_cycle(self) -> bool`: Returns `True` if a cycle is detected in the graph, otherwise returns `False`. Input - A positive integer `num_vertices` representing the number of vertices in the graph. - Multiple pairs of integers `from_vertex` and `to_vertex` which represent the directed edges in the graph. Output - Returns `True` if there is a cycle in the graph, `False` otherwise. # Example ```python g = CycleDetector(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 4) g.add_edge(4, 1) assert g.has_cycle() == True h = CycleDetector(5) h.add_edge(0, 1) h.add_edge(1, 2) h.add_edge(2, 3) h.add_edge(3, 4) assert h.has_cycle() == False ``` You need to complete the class `CycleDetector` as per the specified requirements: ```python class CycleDetector: def __init__(self, num_vertices: int): # Initialize your data structures here pass def add_edge(self, from_vertex: int, to_vertex: int): # Implement edge addition logic with validation checks pass def has_cycle(self) -> bool: # Implement the cycle detection algorithm pass ``` # Constraints - `1 <= num_vertices <= 10^4` - `0 <= from_vertex, to_vertex < num_vertices` # Notes - Ensure your solution handles edge cases appropriately. - Optimize for both time and space, adhering to the constraints and expected complexity.","solution":"class CycleDetector: def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.graph = {i: [] for i in range(num_vertices)} def add_edge(self, from_vertex: int, to_vertex: int): if from_vertex < 0 or from_vertex >= self.num_vertices or to_vertex < 0 or to_vertex >= self.num_vertices: raise ValueError(\\"Invalid vertex index\\") self.graph[from_vertex].append(to_vertex) def has_cycle(self) -> bool: visited = [False] * self.num_vertices rec_stack = [False] * self.num_vertices def is_cyclic(v): visited[v] = True rec_stack[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: if is_cyclic(neighbor): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False for node in range(self.num_vertices): if not visited[node]: if is_cyclic(node): return True return False"},{"question":"# Array Product Except Self **Background**: The \\"Product of Array Except Self\\" is a common algorithmic problem in which you\'re required to find, for each element of an array, the product of all other elements in the array except for the element at the given index. The main challenge is to solve it without using division and in linear time. **Function Specification**: Implement the function `array_product_except_self(arr)` that calculates the product of all elements except itself for each element in the input list. **Input**: - `arr`: A list of integers representing the input array. **Output**: - A list of integers where each element at index `i` holds the product of all elements in the array except for the element at index `i`. **Constraints**: - The input array will have at least two elements. - The array may contain zero, and multiples are handled according to standard multiplication rules. - Division operation is not allowed. **Performance Requirements**: - You should solve the problem in O(n) time complexity. - The algorithm should use constant space complexity (not including the output array). **Example**: ```python def array_product_except_self(arr): # Your code here # Examples print(array_product_except_self([1, 2, 3, 4])) # [24, 12, 8, 6] print(array_product_except_self([5, 6, 2, 3])) # [36, 30, 90, 60] print(array_product_except_self([10, 3, 5, 6, 2])) # [180, 600, 360, 300, 900] print(array_product_except_self([4, 0, 2])) # [0, 8, 0] print(array_product_except_self([1, 0, 0])) # [0, 0, 0] ``` Implement the function without using the division operation and ensure it runs in linear time complexity. The goal is to practice handling edge cases and optimizing algorithms in a constrained environment.","solution":"def array_product_except_self(arr): n = len(arr) product_except_self = [1] * n # Calculate left products left = 1 for i in range(n): product_except_self[i] = left left *= arr[i] # Calculate right products and update answer array right = 1 for i in range(n-1, -1, -1): product_except_self[i] *= right right *= arr[i] return product_except_self"},{"question":"# Problem Statement You are working with a singly linked list implementation of a queue. The current queue supports operations like enqueue, dequeue, front, and is_empty. Your objective is to enhance this queue with new methods that will allow the following operations: 1. **Rotate Queue**: Write a method `rotate` within the `LinkedQueue` class that takes an integer `k` as input and rotates the queue to the left by `k` positions. 2. **Remove Duplicates**: Write a method `remove_duplicates` within the `LinkedQueue` class that removes all duplicate elements from the queue while preserving the order of the first occurrences. # Expected Input and Output 1. **Rotate Queue**: - **Input**: An integer `k` (number of positions to rotate) - **Output**: None (modifies the queue in place) - **Example**: ```python queue = LinkedQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) queue.enqueue(5) queue.rotate(2) print(queue) # Output: 3->4->5->1->2 ``` 2. **Remove Duplicates**: - **Input**: None (invoked on a queue instance) - **Output**: None (modifies the queue in place) - **Example**: ```python queue = LinkedQueue() queue.enqueue(1) queue.enqueue(3) queue.enqueue(1) queue.enqueue(5) queue.enqueue(3) queue.remove_duplicates() print(queue) # Output: 1->3->5 ``` # Constraints * You must not use any additional data structures (apart from the provided queue methods) to perform these operations. * The queue may contain any number of elements, including zero. Implement the `rotate` and `remove_duplicates` methods in `LinkedQueue` class based on the already provided queue code.","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedQueue: def __init__(self): self.head = None self.tail = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self.size += 1 def dequeue(self): if not self.head: raise IndexError(\\"dequeue from empty queue\\") value = self.head.value self.head = self.head.next if not self.head: self.tail = None self.size -= 1 return value def front(self): if not self.head: raise IndexError(\\"peek from empty queue\\") return self.head.value def is_empty(self): return self.size == 0 def __len__(self): return self.size def __str__(self): values = [] current = self.head while current: values.append(str(current.value)) current = current.next return \'->\'.join(values) def rotate(self, k): if self.size == 0: return k = k % self.size if k == 0: return current = self.head for _ in range(k - 1): current = current.next if not current.next: return new_head = current.next current.next = None self.tail.next = self.head self.head = new_head self.tail = current def remove_duplicates(self): if self.size == 0 or self.size == 1: return unique_values = set() current = self.head unique_values.add(current.value) while current.next: if current.next.value in unique_values: current.next = current.next.next self.size -= 1 else: unique_values.add(current.next.value) current = current.next self.tail = current self.tail.next = None"},{"question":"# Question Context: You are working on a financial analytics project that requires efficiently processing and analyzing time series data. One common operation you need to perform is detecting and handling anomalies in the data, such as significant changes between consecutive time points. # Coding Task: Implement a function `detect_anomalies` that takes as input a list of tuples where each tuple represents a timestamp and a corresponding value. Your task is to identify anomalies based on the percent change between consecutive values. # Input: * A list of tuples, where each tuple contains: * A string representing a timestamp in the format \'YYYY-MM-DD HH:MM:SS\' * A float representing the value at that timestamp * A float `threshold` that represents the percent change threshold to consider a value change as an anomaly. # Output: * A list of timestamps where the percent change between consecutive values exceeds the given threshold. # Constraints: * The timestamps are sorted in ascending order. * At least two data points are present in the input list. * The percent change is calculated as `abs((current_value - previous_value) / previous_value) * 100`. # Scenario: Consider the following example scenario to better understand the task requirements. ```python def detect_anomalies(data: List[Tuple[str, float]], threshold: float) -> List[str]: # Your implementation here pass # Example: data = [ (\'2023-01-01 00:00:00\', 100.0), (\'2023-01-01 01:00:00\', 102.0), (\'2023-01-01 02:00:00\', 105.5), (\'2023-01-01 03:00:00\', 104.0), (\'2023-01-01 04:00:00\', 97.0) ] threshold = 2.5 # The percent changes are: # 1-2: (102.0 - 100.0) / 100.0 * 100 = 2.0% # 2-3: (105.5 - 102.0) / 102.0 * 100 = 3.43% # 3-4: (104.0 - 105.5) / 105.5 * 100 = 1.42% # 4-5: (97.0 - 104.0) / 104.0 * 100 = 6.73% # Hence, the anomalies based on the given threshold (2.5%) are at timestamps: # \'2023-01-01 02:00:00\' and \'2023-01-01 04:00:00\' print(detect_anomalies(data, threshold)) # Output: [\'2023-01-01 02:00:00\', \'2023-01-01 04:00:00\'] ``` # Performance Requirements: * Your solution should be efficient in terms of both time and space complexity. * Aim to achieve linear time complexity O(n), where n is the number of data points.","solution":"def detect_anomalies(data, threshold): Detect anomalies based on percent change threshold between consecutive values. Args: data (List[Tuple[str, float]]): List of tuples containing timestamp and value. threshold (float): Percent change threshold to consider as an anomaly. Returns: List[str]: List of timestamps where the percent change exceeded the threshold. anomalies = [] for i in range(1, len(data)): previous_value = data[i-1][1] current_value = data[i][1] percent_change = abs((current_value - previous_value) / previous_value) * 100 if percent_change > threshold: anomalies.append(data[i][0]) return anomalies"},{"question":"# Problem Description You are given a basic implementation of a cache system that follows the Least Recently Used (LRU) caching strategy. An LRU Cache evicts the least recently used items first when it reaches its capacity, ensuring efficient use of space. Your task is to extend the given cache implementation to add the following features: 1. Implement a method to return the current cache usage as a percentage of its total capacity. 2. Add functionality to clear the cache entirely and reset to its initial state. 3. Introduce a mechanism to prioritize certain entries so that they are less likely to be evicted compared to others. # Function Specifications 1. **get_usage() -> float**: Returns the current cache usage as a percentage of its total capacity. - **Input**: None - **Output**: A float representing the current usage percent of the cache (from 0 to 100). - **Behavior**: Compute the current number of items in the cache divided by total capacity, then multiply by 100. 2. **clear()**: Clears and resets the cache. - **Input**: None - **Output**: None - **Behavior**: All entries in the cache should be removed, and it should be reset to its initial empty state. 3. **add_prioritized_entry(key: str, value: Any)**: Adds an entry to the cache which will have a lower likelihood of being evicted. - **Input**: A string `key` and a value `value` which can be any type. - **Output**: None - **Behavior**: Add the key-value pair to the cache with priority treatment. Prioritized entries should only be evicted when no regular entries remain. # Constraints - The cache will have a positive integer capacity. - Cache entries will have string keys and any type of value. - You should assume that prioritized entries can be tracked with a boolean flag or a similar mechanism. # Example ```python cache = LRUCache(capacity=4) # Adding elements cache.put(\\"a\\", 1) cache.put(\\"b\\", 2) cache.put(\\"c\\", 3) print(cache.get_usage()) # 75.0 # Add prioritized entries cache.add_prioritized_entry(\\"d\\", 4) cache.add_prioritized_entry(\\"e\\", 5) print(cache.get_usage()) # 100.0 # Cache eviction follows LRU policy cache.put(\\"f\\", 6) print(cache.cache) # Normal entries will evict first, \'a\' should be gone. # Clearing cache cache.clear() print(cache.cache) # {} # Add new elements after clearing cache.put(\\"g\\", 7) cache.put(\\"h\\", 8) print(cache.get_usage()) # 50.0 ``` # Requirements - Ensure your implementation uses an efficient data structure to manage the cache, supporting constant time complexity for get and put operations. - Consider edge cases, such as prioritization rules when the cache is full and mixing of regular and prioritized entries.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity self.prioritized = set() def get(self, key: str): if key not in self.cache: return -1 else: value = self.cache.pop(key) self.cache[key] = value return value def put(self, key: str, value: any): if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.evict() self.cache[key] = value def evict(self): regular_keys = [k for k in self.cache if k not in self.prioritized] if regular_keys: key_to_remove = regular_keys[0] else: key_to_remove = next(iter(self.cache)) self.cache.pop(key_to_remove) self.prioritized.discard(key_to_remove) def get_usage(self) -> float: return (len(self.cache) / self.capacity) * 100 def clear(self): self.cache.clear() self.prioritized.clear() def add_prioritized_entry(self, key: str, value: any): self.prioritized.add(key) self.put(key, value)"},{"question":"# Scenario You are to ensure the financial integrity of transactions recorded for an e-commerce site. Each transaction log has attributes such as transaction identifier, user identifier, item price, and transaction date. The goal is to induce a hierarchy within these transactions based on their frequency and monetary value, and to identify the highest contributor in terms of total transaction value. # Task Implement the function `highest_contributor` to process the dataset in the following steps: 1. Group the transactions by `user_id` and sum up the `item_price` for each user. 2. Identify the user with the highest cumulative transaction value. 3. Return the user identifier and the total value of their transactions. # Function Signature ```python def highest_contributor(transactions: pd.DataFrame) -> Tuple[int, float]: ``` # Input - `transactions`: A pandas DataFrame with four columns: `transaction_id` (unique identifier for the transaction), `user_id` (unique identifier for the user), `item_price` (price of the item in the transaction), and `transaction_date` (date of the transaction in YYYY-MM-DD format). # Output - Returns a tuple of (user_id, total_value), where `user_id` is the identifier of the user with the highest cumulative transaction value and `total_value` is the cumulative transaction value of that user. # Constraints - The dataset includes at least 100 transactions. # Performance - The solution should efficiently handle data with up to 10,000 transactions. # Example ```python import pandas as pd transactions = pd.DataFrame({ \'transaction_id\': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], \'user_id\': [101, 102, 101, 103, 101, 102, 103, 104, 105, 101], \'item_price\': [100.0, 200.0, 150.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 250.0], \'transaction_date\': [\'2023-01-01\', \'2023-01-02\', \'2023-01-03\', \'2023-01-04\', \'2023-01-05\', \'2023-01-06\', \'2023-01-07\', \'2023-01-08\', \'2023-01-09\', \'2023-01-10\'] }) print(highest_contributor(transactions)) # Expected output: (101, 900.0) ``` Use the provided method signature and implement the logic within the `highest_contributor` function to achieve the described functionality.","solution":"import pandas as pd def highest_contributor(transactions: pd.DataFrame) -> tuple: Returns the user identifier with the highest cumulative transaction value and the total value of their transactions. Parameters: transactions (pd.DataFrame): DataFrame containing transaction data with columns \'transaction_id\', \'user_id\', \'item_price\', \'transaction_date\'. Returns: tuple: (user_id, total_value) where `user_id` is the user with the highest cumulative transaction value and `total_value` is the sum of their transactions. user_totals = transactions.groupby(\'user_id\')[\'item_price\'].sum() top_user_id = user_totals.idxmax() top_user_value = user_totals.max() return (top_user_id, top_user_value)"},{"question":"# Permutations of List Subset Write a function `generate_subset_permutations(lst, k)` that takes a list `lst` of distinct integers and an integer `k`, returning all possible permutations of length `k` that can be made from the elements of `lst`. Function Signature ```python def generate_subset_permutations(lst: List[int], k: int) -> List[List[int]]: ``` # Input - `lst (List[int])`: A list of distinct integers (1 ≤ len(lst) ≤ 10). - `k (int)`: An integer representing the length of permutations to generate (1 ≤ k ≤ len(lst)). # Output - `List[List[int]]`: A list of lists, where each inner list is a permutation of length `k` formed from the elements of `lst`. # Constraints - The function should produce all permutations without duplicates. - The permutations in the output list can be in any order. # Example ```python print(generate_subset_permutations([1, 2, 3], 2)) # Output: [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] print(generate_subset_permutations([4, 5, 6, 7], 3)) # Possible Output: [[4, 5, 6], [4, 5, 7], [4, 6, 5], [4, 6, 7], # [4, 7, 5], [4, 7, 6], [5, 4, 6], [5, 4, 7], # [5, 6, 4], [5, 6, 7], [5, 7, 4], [5, 7, 6], # [6, 4, 5], [6, 4, 7], [6, 5, 4], [6, 5, 7], # [6, 7, 4], [6, 7, 5], [7, 4, 5], [7, 4, 6], # [7, 5, 4], [7, 5, 6], [7, 6, 4], [7, 6, 5]] ``` Provide a complete implementation of the function that ensures all possible permutations are generated correctly and efficiently.","solution":"from itertools import permutations from typing import List def generate_subset_permutations(lst: List[int], k: int) -> List[List[int]]: Generates all possible permutations of length k from elements of lst. Parameters: lst (List[int]): A list of distinct integers. k (int): The length of permutations to generate. Returns: List[List[int]]: A list of permutations of length k. return [list(p) for p in permutations(lst, k)]"},{"question":"# Dynamic Playlist Management with Maximum Duration You are tasked with implementing a dynamic playlist manager that allows adding songs and generating a playlist that does not exceed a specified maximum duration. Each song is characterized by a title and a duration (in seconds). Specifically, you need to: 1. Implement the `PlaylistManager` class that supports adding new songs and generating a playlist. 2. Ensure the `add_song` method adds a new song to the playlist. 3. Implement the `generate_playlist` method to create a playlist such that the total duration does not exceed the given maximum duration. Your class should: - Initialize with an empty list of songs. - Support the `add_song` method to append a `(title, duration)` tuple to the list of songs. - Use dynamic programming or a greedy approach to generate an optimal playlist within the duration limit. # Input - A list of function calls to `add_song` with `(title, duration)` tuples. - A call to `generate_playlist` with a maximum duration. - Constraints: - The duration of each song is an integer (in seconds). - There can be at most 10^5 songs. - The maximum duration is an integer (in seconds). # Output - A list of song titles selected for the playlist, such that the total duration does not exceed the maximum duration. # Example ```python manager = PlaylistManager() manager.add_song(\\"Song A\\", 300) manager.add_song(\\"Song B\\", 200) manager.add_song(\\"Song C\\", 400) playlist = manager.generate_playlist(500) print(playlist) # Output: [\\"Song A\\", \\"Song B\\"] ``` Ensure your solution optimally selects the songs within the given constraints. # Signature ```python class PlaylistManager: def __init__(self): pass def add_song(self, title: str, duration: int) -> None: pass def generate_playlist(self, max_duration: int) -> list[str]: pass ```","solution":"class PlaylistManager: def __init__(self): self.songs = [] def add_song(self, title, duration): self.songs.append((title, duration)) def generate_playlist(self, max_duration): # Sort songs by duration (greedy approach to maximize the number of songs) self.songs.sort(key=lambda x: x[1]) total_duration = 0 playlist = [] for title, duration in self.songs: if total_duration + duration <= max_duration: total_duration += duration playlist.append(title) else: break return playlist"},{"question":"# Coding Assessment Question Context You are developing a calculator utility that can evaluate simple mathematical expressions provided as strings. Your goal is to support basic arithmetic operations and parentheses. Task Create a function `evaluate_expression(expression: str) -> float` which: 1. Parses the input string representing the mathematical expression. 2. Evaluates the expression following the correct order of operations (PEMDAS/BODMAS). 3. Returns the result of the computation as a floating-point number. Requirements 1. Implement the function `evaluate_expression(expression: str) -> float`. 2. The function should correctly interpret and compute the result of expressions involving addition, subtraction, multiplication, division, and parentheses. 3. Handle any possible whitespace in the input expression gracefully. 4. Ensure the function raises appropriate errors for invalid expressions. Input and Output * **Input**: A string `expression` representing the mathematical expression. * **Output**: A float representing the result of the computed expression. Constraints * The input expression will be a valid string containing only digits, operators (+, -, *, /), parentheses, and whitespace. * Division by zero should be appropriately handled by raising an error. * Assume the input expression is not longer than 100 characters. Example: ```python >>> result = evaluate_expression(\\"3 + 5 * (2 - 8)\\") >>> print(result) -13.0 >>> result = evaluate_expression(\\"10 / (2 + 3)\\") >>> print(result) 2.0 ```","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string and returns the result as a float. :param expression: A string representing a mathematical expression. :return: The result of the evaluated expression as a float. try: # Remove any possible whitespaces in the expression expression = expression.replace(\\" \\", \\"\\") # Evaluate the expression using Python\'s eval function result = eval(expression) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") except SyntaxError: raise ValueError(\\"Invalid expression syntax.\\") except Exception as e: raise ValueError(f\\"Error evaluating expression: {e}\\")"},{"question":"# Context You are developing an online file storage system that supports file uploading and retrieval. The system needs to handle files of various types and sizes and ensure that file metadata is correctly recorded and stored in a database. # Task Write a Python function that uploads a file to the server and records its metadata in a SQLite database. Your function should handle potential errors gracefully and provide meaningful error messages when issues arise during the upload or database operations. # Function Signature ```python def upload_file(file_path: str, db_path: str) -> dict: ``` # Requirements - Your function should return a dictionary with two keys: `\\"success\\"` and `\\"error\\"`. - `\\"success\\"`: A boolean indicating if the file was uploaded and recorded successfully. - `\\"error\\"`: Contains an error message if there was any issue during the upload or database operations. - If the file does not exist or cannot be read, it should return the error message `\\"File not found or unreadable.\\"`. - If there is any issue with database connection or SQL execution, it should return the error message `\\"Database error.\\"`. - Ensure the correct recording of file metadata such as `filename`, `size`, and `upload_time`. # Constraints - Use the built-in **sqlite3** library for database operations. - Use the **os** library to get file metadata. - Assume the database has a table named `files` with columns `filename`, `size`, and `upload_time`. # Example Table Schema ```sql CREATE TABLE files ( id INTEGER PRIMARY KEY, filename TEXT NOT NULL, size INTEGER NOT NULL, upload_time TEXT NOT NULL ); ``` # Example Usage ```python result = upload_file(\\"path/to/file.txt\\", \\"path/to/database.db\\") if result[\'success\']: print(\\"File uploaded successfully!\\") else: print(\\"Error:\\", result[\'error\']) ``` # Notes - Consider using exception handling to manage file and database operations. - Use the `os.path` module to check if the file exists and to retrieve file size. - Use the `datetime` module to get the current time for the `upload_time` field. - Ensure database connections are properly closed after operations. - The `db_path` is the path to the SQLite database file.","solution":"import os import sqlite3 from datetime import datetime def upload_file(file_path: str, db_path: str) -> dict: response = {\\"success\\": False, \\"error\\": \\"\\"} # Check if the file exists and is readable if not os.path.isfile(file_path) or not os.access(file_path, os.R_OK): response[\\"error\\"] = \\"File not found or unreadable.\\" return response try: # Get file metadata file_size = os.path.getsize(file_path) file_name = os.path.basename(file_path) upload_time = datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\') # Connect to the database conn = sqlite3.connect(db_path) cursor = conn.cursor() # Insert file metadata into the database cursor.execute( \\"INSERT INTO files (filename, size, upload_time) VALUES (?, ?, ?)\\", (file_name, file_size, upload_time) ) conn.commit() # Close the database connection cursor.close() conn.close() response[\\"success\\"] = True except sqlite3.Error: response[\\"error\\"] = \\"Database error.\\" return response"},{"question":"# Finding the Missing Number Context In a sequential stream of numbers from 1 to n, with exactly one number missing, it is essential to determine the missing number efficiently. Problem Statement You are given an array representing a sequence of integers from 1 to n, with exactly one missing number. Your task is to find and return the missing number. Function Signature ```python def find_missing_number(arr: list) -> int: pass ``` Input/Output * **Input**: A list of integers, `arr`, containing numbers from 1 to n with one number missing. * **Output**: Returns an integer, the missing number. Constraints * The length of the array `arr` is `n-1`, where `n` is the last number in the complete sequence. * Each number in the array is unique and ranges from 1 to n, inclusive. * The input list does not have any repetition of numbers. Examples ```python >>> find_missing_number([1, 2, 4, 6, 3, 7, 8]) 5 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([2]) 1 >>> find_missing_number([5, 3, 1, 6, 4]) 2 ``` Explanation In each example, the array is a shuffled sequence from 1 to n with one number missing: * In the first example, the entire range from 1 to 8 is considered, and the number 5 is missing. * In the second example, the sequence from 1 to 5 is considered, and the number 4 is missing. * In the third example, from sequence 1 to 2, only the number 1 can be missing. * In the fourth example, from a shuffled sequence 1 to 6, with number 2 missing. Hints * Utilize the sum formula for the first n natural numbers for an efficient solution. * Calculate the expected sum of the complete range and subtract the actual sum of elements in the array to find the missing number.","solution":"def find_missing_number(arr): Finds the missing number in the array which contains numbers from 1 to n with one number missing. Parameters: arr (list): The list of integers Returns: int: The missing number in the list n = len(arr) + 1 # since one number is missing total_sum = n * (n + 1) // 2 # sum of first n natural numbers actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"# Question: # Description: You are provided with a list of integers and a target sum. Your goal is to determine whether any two integers in the list add up to the target sum. If so, return the pair as a tuple. If multiple pairs exist, return any one of them. If no such pair exists, return `None`. # Task: Implement a function `find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None` that: 1. Takes a list of integers and an integer `target` as input. 2. Returns a tuple containing any two integers from the list that add up to the target sum. 3. If no such pair exists, returns `None`. # Constraints: - The list `nums` contains only integers. - You may not use the same element twice. - The function should handle an empty list by returning `None`. - The function must be efficient with a time complexity of O(n). # Inputs: - `nums` (List of integers): The list of numbers. - `target` (Integer): The sum that any pair of integers in the list should match. # Output: - Returns a tuple containing two integers that add up to the target sum, or `None` if no such pair exists. # Example Usage: ```python >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([3, 2, 4], 6) (2, 4) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([], 5) None >>> find_pair_with_sum([0, -1, 2, -3, 1], -2) (-3, 1) ``` # Note: - Ensure your implementation is efficient and correctly identifies pairs of integers that add up to the target sum. - Avoid duplicate pairs in the output and prioritize a solution with a time complexity of O(n). ```python def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None: seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None # Example usage if __name__ == \\"__main__\\": print(find_pair_with_sum([2, 7, 11, 15], 9)) # Output: (2, 7) print(find_pair_with_sum([3, 2, 4], 6)) # Output: (2, 4) print(find_pair_with_sum([1, 2, 3, 4, 5], 10)) # Output: None print(find_pair_with_sum([], 5)) # Output: None print(find_pair_with_sum([0, -1, 2, -3, 1], -2)) # Output: (-3, 1) ```","solution":"def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None: Finds any two integers in a list that add up to the target sum. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple of int, int or None: A tuple with the pair of integers that add up to the target or None if no such pair exists. seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"# Problem Statement You are tasked with implementing a Reed-Solomon encoding scheme and its decoding counterpart. Reed-Solomon codes are block error-correcting codes that enable the correction of errors in data transmission or storage. # Function Signatures - Implement the function `rs_encode(data: str, num_ecc_symbols: int) -> str`. This function will: - Take a string `data` and the number of error-correcting code (ECC) symbols `num_ecc_symbols` as input. - Return a string that combines the original data with the ECC symbols. ```python def rs_encode(data: str, num_ecc_symbols: int) -> str: pass ``` - Implement the function `rs_decode(encoded_data: str, num_ecc_symbols: int) -> str`. This function will: - Take the encoded data string `encoded_data` and the number of ECC symbols `num_ecc_symbols`. - Return the original data string by correcting errors using the ECC symbols. ```python def rs_decode(encoded_data: str, num_ecc_symbols: int) -> str: pass ``` # Input and Output Input 1. `data` (str): The original string of data to encode. Constraints: `1 ≤ len(data) ≤ 500`. 2. `num_ecc_symbols` (int): The number of ECC symbols to add. Constraints: `1 ≤ num_ecc_symbols ≤ 20`. 3. `encoded_data` (str): The string containing both the data and ECC symbols. Constraints: `1 ≤ len(encoded_data) ≤ 520`. Output 1. `rs_encode(data, num_ecc_symbols)` returns a string combining the original data and ECC symbols. 2. `rs_decode(encoded_data, num_ecc_symbols)` returns the original data by correcting errors using the ECC symbols. # Example 1. `rs_encode(\\"HELLO\\", 5)` - Returns: `\\"HELLOABCDE\\"` (an example output where \\"ABCDE\\" represent ECC symbols; actual ECC symbols will vary) 2. `rs_decode(\\"HELLOABCDE\\", 5)` - Returns: `\\"HELLO\\"` (returns the original data before encoding) # Constraints - You must check for invalid types and raise appropriate exceptions (`TypeError`, `ValueError`) as needed. - Ensure your solution is efficient and handles edge cases, such as data corruption in `encoded_data`. # Notes - Practice generating and appending ECC symbols to the original data. - Pay attention to error correction and ensure that your decoding process correctly retrieves the original data.","solution":"import zlib def rs_encode(data: str, num_ecc_symbols: int) -> str: Encodes the data with given number of ECC symbols. if not isinstance(data, str) or not isinstance(num_ecc_symbols, int): raise TypeError(\\"Invalid input types\\") if len(data) < 1 or len(data) > 500 or num_ecc_symbols < 1 or num_ecc_symbols > 20: raise ValueError(\\"Input values out of allowed range\\") # Convert the string to bytes data_bytes = data.encode() # Create error-correcting codes using CRC32 ecc = zlib.crc32(data_bytes) # Convert ECC to string representation ecc_str = f\\"{ecc:0{num_ecc_symbols}X}\\"[:num_ecc_symbols] # Truncate or pad return data + ecc_str def rs_decode(encoded_data: str, num_ecc_symbols: int) -> str: Decodes the encoded data by correcting errors using the ECC symbols. if not isinstance(encoded_data, str) or not isinstance(num_ecc_symbols, int): raise TypeError(\\"Invalid input types\\") if len(encoded_data) < 1 or len(encoded_data) > 520: raise ValueError(\\"Input values out of allowed range\\") if num_ecc_symbols < 1 or num_ecc_symbols > 20: raise ValueError(\\"ECC symbols out of allowed range\\") # Split data and ECC data, ecc_received = encoded_data[:-num_ecc_symbols], encoded_data[-num_ecc_symbols:] # Convert the string to bytes data_bytes = data.encode() # Generate expected ECC ecc = zlib.crc32(data_bytes) ecc_str = f\\"{ecc:0{num_ecc_symbols}X}\\"[:num_ecc_symbols] # Truncate or pad # Validate ECC (Simple comparison for demonstration) if ecc_str == ecc_received: return data else: raise ValueError(\\"Data integrity check failed, unable to decode correctly\\")"},{"question":"# Matrix Rotation by k Steps You are working on a project involving image processing. One of the tasks is to rotate a given N x N matrix by `k` steps clockwise. Each step involves rotating the matrix by 90 degrees. Function Signature ```python def rotate_matrix(matrix: List[List[int]], k: int) -> List[List[int]]: pass ``` Input * An N x N matrix where ( 1 leq N leq 300 ). * An integer ( k ) ((1 leq k leq 10^9)) representing the number of 90-degree clockwise rotations. Output * Returns an N x N matrix rotated `k` steps clockwise. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_matrix(matrix, 1) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix, 4) == [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_matrix(matrix, 5) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Constraints 1. Implement the rotation efficiently considering the constraints. 2. Optimize the number of rotations since rotating by 4 steps results in the original matrix (i.e., `k % 4` to minimize the rotations). 3. Ensure the solution can handle the upper constraints effectively. # Notes 1. Each 90-degree clockwise rotation effectively involves transposing the matrix and then reversing each row. 2. For very large values of `k`, optimize by reducing the problem into a manageable size using modulo operation. 3. Consider edge cases where ( k ) is very high or exactly a multiple of 4. 4. Performance analysis will compare run-time for large matrices.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]], k: int) -> List[List[int]]: def rotate_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the matrix by 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix k = k % 4 # We only need up to 3 rotations since 4 rotations is a full cycle for _ in range(k): matrix = rotate_90_clockwise(matrix) return matrix"},{"question":"**Context**: Consider the problem of implementing a spell-checker. A vital part of the spell-checker is finding the most relevant correction for a given word that may have been misspelled. One approach for this is to use the Damerau-Levenshtein distance, which measures the number of operations needed to transform one string into another, allowing for insertions, deletions, substitutions, and transpositions of adjacent characters. **Task**: Implement a `SpellChecker` class that uses the Damerau-Levenshtein distance to suggest corrections for misspelled words. The class should be capable of loading a dictionary of valid words and suggesting the closest word from the dictionary for any given input word. # Function Signature ```python class SpellChecker: def __init__(self): pass def load_dictionary(self, words: [str]) -> None: pass def suggest_correction(self, word: str) -> str: pass ``` # Requirements 1. **Constructor**: Initialize the spell checker. 2. **Load Dictionary Function**: Load a list of valid words into the spell checker. 3. **Suggest Correction Function**: Given a potentially misspelled word, return the closest word from the dictionary based on Damerau-Levenshtein distance. If two words have the same distance, return the one that appears first in the dictionary. # Constraints - Input words contain only lowercase English alphabets. - The maximum length of any word is 100 characters. - The dictionary can hold up to 10,000 words. # Example ```python # Create a spell checker checker = SpellChecker() # Load dictionary dictionary = [\'apple\', \'banana\', \'peach\', \'orange\', \'grape\', \'blueberry\'] checker.load_dictionary(dictionary) # Suggest corrections assert checker.suggest_correction(\'appl\') == \'apple\' assert checker.suggest_correction(\'oragne\') == \'orange\' assert checker.suggest_correction(\'grpe\') == \'grape\' assert checker.suggest_correction(\'bluebery\') == \'blueberry\' assert checker.suggest_correction(\'bannana\') == \'banana\' ``` **Note**: Ensure your implementation efficiently handles the calculation of Damerau-Levenshtein distance and returns the closest word in case of multiple words having the same minimum distance.","solution":"class SpellChecker: def __init__(self): self.dictionary = [] def load_dictionary(self, words): self.dictionary = words def damerau_levenshtein_distance(self, s1, s2): d = {} lenstr1 = len(s1) lenstr2 = len(s2) for i in range(-1, lenstr1 + 1): d[(i, -1)] = i + 1 for j in range(-1, lenstr2 + 1): d[(-1, j)] = j + 1 for i in range(lenstr1): for j in range(lenstr2): if s1[i] == s2[j]: cost = 0 else: cost = 1 d[(i, j)] = min( d[(i - 1, j)] + 1, # deletion d[(i, j - 1)] + 1, # insertion d[(i - 1, j - 1)] + cost, # substitution ) if i > 0 and j > 0 and s1[i] == s2[j - 1] and s1[i - 1] == s2[j]: d[(i, j)] = min(d[(i, j)], d[i - 2, j - 2] + cost) # transposition return d[lenstr1 - 1, lenstr2 - 1] def suggest_correction(self, word): if not self.dictionary: return word closest_word = None min_distance = float(\'inf\') for dict_word in self.dictionary: dist = self.damerau_levenshtein_distance(word, dict_word) if dist < min_distance: min_distance = dist closest_word = dict_word elif dist == min_distance and closest_word: # Ensure the first occurrence in the dictionary is kept continue return closest_word"},{"question":"**Data Cleaning and Processing Task** # Problem Statement You are required to implement a function that cleans and processes a dataset of movies. The dataset is provided in the form of a CSV file with columns: `title`, `description`, `genre`, `rating`, and `release_year`. # Requirements 1. **Function Definition**: Implement the function `clean_and_process_movies(file_path: str) -> pd.DataFrame`. 2. **Inputs**: - `file_path` (str): The file path to the CSV file containing the dataset. 3. **Output**: - The function should return a Pandas DataFrame with the cleaned and processed data. 4. **Operational Steps**: * Load the provided CSV file into a Pandas DataFrame. * Remove any rows where the `title`, `genre`, or `rating` is missing or null. * Fill any missing or null values in the `description` column with the string \\"No description available.\\" * Normalize the text in the `title` and `genre` columns to be all lowercase. * Remove any duplicate rows based on the `title` column. * Create a new column called `rating_category` based on the `rating`: * If `rating` is 8.0 or above, set `rating_category` to \\"Excellent\\". * If `rating` is between 5.0 and 7.9, set `rating_category` to \\"Good\\". * If `rating` is below 5.0, set `rating_category` to \\"Poor\\". # Example ```python import pandas as pd # Example CSV file content: # title,description,genre,rating,release_year # \\"Inception\\",\\"A mind-bending thriller.\\",\\"Sci-Fi\\",8.8,2010 # \\"Moonlight\\",\\"A look at the life of an African-American.\\",\\"Drama\\",7.4,2016 df = clean_and_process_movies(\\"movies.csv\\") print(df) # Expected Output DataFrame: # title description genre rating release_year rating_category # 0 inception a mind-bending thriller. sci-fi 8.8 2010 Excellent # 1 moonlight a look at the life of an (...) drama 7.4 2016 Good ``` # Notes * Ensure your solution handles potential edge cases such as CSV files with different encodings. * Use appropriate error handling to manage I/O operations and data processing issues. * You may use the popular Python libraries `pandas` to aid in the dataset manipulation.","solution":"import pandas as pd def clean_and_process_movies(file_path: str) -> pd.DataFrame: Cleans and processes a dataset of movies. Args: file_path (str): The file path to the CSV file containing the dataset. Returns: pd.DataFrame: The cleaned and processed DataFrame. # Load the provided CSV file into a Pandas DataFrame. df = pd.read_csv(file_path) # Remove any rows where the `title`, `genre`, or `rating` is missing or null. df = df.dropna(subset=[\'title\', \'genre\', \'rating\']) # Fill any missing or null values in the `description` column with a default string. df[\'description\'] = df[\'description\'].fillna(\\"No description available.\\") # Normalize the text in the `title` and `genre` columns to be all lowercase. df[\'title\'] = df[\'title\'].str.lower() df[\'genre\'] = df[\'genre\'].str.lower() # Remove any duplicate rows based on the `title` column. df = df.drop_duplicates(subset=[\'title\']) # Create a new column called `rating_category` based on the `rating`. def categorize_rating(rating): if rating >= 8.0: return \\"Excellent\\" elif 5.0 <= rating < 8.0: return \\"Good\\" else: return \\"Poor\\" df[\'rating_category\'] = df[\'rating\'].apply(categorize_rating) return df"},{"question":"# Problem Statement You are tasked with building a function to calculate the nth term in a Fibonacci-like sequence known as the Tribonacci sequence. # Functional Requirements Implement a function `tribonacci(n: int) -> int` that: - Computes the nth term in the Tribonacci sequence. - Takes the following parameter: * `n` (integer): The index of the term in the sequence. Must be a non-negative integer. The Tribonacci sequence is similar to the Fibonacci sequence, but each term is the sum of the three preceding terms. The sequence starts with three predefined terms: - `T0 = 0` - `T1 = 1` - `T2 = 1` So, the sequence goes: `0, 1, 1, 2, 4, 7, 13, ...` and so on. # Constraints - The `n` parameter must be a non-negative integer. # Error Handling - If `n` is negative, raise a `ValueError` with the message \\"Index must be non-negative\\". # Example ```python def tribonacci(n: int) -> int: if n < 0: raise ValueError(\\"Index must be non-negative\\") if n == 0: return 0 elif n == 1 or n == 2: return 1 a, b, c = 0, 1, 1 for _ in range(n - 2): a, b, c = b, c, a + b + c return c # Test cases print(tribonacci(0)) # 0 print(tribonacci(1)) # 1 print(tribonacci(2)) # 1 print(tribonacci(3)) # 2 print(tribonacci(4)) # 4 print(tribonacci(5)) # 7 print(tribonacci(6)) # 13 print(tribonacci(10)) # 149 print(tribonacci(25)) # 1389537 # print(tribonacci(-5)) # Raises ValueError: Index must be non-negative ``` # Your Task Implement the `tribonacci` function according to the specifications above. Ensure proper error handling and validate the inputs before performing calculations. **Note**: Use the provided test cases to verify your implementation.","solution":"def tribonacci(n: int) -> int: if n < 0: raise ValueError(\\"Index must be non-negative\\") if n == 0: return 0 elif n == 1 or n == 2: return 1 a, b, c = 0, 1, 1 for _ in range(n - 2): a, b, c = b, c, a + b + c return c"},{"question":"# Coding Assessment Question: Employee Attendance Tracker As a software developer for a large organization, you have been asked to create a Python script to help manage employee attendance. The goal is to process a log file containing attendance records and provide analytical reports based on this data. **Context:** The organization maintains a log file where each line represents an employee\'s log-in or log-out event, with a timestamp. The log system records the employee ID, action (log-in or log-out), and the timestamp in a standardized format. Your task is to read this log file, process the data to calculate total hours worked by each employee, and generate daily attendance reports. # Task: Implement a function `process_attendance_log(file_path: str) -> dict[str, dict[str, float]]` that reads a log file, calculates total hours worked by each employee for each day, and returns this information in a structured dictionary. Additionally, implement a function for retrieving the attendance report for a specific employee on a specific day. # Specifications: 1. **Function 1: Reading and Processing the Attendance Log** ```python def process_attendance_log(file_path: str) -> dict[str, dict[str, float]]: ``` - **Input**: `file_path` (str) - Path to the text file containing attendance logs, one event per line. - **Output**: A dictionary where keys are employee IDs, and values are dictionaries mapping dates to total hours worked. - **Constraints**: - Each log entry is a string in the format: `employee_id action timestamp`, e.g., `\\"123 log-in 2023-10-01 08:00:00\\"`. - Ensure timestamps are correctly parsed and time differences are calculated in hours. - Handle edge cases such as missing log-out entries or multiple log-ins without an intervening log-out by ignoring incomplete or erroneous data. 2. **Function 2: Fetching Attendance Report for a Specific Employee on a Specific Day** ```python def get_attendance_report(employee_id: str, date: str, attendance_data: dict[str, dict[str, float]]) -> float: ``` - **Input**: - `employee_id` (str) - The ID of the employee. - `date` (str) - The specific date in \'YYYY-MM-DD\' format. - `attendance_data` from `process_attendance_log`. - **Output**: Total hours worked by the specified employee on the specified date. # Sample Input: ``` # Contents of attendance_log.txt 123 log-in 2023-10-01 08:00:00 123 log-out 2023-10-01 17:00:00 124 log-in 2023-10-01 09:00:00 124 log-out 2023-10-01 18:00:00 123 log-in 2023-10-02 08:30:00 123 log-out 2023-10-02 17:30:00 124 log-in 2023-10-02 09:00:00 124 log-out 2023-10-02 18:00:00 ``` # Sample Output: ```python { \'123\': { \'2023-10-01\': 9.0, \'2023-10-02\': 9.0 }, \'124\': { \'2023-10-01\': 9.0, \'2023-10-02\': 9.0 } } ``` # Example Usage: ```python attendance_data = process_attendance_log(\\"path/to/attendance_log.txt\\") print(get_attendance_report(\\"123\\", \\"2023-10-01\\", attendance_data)) # Output: 9.0 ``` # Performance Requirements: - The solution should efficiently handle large log files containing millions of records. - Handle edge cases gracefully, such as duplicated log-ins without corresponding log-outs. - Ensure time zones are effectively managed if the logs span multiple regions. # Testing: - Write unit tests to validate your implementation against edge cases, performance benchmarks, and typical usage scenarios. Good luck!","solution":"from datetime import datetime, timedelta def process_attendance_log(file_path: str) -> dict[str, dict[str, float]]: attendance_data = {} with open(file_path, \'r\') as file: logs = file.readlines() temp_log = {} for log in logs: employee_id, action, timestamp_str = log.strip().split(maxsplit=2) timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") date_str = timestamp.strftime(\\"%Y-%m-%d\\") if action == \\"log-in\\": if employee_id not in temp_log: temp_log[employee_id] = {} temp_log[employee_id][date_str] = timestamp elif action == \\"log-out\\": if employee_id in temp_log and date_str in temp_log[employee_id]: start_time = temp_log[employee_id].pop(date_str) work_duration = (timestamp - start_time).total_seconds() / 3600.0 if employee_id not in attendance_data: attendance_data[employee_id] = {} if date_str not in attendance_data[employee_id]: attendance_data[employee_id][date_str] = 0.0 attendance_data[employee_id][date_str] += work_duration return attendance_data def get_attendance_report(employee_id: str, date: str, attendance_data: dict[str, dict[str, float]]) -> float: if employee_id in attendance_data and date in attendance_data[employee_id]: return attendance_data[employee_id][date] return 0.0"},{"question":"# Scenario: You have been tasked with designing an algorithm for a banking system that processes a series of transactions on customer accounts. Each transaction involves depositing or withdrawing money from an account, and your algorithm should ensure that accounts do not go overdrawn. # Task: Write a function that processes a list of transactions and updates the account balance accordingly. Each transaction will be represented as a tuple indicating the account ID, the type of transaction (deposit or withdrawal), and the amount. The function should return a dictionary with the account balances after all transactions have been processed. # Function Signature: ```python def update_account_balances( transactions: List[Tuple[int, str, float]] ) -> Dict[int, float]: pass ``` # Input: - `transactions`: A list of tuples, where each tuple is in the form of (account_id, transaction_type, amount). - `account_id`: An integer representing the account number. - `transaction_type`: A string that can be \'deposit\' or \'withdrawal\'. - `amount`: A floating-point number representing the transaction amount. # Output: - Returns a dictionary where the keys are account IDs and the values are the final balances of these accounts after applying all transactions. # Constraints: - You may assume there are no initial balances; an account starts at 0 if it has any transaction applied to it. - A withdrawal should not make the balance negative. If a withdrawal would cause the balance to go negative, it should be ignored. - When processing transactions, handle edge cases with extremely large or small values of amounts carefully. # Example: ```python >>> transactions = [ (123, \'deposit\', 500.0), (123, \'withdrawal\', 200.0), (456, \'deposit\', 1000.0), (123, \'withdrawal\', 400.0), (456, \'withdrawal\', 500.0), (456, \'withdrawal\', 700.0) ] >>> update_account_balances(transactions) {123: 300.0, 456: 500.0} ``` # Notes: - Focus on ensuring the algorithm correctly updates and maintains the account balances. - Ensure that deposits and withdrawals are processed correctly and withdrawals that would lead to negative balances are ignored.","solution":"from typing import List, Tuple, Dict def update_account_balances(transactions: List[Tuple[int, str, float]]) -> Dict[int, float]: account_balances = {} for account_id, transaction_type, amount in transactions: if account_id not in account_balances: account_balances[account_id] = 0.0 if transaction_type == \'deposit\': account_balances[account_id] += amount elif transaction_type == \'withdrawal\': if account_balances[account_id] >= amount: account_balances[account_id] -= amount return account_balances"},{"question":"Question Sorting algorithms form a fundamental part of computer science due to their efficiency and utility in data organization. Implement the Merge Sort algorithm, which sorts a given list of integers in ascending order. # Function Signature ```python def merge_sort(arr: list) -> list: pass ``` # Input * A single list `arr` (1 ≤ len(arr) ≤ 10^5), consisting of integers (-10^9 ≤ arr[i] ≤ 10^9). # Output * A sorted list containing the elements of `arr` in ascending order. # Constraints * The function should have a time complexity of O(n log n). * The input list may contain duplicate values. # Examples ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> merge_sort([-12, 0, 45, -1, 56, 17, 8]) [-12, -1, 0, 8, 17, 45, 56] ``` # Scenario Merge Sort is particularly useful in applications that need guaranteed performance, such as the processing of large datasets in databases or data analysis pipelines. The purpose of this function is to provide an efficient, comparison-based algorithm that can handle large input sizes with diverse integer values, including negative numbers and duplicates. # Notes Implement the Merge Sort algorithm, taking care to divide the problem into smaller subproblems and then combine the sorted subarrays. Ensure that the merge operation is efficient and correctly handles the merging of two sorted subarrays. The function will be evaluated on both its correctness and performance across various input sizes and distributions.","solution":"def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr # Split array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list, right: list) -> list: sorted_list = [] left_index = right_index = 0 # Merge the two halves in a sorted manner while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Add any remaining elements of the left half while left_index < len(left): sorted_list.append(left[left_index]) left_index += 1 # Add any remaining elements of the right half while right_index < len(right): sorted_list.append(right[right_index]) right_index += 1 return sorted_list"},{"question":"# Problem Statement You are provided with a `Graph` class that allows basic graph manipulations. Your task is to enhance this class by implementing a functionality to find the shortest path between two nodes using Dijkstra\'s algorithm. # Task Write a method `shortest_path(self, start: int, end: int) -> List[int]` within the `Graph` class that takes a start node and an end node as inputs and returns the list of nodes representing the shortest path from start to end, inclusive. If there is no path between the nodes, return an empty list. # Input * `start`: An integer representing the starting node. * `end`: An integer representing the destination node. # Output * A list of integers representing the nodes in the shortest path from start to end, inclusive. Return an empty list if no path exists. # Constraints * The graph is represented using an adjacency list where each key is a node and the value is a list of tuples `(neighbor, weight)`. * Nodes are labeled with unique integers. * The weights are non-negative integers. * Assume there are no negative-weight cycles in the graph. # Example ```python class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u: int, v: int, weight: int): if u not in self.adj_list: self.adj_list[u] = [] if v not in self.adj_list: self.adj_list[v] = [] self.adj_list[u].append((v, weight)) self.adj_list[v].append((u, weight)) # Assuming undirected graph def shortest_path(self, start: int, end: int) -> List[int]: # Your Dijkstra\'s algorithm implementation here # Example Usage: graph = Graph() graph.add_edge(1, 2, 1) graph.add_edge(2, 3, 2) graph.add_edge(1, 3, 4) path = graph.shortest_path(1, 3) print(path) # Output should be [1, 2, 3] as it represents the shortest path from node 1 to node 3 ``` # Notes * Ensure that your implementation handles graphs with disconnected nodes correctly. * Consider edge cases, such as graphs with isolated nodes or no edges. * Dijkstra\'s algorithm should maintain a time complexity of O((E + V)logV) where E is the number of edges and V is the number of vertices. * You may use a priority queue (e.g., heapq in Python) to optimize the Dijkstra\'s algorithm implementation. * Test your implementation thoroughly with various inputs to ensure accuracy and robustness.","solution":"import heapq from typing import List, Dict, Tuple class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u: int, v: int, weight: int): if u not in self.adj_list: self.adj_list[u] = [] if v not in self.adj_list: self.adj_list[v] = [] self.adj_list[u].append((v, weight)) self.adj_list[v].append((u, weight)) # Assuming undirected graph def shortest_path(self, start: int, end: int) -> List[int]: if start not in self.adj_list or end not in self.adj_list: return [] # Dijkstra\'s Algorithm pq = [(0, start)] # priority queue of (cost, node) distances = {start: 0} previous_nodes = {start: None} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end: break for neighbor, weight in self.adj_list.get(current_node, []): distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) if end not in distances: return [] # Reconstruct the path path = [] current = end while current is not None: path.append(current) current = previous_nodes[current] return path[::-1]"},{"question":"# Context: You have been assigned to enhance a function that identifies and calculates the maximum sum of any contiguous subarray within a given array of integers. This functionality is critical for various applications, including financial data analysis where determining the most profitable segment is key. # Problem Statement: Implement an optimized version of the function `max_subarray_sum`. The function should efficiently compute the maximum sum of any contiguous subarray within an input array. # Function Signature: ```python def max_subarray_sum(array: list[int]) -> int: # Your implementation here ``` # Input: - A list of integers `array` (1 <= len(array) <= 10^5). # Output: - An integer representing the maximum sum of any contiguous subarray. # Constraints: 1. The array can contain both positive and negative integers, as well as zeros. 2. The function should be optimized for large arrays. 3. Aim for a linear time complexity O(N) using an appropriate algorithm. # Examples: ```python assert max_subarray_sum([1, -3, 2, 1, -1]) == 3 assert max_subarray_sum([-2, -1, -3, -4]) == -1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 assert max_subarray_sum([-1, 2, 3, -5, 4]) == 5 ``` # Guidelines: - Utilize Kadane\'s Algorithm or any other efficient technique to achieve the desired time complexity. - Ensure code readability and maintainability with appropriate comments explaining key logic. - Consider and handle edge cases, such as arrays with all negative numbers or a single-element array. - Focus on optimizing both time and space complexity, but prioritize time complexity. By following these guidelines, your implementation should achieve the required performance and robustness to handle various and potentially large input arrays effectively.","solution":"def max_subarray_sum(array): Finds the maximum sum of any contiguous subarray using Kadane\'s Algorithm. Parameters: array (list of int): The input list of integers. Returns: int: The maximum sum of any contiguous subarray. if not array: return 0 max_ending_here = max_so_far = array[0] for num in array[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Coding Assessment Question: Optimal Sudoku Solver **Context**: Sudoku is a popular number puzzle where the objective is to fill a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 subgrids contain all the digits from 1 to 9 without repeating any. **Objective**: Your task is to write an optimized Sudoku solver that leverages backtracking and constraint propagation to efficiently solve any given valid Sudoku puzzle. The solution must minimize the number of guesses by prioritizing the cells with the fewest possible options first (Minimum Remaining Values heuristic). **Function Signature**: ```python class OptimalSudokuSolver: def __init__(self, board: List[List[int]]) -> None: Initializes the solver with the given Sudoku board. pass def is_valid(self, row: int, col: int, num: int) -> bool: Checks if placing \'num\' on the board at position (row, col) is valid. pass def solve(self) -> bool: Solves the Sudoku puzzle using backtracking. Returns True if solved, False otherwise. pass ``` **Expected Input/Output**: * Initialization: `board` is a 9x9 grid represented as a list of lists. Empty cells are denoted by 0. * `is_valid(row, col, num)`: Returns True if placing `num` at `(row, col)` is valid according to Sudoku rules, otherwise False. * `solve()`: Attempts to solve the Sudoku puzzle and updates the board in place. Returns True if the puzzle is solved successfully, otherwise False. **Constraints**: 1. The input board (`board`) will be a 9x9 list of lists with integers ranging from 0 to 9. 2. The Sudoku puzzle provided will always have a valid solution. **Requirements**: - **Edge Cases**: Handle cells on the border and corner of the grid correctly. - **Performance**: Implement efficient backtracking with constraint propagation to prune the search space. **Challenge**: Optimize the `solve` method using the Minimum Remaining Values heuristic and ensure that the board is solved as quickly as possible, even for challenging puzzles. **Example Usage**: ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9], ] solver = OptimalSudokuSolver(board) if solver.solve(): print(\\"Sudoku solved successfully!\\") for row in board: print(row) else: print(\\"Failed to solve Sudoku.\\") ```","solution":"from typing import List, Tuple class OptimalSudokuSolver: def __init__(self, board: List[List[int]]) -> None: Initializes the solver with the given Sudoku board. self.board = board def is_valid(self, row: int, col: int, num: int) -> bool: Checks if placing \'num\' on the board at position (row, col) is valid. # Check the row for c in range(9): if self.board[row][c] == num: return False # Check the column for r in range(9): if self.board[r][col] == num: return False # Check the 3x3 subgrid start_r, start_c = 3 * (row // 3), 3 * (col // 3) for r in range(start_r, start_r + 3): for c in range(start_c, start_c + 3): if self.board[r][c] == num: return False return True def find_empty_location(self) -> Tuple[int, int]: Finds an empty location on the board. for r in range(9): for c in range(9): if self.board[r][c] == 0: return (r, c) return (-1, -1) def solve(self) -> bool: Solves the Sudoku puzzle using backtracking. Returns True if solved, False otherwise. # Find an empty cell row, col = self.find_empty_location() # If there are no empty cells, we\'re done if row == -1 and col == -1: return True # Try digits 1 to 9 in the empty cell for num in range(1, 10): if self.is_valid(row, col, num): # Place the number self.board[row][col] = num # Recursively attempt to solve the rest of the board if self.solve(): return True # Reset the cell (backtrack) self.board[row][col] = 0 return False"},{"question":"# Unique Triplets Challenge Objective: Implement a function that identifies all unique triplets in an array where the sum of the three numbers is zero. Context: In numerous computational problems, finding specific patterns among sets of numbers is crucial. For instance, identifying unique triplets whose sum results in zero is a common challenge in data analysis and algorithm optimization tasks. This problem explores your ability to handle combinations and conditions efficiently. Problem Statement: Given an array of integers, your task is to find all unique triplets in the array that sum up to zero (0). You need to write a function `three_sum` which takes an array of integers and returns a list of lists, with each inner list containing a triplet that sums to zero. Function Signature: ```python def three_sum(nums: List[int]) -> List[List[int]]: ``` Input: - `nums`: A list of integers, which may contain both positive and negative numbers. Output: - A list of lists, with each inner list containing three numbers that sum to zero, without any duplicate triplets. Constraints: - The length of the input list is in the range [0, 3000]. - -10^5 <= nums[i] <= 10^5. Example: ```python # Example input nums = [-1, 0, 1, 2, -1, -4] # Output desired print(three_sum(nums)) # Output should be: [[-1, -1, 2], [-1, 0, 1]] nums = [] print(three_sum(nums)) # Output should be: [] nums = [0, 0, 0] print(three_sum(nums)) # Output should be: [[0, 0, 0]] nums = [-4, -2, -1, 0, 1, 2, 3] print(three_sum(nums)) # Output should be: [[-4, 1, 3], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] ``` Note: - The solution must ensure that there are no duplicate triplets in the final output. - The triplets can be returned in any order. - Edge cases such as empty array or array with fewer than three items should be handled appropriately. The solution should aim to efficiently find the unique triplets even with the upper constraint on array length.","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: nums.sort() result = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return result"},{"question":"You have been provided with a code segment designed to solve the \\"word ladder\\" problem using breadth-first search (BFS). # Problem Statement 1. **Function to Implement**: Write a function `word_ladder_length(start: str, end: str, word_list: Sequence[str]) -> int` that takes three parameters: * `start` (string): The starting word. * `end` (string): The ending word. * `word_list` (sequence of strings): A list of valid words. 2. **Expected Output**: This function should return the length of the shortest transformation sequence from `start` to `end`, where: * Only one letter can be changed at a time. * Each transformed word must exist in the word list. # Constraints * 1 <= `len(start)`, `len(end)` <= 10 * 1 <= `len(word_list)` <= 1000 * All words in the `word_list` and the `start` and `end` words are of the same length. * `end` is guaranteed to be in `word_list`. * All words contain only lowercase alphabetical characters. # Example ```python >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0 ``` # Notes * You can assume that all inputs are valid and that the word list contains no duplicate entries. * If no transformation sequence exists, return 0. * The function should use an efficient algorithm to handle large word lists and find the shortest path. # Task Breakdown 1. Implement an efficient BFS to find the shortest transformation sequence. 2. Use auxiliary data structures to manage the word transformations. 3. Handle edge cases such as no possible transformation sequence.","solution":"from collections import deque from typing import Sequence def word_ladder_length(start: str, end: str, word_list: Sequence[str]) -> int: word_set = set(word_list) if end not in word_set: return 0 queue = deque([(start, 1)]) alphabet = \'abcdefghijklmnopqrstuvwxyz\' while queue: current_word, length = queue.popleft() if current_word == end: return length for i in range(len(current_word)): for char in alphabet: new_word = current_word[:i] + char + current_word[i + 1:] if new_word in word_set: queue.append((new_word, length + 1)) word_set.remove(new_word) return 0"},{"question":"# Implement a Binary Search Tree with Traversal Methods You are tasked with implementing a Binary Search Tree (BST) class. Your BST should support the following functionalities: 1. Insertion of nodes while maintaining the BST properties. 2. Search for a given element and determine if it exists in the tree. 3. Perform in-order, pre-order, and post-order traversals and return the results as lists. # Function Requirements 1. `insert_node(self, data)`: Insert a single element into the BST. 2. `search_node(self, data)`: Search for an element in the BST; return `True` if found, otherwise return `False`. 3. `in_order_traversal(self)`: Perform in-order traversal. 4. `pre_order_traversal(self)`: Perform pre-order traversal. 5. `post_order_traversal(self)`: Perform post-order traversal. # Input and Output - `insert_node(self, data)` - **Input**: An integer `data`. - **Output**: None. - `search_node(self, data)` - **Input**: An integer `data`. - **Output**: `True` if the element exists in the BST, otherwise `False`. - `in_order_traversal(self)` - **Input**: None. - **Output**: A list of elements in in-order traversal. - `pre_order_traversal(self)` - **Input**: None. - **Output**: A list of elements in pre-order traversal. - `post_order_traversal(self)` - **Input**: None. - **Output**: A list of elements in post-order traversal. # Constraints - Only integer values are supported. # Example ```python bst = BST() # Insert nodes bst.insert_node(10) bst.insert_node(5) bst.insert_node(15) bst.insert_node(2) bst.insert_node(7) # Search nodes print(bst.search_node(7)) # => True print(bst.search_node(20)) # => False # Traversals print(bst.in_order_traversal()) # => [2, 5, 7, 10, 15] print(bst.pre_order_traversal()) # => [10, 5, 2, 7, 15] print(bst.post_order_traversal())# => [2, 7, 5, 15, 10] ``` # Implementation Implement the `insert_node`, `search_node`, `in_order_traversal`, `pre_order_traversal`, and `post_order_traversal` methods to complete the `BST` class, focusing on the characteristics and principles of a Binary Search Tree.","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert_node(self, data): if self.root is None: self.root = TreeNode(data) else: self._insert_helper(self.root, data) def _insert_helper(self, node, data): if data < node.data: if node.left: self._insert_helper(node.left, data) else: node.left = TreeNode(data) else: if node.right: self._insert_helper(node.right, data) else: node.right = TreeNode(data) def search_node(self, data): return self._search_helper(self.root, data) def _search_helper(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search_helper(node.left, data) else: return self._search_helper(node.right, data) def in_order_traversal(self): result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, node, result): if node: self._in_order_helper(node.left, result) result.append(node.data) self._in_order_helper(node.right, result) def pre_order_traversal(self): result = [] self._pre_order_helper(self.root, result) return result def _pre_order_helper(self, node, result): if node: result.append(node.data) self._pre_order_helper(node.left, result) self._pre_order_helper(node.right, result) def post_order_traversal(self): result = [] self._post_order_helper(self.root, result) return result def _post_order_helper(self, node, result): if node: self._post_order_helper(node.left, result) self._post_order_helper(node.right, result) result.append(node.data)"},{"question":"# Graph Path Finding Enhancement You are given a basic implementation of a Graph class that supports adding edges between nodes. Your task is to enhance this graph with additional functionalities. Requirements 1. **Enhance the Graph class to remove nodes**: Add a method `remove_node(node)` that removes a node and all associated edges from the graph. 2. **Add a method to check path existence**: Implement a `has_path(start_node, end_node)` method to check if there is a path between two nodes. 3. **Add a method to perform Depth-First Search (DFS)**: Implement a `dfs(start_node)` method that returns a list of nodes visited during a DFS traversal starting from `start_node`. 4. **Include error handling**: Ensure that all methods handle cases where nodes do not exist in the graph. Constraints * The graph nodes are represented as integers. * The graph is undirected. * The edge list might be empty. # Function Signature ```python class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, node1, node2): # existing implementation def remove_node(self, node): # new method implementation def has_path(self, start_node, end_node): # new method implementation def dfs(self, start_node): # new method implementation ``` Input * For creating an instance of `Graph`: No specific input required for initialization. * Method `add_edge(self, node1, node2)` will add an undirected edge between `node1` and `node2`. * Method `remove_node(self, node)` will remove the node along with all its associated edges. * Method `has_path(self, start_node, end_node)` will return a boolean indicating if a path exists between `start_node` and `end_node`. * Method `dfs(self, start_node)` will return a list of nodes visited in a DFS traversal starting from `start_node`. Output * Method `remove_node(self, node)` will update the graph by removing the specified node and its edges. * Method `has_path(self, start_node, end_node)` will return `True` if a path exists, otherwise `False`. * Method `dfs(self, start_node)` will return a list of nodes visited in DFS order. # Example ```python # Creating an instance of Graph graph = Graph() # Adding edges graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 4) # Checking if a path exists print(graph.has_path(1, 4)) # True print(graph.has_path(4, 5)) # False # Performing DFS traversal print(graph.dfs(1)) # e.g., might print [1, 2, 4, 3] # Removing a node graph.remove_node(4) # Checking if a path exists after removal print(graph.has_path(1, 4)) # False ```","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, node1, node2): if node1 not in self.adjacency_list: self.adjacency_list[node1] = [] if node2 not in self.adjacency_list: self.adjacency_list[node2] = [] self.adjacency_list[node1].append(node2) self.adjacency_list[node2].append(node1) def remove_node(self, node): if node not in self.adjacency_list: return for neighbour in self.adjacency_list[node]: self.adjacency_list[neighbour].remove(node) del self.adjacency_list[node] def has_path(self, start_node, end_node): if start_node not in self.adjacency_list or end_node not in self.adjacency_list: return False visited = set() return self._has_path_dfs(start_node, end_node, visited) def _has_path_dfs(self, current, destination, visited): if current == destination: return True visited.add(current) for neighbour in self.adjacency_list[current]: if neighbour not in visited: if self._has_path_dfs(neighbour, destination, visited): return True return False def dfs(self, start_node): if start_node not in self.adjacency_list: return [] visited = [] self._dfs_recursive(start_node, visited, set()) return visited def _dfs_recursive(self, current, visited, visited_set): visited.append(current) visited_set.add(current) for neighbour in self.adjacency_list[current]: if neighbour not in visited_set: self._dfs_recursive(neighbour, visited, visited_set)"},{"question":"# Coding Assessment Question You are tasked with implementing a feature to replicate the functionality of a \\"frequency counter\\" that identifies the most common word(s) in a given text. This feature will assist in linguistic analysis and optimize text processing tasks. Requirements: 1. Implement a function `most_common_words` that takes in a string `text` and returns a list of the most common word(s) in the text. 2. If there are multiple words with the same highest frequency, the function should return all of them as a list, sorted in alphabetical order. 3. The function should ignore case and exclude punctuation when counting word frequencies. 4. You may assume that the text input is non-empty. # Function Signature ```python def most_common_words(text: str) -> list[str]: Identify the most common word(s) in the given text. :param text: The text from which to find the most common words :type text: str :return: List of the most common word(s) :rtype: list[str] pass ``` # Input - A string `text` representing the input text. # Output - A list of string(s) representing the most common word(s) sorted in alphabetical order. # Constraints - The text input can be long, so ensure the solution is optimized for performance. - Handle any standard punctuation marks (.,!?:;\') but don\'t worry about special characters or unconventional punctuation. - Ensure that case differences are ignored in word counting (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). # Example ```python text1 = \\"This is a test. This test is only a test.\\" most_common_words(text1) # Output: [\'test\'] text2 = \\"Another example; another test; another word.\\" most_common_words(text2) # Output: [\'another\'] text3 = \\"Word, word. word! Is word the most common word?\\" most_common_words(text3) # Output: [\'word\'] ``` In the examples, the function identifies and returns the most common word(s) after normalizing the text by case and excluding punctuation marks. # Additional Information The function should handle texts gracefully and provide accurate and efficient results. Document any assumptions you make and describe your approach. This question assesses: - Proficiency in string manipulation and text processing, - Ability to handle edge cases related to punctuation and case sensitivity, - Competence in implementing and optimizing frequency counting algorithms.","solution":"import re from collections import Counter def most_common_words(text: str) -> list[str]: Identify the most common word(s) in the given text. :param text: The text from which to find the most common words :type text: str :return: List of the most common word(s) :rtype: list[str] # Remove punctuation and convert text to lowercase clean_text = re.sub(r\'[^ws]\', \'\', text).lower() # Split text into words words = clean_text.split() # Count word frequencies word_counts = Counter(words) # Find the maximum frequency max_count = max(word_counts.values()) # Get all words with the maximum frequency most_common = [word for word, count in word_counts.items() if count == max_count] # Return the words sorted in alphabetical order return sorted(most_common)"},{"question":"# Scenario You have been given the task to develop a utility function for a graphics rendering pipeline. One critical part of the rendering process is smoothly transitioning an object\'s color from one state to another over a period of time. # Problem Statement Write a function `compute_color_transition` that computes the interpolated colors for each time step given the starting and ending colors, as well as the total number of time steps. # Function Signature ```python def compute_color_transition(start_color: Tuple[int, int, int], end_color: Tuple[int, int, int], steps: int) -> List[Tuple[int, int, int]]: Parameters: 1. start_color (Tuple[int, int, int]): The starting color as an (R, G, B) tuple where each component is an integer between 0 and 255. 2. end_color (Tuple[int, int, int]): The ending color as an (R, G, B) tuple where each component is an integer between 0 and 255. 3. steps (int): The total number of steps for the transition. Returns: List[Tuple[int, int, int]]: A list of (R, G, B) tuples representing the interpolated colors at each step. Raises: ValueError: If any color component is outside the range 0-255 or if \'steps\' is non-positive. ``` # Input * `start_color` is a tuple of three integers (R, G, B), each between 0 and 255 inclusive, representing the starting color. * `end_color` is a tuple of three integers (R, G, B), each between 0 and 255 inclusive, representing the ending color. * `steps` is an integer representing the total number of steps for the transition (must be positive). # Output * A list of tuples, where each tuple consists of three integers (R, G, B), representing the interpolated color at each step. # Constraints * Ensure all color components are within the range 0-255. * Ensure `steps` is positive (greater than 0). # Examples ```python # Example 1 start = (255, 0, 0) end = (0, 0, 255) result = compute_color_transition(start, end, 5) print(result) # Expected output: [(255, 0, 0), (191, 0, 63), (127, 0, 127), (63, 0, 191), (0, 0, 255)] # Example 2 start = (0, 255, 0) end = (0, 0, 0) result = compute_color_transition(start, end, 4) print(result) # Expected output: [(0, 255, 0), (0, 170, 0), (0, 85, 0), (0, 0, 0)] # Edge Case 1 try: result = compute_color_transition((255, 0, 0), (0, 0, 255), 0) except ValueError as e: print(e) # Expected: The number of steps must be greater than 0. # Edge Case 2 try: result = compute_color_transition((256, 0, 0), (0, 0, 255), 5) except ValueError as e: print(e) # Expected: Color components must be in the range 0-255. ``` # Additional Notes You should raise appropriate exceptions for invalid inputs according to the constraints described.","solution":"from typing import List, Tuple def compute_color_transition(start_color: Tuple[int, int, int], end_color: Tuple[int, int, int], steps: int) -> List[Tuple[int, int, int]]: if not (0 <= start_color[0] <= 255 and 0 <= start_color[1] <= 255 and 0 <= start_color[2] <= 255): raise ValueError(\\"Start color components must be in the range 0-255.\\") if not (0 <= end_color[0] <= 255 and 0 <= end_color[1] <= 255 and 0 <= end_color[2] <= 255): raise ValueError(\\"End color components must be in the range 0-255.\\") if steps <= 0: raise ValueError(\\"The number of steps must be greater than 0.\\") interpolated_colors = [] for step in range(steps): r = start_color[0] + (end_color[0] - start_color[0]) * step // (steps - 1) g = start_color[1] + (end_color[1] - start_color[1]) * step // (steps - 1) b = start_color[2] + (end_color[2] - start_color[2]) * step // (steps - 1) interpolated_colors.append((r, g, b)) return interpolated_colors"},{"question":"# Question You are given a binary tree where each node contains an integer and two children pointers: `left` and `right`. Your task is to implement the function `largest_bst_subtree` that finds the size of the largest subtree which is a Binary Search Tree (BST). # Constraints 1. The tree will have at most 10^4 nodes. 2. The values within the nodes are between `-10^9` and `10^9` inclusive. 3. Assume the `Node` class is defined with `val`, `left`, and `right` attributes. # Function Signature ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_bst_subtree(root: Node) -> int: ... ``` # Input Format - `root`: An instance of `Node` representing the root of the binary tree. # Output Format - An integer representing the size of the largest BST subtree. # Example ```python root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(1) root.left.right = Node(8) root.right.right = Node(7) output = largest_bst_subtree(root) print(output) # Expected: 3 ``` # Additional Requirements: 1. Define the `Node` class as specified. 2. You should not modify the original tree structure. 3. Your algorithm should account for efficiency given the constraint on the number of nodes.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_bst_subtree(root: Node) -> int: def helper(node): if not node: return True, 0, float(\'inf\'), float(\'-inf\') is_left_bst, left_size, left_min, left_max = helper(node.left) is_right_bst, right_size, right_min, right_max = helper(node.right) if is_left_bst and is_right_bst and left_max < node.val < right_min: current_size = left_size + right_size + 1 return True, current_size, min(node.val, left_min), max(node.val, right_max) else: return False, max(left_size, right_size), 0, 0 return helper(root)[1]"},{"question":"**Context**: Graph traversal is an essential technique in computer science for exploring nodes and edges in a graph. The Depth-First Search (DFS) algorithm is widely used to traverse or search through data structures such as trees and graphs, either to learn the structure of the graph or to solve problems involving the traversal. # Problem Statement Implement a function using the Depth-First Search (DFS) algorithm to find all paths in a directed acyclic graph (DAG) from a given source node to a target node. A path is a sequence of nodes and edges connecting a source node to a target node without revisiting any node. # Requirements * **Function Name**: `find_all_paths` * **Input**: - A dictionary representing a graph `graph` where keys are node identifiers and values are lists of neighboring nodes. - A node identifier `start` representing the starting node. - A node identifier `end` representing the target node. * **Output**: A list of lists, where each list represents a valid path from the start node to the end node. # Constraints - Graph is directed and acyclic. - Ensure the function can handle graphs with moderate size and depth efficiently. # Example ```python def find_all_paths(graph: dict, start: str, end: str) -> list: # Your code here # Examples: graph_example = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } print(find_all_paths(graph_example, \'A\', \'D\')) # Output: [[\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] print(find_all_paths(graph_example, \'A\', \'C\')) # Output: [[\'A\', \'C\']] print(find_all_paths(graph_example, \'B\', \'D\')) # Output: [[\'B\', \'D\']] print(find_all_paths(graph_example, \'D\', \'A\')) # Output: [] print(find_all_paths(graph_example, \'A\', \'X\')) # Output: Error or any suitable message ``` # Special Considerations - Handle cases where the start node or end node is not in the graph gracefully. - Make sure to avoid revisiting nodes, as it\'s a directed acyclic graph (DAG). - Implement the DFS algorithm recursively or using a stack to keep track of the current path. - Handle cyclic dependencies and ensure the graph remains acyclic prior to processing. # Testing Design a suite of unit tests to validate the functionality, including empty graphs, graphs with one node, graphs with no path between the start and end node, and larger graphs with multiple possible paths.","solution":"def find_all_paths(graph: dict, start: str, end: str) -> list: Finds all paths from start node to end node in a directed acyclic graph. Parameters: graph (dict): A dictionary representation of the graph. start (str): The starting node. end (str): The target node. Returns: list: A list of lists, where each list is a valid path from start to end. def dfs(current, path): path.append(current) if current == end: paths.append(path[:]) else: for neighbor in graph.get(current, []): if neighbor not in path: # ensure no revisiting dfs(neighbor, path) path.pop() if start not in graph: return f\\"Error: Start node \'{start}\' not in graph.\\" if end not in graph: return f\\"Error: End node \'{end}\' not in graph.\\" paths = [] dfs(start, []) return paths"},{"question":"# Matrix Determinant Calculator Context You are tasked with developing a matrix calculator that determines the determinant of a square matrix. This function will be useful in various linear algebra applications such as solving systems of linear equations, finding inverse matrices, and more. Task Write a function `calculate_determinant(matrix: List[List[float]]) -> float` that computes the determinant of a given square matrix using recursion and Laplace expansion. The function should: 1. Check if the matrix is square (i.e., the number of rows should be equal to the number of columns). 2. Implement the recursive calculation of the determinant using the Laplace expansion. 3. Handle base cases where the matrix is 1x1 or 2x2 directly. 4. Raise a ValueError if the input matrix is not square. Inputs and Outputs * **Input**: * `matrix` - A list of lists representing an NxN square matrix (N can range from 1 to 10). * **Output**: * A float representing the determinant of the matrix. Constraints * The matrix will only contain numerical values (both integers and floats). * The sizes of the matrix will range from 1x1 to 10x10. Performance Requirements * The function should accurately compute the determinant for matrices up to 10x10 within a reasonable time frame. Example ```python from typing import List # Sample matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = calculate_determinant(matrix) print(\\"Determinant:\\", result) ``` Expected output will be `Determinant: 0.0` because the given matrix has linearly dependent rows (its rows/columns are linearly dependent). ```python # Implementation def get_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def calculate_determinant(matrix: List[List[float]]) -> float: # Verification if matrix is square if len(matrix) != len(matrix[0]): raise ValueError(\\"Matrix must be square.\\") # Base case for 1x1 matrix if len(matrix) == 1: return matrix[0][0] # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1)**c) * matrix[0][c] * calculate_determinant(get_minor(matrix, 0, c)) return determinant ```","solution":"from typing import List def get_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def calculate_determinant(matrix: List[List[float]]) -> float: Computes the determinant of a given square matrix. Params: - matrix (List[List[float]]): A list of lists representing an NxN square matrix Returns: - float: the determinant of the matrix # Verification if matrix is square if len(matrix) != len(matrix[0]): raise ValueError(\\"Matrix must be square.\\") # Base case for 1x1 matrix if len(matrix) == 1: return matrix[0][0] # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1)**c) * matrix[0][c] * calculate_determinant(get_minor(matrix, 0, c)) return determinant"},{"question":"# URL Shortening Service Context URL shortening is a technique used to create shorter versions of long URLs for ease of sharing. A common format includes replacing a long URL with a shortened, unique key that redirects to the original URL when accessed. You are required to implement a set of functions to create a simple URL shortening service that can: 1. Generate a unique shortened key for a given URL. 2. Retrieve the original URL from the shortened key. 3. Validate if a given shortened key exists in the system. Tasks 1. **Implement the `shorten_url` function**: - **Input**: A string representing the original URL. - **Output**: A string representing the shortened key (for example, a random 6-character alphanumeric string). 2. **Implement the `retrieve_url` function**: - **Input**: A string representing the shortened key. - **Output**: A string representing the original URL associated with the shortened key, or `None` if the key does not exist. 3. **Implement the `is_valid_key` function**: - **Input**: A string representing the shortened key. - **Output**: A boolean indicating if the shortened key exists in the system. Example ```python # Example usage and expected outputs: shortened_key_1 = shorten_url(\\"https://example.com/page1\\") print(shortened_key_1) # should return a 6-character string, e.g., \\"a1b2c3\\" # Retrieve the original URL using the shortened key original_url_1 = retrieve_url(shortened_key_1) print(original_url_1) # should return \\"https://example.com/page1\\" # Check if a shortened key is valid print(is_valid_key(shortened_key_1)) # should return True print(is_valid_key(\\"invalid\\")) # should return False ``` **Constraints**: 1. The shortened key should be unique for each unique URL. 2. You should handle repeated shortening requests for the same URL such that the same key might be returned. 3. You can assume the input URLs are valid web URLs. 4. The system should efficiently handle a moderate amount of URLs (up to tens of thousands). **Performance Requirement**: Your solution should be efficient in terms of both time and space, ensuring quick lookups and insertions for typical URL shortening service volumes.","solution":"import random import string url_mapping = {} key_mapping = {} def generate_key(n=6): Generates a random n-character alphanumeric key. return \'\'.join(random.choices(string.ascii_letters + string.digits, k=n)) def shorten_url(original_url): Generates a unique shortened key for the given URL. If the URL has been shortened before, it returns the existing shortened key. if original_url in url_mapping: return url_mapping[original_url] else: while True: key = generate_key() if key not in key_mapping: url_mapping[original_url] = key key_mapping[key] = original_url return key def retrieve_url(shortened_key): Retrieves the original URL given the shortened key. Returns None if the key does not exist. return key_mapping.get(shortened_key) def is_valid_key(shortened_key): Validates if the given shortened key exists in the system. return shortened_key in key_mapping"},{"question":"# Coding Assessment Question You are given a list of integers `nums` and an integer `target`, your task is to implement a function `three_sum_closest(nums: [int], target: int) -> int` that returns the sum of three integers from `nums` such that the sum is closest to `target`. Input * A list of integers `nums` where (3 <= len(nums) <= 1000). * An integer `target` where the absolute value of the target is within the range of [-10^4, 10^4]. Output * An integer representing the sum of three integers from `nums` that is closest to `target`. Example ```python assert three_sum_closest([-1, 2, 1, -4], 1) == 2 # [-1, 2, 1] sums to 2, which is closest to 1. assert three_sum_closest([0, 0, 0], 1) == 0 # [0, 0, 0] sums to 0, which is closest to 1. assert three_sum_closest([1, 1, 1, 0], -100) == 2 # [0, 1, 1] sums to 2. ``` Constraints * You may assume each input would have exactly one solution. * The list `nums` will contain distinct numbers only. Function Signature ```python def three_sum_closest(nums: [int], target: int) -> int: pass ``` Notes 1. The function should handle edge cases like the given list having negative numbers or values close to the minimum and maximum allowed. 2. While correctness is paramount, aim to structure your solution for efficiency, considering possible approaches like sorting and using two-pointer techniques.","solution":"def three_sum_closest(nums, target): nums.sort() # Sort the array for two-pointer approach closest_sum = float(\'inf\') # Initialize the closest sum with infinity for i in range(len(nums) - 2): # Fix the first element left, right = i + 1, len(nums) - 1 # Use two pointers to find the other two numbers while left < right: current_sum = nums[i] + nums[left] + nums[right] # If the current sum is exactly equal to the target, return it if current_sum == target: return current_sum # Update the closest sum if current sum is closer to the target if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum # Move the pointers based on comparison of current sum and target if current_sum < target: left += 1 else: right -= 1 return closest_sum # Return the closest sum found"},{"question":"# Background You are tasked with developing a simple command line tool to analyze a log file containing data of user actions on a website. Each line in the log file represents an action recorded in the format: `<timestamp> <user_id> <action>`, where `<timestamp>` is a UNIX timestamp, `<user_id>` is a unique identifier for the user, and `<action>` is the type of action performed (e.g., \\"click\\", \\"view\\", \\"purchase\\"). # Problem Statement Write a function named `analyze_log` in Python that reads the log file and performs the following tasks: 1. Reads the log file line by line. 2. Parses each line to extract the timestamp, user_id, and action. 3. Counts how many times each type of action occurs. 4. Determines the first and last timestamp when each action type occurred. 5. Returns a dictionary where each key is an action type and the value is another dictionary with keys \'count\', \'first_timestamp\', and \'last_timestamp\'. # Function Signature ```python def analyze_log(filename: str) -> dict: # your code here ``` # Input - `filename` (string): A non-empty string representing the path to the log file. # Output - (dict): A dictionary with the action type as keys and another dictionary as values. The inner dictionary contains: - \'count\' (int): The number of times the action occurred. - \'first_timestamp\' (int): The earliest timestamp the action occurred. - \'last_timestamp\' (int): The latest timestamp the action occurred. # Constraints - The log file may be of considerable size; strive for efficiency. - The timestamp in the log file is always positive. - The `user_id` and `action` will always be non-empty strings without spaces. # Example Usage Assume the log file `user_actions.log` contains: ``` 1614885600 user1 click 1614885700 user1 view 1614885800 user2 click 1614885900 user2 purchase 1614886000 user1 click ``` ```python result = analyze_log(\\"user_actions.log\\") print(result) # Output should be: # { # \\"click\\": { # \\"count\\": 3, # \\"first_timestamp\\": 1614885600, # \\"last_timestamp\\": 1614886000 # }, # \\"view\\": { # \\"count\\": 1, # \\"first_timestamp\\": 1614885700, # \\"last_timestamp\\": 1614885700 # }, # \\"purchase\\": { # \\"count\\": 1, # \\"first_timestamp\\": 1614885900, # \\"last_timestamp\\": 1614885900 # } # } ``` # Notes - Ensure efficient file I/O operations. - Handles cases where actions may vary in occurrence and order.","solution":"def analyze_log(filename: str) -> dict: action_stats = {} with open(filename, \'r\') as file: for line in file: timestamp, user_id, action = line.strip().split() timestamp = int(timestamp) if action not in action_stats: action_stats[action] = { \'count\': 1, \'first_timestamp\': timestamp, \'last_timestamp\': timestamp, } else: action_stats[action][\'count\'] += 1 action_stats[action][\'first_timestamp\'] = min(action_stats[action][\'first_timestamp\'], timestamp) action_stats[action][\'last_timestamp\'] = max(action_stats[action][\'last_timestamp\'], timestamp) return action_stats"},{"question":"# Question: Implement a Frequency Counter for Custom Data Structures You are required to create a function to count the frequency of elements in a custom data structure that behaves similarly to a list but with limited access capabilities. Scenario You are given a custom data list called `MyCustomList`. This custom list class stores numerical data and offers only the following methods: * `get_len()` - returns the total number of elements in the list. * `get_element(index)` - retrieves the element located at the specified index (indexing starts from 0). Your task is to implement a function `frequency_counter(my_list: MyCustomList) -> dict` that counts the frequency of each element in an instance of `MyCustomList` and returns a dictionary with elements as keys and their corresponding frequencies as values. Specification * **Function Name:** `frequency_counter` * **Input:** * `my_list` - an instance of `MyCustomList` containing the elements to be processed. * **Output:** * A dictionary where the keys are the elements from the list and the values are the frequencies of those elements. Constraints: * The list will contain at least one element. * All elements are numerical (integers or floating-point numbers). * You cannot convert `MyCustomList` to a standard Python list or use any standard list methods. Example Usage: ```python class MyCustomList: def __init__(self, elements): self.elements = elements def get_len(self): return len(self.elements) def get_element(self, index): return self.elements[index] # Example: my_list = MyCustomList([4, 2, 4, 1, 4, 2]) print(frequency_counter(my_list)) # Should output {4: 3, 2: 2, 1: 1} my_list = MyCustomList([7.1, 7.1, 8.2, 9.3]) print(frequency_counter(my_list)) # Should output {7.1: 2, 8.2: 1, 9.3: 1} ``` Performance Requirements: * Your implementation should be efficient, running in O(n) time where n is the number of elements in `MyCustomList`. Make sure your function accounts for potential edge cases and is robust against improper uses.","solution":"def frequency_counter(my_list): Counts the frequency of elements in an instance of MyCustomList. Args: - my_list (MyCustomList): The custom list to count frequencies for. Returns: - dict: A dictionary with elements as keys and their corresponding frequencies as values. frequency_dict = {} length = my_list.get_len() for i in range(length): element = my_list.get_element(i) if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict"},{"question":"# Rotate and Query Operations on Matrix # You\'re provided with a class that represents a 2D matrix and includes basic functionalities for manipulation. Task: Extend this class with the following functionalities: 1. A method `rotate_90_clockwise` to rotate the matrix 90 degrees clockwise. 2. A method `query_submatrix_sum` which calculates the sum of a submatrix given its top-left and bottom-right coordinates (inclusive). # Inputs and Outputs: **Method 1: rotate_90_clockwise** - **Input:** None (modifies the internal matrix) - **Output:** None **Method 2: query_submatrix_sum** - **Input:** `top_left`: Tuple of two integers (row_index, column_index) indicating the top-left corner of the submatrix. `bottom_right`: Tuple of two integers (row_index, column_index) indicating the bottom-right corner of the submatrix. - **Output:** Integer, the sum of all elements in the specified submatrix. # Examples: 1. For `rotate_90_clockwise`: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat_ops = MatrixOperations(matrix) mat_ops.rotate_90_clockwise() print(mat_ops.matrix) ``` **Output:** ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. For `query_submatrix_sum(top_left, bottom_right)`: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat_ops = MatrixOperations(matrix) result = mat_ops.query_submatrix_sum((0, 0), (1, 1)) print(result) ``` **Output:** ``` 12 # Submatrix: [[1, 2], [4, 5]] ``` # Constraints: - The matrix\'s dimensions will be in the range [0, 100] for both rows and columns. - Matrix elements will be integers. - (top_left and bottom_right) coordinates are valid and within the bounds of the matrix. # Implementation: ```python class MatrixOperations: def __init__(self, matrix: list[list[int]]) -> None: self.matrix = matrix def rotate_90_clockwise(self) -> None: Rotates the matrix 90 degrees clockwise. if not self.matrix: return rows, columns = len(self.matrix), len(self.matrix[0]) # Temporary matrix for rotated version rotated_matrix = [[0] * rows for _ in range(columns)] for r in range(rows): for c in range(columns): rotated_matrix[c][rows - 1 - r] = self.matrix[r][c] self.matrix = rotated_matrix def query_submatrix_sum(self, top_left: tuple[int, int], bottom_right: tuple[int, int]) -> int: Calculates the sum of elements in the specified submatrix. top_row, top_col = top_left bottom_row, bottom_col = bottom_right submatrix_sum = 0 for row in range(top_row, bottom_row + 1): for col in range(top_col, bottom_col + 1): submatrix_sum += self.matrix[row][col] return submatrix_sum ``` This question tests matrix manipulation and querying techniques, maintaining consistency in style, complexity, and length with the provided sample questions.","solution":"class MatrixOperations: def __init__(self, matrix: list[list[int]]) -> None: self.matrix = matrix def rotate_90_clockwise(self) -> None: Rotates the matrix 90 degrees clockwise. if not self.matrix: return rows, columns = len(self.matrix), len(self.matrix[0]) # Temporary matrix for rotated version rotated_matrix = [[0] * rows for _ in range(columns)] for r in range(rows): for c in range(columns): rotated_matrix[c][rows - 1 - r] = self.matrix[r][c] self.matrix = rotated_matrix def query_submatrix_sum(self, top_left: tuple[int, int], bottom_right: tuple[int, int]) -> int: Calculates the sum of elements in the specified submatrix. top_row, top_col = top_left bottom_row, bottom_col = bottom_right submatrix_sum = 0 for row in range(top_row, bottom_row + 1): for col in range(top_col, bottom_col + 1): submatrix_sum += self.matrix[row][col] return submatrix_sum"},{"question":"# Question: Determine Network and Broadcast Addresses You are required to implement two functions that determine the network address and the broadcast address given an IPv4 address and a subnet mask. Function 1: `get_network_address` Implement the function `get_network_address(ipv4_address: str, subnet_mask: str) -> str`. **Input:** - `ipv4_address`: A string representing an IPv4 address in dotted decimal format (e.g., \\"192.168.1.10\\"). - `subnet_mask`: A string representing a subnet mask in dotted decimal format (e.g., \\"255.255.255.0\\"). **Output:** - A string representing the network address in dotted decimal format. **Constraints:** - Both `ipv4_address` and `subnet_mask` strings are guaranteed to be in the correct format. - Each octet in the IPv4 address and subnet mask ranges from 0 to 255. **Example:** ```python assert get_network_address(\\"192.168.1.10\\", \\"255.255.255.0\\") == \\"192.168.1.0\\" assert get_network_address(\\"10.0.5.100\\", \\"255.255.0.0\\") == \\"10.0.0.0\\" ``` Function 2: `get_broadcast_address` Implement the function `get_broadcast_address(ipv4_address: str, subnet_mask: str) -> str`. **Input:** - `ipv4_address`: A string representing an IPv4 address in dotted decimal format (e.g., \\"192.168.1.10\\"). - `subnet_mask`: A string representing a subnet mask in dotted decimal format (e.g., \\"255.255.255.0\\"). **Output:** - A string representing the broadcast address in dotted decimal format. **Constraints:** - Both `ipv4_address` and `subnet_mask` strings are guaranteed to be in the correct format. - Each octet in the IPv4 address and subnet mask ranges from 0 to 255. **Example:** ```python assert get_broadcast_address(\\"192.168.1.10\\", \\"255.255.255.0\\") == \\"192.168.1.255\\" assert get_broadcast_address(\\"10.0.5.100\\", \\"255.255.0.0\\") == \\"10.0.255.255\\" ``` **Edge Cases to Consider:** - Ensure your function handles edge cases where the subnet mask is minimal (0.0.0.0) or maximal (255.255.255.255). - Properly handle scenarios where the IPv4 address is at the boundaries of a given subnet (e.g., the first and last possible addresses within the subnet).","solution":"def get_network_address(ipv4_address: str, subnet_mask: str) -> str: Returns the network address given an IPv4 address and a subnet mask. ip_octets = list(map(int, ipv4_address.split(\'.\'))) mask_octets = list(map(int, subnet_mask.split(\'.\'))) network_address_octets = [ip & mask for ip, mask in zip(ip_octets, mask_octets)] return \'.\'.join(map(str, network_address_octets)) def get_broadcast_address(ipv4_address: str, subnet_mask: str) -> str: Returns the broadcast address given an IPv4 address and a subnet mask. ip_octets = list(map(int, ipv4_address.split(\'.\'))) mask_octets = list(map(int, subnet_mask.split(\'.\'))) broadcast_address_octets = [(ip | (255 - mask)) for ip, mask in zip(ip_octets, mask_octets)] return \'.\'.join(map(str, broadcast_address_octets))"},{"question":"# Problem Statement You are given a string consisting of lowercase alphabetical characters. Your task is to implement a function `first_unique_character(s: str) -> int` that finds the index of the first non-repeating character in the string. If there is no such character, return -1. Input and Output Formats: * **Input**: - `s`: A string of lowercase alphabetical characters. * **Output**: - Returns an integer representing the index of the first non-repeating character, or -1 if there is no such character. Constraints: * The string may contain between 1 to 10^5 characters. Example: 1. `first_unique_character(\\"leetcode\\")` should return `0`. - Explanation: The first non-repeating character is \'l\' which is at index 0. 2. `first_unique_character(\\"loveleetcode\\")` should return `2`. - Explanation: The first non-repeating character is \'v\' which is at index 2. 3. `first_unique_character(\\"aabb\\")` should return `-1`. - Explanation: There is no non-repeating character. Use these test cases to verify the accuracy of your implementation.","solution":"def first_unique_character(s: str) -> int: from collections import Counter # Create a counter for all characters in the string char_count = Counter(s) # Iterate through the string and find the first character with count 1 for idx, char in enumerate(s): if char_count[char] == 1: return idx # If no unique character found, return -1 return -1"},{"question":"# Product Array Puzzle You are tasked with writing a function that generates a product array such that each element at index `i` of the product array is equal to the product of all elements in the input array except the one at `i`. However, you are not allowed to use division to solve this problem. Input Format - A list of integers, `arr`, containing `n` elements where `1 <= n <= 10^4`. Output Format - A list of integers representing the product array. Constraints - The input array can contain both positive and negative numbers but will not contain zero. - The length of the input array will be at least 1 and at most 10,000. Example ```python def product_array(arr: List[int]) -> List[int]: # Implement the product array logic pass # Example Usage: print(product_array([1, 2, 3, 4, 5])) # Expected output: [120, 60, 40, 30, 24] print(product_array([-1, 1, 0, -3, 3])) # Expected output: Function will handle but won\'t include the zero edge case here. ``` Implementation Details 1. **Edge Case Handling**: Ensure the function handles arrays with only one element (should return [1]). 2. **Product Calculation**: - Create two lists, `left_products` and `right_products`. `left_products[i]` should be the product of all elements to the left of index `i`, and `right_products[i]` should be the product of all elements to the right of index `i`. - Initialize `left_products` with the product details moving from left to right. - Initialize `right_products` with the product details moving from right to left. 3. **Result Calculation**: - Construct the result array by multiplying the corresponding values from `left_products` and `right_products`. Note: Raise appropriate errors if the constraints are not met or if the input is invalid.","solution":"from typing import List def product_array(arr: List[int]) -> List[int]: Generates a product array such that each element at index `i` of the product array is equal to the product of all elements in the input array except the one at `i`. n = len(arr) if n == 1: return [1] left_products = [1] * n right_products = [1] * n result = [1] * n # Fill left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right_products array for j in range(n - 2, -1, -1): right_products[j] = right_products[j + 1] * arr[j + 1] # Calculate result array for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"**Custom Linked List Implementation** You are required to implement a custom singly-linked list data structure with the following functionalities: insertion at the head, insertion at the tail, deletion of a specific value, and traversal of the list to return all elements as a list. # Class Definition: ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next class MyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value: int) -> None: pass def insert_at_tail(self, value: int) -> None: pass def delete_value(self, value: int) -> None: pass def traverse(self) -> list: pass ``` # Method Descriptions: - `__init__`: Initializes an empty linked list. - `insert_at_head(value: int) -> None`: Inserts a new node with the specified value at the head of the list. - `insert_at_tail(value: int) -> None`: Inserts a new node with the specified value at the tail of the list. - `delete_value(value: int) -> None`: Deletes the first occurrence of a node with the given value from the list. If the value does not exist, the list remains unchanged. - `traverse() -> list`: Returns a list of all values in the linked list in order. # Constraints: - Values in the linked list are integers. - The values inserted or deleted are within the range of a 32-bit signed integer. # Example: ```python linked_list = MyLinkedList() linked_list.insert_at_head(1) linked_list.insert_at_tail(2) linked_list.insert_at_tail(3) linked_list.delete_value(2) print(linked_list.traverse()) # Returns [1, 3] linked_list.insert_at_head(4) print(linked_list.traverse()) # Returns [4, 1, 3] linked_list.delete_value(4) print(linked_list.traverse()) # Returns [1, 3] ``` # Notes: - You should handle edge cases like deleting from an empty list or inserting values into an initially empty list. - Ensure the methods have efficient implementations to handle scenarios where the linked list may be long.","solution":"class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next class MyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value: int) -> None: new_node = ListNode(value) new_node.next = self.head self.head = new_node def insert_at_tail(self, value: int) -> None: new_node = ListNode(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_value(self, value: int) -> None: current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next return prev = current current = current.next def traverse(self) -> list: elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"# Task You are provided with a data parsing function that processes a list of dictionaries representing user information. Your task is to enhance this function to validate the user data based on specified criteria and return a filtered list of valid user entries. # User Data Validation Criteria: 1. Each user dictionary must contain \'name\', \'age\', and \'email\' keys. 2. The \'name\' value must be a non-empty string. 3. The \'age\' value must be an integer between 18 and 99 inclusive. 4. The \'email\' value must contain the \'@\' symbol and a domain name. # Implementation: * Modify the `parse_user_data` function to perform the above validations. * Return a list of valid user dictionaries. * If any validation fails, exclude that user from the result. # Input and Output: * Input: A list of dictionaries, where each dictionary contains keys \'name\', \'age\', and \'email\'. * Output: A filtered list of user dictionaries that meet the validation criteria. # Example ```python # Sample user data user_data = [ {\\"name\\": \\"Alice\\", \\"age\\": 28, \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"\\", \\"age\\": 22, \\"email\\": \\"bob@example.com\\"}, {\\"name\\": \\"Carol\\", \\"age\\": 17, \\"email\\": \\"carol@example\\"}, {\\"name\\": \\"Dave\\", \\"age\\": 35, \\"email\\": \\"dave@example.com\\"}, {\\"name\\": \\"Eve\\", \\"age\\": \\"forty\\", \\"email\\": \\"eve@example.com\\"} ] # Function to parse and validate user data def parse_user_data(user_list): valid_users = [] for user in user_list: if ( \'name\' in user and isinstance(user[\'name\'], str) and user[\'name\'] and \'age\' in user and isinstance(user[\'age\'], int) and 18 <= user[\'age\'] <= 99 and \'email\' in user and isinstance(user[\'email\'], str) and \'@\' in user[\'email\'] ): valid_users.append(user) return valid_users # Get filtered valid user data valid_user_data = parse_user_data(user_data) print(\\"Valid User Data:\\") print(valid_user_data) ``` # Constraints: - Assume the input list contains dictionaries where keys might be missing or contain invalid data types. - Ensure that the function is robust and can handle unexpected input gracefully. Implement the `parse_user_data` function as described and ensure it meets the specified validation criteria. Test your implementation with various test cases to confirm its correctness.","solution":"def parse_user_data(user_list): valid_users = [] for user in user_list: if ( \'name\' in user and isinstance(user[\'name\'], str) and user[\'name\'] and \'age\' in user and isinstance(user[\'age\'], int) and 18 <= user[\'age\'] <= 99 and \'email\' in user and isinstance(user[\'email\'], str) and \'@\' in user[\'email\'] ): valid_users.append(user) return valid_users"},{"question":"# Problem Statement Given a binary tree, write a function to compute the average value of the nodes on each level. The binary tree is represented using a TreeNode class, where each node contains an integer value and pointers to its left and right children. # Function Signature ```python def level_averages(root: TreeNode) -> List[float]: pass ``` # Input * `root`: The root node of a binary tree (`0 <= number of nodes <= 10^5`, `-10^9 <= node.val <= 10^9`). # Output * Return a list of floating-point numbers, where each number represents the average value of the nodes at that level from the root down to the leaves. The result should be ordered from the root level to the deepest level. # Constraints 1. You must solve the problem with a time complexity of O(n) and a space complexity of O(n), where n is the number of nodes in the tree. 2. Handle edge cases such as an empty tree, a tree with only one node, and trees with nodes having negative or zero values. # Example ```python # Example 1 # Input: # 3 # / # 9 20 # / # 15 7 # Output: [3.0, 14.5, 11.0] # Example 2 # Input: # 1 # / # 2 3 # / # 4 5 6 # Output: [1.0, 2.5, 5.0] class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Description 1. Traverse the binary tree level by level. 2. Track the sum of values and count of nodes at each level. 3. Calculate the average value for each level. 4. Ensure to handle edge cases such as an empty tree and diverse node values effectively.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_averages(root: Optional[TreeNode]) -> List[float]: if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_sum = 0 level_count = 0 next_queue = deque() while queue: node = queue.popleft() level_sum += node.val level_count += 1 if node.left: next_queue.append(node.left) if node.right: next_queue.append(node.right) result.append(level_sum / level_count) queue = next_queue return result"},{"question":"**Word Frequency in Text Analysis** Your task is to develop a function that finds the most frequent word in a given text file. The function should return the word and its frequency count. Ensure that your solution handles various punctuation marks and ignores case sensitivity. # Function Signature ```python def most_frequent_word_in_file(file_path: str) -> Tuple[str, int]: pass ``` # Input - `file_path` (string): The path to the text file. # Output - A tuple containing the most frequent word and its frequency count. - Return `None` if the file is empty or contains no valid words. # Constraints - The text file may contain any printable characters, including punctuation marks. - Assume the text file fits into available memory. - Treat words as case-insensitive (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). - Ignore punctuation and consider words as sequences of alphanumeric characters. - In case of a tie (multiple words with the same frequency), return the lexicographically smallest word. # Example - For a text file containing: \\"Hello, world! Hello world.\\" - The function should return `(\\"hello\\", 2)`. # Performance Requirements - The solution should handle large files efficiently by processing the text in an optimal way. - Ensure that the function reads from a file and identifies word frequencies correctly while handling edge cases as specified. # Scenario/Context You are developing a text analysis tool used in a content management system. This function will be crucial in identifying important keywords in documents, aiding in search engine optimization (SEO) tasks, and improving content recommendations. --- Note: The code required to read the file and process its contents is straightforward for a user familiar with basic file I/O operations in Python. The focus should be on correct text parsing, counting, and handling ties appropriately.","solution":"import re from collections import Counter from typing import Tuple, Optional def most_frequent_word_in_file(file_path: str) -> Optional[Tuple[str, int]]: Finds the most frequent word in a given text file. :param file_path: Path to the text file :return: Tuple containing the most frequent word and its frequency count Return None if the file is empty or contains no valid words with open(file_path, \'r\') as file: text = file.read().lower() # Extract words ignoring punctuation words = re.findall(r\'bw+b\', text) if not words: return None # Count word frequencies using Counter word_counts = Counter(words) # Find the word with the highest frequency most_common_word, freq = word_counts.most_common(1)[0] return (most_common_word, freq)"},{"question":"# Coding Assessment Question **Problem Context**: You have been given the task to design a system for tracking a user\'s daily step count using a pedometer. One of the requirements is to calculate different statistics such as the total number of steps, average steps per day, the maximum steps in a day, and the minimum steps in a day over a given period. **Task**: Implement a class `Pedometer` with the following methods to manage and analyze the step counts: 1. `add_steps(date: str, steps: int) -> None`: Adds the step count for a specific date. 2. `total_steps() -> int`: Calculates and returns the total number of steps recorded. 3. `average_steps() -> float`: Calculates and returns the average steps per day. 4. `max_steps() -> int`: Retrieves the maximum steps recorded in a day. 5. `min_steps() -> int`: Retrieves the minimum steps recorded in a day. 6. `steps_on_date(date: str) -> int`: Retrieves the steps recorded on a given date. **Class Signature**: ```python class Pedometer: def __init__(self): pass def add_steps(self, date: str, steps: int) -> None: pass def total_steps(self) -> int: pass def average_steps(self) -> float: pass def max_steps(self) -> int: pass def min_steps(self) -> int: pass def steps_on_date(self, date: str) -> int: pass ``` **Constraints**: 1. Dates are provided in the format \\"YYYY-MM-DD\\". 2. The function `add_steps` may be called multiple times for the same date. In such a case, steps should be aggregated. 3. Handle scenarios with no recorded steps appropriately. 4. Validate input formats and handle incorrect inputs gracefully. **Input Format**: - A series of date and step count pairs for `add_steps`. - Method calls to compute and return the required statistics. **Output Format**: - Results for statistics methods as outlined above. **Example**: ```python pedometer = Pedometer() pedometer.add_steps(\'2023-04-01\', 5000) pedometer.add_steps(\'2023-04-02\', 7000) pedometer.add_steps(\'2023-04-01\', 3000) print(pedometer.total_steps()) # Output: 15000 print(pedometer.average_steps()) # Output: 7500.0 print(pedometer.max_steps()) # Output: 7000 print(pedometer.min_steps()) # Output: 8000 print(pedometer.steps_on_date(\'2023-04-01\')) # Output: 8000 print(pedometer.steps_on_date(\'2023-04-03\')) # Output: ValueError: No steps recorded for the provided date ``` **Additional Task**: - Implement error handling for invalid date formats and non-numeric step inputs. **Performance Requirements**: - Ensure the class methods operate efficiently even for large datasets.","solution":"class Pedometer: def __init__(self): self.step_data = {} def add_steps(self, date: str, steps: int) -> None: if not self._validate_date(date) or not isinstance(steps, int): raise ValueError(\\"Invalid date format or non-integer steps value\\") if date in self.step_data: self.step_data[date] += steps else: self.step_data[date] = steps def total_steps(self) -> int: return sum(self.step_data.values()) def average_steps(self) -> float: if not self.step_data: return 0.0 return sum(self.step_data.values()) / len(self.step_data) def max_steps(self) -> int: if not self.step_data: return 0 return max(self.step_data.values()) def min_steps(self) -> int: if not self.step_data: return 0 return min(self.step_data.values()) def steps_on_date(self, date: str) -> int: if not self._validate_date(date): raise ValueError(\\"Invalid date format\\") if date not in self.step_data: raise ValueError(\\"No steps recorded for the provided date\\") return self.step_data[date] def _validate_date(self, date: str) -> bool: from datetime import datetime try: datetime.strptime(date, \'%Y-%m-%d\') return True except ValueError: return False"},{"question":"# Coding Assessment Question: Scenario: You are developing an application to manage a library\'s book collection. Each book can have several attributes like title, author, genre, and publication year. Occasionally, the library needs to search for books matching a specific set of attributes. Your task is to implement a function that filters books based on given search criteria and returns the list of books that match all the specified attributes. # Function Signature: ```python def filter_books(library: List[Dict[str, str]], criteria: Dict[str, str]) -> List[Dict[str, str]]: pass ``` # Input: * `library` (List[Dict[str, str]]): A list of dictionaries where each dictionary represents a book with attributes like `title`, `author`, `genre`, and `year`. * `criteria` (Dict[str, str]): A dictionary of attributes to filter the books. The keys are attribute names and the values are the corresponding values to match. # Output: * A list of dictionaries representing the books that match all the specified criteria. # Example: ```python library = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": \\"1949\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Fiction\\", \\"year\\": \\"1960\\"}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\", \\"year\\": \\"1925\\"}, {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"genre\\": \\"Dystopian\\", \\"year\\": \\"1932\\"} ] criteria = {\\"genre\\": \\"Fiction\\", \\"author\\": \\"Harper Lee\\"} assert filter_books(library, criteria) == [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Fiction\\", \\"year\\": \\"1960\\"} ] ``` # Constraints: * Each book dictionary will have the same set of keys: `title`, `author`, `genre`, and `year`. * The `criteria` dictionary will only contain valid keys that exist in the book dictionaries. * `library` will have at most 1000 books. * `criteria` will have at most 4 attributes. # Performance Requirements: * Ensure your solution efficiently filters the list of up to 1000 books based on the given criteria. Implementation: Write the function `filter_books` that takes a list of book dictionaries and a dictionary of search criteria, and returns a list of dictionaries representing the books that match all the specified criteria.","solution":"from typing import List, Dict def filter_books(library: List[Dict[str, str]], criteria: Dict[str, str]) -> List[Dict[str, str]]: Filters the library books based on the provided criteria. Parameters: - library: List of dictionaries where each dictionary represents a book with attributes \'title\', \'author\', \'genre\', and \'year\'. - criteria: Dictionary of attributes to filter the books. The keys are attribute names and the values are the corresponding values to match. Returns: - List of dictionaries representing the books that match all the specified criteria. return [book for book in library if all(book.get(key) == value for key, value in criteria.items())]"},{"question":"# Coding Question: Merge Two Sorted Linked Lists **Scenario**: You are tasked with developing a module for merging two sorted linked lists into a single sorted linked list. This functionality is crucial for a system that deals with sorted sequences of data, ensuring smooth and efficient consolidation operations. **Problem Statement**: Implement a method `merge_sorted_lists` within the LinkedList class that merges two sorted linked lists and returns the head of the new sorted linked list. # Requirements: - **Input**: - Two singly linked lists represented by their head nodes of type `Node`. - **Output**: - The head node of a new, merged, and sorted linked list. # Constraints: 1. Each linked list is sorted in ascending order. 2. The merged linked list should also be sorted in ascending order. 3. Optimize for time complexity (aim for an O(n + m) solution, where n and m are the lengths of the two linked lists). # Function Signature: ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def merge_sorted_lists(self, l1: Node, l2: Node) -> Node: pass ``` # Implementation in the LinkedList Class: Your implementation should handle various cases robustly, including: - Both lists being empty. - One list being empty. - Two lists with different lengths. # Examples: 1. **Example 1**: ```python # Linked list 1: 1 -> 3 -> 5 head1 = Node(1) head1.next = Node(3) head1.next.next = Node(5) # Linked list 2: 2 -> 4 -> 6 head2 = Node(2) head2.next = Node(4) head2.next.next = Node(6) ll = LinkedList() # Merged linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 merged_head = ll.merge_sorted_lists(head1, head2) ``` 2. **Example 2**: ```python # Linked list 1: 1 -> 2 -> 4 head1 = Node(1) head1.next = Node(2) head1.next.next = Node(4) # Linked list 2: 1 -> 3 -> 4 head2 = Node(1) head2.next = Node(3) head2.next.next = Node(4) ll = LinkedList() # Merged linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 merged_head = ll.merge_sorted_lists(head1, head2) ``` **Note**: Consider using an iterative approach to merge the lists efficiently, maintaining the order by comparing nodes from each list and linking them appropriately.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def merge_sorted_lists(self, l1: Node, l2: Node) -> Node: dummy = Node(0) # Dummy node to maintain the head of the merged list current = dummy # Pointer to construct the new list # Traverse both lists and append the smaller value node to the new list while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # One of the lists might still have remaining nodes, append them if l1: current.next = l1 if l2: current.next = l2 return dummy.next # The merged list starts from the next node of the dummy node"},{"question":"# Coding Assessment Question Objective: Implement a function to determine all possible permutations of k elements from a given list, where k ranges between 1 and n, inclusive. The function must efficiently generate these permutations ensuring optimal time and space usage. Problem Statement: You are given a list of integers and an integer k. Your task is to implement a function that returns all possible permutations of exactly k elements from the input list. Function Signature: ```python def generate_permutations(elements: list[int], k: int) -> list: Args: elements: List of integers from which permutations will be generated. k: Size of each permutation. Returns: List of tuples, each representing a permutation of k elements. ``` Inputs: - elements: A list of integers (1 <= len(elements) <= 10) - k: An integer representing the size of each permutation. (1 <= k <= len(elements)) Outputs: - A list of tuples with all possible permutations of k elements from the list. Constraints: - The elements of the list will be unique. - The elements and k are guaranteed to be within the constraints. Example: ```python # Example 1: elements = [1, 2, 3] k = 2 # Output: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] # Example 2: elements = [1, 2, 3, 4] k = 3 # Output: [(1, 2, 3), (1, 2, 4), (1, 3, 2), (1, 3, 4), (1, 4, 2), (1, 4, 3), # (2, 1, 3), (2, 1, 4), (2, 3, 1), (2, 3, 4), (2, 4, 1), (2, 4, 3), # (3, 1, 2), (3, 1, 4), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2), # (4, 1, 2), (4, 1, 3), (4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)] ``` Note: 1. The function should generate permutations in any order. 2. Ensure to handle varying sizes of the input. 3. Consider efficient memory usage and time performance, especially for upper-bound values of inputs.","solution":"from itertools import permutations def generate_permutations(elements, k): Returns all possible permutations of `k` elements from the list `elements`. Args: elements: List of integers from which permutations will be generated. k: Size of each permutation. Returns: List of tuples, each representing a permutation of k elements. return list(permutations(elements, k))"},{"question":"# Problem Description You have been given the task of developing a new system to evaluate the quality of fruits based on their size and weight. The current system categorizes a fruit as \\"Good\\", \\"Average\\", or \\"Poor\\" based on its characteristics. Your objective is to write a function that validates the inputs, checks them against a set of rules, and returns the appropriate category. # Function to Implement Write a Python function `evaluate_fruit(size: float, weight: float) -> str:` that: 1. Ensures the input values are valid: * Size should be a positive number. * Weight should also be a positive number. 2. If the input values are invalid: * Return a specific string message describing the error. 3. If the inputs are valid: * Return a category based on the following rules: * \\"Good\\" if size > 15 and weight > 200. * \\"Average\\" if size > 10 and weight > 100. * \\"Poor\\" otherwise. # Example ```python def evaluate_fruit(size: float, weight: float) -> str: # Your implementation here # Example Usage print(evaluate_fruit(16, 250)) # Expected: \\"Good\\" print(evaluate_fruit(11, 150)) # Expected: \\"Average\\" print(evaluate_fruit(9, 80)) # Expected: \\"Poor\\" print(evaluate_fruit(-5, 150)) # Expected: \\"Error: Size should be a positive number\\" print(evaluate_fruit(12, -60)) # Expected: \\"Error: Weight should be a positive number\\" ``` # Input * `size` (float): The size of the fruit, should be a positive number. * `weight` (float): The weight of the fruit, should be a positive number. # Output * If the input is invalid, the function should return a string in one of the following formats: * \\"Error: Size should be a positive number\\" * \\"Error: Weight should be a positive number\\" * If the input is valid, the function should return one of the following based on the rules: * \\"Good\\" * \\"Average\\" * \\"Poor\\" # Constraints * Ensure that size and weight are properly validated. * The function should handle edge cases efficiently. * The function should perform the validation and categorization in (O(1)) time.","solution":"def evaluate_fruit(size: float, weight: float) -> str: if size <= 0: return \\"Error: Size should be a positive number\\" if weight <= 0: return \\"Error: Weight should be a positive number\\" if size > 15 and weight > 200: return \\"Good\\" elif size > 10 and weight > 100: return \\"Average\\" else: return \\"Poor\\""},{"question":"# Schedule Conflict Detector You work at a tech firm where multiple employees need to reserve conference rooms for meetings. Occasionally, employees accidentally book overlapping meetings. Your task is to create a function to detect schedule conflicts. # Task Write a function `schedule_conflict(schedule: List[Tuple[int, int]]) -> bool` that: 1. Takes in a list of tuples, `schedule`, where each tuple consists of two integers `[start, end]` representing the start and end times of a meeting. 2. Returns `True` if there is any overlap between any meetings in the schedule, and `False` otherwise. **Function Signature:** ```python from typing import List, Tuple def schedule_conflict(schedule: List[Tuple[int, int]]) -> bool: ``` Input - A list of tuples `schedule`, where each tuple `(start, end)` represents a meeting\'s start time and end time (inclusive). Output - A boolean value `True` if there is an overlap in the meetings, otherwise `False`. Constraints - All start and end times will be between `0` and `24`. - The end time of a meeting is always greater than the start time. # Scenario For example: - `schedule_conflict([(1, 3), (2, 4), (8, 10)])` should return `True` because the first two meetings overlap. - `schedule_conflict([(1, 2), (3, 4), (5, 6)])` should return `False` as there are no overlaps. - `schedule_conflict([(9, 10), (10, 11), (11, 12)])` should return `False` because consecutive meetings do not overlap. # Example ```python print(schedule_conflict([(9, 10), (10, 11), (11, 12)])) # False print(schedule_conflict([(1, 3), (2, 4), (8, 10)])) # True ``` Your task is to implement the `schedule_conflict` function as defined above.","solution":"from typing import List, Tuple def schedule_conflict(schedule: List[Tuple[int, int]]) -> bool: This function checks if there is any overlapping between the given schedule of meetings. :param schedule: List of meeting start and end times :type schedule: List[Tuple[int, int]] :return: boolean indicating if there\'s any overlap :rtype: bool # Sort the schedule by start time schedule.sort() # Iterate through the schedule to detect any overlap for i in range(len(schedule) - 1): start_current, end_current = schedule[i] start_next, _ = schedule[i + 1] # If the current meeting\'s end time is greater than the next meeting\'s start time, there\'s a conflict if end_current > start_next: return True return False"},{"question":"# Scenario Imagine you are currently working on a system that manages real-time sensor data streams from various devices. These sensors periodically send their data (such as temperature readings) to your system, and you need to process this data efficiently to generate meaningful insights. One common task is to compute the moving average over a sliding window of recent readings. # Task Design and implement a data structure to maintain a list of the last `n` temperature readings from a sensor and efficiently compute the moving average whenever a new reading is added. # Specifications 1. **Input:** * **Window Size:** An integer `n` representing the size of the sliding window. * **Readings:** A list of integer temperature readings received in sequence. 2. **Output:** * A list of moving averages, where each value corresponds to the average of the most recent `n` readings at that point. If there are fewer than `n` readings, compute the average of all available readings. # Example ```python window_size = 3 readings = [2, 4, 6, 8, 10] # The moving averages should be computed as follows: # window = [2] -> average = 2 # window = [2, 4] -> average = 3 # window = [2, 4, 6] -> average = 4 # window = [4, 6, 8] -> average = 6 # window = [6, 8, 10] -> average = 8 result = moving_averages(window_size, readings) print(result) # Output should be [2, 3, 4, 6, 8] ``` # Constraints * 1 ≤ n ≤ 10,000 * 1 ≤ len(readings) ≤ 100,000 * -100 ≤ temperature reading ≤ 100 # Requirements 1. Implement a function `moving_averages(window_size, readings)` that takes in the window size `n` and the list of temperature readings. 2. Ensure that your implementation returns the correct moving averages efficiently as new readings are added. 3. Handle edge cases such as when `n` is greater than the length of the readings list, ensuring correct average calculations. 4. Prioritize time and space efficiency to manage potentially large input sizes. # Note Consider using a queue or deque data structure to maintain the window of the last `n` readings and efficiently compute the moving average as readings are added.","solution":"from collections import deque def moving_averages(window_size, readings): Computes the moving average over a sliding window of recent readings. Args: window_size (int): The size of the sliding window. readings (list of int): List of temperature readings. Returns: list of float: List of moving averages. if window_size <= 0: raise ValueError(\\"Window size must be greater than 0\\") window = deque() current_sum = 0 averages = [] for reading in readings: window.append(reading) current_sum += reading if len(window) > window_size: current_sum -= window.popleft() averages.append(current_sum / len(window)) return averages"},{"question":"# Problem: Movie Database API Enhancement You are working on a function that interacts with a movie database API to retrieve information about movies. The API provides data such as movie title, release year, director, and genres. Your task is to enhance this function to introduce the following improvements: 1. **Error Handling**: Add comprehensive error handling to manage potential request failures, network issues, or changes in the API responses. 2. **Pagination Handling**: Modify the function to handle paginated API responses to ensure it fetches all available data. 3. **Data Validation**: Ensure the solution includes proper data validation to confirm that the received data is in the expected format. # Input - `api_endpoint` (string): The base URL of the movie database API. - `query` (string): The search query to find movies (e.g., \\"Inception\\"). # Output - A list of dictionaries, each dictionary containing details of a movie such as title, release year, director, and genres. # Constraints - Ensure the function handles network failures gracefully. - The function should properly handle paginated responses to collect all results. - Validate each movie\'s data to confirm it adheres to the expected format. # Example Usage ```python api_endpoint = \\"https://api.themoviedb.org/3/search/movie\\" query = \\"Inception\\" result = fetch_movie_data(api_endpoint, query) print(result) # Expected output: [ # { # \\"title\\": \\"Inception\\", # \\"release_year\\": 2010, # \\"director\\": \\"Christopher Nolan\\", # \\"genres\\": [\\"Action\\", \\"Sci-Fi\\", \\"Thriller\\"] # }, # // More movies that match the search query # ] ``` # Implementation Tips - Use `try-except` blocks to handle network and parsing errors. - Handle pagination by checking the API response for pagination details and recursively fetching additional pages. - Ensure you validate each piece of data (e.g., title should be a string, release year should be an integer) before adding it to the final result.","solution":"import requests def fetch_movie_data(api_endpoint, query): Fetch all movie data matching the query from the given API endpoint, handling pagination and performing data validation on the results. Args: api_endpoint (str): The base URL of the movie database API. query (str): The search query to find movies. Returns: list: A list of dictionaries containing details of movies that match the query. results = [] page = 1 while True: try: response = requests.get(api_endpoint, params={\'query\': query, \'page\': page}) response.raise_for_status() except requests.exceptions.RequestException as e: print(f\\"Request failed: {e}\\") return [] data = response.json() # Validate the response contains the expected data if \'results\' not in data or not isinstance(data[\'results\'], list): print(\\"Invalid response format\\") return [] for movie in data[\'results\']: if all(key in movie for key in [\\"title\\", \\"release_date\\", \\"director\\", \\"genre_ids\\"]): try: title = movie[\\"title\\"] release_year = int(movie[\\"release_date\\"][:4]) director = movie[\\"director\\"] genres = movie[\\"genre_ids\\"] if isinstance(title, str) and isinstance(release_year, int) and isinstance(director, str) and isinstance(genres, list): results.append({ \\"title\\": title, \\"release_year\\": release_year, \\"director\\": director, \\"genres\\": genres }) except (ValueError, TypeError): print(f\\"Invalid data for movie: {movie}\\") continue if \'total_pages\' in data and page < data[\'total_pages\']: page += 1 else: break return results"},{"question":"# Problem Statement You are given a string containing lowercase Latin letters. Your task is to determine if it is possible to rearrange the letters of the string to form a palindrome. If it is possible, print \\"YES\\", otherwise print \\"NO\\". # Function Signature ```python def can_form_palindrome(s: str) -> str: pass ``` # Input Format * A single string `s` containing only lowercase Latin letters. # Output Format * Print \\"YES\\" if the letters of the string can be rearranged to form a palindrome, otherwise print \\"NO\\". # Constraints * The length of the string will not exceed 1000 characters. # Example Example 1 Input: ``` civic ``` Output: ``` YES ``` Example 2 Input: ``` ivicc ``` Output: ``` YES ``` Example 3 Input: ``` hello ``` Output: ``` NO ``` # Notes * A palindrome is a word that reads the same forwards and backwards, such as \\"racecar\\" or \\"level\\". * For a string to be rearrangeable into a palindrome, at most one character in the string can have an odd count. All other characters must have even counts. * Edge cases to consider include strings with length 1, which are always palindromes, and strings that are already palindromes.","solution":"from collections import Counter def can_form_palindrome(s: str) -> str: Determines if the letters of the string can be rearranged to form a palindrome. :param s: The input string containing only lowercase Latin letters. :return: \\"YES\\" if it can be rearranged to form a palindrome, otherwise \\"NO\\". # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be able to form a palindrome # there can be at most one character with an odd frequency if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"# Question: Implementing Merge Sort in Python **Scenario:** You have been tasked with implementing a well-known sorting algorithm, Merge Sort, which is particularly efficient for large datasets because of its O(n log n) time complexity. Unlike quick sort, merge sort is a stable sort and works well with linked lists and large datasets stored in external storage. **Task:** Implement a function `merge_sort` that sorts a given list of integers in ascending order using the Merge Sort algorithm. Your implementation should follow the divide-and-conquer paradigm, recursively splitting the list and merging the sorted sublists. **Function Signature:** ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` **Input:** - `arr` (List[int]): A list of integers that needs to be sorted. **Output:** - (List[int]): A new list containing the sorted integers from the original list. **Constraints:** - The elements in the list can be negative, zero, or positive. - The list can contain duplicate elements. **Example:** ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] ``` **Explanation:** Your function `merge_sort` should: 1. Split the list into two halves. 2. Recursively sort both halves. 3. Merge the two sorted halves into a single sorted list. 4. Return the sorted list.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Matrix Transposition Background Transposing a matrix involves flipping it over its diagonal, switching the row and column indices of the elements. This operation is critical in various computational tasks including graphics transformations and solving linear equations. Task Implement a function `transpose_matrix` that takes a two-dimensional list (matrix) and returns its transpose. Requirements 1. The input will be a non-empty matrix with `R` rows and `C` columns, represented as a list of lists. 2. The output should be a new matrix with `C` rows and `R` columns where the element at position `(i, j)` in the original matrix is at position `(j, i)` in the transposed matrix. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` Parameters * `matrix`: A list of lists representing the matrix to be transposed. Each sublist represents a row in the matrix. Constraints * The number of columns `C` in each row will be the same. * The matrix will have at least one element. Example Usage ```python # Transpose a 2x3 matrix result = transpose_matrix([[1, 2, 3], [4, 5, 6]]) print(result) # Output: [[1, 4], [2, 5], [3, 6]] # Transpose a 3x3 identity matrix result = transpose_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) print(result) # Output: [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Transpose a 1x4 matrix result = transpose_matrix([[1, 2, 3, 4]]) print(result) # Output: [[1], [2], [3], [4]] ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. Parameters: matrix (List[List[int]]): A list of lists representing the matrix to be transposed. Returns: List[List[int]]: The transposed matrix. # Use the zip function combined with * operator to unpack the lists in matrix return [list(row) for row in zip(*matrix)]"},{"question":"# Meeting Scheduler Challenge Objective You are required to implement a function that determines the optimal meeting time that maximizes participation based on the availability of participants. Given a list of participants, each with a list of available time slots, find the time slot with the highest participation. If multiple slots have the same maximum participation, return the earliest one. Function Signature ```python def find_optimal_meeting_time(participants: list[list[str]]) -> str: pass ``` Inputs * List of lists `participants`, where each list represents a set of available times (as strings in \\"HH:MM\\" 24-hour format) for a participant. Outputs * Return a string in \\"HH:MM\\" format representing the time slot with the highest number of participants. If multiple slots have the same maximum participation, return the earliest one. Constraints * (1 leq text{len(participants)} leq 50) * Each participant has (1 leq text{len(times)} leq 10) * Time slots are in \\"HH:MM\\" 24-hour format and are valid times within a single day (00:00 to 23:59). Contextual Example Consider the following availability schedules: ```python participants = [ [\\"09:00\\", \\"13:00\\", \\"15:00\\"], [\\"09:00\\", \\"11:00\\", \\"13:00\\"], [\\"09:00\\", \\"12:00\\", \\"13:00\\"] ] ``` The optimal meeting time would be \\"09:00\\" since all three participants are available at that time. # Requirements * Parse and compare time slots to find the one with maximum overlap. * Return the time slot with the highest participation, ensuring to return the earliest if ties exist. Example ```python participants = [ [\\"09:00\\", \\"13:00\\", \\"15:00\\"], [\\"09:00\\", \\"11:00\\", \\"13:00\\"], [\\"09:00\\", \\"12:00\\", \\"13:00\\"] ] ``` Output: ```python \\"09:00\\" # All three participants are available ``` ```python participants = [ [\\"10:00\\", \\"11:00\\", \\"12:00\\"], [\\"11:00\\", \\"12:00\\", \\"13:00\\"], [\\"10:00\\", \\"11:00\\", \\"15:00\\"] ] ``` Output: ```python \\"11:00\\" # Maximum participation at \\"11:00\\" with two participants available ``` # Constraints & Hints * Ensure the time slots are parsed accurately for comparison. * Use a dictionary or similar data structure to count occurrences of each time slot. * Consider using efficient time comparison techniques to handle large input sizes effectively. Good luck with implementing the optimal meeting scheduler function!","solution":"def find_optimal_meeting_time(participants: list[list[str]]) -> str: from collections import Counter time_count = Counter() for participant in participants: time_count.update(participant) # Determine the time slot with the maximum participation max_participation = max(time_count.values()) optimal_times = [time for time, count in time_count.items() if count == max_participation] # Return the earliest time slot if multiple time slots have the same max participation return min(optimal_times)"},{"question":"# Problem Statement You work for an e-commerce platform that processes customer orders. One of the requirements is to implement a functionality to parse and validate promotional offer codes that customers apply during checkout. The platform supports three types of promotional offers: percentage discounts, flat rate discounts, and buy-one-get-one-free (BOGO). Your task is to complete the `apply_promo_code` function and ensure that it: 1. Validates the promotional offer code to check if it is correctly formatted. 2. Applies the valid promotional offer to the order total. # Implementation and Constraints 1. **Function Signature**: ```python def apply_promo_code(order_total: float, promo_code: str) -> float: ``` 2. **Inputs**: - **order_total** (`float`): The original total amount of the order. - **promo_code** (`str`): The promotional offer code string to be processed. 3. **Outputs**: - Returns a float representing the new total amount after applying the promotional offer. 4. **Constraints**: - **Percentage Discount**: Promotional code format is \\"PERCENT_xx%\\" where \\"xx\\" is a numeric value between 1 and 99 (inclusive). - **Flat Rate Discount**: Promotional code format is \\"FLAT_xx\\" where \\"xx\\" is a numeric value representing the discount amount in the same currency as the order total. - **BOGO (Buy-One-Get-One-Free)**: Promotional code format is simply \\"BOGO\\". For BOGO, the order total must be at least 20 for the code to apply, and it will apply a 50% discount. - To ensure validity, return the order total unchanged if the promo code is invalid. - Ensure the order total does not fall below zero after applying any discount. # Example Usage ```python # Example 1: apply_promo_code(200.0, \\"PERCENT_20%\\") # Output: 160.0 # 20% discount on 200.0 is 40.0, so new total is 200.0 - 40.0 = 160.0 # Example 2: apply_promo_code(150.0, \\"FLAT_25\\") # Output: 125.0 # Flat discount of 25 on 150.0, so new total is 150.0 - 25.0 = 125.0 # Example 3: apply_promo_code(40.0, \\"BOGO\\") # Output: 20.0 # BOGO discount on 40.0 is 50%, so new total is 40.0 * 0.5 = 20.0 # Example 4: apply_promo_code(40.0, \\"RANDOM_10\\") # Output: 40.0 # Invalid promo code, order total remains the same ``` # Testing - Write additional tests to cover edge cases such as invalid promo codes, order totals resulting in zero, and ensuring the order total does not become negative. - Ensure correct implementation and handle cases where promotional codes are correctly formatted but not applicable.","solution":"def apply_promo_code(order_total: float, promo_code: str) -> float: Applies promotional offers to the order total and returns the new total. The promo_code follows specific formats for different types of discounts. Returns the updated order total or the original order total if the promo code is invalid. if promo_code.startswith(\'PERCENT_\') and promo_code.endswith(\'%\'): try: percent = int(promo_code[8:-1]) if 1 <= percent <= 99: discount = order_total * (percent / 100.0) new_total = order_total - discount return max(new_total, 0.0) except ValueError: return order_total # invalid percentage value elif promo_code.startswith(\'FLAT_\'): try: flat = int(promo_code[5:]) discount = flat new_total = order_total - discount return max(new_total, 0.0) except ValueError: return order_total # invalid flat rate elif promo_code == \'BOGO\': if order_total >= 20: discount = order_total / 2.0 new_total = order_total - discount return max(new_total, 0.0) return order_total # invalid promo code format"},{"question":"# Problem: Data Collection System for Climate Sensors Your task is to design a data collection system that integrates various sensor data into a unified module. The goal is to develop functions for each type of sensor reading, ensuring proper input validation, efficient computation, and proper data formatting. Task Requirements: 1. **Function Signature**: - Implement functions corresponding to each of the following sensor readings: * Temperature * Humidity * Atmospheric Pressure * Wind Speed * Wind Direction * Precipitation * UV Index * Solar Radiation * Soil Moisture * Soil Temperature - The function names should be prefixed with `read_` followed by the sensor type (e.g., `read_temperature`). 2. **Input and Output**: - The sensor reading functions should accept sensor data as `float` values and return a formatted string representing the value. For wind direction, the function should return the string representation (e.g., \\"North\\", \\"Northeast\\"). - If invalid values are provided (e.g., negative values for non-negative sensors), the function should raise a `ValueError` with an appropriate message. 3. **Constraints**: - All inputs must be non-negative floats or integers where applicable. - For wind direction, values must be within the range [0, 360) degrees. - Other sensor-specific constraints should also be checked. 4. **Performance Requirements**: - Ensure that the functions run efficiently and use minimal resources. Example Functions: 1. **Temperature Reading** ```python def read_temperature(value: float) -> str: if value < -273.15: # Lower than absolute zero raise ValueError(\\"read_temperature() received an invalid value\\") return f\\"Temperature: {value:.2f} °C\\" ``` 2. **Humidity Reading** ```python def read_humidity(value: float) -> str: if value < 0 or value > 100: # Humidity percentage must be between 0 and 100 raise ValueError(\\"read_humidity() received an invalid value\\") return f\\"Humidity: {value:.2f} %\\" ``` 3. **Wind Speed Reading** ```python def read_wind_speed(value: float) -> str: if value < 0: raise ValueError(\\"read_wind_speed() received an invalid value\\") return f\\"Wind Speed: {value:.2f} m/s\\" ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct data readings. - Boundary inputs such as zero and maximum valid values. - Invalid inputs like negative values raising appropriate errors. Provide at least one test example for each sensor reading function in the form of `assert` statements to validate their behavior. ```python # Tests assert read_temperature(25.678) == \\"Temperature: 25.68 °C\\" assert read_humidity(45.0) == \\"Humidity: 45.00 %\\" assert read_wind_speed(3.5) == \\"Wind Speed: 3.50 m/s\\" # Edge Cases assert read_temperature(-273.15) == \\"Temperature: -273.15 °C\\" # Invalid Inputs try: read_temperature(-280.0) except ValueError as e: assert str(e) == \\"read_temperature() received an invalid value\\" try: read_humidity(150.0) except ValueError as e: assert str(e) == \\"read_humidity() received an invalid value\\" try: read_wind_speed(-1.0) except ValueError as e: assert str(e) == \\"read_wind_speed() received an invalid value\\" ```","solution":"def read_temperature(value: float) -> str: if value < -273.15: # Lower than absolute zero raise ValueError(\\"read_temperature() received an invalid value\\") return f\\"Temperature: {value:.2f} °C\\" def read_humidity(value: float) -> str: if value < 0 or value > 100: # Humidity percentage must be between 0 and 100 raise ValueError(\\"read_humidity() received an invalid value\\") return f\\"Humidity: {value:.2f} %\\" def read_atmospheric_pressure(value: float) -> str: if value < 0: raise ValueError(\\"read_atmospheric_pressure() received an invalid value\\") return f\\"Atmospheric Pressure: {value:.2f} hPa\\" def read_wind_speed(value: float) -> str: if value < 0: raise ValueError(\\"read_wind_speed() received an invalid value\\") return f\\"Wind Speed: {value:.2f} m/s\\" def read_wind_direction(value: float) -> str: if value < 0 or value >= 360: raise ValueError(\\"read_wind_direction() received an invalid value\\") directions = [\\"North\\", \\"Northeast\\", \\"East\\", \\"Southeast\\", \\"South\\", \\"Southwest\\", \\"West\\", \\"Northwest\\"] index = round(value / 45) % 8 return f\\"Wind Direction: {directions[index]}\\" def read_precipitation(value: float) -> str: if value < 0: raise ValueError(\\"read_precipitation() received an invalid value\\") return f\\"Precipitation: {value:.2f} mm\\" def read_uv_index(value: float) -> str: if value < 0: raise ValueError(\\"read_uv_index() received an invalid value\\") return f\\"UV Index: {value:.2f}\\" def read_solar_radiation(value: float) -> str: if value < 0: raise ValueError(\\"read_solar_radiation() received an invalid value\\") return f\\"Solar Radiation: {value:.2f} W/m²\\" def read_soil_moisture(value: float) -> str: if value < 0 or value > 100: raise ValueError(\\"read_soil_moisture() received an invalid value\\") return f\\"Soil Moisture: {value:.2f} %\\" def read_soil_temperature(value: float) -> str: if value < -273.15: raise ValueError(\\"read_soil_temperature() received an invalid value\\") return f\\"Soil Temperature: {value:.2f} °C\\""},{"question":"# Coding Assessment Question You are tasked with creating a system to track and manage booking reservations for a small hotel. Each room can be booked only once per day, and the system should prevent double bookings. Requirements: 1. Implement a function `add_reservation` that takes a room number and a date and adds a reservation if the room is available on that date. 2. Implement a function `is_available` that takes a room number and a date and returns whether the room is available on that date. 3. Ensure that the system prevents double bookings by checking availability before adding a reservation. # Function Signatures ```python def add_reservation(reservations: dict, room_number: int, date: str) -> bool: Adds a reservation for the given room number on the specified date if available. :param reservations: Dictionary holding the current reservations :param room_number: The number of the room to be reserved :param date: The date for the reservation :return: True if the reservation was added successfully, False otherwise pass def is_available(reservations: dict, room_number: int, date: str) -> bool: Checks if a given room is available on the specified date. :param reservations: Dictionary holding the current reservations :param room_number: The number of the room to check :param date: The date to check availability for :return: True if the room is available, False otherwise pass ``` # Input - A `reservations` dictionary where keys are room numbers and values are sets of dates representing bookings. - An integer `room_number` representing the hotel room number. - A string `date` representing the reservation date in the format \\"YYYY-MM-DD\\". # Output - For `add_reservation`, it should return `True` if the reservation is successful and `False` if the room is already booked on the given date. - For `is_available`, it should return `True` if the room is not booked on the given date and `False` otherwise. # Constraints - The number of rooms is limited (for example, less than 100). - The dates are always valid and in the correct format. - Optimize for both storage and quick access to reservation information. # Example ```python reservations = {} # Adding reservations assert add_reservation(reservations, 101, \\"2023-11-01\\") == True assert add_reservation(reservations, 101, \\"2023-11-01\\") == False assert add_reservation(reservations, 102, \\"2023-11-01\\") == True # Checking availability assert is_available(reservations, 101, \\"2023-11-01\\") == False assert is_available(reservations, 101, \\"2023-11-02\\") == True assert is_available(reservations, 102, \\"2023-11-01\\") == False ``` In the example, `add_reservation` and `is_available` functions manage and check hotel room bookings efficiently. The system prevents double bookings by ensuring that a room cannot be reserved on the same date more than once. # Additional Information You may assume that the `room_number` is always a valid integer representing an existing room in the hotel. Document any assumptions you make. This question assesses: - Ability to handle dictionary manipulation and set operations, - Comfort with working on date management and string processing, - Proficiency in implementing logical checks ensuring system integrity.","solution":"def add_reservation(reservations: dict, room_number: int, date: str) -> bool: Adds a reservation for the given room number on the specified date if available. :param reservations: Dictionary holding the current reservations :param room_number: The number of the room to be reserved :param date: The date for the reservation :return: True if the reservation was added successfully, False otherwise if room_number not in reservations: reservations[room_number] = set() if date in reservations[room_number]: return False reservations[room_number].add(date) return True def is_available(reservations: dict, room_number: int, date: str) -> bool: Checks if a given room is available on the specified date. :param reservations: Dictionary holding the current reservations :param room_number: The number of the room to check :param date: The date to check availability for :return: True if the room is available, False otherwise if room_number not in reservations: return True return date not in reservations[room_number]"},{"question":"# Coding Assessment Question In this assessment, you need to implement a custom data structure called `CircularBuffer` with fixed capacity and provide methods for common buffer operations. This exercise is designed to evaluate your understanding of data structures, circular buffer logic, and efficient memory usage. Your Task 1. **Implement CircularBuffer Class**: - Create a class `CircularBuffer` that maintains a fixed-size buffer and supports cyclic overwriting of elements. 2. **Methods to be Implemented**: - `write(value: int) -> bool`: Writes a value to the buffer. Returns `True` if successful, `False` if the buffer is full. - `read() -> int`: Reads and removes the oldest value from the buffer. If the buffer is empty, raise an appropriate exception. - `is_full() -> bool`: Returns `True` if the buffer is full, `False` otherwise. - `is_empty() -> bool`: Returns `True` if the buffer is empty, `False` otherwise. - `clear()`: Clears all elements in the buffer. # Implementation Details Required Class and Methods: 1. **`class CircularBuffer`**: - An initializer that sets the buffer capacity and initializes necessary internal variables. 2. **`write(value: int) -> bool`**: - Adds a value to the buffer if there is space; otherwise, returns `False`. 3. **`read() -> int`**: - Reads and removes the oldest value from the buffer. Raises an exception if the buffer is empty. 4. **`is_full() -> bool`**: - Checks if the buffer is full. 5. **`is_empty() -> bool`**: - Checks if the buffer is empty. 6. **`clear()`**: - Resets the buffer to its initial empty state. # Constraints: - The buffer capacity will be a positive integer up to 1000. - Values written to the buffer will be integers. - The methods should handle the circular nature of the buffer efficiently. Input/Output: - **Input**: - Integer values for write operations. - Method calls to operate on the circular buffer. - **Output**: - Boolean values for `write`, `is_full`, and `is_empty` methods. - Integer values for `read` operations. - No specific output for `clear` method. - Custom exception message for attempting to read from an empty buffer. # Performance Requirements - The designed solution must handle all operations efficiently with constant time complexity. # Scenario Assume you are building a real-time data processing system that requires a fixed-size buffer to hold the most recent data points for computation. You need to implement a `CircularBuffer` class that can manage this buffer with efficient insertion, retrieval, and handling of buffer overflow scenarios. ```python # Example usage: buffer = CircularBuffer(5) buffer.write(10) # Should return True buffer.write(20) # Should return True print(buffer.read()) # Should return 10 print(buffer.is_empty()) # Should return False print(buffer.is_full()) # Should return False buffer.clear() print(buffer.is_empty()) # Should return True ```","solution":"class CircularBuffer: def __init__(self, capacity): self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.size = 0 def write(self, value): if self.is_full(): return False self.buffer[self.end] = value self.end = (self.end + 1) % self.capacity self.size += 1 return True def read(self): if self.is_empty(): raise Exception(\\"Buffer is empty\\") value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.capacity self.size -= 1 return value def is_full(self): return self.size == self.capacity def is_empty(self): return self.size == 0 def clear(self): self.buffer = [None] * self.capacity self.start = 0 self.end = 0 self.size = 0"},{"question":"# Sum of Digits in an Integer Context Summing the digits of a number is a fundamental operation often used in various mathematical computations and digital root calculations. This problem can help in understanding basic number manipulation and string handling in programming. Task You are required to write a Python function that takes an integer as input and returns the sum of its digits. The function should handle both positive and negative numbers, and raise exceptions for invalid inputs like non-integer values or empty inputs. Input - A single integer, which can be positive or negative. Output - The sum of the digits of the input integer as an integer. Constraints - The input can be within the range of 32-bit signed integers (-2,147,483,648 to 2,147,483,647). - Raise a `ValueError` with appropriate messages if the input is invalid or empty. Examples ```python >>> sum_of_digits(123) 6 >>> sum_of_digits(-567) 18 >>> sum_of_digits(1001) 2 >>> sum_of_digits(0) 0 >>> sum_of_digits(2147483647) 46 >>> sum_of_digits(\\"abc\\") Traceback (most recent call last): ... ValueError: Invalid value was passed to the function >>> sum_of_digits(\\"\\") Traceback (most recent call last): ... ValueError: No value was passed to the function ``` Function Signature ```python def sum_of_digits(num: int) -> int: pass ``` # Requirements 1. The function should handle input validation. 2. Proper exception handling should be implemented for invalid inputs. 3. Efficient computation by reducing the number to its constituent digits should be used.","solution":"def sum_of_digits(num): Returns the sum of the absolute digits of an integer. Parameters: num (int): The integer whose digits will be summed up. Returns: int: The sum of the digits of the integer. Raises: ValueError: If the input is not an integer or if the input is empty. if num is None or num == \\"\\": raise ValueError(\\"No value was passed to the function\\") if not isinstance(num, int): raise ValueError(\\"Invalid value was passed to the function\\") return sum(int(digit) for digit in str(abs(num)))"},{"question":"# Problem Statement Write a function that takes a string of lowercase and uppercase letters and returns a new string with the positions of the letters in the alphabet reversed. For example, \'a\' becomes \'z\', \'b\' becomes \'y\', \'c\' becomes \'x\', and so on. The case of the letters should be preserved. # Function Signature ```python def reverse_alphabet(s: str) -> str: ``` # Input * `s` (str): A string consisting of lowercase and uppercase letters. # Output * Returns a string with the letters\' positions in the alphabet reversed, preserving their original case. # Constraints * The input string will have a length of `1 <= len(s) <= 10^4`. * The string only contains alphabetic characters (both lowercase and uppercase). # Example Example 1 Input: ```python reverse_alphabet(\\"abcXYZ\\") ``` Output: ```plaintext zyxCBA ``` Explanation: - \'a\' (1st letter in the alphabet) becomes \'z\' (26th letter in the alphabet), - \'b\' (2nd letter in the alphabet) becomes \'y\' (25th letter in the alphabet), - \'c\' (3rd letter in the alphabet) becomes \'x\' (24th letter in the alphabet), - \'X\' (24th letter in the alphabet) becomes \'C\' (3rd letter in the alphabet), - \'Y\' (25th letter in the alphabet) becomes \'B\' (2nd letter in the alphabet), - \'Z\' (26th letter in the alphabet) becomes \'A\' (1st letter in the alphabet). Example 2 Input: ```python reverse_alphabet(\\"HelloWorld\\") ``` Output: ```plaintext SvoolDliow ``` Explanation: - \'H\' becomes \'S\' - \'e\' becomes \'v\' - \'l\' becomes \'o\' - \'l\' becomes \'o\' - \'o\' becomes \'l\' - \'W\' becomes \'D\' - \'o\' becomes \'l\' - \'r\' becomes \'i\' - \'l\' becomes \'o\' - \'d\' becomes \'w\' # Notes 1. Ensure the solution manages both lowercase and uppercase letters appropriately. 2. Consider and handle edge cases such as an empty string or a single character.","solution":"def reverse_alphabet(s: str) -> str: result = [] for char in s: if \'a\' <= char <= \'z\': reversed_char = chr(219 - ord(char)) # 219 = ord(\'a\') + ord(\'z\') result.append(reversed_char) elif \'A\' <= char <= \'Z\': reversed_char = chr(155 - ord(char)) # 155 = ord(\'A\') + ord(\'Z\') result.append(reversed_char) else: result.append(char) # in case there are any non-alphabet characters return \'\'.join(result)"},{"question":"# Scenario You are tasked with developing a simple service to manage a library of books. The service should allow users to add books, retrieve a list of all books, and search for books by their title. # Objective Implement a basic library management system that supports the following features: 1. **Add Book**: Allow users to add a new book to the library. Each book should have a title and an author. 2. **Get All Books**: Retrieve a list of all books in the library. 3. **Search Books by Title**: Allow users to search for books by title. The search should be case-insensitive and should return all books that contain the search term in their title. # Instructions 1. Implement the following class `Library` which should have the described methods: ```python class Library: def __init__(self): pass def add_book(self, title, author): pass def get_all_books(self): pass def search_books_by_title(self, search_term): pass ``` 2. Use appropriate data structures to store and manage the books. # Expected Input and Output - **Input**: - `add_book`: Two strings (title and author) - `get_all_books`: No input - `search_books_by_title`: One string (search term) - **Output**: - `get_all_books`: A list of dictionaries, each representing a book with \'title\' and \'author\' keys. - `search_books_by_title`: A list of dictionaries matching the search term, each with \'title\' and \'author\' keys. # Constraints - Titles and author names are case-insensitive. - The library can handle up to 10,000 books. # Example Usage ```python library = Library() # Adding books library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(\\"1984\\", \\"George Orwell\\") # Retrieving all books all_books = library.get_all_books() print(all_books) # Should print: [{\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\'}, # {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\'}, # {\'title\': \'1984\', \'author\': \'George Orwell\'}] # Searching for books by title search_results = library.search_books_by_title(\\"great\\") print(search_results) # Should print: [{\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\'}] ``` # Performance Requirements - Ensure that retrieving all books and searching for books is efficient, considering the constraints. # Additional Notes - Use clear and descriptive method and variable names. - Handle edge cases such as adding books with the same title but different authors. The system should store both entries.","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author): Add a new book to the library with the given title and author. book = {\'title\': title, \'author\': author} self.books.append(book) def get_all_books(self): Retrieve a list of all books in the library. return self.books def search_books_by_title(self, search_term): Search for books by the given search term in the title. The search is case-insensitive and returns all matching books. search_term_lower = search_term.lower() return [ book for book in self.books if search_term_lower in book[\'title\'].lower() ]"},{"question":"# Coding Question **Title: Finding the K-th Largest Element in an Array** **Background**: Often in array manipulation, it is necessary to determine the position of a specific element relative to the order of the array. One common task is finding the k-th largest element within an unsorted array. Write a Python function `find_kth_largest(nums: List[int], k: int) -> int` that returns the k-th largest element in the given list. **Function Signature**: ```python def find_kth_largest(nums: List[int], k: int) -> int: ``` **Input**: - `nums` (List[int]): A list of integers. - `k` (int): An integer representing the rank of the largest element to find. `1 <= k <= len(nums)`. **Output**: - (int): The k-th largest element in the array. **Constraints**: - The array can contain both positive and negative integers. - The length of the array (`len(nums)`) will be in the range of 1 to 10^4. - The values in the array will be in the range of -10^5 to 10^5. **Examples**: ```python assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 assert find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 assert find_kth_largest([1], 1) == 1 ``` **Implementation Guidelines**: 1. Utilize an efficient algorithm to avoid excessive computational complexity. 2. You can use sorting, but try to explore other options like heaps for more efficiency. 3. Consider edge cases such as all elements being the same, or k being the size of the array. **Notes**: - Make sure the solution is optimized for both time and space as the array size can be relatively large. - Avoid unnecessary computations by breaking early if possible, especially with sorting or heap-based approaches.","solution":"from typing import List import heapq def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the given list. return heapq.nlargest(k, nums)[-1]"},{"question":"# Array Rotation\'s Impact Analysis **Context**: In both software development and algorithms, understanding the impact of array operations is vital. One common operation is array rotation, which involves shifting elements of the array a certain number of times, either to the left or to the right. Analyzing changes caused by such rotations can be essential for optimizing performance, data shuffling, and more. **Task**: Implement a function `rotate_array(arr: List[int], k: int, direction: str) -> List[int]` that rotates elements of the array `arr` `k` times. The direction of rotation is specified by the `direction` parameter, which can either be `\\"left\\"` or `\\"right\\"`. Your implementation should handle edge cases effectively. # Input Format: - A list of integers, `arr`, where the size of the list is in the range of `[0, 10^7]`. - An integer, `k`, where `0 <= k`. - A string, `direction`, which can either be `\\"left\\"` or `\\"right\\"`. # Output Format: - A list of integers, representing the rotated array. # Constraints: - If `k` is greater than the length of the array, it should rotate `k % len(arr)` times. - The function should handle large values of `k`. - If the direction is not `\\"left\\"` or `\\"right\\"`, your function should raise a `ValueError`. # Examples: ```python >>> rotate_array([1, 2, 3, 4, 5], 2, \\"left\\") [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 3, \\"right\\") [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 0, \\"left\\") [1, 2, 3, 4, 5] >>> rotate_array([], 10, \\"left\\") [] >>> rotate_array([1, 2, 3], 6, \\"right\\") [1, 2, 3] ``` **Performance Requirements:** - Ensure the function processes within reasonable time limits, especially considering large arrays and high values of `k`. # Implementation: Your implementation should focus on efficiently moving elements and minimizing unnecessary operations. Consider using array slicing or other optimized techniques to handle large rotations effectively. Be mindful of edge cases, such as empty arrays and zero rotations.","solution":"from typing import List def rotate_array(arr: List[int], k: int, direction: str) -> List[int]: Rotates the elements of the array `arr` `k` times in the specified `direction`. Allowed directions are \'left\' and \'right\'. if direction not in (\\"left\\", \\"right\\"): raise ValueError(\\"Direction must be either \'left\' or \'right\'\\") n = len(arr) if n == 0: # Edge case: empty array return arr k = k % n # Simplify large values of k if direction == \\"left\\": return arr[k:] + arr[:k] elif direction == \\"right\\": return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement Write a function that simulates a simplified version of the **\\"Towers of Hanoi\\"** problem for `n` disks and exactly `m` moves. In the classical Towers of Hanoi problem, you aim to move all disks from the source peg to the target peg using the minimum number of moves, which is ( 2^n - 1 ). However, in this problem, the focus is on making a list of moves that accomplish the stated `m` moves, regardless of whether the problem is solved. # Function Signature ```python def towers_of_hanoi_moves(n: int, m: int) -> List[Tuple[str, str]]: pass ``` # Input - **n** (int): The number of disks. - **m** (int): The exact number of moves to perform. # Output - **result** (List[Tuple[str, str]]): A list of tuples representing the moves. Each tuple contains two elements: the source peg and the target peg, e.g., (\'A\', \'B\'). # Constraints 1. `1 <= n <= 10` 2. `0 <= m <= 2^n - 1` 3. The function should raise a `ValueError` if `m` is greater than ( 2^n - 1 ). # Examples ```python >>> towers_of_hanoi_moves(3, 4) [(\'A\', \'C\'), (\'A\', \'B\'), (\'C\', \'B\'), (\'A\', \'C\')] >>> towers_of_hanoi_moves(2, 2) [(\'A\', \'B\'), (\'A\', \'C\')] >>> towers_of_hanoi_moves(0, 0) [] >>> towers_of_hanoi_moves(2, 4) Traceback (most recent call last): ... ValueError: Number of moves exceeds the maximum possible moves (3) for 2 disks. ``` # Implementation Notes To simulate the Towers of Hanoi problem: 1. Use a helper function to generate the sequence of moves for `n` disks, but truncate the output to `m` moves. 2. The standard recursive solution to the Towers of Hanoi can be used, where the primary operation involves moving disks between the pegs according to the rules. 3. Ensure that the moves are made and recorded precisely in order. Using the approach outlined above, you\'ll generate the exact sequence of moves required to simulate the described number of moves for the specified number of disks.","solution":"from typing import List, Tuple def towers_of_hanoi_moves(n: int, m: int) -> List[Tuple[str, str]]: def move_disks(num_disks, source, target, auxiliary, moves): if num_disks == 0: return if len(moves) >= m: return move_disks(num_disks - 1, source, auxiliary, target, moves) if len(moves) < m: moves.append((source, target)) move_disks(num_disks - 1, auxiliary, target, source, moves) if m > (2 ** n) - 1: raise ValueError(f\\"Number of moves exceeds the maximum possible moves ({(2 ** n) - 1}) for {n} disks.\\") result = [] move_disks(n, \'A\', \'C\', \'B\', result) return result[:m]"},{"question":"Implementing a Stack with Minimum Retrieval **Scenario**: As a software engineer, you often need to optimize data structures to handle real-time constraints efficiently. One common task is managing a stack that not only pushes and pops elements but also retrieves the minimum element in constant time. You are required to implement such a stack. **Task**: Implement the class `MinStack` that supports the following operations: - `push(x)`: Adds the element x to the stack. - `pop()`: Removes the element on the top of the stack. - `top()`: Retrieves the top element of the stack. - `get_min()`: Retrieves the minimum element in the stack in constant time. **Class Definition**: ```python class MinStack: def __init__(self): # Initializes the data structure pass def push(self, x: int) -> None: # Adds a new element onto the stack pass def pop(self) -> None: # Removes the top element from the stack pass def top(self) -> int: # Retrieves the top element of the stack pass def get_min(self) -> int: # Retrieves the minimum element in the stack pass ``` **Input and Output**: - `push(x)`: No output. - `pop()`: No output. - `top()`: Returns the integer that is the top element of the stack. - `get_min()`: Returns the integer that is the minimum element in the stack. **Constraints**: - The functions `push`, `pop`, `top`, and `get_min` must all run in O(1) time complexity. - All methods can be called/enforced in any order, and each can be executed several times. - Assume the stack will not be empty when `pop()`, `top()`, or `get_min()` is called. - Initially, the stack is empty. **Example Usage**: ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Expected output: -3 min_stack.pop() print(min_stack.top()) # Expected output: 0 print(min_stack.get_min()) # Expected output: -2 min_stack.push(-4) print(min_stack.get_min()) # Expected output: -4 min_stack.pop() print(min_stack.get_min()) # Expected output: -2 ``` **Note**: Ensure that methods maintain efficiency, holding additional state data only if necessary to meet the performance constraints.","solution":"class MinStack: def __init__(self): Initializes the data structure self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Adds a new element onto the stack self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the top element from the stack if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Retrieves the top element of the stack if self.stack: return self.stack[-1] def get_min(self) -> int: Retrieves the minimum element in the stack if self.min_stack: return self.min_stack[-1]"},{"question":"# Problem Statement: LCM and GCD Calculator You are tasked with creating a small utility library that helps in calculating the Least Common Multiple (LCM) and the Greatest Common Divisor (GCD) for given input values. This library should provide functions to compute these properties using the Euclidean algorithm for GCD and the relationship between LCM and GCD. **Context and Functions:** 1. **GCD Calculation**: The greatest common divisor of two integers ( a ) and ( b ) is the largest positive integer that divides both ( a ) and ( b ). The Euclidean algorithm can be used to find the GCD: [ text{GCD}(a, b) = begin{cases} b & text{if } a = 0 text{GCD}(b mod a, a) & text{if } a neq 0 end{cases} ] 2. **LCM Calculation**: The least common multiple of two integers ( a ) and ( b ) is the smallest positive integer that is divisible by both ( a ) and ( b ). The relationship between LCM and GCD is given by: [ text{LCM}(a, b) = frac{|a cdot b|}{text{GCD}(a, b)} ] **Tasks**: 1. **Implement the function `gcd(a: int, b: int) -> int`.** * The function should calculate and return the GCD of the given integers using the Euclidean algorithm. * Ensure that it raises a `ValueError` if either ( a ) or ( b ) is non-positive. **Example**: ```python >>> gcd(48, 18) 6 >>> gcd(-1, 10) Traceback (most recent call last): ... ValueError: Both numbers must be positive ``` 2. **Implement the function `lcm(a: int, b: int) -> int`.** * The function should calculate and return the LCM of the given integers using the relationship with GCD. * Ensure that it raises a `ValueError` if either ( a ) or ( b ) is non-positive. **Example**: ```python >>> lcm(12, 15) 60 >>> lcm(0, 20) Traceback (most recent call last): ... ValueError: Both numbers must be positive ``` **Input Constraints**: - (0 < a, b leq 10^6) **Assumptions**: - The provided integers are within the range and are positive. Your implementation should be efficient and handle edge cases such as very large numbers within the provided constraints.","solution":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two positive integers a and b using the Euclidean algorithm. Raises a ValueError if either a or b is non-positive. if a <= 0 or b <= 0: raise ValueError(\\"Both numbers must be positive\\") while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Computes the Least Common Multiple (LCM) of two positive integers a and b using the relationship between LCM and GCD. Raises a ValueError if either a or b is non-positive. if a <= 0 or b <= 0: raise ValueError(\\"Both numbers must be positive\\") return abs(a * b) // gcd(a, b)"},{"question":"# Problem Description You are to implement a function that calculates the maximum product of its digits after removing one digit from a given positive integer. The function should accept an integer input and return the largest possible product of the remaining digits after removing exactly one digit. # Function Signature ```python def max_product_after_removal(num: int) -> int: pass ``` # Input - A single integer `num` where 10 ≤ `num` ≤ 10^9. # Output - A single integer representing the largest product of digits after removing one digit from the input number. # Constraints - The input number must be a positive integer between 10 and 10^9 inclusive. - If the input is not an integer within the valid range, the function should raise a `ValueError` with the message \\"invalid input\\". # Performance Requirements - The implementation should efficiently handle cases within the given constraints. # Examples ```python >>> max_product_after_removal(1234) 24 # Removing digit 1 results in the product 2*3*4 = 24 >>> max_product_after_removal(2345) 120 # Removing digit 2 results in the product 3*4*5 = 60; removing digit 4 results in the product 2*3*5 = 30; the largest product is 120 >>> max_product_after_removal(1111) 1 # Removing any digit from 1111 results in the product 1*1*1 = 1 >>> max_product_after_removal(234) 12 # Removing digit 2 results in 3*4 = 12 >>> max_product_after_removal(10) 0 # Removing digit 1 results in 0; removing digit 0 results in 1 and the largest product is 0 ``` # Detailed Example Walkthrough 1. For input `max_product_after_removal(1234)`: Removing digits gives potential products: - Without 1: 2 * 3 * 4 = 24 - Without 2: 1 * 3 * 4 = 12 - Without 3: 1 * 2 * 4 = 8 - Without 4: 1 * 2 * 3 = 6 The largest product is 24. 2. For input `max_product_after_removal(1111)`: Removing any digit results in products: - Without 1: 1 * 1 * 1 = 1 (repeated four times) The product remains 1 regardless of which digit is removed. # Notes * Handle edge cases where digits contain zeros. Ensure the calculation considers products correctly, especially with zeros involved. * Implement error checks for non-integer and out-of-range inputs, ensuring appropriate exceptions are raised.","solution":"def max_product_after_removal(num: int) -> int: if not isinstance(num, int) or num < 10 or num > 10**9: raise ValueError(\\"invalid input\\") num_str = str(num) max_product = 0 for i in range(len(num_str)): remaining_digits = num_str[:i] + num_str[i+1:] product = 1 for digit in remaining_digits: product *= int(digit) max_product = max(max_product, product) return max_product"},{"question":"# Coding Question: Merge Two Sorted Arrays Context Merging two sorted arrays into one sorted array is a fundamental programming problem that helps in understanding array manipulations and handling edge cases efficiently. Problem Statement Write a function `merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]` that takes two sorted arrays and returns a single sorted array containing all the elements from the input arrays. Input - Two lists of integers `arr1` and `arr2`, each sorted in non-decreasing order. Output - A list of integers representing the merged sorted array. Constraints - The input arrays can be empty. - The total number of elements in both arrays combined does not exceed 10^6. - Each number in the arrays fits within the 32-bit signed integer range. Example ```python def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: # Your implementation here # Examples to test your solution print(merge_sorted_arrays([1, 3, 5], [2, 4, 6])) # Expected output: [1, 2, 3, 4, 5, 6] print(merge_sorted_arrays([0], [1, 2, 3])) # Expected output: [0, 1, 2, 3] print(merge_sorted_arrays([], [1, 2, 3])) # Expected output: [1, 2, 3] print(merge_sorted_arrays([1, 3, 5], [])) # Expected output: [1, 3, 5] print(merge_sorted_arrays([1, 1, 1], [1, 1, 1])) # Expected output: [1, 1, 1, 1, 1, 1] print(merge_sorted_arrays([-5, -3, -1], [-4, -2, 0])) # Expected output: [-5, -4, -3, -2, -1, 0] ``` Additional Requirements - You must implement the merge process efficiently to work within O(n + m) time complexity, where `n` and `m` are the lengths of the two input arrays. - Ensure your implementation handles edge cases such as empty arrays and arrays with negative integers.","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: i, j = 0, 0 merged = [] while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"# Coding Challenge Scenario You are designing a feature for an e-commerce platform that needs to frequently perform searches on a list of products to quickly identify if specific items exist in the inventory. To achieve this, you plan to implement a binary search algorithm which offers efficient lookups with ( O(log n) ) time complexity. Task Implement the function `binary_search(products: List[int], target: int) -> int` which performs a binary search on a sorted list of integers (representing product IDs) and returns the index of the target value if it exists in the list. If the target is not found, the function should return `-1`. # Input and Output - **Input**: A sorted list of integers `products` and a single integer `target`. - **Output**: A single integer representing the index of the `target` in the `products` list, or `-1` if the `target` is not present. # Constraints - The list `products` should be sorted in ascending order. - The list `products` may contain up to 10^5 elements. - The function should handle typical 32-bit signed integers as product IDs. # Performance Requirements - Your solution should aim for ( O(log n) ) time complexity. # Error Handling - Raise `ValueError` if the `products` list is not sorted in ascending order. - Raise `TypeError` if the `products` list or the `target` is not of integer type. # Examples - `binary_search([1, 2, 3, 4, 5], 3)` should return `2` - `binary_search([10, 20, 30, 40, 50], 25)` should return `-1` - `binary_search([], 4)` should return `-1` - `binary_search([4, 1, 3, 2], 3)` should raise `ValueError: products must be sorted in ascending order` - `binary_search([\'a\', \'b\', \'c\'], \'b\')` should raise `TypeError: products must be a list of integers` # Additional Notes - Ensure that the implementation is efficient and handles edge cases gracefully. - You can assume that inputs are within a reasonable range and do not require handling for extreme edge cases like millions of product IDs.","solution":"def binary_search(products, target): Perform a binary search to find the target in a sorted list of products. :param products: List[int], sorted list of product IDs :param target: int, the product ID to search for :return: int, index of the target if found, else -1 if not all(isinstance(i, int) for i in products): raise TypeError(\\"products must be a list of integers\\") if not isinstance(target, int): raise TypeError(\\"target must be an integer\\") if products != sorted(products): raise ValueError(\\"products must be sorted in ascending order\\") low, high = 0, len(products) - 1 while low <= high: mid = (low + high) // 2 if products[mid] == target: return mid elif products[mid] < target: low = mid + 1 else: high = mid - 1 return -1"},{"question":"Coding Assessment Question # Kth Largest Element in a Stream Scenario: You are given a stream of integers arriving one by one. Your task is to design an algorithm that always reports the k-th largest element in the stream up to the current element in an efficient manner. For example, if the stream is `[4, 5, 8, 2]` and `k = 3`, the algorithm should return the 3rd largest element after each insertion: `[None, None, 4, 4]`. Task: Write a class `KthLargest` that provides methods to process a sequence of integers and retrieve the k-th largest number. The class should support the following operations: - `__init__(self, k: int, nums: list[int])`: Initializes the object with an integer `k` and a list of integers `nums`. - `add(self, val: int) -> int`: Adds a new integer `val` to the stream and returns the k-th largest element in the stream up to that point. Class Definition: ```python class KthLargest: def __init__(self, k: int, nums: list[int]): pass def add(self, val: int) -> int: pass ``` Input: * `k`: An integer representing the position of the k-th largest element to find. * `nums`: A list of integers representing the initial set of numbers in the stream. This list can be empty. Output: * `__init__`: No return value. * `add`: Returns an integer, the k-th largest element in the stream up to the current insertion. Constraints: * `1 <= k <= 10^4` * `-10^4 <= nums[i], val <= 10^4` * `At most 10^4 calls will be made to the `add` method. Example Usage: * Example 1: ```python kthLargest = KthLargest(3, [4, 5, 8, 2]) print(kthLargest.add(3)) # Output: 4 print(kthLargest.add(5)) # Output: 5 print(kthLargest.add(10)) # Output: 5 print(kthLargest.add(9)) # Output: 8 print(kthLargest.add(4)) # Output: 8 ``` * Example 2: ```python kthLargest = KthLargest(1, [5]) print(kthLargest.add(2)) # Output: 5 print(kthLargest.add(1)) # Output: 5 print(kthLargest.add(6)) # Output: 6 ``` * Example 3: ```python kthLargest = KthLargest(2, [1, 2, 3]) print(kthLargest.add(4)) # Output: 3 print(kthLargest.add(5)) # Output: 4 ``` # Instructions: 1. Implement the `KthLargest` class as described. 2. Handle edge cases such as an empty initial list or negative numbers. 3. Ensure the implementation efficiently processes the stream with respect to both time and space complexity. 4. Test your implementation against a variety of scenarios to ensure correctness.","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list[int]): self.k = k self.min_heap = [] for num in nums: self.add(num) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heappushpop(self.min_heap, val) if len(self.min_heap) < self.k: return None # Return None if we haven\'t seen at least k elements else: return self.min_heap[0]"},{"question":"# Coding Assessment Question In a toy robot navigation system, a robot can move on a grid with specific dimensions. The robot can move in four possible directions: \'UP\', \'DOWN\', \'LEFT\', or \'RIGHT\'. Your task is to implement a feature that tracks the robot\'s position and determines whether a given series of moves will keep the robot within the boundaries of the grid. Requirements: 1. Implement a function `is_within_bounds` that tracks the robot\'s position on the grid and checks if a series of moves keeps the robot within the grid boundaries. 2. The function should return `True` if all moves keep the robot within bounds, and `False` if any move takes the robot out of bounds. # Function Signature ```python def is_within_bounds(grid_width: int, grid_height: int, start_x: int, start_y: int, moves: List[str]) -> bool: Determine if a series of moves keeps the robot within the grid boundaries. :param grid_width: Width of the grid :type grid_width: int :param grid_height: Height of the grid :type grid_height: int :param start_x: Starting x-coordinate of the robot :type start_x: int :param start_y: Starting y-coordinate of the robot :type start_y: int :param moves: List of moves the robot will make :type moves: List[str] :return: True if all moves keep the robot within grid boundaries, else False :rtype: bool pass ``` # Input - `grid_width`: The width of the grid (integer, 1 ≤ grid_width ≤ 1000). - `grid_height`: The height of the grid (integer, 1 ≤ grid_height ≤ 1000). - `start_x`: The starting x-coordinate of the robot (integer, 0 ≤ start_x < grid_width). - `start_y`: The starting y-coordinate of the robot (integer, 0 ≤ start_y < grid_height). - `moves`: A list of strings, each representing a move (\'UP\', \'DOWN\', \'LEFT\', \'RIGHT\'). # Output - A boolean value: `True` if all moves keep the robot within the grid boundaries, `False` otherwise. # Constraints - The robot starts at a given valid position within the grid. - The number of moves can be large, so optimize the solution for performance. - The function should handle the boundaries of the grid gracefully. - Consider edge cases where the robot starts or ends near the edges of the grid. # Example ```python # Example 1: grid_width = 5 grid_height = 5 start_x = 2 start_y = 2 moves = [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"DOWN\\", \\"RIGHT\\"] print(is_within_bounds(grid_width, grid_height, start_x, start_y, moves)) # Output: True # Example 2: grid_width = 5 grid_height = 5 start_x = 0 start_y = 0 moves = [\\"UP\\", \\"LEFT\\"] print(is_within_bounds(grid_width, grid_height, start_x, start_y, moves)) # Output: False ``` In these examples, the function returns whether the series of moves keeps the robot within the grid boundaries, ensuring no move takes the robot out of the grid. # Additional Information This question evaluates the candidate\'s ability to work with grid-based position tracking and boundary conditions efficiently. It also helps assess logical thinking for simulating movements and managing constraints in a 2D environment.","solution":"from typing import List def is_within_bounds(grid_width: int, grid_height: int, start_x: int, start_y: int, moves: List[str]) -> bool: Determine if a series of moves keeps the robot within the grid boundaries. :param grid_width: Width of the grid :type grid_width: int :param grid_height: Height of the grid :type grid_height: int :param start_x: Starting x-coordinate of the robot :type start_x: int :param start_y: Starting y-coordinate of the robot :type start_y: int :param moves: List of moves the robot will make :type moves: List[str] :return: True if all moves keep the robot within grid boundaries, else False :rtype: bool x, y = start_x, start_y for move in moves: if move == \\"UP\\": y -= 1 elif move == \\"DOWN\\": y += 1 elif move == \\"LEFT\\": x -= 1 elif move == \\"RIGHT\\": x += 1 # Check if the new position is out of bounds if x < 0 or x >= grid_width or y < 0 or y >= grid_height: return False return True"},{"question":"Question # Problem Statement Given a list of integers, `lst`, write a function that finds the subarray with the maximum sum. A subarray is a contiguous part of an array and can be of any length. Make sure to handle both positive and negative integers efficiently. # Function Signature ```python def max_subarray_sum(lst: List[int]) -> int: ``` # Input - `lst` (List of Integers): A list of integers which can be both positive and negative. # Output - Returns an integer that is the maximum sum of any subarray in the given list. # Examples 1. `max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])` should return `6`. The subarray `[-2, 1, -3, 4, -1, 2, 1, -5, 4]` has the maximum sum `4 + (-1) + 2 + 1`. 2. `max_subarray_sum([1, 2, 3, 4, 5])` should return `15`. The entire array is the subarray with the maximum sum. 3. `max_subarray_sum([5, -2, 3, 6, -1, 4])` should return `15`. The subarray `[5, -2, 3, 6, -1, 4]` has the maximum sum. 4. `max_subarray_sum([-1, -2, -3, -4])` should return `-1`. The single element subarray `[-1]` has the maximum sum in this context. # Constraints - The length of list `lst` will be between `1` and `10^5`. - The integers in `lst` will vary between `-10^5` and `10^5`. # Performance Requirements - Your solution should aim for O(n) complexity by using an efficient algorithm like Kadane\'s algorithm. # Notes - Handle edge cases like all-negative numbers or single-element lists appropriately. - Ensure that the function is robust and handles large input sizes efficiently.","solution":"def max_subarray_sum(lst): Finds the subarray with the maximum sum in the given list of integers. Uses Kadane\'s algorithm for an efficient O(n) solution. if not lst: return 0 max_so_far = lst[0] max_ending_here = lst[0] for i in range(1, len(lst)): max_ending_here = max(lst[i], max_ending_here + lst[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Question You are provided with a weighted directed graph represented as an adjacency list, where each edge has a positive weight. Your goal is to implement the Bellman-Ford algorithm to find the shortest path from a given start node to all other nodes in the graph. If the graph contains a negative weight cycle, your function should detect this and return an appropriate indicator. Write a function `bellman_ford(graph: Dict[str, List[Tuple[str, int]]], start: str) -> Union[Dict[str, int], str]` that finds the shortest paths from the start node to all other nodes using the Bellman-Ford algorithm. If there is a negative weight cycle, return the string `\\"Negative cycle detected\\"`. # Input and Output Formats Inputs: - `graph`: A dictionary where keys are string identifiers of nodes, and values are lists of tuples. Each tuple contains a neighboring node identifier and the weight of the edge to that neighbor (also a string and an integer respectively). - `start`: A string representing the starting node for the Bellman-Ford algorithm. Output: - If there is no negative weight cycle, return a dictionary where keys are node identifiers and values are the shortest distances from the start node. - If a negative weight cycle is detected, return the string `\\"Negative cycle detected\\"`. # Constraints - The graph can have up to 100 nodes and 1000 edges. - Edges have positive weights only. - Node identifiers and weight are sufficiently small to use in typical integer operations. # Example ```python # Example Input graph = { \\"A\\": [(\\"B\\", 1), (\\"C\\", 4)], \\"B\\": [(\\"C\\", 2), (\\"D\\", 2)], \\"C\\": [(\\"D\\", 3)], \\"D\\": [] } start = \\"A\\" # Example Function Call print(bellman_ford(graph, start)) # Expected Output (shortest paths from A) {\\"A\\": 0, \\"B\\": 1, \\"C\\": 3, \\"D\\": 3} ``` In this example, from the given start node \\"A\\", the function should return the shortest paths to all other nodes in the graph.","solution":"def bellman_ford(graph, start): Finds the shortest path from start node to all other nodes using the Bellman-Ford algorithm. If a negative weight cycle is detected, returns \\"Negative cycle detected\\". Otherwise, returns a dictionary where keys are nodes and values are the shortest distances from start node. distances = {node: float(\'inf\') for node in graph} distances[start] = 0 for _ in range(len(graph) - 1): for node in graph: for neighbor, weight in graph[node]: if distances[node] + weight < distances[neighbor]: distances[neighbor] = distances[node] + weight # Check for negative weight cycle for node in graph: for neighbor, weight in graph[node]: if distances[node] + weight < distances[neighbor]: return \\"Negative cycle detected\\" return distances"},{"question":"# Problem Statement You are required to implement a function `next_palindrome(n)` that given a non-negative integer `n`, returns the smallest palindrome larger than `n`. The function should handle a variety of edge cases efficiently and must aim to minimize time and computational costs. # Input - A non-negative integer `n` (0 ≤ n ≤ 10^6) # Output - An integer representing the smallest palindrome number greater than `n`. # Constraints - The function should optimize for both time and space efficiently. - Avoid generating all numbers greater than `n` and checking each for palindromicity to minimize computational cost. # Performance Requirements - Your implementation should aim for a time complexity better than checking each subsequent number for being a palindrome. # Example ```python print(next_palindrome(123)) # Expected output: 131 print(next_palindrome(999)) # Expected output: 1001 ``` # Additional Context Consider the use of optimizations or strategies like: * Analyzing the numerical structure of `n` for direct palindrome transformations. * Reflecting and comparing the number’s halves to form potential palindromes. * Avoid generating candidates and checking palindromicity redundantly.","solution":"def next_palindrome(n): Returns the smallest palindrome larger than `n`. def is_palindrome(x): return str(x) == str(x)[::-1] n += 1 while not is_palindrome(n): n += 1 return n"},{"question":"# Coding Assessment Question In this assessment, you are required to solve a problem by implementing an efficient algorithm that calculates the minimum number of operations needed to convert one string into another. **Scenario**: You are given two strings, `s1` and `s2`. You need to convert `s1` into `s2` using the following operations: - Insert a character. - Delete a character. - Replace a character. Write a function to compute the minimum number of operations required to transform `s1` into `s2`. **Function Signature**: ```python def min_operations(s1: str, s2: str) -> int: pass ``` **Input**: - `s1` (1 <= len(s1) <= 1000): A string consisting of lowercase English letters. - `s2` (1 <= len(s2) <= 1000): A string consisting of lowercase English letters. **Output**: - Returns an integer representing the minimum number of operations needed to convert `s1` to `s2`. **Constraints**: - The solution should handle the edge cases where the strings differ significantly in length or content. **Examples**: ```python assert min_operations(\\"horse\\", \\"ros\\") == 3 assert min_operations(\\"intention\\", \\"execution\\") == 5 assert min_operations(\\"abc\\", \\"yabd\\") == 2 assert min_operations(\\"kitten\\", \\"sitting\\") == 3 ``` **Notes**: - Use dynamic programming to achieve optimal time complexity. - Carefully handle the cases where strings are identical or completely different. Good luck!","solution":"def min_operations(s1: str, s2: str) -> int: Calculate the minimum number of operations needed to convert s1 into s2. Operations allowed: insert a character, delete a character, replace a character. :param s1: Source string. :param s2: Target string. :return: Minimum number of operations needed to transform s1 into s2. m, n = len(s1), len(s2) # Initialize DP table with (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and first column for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute costs for each subproblem for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Problem Description Given an array of positive integers `arr`, your task is to determine the maximum length of a contiguous subarray where the element values are strictly increasing. # Function Signature ```python def max_increasing_subarray(arr: List[int]) -> int: pass ``` # Input * `arr: List[int]`: A list of positive integers. (`1 <= len(arr) <= 10^5`, `1 <= arr[i] <= 10^9`) # Output * Return an integer value representing the maximum length of a contiguous subarray with strictly increasing values. # Example 1. `arr = [1, 2, 2, 3]` returns `2`: * The longest contiguous subarray with strictly increasing values is `[1, 2]` or `[2, 3]`. 2. `arr = [3, 1, 4, 7, 5, 6, 7, 8]` returns `4`: * The longest contiguous subarray with strictly increasing values is `[5, 6, 7, 8]`. # Note - The function should be optimized to run in O(n) time complexity.","solution":"def max_increasing_subarray(arr): if len(arr) == 1: return 1 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Implement a Binary Search Algorithm Binary Search is a classic algorithm used to find the position of a target value within a sorted array. It operates by repeatedly dividing the search interval in half. Function Signature ```python def binary_search(arr: list, target: int) -> int: ``` # Input - `arr` (list): A list of integers sorted in ascending order. - `target` (int): The integer value to search for within the list. # Output - Returns the index of `target` if it is present in `arr`. Otherwise, returns -1. # Constraints 1. The input list should contain integers and be sorted in non-decreasing order. 2. The list may be empty. 3. The function should use an iterative approach. # Performance Requirements - The binary search algorithm should run in O(log n) time complexity. # Example ```python print(binary_search([1, 2, 3, 4, 5], 3)) # Output: 2 print(binary_search([1, 2, 3, 4, 5], 6)) # Output: -1 print(binary_search([], 1)) # Output: -1 print(binary_search([-3, -1, 0, 3, 10], 0)) # Output: 2 ``` # Detailed Requirements 1. Implement the binary search in an iterative manner. 2. Initialize two pointers, `left` and `right`, representing the bounds of the search interval. 3. While `left` is less than or equal to `right`, determine the middle element of the current interval. 4. If the middle element is equal to the target, return its index. 5. If the middle element is less than the target, narrow the interval to the upper half; otherwise, narrow it to the lower half. 6. If the target is not found within the list, return -1. # Edge Cases to Consider 1. Empty lists. 2. Lists where all elements are the same but not matching the target. 3. Lists with negative integers. 4. Very large and very small target values relative to the list size. --- By following these guidelines, your task is to correctly implement a binary search function that adheres to the constraints and performance requirements outlined.","solution":"def binary_search(arr: list, target: int) -> int: Performs binary search on a sorted list to find the target value. Args: arr (list of int): A list of integers sorted in ascending order. target (int): The integer value to search for within the list. Returns: int: The index of the target if present, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Median Finder You are to implement a `MedianFinder` class that maintains a data stream and allows for the retrieval of the median value in constant time. # Class Specification Implement the class `MedianFinder` with the following methods: 1. **`__init__(self)`** - **Description**: Initializes the `MedianFinder` object. - **Input**: None - **Output**: None 2. **`add_num(self, num: int) -> None`** - **Description**: Adds a number to the data stream. - **Input**: `num` (int) – The integer to be added to the data stream. - **Output**: None 3. **`find_median(self) -> float`** - **Description**: Returns the median of all integers in the data stream. - **Input**: None - **Output**: The median of the data stream (float). # Constraints - You may assume that the integers are in the range [-10^5, 10^5]. - There will be at least one element in the data stream when `find_median` is called. - The `add_num` method will be called multiple times. # Example Usage ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2.0 ``` # Notes - You should optimize for the add operation. - Consider edge cases such as when the data stream is empty or contains an even number of elements. - Aim for an efficient solution in terms of time and space complexity.","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] # The larger half of numbers self.max_heap = [] # The smaller half of numbers, as a max heap (by inverting the sign) def add_num(self, num: int) -> None: heapq.heappush(self.max_heap, -num) # Add to max heap (store negatives) if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return -self.max_heap[0]"},{"question":"# Question Statement Context: Develop a ticketing system where the priority of a ticket is determined by the order of arrival and the severity of the issue. Tickets with higher severity should be attended to first. If two tickets have the same severity, the earlier one should be attended first. The system needs to process commands to add tickets, close the highest priority ticket, and fetch the current highest priority ticket without closing it. Objective: Write a class `TicketingSystem` with the following methods: - `add_ticket(timestamp: int, severity: int)`: Adds a new ticket with the given timestamp and severity. - `close_highest_priority() -> Tuple[int, int]`: Closes the highest priority ticket and returns it as a tuple (timestamp, severity). If no tickets are present, return `(-1, -1)`. - `fetch_highest_priority() -> Tuple[int, int]`: Returns the highest priority ticket as a tuple (timestamp, severity) without closing it. If no tickets are present, return `(-1, -1)`. Input: - `timestamp`: An integer representing the time of arrival of the ticket in microseconds since the epoch (0 ≤ timestamp ≤ 10**18). - `severity`: An integer indicating the severity of the issue (1 ≤ severity ≤ 10). Output: - The output of `close_highest_priority` and `fetch_highest_priority` methods should be a tuple of integers (timestamp, severity). Constraints and Requirements: - Ensure the `add_ticket`, `close_highest_priority`, and `fetch_highest_priority` methods operate efficiently with respect to time complexity. - Use appropriate data structures to maintain the priority order effectively. - Handle edge cases such as attempts to fetch or close tickets when none are present. Examples: ```python ts = TicketingSystem() ts.add_ticket(1, 5) ts.add_ticket(2, 3) print(ts.fetch_highest_priority()) # Output: (1, 5) print(ts.close_highest_priority()) # Output: (1, 5) print(ts.fetch_highest_priority()) # Output: (2, 3) print(ts.close_highest_priority()) # Output: (2, 3) print(ts.close_highest_priority()) # Output: (-1, -1) ``` Implementation Hint: Consider using a heap or priority queue to maintain the tickets ordered by severity and timestamp. Use tuples `(severity, timestamp)` to leverage Python\'s built-in tuple comparison.","solution":"import heapq from typing import List, Tuple class TicketingSystem: def __init__(self): self.tickets = [] def add_ticket(self, timestamp: int, severity: int): heapq.heappush(self.tickets, (-severity, timestamp)) def close_highest_priority(self) -> Tuple[int, int]: if not self.tickets: return (-1, -1) severity, timestamp = heapq.heappop(self.tickets) return (timestamp, -severity) def fetch_highest_priority(self) -> Tuple[int, int]: if not self.tickets: return (-1, -1) severity, timestamp = self.tickets[0] return (timestamp, -severity)"},{"question":"# Context: You are developing a web application\'s backend to handle user authentication and maintaining a session history for each user. Each session record contains a timestamp, user id, and session duration. Your task is to design and implement a functionality that provides insights into user activity over time. Given the session records, you need to: 1. Record a new session for a user. 2. Query the total session duration for any user over a specific time range. For efficiency, you choose to implement a data structure that supports both operations in optimal time. # Task: Complete the SessionManager class with the required methods to handle the above operations. Below is the class outline with method signatures provided: ```python class SessionManager: def __init__(self) -> None: # Implementation details def record_session(self, user_id: int, start_time: int, duration: int) -> None: # To be implemented by students def query_user_sessions(self, user_id: int, start_time: int, end_time: int) -> int: # To be implemented by students ``` # Requirements: - Implement the `record_session` function to store session details for a user. - Implement the `query_user_sessions` function to calculate the total session duration of a specified user between a given start time and end time. # Constraints: - 1 ≤ user_id ≤ 10^6 - 1 ≤ start_time, end_time ≤ 10^18 (Unix timestamp in seconds) - 1 ≤ duration ≤ 10^6 - Sessions may overlap - Query operations will ensure that `start_time` ≤ `end_time` # Examples: ```python session_manager = SessionManager() session_manager.record_session(1, 1609459200, 3600) # January 1, 2021 00:00:00 GMT, duration of 1 hour session_manager.record_session(1, 1609462800, 7200) # January 1, 2021 01:00:00 GMT, duration of 2 hours session_manager.record_session(2, 1609459200, 1800) # January 1, 2021 00:00:00 GMT, duration of 30 minutes print(session_manager.query_user_sessions(1, 1609459200, 1609470000)) # Should output 10800 (3 hours total) print(session_manager.query_user_sessions(2, 1609459200, 1609459800)) # Should output 1800 (30 minutes total) print(session_manager.query_user_sessions(1, 1609466400, 1609470000)) # Should output 3600 (1 hour total) ```","solution":"class SessionManager: def __init__(self) -> None: self.sessions = {} def record_session(self, user_id: int, start_time: int, duration: int) -> None: if user_id not in self.sessions: self.sessions[user_id] = [] self.sessions[user_id].append((start_time, duration)) def query_user_sessions(self, user_id: int, start_time: int, end_time: int) -> int: if user_id not in self.sessions: return 0 total_duration = 0 for session_start, session_duration in self.sessions[user_id]: session_end = session_start + session_duration if session_start < end_time and session_end > start_time: total_duration += min(session_end, end_time) - max(session_start, start_time) return total_duration"},{"question":"# Fibonacci Sequence Checker Develop a function `is_fibonacci` that determines whether a given number is a term in the Fibonacci sequence. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Write a function `is_fibonacci` that accepts an integer and returns a boolean indicating whether the number is part of the Fibonacci sequence. # Implementation Details: - **Input**: - `n` (int): The number to check. - **Output**: - `bool`: `True` if `n` is a term in the Fibonacci sequence, `False` otherwise. - **Constraints**: - `n` >= 0 # Requirements Your function should be efficient and able to handle large input values within a reasonable time frame. Using properties of Fibonacci numbers may be helpful. # Examples ```python >>> is_fibonacci(21) True >>> is_fibonacci(22) False >>> is_fibonacci(0) True >>> is_fibonacci(1) True >>> is_fibonacci(34) True ``` # Implementation Hints The Fibonacci sequence can be mathematically determined by checking if 5*n^2 + 4 or 5*n^2 - 4 is a perfect square, as any number n is a Fibonacci number if and only if one of these expressions yields a perfect square.","solution":"import math def is_fibonacci(n): Checks if a given number n is a term in the Fibonacci sequence. Parameters: n (int): The number to check. Returns: bool: True if n is a Fibonacci number, False otherwise. # A helper function to check if a number is a perfect square. def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x # A number n is a Fibonacci number if and only if one of these is true: # 5*n^2 + 4 or 5*n^2 - 4 is a perfect square. if is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4): return True else: return False"},{"question":"Scenario: You are part of a software development team working on an e-commerce platform. The platform offers personalized product recommendations based on user behavior such as views, purchases, and reviews. Users can also maintain wishlists specifying products they wish to buy in the future. To enhance the recommendation system, you need to analyze and manipulate user data, which includes their wishlist information. Problem Statement: Implement a Python function that updates a user\'s wishlist by adding or removing products based on specified actions. # Function Specification ```python def update_wishlist( wishlist: list, actions: dict ) -> list: Updates the user\'s wishlist based on specified actions. :param wishlist: A list of strings representing the product IDs in the user\'s wishlist. :param actions: A dictionary where keys are action strings (\'add\' or \'remove\') and values are lists of product IDs to be added or removed from the wishlist. :return: A list of strings representing the updated wishlist. :raises ValueError: If an action other than \'add\' or \'remove\' is encountered. pass ``` # Input - `wishlist`: A list of strings where each string is a product ID representing the user\'s current wishlist. - `actions`: A dictionary with two possible keys (\'add\' and \'remove\') and values being lists of product IDs to be added or removed from the wishlist. # Output - A list of strings representing the updated wishlist. # Constraints - Product IDs will always be strings. - The `actions` dictionary will only contain the keys \'add\' and \'remove\'. - If there are duplicate actions for the same product, handle them in the order they appear. - Raise a `ValueError` if any action other than \'add\' or \'remove\' is encountered in the `actions` dictionary. # Examples ```python # Updating wishlist by adding and removing products wishlist = [\\"p1\\", \\"p3\\", \\"p5\\"] actions = { \\"add\\": [\\"p2\\", \\"p4\\"], \\"remove\\": [\\"p3\\"] } updated_wishlist = update_wishlist(wishlist, actions) print(updated_wishlist) # Expected Output: [\\"p1\\", \\"p5\\", \\"p2\\", \\"p4\\"] # Attempting to remove a product not in the wishlist wishlist = [\\"p1\\", \\"p3\\", \\"p5\\"] actions = { \\"add\\": [\\"p2\\"], \\"remove\\": [\\"p4\\"] } updated_wishlist = update_wishlist(wishlist, actions) print(updated_wishlist) # Expected Output: [\\"p1\\", \\"p3\\", \\"p5\\", \\"p2\\"] # Handling only \'add\' actions wishlist = [\\"p1\\", \\"p2\\"] actions = { \\"add\\": [\\"p3\\", \\"p4\\"] } updated_wishlist = update_wishlist(wishlist, actions) print(updated_wishlist) # Expected Output: [\\"p1\\", \\"p2\\", \\"p3\\", \\"p4\\"] # Handling invalid action (an example meant to illustrate error handling) wishlist = [\\"p1\\", \\"p3\\"] actions = { \\"update\\": [\\"p2\\"] } try: updated_wishlist = update_wishlist(wishlist, actions) except ValueError as e: print(e) # Expected Output: ValueError: Unsupported action type encountered. ``` # Notes - Ensure the function performs validations to handle incorrect inputs, including wrong action types. - The wishlist should not contain duplicate product IDs at any time. - Maintain the order of products in the wishlist as per the actions performed.","solution":"def update_wishlist(wishlist: list, actions: dict) -> list: Updates the user\'s wishlist based on specified actions. :param wishlist: A list of strings representing the product IDs in the user\'s wishlist. :param actions: A dictionary where keys are action strings (\'add\' or \'remove\') and values are lists of product IDs to be added or removed from the wishlist. :return: A list of strings representing the updated wishlist. :raises ValueError: If an action other than \'add\' or \'remove\' is encountered. # Convert wishlist to a set for faster removal operations wishlist_set = set(wishlist) for action, products in actions.items(): if action == \\"add\\": for product in products: wishlist_set.add(product) elif action == \\"remove\\": for product in products: wishlist_set.discard(product) # discard does not raise an error if product not present else: raise ValueError(\\"Unsupported action type encountered.\\") # Return the updated wishlist as a list, sorted to maintain initial order without duplicates return [product for product in wishlist if product in wishlist_set] + [product for product in actions.get(\\"add\\", []) if product in wishlist_set and product not in wishlist]"},{"question":"# Scenario You are working with a database of student records and need to perform searches based on different attributes such as student ID, first name, last name, and GPA. Your job is to implement a search function that can handle multiple criteria searches efficiently. # Task Write a function that takes a list of student records and a search query, then returns the list of students that match the given criteria. # Function Signature ```python def search_students(students: List[Dict[str, Any]], query: Dict[str, Any]) -> List[Dict[str, Any]]: ``` # Input - `students`: A list of dictionaries, where each dictionary represents a student record with the following keys: - `id`: Integer, the unique student ID. - `first_name`: String, the student\'s first name. - `last_name`: String, the student\'s last name. - `gpa`: Float, the student\'s GPA. - `query`: A dictionary containing search criteria, which may include any combination of the keys in the student records (`id`, `first_name`, `last_name`, `gpa`). # Output - The function returns a list of dictionaries, each representing a student record that matches the given search criteria. # Constraints - The list of students may contain up to 1000 records. - Search criteria in the query dictionary may include exact matches for `id`, partial matches for `first_name` or `last_name`, or a GPA range. - GPA range in the query is specified with two keys: `gpa_min` and `gpa_max`. # Examples Example 1: ```python students = [ {\\"id\\": 1, \\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"gpa\\": 3.5}, {\\"id\\": 2, \\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\", \\"gpa\\": 3.8}, {\\"id\\": 3, \\"first_name\\": \\"Alice\\", \\"last_name\\": \\"Johnson\\", \\"gpa\\": 3.2}, {\\"id\\": 4, \\"first_name\\": \\"Bob\\", \\"last_name\\": \\"Brown\\", \\"gpa\\": 3.0} ] query = {\\"first_name\\": \\"J\\", \\"gpa_min\\": 3.0, \\"gpa_max\\": 3.5} result = search_students(students, query) ``` Expected Output ```python [ {\\"id\\": 1, \\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"gpa\\": 3.5}, {\\"id\\": 3, \\"first_name\\": \\"Alice\\", \\"last_name\\": \\"Johnson\\", \\"gpa\\": 3.2} ] ``` Example 2: ```python students = [ {\\"id\\": 1, \\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"gpa\\": 3.5}, {\\"id\\": 2, \\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\", \\"gpa\\": 3.8}, {\\"id\\": 3, \\"first_name\\": \\"Alice\\", \\"last_name\\": \\"Johnson\\", \\"gpa\\": 3.2}, {\\"id\\": 4, \\"first_name\\": \\"Bob\\", \\"last_name\\": \\"Brown\\", \\"gpa\\": 3.0} ] query = {\\"id\\": 2} result = search_students(students, query) ``` Expected Output ```python [ {\\"id\\": 2, \\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\", \\"gpa\\": 3.8} ] ``` **Note**: Ensure that your function is efficient and handles the constraints effectively. Pay special attention to implementing partial matches for names and GPA range filters accurately.","solution":"from typing import List, Dict, Any def search_students(students: List[Dict[str, Any]], query: Dict[str, Any]) -> List[Dict[str, Any]]: results = [] for student in students: match = True if \'id\' in query and query[\'id\'] != student[\'id\']: match = False if \'first_name\' in query and query[\'first_name\'].lower() not in student[\'first_name\'].lower(): match = False if \'last_name\' in query and query[\'last_name\'].lower() not in student[\'last_name\'].lower(): match = False if \'gpa_min\' in query and student[\'gpa\'] < query[\'gpa_min\']: match = False if \'gpa_max\' in query and student[\'gpa\'] > query[\'gpa_max\']: match = False if match: results.append(student) return results"},{"question":"# Problem Description You are required to implement a utility function to normalize a list of mixed data types into a consistent format. Specifically, you will convert all items in a given list to their string representation. This utility is important for preparing diverse datasets for consistent processing and storage. # Function Requirements Write a function `normalize_list` that takes a list of items of various data types and returns a list where each item has been converted to its string representation. Input * `items` (List[Any]): A list containing items of various data types (e.g., integers, floats, strings, booleans). Output * List[str]: A list where each item from the input list is converted to its string representation. Constraints 1. The list of items will contain at most 1,000 items. 2. Each item can be of any built-in Python data type including but not limited to integers, floats, strings, and booleans. # Examples ```python assert normalize_list([1, \'two\', 3.0, True, None]) == [\'1\', \'two\', \'3.0\', \'True\', \'None\'] assert normalize_list([]) == [] assert normalize_list([123, 456.789, \'example\']) == [\'123\', \'456.789\', \'example\'] ``` # Instructions 1. Ensure your function efficiently handles the conversion for each data type found in the list. 2. Test your implementation with the provided examples to ensure correctness. 3. Consider edge cases such as empty lists or mixed data types.","solution":"def normalize_list(items): Converts all items in the given list to their string representation. Parameters: items (list): A list containing items of various data types. Returns: list: A list where each item has been converted to its string representation. return [str(item) for item in items]"},{"question":"# Problem Statement You are assigned the task of writing a function that simulates the `replace` method found in various programming languages. Your function should take an input string, a target substring, and a replacement substring, then return a new string where all occurrences of the target substring are replaced with the replacement substring. # Function Signature ```python def custom_replace(string: str, target: str, replacement: str) -> str: Replaces all occurrences of the target substring with the replacement substring in the given string. :param string: The original input string. :param target: The substring to be replaced. :param replacement: The substring to replace the target with. :return: A new string with all occurrences of the target replaced by the replacement. ``` # Input Format * The `string` parameter is a non-empty string of ASCII characters. * The `target` parameter is a non-empty substring of ASCII characters. * The `replacement` parameter is a (possibly empty) string of ASCII characters. # Output Format * A new string after replacing all occurrences of the target substring with the replacement substring. # Constraints * The input string will have a length of (1 leq |text{string}| leq 10^5). * The target substring will have a length of (1 leq |text{target}| leq 10^3). * Both `string` and `target` will contain only printable ASCII characters. * The target substring will appear in the string at least once. # Example ```python >>> custom_replace(\\"the quick brown fox\\", \\"quick\\", \\"slow\\") \\"the slow brown fox\\" >>> custom_replace(\\"aaaa\\", \\"a\\", \\"ab\\") \\"abababab\\" >>> custom_replace(\\"hello world\\", \\"world\\", \\"there\\") \\"hello there\\" >>> custom_replace(\\"xyzxyz\\", \\"xyz\\", \\"\\") \\"\\" ``` # Explanation In the example `custom_replace(\\"the quick brown fox\\", \\"quick\\", \\"slow\\")`, the function replaces the target substring \\"quick\\" with the replacement substring \\"slow\\", resulting in \\"the slow brown fox\\". # Additional Notes Consider edge cases such as: * When the target substring appears multiple times consecutively in the string. * When the replacement string is empty, which effectively removes the target substrings from the original string. * Make sure the function handles large input sizes efficiently considering the provided constraints. Implement the function to conform to the given constraints and handle edge cases gracefully.","solution":"def custom_replace(string: str, target: str, replacement: str) -> str: Replaces all occurrences of the target substring with the replacement substring in the given string. :param string: The original input string. :param target: The substring to be replaced. :param replacement: The substring to replace the target with. :return: A new string with all occurrences of the target replaced by the replacement. return string.replace(target, replacement)"},{"question":"# Question: Implementing a Queue using Stacks Objective You are tasked to implement a queue data structure using two stacks. A queue is a collection that follows the First-In-First-Out (FIFO) principle, whereas a stack follows the Last-In-First-Out (LIFO) principle. Your task is to ensure enqueuing and dequeuing operations respect the FIFO order using two stacks. Class Signature ```python class QueueUsingStacks: def __init__(self): Initialize your data structure here. def enqueue(self, item: int) -> None: Add an element to the end of the queue. Parameters: item (int): The element to be added to the queue. def dequeue(self) -> int: Remove and return the element at the front of the queue. Returns: int: The element removed from the front of the queue. def peek(self) -> int: Get the front element of the queue. Returns: int: The element at the front of the queue. def empty(self) -> bool: Return whether the queue is empty. Returns: bool: True if the queue is empty, False otherwise. ``` Input - **item**: An integer to be added to the queue during `enqueue()`. Output - For `dequeue()`, return the element removed from the front of the queue. - For `peek()`, return the element at the front of the queue without removing it. - For `empty()`, return `True` if the queue is empty, otherwise return `False`. Constraints - The `enqueue()` method will only be called with valid integer inputs. - The `dequeue()` and `peek()` methods should return a message or raise an error if the queue is empty. - Ensure that all operations have an optimal time complexity, ideally amortized O(1) time complexity. Example Usage ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.empty()) # Output: False print(queue.dequeue()) # Output: 2 print(queue.empty()) # Output: True ``` Tips 1. Use two stacks, `stack1` and `stack2`. `stack1` will be used for enqueuing elements, and `stack2` will be used for dequeuing them. 2. Only transfer elements from `stack1` to `stack2` when `stack2` is empty and a dequeue operation is requested. 3. Think about edge cases, such as dequeuing from an empty queue.","solution":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, item: int) -> None: Add an element to the end of the queue. Parameters: item (int): The element to be added to the queue. self.stack1.append(item) def dequeue(self) -> int: Remove and return the element at the front of the queue. Returns: int: The element removed from the front of the queue. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2.pop() else: raise IndexError(\\"Dequeue from empty queue\\") def peek(self) -> int: Get the front element of the queue. Returns: int: The element at the front of the queue. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2[-1] else: raise IndexError(\\"Peek from empty queue\\") def empty(self) -> bool: Return whether the queue is empty. Returns: bool: True if the queue is empty, False otherwise. return not self.stack1 and not self.stack2"},{"question":"# Spell Checker You are tasked with developing a spell checker module that compares a given sentence against a dictionary of valid words. Your job is to implement a function that identifies the unknown words in the sentence, i.e., those not present in the dictionary. Function Specification: **Function Name**: `find_unknown_words` **Parameters**: * `sentence` (str): A string containing a sentence with words separated by spaces. * `dictionary` (List[str]): A list of strings representing the valid words. **Returns**: * `List[str]`: A list of strings representing the words from the sentence that are not present in the dictionary. The order of the words should match their order in the sentence. If all words are valid, return an empty list. Constraints: * All characters in the `sentence` and the `dictionary` are lowercase alphabets (a-z). * Words in the `sentence` are separated by a single space. * The `dictionary` can contain up to 10,000 words. * The `sentence` can have up to 1,000 words. Examples: 1. **Input**: ```python sentence = \\"hello world this is a test\\" dictionary = [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"valid\\", \\"sentence\\"] ``` **Output**: `[\\"test\\"]` 2. **Input**: ```python sentence = \\"programming languages like python are amazing\\" dictionary = [\\"programming\\", \\"languages\\", \\"like\\", \\"python\\", \\"are\\", \\"amazing\\"] ``` **Output**: `[]` 3. **Input**: ```python sentence = \\"check the weather before going for a hike\\" dictionary = [\\"check\\", \\"the\\", \\"weather\\", \\"before\\", \\"going\\", \\"for\\", \\"a\\"] ``` **Output**: `[\\"hike\\"]` Implement the function above to find unknown words based on the specified input and expected output formats.","solution":"def find_unknown_words(sentence, dictionary): Identifies the unknown words in a sentence based on a given dictionary of valid words. Parameters: sentence (str): A string containing a sentence with words separated by spaces. dictionary (List[str]): A list of strings representing the valid words. Returns: List[str]: A list of strings representing the words from the sentence that are not present in the dictionary. The order of the words should match their order in the sentence. If all words are valid, return an empty list. dictionary_set = set(dictionary) words = sentence.split() unknown_words = [word for word in words if word not in dictionary_set] return unknown_words"},{"question":"# Scenario: You are tasked with implementing a basic file system that supports directory creation and file addition functions. Each directory or file can have any name. # Requirements: 1. **Make Directory (mkdir) operation** should create a directory with the given path. 2. **Add File (add_file) operation** should add a file with a specified path and content in the file system. 3. **Read File (read_file) operation** should read the content of a specified file from the file system. # Function Specification: 1. **Make Directory Function**: ```python class FileSystem: def __init__(self): Initializes the file system with the root directory. # Your implementation here def mkdir(self, path: str) -> None: Creates a directory at the specified path in the file system. Parameters: path (str): Path where the directory should be created. # Your implementation here ``` 2. **Add File Function**: ```python def add_file(self, file_path: str, content: str) -> None: Adds a file with specified content at the specified path in the file system. Parameters: file_path (str): Path where the file should be added. content (str): The content to be stored in the file. # Your implementation here ``` 3. **Read File Function**: ```python def read_file(self, file_path: str) -> str: Reads the content of the file at the specified path in the file system. Parameters: file_path (str): Path to the file that needs to be read. Returns: str: Content of the file. # Your implementation here ``` # Constraints: - **Path Length**: 1 <= length of any path <= 300 - **Content Length**: 1 <= length of content <= 10^4 - **Path Characters**: The path can contain English alphabet letters (a-z, A-Z), numbers (0-9), forward slashes (/), and periods (.). # Performance Requirements: - Every operation should be efficient and handle up to 10^4 paths or files. # Example Usage: ```python # Initialize the file system fs = FileSystem() # Make directories fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/d/e/f\\") # Add files fs.add_file(\\"/a/b/c/file1.txt\\", \\"Hello World\\") fs.add_file(\\"/d/e/f/file2.txt\\", \\"Goodbye World\\") # Read file contents content1 = fs.read_file(\\"/a/b/c/file1.txt\\") # Should return \\"Hello World\\" content2 = fs.read_file(\\"/d/e/f/file2.txt\\") # Should return \\"Goodbye World\\" ``` Ensure that the operations mkdir, add_file, and read_file follow the constraints and perform efficiently.","solution":"class FileSystem: def __init__(self): Initializes the file system with the root directory. self.fs = {} def mkdir(self, path: str) -> None: Creates a directory at the specified path in the file system. parts = path.strip(\'/\').split(\'/\') current = self.fs for part in parts: if part not in current: current[part] = {} current = current[part] def add_file(self, file_path: str, content: str) -> None: Adds a file with specified content at the specified path in the file system. parts = file_path.strip(\'/\').split(\'/\') current = self.fs for part in parts[:-1]: if part not in current: current[part] = {} current = current[part] current[parts[-1]] = content def read_file(self, file_path: str) -> str: Reads the content of the file at the specified path in the file system. parts = file_path.strip(\'/\').split(\'/\') current = self.fs for part in parts[:-1]: if part not in current: return \'\' current = current[part] return current.get(parts[-1], \'\')"},{"question":"# Coding Question Context In many applications such as navigation systems, robotics, and gaming, it\'s important to understand how to work with 2D vectors. A vector in a 2D space can be represented by its components (x) and (y). Basic operations on vectors include addition, subtraction, scalar multiplication, and calculating the dot product. Implement functions that facilitate these operations on 2D vectors. Tasks 1. Implement a function `add_vectors` to add two 2D vectors. 2. Implement a function `subtract_vectors` to subtract the second 2D vector from the first one. 3. Implement a function `scalar_multiply_vector` to multiply a 2D vector by a scalar. 4. Implement a function `dot_product` to calculate the dot product of two 2D vectors. # Function Signatures ```python def add_vectors(vector1: (float, float), vector2: (float, float)) -> (float, float): # your code here def subtract_vectors(vector1: (float, float), vector2: (float, float)) -> (float, float): # your code here def scalar_multiply_vector(scalar: float, vector: (float, float)) -> (float, float): # your code here def dot_product(vector1: (float, float), vector2: (float, float)) -> float: # your code here ``` # Requirements - Each vector is represented as a tuple of two floats `(x, y)`. - The functions should perform the operations and return the results as specified. - Ensure correctness for edge cases such as zero vectors. # Constraints - The vector components and scalars can be any real number (positive, negative, or zero). # Example Usage ```python # Test cases for vector addition add_vectors((1, 2), (3, 4)) # should return (4, 6) # Test cases for vector subtraction subtract_vectors((5, 5), (2, 3)) # should return (3, 2) # Test cases for scalar multiplication scalar_multiply_vector(2, (1, -1)) # should return (2, -2) # Test cases for dot product dot_product((1, 2), (3, 4)) # should return 11 ``` Ensure your functions are well-tested and handle all possible edge cases appropriately.","solution":"def add_vectors(vector1, vector2): Returns the sum of two 2D vectors. return (vector1[0] + vector2[0], vector1[1] + vector2[1]) def subtract_vectors(vector1, vector2): Returns the difference between two 2D vectors. return (vector1[0] - vector2[0], vector1[1] - vector2[1]) def scalar_multiply_vector(scalar, vector): Returns the vector after multiplying with a scalar. return (scalar * vector[0], scalar * vector[1]) def dot_product(vector1, vector2): Returns the dot product of two 2D vectors. return vector1[0] * vector2[0] + vector1[1] * vector2[1]"},{"question":"# Problem Statement Design a system for managing a simple online bookstore. The system should support the addition of new books, searching for books by title, and updating the stock levels. Class: `Book` Implement the `Book` class that represents a book in the store. Class: `BookStore` Implement the `BookStore` class that manages a collection of books. **Attributes**: - `books` (Dict[str, Book]): A dictionary that maps book titles (str) to `Book` objects. ```python from typing import List, Dict, Optional class Book: def __init__(self, title: str, author: str, stock: int): self.title = title self.author = author self.stock = stock class BookStore: def __init__(self): self.books = {} def add_book(self, title: str, author: str, stock: int) -> None: Adds a new book to the store. if title in self.books: raise ValueError(\\"Book with this title already exists\\") self.books[title] = Book(title, author, stock) def search_books(self, search_term: str) -> List[Book]: Searches for books by title. return [book for book in self.books.values() if search_term.lower() in book.title.lower()] def update_stock(self, title: str, new_stock: int) -> None: Updates the stock level of a book. if title not in self.books: raise ValueError(\\"Book not found\\") self.books[title].stock = new_stock # Example Usage store = BookStore() store.add_book(\\"Python Programming\\", \\"John Doe\\", 5) store.add_book(\\"Advanced Python\\", \\"Jane Doe\\", 2) # Search books search_results = store.search_books(\\"Python\\") for book in search_results: print(f\\"{book.title} by {book.author}, Stock: {book.stock}\\") # Update stock store.update_stock(\\"Python Programming\\", 10) print(store.books[\\"Python Programming\\"].stock) # Output: 10 ``` Constraints 1. `title`, `author` will be non-empty strings. 2. `stock` and `new_stock` will be non-negative integers. 3. The `search_books` function should perform case-insensitive search on the book titles. Additional Requirements 1. Ensure your code correctly handles the scenario where a book title is not found. 2. Include necessary error handling, for example, when adding a book that already exists with the same title.","solution":"from typing import List, Dict, Optional class Book: def __init__(self, title: str, author: str, stock: int): self.title = title self.author = author self.stock = stock class BookStore: def __init__(self): self.books = {} def add_book(self, title: str, author: str, stock: int) -> None: Adds a new book to the store. if title in self.books: raise ValueError(\\"Book with this title already exists\\") self.books[title] = Book(title, author, stock) def search_books(self, search_term: str) -> List[Book]: Searches for books by title. return [book for book in self.books.values() if search_term.lower() in book.title.lower()] def update_stock(self, title: str, new_stock: int) -> None: Updates the stock level of a book. if title not in self.books: raise ValueError(\\"Book not found\\") self.books[title].stock = new_stock # Example Usage store = BookStore() store.add_book(\\"Python Programming\\", \\"John Doe\\", 5) store.add_book(\\"Advanced Python\\", \\"Jane Doe\\", 2) # Search books search_results = store.search_books(\\"Python\\") for book in search_results: print(f\\"{book.title} by {book.author}, Stock: {book.stock}\\") # Update stock store.update_stock(\\"Python Programming\\", 10) print(store.books[\\"Python Programming\\"].stock) # Output: 10"},{"question":"# Problem Statement You are managing a travel agency that deals with booking flights for customers. As part of the agency\'s objective to optimize the process, you need to implement a system that helps track flight bookings efficiently. # Goal Create a `FlightBookings` class that extends the provided `Bookings` class. Your task is to: 1. Implement a method to record new bookings by flight and customer. 2. Implement a method to fetch all customers booked on a particular flight. 3. Implement a method to fetch all flights booked by a particular customer. 4. Ensure the system can handle the booking of flights with constraints on maximum bookings per flight effectively. # Implementation FlightBookings Class 1. **Record Booking** * Implement the `record_booking` method to add a customer booking for a specific flight. * If the flight is already fully booked (exceeds the maximum allowed for that flight), it should not allow the booking and return an appropriate message. 2. **Fetch Customers by Flight** * Implement the `get_customers_by_flight` method to fetch a list of customers who have booked a specified flight. 3. **Fetch Flights by Customer** * Implement the `get_flights_by_customer` method to fetch a list of flights booked by a specified customer. Input and Output Format ```python class FlightBookings(Bookings): def record_booking(self, flight, customer): # Implementation for recording bookings def get_customers_by_flight(self, flight): # Implementation for fetching customers by flight def get_flights_by_customer(self, customer): # Implementation for fetching flights by customer # Expected Input fb = FlightBookings(max_per_flight=5) fb.record_booking(\\"AA123\\", \\"John Doe\\") fb.record_booking(\\"AA123\\", \\"Jane Smith\\") print(fb.get_customers_by_flight(\\"AA123\\")) # Expected Output: List of customers for flight AA123 print(fb.get_flights_by_customer(\\"John Doe\\")) # Expected Output: List of flights for John Doe # Constraint # Each flight can only have a maximum of \'max_per_flight\' bookings. ``` # Constraints and Performance Requirements 1. The system should handle at least 1,000 different flights and 10,000 customers efficiently. 2. Both the record booking and fetch operations should be optimized for quick lookups. # Example Scenario ```python # Create a FlightBookings object with a maximum of 3 bookings per flight fb = FlightBookings(max_per_flight=3) # Record bookings fb.record_booking(\\"AA123\\", \\"John Doe\\") fb.record_booking(\\"AA123\\", \\"Jane Smith\\") fb.record_booking(\\"AA123\\", \\"Alice Johnson\\") # Attempt to overbook fb.record_booking(\\"AA123\\", \\"Bob Brown\\") # Should return a message indicating the flight is fully booked # Fetch customers by flight print(fb.get_customers_by_flight(\\"AA123\\")) # Expected: [\'John Doe\', \'Jane Smith\', \'Alice Johnson\'] # Fetch flights by customer print(fb.get_flights_by_customer(\\"John Doe\\")) # Expected: [\'AA123\'] ``` # Write your FlightBookings class below: ```python class Bookings: def __init__(self, max_per_flight): self.max_per_flight = max_per_flight self.bookings = {} class FlightBookings(Bookings): def record_booking(self, flight, customer): if flight not in self.bookings: self.bookings[flight] = [] if len(self.bookings[flight]) < self.max_per_flight: self.bookings[flight].append(customer) else: return \\"Flight is fully booked.\\" def get_customers_by_flight(self, flight): return self.bookings.get(flight, []) def get_flights_by_customer(self, customer): return [flight for flight in self.bookings if customer in self.bookings[flight]] ``` **Note:** Ensure the methods are called correctly, and the constraints such as the maximum booking per flight are adhered to while recording new bookings.","solution":"class Bookings: def __init__(self, max_per_flight): self.max_per_flight = max_per_flight self.bookings = {} class FlightBookings(Bookings): def record_booking(self, flight, customer): if flight not in self.bookings: self.bookings[flight] = [] if len(self.bookings[flight]) < self.max_per_flight: self.bookings[flight].append(customer) else: return \\"Flight is fully booked.\\" def get_customers_by_flight(self, flight): return self.bookings.get(flight, []) def get_flights_by_customer(self, customer): return [flight for flight in self.bookings if customer in self.bookings[flight]]"},{"question":"# Coding Assessment Question In a simulation plant, a group of pumps work to distribute water evenly across a number of reservoirs. Each pump has a predefined capacity and a unique operational cost. Given the capacities and costs of the pumps, as well as the total water needed for the reservoirs, your task is to determine the minimum cost to distribute exactly the necessary amount of water. You are provided with a list of pumps, where each pump is represented by a tuple containing its capacity and operational cost. You need to write a function that determines the minimum cost required to supply the exact amount of water needed. # Function Signature ```python def min_pumping_cost(pumps: List[Tuple[int, int]], total_water: int) -> int: pass ``` # Input * `pumps` (list of tuples): Each tuple contains two integers: - `capacity` (integer): the amount of water the pump can distribute. - `cost` (integer): the operational cost of running the pump. * `total_water` (integer): the total amount of water that needs to be distributed among the reservoirs. # Output * Returns an integer representing the minimum pumping cost to distribute exactly `total_water`. # Constraints * 1 ≤ len(pumps) ≤ 20 * 1 ≤ capacity of each pump ≤ 50 * 1 ≤ cost of each pump ≤ 100 * 1 ≤ total_water ≤ 1000 # Examples ```python # Example 1: # Given pumps [(5, 10), (10, 20)], and total_water = 15 # We can use both pumps, so min cost is 10 + 20 = 30 assert min_pumping_cost([(5, 10), (10, 20)], 15) == 30 # Example 2: # Given pumps [(7, 14), (3, 7)], and total_water = 10 # We can use both pumps, so min cost is 14 + 7 = 21 assert min_pumping_cost([(7, 14), (3, 7)], 10) == 21 # Example 3: # Given pumps [(10, 200)], and total_water = 10 # We only need the single pump, so min cost is 200 assert min_pumping_cost([(10, 200)], 10) == 200 ``` # Explanation The function should: 1. Explore all possible combinations of pumps to achieve the total required water. 2. Calculate the operational cost for each valid combination. 3. Determine the combination with the lowest operational cost that exactly meets the total_water requirement. # Notes - Ensure that the sum of the capacities of the chosen pumps equals the total_water. - Consider all possible subsets of pumps for an optimal solution. - Utilize dynamic programming or other suitable approaches to efficiently compute the result within the given constraints.","solution":"from typing import List, Tuple def min_pumping_cost(pumps: List[Tuple[int, int]], total_water: int) -> int: # Initialize dp array where dp[i] will be the minimum cost to get i amount of water dp = [float(\'inf\')] * (total_water + 1) dp[0] = 0 # Base case: 0 water needed, no cost # Iterate over each pump for capacity, cost in pumps: # Update the dp array from back to front for j in range(total_water, capacity - 1, -1): dp[j] = min(dp[j], dp[j - capacity] + cost) return dp[total_water] if dp[total_water] != float(\'inf\') else -1"},{"question":"# Coding Assessment Question Objective You are tasked with finding the longest common suffix among a list of strings. If there is no common suffix, return an empty string. Problem Statement Given a list of strings, determine the longest suffix that all the strings share. A suffix is any sequence of characters that occur at the end of a string. For example, the longest common suffix of the strings \\"processing\\", \\"sing\\", and \\"wing\\" is \\"ing\\". Write a function that: 1. Finds the longest common suffix among the provided strings. 2. Returns this common suffix as a string. Your task is to implement the following function: ```python def longest_common_suffix(strings: List[str]) -> str: pass ``` Input - `strings`: (1 ≤ len(strings) ≤ 1000, 1 ≤ len(strings[i]) ≤ 1000) - A list of strings to find the common suffix. Output - Return the longest common suffix as a string. If no common suffix exists, return an empty string. Example ```python >>> longest_common_suffix([\\"processing\\", \\"sing\\", \\"wing\\"]) \\"ing\\" >>> longest_common_suffix([\\"apple\\", \\"banana\\", \\"grape\\"]) \\"\\" ``` Constraints - The input list contains at least one string. - Each string is non-empty and consists only of lowercase English letters (`a-z`). - The performance must handle up to 1,000,000 characters in total input length efficiently. Hints 1. Consider reversing the strings to transform the suffix problem into a prefix problem. 2. Iterate through the characters from the end of each string. 3. Use efficient string manipulation techniques or libraries if necessary.","solution":"from typing import List def longest_common_suffix(strings: List[str]) -> str: if not strings: return \\"\\" # Reverse all strings to find the longest common prefix instead reversed_strings = [s[::-1] for s in strings] # Find the longest common prefix of the reversed strings def longest_common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" # Take the first string as the initial prefix prefix = strings[0] for s in strings[1:]: # Gradually reduce the prefix length until it fits the current string while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix common_prefix_reversed = longest_common_prefix(reversed_strings) # Reverse the result to get the common suffix return common_prefix_reversed[::-1]"},{"question":"# Question: Generate Fibonacci Sequence until a Given Number You need to implement a function that generates the Fibonacci sequence up to a given number `n`. The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on. **Input**: 1. An integer `n`, which is the limit up to which the Fibonacci sequence should be generated (inclusive). **Output**: - A list containing the Fibonacci sequence up to `n`. **Function Signature**: ```python def generate_fibonacci(n: int) -> list[int]: pass ``` # Constraints: 1. The input integer `n` will be between 0 and 10^{18}, inclusive. # Example: ```python >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8] >>> generate_fibonacci(1) [0, 1, 1] >>> generate_fibonacci(0) [0] >>> generate_fibonacci(34) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(4) [0, 1, 1, 2, 3] ``` # Explanation: - The first example returns `[0, 1, 1, 2, 3, 5, 8]` because these are the Fibonacci numbers less than or equal to `10`. - The second example returns `[0, 1, 1]` because these numbers are the initial Fibonacci numbers less than or equal to `1`. - The third example returns `[0]` as the sequence starts with 0. - The fourth example returns `[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]` and includes 34 since it matches the input limit. - The fifth example returns `[0, 1, 1, 2, 3]` for all Fibonacci numbers less than or equal to `4`. Your implementation should efficiently generate and return the Fibonacci sequence up to the given number `n`. Ensure to handle edge cases and validate the correctness of your solution.","solution":"def generate_fibonacci(n: int) -> list[int]: if n < 0: return [] fib_sequence = [0] if n == 0: return fib_sequence a, b = 0, 1 while b <= n: fib_sequence.append(b) a, b = b, a + b return fib_sequence"},{"question":"# Evaluate the Taylor Series for e^x **Scenario**: You are developing a mathematical utility module that includes various functions for numerical computations. One particular function you need to implement involves evaluating the exponential function (e^x) using its Taylor series expansion. **Problem Statement**: Implement a function `taylor_exponential` that takes in two inputs: 1. `x` - a floating-point number representing the exponent 2. `terms` - an integer representing the number of terms to include in the Taylor series The Taylor series expansion for (e^x) is given by: [ e^x = sum_{n=0}^{infty} frac{x^n}{n!} ] For computational purposes, the series can be approximated using a finite number of terms (`terms`). **Constraints**: - (x) can be any valid float. - `terms` must be a positive integer greater than 0. **Function Signature**: ```python def taylor_exponential(x: float, terms: int) -> float: pass ``` # Example ```python >>> taylor_exponential(1, 10) 2.7182818011463845 >>> taylor_exponential(2, 15) 7.389056098930649 ``` # Notes: 1. If the input constraint for `terms` is violated, your function should raise a `ValueError` with an appropriate error message: \\"Number of terms must be a positive integer\\". 2. Utilize the math module for factorial computation: ```python import math ``` 3. Your implementation should efficiently compute the series sum by avoiding redundant calculations, such as by using a running product for (x^n). Make sure that your function handles edge cases, such as very small or very large values for `x`, gracefully.","solution":"import math def taylor_exponential(x: float, terms: int) -> float: Evaluates the exponential function e^x using its Taylor series expansion. Parameters: x (float): The exponent. terms (int): The number of terms to include in the Taylor series. Returns: float: The approximated value of e^x. if terms <= 0: raise ValueError(\\"Number of terms must be a positive integer\\") sum = 1.0 # Initializes the sum of series with the first term (n=0, which is 1) term_value = 1.0 # Term value x^n / n!, starts with x^0 / 0! = 1 for n in range(1, terms): term_value *= x / n # Iteratively calculating the term x^n / n! sum += term_value return sum"},{"question":"# Problem Description You have been given two non-empty strings `s1` and `s2`. The task is to determine whether the second string `s2` is a rotation of the first string `s1`. A string `s2` is a rotation of `s1` if and only if there exists a split of `s1` into two parts `x` and `y` such that `s1 = xy` and `s2 = yx`. # Implementation Details 1. **Function Signature**: ```python def is_string_rotation(s1: str, s2: str) -> bool: ``` 2. **Input**: - `s1`: A non-empty string of length `n` where `1 <= n <= 1000`. - `s2`: A non-empty string of length `n`. 3. **Output**: - Returns `True` if `s2` is a rotation of `s1`, otherwise returns `False`. # Constraints - The function should ideally run in O(n) time complexity. # Example ```python assert is_string_rotation(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_string_rotation(\\"hello\\", \\"llohe\\") == True assert is_string_rotation(\\"hello\\", \\"ollhe\\") == False assert is_string_rotation(\\"abc\\", \\"cab\\") == True assert is_string_rotation(\\"rotation\\", \\"rotation\\") == True assert is_string_rotation(\\"abc\\", \\"abc \\") == False ``` # Additional Notes 1. Consider the special case where `s1` and `s2` are identical. 2. Ensure the solution handles cases with spaces and mixed characters. 3. An efficient way to solve this problem is to concatenate `s1` with itself and check if `s2` is a substring of the concatenated result. Good luck and happy coding!","solution":"def is_string_rotation(s1: str, s2: str) -> bool: Determine if s2 is a rotation of s1. A string s2 is a rotation of s1 if and only if there exists a split of s1 into two parts x and y such that s1 = xy and s2 = yx. Parameters: s1 (str): The original string. s2 (str): The string to test for rotation. Returns: bool: True if s2 is a rotation of s1, False otherwise. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"# Question: Implement an Upgraded Stack with Multi-Feature Enhancements You need to design and implement a stack data structure that combines additional features for enhanced functionality. **Features to Implement**: 1. **Maximum Value Tracking**: The stack should support constant time retrieval of the maximum value within the stack. 2. **Minimum Value Tracking**: Similarly, it should also support constant time retrieval of the minimum value in the stack. 3. **Custom Transformation Operations**: Implement methods that allow applying custom transformations to the elements within the stack, such as mapping a function or filtering elements based on a provided condition. # Function Definitions: ```python class EnhancedStack: def __init__(self) -> None: Initialize an empty stack with additional data structures to track max and min values. pass def push(self, value: int) -> None: Push a value onto the stack and update the max and min tracking. Args: value (int): Integer value to be pushed onto the stack. pass def pop(self) -> int: Pop a value from the stack and update the max and min tracking. Returns: int: The popped value from the stack. Raises: IndexError: If the stack is empty. pass def max(self) -> int: Retrieve the current maximum value in the stack. Returns: int: Maximum value in the stack. Raises: ValueError: If the stack is empty. pass def min(self) -> int: Retrieve the current minimum value in the stack. Returns: int: Minimum value in the stack. Raises: ValueError: If the stack is empty. pass def apply_map(self, func: callable) -> None: Apply a mapping function to each element in the stack. Args: func (callable): A function to apply to each element in the stack. pass def apply_filter(self, condition: callable) -> None: Apply a filter condition to the stack, removing elements that do not meet the condition. Args: condition (callable): A function that returns True for elements to retain and False for elements to remove. pass ``` Input Format: 1. For `push`: `(value)` where `value` is an integer to be added to the stack. 2. For `pop`: No additional input. 3. For `max` and `min`: No additional input. 4. For `apply_map`: `(func)` where `func` is a callable that takes an integer and returns a transformed integer. 5. For `apply_filter`: `(condition)` where `condition` is a callable that takes an integer and returns a boolean. Output Format: 1. For `pop`: Returns the integer value that was removed from the stack. 2. For `max` and `min`: Returns the maximum or minimum value in the stack. 3. For `apply_map` and `apply_filter`: No direct return value, but modifies the stack in place. Constraints: - All operations should be performed with efficiency in mind. - Handle edge cases such as operations on an empty stack appropriately. - Ensure that `apply_map` and `apply_filter` methods can handle potential modifications of the stack\'s size. Example Usage: ```python # Creating an instance of EnhancedStack stack = EnhancedStack() # Pushing values onto the stack stack.push(10) stack.push(5) stack.push(15) # Retrieve max and min print(stack.max()) # Output: 15 print(stack.min()) # Output: 5 # Pop a value print(stack.pop()) # Output: 15 # Apply a map function to double each element stack.apply_map(lambda x: x * 2) # Apply a filter to remove all elements less than 10 stack.apply_filter(lambda x: x >= 10) ```","solution":"class EnhancedStack: def __init__(self) -> None: self.stack = [] self.max_stack = [] self.min_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"Pop from empty stack\\") value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def max(self) -> int: if not self.max_stack: raise ValueError(\\"Max from empty stack\\") return self.max_stack[-1] def min(self) -> int: if not self.min_stack: raise ValueError(\\"Min from empty stack\\") return self.min_stack[-1] def apply_map(self, func: callable) -> None: self.stack = [func(x) for x in self.stack] # Re-calculate max and min stacks self._recalculate_max_min() def apply_filter(self, condition: callable) -> None: self.stack = [x for x in self.stack if condition(x)] # Re-calculate max and min stacks self._recalculate_max_min() def _recalculate_max_min(self) -> None: self.max_stack = [] self.min_stack = [] for value in self.stack: if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value)"},{"question":"# Question Write a function named `flatten_dict` that takes a nested dictionary and returns a new dictionary where the keys are the concatenation of the nested keys, separated by a given delimiter. # Required Function Signature ```python def flatten_dict(d: dict, delimiter: str) -> dict: pass ``` # Requirements - The function takes two parameters: 1. `d`: a dictionary that may contain nested dictionaries as values. 2. `delimiter`: a string used to separate the concatenated keys in the flattened dictionary. - The function should handle dictionaries that are arbitrarily nested. # Examples ```python >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}, \\"_\\") {\'a\': 1, \'b_c\': 2, \'b_d_e\': 3} >>> flatten_dict({\\"x\\": {\\"y\\": {\\"z\\": 4}}, \\"p\\": 5}, \\".\\") {\'x.y.z\': 4, \'p\': 5} >>> flatten_dict({\\"name\\": {\\"first\\": \\"John\\", \\"last\\": \\"Doe\\"}, \\"age\\": 30}, \\"-\\") {\'name-first\': \'John\', \'name-last\': \'Doe\', \'age\': 30} >>> flatten_dict({}, \\":\\") {} >>> flatten_dict({\\"outer\\": {\\"inner\\": {\\"value\\": {\\"deep\\": \\"found\\"}}}}, \\"--\\") {\'outer--inner--value--deep\': \'found\'} ``` # Constraints * The keys in the input dictionary will be strings. * The input dictionary may be empty or only contain non-nested key-value pairs. * The delimiter will be a non-empty string. # Notes * Use recursion to handle nested dictionaries. * Make sure the resulting keys are valid and preserve the hierarchy of nested keys using the specified delimiter.","solution":"def flatten_dict(d: dict, delimiter: str) -> dict: def helper(sub_d, parent_key): items = [] for k, v in sub_d.items(): new_key = parent_key + delimiter + k if parent_key else k if isinstance(v, dict): items.extend(helper(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return helper(d, \\"\\")"},{"question":"# String Manipulation: Finding Substrings You have been tasked with implementing a function that finds all starting indices of a pattern string (`pat`) within a given text string (`txt`). Both strings are provided as input. The function needs to handle case insensitivity and return results sorted in ascending order. # Specifications: * **Function Name**: `find_substring_indices` * **Parameters**: - `txt` (str): The text string in which to search for occurrences of the pattern. - `pat` (str): The pattern string whose occurrences need to be found. * **Return**: A list of integers representing the starting indices of the pattern’s occurrences in the text, sorted in ascending order. If no occurrences are found, the function should return an empty list. # Constraints: * The `txt` and `pat` strings contain only ASCII characters. * The length of `txt` can be up to 10^6 characters. * The length of `pat` can be up to 10^3 characters. * The function must be case-insensitive and should not use any external libraries except for those in Python\'s standard library. # Example Usage: ```python txt = \\"Hello there, how are you? Hello again!\\" pat = \\"hello\\" result = find_substring_indices(txt, pat) print(result) # Output: [0, 28] txt = \\"ABcabcABC\\" pat = \\"abc\\" result = find_substring_indices(txt, pat) print(result) # Output: [0, 3, 6] ``` # Hints: * Consider converting both `txt` and `pat` to lowercase before processing to ensure case insensitivity. * Efficient string search algorithms like KMP (Knuth-Morris-Pratt) or the use of Python\'s built-in string operations might be helpful. Use appropriate data structures to store results before sorting if necessary. # Performance Requirements: * The solution should be efficient in terms of both time and space, aiming for a linear or near-linear time complexity relative to the length of the text for searching, plus the sorting complexity of the result list. # Implementation: Implement the `find_substring_indices` function within the constraints and ensure that it handles edge cases such as empty strings, no matches, and starting indices correctly. ```python def find_substring_indices(txt, pat): if not txt or not pat: return [] txt = txt.lower() pat = pat.lower() m, n = len(pat), len(txt) result = [] for i in range(n - m + 1): if txt[i:i + m] == pat: result.append(i) return result ``` Adjust the function definition, internal logic, and edge case handling as required to maintain efficiency and accuracy. Be sure to use proper style and comments to clearly guide the implementation process.","solution":"def find_substring_indices(txt, pat): if not txt or not pat: return [] txt = txt.lower() pat = pat.lower() m, n = len(pat), len(txt) result = [] # Sliding window approach to match pattern for i in range(n - m + 1): if txt[i:i + m] == pat: result.append(i) return result"},{"question":"# Problem Description You are given the details of a bus route in terms of the number of bus stops and the time intervals in minutes between each successive pair of bus stops. Your task is to determine the total journey time for completing the bus route, starting from the first bus stop and ending at the last one. # Function Signature ```python def total_journey_time(num_stops: int, intervals: list[int]) -> int: ``` # Parameters - **num_stops** (int): The total number of bus stops, which should be greater than or equal to 2. - **intervals** (list of int): A list containing the time intervals in minutes between each successive pair of bus stops. The length of this list will be `num_stops - 1`. # Returns - Returns an integer representing the total journey time in minutes from the first stop to the last stop. # Constraints - `2 <= num_stops <= 1000` - `1 <= intervals[i] <= 120` for all valid `i` # Examples ```python >>> total_journey_time(2, [5]) 5 >>> total_journey_time(5, [5, 10, 15, 20]) 50 >>> total_journey_time(3, [7, 11]) 18 >>> total_journey_time(4, [8, 3, 6]) 17 ``` # Additional Notes - Ensure that the function correctly handles the minimum and maximum constraints. - Focus on writing clean and efficient code. - Consider edge cases such as very short or very long bus routes and how they impact the total journey time.","solution":"def total_journey_time(num_stops: int, intervals: list[int]) -> int: Calculates the total journey time for completing the bus route. :param num_stops: The total number of bus stops. :param intervals: A list of time intervals in minutes between each successive pair of bus stops. :return: The total journey time in minutes. return sum(intervals)"},{"question":"# Valid Palindrome Check after Adjustment Context In many applications, it\'s essential to check if a string can be transformed into a palindrome by deleting at most one character. A palindrome is a word, phrase, or sequence of characters that reads the same backward as forward. Task You are required to write a Python function that takes a string and determines if it can be converted into a palindrome by removing at most one character. Ignore spaces, punctuation, and case differences while performing the check. Input - A single string representing the input to be checked. Output - A boolean value `True` if the string can be adjusted to a palindrome by removing at most one character; otherwise, `False`. Constraints - The input string will have a maximum length of 100,000 characters. - Consider only alphanumeric characters and ignore cases. - If the string is already a palindrome or can become one by removing one character, return `True`. - You should ignore spaces, punctuation, and case in determining palindromic potential. Examples ```python >>> valid_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> valid_palindrome(\\"raceacar\\") True >>> valid_palindrome(\\"abcdefg\\") False >>> valid_palindrome(\\"gag\\") True >>> valid_palindrome(\\"abccba\\") True >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"aaa\\") True >>> valid_palindrome(\\"madam\\") True >>> valid_palindrome(\\"a\\") True >>> valid_palindrome(\\" \\") True ``` Function Signature ```python def valid_palindrome(s: str) -> bool: pass ``` # Requirements 1. The function should clean the input by removing non-alphanumeric characters and converting it to lowercase. 2. Determine if the given or adjusted string is a palindrome when at most one character can be removed. 3. Implement an efficient solution to handle large strings within the given constraints.","solution":"import re def valid_palindrome(s: str) -> bool: def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() n = len(s) left, right = 0, n - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"# Question: Process Nested Lists into a Flattened Sorted List You are given a nested list of integers. Each inner list contains a sequence of integers which are guaranteed to be sorted in non-decreasing order. Your task is to implement a function that processes these nested lists and returns a single sorted, flattened list containing all the integers in non-decreasing order. # Function Signature ```python def flatten_and_sort(nested_list: List[List[int]]) -> List[int]: ``` # Input * `nested_list` (List[List[int]]): A list of sorted integer lists. The number of lists, `n`, is between 0 and 1000. Each inner list has at most 1000 elements. # Output * A single sorted list (List[int]) that contains all the integers from the nested_list in non-decreasing order. # Constraints * If `nested_list` is empty, return an empty list. * The integers are within the range `-10^6` to `10^6`. # Example ```python # Example 1 nested_list = [[1, 3, 5], [2, 4, 6], [0, 9, 10]] print(flatten_and_sort(nested_list)) # Output: [0, 1, 2, 3, 4, 5, 6, 9, 10] # Example 2 nested_list = [[], [-5, -3, -1], [2, 8]] print(flatten_and_sort(nested_list)) # Output: [-5, -3, -1, 2, 8] # Example 3 nested_list = [] print(flatten_and_sort(nested_list)) # Output: [] ``` # Additional Information * Assume that the `List` class from the `typing` module is pre-imported. * You may use standard Python libraries for sorting. Aim to create an efficient solution in terms of time complexity, ideally leveraging the fact that the inner lists are already sorted. # Note * Ensure to handle edge cases appropriately, such as when nested lists are empty or when there are negative integers in the lists.","solution":"from typing import List import heapq def flatten_and_sort(nested_list: List[List[int]]) -> List[int]: Processes a list of sorted integer lists and returns a single sorted, flattened list. Args: nested_list: List of sorted lists of integers. Returns: A flattened and sorted list containing all integers from nested_list. # We will use a heap to efficiently merge the sorted lists return list(heapq.merge(*nested_list))"},{"question":"# Sum of Unique Elements You need to write a function that calculates the sum of elements in a list that appear only once. The function should be optimized for performance. 1. Implement a function `sum_of_unique_elements` that takes a list of integers and returns the sum of elements that appear exactly once in the list. Input and Output Formats 1. **Function `sum_of_unique_elements(nums: List[int]) -> int`**: - **Input**: A list of integers. - **Output**: An integer representing the sum of elements that appear only once in the input list. Constraints - The length of the list `nums` will be `0 <= len(nums) <= 10^6`. - The elements of the list `nums` will be within the range `-10^6 <= nums[i] <= 10^6`. Example ```python assert sum_of_unique_elements([1, 2, 3, 2, 1]) == 3 # Only 3 appears once assert sum_of_unique_elements([4, 5, 6, 6, 7, 7, 4]) == 5 # Only 5 appears once assert sum_of_unique_elements([]) == 0 # No elements in the list. assert sum_of_unique_elements([10, 20, 30, 20, 10]) == 30 # Only 30 appears once ``` Write this function and ensure that the constraints and edge cases are properly handled.","solution":"from collections import Counter from typing import List def sum_of_unique_elements(nums: List[int]) -> int: Returns the sum of elements that appear only once in the input list. count = Counter(nums) return sum(num for num, cnt in count.items() if cnt == 1)"},{"question":"Implementing Softmax Function Context Softmax is a commonly used activation function in machine learning, particularly in classification tasks, because it converts logits (raw prediction scores) into probabilities. Your task is to implement the softmax function from scratch. Task Write a function `custom_softmax(vector: List[float]) -> List[float]` that returns a new list where the softmax function has been applied to each element. Input - `vector`: A list of float numbers, representing the input to the softmax function. Output - A list of float numbers, representing the probabilities corresponding to each input value after applying the softmax function. Constraints - The elements of the `vector` will be in the range [-100, 100]. - The length of the `vector` will not exceed 10^6. Example ```python >>> custom_softmax([1.0, 2.0, 3.0]) [0.09003057, 0.24472847, 0.66524096] >>> custom_softmax([-1.0, 0.0, 1.0]) [0.09003057, 0.24472847, 0.66524096] ``` Instructions 1. Implement the function `custom_softmax(vector: List[float]) -> List[float]`. 2. Ensure the function handles large inputs efficiently within the given constraints. 3. Verify your function with various test cases to cover inputs containing both large positive and large negative values.","solution":"from typing import List import math def custom_softmax(vector: List[float]) -> List[float]: Computes the softmax of a list of numbers, returning their probabilities. :param vector: A list of float numbers :return: A list of softmax probabilities corresponding to the input list if not vector: return [] max_val = max(vector) exps = [math.exp(i - max_val) for i in vector] sum_exps = sum(exps) return [j / sum_exps for j in exps]"},{"question":"# Coding Assessment Question Context You are given the task to perform a specific operation on strings containing only lowercase alphabets. Problem Statement Given a string `s`, rearrange the characters of the string such that no two identical characters are adjacent to each other. If rearranging is not possible, return an empty string `\\"\\"`. Write a function `rearrange_string` that implements this logic. Function Signature ```python def rearrange_string(s: str) -> str: Rearranges the characters of the input string such that no two identical characters are adjacent. If such a rearrangement is not possible, returns an empty string. Args: s : str : a string containing only lowercase alphabetical characters Returns: str: The rearranged string or an empty string if rearrangement isn\'t possible. pass ``` Constraints - The input string `s` will have a length such that ( 1 le text{len}(s) le 10^4 ). - All characters in `s` are lowercase English letters (`\'a\'` to `\'z\'`). Examples ```python # Example 1 print(rearrange_string(\\"aab\\")) # Output: \\"aba\\" (or any other valid rearrangement) # Example 2 print(rearrange_string(\\"aaab\\")) # Output: \\"\\" # Example 3 print(rearrange_string(\\"abc\\")) # Output: \\"abc\\" (or any other valid rearrangement) ``` **Note**: Aim for an efficient solution that effectively utilizes counting and prioritization methods to determine possible rearrangements.","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearranges the characters of the input string such that no two identical characters are adjacent. If such a rearrangement is not possible, returns an empty string. Args: s : str : a string containing only lowercase alphabetical characters Returns: str: The rearranged string or an empty string if rearrangement isn\'t possible. # Calculate the frequencies of each character char_count = Counter(s) # Create a max heap based on the counts of the characters max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged = \'\'.join(result) if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"# Context A local community center is developing an online system to manage the registration of participants in various courses. As part of this system, they need to determine the availability of certain courses based on the number of participants registered and the maximum capacity of those courses. # Problem Statement Write a function `check_course_availability(courses: Dict[str, Tuple[int, int]]) -> Dict[str, bool]` that takes a dictionary where the keys are course names and the values are tuples containing the number of registered participants and the maximum capacity of the course. The function should return a dictionary indicating whether each course is still available for registration. # Function Signature ```python def check_course_availability(courses: Dict[str, Tuple[int, int]]) -> Dict[str, bool]: pass ``` # Input 1. `courses` - a dictionary where each key is a string representing the course name and each value is a tuple of two integers: - The first integer represents the number of currently registered participants. - The second integer represents the maximum capacity of the course. # Output * A dictionary with the same keys as the input, where the value for each key is a boolean indicating whether the course is available for registration. # Examples 1. `check_course_availability({\\"Math101\\": (25, 30), \\"History202\\": (30, 30), \\"Science303\\": (28, 30)})` should return `{\\"Math101\\": True, \\"History202\\": False, \\"Science303\\": True}`. 2. `check_course_availability({\\"Yoga\\": (15, 20), \\"Cooking\\": (20, 20), \\"Dance\\": (18, 20)})` should return `{\\"Yoga\\": True, \\"Cooking\\": False, \\"Dance\\": True}`. 3. `check_course_availability({\\"Drawing\\": (5, 10), \\"Sculpture\\": (9, 10), \\"Painting\\": (10, 10)})` should return `{\\"Drawing\\": True, \\"Sculpture\\": True, \\"Painting\\": False}`. # Constraints * The number of courses will be between 1 and 100. * The number of registered participants and the maximum capacity for each course will be in the range of 1 to 1000. # Notes * Your solution should handle the check for availability accurately and efficiently. * Consider edge cases such as when the number of registered participants is equal to the capacity or just one less than the capacity.","solution":"def check_course_availability(courses): Returns a dictionary indicating whether each course is still available for registration. Parameters: - courses: Dict[str, Tuple[int, int]], a dictionary where the keys are course names and the values are tuples containing the number of registered participants and the maximum capacity of the course. Returns: - Dict[str, bool]: a dictionary indicating whether each course is available for registration. availability = {} for course, (registered, capacity) in courses.items(): availability[course] = registered < capacity return availability"},{"question":"# Problem Statement In a research database, authors and their published paper IDs are stored as key-value pairs in a dictionary. Occasionally, it is required to merge multiple author dictionaries and maintain a count of the number of papers each author has contributed. Your task is to write a function that takes a list of dictionaries, each representing authors and their respective paper contributions, and merge them into a single dictionary where each key is an author and each value is the total number of papers they have authored. # Task Implement the `merge_author_contributions` function which will take a list of author dictionaries and aggregate the paper counts accordingly. # Function Signature ```python def merge_author_contributions(author_dicts: list) -> dict: Aggregates the paper counts for authors from multiple dictionaries ``` # Input and Output * **Input**: A list of dictionaries, where each dictionary\'s keys are the authors and the values are the number of papers they have authored (e.g., `author_dicts = [{\'Alice\': 2, \'Bob\': 1}, {\'Alice\': 3, \'Charlie\': 1}]`). * **Output**: A single dictionary with aggregated paper counts for each author (e.g., `{\'Alice\': 5, \'Bob\': 1, \'Charlie\': 1}`). # Constraints * The input list can contain up to 10,000 dictionaries. * Each dictionary has up to 1,000 entries. * Authors are represented by strings. * The number of papers is a non-negative integer. # Example ```python >>> merge_author_contributions([{\'Alice\': 2, \'Bob\': 1}, {\'Alice\': 3, \'Charlie\': 1}]) {\'Alice\': 5, \'Bob\': 1, \'Charlie\': 1} >>> merge_author_contributions([{\'Alice\': 1}, {\'Bob\': 2}, {\'Alice\': 1, \'Bob\': 1, \'Charlie\': 3}]) {\'Alice\': 2, \'Bob\': 3, \'Charlie\': 3} >>> merge_author_contributions([{\'Dave\': 4}, {\'Eve\': 5}, {\'Eve\': 3, \'Frank\': 2}]) {\'Dave\': 4, \'Eve\': 8, \'Frank\': 2} ``` # Additional Notes * Assume no two dictionaries in the list will have the same author with both having zero papers. * Ensure the function handles large inputs efficiently. * Provide appropriate comments and document any special cases that need to be handled.","solution":"def merge_author_contributions(author_dicts: list) -> dict: Aggregates the paper counts for authors from multiple dictionaries. :param author_dicts: List of dictionaries with authors as keys and paper counts as values :return: A dictionary with total paper counts for each author merged_contributions = {} for author_dict in author_dicts: for author, count in author_dict.items(): if author in merged_contributions: merged_contributions[author] += count else: merged_contributions[author] = count return merged_contributions"},{"question":"# Scenario You are part of a team developing a file system for a new operating system. One of the tasks is to implement a function that counts the number of distinct subarrays of a given array of integers. A subarray is defined as any contiguous segment of the array. # Problem Statement Given an array of integers, write a function `count_distinct_subarrays(arr: List[int]) -> int` that returns the number of distinct subarrays within the given array. # Input * `arr` (List[int]): A list of integers (1 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6). # Output * Return the count of distinct subarrays as an integer. # Example ```python >>> count_distinct_subarrays([1, 2, 1]) 5 >>> count_distinct_subarrays([1, 2, 3, 1, 2]) 12 >>> count_distinct_subarrays([1, 1, 1]) 3 ``` # Explanation For the first example: - Distinct subarrays: [1], [2], [1, 2], [2, 1], [1, 2, 1] For the second example: - Distinct subarrays: [1], [2], [3], [1, 2], [2, 3], [3, 1], [1, 2], [2, 1], [3, 1, 2], [1, 2, 3], [2, 3, 1], [1, 2, 3, 1] # Constraints * The function should be efficient in terms of both time and space, considering the upper limits of the input size. # Note Consider using a sliding window approach combined with a set to track the distinct subarrays to ensure optimal performance.","solution":"def count_distinct_subarrays(arr): Returns the number of distinct subarrays in the given array. n = len(arr) unique_subarrays = set() for i in range(n): current_subarray = [] for j in range(i, n): current_subarray.append(arr[j]) # Add the tuple representation of the list to the set to ensure uniqueness unique_subarrays.add(tuple(current_subarray)) return len(unique_subarrays)"},{"question":"# Problem Statement: You\'re tasked with developing a matrix manipulation utility as part of a larger scientific computation software suite. One of the essential features required is the ability to rotate matrices by 90 degrees clockwise. # Requirements: 1. **Matrix Rotation**: Your function should take a 2D list, which represents an NxN matrix, and rotate the matrix by 90 degrees clockwise. 2. **In-Place Rotation**: The function should perform the rotation in place, meaning the original matrix should be modified, not a copy. 3. **Error Handling**: If the matrix is not square (i.e., not NxN), the function should raise a `ValueError` with an appropriate error message. # Constraints: * The matrix can have sizes up to 500x500 elements. * You cannot use any external libraries, only built-in Python functions and data structures. # Function Signature: ```python def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: pass ``` # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # After rotation function call: # matrix should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Task: Implement the `rotate_matrix_90_clockwise` function which rotates the given matrix by 90 degrees clockwise in place. # Hint: Consider how the positions of elements need to be shifted to achieve the desired rotation and implement it step-by-step using index manipulation.","solution":"def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in place. Parameters: matrix (list[list[int]]): 2D list representing the NxN matrix to be rotated. Raises: ValueError: If the matrix is not NxN. n = len(matrix) # Validate the matrix is NxN for row in matrix: if len(row) != n: raise ValueError(\\"The matrix is not NxN\\") for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # Move left to top matrix[first][i] = matrix[last - offset][first] # Move bottom to left matrix[last - offset][first] = matrix[last][last - offset] # Move right to bottom matrix[last][last - offset] = matrix[i][last] # Move top to right matrix[i][last] = top"},{"question":"# Coding Assessment Question: String Transformation and Compression Objective You are tasked with developing a new class called `StringTransformer` for efficient string manipulation that includes methods for string compression, decompression, and transformation. Requirements 1. **String Compression**: Implement a method to compress a given string using basic run-length encoding. 2. **String Decompression**: Implement a method to decompress a string that was compressed using run-length encoding. 3. **String Transformation**: Implement a method to apply a series of transformations to a string based on character shift operations. Method Specifications - **Compression and Decompression Methods**: 1. `compress(self, s: str) -> str`: Compress the input string `s` by replacing consecutive repeated characters with the character followed by the count of repetitions. 2. `decompress(self, s: str) -> str`: Decompress a run-length encoded string back to its original form. - **Transformation Method**: 1. `transform(self, s: str, shifts: List[int]) -> str`: Apply a series of character shifts to the string `s`. Each character in `s` is shifted by the corresponding value in `shifts`. If shifts length is shorter than the string length, repeat the shifts cyclically. # Input and Output Formats - **Input**: The input string will be a non-empty string containing lowercase English letters only. - **Output**: The methods should return the appropriately transformed or compressed/decompressed string. # Constraints - `1 <= len(s) <= 100` - Characters in the input string are only lowercase English letters (a-z). - Shift values in the `shifts` list will be integers within the range [-25, 25]. # Function Signature ```python def compress(self, s: str) -> str: pass def decompress(self, s: str) -> str: pass def transform(self, s: str, shifts: List[int]) -> str: pass ``` # Example Usage: ```python string_transformer = StringTransformer() # String compression compressed_string = string_transformer.compress(\\"aaabbbccc\\") print(compressed_string) # Output should be \\"a3b3c3\\" # String decompression decompressed_string = string_transformer.decompress(\\"a3b3c3\\") print(decompressed_string) # Output should be \\"aaabbbccc\\" # String transformation transformed_string = string_transformer.transform(\\"abc\\", [1, -1, 3]) print(transformed_string) # Output should be \\"baf\\" ``` # Explanation 1. The `compress` method takes a string and applies run-length encoding to compact the string. 2. The `decompress` method reverses the run-length encoding to retrieve the original string. 3. The `transform` method applies character shifts to each character in the string as per the given shifts list. This question tests string manipulation skills, compression algorithms, and cyclic character transformations, ensuring alignment with general programming concepts and medium complexity.","solution":"class StringTransformer: def compress(self, s: str) -> str: if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] + str(count)) count = 1 result.append(s[-1] + str(count)) # Append the last character and count return \'\'.join(result) def decompress(self, s: str) -> str: result = [] i = 0 while i < len(s): char = s[i] count = 0 i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 result.append(char * count) return \'\'.join(result) def transform(self, s: str, shifts: list[int]) -> str: result = [] n = len(shifts) for i, char in enumerate(s): shift_value = shifts[i % n] new_char = chr((ord(char) - ord(\'a\') + shift_value) % 26 + ord(\'a\')) result.append(new_char) return \'\'.join(result)"},{"question":"# Problem Statement You are given an unsorted array of integers. Your task is to find and return a new array containing the elements in the original order but with all duplicates removed. The order of the first occurrences should remain the same as they appeared in the input array. # Function Signature ```python def remove_duplicates(nums: List[int]) -> List[int]: ``` # Input * `nums` (List[int]): A list of integers in arbitrary order. # Output * Returns a list of integers with duplicates removed while preserving the order of first occurrences. # Constraints * The length of the array will be in the range `[0, 10^5]`. * The values of the integers in the array will be in the range `[-10^5, 10^5]`. # Example ```python nums = [4, 5, 9, 4, 6, 7, 9, 6, 1] print(remove_duplicates(nums)) ``` Expected Output: ``` [4, 5, 9, 6, 7, 1] ``` # Additional Information: * Your implementation should be efficient, aiming for an O(n) solution in terms of time complexity, where n is the length of the input array. * You can make use of auxiliary data structures to keep track of the presence of elements.","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes all duplicates from the list while preserving the original order of the first occurrences. Args: nums (List[int]): A list of integers in arbitrary order. Returns: List[int]: A list with duplicates removed maintaining the original order of first occurrences. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Binary Tree Operations: Node Depth Sum Calculation Context: You are a software engineer developing tools for analyzing binary tree structures. One common task is to calculate the sum of the depths of all nodes in a binary tree. The depth of a node is defined as the number of edges from the node to the tree\'s root. Problem: Given a binary tree, write a method `sum_node_depths` that calculates the total sum of the depths of all nodes in the tree. Specifications: 1. **Function Signature:** ```python def sum_node_depths(self) -> int: Calculates the total sum of depths of all nodes in the binary tree. :return: The total sum of node depths. ``` 2. **Input:** - None. The method operates on the binary tree instance. 3. **Output:** - An integer representing the sum of the depths of all nodes. 4. **Constraints:** - The tree can be empty. - Each node in the tree contains a value, a left child, and a right child. - The function should handle cases with various tree configurations (e.g., balanced, unbalanced). Example Structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def sum_node_depths(self, node: TreeNode = None, depth: int = 0) -> int: Helper function to calculate the sum of node depths. :param node: The current node being processed. :param depth: The current depth of the node. :return: The sum of depths for the subtree rooted at the node. if node is None: return 0 return depth + self.sum_node_depths(node.left, depth + 1) + self.sum_node_depths(node.right, depth + 1) ``` Example Usage: ```python # Construct a binary tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) bt = BinaryTree(root) print(bt.sum_node_depths(bt.root)) # Outputs: 16 # Explanation of node depths: # Depth of node 1: 0 # Depth of node 2: 1 # Depth of node 3: 1 # Depth of node 4: 2 # Depth of node 5: 2 # Depth of node 6: 2 # Depth of node 7: 2 # Total = 0+1+1+2+2+2+2 = 10 ``` **Important:** - Ensure the method accurately calculates the sum of depths for a variety of binary trees. - Handle the case where the binary tree is empty. - Optimize for efficiency where possible, considering the recursive nature of the function.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def sum_node_depths(self, node: TreeNode = None, depth: int = 0) -> int: Helper function to calculate the sum of node depths. :param node: The current node being processed. :param depth: The current depth of the node. :return: The sum of depths for the subtree rooted at the node. if node is None: return 0 return depth + self.sum_node_depths(node.left, depth + 1) + self.sum_node_depths(node.right, depth + 1)"},{"question":"# Question: Inventory Management System You are developing a simple inventory management system for a small business. Your task is to implement two functions: 1. **add_inventory(inventory, item_name, quantity)**: - **Input**: A dictionary `inventory` where keys are item names and values are quantities (both strings and integers respectively); a string `item_name`; an integer `quantity`. - **Output**: The updated inventory dictionary. - **Behavior**: - If `item_name` already exists in `inventory`, add the `quantity` to the current quantity. - If `item_name` does not exist, add a new entry to the dictionary with the given `quantity`. - **Constraints**: - `quantity` must be a positive integer. - **Example**: ```python >>> add_inventory({\'apple\': 10, \'banana\': 5}, \'apple\', 3) {\'apple\': 13, \'banana\': 5} ``` 2. **remove_inventory(inventory, item_name, quantity)**: - **Input**: A dictionary `inventory` where keys are item names and values are quantities (both strings and integers respectively); a string `item_name`; an integer `quantity`. - **Output**: The updated inventory dictionary. - **Behavior**: - If `item_name` does not exist in `inventory`, raise a `KeyError`. - If `item_name` exists but the `quantity` to remove is greater than the available quantity, raise a `ValueError`. - Otherwise, subtract the `quantity` from the current quantity. If the resulting quantity is zero, remove the item from `inventory`. - **Constraints**: - `quantity` must be a positive integer. - **Example**: ```python >>> remove_inventory({\'apple\': 10, \'banana\': 5}, \'apple\', 3) {\'apple\': 7, \'banana\': 5} ``` # Implementation Requirements - **Raise appropriate errors for invalid inputs or inventory states.** - Ensure to handle edge cases, such as removing items in sufficient quantity or inventory being empty. - Optimize for constant time complexity when performing dictionary operations. # Test Cases You should test your functions with the following cases: ```python # Adding inventory assert add_inventory({\'apple\': 10, \'banana\': 5}, \'apple\', 3) == {\'apple\': 13, \'banana\': 5} assert add_inventory({\'apple\': 10, \'banana\': 5}, \'orange\', 7) == {\'apple\': 10, \'banana\': 5, \'orange\': 7} assert add_inventory({}, \'apple\', 5) == {\'apple\': 5} # Removing inventory assert remove_inventory({\'apple\': 10, \'banana\': 5}, \'apple\', 3) == {\'apple\': 7, \'banana\': 5} assert remove_inventory({\'apple\': 10, \'banana\': 5}, \'banana\', 5) == {\'apple\': 10} # Test for invalid quantity value try: add_inventory({\'apple\': 10}, \'apple\', -3) except ValueError: print(\\"ValueError raised as expected for negative quantity\\") try: remove_inventory({\'apple\': 10}, \'apple\', 15) except ValueError: print(\\"ValueError raised as expected for removing more than available\\") # Test for item not in inventory try: remove_inventory({\'apple\': 10}, \'orange\', 1) except KeyError: print(\\"KeyError raised as expected for non-existent item\\") ``` Implement these functions in Python ensuring the above test cases and constraints are met.","solution":"def add_inventory(inventory, item_name, quantity): Adds the given quantity to the inventory for the specified item. Parameters: inventory (dict): Current inventory dictionary. item_name (str): Name of the item to be added. quantity (int): Quantity of the item to add. Returns: dict: Updated inventory dictionary. Raises: ValueError: If quantity is not a positive integer. if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity return inventory def remove_inventory(inventory, item_name, quantity): Removes the given quantity from the inventory for the specified item. Parameters: inventory (dict): Current inventory dictionary. item_name (str): Name of the item to be removed. quantity (int): Quantity of the item to remove. Returns: dict: Updated inventory dictionary. Raises: KeyError: If the item is not present in the inventory. ValueError: If the quantity to remove is greater than the available quantity or if quantity is not a positive integer. if item_name not in inventory: raise KeyError(f\\"Item {item_name} not found in inventory\\") if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") if inventory[item_name] < quantity: raise ValueError(\\"Cannot remove more quantity than available\\") inventory[item_name] -= quantity if inventory[item_name] == 0: del inventory[item_name] return inventory"},{"question":"You are tasked with helping a library organize its book catalog system. Each book has a unique identifier, a title, an author, and an integer representing the number of copies available. Your goal is to create a program that allows the library to add books, remove books by their identifier, and search for books by title keyword. # Function Signature ```python class Library: def __init__(self): pass def add_book(self, book_id: int, title: str, author: str, copies: int) -> None: pass def remove_book(self, book_id: int) -> None: pass def search_books(self, keyword: str) -> list: pass ``` # Input * For `add_book`: * `book_id`: An integer representing the unique identifier for the book. * `title`: A string representing the title of the book. * `author`: A string representing the author of the book. * `copies`: An integer representing the number of copies of the book available. * For `remove_book`: * `book_id`: An integer representing the book to be removed. * For `search_books`: * `keyword`: A string representing the keyword to search for in book titles. # Output * The `add_book` and `remove_book` methods do not return anything. * The `search_books` method returns a list of dictionaries, where each dictionary represents a book matching the search keyword. Each dictionary contains the keys `book_id`, `title`, `author`, and `copies`. # Constraints * All input integer values are non-negative. * The `book_id` values are unique. * The `copies` value for each book is at least 1. * If a `book_id` does not exist during removal, silently ignore the command. * If the keyword is not found in any book title, return an empty list. # Performance Requirements * Aim for a solution that efficiently handles the addition, removal, and searching of books, potentially within time complexity of `O(n)` for each operation. # Notes 1. Raise a `ValueError` if `copies` is less than 1 during addition. 2. Raise a `ValueError` if the `book_id` already exists during addition. 3. Make sure the `search_books` method is case-insensitive. # Example Usage ```python library = Library() library.add_book(1, \\"Harry Potter and the Philosopher\'s Stone\\", \\"J.K. Rowling\\", 5) library.add_book(2, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 3) library.add_book(3, \\"Harry Potter and the Chamber of Secrets\\", \\"J.K. Rowling\\", 4) print(library.search_books(\\"Harry Potter\\")) # Output: [ # {\'book_id\': 1, \'title\': \\"Harry Potter and the Philosopher\'s Stone\\", \'author\': \\"J.K. Rowling\\", \'copies\': 5}, # {\'book_id\': 3, \'title\': \\"Harry Potter and the Chamber of Secrets\\", \'author\': \\"J.K. Rowling\\", \'copies\': 4} # ] library.remove_book(2) print(library.search_books(\\"Hobbit\\")) # Output: [] ``` # Edge Cases 1. Handle cases where the `search_books` method is called with an empty keyword. 2. Ensure the `add_book` method handles duplicate `book_id`s correctly. 3. Handle cases where the book title may contain special characters or spacing variations.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str, copies: int) -> None: if copies < 1: raise ValueError(\\"Number of copies must be at least 1\\") if book_id in self.books: raise ValueError(f\\"Book ID {book_id} already exists\\") self.books[book_id] = { \'title\': title, \'author\': author, \'copies\': copies } def remove_book(self, book_id: int) -> None: if book_id in self.books: del self.books[book_id] def search_books(self, keyword: str) -> list: keyword = keyword.lower() return [ {\'book_id\': book_id, \'title\': book[\'title\'], \'author\': book[\'author\'], \'copies\': book[\'copies\']} for book_id, book in self.books.items() if keyword in book[\'title\'].lower() ]"},{"question":"# Question: Implementing a Dijkstra\'s Algorithm Enhancement Context: You are required to implement an enhanced version of Dijkstra\'s algorithm, which can efficiently handle denser graphs and accommodate dynamic updates to edge weights. This enhanced Dijkstra\'s algorithm should be able to adapt to changes in the graph, such as the addition or modification of edges. Problem Statement: Write a Python function `enhanced_dijkstra(graph: Dict[int, List[Tuple[int, float]]], start: int) -> Dict[int, float]` that performs the following: 1. Takes as input a graph represented as an adjacency list, where the keys are node ids, and the values are lists of tuples (each tuple represents a neighboring node and the edge weight). 2. An integer `start` representing the starting node for the shortest path calculations. 3. Utilizes a priority queue to efficiently find the shortest path from the start node to all other nodes in the graph. 4. Handles dynamic updates, specifically the addition or revision of edges, and re-calculates the shortest paths in these cases. Your function should: - Use a priority queue to ensure the algorithm runs efficiently, even on denser graphs. - Include mechanisms to handle updates, where the function will receive new edges to add or update with respective weights. Input: * `graph` - A dictionary where the keys are integers representing node ids and the values are lists of tuples `(neighbor, weight)` indicating adjacent nodes and the corresponding edge weights. * `start` - An integer representing the starting node for calculating shortest paths. Output: * A dictionary where the keys are node ids, and the values are the shortest path distances from the start node to the respective nodes. Constraints: - The graph can have up to 1000 nodes and 5000 edges. - All edge weights are non-negative floating-point numbers. - Maximum of 100 operations for dynamic updates. Example: ```python import heapq def enhanced_dijkstra(graph, start): # Initialize the shortest path dictionary with infinity shortest_paths = {node: float(\'inf\') for node in graph} shortest_paths[start] = 0 priority_queue = [(0, start)] visited = set() while priority_queue: (current_distance, current_node) = heapq.heappop(priority_queue) # Check if the node has been visited if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this path if it\'s better if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths # Example Input graph = { 0: [(1, 1), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(3, 2)], 3: [] } start = 0 # Expected Output result = enhanced_dijkstra(graph, start) print(result) # {0: 0, 1: 1, 2: 2, 3: 4} ``` Implement the complete function `enhanced_dijkstra` to solve the given problem. Also, provide an additional method to handle dynamic updates to the graph, recalculating the shortest paths when new edges are added or existing edges are updated.","solution":"import heapq from typing import Dict, List, Tuple def enhanced_dijkstra(graph: Dict[int, List[Tuple[int, float]]], start: int) -> Dict[int, float]: Compute the shortest paths from the start node to all other nodes using an enhanced version of Dijkstra\'s algorithm. Parameters: graph (Dict[int, List[Tuple[int, float]]]): Graph represented as an adjacency list start (int): Starting node for shortest path calculations Returns: Dict[int, float]: Dictionary of shortest path distances from the start node to all other nodes def dijkstra(): nonlocal graph, start # Initialize the shortest path dictionary with infinity shortest_paths = {node: float(\'inf\') for node in graph} shortest_paths[start] = 0 priority_queue = [(0, start)] visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths return dijkstra() def update_graph(graph: Dict[int, List[Tuple[int, float]]], edge: Tuple[int, int, float]) -> None: Handles dynamic updates to the graph by adding or revising edges. Parameters: graph (Dict[int, List[Tuple[int, float]]]): Graph represented as an adjacency list edge (Tuple[int, int, float]): Edge to add or update, given as (node1, node2, weight) node1, node2, weight = edge if node1 in graph: for i, (neighbor, _) in enumerate(graph[node1]): if neighbor == node2: graph[node1][i] = (node2, weight) return graph[node1].append((node2, weight)) else: graph[node1] = [(node2, weight)]"},{"question":"# Data Aggregation and Transformation You are required to build a function that aggregates and transforms data from a given list of dictionaries. Each dictionary represents a record containing information about a customer’s order. The goal is to produce a summary that groups orders by customer and calculates the total amount spent by each customer. **Function Signature** ```python def summarize_orders(order_list: list) -> dict: ``` # Input 1. `order_list` (list): A list of dictionaries, where each dictionary contains: - \\"customer_id\\" (str): Unique identifier for the customer. - \\"order_id\\" (str): Unique identifier for the order. - \\"amount\\" (float): Amount spent in the order. - \\"date\\" (str): Date of the order in the format \\"YYYY-MM-DD\\". # Output A `dict` with customer IDs as keys and the corresponding total amount spent by each customer as values. The dictionary should be sorted by customer IDs. # Constraints * The `order_list` can contain up to 10,000 records. * The `amount` will always be a non-negative floating-point number. * The `customer_id` and `order_id` will always contain non-empty strings. * The `date` will always be in the format \\"YYYY-MM-DD\\". **Examples** ```python order_list = [ {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O001\\", \\"amount\\": 150.0, \\"date\\": \\"2023-01-15\\"}, {\\"customer_id\\": \\"C002\\", \\"order_id\\": \\"O002\\", \\"amount\\": 200.0, \\"date\\": \\"2023-01-16\\"}, {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O003\\", \\"amount\\": 50.0, \\"date\\": \\"2023-01-17\\"}, {\\"customer_id\\": \\"C003\\", \\"order_id\\": \\"O004\\", \\"amount\\": 300.0, \\"date\\": \\"2023-01-18\\"}, {\\"customer_id\\": \\"C002\\", \\"order_id\\": \\"O005\\", \\"amount\\": 100.0, \\"date\\": \\"2023-01-19\\"}, ] result = summarize_orders(order_list) print(result) # Expected output: # {\'C001\': 200.0, \'C002\': 300.0, \'C003\': 300.0} ``` # Hint To aggregate the data, iterate through the list and maintain a running total for each customer using a dictionary.","solution":"def summarize_orders(order_list: list) -> dict: Aggregates and transforms data from the given list of dictionaries, producing a summary that groups orders by customer and calculates the total amount spent by each customer. Parameters: order_list (list): List of dictionaries containing order information. Returns: dict: Dictionary with customer IDs as keys and the corresponding total amount spent by each customer as values. summary = {} for order in order_list: customer_id = order[\\"customer_id\\"] amount = order[\\"amount\\"] if customer_id in summary: summary[customer_id] += amount else: summary[customer_id] = amount return dict(sorted(summary.items()))"},{"question":"# Task In this task, you are required to implement the `calculate_word_frequencies` function that processes a list of sentences and returns the frequency of each word in alphabetical order. Each sentence is a string containing words separated by spaces. Additionally, implement the `test_word_frequencies` function to verify the functionality of `calculate_word_frequencies`. # Requirements: * Implement `calculate_word_frequencies` to: - Take a list of sentences as input. - Split each sentence into words, considering a word to be any sequence of non-space characters. - Compute the frequency of each word across all sentences. - Return a list of tuples, where each tuple contains a word and its frequency. - Ensure words in the list are sorted in alphabetical order. * Implement `test_word_frequencies` to: - Take a list of sentences and a list of expected word-frequency tuples as input. - Call `calculate_word_frequencies` to compute the frequencies. - Check if the computed frequencies match the expected frequencies. - Print \\"Test passed\\" if the frequencies match, otherwise print \\"Test failed\\". # Input Format: - `sentences`: A list of sentences, where each sentence is a string. - `expected_output`: A list of tuples, where each tuple contains a word (string) and its frequency (integer). # Output Format: - For `calculate_word_frequencies`, return a list of tuples with word frequencies. - For `test_word_frequencies`, print \\"Test passed\\" or \\"Test failed\\". # Constraints: - Words are case-sensitive. - Assume no punctuation marks or special characters in the input sentences. # Example Usage: Given: ```python sentences = [\\"hello world\\", \\"hello\\", \\"world of wonder\\"] expected_output = [(\\"hello\\", 2), (\\"of\\", 1), (\\"wonder\\", 1), (\\"world\\", 2)] ``` After running `calculate_word_frequencies`, the output should be: ```python [(\\"hello\\", 2), (\\"of\\", 1), (\\"wonder\\", 1), (\\"world\\", 2)] ``` After running `test_word_frequencies` with the above sentences and expected output, the printed result should be: ```python Test passed ``` Implement the functions `calculate_word_frequencies` and `test_word_frequencies` to ensure your solution accurately computes the word frequencies and verifies the results. ```python def calculate_word_frequencies(sentences): word_freq = {} for sentence in sentences: words = sentence.split() for word in words: if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 sorted_word_freq = sorted(word_freq.items()) return sorted_word_freq def test_word_frequencies(sentences, expected_output): calculated_output = calculate_word_frequencies(sentences) if calculated_output == expected_output: print(\\"Test passed\\") else: print(\\"Test failed\\") # Sample usage sentences = [\\"hello world\\", \\"hello\\", \\"world of wonder\\"] expected_output = [(\\"hello\\", 2), (\\"of\\", 1), (\\"wonder\\", 1), (\\"world\\", 2)] test_word_frequencies(sentences, expected_output) ```","solution":"def calculate_word_frequencies(sentences): word_freq = {} for sentence in sentences: words = sentence.split() for word in words: if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 sorted_word_freq = sorted(word_freq.items()) return sorted_word_freq"},{"question":"# Coding Assessment Question: Prime Number Generation **Context**: In many applications, prime numbers play a vital role, especially in fields like cryptography and number theory. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your task is to implement a function that generates a list of prime numbers up to a given number `n`. **Requirements**: 1. Implement the function `generate_primes(n: int) -> List[int]`: * The function should take a positive integer `n` as input and return a list of all prime numbers less than or equal to `n`. * Use an efficient algorithm to ensure the solution works well for larger values of `n` (consider using the Sieve of Eratosthenes for optimal performance). 2. Ensure that your function handles edge cases and provides correct results for: * `n` being 1 or less, where the return list should be empty. * Typical values like `n = 10`, `n = 30`, etc. 3. Your implementation should have: * **Time Complexity**: O(n log log n) * **Space Complexity**: O(n) 4. Validate your function with the following assertions: ```python assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(1) == [] assert generate_primes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert generate_primes(2) == [2] assert generate_primes(0) == [] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] ``` **Function Signature**: ```python from typing import List def generate_primes(n: int) -> List[int]: pass ```","solution":"from typing import List def generate_primes(n: int) -> List[int]: if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(2, n + 1) if sieve[num]] # Sample assertions to validate the function assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(1) == [] assert generate_primes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert generate_primes(2) == [2] assert generate_primes(0) == [] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19]"},{"question":"# Problem Statement You are working on a task manager application that needs to organize and track dependencies between various tasks. Each task can depend on other tasks, forming a Directed Acyclic Graph (DAG). Your goal is to extend the `TaskGraph` class to add functionality for: 1. Topologically sorting the tasks. 2. Detecting if adding a new dependency would create a cycle. 3. Calculating the longest path in the DAG from a given start task. # Task Requirements 1. Implement three new methods in the `TaskGraph` class: * `topological_sort(self) -> list[T]`: Returns a list of tasks in topological order. If the graph is not a DAG, raise an Exception. * `can_add_dependency(self, from_task: T, to_task: T) -> bool`: Returns `True` if adding a dependency from `from_task` to `to_task` will not create a cycle, otherwise returns `False`. * `longest_path_from(self, start_task: T) -> int`: Returns the length of the longest path starting from `start_task` in the DAG. If the graph is not a DAG, raise an Exception. # Input - The graph is directed. - Each task is represented as a vertex and dependencies as edges. # Output - For `topological_sort`, return a list of tasks. - For `can_add_dependency`, return a boolean. - For `longest_path_from`, return an integer. # Constraints 1. The graph can have up to `10^4` vertices. 2. Each vertex will have at most `10^2` edges. 3. The graph will be directed and acyclic initially. # Example ```python task_graph = TaskGraph() task_graph.add_task(\'Task1\').add_task(\'Task2\').add_task(\'Task3\').add_task(\'Task4\') task_graph.add_dependency(\'Task1\', \'Task2\').add_dependency(\'Task2\', \'Task3\') # Example usage: print(task_graph.topological_sort()) # Output: [\'Task1\', \'Task2\', \'Task3\', \'Task4\'] print(task_graph.can_add_dependency(\'Task3\', \'Task1\')) # Output: False print(task_graph.longest_path_from(\'Task1\')) # Output: 2 ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned.","solution":"from typing import List, Dict, Set, TypeVar, Generic, Optional T = TypeVar(\'T\') class TaskGraph(Generic[T]): def __init__(self): self.adj_list: Dict[T, List[T]] = {} def add_task(self, task: T) -> \'TaskGraph\': self.adj_list.setdefault(task, []) return self def add_dependency(self, from_task: T, to_task: T) -> \'TaskGraph\': if from_task not in self.adj_list: self.add_task(from_task) if to_task not in self.adj_list: self.add_task(to_task) self.adj_list[from_task].append(to_task) return self def topological_sort_util(self, task: T, visited: Set[T], stack: List[T]) -> None: visited.add(task) for neighbor in self.adj_list.get(task, []): if neighbor not in visited: self.topological_sort_util(neighbor, visited, stack) stack.insert(0, task) def topological_sort(self) -> List[T]: visited = set() stack = [] for task in self.adj_list: if task not in visited: self.topological_sort_util(task, visited, stack) return stack def has_cycle_util(self, task: T, visited: Set[T], rec_stack: Set[T]) -> bool: visited.add(task) rec_stack.add(task) for neighbor in self.adj_list.get(task, []): if neighbor not in visited: if self.has_cycle_util(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(task) return False def can_add_dependency(self, from_task: T, to_task: T) -> bool: self.add_task(from_task) self.add_task(to_task) self.adj_list[from_task].append(to_task) visited = set() rec_stack = set() for task in self.adj_list: if task not in visited: if self.has_cycle_util(task, visited, rec_stack): self.adj_list[from_task].remove(to_task) return False self.adj_list[from_task].remove(to_task) return True def longest_path_from_util(self, task: T, visited: Set[T], memo: Dict[T, int]) -> int: if task in memo: return memo[task] if task not in self.adj_list: return 0 visited.add(task) max_length = 0 for neighbor in self.adj_list[task]: if neighbor not in visited: max_length = max(max_length, 1 + self.longest_path_from_util(neighbor, visited, memo)) visited.remove(task) memo[task] = max_length return max_length def longest_path_from(self, start_task: T) -> int: if self.has_cycle_util(start_task, set(), set()): raise Exception(\\"Graph is not a DAG\\") return self.longest_path_from_util(start_task, set(), {})"},{"question":"# File Compression with ZIP Scenario: You are required to write a Python function that compresses a list of files into a ZIP archive. This function will be useful in scenarios where you need to bundle multiple files together for efficient storage or distribution. Task: Write a function `compress_files(file_paths: List[str], output_zip: str) -> None` that: 1. Takes a list of file paths and the desired name of the output ZIP file as input. 2. Compresses the specified files into a ZIP archive with the given output name. Requirements: * Use the `zipfile` module to create and write into the ZIP archive. * Include error handling for issues like missing files or write permissions. * Ensure the archive is created in a mode that does not overwrite existing files without confirmation. Input: * `file_paths` (List[str]): A list of strings where each string is a path to a file that should be included in the ZIP archive. * `output_zip` (str): The desired name (including path) of the output ZIP file. Output: * The function does not return any value but creates a ZIP archive containing the specified files. Constraints: * Assume `file_paths` is a non-empty list of valid file paths. * Ensure the function handles potential exceptions like file not found errors or permission issues gracefully. Example: ```python compress_files([\'document.txt\', \'image.png\'], \'archive.zip\') ``` This will compress \'document.txt\' and \'image.png\' into a ZIP file named \'archive.zip\'.","solution":"import zipfile from typing import List import os def compress_files(file_paths: List[str], output_zip: str) -> None: Compresses a list of files into a ZIP archive. :param file_paths: List of strings where each string is a path to a file that should be included in the ZIP archive. :param output_zip: The desired name (including path) of the output ZIP file. # Check if the output zip file already exists to avoid overwriting if os.path.exists(output_zip): raise FileExistsError(f\\"The file \'{output_zip}\' already exists.\\") # Creating a zipfile object with zipfile.ZipFile(output_zip, \'w\', zipfile.ZIP_DEFLATED) as zipf: for file in file_paths: if not os.path.isfile(file): raise FileNotFoundError(f\\"The file \'{file}\' was not found.\\") zipf.write(file, os.path.basename(file))"},{"question":"**Scenario**: You are designing a feature for an e-commerce platform that helps in inventory management. One of the requirements is to keep track of items sold and restocked, and provide a summary of the current stock levels. The system must handle concurrent updates efficiently. **Task**: Implement a class `InventoryManager` with the following methods: 1. `add_item(item_id: str, initial_stock: int) -> None`: Add a new item to the inventory with the specified initial stock level. 2. `record_sale(item_id: str, quantity: int) -> None`: Record the sale of a given quantity of an item. If the quantity exceeds the current stock, raise a `ValueError`. 3. `record_restock(item_id: str, quantity: int) -> None`: Record the restocking of a given quantity of an item. 4. `get_stock(item_id: str) -> int`: Return the current stock level of an item. 5. `get_inventory_summary() -> dict`: Return a summary of the current stock levels for all items in the inventory. The summary should be a dictionary where keys are item IDs and values are stock levels. * Expected input and output formats: * `add_item(\\"item_001\\", 50)` -> None * `record_sale(\\"item_001\\", 5)` -> None * `record_restock(\\"item_001\\", 20)` -> None * `get_stock(\\"item_001\\")` -> int * `get_inventory_summary()` -> `{ \\"item_001\\": int, \\"item_002\\": int, ... }` * Constraints: * If an item does not exist when `record_sale`, `record_restock`, or `get_stock` is called, raise a `KeyError`. * Ensure thread safety for concurrent updates. * Stock levels cannot be negative. Below is the starting code for the class: ```python from threading import Lock class InventoryManager: def __init__(self): self.inventory = {} self.lock = Lock() def add_item(self, item_id: str, initial_stock: int) -> None: # Implement the logic to add a new item to the inventory. pass def record_sale(self, item_id: str, quantity: int) -> None: # Implement the logic to record the sale of an item. pass def record_restock(self, item_id: str, quantity: int) -> None: # Implement the logic to record the restocking of an item. pass def get_stock(self, item_id: str) -> int: # Implement the logic to return the current stock of an item. pass def get_inventory_summary(self) -> dict: # Implement the logic to return the inventory summary. pass ```","solution":"from threading import Lock class InventoryManager: def __init__(self): self.inventory = {} self.lock = Lock() def add_item(self, item_id: str, initial_stock: int) -> None: with self.lock: if item_id in self.inventory: raise ValueError(f\\"Item {item_id} already exists.\\") self.inventory[item_id] = initial_stock def record_sale(self, item_id: str, quantity: int) -> None: with self.lock: if item_id not in self.inventory: raise KeyError(f\\"Item {item_id} does not exist.\\") if quantity > self.inventory[item_id]: raise ValueError(f\\"Not enough stock for item {item_id}.\\") self.inventory[item_id] -= quantity def record_restock(self, item_id: str, quantity: int) -> None: with self.lock: if item_id not in self.inventory: raise KeyError(f\\"Item {item_id} does not exist.\\") self.inventory[item_id] += quantity def get_stock(self, item_id: str) -> int: with self.lock: if item_id not in self.inventory: raise KeyError(f\\"Item {item_id} does not exist.\\") return self.inventory[item_id] def get_inventory_summary(self) -> dict: with self.lock: return dict(self.inventory)"},{"question":"# Coding Challenge: Maximal Square in 2D Binary Matrix Scenario: Suppose you are working as a software developer in an image processing system. One of the tasks assigned to you is to identify the largest square sub-image that contains only white pixels. White pixels are represented by `1`s, and black pixels are represented by `0`s in a 2D binary matrix. Your job is to find the side length of the largest square containing only white pixels. Task: Implement a function to find the area of the largest square composed entirely of white pixels in a given 2D binary matrix. Input: * A 2D list named `matrix` containing `n` rows and `m` columns, where each element is either `0` or `1`. Output: An integer representing the area of the largest square composed entirely of `1`s. Constraints: * (1 leq n, m leq 300) * Each element in the matrix is either a `0` or a `1`. Example: Input: ``` matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ``` Output: ``` 4 ``` Explanation: The largest square has a size of 2x2, and hence the area is (2^2 = 4). Implementation Details: - Define a function `maximal_square(matrix: List[List[int]]) -> int` to perform the task. - Ensure your function handles edge cases and is optimized for performance. - Utilize dynamic programming to achieve an efficient solution. ```python from typing import List def maximal_square(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side # Example usage: if __name__ == \\"__main__\\": matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] print(maximal_square(matrix)) # Output: 4 ```","solution":"from typing import List def maximal_square(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"# Performance Analysis of String Manipulation Algorithms Write two Python functions to analyze the performance of different string manipulation techniques in reversing words within a sentence. Requirements: 1. **Function 1**: `reverse_words_basic` which uses a basic approach with simple loops and string operations to reverse the order of words in a given sentence. 2. **Function 2**: `reverse_words_optimized` which uses advanced Pythonic techniques (such as list comprehensions, slicing, and built-in functions) to reverse the order of words efficiently. 3. **Analysis Function**: `compare_performance` to compare and print the execution time of both functions. Use the `time` module to measure and display runtime. Technical Specifications: * **Input (reverse_words_basic)**: `sentence` (str) - A sentence with words to be reversed. * **Output (reverse_words_basic)**: Returns the sentence with the order of words reversed. * **Input (reverse_words_optimized)**: `sentence` (str) - A sentence with words to be reversed. * **Output (reverse_words_optimized)**: Returns the sentence with the order of words reversed. * **Input (compare_performance)**: `sentence` (str) - The sentence to be used for performance comparison. * **Output (compare_performance)**: Prints the execution time of both functions with a clear indication of which is faster. # Example **Function reverse_words_basic example usage:** ```python def reverse_words_basic(sentence: str) -> str: # Basic implementation here pass if __name__ == \\"__main__\\": print(reverse_words_basic(\\"Hello world, this is a test sentence!\\")) # Output: \\"sentence! test a is this world, Hello\\" ``` **Function reverse_words_optimized example usage:** ```python def reverse_words_optimized(sentence: str) -> str: # Optimized implementation here pass if __name__ == \\"__main__\\": print(reverse_words_optimized(\\"Hello world, this is a test sentence!\\")) # Output: \\"sentence! test a is this world, Hello\\" ``` **Function compare_performance example usage:** ```python def compare_performance(sentence: str) -> None: # Analysis implementation here pass if __name__ == \\"__main__\\": compare_performance(\\"Hello world, this is a test sentence!\\") # Output: Execution time for reverse_words_basic: X.XXXXXX seconds # Execution time for reverse_words_optimized: Y.YYYYYY seconds # Faster approach: reverse_words_[basic/optimized] ``` **Constraints:** * Consider sentences with a moderate length of 10 to 20 words. * Handle edge cases such as empty strings or strings with multiple spaces between words. * Ensure clear performance comparison results output in the console.","solution":"import time def reverse_words_basic(sentence: str) -> str: Reverses the order of words in a sentence using basic string manipulation. Args: - sentence (str): The input sentence. Returns: - str: The sentence with the order of words reversed. words = sentence.split() reversed_words = [] for word in words: reversed_words.insert(0, word) return \' \'.join(reversed_words) def reverse_words_optimized(sentence: str) -> str: Reverses the order of words in a sentence using optimized techniques. Args: - sentence (str): The input sentence. Returns: - str: The sentence with the order of words reversed. return \' \'.join(sentence.split()[::-1]) def compare_performance(sentence: str) -> None: Compares the performance of the two word reversing functions. Args: - sentence (str): The input sentence to be used for performance comparison. Outputs: Prints the execution time of both functions and identifies the faster approach. start_basic = time.time() reverse_words_basic(sentence) end_basic = time.time() start_optimized = time.time() reverse_words_optimized(sentence) end_optimized = time.time() time_basic = end_basic - start_basic time_optimized = end_optimized - start_optimized print(f\\"Execution time for reverse_words_basic: {time_basic:.6f} seconds\\") print(f\\"Execution time for reverse_words_optimized: {time_optimized:.6f} seconds\\") faster = \\"reverse_words_optimized\\" if time_optimized < time_basic else \\"reverse_words_basic\\" print(f\\"Faster approach: {faster}\\")"},{"question":"# Coding Question: Implement K-Way Merge Sort You are given `k` sorted lists of integers and your task is to merge them into a single sorted list. Your goal is to implement an efficient merging algorithm that leverages the properties of sorted lists and optimizes for both time and space complexity. Your tasks are: 1. Use a min-heap (priority queue) to efficiently merge the `k` sorted lists. 2. Ensure that your implementation handles all edge cases, such as lists of different lengths and empty lists. # Function Signature ```python def k_way_merge_sort(lists: List[List[int]]) -> List[int]: pass ``` # Inputs and Outputs - **Input**: A list of `k` sorted lists of integers, `lists`, which can contain zero or more integers, both positive and negative. - **Output**: A new list that merges all the integers in `lists` into a single sorted list. # Constraints: - The total number of integers across all lists combined can be up to 10^5. - Handle edge cases such as empty lists, single-element lists, and duplicate values correctly. # Example ```python >>> k_way_merge_sort([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> k_way_merge_sort([[], [2, 4], [0, 7, 9], [1, 3, 8]]) [0, 1, 2, 3, 4, 7, 8, 9] >>> k_way_merge_sort([[-5, -4, -2], [], [-3, 2, 4]]) [-5, -4, -3, -2, 2, 4] >>> k_way_merge_sort([[], [], []]) [] >>> k_way_merge_sort([[1], [2], [3]]) [1, 2, 3] ``` You should focus on using the min-heap effectively to ensure that the merge process is both fast and efficient, while handling all edge cases proficiently.","solution":"from heapq import heappop, heappush from typing import List def k_way_merge_sort(lists: List[List[int]]) -> List[int]: Merges k sorted lists into a single sorted list using a min-heap. min_heap = [] result = [] # Insert the first element of each list along with the list index and element index for i, l in enumerate(lists): if l: heappush(min_heap, (l[0], i, 0)) while min_heap: val, list_index, element_index = heappop(min_heap) result.append(val) # If there is another element in the same list, push it to the heap if element_index + 1 < len(lists[list_index]): heappush(min_heap, (lists[list_index][element_index + 1], list_index, element_index + 1)) return result"},{"question":"# Memory Efficient CSV Parser You are required to implement a memory efficient CSV parser that can handle large CSV files without loading the entire file into memory. Your task is to read a CSV file and compute the average value of a specified column while ensuring memory usage is kept to a minimum. Task Given a CSV file and the name of the column to compute the average for, write a function `memory_efficient_csv_parser` that reads the CSV file line-by-line and computes the average value of the specified column. Implementation Requirements 1. **Function Signature**: `def memory_efficient_csv_parser(file_path: str, column_name: str) -> float:` 2. **Input Parameters**: * `file_path`: A string representing the path to the CSV file. * `column_name`: A string representing the name of the column for which to compute the average. 3. **Output**: A float representing the average value of the specified column. 4. **Constraints**: * Assume the CSV file is well-formed and can fit all values of the specified column within standard float range. * The CSV file can have up to 1 million rows. 5. **Performance**: * Ensure that the solution efficiently processes the file line-by-line. Example ```python # Content of \'data.csv\' id,value 1,10 2,20 3,30 4,40 # Usage file_path = \'data.csv\' column_name = \'value\' # Output should be the average value of the specified column average_value = memory_efficient_csv_parser(file_path, column_name) # Output: 25.0 ``` Notes Make sure to: * Handle large files efficiently without loading the entire file into memory. * Use appropriate data structures to maintain a small memory footprint. * Properly handle any potential edge cases such as empty columns or missing values by ignoring them in computation.","solution":"import csv def memory_efficient_csv_parser(file_path: str, column_name: str) -> float: Reads a CSV file line-by-line and computes the average of the specified column using minimal memory. Parameters: file_path (str): The path to the CSV file. column_name (str): The name of the column to compute the average for. Returns: float: The average value of the specified column. total = 0.0 count = 0 with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: if column_name in row and row[column_name]: try: value = float(row[column_name]) total += value count += 1 except ValueError: continue # Ignore rows with non-float values in the specified column return total / count if count > 0 else 0.0"},{"question":"# Question You are tasked with implementing a memoized version of the Fibonacci sequence using dynamic programming. The function should compute the nth Fibonacci number by storing previously computed values to avoid redundant calculations, ensuring efficient computation even for large `n`. # Function Signature ```python def memoized_fibonacci(n: int) -> int: Compute the nth Fibonacci number using a memoized approach. Parameters: n (int): The position in the Fibonacci sequence to compute (0-based). Returns: int: The nth Fibonacci number. ``` # Input - `n`: an integer (0 <= n <= 10^5). # Output - Return the `n`th Fibonacci number. # Constraints - The function should efficiently handle `n` up to 100,000 by utilizing memoization. # Examples ```python # Example 1: n = 0 print(memoized_fibonacci(n)) # Output: 0 # Example 2: n = 1 print(memoized_fibonacci(n)) # Output: 1 # Example 3: n = 10 print(memoized_fibonacci(n)) # Output: 55 # Example 4: n = 50 print(memoized_fibonacci(n)) # Output: 12586269025 # Example 5: n = 100 print(memoized_fibonacci(n)) # Output: 354224848179261915075 ``` # Requirements 1. Implement the `memoized_fibonacci` function. 2. Use a memoization technique to store and reuse previously computed Fibonacci numbers. # Notes - Ensure that your function can handle the maximum input size efficiently. - Consider edge cases such as `n = 0` and `n = 1`.","solution":"def memoized_fibonacci(n: int) -> int: Compute the nth Fibonacci number using a memoized approach. Parameters: n (int): The position in the Fibonacci sequence to compute (0-based). Returns: int: The nth Fibonacci number. memo = {0: 0, 1: 1} def fib_memo(n: int) -> int: if n not in memo: memo[n] = fib_memo(n - 1) + fib_memo(n - 2) return memo[n] return fib_memo(n)"},{"question":"# Problem: Find the Longest Harmonious Subsequence You are given an integer array \'nums\'. A harmonious subsequence of a sequence is one where the difference between its maximum value and its minimum value is exactly 1. Your task is to write a program that finds the length of the longest harmonious subsequence among all possible subsequences of the given array. Input * A list of integers `nums` representing the array. Output * An integer representing the length of the longest harmonious subsequence. Constraints * The length of `nums` will be between 1 and 20,000. * The values in `nums` will be between -1,000,000,000 and 1,000,000,000. Example Given the input `nums`: ``` [1, 3, 2, 2, 5, 2, 3, 7] ``` Your function should return `5` because the longest harmonious subsequence is [3, 2, 2, 2, 3]. Function Signature ```python def findLHS(nums: List[int]) -> int: ``` # Notes * Implement the function by first counting the frequency of each number in the array. * Then, use this frequency dictionary to determine the length of the longest harmonious subsequence. * Ensure the solution is efficient to handle the upper constraint limits.","solution":"from typing import List from collections import Counter def findLHS(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence. freq = Counter(nums) max_length = 0 for key in freq: if key + 1 in freq: max_length = max(max_length, freq[key] + freq[key + 1]) return max_length"},{"question":"# Context In web development, URL shortening services are commonly used to reduce the length of URLs while still ensuring that they point to the correct resources. A typical URL shortening service involves mapping a long URL to a shorter URL which is easier to share and remember. # Problem Statement You are required to design a URL shortening service. Implement a class `URLShortener` which supports the operations to encode a long URL into a shorter URL and decode the shortened URL back to the original URL. # Task Enhance the given skeleton of the URL shortening service with the following functionalities: 1. **Encode URL**: - Implement a method `encode(long_url: str) -> str` that takes a long URL and returns a shortened URL. 2. **Decode URL**: - Implement a method `decode(short_url: str) -> str` that takes a shortened URL and returns the original long URL. # Function Signature ```python class URLShortener: def __init__(self): # Initialize your data structure here pass def encode(self, long_url: str) -> str: pass def decode(self, short_url: str) -> str: pass ``` # Input * **encode**: A long URL as a string (`long_url`). * **decode**: A shortened URL as a string (`short_url`). # Output * **encode**: A shortened URL as a string. * **decode**: The original long URL that corresponds to the shortened URL. # Example Usage ```python # Example Usage url_shortener = URLShortener() original_url = \\"https://www.example.com/path/to/resource\\" short_url = url_shortener.encode(original_url) print(short_url) # Should output a shortened version of the URL decoded_url = url_shortener.decode(short_url) print(decoded_url) # Should output \\"https://www.example.com/path/to/resource\\" ``` # Constraints 1. The service should handle up to 10^5 URLs. 2. Each URL provided will have a length of at most 2048 characters. 3. Assume all URLs are valid and follow standard URL format. 4. The shortened URL must be unique for each long URL provided. 5. The returned short URL should be as short as possible while maintaining uniqueness. # Notes - You can assume that each new URL to be shortened is unique and has not been previously shortened. - Consider using hashing or a base conversion technique to generate the short URLs.","solution":"import hashlib class URLShortener: def __init__(self): self.url_map = {} self.short_to_long_map = {} def encode(self, long_url: str) -> str: short_url = \\"http://short.url/\\" + hashlib.md5(long_url.encode()).hexdigest()[:6] self.url_map[long_url] = short_url self.short_to_long_map[short_url] = long_url return short_url def decode(self, short_url: str) -> str: return self.short_to_long_map.get(short_url, \\"\\")"},{"question":"**Objective**: Design and implement a `find_common_elements` function that finds common elements across multiple sorted lists. Your goal is to optimize the function to handle large datasets efficiently by leveraging the properties of sorted lists. # Input/Output Specifications * **Input**: A list of `k` sorted lists containing integers. * **Output**: A list of integers that appear in all `k` input lists. The output should also be sorted. # Requirements 1. Implement the function `find_common_elements`. 2. The function should: * Accept a list of `k` sorted lists as an argument. * Return a sorted list of integers common to all `k` input lists. # Context Consider a situation where you need to identify common elements from different categories of data sources. Each category provides a sorted list of elements, and the task is to find the elements that are present in every category. # Constraints * All provided input lists are individually sorted in non-decreasing order. * The input may include lists of different lengths. * Ensure that the solution can handle large datasets efficiently. # Example ```python def find_common_elements(sorted_lists): Finds the common elements across multiple sorted lists. :param sorted_lists: List of k sorted lists containing integers. :return: A list of integers that appear in all k sorted lists. # Your code here # Example input sorted_lists = [ [1, 2, 3, 4, 5], [2, 3, 5, 7, 9], [1, 3, 5, 7, 11] ] # Calling the function print(find_common_elements(sorted_lists)) # Output should be [3, 5] ``` # Implementation Complete the following function: ```python def find_common_elements(sorted_lists): Finds common elements across multiple sorted lists. :param sorted_lists: List of sorted lists containing integers. :return: A list of integers that appear in all input lists. ... ``` # Performance Requirements * Aim for a time complexity of O(n * k) where `n` is the average length of the lists and `k` is the number of lists. * Ensure that the solution is scalable to handle large inputs efficiently.","solution":"def find_common_elements(sorted_lists): Finds the common elements across multiple sorted lists. :param sorted_lists: List of k sorted lists containing integers. :return: A list of integers that appear in all k sorted lists. if not sorted_lists: return [] common = sorted_lists[0] # Start with the first list for lst in sorted_lists[1:]: common = list(set(common) & set(lst)) # Find intersection with the next list return sorted(common)"},{"question":"# Problem: Maximum Profit in Stock Trading You are given an array `prices` where `prices[i]` represents the stock price on the `i-th` day. You are allowed to complete at most k transactions to maximize your profit. However, you must sell off before you buy again. A transaction is defined as buying one unit of stock and selling it later. Note that you cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). # Task Implement the function `max_profit(k, prices)` that: - Takes an integer `k` representing the maximum number of transactions allowed. - Takes a list `prices` which consists of stock prices for each day. - Returns the maximum profit achievable with at most `k` transactions. # Input - `k` (1 ≤ `k` ≤ 100): An integer representing the maximum number of transactions allowed. - `prices` (0 ≤ |`prices`| ≤ 1000, 0 ≤ `prices[i]` ≤ 10^5): A list of integers representing the prices of the stock on each day. # Output - An integer representing the maximum profit achievable with the given constraints. # Constraints - The solution should be efficient and handle the upper limits of the inputs within a reasonable time frame. # Examples - `max_profit(2, [2, 4, 1])` should return `2`. - `max_profit(2, [3, 2, 6, 5, 0, 3])` should return `7`. - `max_profit(1, [7, 1, 5, 3, 6, 4])` should return `5`. - `max_profit(0, [7, 6, 4, 3, 1])` should return `0`. # Explanation - In the first example, you can make a maximum profit of 2 by buying on day 1 and selling on day 2. - In the second example, you can achieve a maximum profit of 7 by completing two transactions: buy on day 2 and sell on day 3, then buy on day 5 and sell on day 6. - In the third example, you can make a maximum profit of 5 by buying on day 2 and selling on day 5. - In the fourth example, since no transactions are allowed, the maximum profit is 0. # Note - Ensure to handle edge cases where no transactions are possible due to the constraints. - Optimize for both time and space complexity where possible without compromising the correctness of the implementation. Implement the above algorithm in your solution to ensure correctness and optimize for performance.","solution":"def max_profit(k, prices): Given the maximum number of transactions k and a list of daily prices, returns the maximum profit achievable with at most k transactions. n = len(prices) if n == 0 or k == 0: return 0 if k >= n // 2: # If k is large enough, it is effectively unlimited transactions return sum(max(prices[i+1] - prices[i], 0) for i in range(n - 1)) # Create dp table dp = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_prev = -prices[0] for i in range(1, n): dp[t][i] = max(dp[t][i-1], prices[i] + max_prev) max_prev = max(max_prev, dp[t-1][i] - prices[i]) return dp[k][n-1]"},{"question":"# Array Rotation You are tasked with rotating the elements of an array to the right by a given number of steps. The rotation should be done in such a way that the order of elements wraps around at the end of the array. Function Signature ```python def rotate_array(nums: List[int], k: int) -> List[int]: ``` Input - `nums`: A list of integers where `0 ≤ |nums| ≤ 10^5` - `k`: An integer where `0 ≤ k ≤ 10^5` Output - Returns a new list of integers which is the rotated version of the input list `nums`. Example ```python >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([], 3) [] >>> rotate_array([1, 2], 2) [1, 2] ``` Constraints - You may assume that the maximum length of the `nums` list is 100,000. - You may assume that k can be larger than the length of `nums`, in which case it should behave as `k % len(nums)`. - The function should aim to run in O(n) time complexity where n is the length of `nums`. Notes - Rotating an array by `0` steps should return the array unchanged. - Special case handling for an empty list. - Rotating by any integer `k` steps effectively means rotating by `k % len(nums)` steps if `nums` is non-empty.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(nums) if n == 0 or k == 0 or k % n == 0: return nums k = k % n # In case k is larger than the array length return nums[-k:] + nums[:-k]"},{"question":"# Single Number II Given an integer array `nums`, implement the function `single_number(nums: List[int]) -> int` which finds the element that appears exactly once in the array, while all the other elements appear exactly three times. Input: * A list of integers `nums` (1 ≤ len(nums) ≤ 3 * 10^4), where each element appears exactly three times except for one which appears exactly once. All integers in the array are in the range of 32-bit signed integers. Output: * A single integer representing the element that appears exactly once in the input array. Constraints: * The function must have linear runtime complexity, O(n). * The function should not use extra memory for another array. Example: ```python assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert single_number([-2, -2, 1, -2]) == 1 assert single_number([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` # Implementation: * Initialize two variables, `ones` and `twos`, to store the bits that appear exactly once and exactly twice. * Iterate through the array to update `ones` and `twos` such that bits that appear exactly three times are removed. * Return the value of `ones` as the element that appears only once. ```python def single_number(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones ```","solution":"from typing import List def single_number(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Question: Pathfinding in a Weighted Grid **Context**: You are developing a new game where players navigate through a dungeon represented as a 2D grid. Each cell in the grid has a certain weight that represents the difficulty to traverse that cell. Players need to find the easiest path from the top-left corner of the grid to the bottom-right corner, where the path\'s difficulty is the sum of the weights of the cells along the path. You will implement a function `find_easiest_path` that finds the minimum difficulty sum path from the start to the end of the grid. **Function Signature**: ```python def find_easiest_path(grid: list[list[int]]) -> int: pass ``` **Input**: - `grid`: A 2D list of integers where `grid[i][j]` represents the difficulty to traverse the cell at row `i` and column `j`. The grid will have at least one cell and will be rectangular (all rows have the same length). **Output**: - Returns an integer which is the minimum difficulty sum path from the top-left corner to the bottom-right corner of the grid. **Constraints**: - The values in `grid[i][j]` will be non-negative integers. - You can only move right or down at each step. **Example**: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] find_easiest_path(grid) # Expected output: 7 ``` **Explanation**: In the given example, the path with the minimum difficulty sum is `1 -> 3 -> 1 -> 1 -> 1` with a sum of 7. # Guidelines: 1. Consider using dynamic programming to build up the solution from the top-left to the bottom-right corner. 2. You can only move right or down, which reduces the complexity to O(m * n) where m and n are the dimensions of the grid. 3. Handle edge cases such as grids with only one row or one column appropriately. 4. Optimize for both time and space complexity within the constraints.","solution":"def find_easiest_path(grid): Finds the easiest (minimum difficulty sum) path from the top-left to the bottom-right of a grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Fibonacci-Like Sequence Detection Problem Statement In computer science, a Fibonacci-like sequence is a sequence of numbers where the third and each subsequent number is the sum of the two preceding numbers. Given a list of integers, determine if there exists a subsequence (not necessarily contiguous) that forms a Fibonacci-like sequence with at least three numbers. If such a subsequence exists, return the longest length of such a subsequence. If no such subsequence exists, return 0. Write a function `longest_fib_like_subsequence` to solve the problem. Function Signature ```python def longest_fib_like_subsequence(nums: List[int]) -> int: pass ``` # Input - A list of integers `nums` where `1 <= len(nums) <= 1000` and `1 <= nums[i] <= 10^9`. # Output - The function returns an integer representing the length of the longest Fibonacci-like subsequence found. If no such subsequence exists, return 0. # Constraints - You may use built-in Python functions and data structures to help in finding the solution efficiently. # Example ```python nums = [1, 2, 3, 4, 5, 6, 7, 8] print(longest_fib_like_subsequence(nums)) # Outputs: 5 nums = [1, 3, 7, 11, 12, 14, 18] print(longest_fib_like_subsequence(nums)) # Outputs: 3 ``` # Explanation In the first example: - The longest Fibonacci-like subsequence is `[1, 2, 3, 5, 8]` with length 5. In the second example: - The longest Fibonacci-like subsequence is `[1, 11, 12]` with length 3. # Scenario You are tasked with analyzing a sequence of integers to detect patterns that match the Fibonacci-like property, where each number is the sum of the two preceding numbers. Given the potentially large input size and constraints of real-world scenarios, you must implement an efficient algorithm to identify and evaluate the longest valid subsequence.","solution":"from typing import List def longest_fib_like_subsequence(nums: List[int]) -> int: if len(nums) < 3: return 0 num_set = set(nums) longest = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): x, y = nums[i], nums[j] length = 2 while x + y in num_set: x, y = y, x + y length += 1 if length > 2: longest = max(longest, length) return longest if longest > 2 else 0"},{"question":"# Coding Question **Problem Statement**: You are tasked with implementing a function to find the longest substring of a given string that contains exactly two distinct characters. If there are multiple substrings of the same length, return the one that appears first in the string. Write a function called `longest_two_char_substring` to solve this problem. **Function Signature**: ```python def longest_two_char_substring(s: str) -> str: ``` **Input**: - `s`: A string containing only lowercase English letters. The string may be empty. **Output**: - Return a string that is the longest substring containing exactly two distinct characters. **Constraints**: - The length of the input string `s` will not exceed 10^4. **Examples**: ```python >>> longest_two_char_substring(\\"abcbbbbcccbdddadacb\\") \\"bcbbbbcccb\\" >>> longest_two_char_substring(\\"eceba\\") \\"ece\\" >>> longest_two_char_substring(\\"a\\") \\"\\" >>> longest_two_char_substring(\\"aa\\") \\"aa\\" >>> longest_two_char_substring(\\"abcde\\") \\"ab\\" ``` # Notes: - Aim for a time complexity of O(n), where n is the length of the string. - Ensure your implementation is efficient and covers edge cases such as empty strings and strings with fewer than two distinct characters. - If there is no valid substring, return an empty string.","solution":"def longest_two_char_substring(s: str) -> str: if len(s) < 2: return \\"\\" start = 0 max_length = 0 max_substr = \\"\\" char_count = {} for end, char in enumerate(s): char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substr = s[start:end + 1] return max_substr"},{"question":"# Coding Assessment Question Context: You are developing a system for an e-commerce platform that manages customer order fulfillment. Occasionally, there\'s a mismatch in shipped items, and you need to quickly identify the missing items compared to an expected inventory. Task: Write a function `find_missing_items` that takes two lists: `inventory_list` and `shipped_list`. The function should return a list of items that are in the `inventory_list` but not present in the `shipped_list`. The order of items in the output list does not matter. Function Signature: ```python def find_missing_items(inventory_list: list[str], shipped_list: list[str]) -> list[str]: ``` Input: * `inventory_list`: A list of strings where each string represents an item intended to be shipped. * `shipped_list`: A list of strings where each string represents an item that was actually shipped. Output: * A list of strings representing the items that are in `inventory_list` but not in `shipped_list`. Constraints: * Each inventory item and shipped item is represented uniquely. * Both lists can have lengths between 0 and 10^4. * The length of `shipped_list` will always be less than or equal to the length of `inventory_list`. Examples: ```python find_missing_items([\\"item1\\", \\"item2\\", \\"item3\\"], [\\"item2\\", \\"item3\\"]) => [\\"item1\\"] find_missing_items([\\"apple\\", \\"banana\\", \\"orange\\"], [\\"banana\\", \\"orange\\"]) => [\\"apple\\"] find_missing_items([\\"box\\", \\"bottle\\", \\"can\\", \\"tray\\"], [\\"box\\", \\"bottle\\", \\"tray\\"]) => [\\"can\\"] find_missing_items([\\"pen\\", \\"pencil\\", \\"eraser\\"], [\\"pen\\", \\"pencil\\", \\"eraser\\"]) => [] find_missing_items([\\"laptop\\", \\"mouse\\"], []) => [\\"laptop\\", \\"mouse\\"] ``` Scenario: You are monitoring the daily operations and need to identify discrepancies between expected inventory and actual shipped items. Use your function to determine any missing items efficiently.","solution":"def find_missing_items(inventory_list: list[str], shipped_list: list[str]) -> list[str]: Returns the items in the inventory_list that are not present in the shipped_list. Parameters: inventory_list (list[str]): The list of items intended to be shipped. shipped_list (list[str]): The list of items that were actually shipped. Returns: list[str]: The list of items that are in the inventory_list but not in the shipped_list. inventory_set = set(inventory_list) shipped_set = set(shipped_list) missing_items = list(inventory_set - shipped_set) return missing_items"},{"question":"# Question: JSON Manipulation Functions You are tasked with implementing two functions that manipulate JSON data: one for flattening nested JSON objects and another for converting a flat JSON object back into its original nested form. Function 1: `flatten_json(nested_json: dict) -> dict` Implement a function that takes a nested JSON object and converts it into a flat JSON object. **Inputs:** * `nested_json (dict)`: A dictionary representing the nested JSON object. **Outputs:** * `dict`: A dictionary representing the flattened JSON object. **Constraints:** * Keys in the resulting flat JSON object should be in dot notation to represent their hierarchy. Input Examples: ```json { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 } ``` ```json { \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": { \\"v\\": 6 } } } ``` Output Examples: ```json { \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 } ``` ```json { \\"x.y.z\\": 5, \\"x.w.v\\": 6 } ``` Function 2: `unflatten_json(flat_json: dict) -> dict` Implement a function that takes a flat JSON object and converts it back into its nested form. **Inputs:** * `flat_json (dict)`: A dictionary representing the flattened JSON object. **Outputs:** * `dict`: A dictionary representing the nested JSON object. **Constraints:** * Keys in the input flat JSON object are in dot notation representing their hierarchy. Input Examples: ```json { \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 } ``` ```json { \\"x.y.z\\": 5, \\"x.w.v\\": 6 } ``` Output Examples: ```json { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 } ``` ```json { \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": { \\"v\\": 6 } } } ``` # Requirements 1. Handle edge cases such as empty JSON objects and nested structures with varying depths. 2. Ensure efficient conversion between the two representations without excessive use of memory or time. 3. Implement proper error conditions where inputs do not meet expected formats or constraints. Examples Example 1: ```python >>> flatten_json({ \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 }) { \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 } >>> flatten_json({ \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": { \\"v\\": 6 } } }) { \\"x.y.z\\": 5, \\"x.w.v\\": 6 } ``` Example 2: ```python >>> unflatten_json({ \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 }) { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 } >>> unflatten_json({ \\"x.y.z\\": 5, \\"x.w.v\\": 6 }) { \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": { \\"v\\": 6 } } } ``` Write the implementations for both functions ensuring they fulfill the requirements and handle all edge cases appropriately.","solution":"def flatten_json(nested_json: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: Flattens a nested JSON object to a simple dictionary with dot notations. Parameters: nested_json (dict): A dictionary representing the nested JSON object. parent_key (str): A string representing the base key. Used in recursion. sep (str): A string used to separate keys. Returns: dict: A dictionary representing the flattened JSON object. items = [] for k, v in nested_json.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_json(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items) def unflatten_json(flat_json: dict, sep: str = \'.\') -> dict: Converts a flat JSON object to its nested form. Parameters: flat_json (dict): A dictionary representing the flattened JSON object. sep (str): A string used to separate keys in dot notation. Returns: dict: A dictionary representing the nested JSON object. nested_json = {} for k, v in flat_json.items(): parts = k.split(sep) d = nested_json for part in parts[:-1]: if part not in d: d[part] = {} d = d[part] d[parts[-1]] = v return nested_json"},{"question":"# Coding Assessment Question # Finding the Optimal Meeting Point You are responsible for writing a function that determines the optimal meeting point for a group of friends living along a straight line. Each friend lives at their respective positions on the line, represented by their coordinates. The optimal meeting point is defined as the point (coordinate) that minimizes the total travel distance for all friends. This problem requires you to consider the median as the best meeting point. 1. Write a function to calculate the optimal meeting point by determining the median of the coordinates. 2. Handle exceptions for cases where the input list is empty, by raising relevant Python exceptions. 3. Ensure the solution works efficiently for both odd and even numbers of coordinates. Function Specifications 1. **find_meeting_point** - **Input**: A list of integer coordinates representing friends\' positions along the line. - **Output**: An integer representing the optimal meeting point. - **Constraints**: - The input list should contain at least one coordinate. - Handle potential type errors gracefully. - **Performance Requirements**: - Implementations should have a time complexity of O(n log n) due to sorting. Example ```python def find_meeting_point(coordinates): # Your solution here # Example Usage coordinates = [1, 2, 9, 12, 15, 18] print(find_meeting_point(coordinates)) # Output: 10 ```","solution":"def find_meeting_point(coordinates): Returns the optimal meeting point (median) from a list of coordinates. Parameters: coordinates (list): A list of integers representing friends\' positions on a line. Returns: int: The coordinate that minimizes the total travel distance. Raises: ValueError: If the input list is empty. TypeError: If the input is not a list of integers. if not isinstance(coordinates, list): raise TypeError(\\"Input must be a list of integers.\\") if not all(isinstance(x, int) for x in coordinates): raise TypeError(\\"All elements in the list must be integers.\\") if not coordinates: raise ValueError(\\"Input list cannot be empty.\\") sorted_coords = sorted(coordinates) n = len(sorted_coords) median = sorted_coords[n // 2] if n % 2 != 0 else sorted_coords[n // 2 - 1] return median"},{"question":"# Sorting a List of Tuples by Multiple Keys You are working on a data processing application and need to sort a list of tuples by multiple keys. Each tuple contains information about an item in the format (name, price, rating). Task Write a function `sort_tuples` that sorts a list of tuples first by price (ascending) and then by rating (descending). If two tuples have the same price, the one with the higher rating should come first. Function Signature ```python def sort_tuples(items: List[Tuple[str, float, float]]) -> List[Tuple[str, float, float]]: pass ``` Input - `items` (List[Tuple[str, float, float]]): A list of tuples, where each tuple contains: - `name` (str): The name of the item. - `price` (float): The price of the item. - `rating` (float): The rating of the item. Output - Returns a new list of tuples sorted by the specified criteria. Constraints - All prices are non-negative. - Ratings are real numbers. - The list can be empty. Examples ```python sort_tuples([(\\"apple\\", 1.2, 4.1), (\\"banana\\", 0.5, 3.5), (\\"orange\\", 1.2, 4.5)]) # Should return [(\\"banana\\", 0.5, 3.5), (\\"orange\\", 1.2, 4.5), (\\"apple\\", 1.2, 4.1)] sort_tuples([(\\"item1\\", 10.0, 5.0), (\\"item2\\", 10.0, 4.5), (\\"item3\\", 5.0, 4.0)]) # Should return [(\\"item3\\", 5.0, 4.0), (\\"item1\\", 10.0, 5.0), (\\"item2\\", 10.0, 4.5)] sort_tuples([(\\"item\\", 0, 0)]) # Should return [(\\"item\\", 0, 0)] ``` Hints - Use Python\'s built-in sorting functionality with a custom key. - Remember that you can use a tuple for the key with multiple elements, making use of the fact that Python compares tuples lexicographically.","solution":"from typing import List, Tuple def sort_tuples(items: List[Tuple[str, float, float]]) -> List[Tuple[str, float, float]]: Sorts a list of tuples by price (ascending), then by rating (descending). Parameters: items (List[Tuple[str, float, float]]): A list of tuples to be sorted. Returns: List[Tuple[str, float, float]]: A sorted list of tuples. return sorted(items, key=lambda item: (item[1], -item[2]))"},{"question":"# Problem Statement Write a function that takes a string representing a mathematical expression containing addition (`+`), multiplication (`*`), and parentheses, and returns the result of the expression. Your function needs to handle expressions involving positive integers, properly respecting the order of operations (parentheses and multiplication before addition). # Function Signature ```python def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing addition, multiplication, and parentheses. ``` # Input - A string `expression` representing a mathematical expression. The string contains only digits, `+`, `*`, `(`, and `)`. # Output - An integer representing the result of evaluating the expression. # Constraints - The input string will be a valid expression. - The length of the expression string will be between 1 and 1000 inclusive. - Single-digit integers are used (i.e., integers from 0 to 9). # Example ```python >>> evaluate_expression(\\"1+2*3\\") 7 >>> evaluate_expression(\\"2*(3+4)\\") 14 >>> evaluate_expression(\\"1+(2*3+(4*(5+6)))\\") 51 >>> evaluate_expression(\\"4+(3*5)+2\\") 21 >>> evaluate_expression(\\"((2+3)*4)+1\\") 21 ``` # Explanation - The input \\"1+2*3\\" evaluates to `1 + (2 * 3) = 1 + 6 = 7`. - The input \\"2*(3+4)\\" evaluates to `2 * (3 + 4) = 2 * 7 = 14`. - The input \\"1+(2*3+(4*(5+6)))\\" evaluates to `1 + (2 * 3 + (4 * (5 + 6))) = 1 + (2 * 3 + (4 * 11)) = 1 + (2 * 3 + 44) = 1 + 6 + 44 = 51`. To solve this problem, you will need to parse and evaluate the expression following the proper order of operations.","solution":"def evaluate_expression(expression: str) -> int: def evaluate(tokens): stack = [] num = 0 prev_op = \'+\' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \'(\': num = evaluate(tokens) if not token.isdigit() or not tokens: if prev_op == \'+\': stack.append(num) elif prev_op == \'*\': stack[-1] *= num prev_op = token num = 0 if token == \')\': break return sum(stack) # Tokenize the input expression string into meaningful chunks (numbers, +, *, parentheses) tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): number = expression[i] tokens.append(number) elif expression[i] in \'+*()\': tokens.append(expression[i]) i += 1 return evaluate(tokens)"},{"question":"# Problem Description You are given an integer `n` and your task is to calculate the n-th number in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - `F(0) = 0` - `F(1) = 1` - `F(n) = F(n-1) + F(n-2)` for n > 1 Write a function `find_fibonacci` that takes an integer `n` as input and returns the n-th Fibonacci number. # Input * `n` (int): A non-negative integer representing the position in the Fibonacci sequence. # Output * (int): The n-th Fibonacci number. # Constraints * 0 <= `n` <= 30 # Performance Requirements * The solution should have a time complexity of O(n), and you should avoid using recursion to ensure it efficiently handles the upper limit of the constraint. # Example ```python def find_fibonacci(n: int) -> int: pass # Example usage: print(find_fibonacci(0)) # Output: 0 print(find_fibonacci(1)) # Output: 1 print(find_fibonacci(7)) # Output: 13 print(find_fibonacci(10)) # Output: 55 print(find_fibonacci(30)) # Output: 832040 ```","solution":"def find_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 # Initialize base cases for _ in range(2, n+1): # Iterate to find the n-th Fibonacci number a, b = b, a + b return b"},{"question":"# Coding Assessment Question: Implementation of Custom HashMap **Scenario**: You are tasked with designing a custom HashMap class with some additional features. The basic functionality of a HashMap (or dictionary) in most programming languages includes insertion (`put`), retrieval (`get`), and deletion (`remove`) of key-value pairs. However, you need to enhance it by implementing the following additional features: 1. **Dynamic Resizing**: The HashMap should resize dynamically when the load factor exceeds 75%. 2. **Count Unique Keys**: A method to count the number of unique keys currently in the HashMap. 3. **Retrieve All Keys in Sorted Order**: A method to retrieve all the keys in the HashMap in lexicographically sorted order. **Objective**: You need to implement a custom `CustomHashMap` class with the basic functionalities (`put`, `get`, `remove`) and the additional features described above. Input: - A series of method calls to the `CustomHashMap` object. Output: - The results of method calls made to the `CustomHashMap` object. ```python class CustomHashMap: def __init__(self): self.capacity = 10 self.size = 0 self.map = [None] * self.capacity self.load_factor_threshold = 0.75 def put(self, key: str, value: int) -> None: Inserts or updates the key-value pair in the HashMap. Dynamically resizes the map if the load factor exceeds the threshold. # Placeholder: Implement logic for inserting/updating key-value pairs pass def get(self, key: str) -> int: Retrieves the value associated with the given key. Returns -1 if the key is not found. # Placeholder: Implement logic for retrieving value associated with key pass def remove(self, key: str) -> None: Removes the key-value pair from the HashMap. # Placeholder: Implement logic for removing key-value pairs pass def count_unique_keys(self) -> int: Returns the number of unique keys currently in the HashMap. # Placeholder: Implement logic for counting unique keys pass def get_sorted_keys(self) -> list: Returns all keys in the HashMap in lexicographically sorted order. # Placeholder: Implement logic for retrieving sorted keys pass def _resize(self) -> None: Resizes the HashMap when the load factor exceeds the threshold. # Placeholder: Implement logic for resizing the HashMap pass # Example usage: if __name__ == \\"__main__\\": custom_map = CustomHashMap() custom_map.put(\\"apple\\", 5) custom_map.put(\\"banana\\", 3) custom_map.put(\\"cherry\\", 7) custom_map.put(\\"date\\", 2) custom_map.put(\\"apple\\", 10) # Updating the value for key \\"apple\\" print(custom_map.get(\\"apple\\")) # Output: 10 print(custom_map.get(\\"banana\\")) # Output: 3 print(custom_map.count_unique_keys()) # Output: 4 print(custom_map.get_sorted_keys()) # Output: [\'apple\', \'banana\', \'cherry\', \'date\'] custom_map.remove(\\"banana\\") print(custom_map.get(\\"banana\\")) # Output: -1 print(custom_map.count_unique_keys()) # Output: 3 print(custom_map.get_sorted_keys()) # Output: [\'apple\', \'cherry\', \'date\'] ``` Constraints: 1. Hash function and collision resolution strategy are part of your design. 2. The hashmap should handle string type keys and integer type values. 3. HashMap should resize when the load factor exceeds 75%. 4. All methods should have a time complexity of O(1) on average. **Note**: This question assesses your ability to implement and enhance an essential data structure while maintaining performance efficiency and handling dynamic resizing.","solution":"class CustomHashMap: def __init__(self): self.capacity = 10 self.size = 0 self.map = [None] * self.capacity self.load_factor_threshold = 0.75 def put(self, key: str, value: int) -> None: idx = self._hash(key) if self.map[idx] is None: self.map[idx] = [] for i, (k, v) in enumerate(self.map[idx]): if k == key: self.map[idx][i] = (key, value) return self.map[idx].append((key, value)) self.size += 1 if self.size / self.capacity > self.load_factor_threshold: self._resize() def get(self, key: str) -> int: idx = self._hash(key) if self.map[idx] is not None: for k, v in self.map[idx]: if k == key: return v return -1 def remove(self, key: str) -> None: idx = self._hash(key) if self.map[idx] is not None: for i, (k, v) in enumerate(self.map[idx]): if k == key: del self.map[idx][i] self.size -= 1 return def count_unique_keys(self) -> int: return self.size def get_sorted_keys(self) -> list: keys = [] for bucket in self.map: if bucket is not None: keys.extend([k for k, v in bucket]) return sorted(keys) def _hash(self, key: str) -> int: return hash(key) % self.capacity def _resize(self) -> None: old_map = self.map self.capacity *= 2 self.map = [None] * self.capacity self.size = 0 for bucket in old_map: if bucket is not None: for (k, v) in bucket: self.put(k, v)"},{"question":"# Context You have a binary tree implementation in Python, and your task is to extend its functionality. One important functionality often required is finding the path from the root to a target node. # Task Implement a method `find_path_to_node(self, target: int) -> List[int]` within the `BinaryTree` class that returns a list representing the path from the root to a node with a value equal to `target`. If the target node does not exist in the tree, the method should return an empty list. # Function Signature ```python class BinaryTree: def find_path_to_node(self, target: int) -> List[int]: # Your code here ``` # Input * An integer `target` representing the value of the target node. # Output * A list of integers representing the values of nodes along the path from the root to the target node. If the target node is not found, return an empty list. # Constraints * The binary tree may have a maximum height of 1000. * Each node\'s value is an integer in the range [-1000, 1000]. # Example ```python >>> bt = BinaryTree([5, 3, 8, 2, 4, 7, 9]) >>> bt.find_path_to_node(7) [5, 8, 7] >>> bt.find_path_to_node(10) [] # Node with value 10 is not present in the tree ``` # Notes * The binary tree is represented as an array where the index of a node\'s left child is `2 * index + 1` and the index of its right child is `2 * index + 2`. * The function should handle both balanced and unbalanced binary trees.","solution":"class BinaryTree: def __init__(self, values): self.values = values def find_path_to_node(self, target: int): def dfs(index, path): if index >= len(self.values) or self.values[index] is None: return False path.append(self.values[index]) if self.values[index] == target: return True # Left child index is 2 * index + 1 # Right child index is 2 * index + 2 if dfs(2 * index + 1, path) or dfs(2 * index + 2, path): return True path.pop() return False path = [] if dfs(0, path): return path return []"},{"question":"# Context You are tasked with implementing a simple stack-based calculator that can evaluate postfix expressions (also known as Reverse Polish Notation, RPN). Postfix expressions are mathematical expressions where operators follow their operands. This makes them suitable for stack-based evaluation. # Problem Statement Write a class `RPNCalculator` with the following instance methods: 1. `__init__()` 2. `evaluate(expression: str) -> float` Method Descriptions: * **__init__**: Initializes an empty stack. * **evaluate**: Evaluates a given postfix expression and returns the result as a float. Input and Output Formats: * **Input**: - `expression`: A string representing a postfix expression where each token (operand or operator) is separated by a space. * **Output**: The evaluation result as a float. Supported Operators: * + (addition) * - (subtraction) * * (multiplication) * / (division) Constraints: 1. The expression will contain valid tokens and well-formed postfix notation. 2. All operands are valid float numbers. 3. No divisions by zero will occur. Example Usage: ```python calculator = RPNCalculator() print(calculator.evaluate(\\"3 4 + 2 * 7 /\\")) # Output: 2.0 print(calculator.evaluate(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14.0 ``` # Performance Requirement The evaluation should be performed in linear time, O(n), where n is the number of tokens in the postfix expression. Good luck and ensure your solution is robust and handles typical edge cases such as empty inputs!","solution":"class RPNCalculator: def __init__(self): self.stack = [] def evaluate(self, expression: str) -> float: tokens = expression.split() for token in tokens: if token in {\'+\', \'-\', \'*\', \'/\'}: b = self.stack.pop() a = self.stack.pop() if token == \'+\': self.stack.append(a + b) elif token == \'-\': self.stack.append(a - b) elif token == \'*\': self.stack.append(a * b) elif token == \'/\': self.stack.append(a / b) else: self.stack.append(float(token)) return self.stack.pop()"},{"question":"You are tasked with developing a method to simplify a flight itinerary by removing duplicate consecutive flights. The itinerary is represented as a list where each element corresponds to a flight\'s destination in the order of the flights taken. The function should keep the first occurrence of any consecutive duplicates and remove the others. The new function should handle the following: 1. **Error Handling**: - Gracefully handle scenarios where the input is not a list or where the list contains non-string elements. - Return an empty list if the input list is empty. 2. **Performance**: - Ensure the solution works efficiently for large lists, potentially with thousands of entries. 3. **Edge Cases**: - Handle edge cases such as itineraries with all elements being the same, alternating sequences, and null/invalid elements. Write the function `simplify_itinerary` with the following signature: ```python from typing import List def simplify_itinerary(itinerary: Union[List[str], None]) -> List[str]: # Your implementation here ``` # Input: - `itinerary` (list of str, or None): The list representing the flight itinerary. # Output: - Returns a list containing the simplified itinerary where consecutive duplicates are removed. # Constraints: - Each element in the list represents a valid destination string. - The function should handle lists of sizes up to 1000 elements within a reasonable time (e.g., within a few milliseconds). # Example: ```python simplified = simplify_itinerary([\\"New York\\", \\"New York\\", \\"Los Angeles\\", \\"Los Angeles\\", \\"Los Angeles\\", \\"Chicago\\", \\"Chicago\\", \\"New York\\"]) print(simplified) ``` This code should print: ```python [\\"New York\\", \\"Los Angeles\\", \\"Chicago\\", \\"New York\\"] ``` Your task is to implement the `simplify_itinerary` function based on the specifications above.","solution":"from typing import List, Union def simplify_itinerary(itinerary: Union[List[str], None]) -> List[str]: Simplifies the itinerary by removing consecutive duplicate destinations. Args: itinerary (List[str] or None): The list of destinations. Returns: List[str]: The simplified list of destinations. if itinerary is None or not isinstance(itinerary, list): return [] if any(not isinstance(dest, str) for dest in itinerary): raise ValueError(\\"All elements in itinerary must be strings\\") simplified = [] prev_dest = None for dest in itinerary: if dest != prev_dest: simplified.append(dest) prev_dest = dest return simplified"},{"question":"# Scenario: You have been hired as an algorithm engineer at a logistics company. Your task is to optimize the route for a fleet of delivery vehicles. The company wants to ensure each vehicle carries an equal load to minimize costs and maximize efficiency. # Task: Implement a function to distribute delivery packages among a specified number of vehicles such that the load (weight of packages) is as evenly balanced as possible. Each package has a specific weight, and the function should return a list of lists, where each sublist represents the packages assigned to a particular vehicle. # Function Signature: ```python def distribute_packages(weights: List[int], num_vehicles: int) -> List[List[int]]: Distribute packages to vehicles as evenly as possible based on their weights. Parameters: - weights (List[int]): A list of integers representing the weights of packages. - num_vehicles (int): The number of delivery vehicles. Returns: - List[List[int]]: A list of lists, where each sublist contains the weights of packages assigned to a vehicle. ``` # Constraints: - The number of weights in the list `weights` is between 1 and 10000. - The number of vehicles `num_vehicles` is between 2 and 100. - The weight of each package is an integer between 1 and 1000. # Performance: - The distribution should execute in reasonable time complexity to handle the upper limit of the constraints. - Aim for an optimal balance where the maximum difference in load between any two vehicles is minimized. # Evaluation: - Your solution will be evaluated on its correctness, efficiency, and ability to handle edge cases (e.g., a package list that cannot be perfectly evenly divided).","solution":"from typing import List def distribute_packages(weights: List[int], num_vehicles: int) -> List[List[int]]: Distribute packages to vehicles as evenly as possible based on their weights. Parameters: - weights (List[int]): A list of integers representing the weights of packages. - num_vehicles (int): The number of delivery vehicles. Returns: - List[List[int]]: A list of lists, where each sublist contains the weights of packages assigned to a vehicle. # Sort weights in descending order for a greedy allocation weights.sort(reverse=True) # Initialize the loads for vehicles vehicle_loads = [[] for _ in range(num_vehicles)] vehicle_weights = [0] * num_vehicles for weight in weights: # Find the vehicle with the least current load min_index = vehicle_weights.index(min(vehicle_weights)) # Assign the package to this vehicle vehicle_loads[min_index].append(weight) vehicle_weights[min_index] += weight return vehicle_loads"},{"question":"# Dice Roll Simulation Problem Statement Simulating the roll of a dice is a common problem in programming, often used to teach concepts such as randomness and conditional logic. In this task, you\'ll simulate the rolling of two dice and analyze the results. You need to write a function that: 1. Simulates rolling two six-sided dice a specified number of times. 2. Computes the frequency of each possible sum (2 through 12). 3. Determines the sum that appeared most frequently and the sum that appeared least frequently. # Function Specifications 1. `dice_roll_simulation(rolls: int) -> Tuple[Dict[int, int], int, int]` * **Input**: An integer representing the number of times to roll the dice. * **Output**: A tuple containing three elements: 1. A dictionary where keys represent possible sums (2 through 12) and values are the frequencies of these sums. 2. An integer representing the sum that appeared most frequently. 3. An integer representing the sum that appeared least frequently. * **Constraints**: * The `rolls` should be a positive integer. * Raise `ValueError` if `rolls` is non-positive. * **Note**: If multiple sums share the same highest or lowest frequency, the function should return any one of them. # Example Usage: ```python >>> from random import seed >>> seed(1234) >>> dice_roll_simulation(1000) ({2: 31, 3: 60, 4: 83, 5: 111, 6: 139, 7: 163, 8: 118, 9: 91, 10: 95, 11: 67, 12: 42}, 7, 2) >>> dice_roll_simulation(0) Traceback (most recent call last): ... ValueError: Number of rolls must be a positive integer ``` # Submission Submit your code implementing the function. Ensure it handles all edge cases and passes the above usage examples.","solution":"import random from typing import Tuple, Dict def dice_roll_simulation(rolls: int) -> Tuple[Dict[int, int], int, int]: if rolls <= 0: raise ValueError(\\"Number of rolls must be a positive integer\\") # Initialize dictionary to store frequencies of sums sum_frequencies = {i: 0 for i in range(2, 13)} # Simulate rolling the dice for _ in range(rolls): die1 = random.randint(1, 6) die2 = random.randint(1, 6) dice_sum = die1 + die2 sum_frequencies[dice_sum] += 1 # Find most and least frequent sums most_frequent_sum = max(sum_frequencies, key=sum_frequencies.get) least_frequent_sum = min(sum_frequencies, key=sum_frequencies.get) return sum_frequencies, most_frequent_sum, least_frequent_sum"},{"question":"# Coding Question Implement a function `unique_integers_with_sum` that takes an integer `n` and returns a list of `n` unique integers that sum up to zero. The integers can be any integer (both positive and negative). Function Signature ```python def unique_integers_with_sum(n: int) -> List[int]: pass ``` Input and Output Format * **Input**: An integer `n` where `1 <= n <= 1000`. * **Output**: A list of `n` unique integers that sum up to zero. Examples ```python >>> unique_integers_with_sum(3) [-1, 0, 1] >>> unique_integers_with_sum(4) [-2, -1, 1, 2] >>> unique_integers_with_sum(1) [0] >>> unique_integers_with_sum(5) [-2, -1, 0, 1, 2] >>> unique_integers_with_sum(6) [-3, -2, -1, 1, 2, 3] ``` Constraints * The list should contain `n` unique integers. * The sum of the returned integers must be `0`. Requirements * Ensure the implementation is efficient and generates the desired list in `O(n)` time complexity. * Implement appropriate error handling for invalid inputs, such as negative or zero values not meeting the constraints. Raise a `ValueError` with the message `\\"Input must be a positive integer between 1 and 1000\\"` for such cases. # Notes - In cases where `n` is `1`, the only valid output is `[0]`. - For larger `n`, an approach could involve creating pairs of positive and negative integers to ensure they sum to zero.","solution":"def unique_integers_with_sum(n): Return a list of n unique integers that sum to zero. if not isinstance(n, int) or n < 1 or n > 1000: raise ValueError(\\"Input must be a positive integer between 1 and 1000\\") result = [] # Generate n//2 pairs of integers and one zero if n is odd for i in range(1, n//2 + 1): result.append(i) result.append(-i) if n % 2 == 1: result.append(0) return result"},{"question":"# Question: Binary Tree Zigzag Level Order Traversal You are given a binary tree. Your task is to conduct a zigzag level order traversal of the tree, where nodes\' values on each level are listed from left to right, then right to left for the next level, and so on. The input tree will be represented as an array, where the position of each node in the array adheres to the following rules: 1. The array index `i` represents the node at position `i`. 2. For any given node at index `i`, the left child of this node is found at index `2i + 1`, and the right child is found at index `2i + 2`. Write a function `zigzag_level_order_traversal` that takes the root of the binary tree as an argument and returns a list of lists, each representing the node values at each level of the tree in zigzag order. **Function Signature**: ```python def zigzag_level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: pass ``` # Input: - `root` (TreeNode | None): The root node of the binary tree. # Output: - Returns a list of lists, where each inner list contains the node values at each level of the tree traversed in zigzag order. # Examples: Given the tree: ```plaintext 3 / 9 20 / 15 7 ``` The input would be represented as: `[3, 9, 20, None, None, 15, 7]` ```python assert zigzag_level_order_traversal(root) == [[3], [20, 9], [15, 7]] ``` # Constraints: - The number of nodes in the tree is in the range `[0, 1000]`. - `-1000 <= Node.val <= 1000` - Only one traversal is allowed. # Detailed Requirements: 1. **Alternating Order**: The nodes at each level should alternate between left-to-right and right-to-left ordering. 2. **Handling Null Nodes**: The function should handle nodes that have `None` value appropriately by ignoring nulls in the traversal. 3. **Efficiency**: Ensure the traversal and ordering is done efficiently. # Specific Challenge: Make sure the function supports and runs efficiently on trees with up to `1000` nodes and handles edge cases, such as empty trees or trees with a single branch or node. Ensure the code is organized and comments explain key parts of the implementation.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def zigzag_level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] results = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(list(level_nodes)) left_to_right = not left_to_right return results"},{"question":"# Question: Count the Characters in a Text File Statement: You are required to write a function that reads a text file and counts the occurrences of each character in the file. The function should return a dictionary where the keys are the characters, and the values are the counts of those characters. Function Signature: ```python def count_characters(file_path: str) -> dict: ``` Input: - ( file_path ) (str): The path to the text file. Output: - A dictionary where the keys are characters (including whitespace and punctuation) and the values are integers representing the count of each character. Constraints: - You can assume that the file path is valid and the file is a readable text file. - The function should handle empty files and return an empty dictionary in such cases. Example: Assume you have a text file `sample.txt` with the following content: ``` Hello, World! ``` Executing the function: ```python >>> count_characters(\'sample.txt\') {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \',\': 1, \' \': 1, \'W\': 1, \'r\': 1, \'d\': 1, \'!\': 1} ``` Notes: - This includes all characters in the file content, including letters, digits, whitespace, punctuation, and special characters. - Use appropriate file handling to ensure the file is properly closed after reading. - Consider efficiency when dealing with large files. # Solution: ```python def count_characters(file_path: str) -> dict: char_count = {} with open(file_path, \'r\') as file: content = file.read() for char in content: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count ``` This question seamlessly integrates with the existing set by requiring thoughtful file handling and character counting logic, comparable in complexity and scope to the provided geometric series problem.","solution":"def count_characters(file_path: str) -> dict: Reads a file and counts the occurrences of each character. Returns a dictionary where keys are characters and values are their counts. Parameters: file_path (str): The path to the text file Returns: dict: A dictionary with character counts char_count = {} with open(file_path, \'r\') as file: content = file.read() for char in content: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Problem: Rotate a List to the Right by K Steps You are given a list of integers and an integer k. Write a function that rotates the list to the right by k steps. The rotation should be performed efficiently to handle large lists. # Function Signature ```python def rotate_list(nums: list[int], k: int) -> list[int]: ``` # Input * `nums`: A list of integers. * `k`: A non-negative integer representing the number of steps to rotate the list to the right. # Output * Returns the rotated list. # Examples ```python >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_list([1, 2, 3], 4) [3, 1, 2] >>> rotate_list([1], 5) [1] ``` # Constraints * The length of `nums` is n where 1 <= n <= 10^5. * 0 <= k <= 10^5. # Performance Requirements * Your solution must run in O(n) time complexity. * Your solution must use O(1) additional space. # Edge Cases to Consider * The list has only one element. * The value of k is larger than the length of the list. * k is equal to 0. * Rotating an empty list.","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k steps. Parameters: nums (list of int): The list of integers to be rotated. k (int): The number of steps to rotate the list to the right. Returns: list of int: The rotated list. if not nums: return nums n = len(nums) k = k % n # Normalize k if it\'s larger than the list size if k == 0: return nums return nums[-k:] + nums[:-k]"},{"question":"# Problem Statement You are tasked with checking if a given word pattern matches a sequence of words. Your job is to write a function that determines if there is a one-to-one correspondence between the characters in the pattern and the words in the given sequence. # Function Signature ```python def word_pattern(pattern: str, s: str) -> bool: ``` # Input * `pattern` (str): A string consisting of lowercase letters only, representing the pattern. * `s` (str): A string representing a sequence of words separated by spaces. # Output * Returns a boolean value `True` if the pattern matches the sequence of words, otherwise `False`. # Constraints * `1 <= len(pattern) <= 300` * `1 <= len(s) <= 3000` * The input strings contain only lowercase letters and spaces. * Words in `s` are separated by a single space. # Example Example 1 Input: ```python word_pattern(\\"abba\\", \\"dog cat cat dog\\") ``` Output: ```plaintext True ``` Explanation: The pattern `\\"abba\\"` matches the sequence `\\"dog cat cat dog\\"` because: * \'a\' -> \\"dog\\" * \'b\' -> \\"cat\\" Example 2 Input: ```python word_pattern(\\"abba\\", \\"dog cat cat fish\\") ``` Output: ```plaintext False ``` Explanation: The pattern `\\"abba\\"` does not match the sequence `\\"dog cat cat fish\\"` because: * \'a\' -> \\"dog\\" * \'b\' -> \\"cat\\" * \'a\' should match \\"dog\\", but it matches \\"fish\\" instead. # Notes 1. Each character in the pattern must map to a unique word, and each word must map to a unique character. 2. Handle edge cases such as an empty pattern or word sequence appropriately.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"String Pattern Matching Function # Context String patterns often need to be found within larger texts, which is common in text processing, search engines, and various applications involving data parsing. One frequent task in this context is to identify and count the occurrences of a specific pattern within a given text. # Task Implement a function `count_pattern_occurrences` that counts the number of times a specific pattern appears within a given text. The pattern matching should be case-insensitive. # Function Signature ```python def count_pattern_occurrences(text: str, pattern: str) -> int: pass ``` # Inputs and Outputs - **Input**: - `text`: A string representing the text in which to search. - `pattern`: A string representing the pattern to search for. - **Output**: - An integer representing the number of times the pattern occurs in the text. # Constraints - `text` and `pattern` will be non-empty strings. - The function should be case-insensitive with respect to both the text and pattern. # Example Usage ```python assert count_pattern_occurrences(\\"Hello World! Hello Universe!\\", \\"hello\\") == 2 assert count_pattern_occurrences(\\"Python is amazing. Python is fun.\\", \\"python\\") == 2 assert count_pattern_occurrences(\\"abababab\\", \\"ab\\") == 4 assert count_pattern_occurrences(\\"123456789\\", \\"123\\") == 1 assert count_pattern_occurrences(\\"Mississippi\\", \\"issi\\") == 2 ``` # Notes 1. Both the `text` and `pattern` should be processed in a case-insensitive manner. 2. Ensure the function is efficient enough to handle large text inputs. --- This question integrates with the existing set by focusing on a fundamental programming task, pattern matching in strings, while aligning with the complexity and scope observed in the given questions. The provided specification allows for clear expectations and executable examples for the function implementation.","solution":"def count_pattern_occurrences(text: str, pattern: str) -> int: Counts the number of case-insensitive occurrences of the pattern in the text. :param text: str: The text in which to search for the pattern. :param pattern: str: The pattern to search for. :return: int: The number of occurrences of the pattern in the text. text_lower = text.lower() pattern_lower = pattern.lower() count = 0 start = 0 while True: start = text_lower.find(pattern_lower, start) if start == -1: break count += 1 start += 1 return count"},{"question":"# Problem Statement You need to design a function that finds the longest substring of unique characters within a given string. This is useful in scenarios where identifying patterns without repetition is crucial, such as in genetic sequence analysis or data compression algorithms. # The context A company focusing on bioinformatics applications wants to integrate a feature in their software to analyze DNA sequences. One particular analysis involves finding the longest sequence of non-repeating DNA bases. # Function Specification Implement the `longest_unique_substring` function that returns the longest substring of unique characters from the given string. Function Signature ```python def longest_unique_substring(s: str) -> str: pass ``` Inputs * `s`: A string containing any combination of characters. Outputs * A string representing the longest substring of unique characters within the input string. Constraints * The length of `s` will not exceed 10^5 characters. * The string will only contain ASCII characters. Assumptions * If there are multiple substrings of the same maximum length, return the first one encountered. # Example ```python result = longest_unique_substring(\\"abrkaabcdefghijjxxx\\") print(result) # Expected output: \\"abcdefghij\\" ``` # Hints * Consider using a sliding window approach along with a set to track characters and ensure the uniqueness constraint. * Optimize for time efficiency, think about how to avoid re-evaluating characters unnecessarily.","solution":"def longest_unique_substring(s: str) -> str: This function returns the longest substring with unique characters from the given string s. start = 0 max_length = 0 max_substr_start = 0 seen = {} for i in range(len(s)): if s[i] in seen and seen[s[i]] >= start: start = seen[s[i]] + 1 seen[s[i]] = i if i - start + 1 > max_length: max_length = i - start + 1 max_substr_start = start return s[max_substr_start:max_substr_start + max_length]"},{"question":"# Coding Question: Word Ladder Pathfinding Context: In the Word Ladder problem, you transform one word into another by changing only one letter at a time, such that each transformed word must be a valid word in a given dictionary. You must find the shortest transformation sequence from a start word to an end word, if one exists. Task: Create a function that returns the length of the shortest transformation sequence from the start word to the end word, using Breadth-First Search (BFS). If no such transformation is possible, return 0. Requirements: * **Function Signature**: `def word_ladder_length(start: str, end: str, word_list: List[str]) -> int` * **Input**: * `start`: A string representing the start word. * `end`: A string representing the end word. * `word_list`: A list of strings representing the valid words. * **Output**: * An integer representing the length of the shortest transformation sequence from `start` to `end`. Return 0 if there is no valid transformation. * **Constraints**: * All strings are of the same length. * All characters are lowercase English letters. * The `start` word and `end` word are not empty and part of the `word_list`. Example: ```python assert word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) == 5 # Explanation: The shortest transformation is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\" assert word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) == 0 # Explanation: There is no valid transformation. ``` Challenge: Implement the function using the Breadth-First Search algorithm to ensure the shortest path is found efficiently. Make sure the function handles edge cases such as an empty word list or a word list that does not contain the end word.","solution":"from collections import deque from typing import List def word_ladder_length(start: str, end: str, word_list: List[str]) -> int: Returns the length of the shortest transformation sequence from start to end using the BFS algorithm, or 0 if no such transformation is possible. if end not in word_list: return 0 word_set = set(word_list) # To allow quick lookup queue = deque([(start, 1)]) # Queue contains tuples of (current_word, current_length) while queue: current_word, current_length = queue.popleft() if current_word == end: return current_length for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"# Task Write a function that extracts and returns the most frequent IP address from a given log file. Function Signature ```python def find_most_frequent_ip(log_file: str) -> str: Determines the most frequent IP address in the provided log file. Args: log_file (str): Path to the text file containing log entries. Returns: str: The most frequent IP address in the log file. ``` # Input * A text file (`log_file`) containing multiple lines, each representing a log entry that includes an IP address (i.e., \\"192.168.1.1 - - [date] \\"request\\" ...\\"). # Output * Return the most frequent IP address found in the log file. # Constraints * The file can contain up to 100,000 lines. * Each log entry is well-formatted, with IP addresses following the typical IPv4 notation. * Assume there are no ties for the most frequent IP. # Example Given a file `access.log` with the following content: ``` 192.168.1.1 - - [24/Feb/2023:10:23:57 +0000] \\"GET /index.html HTTP/1.1\\" 10.0.0.1 - - [24/Feb/2023:10:24:57 +0000] \\"POST /form HTTP/1.1\\" 192.168.1.1 - - [24/Feb/2023:10:25:57 +0000] \\"GET /contact.html HTTP/1.1\\" 10.0.0.2 - - [24/Feb/2023:10:26:57 +0000] \\"GET /about.html HTTP/1.1\\" ``` Calling `find_most_frequent_ip(\\"access.log\\")` should return `192.168.1.1`. # Notes * It is recommended to use a dictionary to tally the occurrences of each IP address. * Ensure efficient processing even for large files by reading the file line by line.","solution":"def find_most_frequent_ip(log_file: str) -> str: Determines the most frequent IP address in the provided log file. Args: log_file (str): Path to the text file containing log entries. Returns: str: The most frequent IP address in the log file. from collections import defaultdict ip_count = defaultdict(int) with open(log_file, \'r\') as file: for line in file: ip = line.split()[0] ip_count[ip] += 1 return max(ip_count, key=ip_count.get)"},{"question":"# Introduction You are enhancing a game where players control characters to perform various actions in a 2D grid-based world. One critical aspect is to accurately calculate the shortest path for a character to traverse from the starting position to a target position, considering any obstacles present on the grid. # Problem Description Write two functions `find_shortest_path` and `is_path_possible` that take specific input parameters and return the shortest path in terms of steps and whether a path is possible. Function 1: `find_shortest_path` Write a function `find_shortest_path` that utilizes the A* algorithm to calculate the shortest path. **Function Signature**: ```python def find_shortest_path( grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> int: ``` **Input**: - `grid` (List[List[int]]): 2D grid where 0 represents an open cell and 1 represents an obstacle. - `start` (Tuple[int, int]): Starting position as (row, column). - `target` (Tuple[int, int]): Target position as (row, column). **Output**: - (int): The number of steps in the shortest path from start to target, or -1 if no valid path exists. **Constraints**: - The grid dimensions will be between 2x2 and 100x100. - The start and target positions will be within the bounds of the grid. - The start and target positions will always be open cells (0). Function 2: `is_path_possible` Write a function `is_path_possible` that checks if a path from start to target is feasible. **Function Signature**: ```python def is_path_possible( grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> bool: ``` **Input**: - `grid` (List[List[int]]): 2D grid where 0 represents an open cell and 1 represents an obstacle. - `start` (Tuple[int, int]): Starting position as (row, column). - `target` (Tuple[int, int]): Target position as (row, column). **Output**: - (bool): True if a valid path from start to target exists, False otherwise. **Constraints**: - The grid dimensions will be between 2x2 and 100x100. - The start and target positions will be within the bounds of the grid. - The start and target positions will always be open cells (0). # Example ```python grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] start = (0, 0) target = (4, 4) assert find_shortest_path(grid, start, target) == 8 assert is_path_possible(grid, start, target) == True ``` # Note - Ensure to handle edge cases such as grids filled completely with obstacles or minimal paths. - Properly handle invalid inputs per specified constraints. - The solution should include necessary imports and follow proper coding standards.","solution":"from typing import List, Tuple import heapq def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_shortest_path( grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> int: rows, cols = len(grid), len(grid[0]) open_set = [(0, start)] heapq.heapify(open_set) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, target)} while open_set: current_f, current = heapq.heappop(open_set) if current == target: return g_score[current] for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, target) if neighbor not in [i[1] for i in open_set]: heapq.heappush(open_set, (f_score[neighbor], neighbor)) return -1 def is_path_possible( grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> bool: return find_shortest_path(grid, start, target) != -1"},{"question":"# Problem Description You are given an integer n. Your task is to implement a function to generate the first n numbers of the Fibonacci sequence using an iterative approach. The function should handle the edge cases appropriately. # Function Signature ```python def generate_fibonacci(n: int) -> list: pass ``` # Input * `n` (int): An integer representing the number of terms to generate in the Fibonacci sequence. # Output * A list containing the first n numbers in the Fibonacci sequence. # Constraints * `0 <= n <= 30` * The function must be implemented using an iterative approach. # Example ```python # Test Case 1 assert generate_fibonacci(5) == [0, 1, 1, 2, 3] # Test Case 2 assert generate_fibonacci(1) == [0] # Test Case 3 assert generate_fibonacci(0) == [] # Test Case 4 assert generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Explanation: 1. In test case 1, the first 5 Fibonacci numbers are `[0, 1, 1, 2, 3]`. 2. In test case 2, the first Fibonacci number is `[0]`. 3. In test case 3, when `n` is `0`, the resulting list is empty. 4. In test case 4, the first 10 Fibonacci numbers are `[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]`. Use the provided starting code to implement your solution. Make sure your function adheres to the function signature specified above.","solution":"def generate_fibonacci(n: int) -> list: Generates the first n numbers in the Fibonacci sequence using an iterative approach. Args: n (int): Number of terms to generate in the Fibonacci sequence. Returns: list: A list containing the first n Fibonacci numbers. if n == 0: return [] if n == 1: return [0] fibonacci_sequence = [0, 1] for _ in range(2, n): next_value = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_value) return fibonacci_sequence"},{"question":"# Coding Assessment Question You are required to design a function that retrieves the latest global weather data from the OpenWeatherMap API and processes it for a given set of cities. The function should include error handling, the ability to select specific weather attributes, and options to handle requests efficiently. Function Specification **Function Name**: `get_weather_data` **Input Parameters**: 1. `city_names`: (list of str) List of city names for which to fetch weather data. 2. `attributes`: (list of str) List of weather attributes to be returned for each city (e.g., temperature, humidity, weather description). Default is to return all attributes. 3. `use_cache`: (bool) Optional parameter to indicate if the function should use cached data when available. Default is `True`. **Output**: - If successful, returns a dictionary where each key is a city name, and the value is another dictionary containing the requested weather attributes. - In case of failures, returns an appropriate error message or an empty dictionary. **Constraints**: - City names should be valid and within the API\'s supported cities. - The `attributes` list, if provided, should only include valid weather attribute names available from the API. - Implement caching mechanisms to store responses for previously fetched cities to avoid redundant API calls. Example Usage ```python def get_weather_data(city_names: list, attributes: list = [], use_cache=True) -> dict: # Your implementation here pass # Example call cities = [\\"London\\", \\"New York\\", \\"Tokyo\\"] attributes = [\\"temperature\\", \\"humidity\\"] results = get_weather_data(cities, attributes) for city, data in results.items(): print(f\\"Weather data for {city}: {data}\\") ``` # Requirements: 1. **Error Handling**: Your implementation should handle API errors, invalid city names, and empty responses. 2. **Caching**: Implement a caching mechanism to store previous responses in memory and allow re-use when `use_cache` is `True`. 3. **Efficiency**: Ensure that the solution handles multiple city requests efficiently, avoiding significant performance issues. 4. **Clear Documentation and Code**: Provide meaningful function and variable names, and ensure your code is well-documented. You have 2 hours to complete this task. Good luck!","solution":"import requests from typing import List, Dict # Simple in-memory cache cache = {} def get_weather_data(city_names: List[str], attributes: List[str] = [], use_cache: bool = True) -> Dict: api_key = \'YOUR_API_KEY_HERE\' base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" # Prepare the output dictionary results = {} for city in city_names: if use_cache and city in cache: response_data = cache[city] else: params = { \'q\': city, \'appid\': api_key, \'units\': \'metric\' # For temperature in Celsius } try: response = requests.get(base_url, params=params) if response.status_code != 200: results[city] = f\\"Error: {response.json().get(\'message\', \'Unknown error\')}\\" continue response_data = response.json() if use_cache: cache[city] = response_data except requests.RequestException as e: results[city] = f\\"Error: {e}\\" continue # Extract the desired attributes city_weather_data = {} if not attributes: city_weather_data = response_data else: for attr in attributes: if attr == \\"temperature\\": city_weather_data[attr] = response_data.get(\\"main\\", {}).get(\\"temp\\") elif attr == \\"humidity\\": city_weather_data[attr] = response_data.get(\\"main\\", {}).get(\\"humidity\\") elif attr == \\"weather description\\": weather = response_data.get(\\"weather\\", [{}]) if len(weather) > 0: city_weather_data[attr] = weather[0].get(\\"description\\") results[city] = city_weather_data return results"},{"question":"# Coding Assessment Question: **Scenario**: Turing Tech Company is working on creating a secure login system where users must provide an 8-character password composed of lowercase letters, uppercase letters, digits, and special characters (`!@#%^&*()`). To enhance security, they want to generate random passwords that meet the following criteria: 1. Contain at least one lowercase letter. 2. Contain at least one uppercase letter. 3. Contain at least one digit. 4. Contain at least one special character. **Task**: Implement a function that generates a random 8-character password that meets all the above criteria. **Function Signature**: ```python gen_passwd) -> str: Function to generate a random 8-character password that meets the specified criteria. Returns: A string representing the generated password. pass ``` **Input**: This function does not take any inputs. **Output**: A string representing the generated password with the conditions: 1. It should be exactly 8 characters long. 2. It must include at least one lowercase letter, one uppercase letter, one digit, and one special character. **Example:** ```python passwd = gen_passwd() print(passwd) # Expected output: A sample output could be \'A7b&1d!\' # Note: Outputs will be random but should meet the criteria. ``` **Hints**: 1. You can use Python\'s built-in libraries such as `random` and `string` to help with the implementation. 2. Validate the generated password to ensure it meets all the criteria before returning it. **Constraints**: * The password must be exactly 8 characters long. * The password must include at least one of each: lowercase letter, uppercase letter, digit, and special character. **Note**: Ensure your implementation is efficient and generates a valid password within a reasonable amount of time even under multiple function calls.","solution":"import random import string def gen_passwd() -> str: Function to generate a random 8-character password that meets the specified criteria. Returns: A string representing the generated password. all_chars = string.ascii_lowercase + string.ascii_uppercase + string.digits + \\"!@#%^&*()\\" password = [] # Ensure at least one of each required type password.append(random.choice(string.ascii_lowercase)) password.append(random.choice(string.ascii_uppercase)) password.append(random.choice(string.digits)) password.append(random.choice(\\"!@#%^&*()\\")) # Fill the rest of the password length (8-4=4 more characters) for _ in range(4): password.append(random.choice(all_chars)) # Shuffle the list to ensure randomness random.shuffle(password) return \'\'.join(password)"},{"question":"# Coding Assessment Question: Find the Most Frequent Element in a Matrix Given a function to find the most frequent element in a matrix, your task is to implement this functionality and handle various edge cases, such as multiple elements having the same highest frequency and handling large matrix inputs efficiently. Problem Description Write a function `find_most_frequent_element(matrix: List[List[int]]) -> int` that takes in a 2D list representing a matrix and returns the element with the highest frequency. If multiple elements have the same highest frequency, return the smallest one. Input - `matrix`: A 2D list of integers, any size up to 1,000,000 total elements. Each sublist represents a row of the matrix and is of any length. Output - An integer representing the most frequent element. If there are multiple elements with the highest frequency, return the smallest one. Example ```python def find_most_frequent_element(matrix: List[List[int]]) -> int: from collections import Counter frequency = Counter() for row in matrix: frequency.update(row) most_common_element = min(frequency.items(), key=lambda x: (-x[1], x[0]))[0] return most_common_element matrix = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] print(find_most_frequent_element(matrix)) # Expected Output: 3 ``` Constraints - Matrix can be of any size, but the total number of elements in the matrix will not exceed 1,000,000. - Each element in the matrix will be an integer between –2^31 and +2^31 – 1 inclusive. Performance Requirements - The algorithm should operate with an average time complexity of O(N), where N is the total number of elements in the matrix. - Space complexity should aim for O(N) in worst-case scenarios. --- Your task is to create efficient code to identify the most frequent element in a potentially large matrix while ensuring it handles any edge cases as specified.","solution":"from typing import List from collections import Counter def find_most_frequent_element(matrix: List[List[int]]) -> int: Returns the most frequent element in the given matrix. If multiple elements have the same highest frequency, returns the smallest element. frequency = Counter() # Update frequencies for each row in the matrix for row in matrix: frequency.update(row) # Find the most common element, preferring smaller elements if tied most_common_element = min(frequency.items(), key=lambda x: (-x[1], x[0]))[0] return most_common_element"},{"question":"# Problem Statement **Background**: Merge sort is a popular sorting algorithm that uses the divide-and-conquer strategy to sort an array. It works by recursively dividing the array into two halves until each half contains only one element, and then merging those halves in a sorted manner. # Description Implement a function `merge_sort` that sorts a given list of integers using the merge sort algorithm. The function should: 1. Recursively split the input list into halves until each half contains a single element. 2. Merge the halves back together in sorted order using an auxiliary merge function. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where the length is 0 <= len(arr) <= 10^6, and -10^9 <= arr[i] <= 10^9. # Output - Returns a sorted list of integers. # Constraints - The function should handle lists with up to 10^6 elements efficiently. - Consider edge cases like empty lists and identical elements. # Performance Requirements - Time complexity should be O(n log n) in the average and worst cases. - Auxillary space should be O(n) due to the merging process. # Example ```python assert merge_sort([3, 1, 4, 1, 5, 9, 2]) == [1, 1, 2, 3, 4, 5, 9] assert merge_sort([5, -2, -2, 2, 0, 8, 7]) == [-2, -2, 0, 2, 5, 7, 8] assert merge_sort([]) == [] ``` # Constraints and Notes - Use a helper function for merging two sorted subarrays. - Ensure that your implementation handles edge cases, including very small or very large numbers. - Aim for clear and maintainable code by using appropriate variable names and comments.","solution":"def merge_sort(arr): Sorts a list of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into a single sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"# Problem Statement: You are required to implement a text encryption and decryption scheme using the Vigenère Cipher. The Vigenère Cipher involves a keyword, where each letter in the keyword shifts the corresponding letter in the plaintext by its alphabetical order. # Function Requirements: 1. **`vigenere_encrypt(keyword: str, plaintext: str) -> str`**: - **Input**: - `keyword` (string): The keyword used for encryption. - `plaintext` (string): The text to be encrypted. - **Output**: - Return the resulting ciphertext as a string. 2. **`vigenere_decrypt(keyword: str, ciphertext: str) -> str`**: - **Input**: - `keyword` (string): The keyword used for decryption. - `ciphertext` (string): The text to be decrypted. - **Output**: - Return the resulting plaintext as a string. # Constraints: - The `keyword` and `plaintext/ciphertext` will only contain alphabetic characters and spaces. - The letters should be converted to uppercase, and spaces should be removed during processing. - Your implementation should handle edge cases like empty strings and keyword repetitions appropriately. # Example: ```python keyword = \\"LEMON\\" # Example Encryption plaintext = \\"ATTACK AT DAWN\\" ciphertext = vigenere_encrypt(keyword, plaintext) assert ciphertext == \\"LXFOPVEFRNHR\\" # Example Decryption decrypted_text = vigenere_decrypt(keyword, ciphertext) assert decrypted_text == \\"ATTACKATDAWN\\" ``` # Additional Requirements: - Focus on time and space efficiency. - Ensure all parts of the transformations are clearly legible and well-commented. - Take care of edge cases and provide proper verification using assert statements. This new question integrates seamlessly with the provided corpus, matching its style, tone, and complexity level while exploring the related concept of the Vigenère Cipher, ensuring a comprehensive assessment.","solution":"def vigenere_encrypt(keyword: str, plaintext: str) -> str: Encrypts the plaintext using the Vigenère cipher and the given keyword. :param keyword: The keyword for encryption :param plaintext: The text to be encrypted :return: The encrypted ciphertext keyword = keyword.upper().replace(\\" \\", \\"\\") plaintext = plaintext.upper().replace(\\" \\", \\"\\") keyword_repeated = (keyword * (len(plaintext) // len(keyword) + 1))[:len(plaintext)] ciphertext = [] for p, k in zip(plaintext, keyword_repeated): encrypted_char = chr(((ord(p) - ord(\'A\')) + (ord(k) - ord(\'A\'))) % 26 + ord(\'A\')) ciphertext.append(encrypted_char) return \'\'.join(ciphertext) def vigenere_decrypt(keyword: str, ciphertext: str) -> str: Decrypts the ciphertext using the Vigenère cipher and the given keyword. :param keyword: The keyword for decryption :param ciphertext: The text to be decrypted :return: The decrypted plaintext keyword = keyword.upper().replace(\\" \\", \\"\\") ciphertext = ciphertext.upper().replace(\\" \\", \\"\\") keyword_repeated = (keyword * (len(ciphertext) // len(keyword) + 1))[:len(ciphertext)] plaintext = [] for c, k in zip(ciphertext, keyword_repeated): decrypted_char = chr(((ord(c) - ord(\'A\')) - (ord(k) - ord(\'A\')) + 26) % 26 + ord(\'A\')) plaintext.append(decrypted_char) return \'\'.join(plaintext)"},{"question":"# Coding Assessment Question You are tasked with developing a function that interacts with a weather API to fetch current weather data based on a city name. The current implementation retrieves only the temperature. As a developer, your goal is to capture more details about the weather and handle potential issues effectively. Function Specifications You must write a function `get_weather_info` that collects detailed weather information and manages various edge cases robustly. **Function Signature**: ```python def get_weather_info(city: str, api_key: str = \\"YOUR API KEY\\") -> dict: ``` **Expected Input**: - `city` (str): The city name for which the weather information is to be fetched. - `api_key` (str): Your weather API key. **Expected Output**: - Returns a dictionary with the following structure: ```python { \\"city\\": city, \\"temperature\\": temperature_in_Celsius, \\"humidity\\": humidity_percentage, \\"description\\": weather_description, \\"wind_speed\\": wind_speed_in_kmh } ``` **Constraints**: - Handle cases where the API may return errors such as invalid city name or API key issues. - Ensure the function is resilient against network problems. - Limit the number of retries for failed requests to 3 and handle each exception appropriately. **Performance Requirements**: - Optimize the response time for API calls. - Make sure the function can handle frequent calls without imprudent resource consumption. **Context**: Suppose you are creating an application that displays live weather data for any given city. Obtaining comprehensive weather information will significantly enhance the user experience by providing more context and detail about the current weather conditions. # Example Usage ```python result = get_weather_info(city=\\"New York\\") print(result) ``` # Example Output ```python { \\"city\\": \\"New York\\", \\"temperature\\": 22.5, \\"humidity\\": 60, \\"description\\": \\"clear sky\\", \\"wind_speed\\": 5.5 } ```","solution":"import requests def get_weather_info(city: str, api_key: str = \\"YOUR_API_KEY\\") -> dict: base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" params = { \\"q\\": city, \\"appid\\": api_key, \\"units\\": \\"metric\\" } retries = 3 while retries > 0: try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() return { \\"city\\": data[\\"name\\"], \\"temperature\\": data[\\"main\\"][\\"temp\\"], \\"humidity\\": data[\\"main\\"][\\"humidity\\"], \\"description\\": data[\\"weather\\"][0][\\"description\\"], \\"wind_speed\\": data[\\"wind\\"][\\"speed\\"] } except requests.RequestException as e: retries -= 1 if retries == 0: return {\\"error\\": str(e)} except (ValueError, KeyError) as e: return {\\"error\\": f\\"Error parsing data: {e}\\"}"},{"question":"# Question: Fibonacci GCD Consider two sequences: * The Fibonacci sequence: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1. * A sequence based on the greatest common divisor (GCD): G(n) = gcd(F(n), F(n+1)). Your task is to compute the G(n) for a given n. **Function to Implement:** ```python def fibonacci_gcd(n: int) -> int: Calculates the GCD of the n-th and (n+1)-th Fibonacci numbers. Args: n (int): The index of the Fibonacci sequence. Returns: int: The GCD of F(n) and F(n+1). ``` **Expected Input & Output:** * There is one input parameter n, an integer (1 <= n <= 10^5). * The output should be an integer representing the GCD of the n-th and (n+1)-th Fibonacci numbers. **Constraints:** * The calculated GCD may potentially be large, ensure efficient calculation and optimal space management. **Example:** ```python >>> fibonacci_gcd(10) 1 >>> fibonacci_gcd(5) 1 ``` **Evaluation Criteria:** * Correctness: Ensure all test cases, including edge cases, are handled correctly. * Efficiency: Implement an efficient solution to handle the maximum constraints. * Readability: Write clean, maintainable code with necessary comments.","solution":"def fibonacci_gcd(n: int) -> int: Calculates the GCD of the n-th and (n+1)-th Fibonacci numbers. Args: n (int): The index of the Fibonacci sequence. Returns: int: The GCD of F(n) and F(n+1). return 1 # Since gcd(F(n), F(n+1)) is always 1 for n >= 1"},{"question":"# Question: Calculate the N-th Power of a Given Matrix **Context**: Matrix exponentiation is an important technique used in various fields such as computer graphics, cryptography, and solving linear recurrence relations. Given a square matrix, computing its power can be performed efficiently using an approach known as \\"Exponentiation by Squaring\\". **Task**: Write a Python function `matrix_power(matrix: List[List[int]], n: int) -> List[List[int]]` that calculates the n-th power of a given square matrix. # Input * A 2D list `matrix` representing a square matrix (1 ≤ len(matrix) ≤ 10, -10^9 ≤ matrix[i][j] ≤ 10^9). * An integer `n` which represents the power to which the matrix is to be raised (0 ≤ n ≤ 10^9). # Output * A 2D list representing the resulting matrix after raising the input matrix to the n-th power. # Constraints * You must use an efficient algorithm such as Exponentiation by Squaring to handle large exponent values within a reasonable time frame. * Ensure that the matrix multiplication handles large integers safely. # Example ```python # Given matrix = [[1, 2], [3, 4]] and n = 2 # The resulting matrix after raising to power 2: # [[7, 10], [15, 22]] print(matrix_power([[1, 2], [3, 4]], 2)) # Output: [[7, 10], [15, 22]] ``` # Implementation Details 1. Define a helper function `identity_matrix(size: int) -> List[List[int]]` to generate an identity matrix of a given size. 2. Implement matrix multiplication as `multiply_matrices(a: List[List[int]], b: List[List[int]]) -> List[List[int]]`. 3. Use Exponentiation by Squaring to efficiently compute the n-th power of the matrix within `matrix_power`. # Hints * The identity matrix is the multiplicative identity in matrix exponentiation (/A x I = I x A = A/). * Exponentiation by Squaring minimizes the number of multiplications to approximately log2(n).","solution":"from typing import List def identity_matrix(size: int) -> List[List[int]]: Generates an identity matrix of a given size. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def multiply_matrices(a: List[List[int]], b: List[List[int]]) -> List[List[int]]: Multiplies two matrices a and b. size = len(a) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): result[i][j] = sum(a[i][k] * b[k][j] for k in range(size)) return result def matrix_power(matrix: List[List[int]], n: int) -> List[List[int]]: Computes the n-th power of a given square matrix using Exponentiation by Squaring. size = len(matrix) result = identity_matrix(size) base = matrix while n > 0: if n % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) n //= 2 return result"},{"question":"Question: Find the Majority Element Given an array of integers, write a function to find the majority element. A majority element in an array of size `n` is an element that appears more than `n/2` times. Implement both the Boyer-Moore Voting Algorithm and a method using a hash map. # Function Signatures ```python def majority_element_boyer_moore(arr: list[int]) -> int: pass def majority_element_hash_map(arr: list[int]) -> int: pass ``` # Input - A list of integers `arr` (1 ≤ len(arr) ≤ 10^5). # Output - An integer representing the majority element in the list `arr`. # Constraints - The function should raise a `ValueError` if no majority element exists. # Example ```python assert majority_element_boyer_moore([3, 2, 3]) == 3 assert majority_element_boyer_moore([2, 2, 1, 1, 1, 2, 2]) == 2 assert majority_element_boyer_moore([1, 1, 1, 3, 3, 2, 2, 2]) == ValueError assert majority_element_hash_map([3, 2, 3]) == 3 assert majority_element_hash_map([2, 2, 1, 1, 1, 2, 2]) == 2 assert majority_element_hash_map([1, 1, 1, 3, 3, 2, 2, 2]) == ValueError ``` # Notes - Test and compare the performance of both implementations for various list sizes and configurations. - Ensure that your code handles edge cases and performs efficiently. Explore how these algorithms can detect majority elements effectively and apply them to different data scenarios. The hash map method might have different performance characteristics compared to the Boyer-Moore algorithm, especially in terms of space complexity.","solution":"def majority_element_boyer_moore(arr: list[int]) -> int: Function to find the majority element using Boyer-Moore Voting Algorithm. count = 0 candidate = None for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify if the candidate is really the majority element if arr.count(candidate) > len(arr) // 2: return candidate else: raise ValueError(\\"No majority element found\\") def majority_element_hash_map(arr: list[int]) -> int: Function to find the majority element using a hash map. from collections import defaultdict freq = defaultdict(int) majority_count = len(arr) // 2 for num in arr: freq[num] += 1 if freq[num] > majority_count: return num raise ValueError(\\"No majority element found\\")"},{"question":"# Problem Statement Given a list of student records, where each record contains a student\'s name and their scores in various subjects, write a function to compute the average score for each student and return the student with the highest average score. If there are multiple students with the same average score, return the one who appears earliest in the input list. # Function Signature ```python def top_student(records: list[tuple[str, list[int]]]) -> str: pass ``` # Input - `records`: A list of tuples. Each tuple contains: * A string, the student\'s name. * A list of integers, the student\'s scores in various subjects. # Output - The function should return a string, the name of the student with the highest average score. # Constraints - 1 ≤ len(records) ≤ 100 - 1 ≤ len(scores) ≤ 10 - 0 ≤ score ≤ 100 # Example ```python records = [ (\\"John Doe\\", [88, 92, 95]), (\\"Jane Smith\\", [85, 90, 92]), (\\"Emily Davis\\", [90, 85, 85]), (\\"Chris Johnson\\", [70, 80, 90]) ] print(top_student(records)) # Expected: \\"John Doe\\" ``` # Notes - Ensure you handle cases with students having the same average score by returning the student who appears first in the list. - Calculate the average by summing the student\'s scores and dividing by the number of subjects, using floating point division. - Assume that the input is always valid and there is at least one student record in the list.","solution":"def top_student(records): Returns the name of the student with the highest average score. If there are multiple students with the same average score, the one who appears earliest in the input list is returned. def average(scores): return sum(scores) / len(scores) top_student_name = \\"\\" highest_avg_score = float(\'-inf\') for student, scores in records: avg_score = average(scores) if avg_score > highest_avg_score: highest_avg_score = avg_score top_student_name = student return top_student_name"},{"question":"# Problem Statement: You are assigned the task to simulate a basic recommendation system in a social media platform where users can follow each other. Your goal is to create a function that can suggest friends for a user based on their current friends\' connections. Create the following functions: 1. **`add_user`**: Adds a new user to the network. 2. **`add_connection`**: Establishes a following relationship between two users. 3. **`get_user_following`**: Retrieves a list of all users that a given user is following. 4. **`suggest_friends`**: Suggests potential friends for a user based on the users their friends follow (excluding users the given user is already following). # Function Signatures: 1. **`def add_user(network: dict, user: str) -> None:`** 2. **`def add_connection(network: dict, user: str, follows: str) -> None:`** 3. **`def get_user_following(network: dict, user: str) -> list:`** 4. **`def suggest_friends(network: dict, user: str) -> list:`** # Input: - `network`: A dictionary representing the social network where the keys are user names and the values are sets of users they follow. - `user`: A string representing the user\'s name. - `follows`: A string representing the user to be followed. # Constraints: - Usernames are unique and consist of lowercase alphabets. - Users can follow any number of other users, including zero. - A user cannot follow themselves. - The analysis should be case-sensitive (e.g., \'alice\' and \'Alice\' are different users). # Output: - For `add_user`, `add_connection`: These functions should modify the `network` dictionary in place and return `None`. - For `get_user_following`: The function returns a list of users the input user is following. - For `suggest_friends`: The function returns a list of suggested friends for the user based on their friends\' connections. # Example: ```python network = {} # Add users add_user(network, \'alice\') add_user(network, \'bob\') add_user(network, \'charlie\') add_user(network, \'diana\') # Create connections add_connection(network, \'alice\', \'bob\') add_connection(network, \'bob\', \'charlie\') add_connection(network, \'charlie\', \'diana\') # Get the list of users Alice is following following_alice = get_user_following(network, \'alice\') print(following_alice) # Output: [\'bob\'] # Suggest friends for Alice suggested_friends_alice = suggest_friends(network, \'alice\') print(suggested_friends_alice) # Output: [\'charlie\'] ``` # Explanation: 1. **`add_user`**: This function adds a new user to the network dictionary with an empty set. 2. **`add_connection`**: This function adds a connection between the given user and the user to be followed. 3. **`get_user_following`**: This function returns a list of users that the input user is following. 4. **`suggest_friends`**: This function suggests friends by looking at the users that friends of the input user are following, and excludes those already followed by the input user. Write the functions following the given signatures and constraints.","solution":"def add_user(network: dict, user: str) -> None: Adds a new user to the network. if user not in network: network[user] = set() def add_connection(network: dict, user: str, follows: str) -> None: Establishes a following relationship between two users. if user in network and follows in network and user != follows: network[user].add(follows) def get_user_following(network: dict, user: str) -> list: Retrieves a list of all users that a given user is following. if user in network: return list(network[user]) return [] def suggest_friends(network: dict, user: str) -> list: Suggests potential friends for a user based on the users their friends follow (excluding users the given user is already following). if user not in network: return [] following = network[user] suggested_friends = set() for friend in following: if friend in network: for fof in network[friend]: # Friends of friend if fof != user and fof not in following: suggested_friends.add(fof) return list(suggested_friends)"},{"question":"# Scenario: You are developing a software for a retail company to analyze customer transactions. One of the features required is to identify the most popular item in terms of the number of purchases across all transactions. # Function Requirements: * Implement a function `most_popular_item` that takes a list of transactions and returns the item (represented by its name) that appears the most frequently. * If there is a tie (multiple items with the same highest frequency), return any one of the most frequent items. * Each transaction is represented as a list of item names. # Constraints: * Assume the list of transactions will always contain at least one transaction and each transaction will contain at least one item. * All item names are non-empty strings. # Function Signature: ```python def most_popular_item(transactions: List[List[str]]) -> str: pass ``` # Example: ```python assert most_popular_item([[\\"apple\\", \\"banana\\", \\"apple\\"], [\\"banana\\", \\"orange\\"], [\\"apple\\", \\"orange\\", \\"orange\\"]]) == \\"apple\\" or most_popular_item([[\\"apple\\", \\"banana\\", \\"apple\\"], [\\"banana\\", \\"orange\\"], [\\"apple\\", \\"orange\\", \\"orange\\"]]) == \\"orange\\" assert most_popular_item([[\\"milk\\", \\"bread\\"], [\\"milk\\"], [\\"bread\\", \\"milk\\"], [\\"milk\\", \\"bread\\", \\"egg\\"]]) == \\"milk\\" ``` # Input: - `transactions` (List[List[str]]): A list of transactions, where each transaction is a list of strings representing item names. # Output: - (str): The name of the most frequently purchased item. **Good luck!**","solution":"from typing import List from collections import Counter def most_popular_item(transactions: List[List[str]]) -> str: Identifies the most popular item in terms of the number of purchases across all transactions. :param transactions: List of transactions, where each transaction is a list of item names. :return: The name of the most frequently purchased item. # Flatten the list of transactions into a single list of items all_items = [item for transaction in transactions for item in transaction] # Count the frequency of each item using a Counter item_counts = Counter(all_items) # Find the item with the highest frequency most_popular = item_counts.most_common(1)[0][0] return most_popular"},{"question":"# Matrix Rotation: Clockwise and Counter-Clockwise Scenario You are tasked with rotating a given square matrix in two different directions: 90 degrees clockwise and 90 degrees counter-clockwise. You need to implement two functions for rotating the matrix in the specified directions. Input and Output * Input: * A list of lists `matrix` representing a square matrix of integers, where each list represents a row of the matrix. * Output: * Two separate lists of lists representing the rotated matrix: one for the rotation by 90 degrees clockwise and the other for the rotation by 90 degrees counter-clockwise. Constraints * The matrix will always be a square matrix (i.e., the number of rows equals the number of columns). * The size of the matrix can be up to 50x50. * The values in the matrix are integers within the range of -1000 to 1000. Performance Requirements * Both rotation functions should complete within 1 second for the largest input size (50x50). Functions Definition ```python def rotate_matrix_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate a square matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): The input square matrix. Returns: list[list[int]]: The rotated matrix. # Implementation goes here def rotate_matrix_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate a square matrix by 90 degrees counter-clockwise. Args: matrix (list[list[int]]): The input square matrix. Returns: list[list[int]]: The rotated matrix. # Implementation goes here ``` Implement the above methods so that their performance and outputs can be compared. Example ```python # Example 1: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_matrix_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] # Example 2: matrix = [ [1, 2], [3, 4] ] print(rotate_matrix_clockwise(matrix)) # Output: # [ # [3, 1], # [4, 2] # ] print(rotate_matrix_counterclockwise(matrix)) # Output: # [ # [2, 4], # [1, 3] # ] ```","solution":"def rotate_matrix_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate a square matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): The input square matrix. Returns: list[list[int]]: The rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix def rotate_matrix_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate a square matrix by 90 degrees counter-clockwise. Args: matrix (list[list[int]]): The input square matrix. Returns: list[list[int]]: The rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[n - 1 - j][i] = matrix[i][j] return rotated_matrix"},{"question":"# Problem Statement You are given a list of words and a string `text`. Your task is to count the number of times each word in the list appears in the string `text`. The words in the list and the string are case-sensitive and punctuation marks should be treated as part of the words. Implement the function `count_word_occurrences(words: list, text: str) -> dict` where: **Input**: * `words` (list): A list of strings representing the words to count. * `text` (str): A string in which to count the occurrences of each word. **Output**: * (dict): A dictionary where each key is a word from the list, and the corresponding value is the count of its occurrences in the `text`. **Constraints**: * The list `words` cannot be empty. * The string `text` cannot be empty. * Each word in the list is unique and contains only alphanumeric characters. **Example**: ```python >>> count_word_occurrences([\\"apple\\", \\"banana\\", \\"orange\\"], \\"apple banana apple apple orange banana.\\") {\'apple\': 3, \'banana\': 2, \'orange\': 1} >>> count_word_occurrences([\\"dog\\", \\"cat\\"], \\"The dog chased the cat, and the cat climbed a tree.\\") {\'dog\': 1, \'cat\': 2} ``` **Notes**: * If the list of words is empty, raise a `ValueError` with the message \\"word list cannot be empty\\". * If the string `text` is empty, raise a `ValueError` with the message \\"text cannot be empty\\".","solution":"def count_word_occurrences(words: list, text: str) -> dict: if not words: raise ValueError(\\"word list cannot be empty\\") if not text: raise ValueError(\\"text cannot be empty\\") word_count = {word: 0 for word in words} text_words = text.split() for word in text_words: if word in word_count: word_count[word] += 1 return word_count"},{"question":"# Coding Problem: Largest Divisible Subset **Problem Statement**: Given an array of distinct positive integers `nums`, return the largest subset in which every pair `(Si, Sj)` of elements satisfies `Si % Sj == 0` or `Sj % Si == 0`. If there are multiple solutions, return any of them. **Input**: - A list `nums` of distinct positive integers. **Output**: - Return the largest subset (as a list of integers) which satisfies the condition described. **Function Signature**: ```python def largestDivisibleSubset(nums: List[int]) -> List[int]: pass ``` **Constraints**: - The length of `nums` is between 1 and 1000. - The integers in `nums` are between 1 and 2 * 10^9. **Example**: ```python >>> largestDivisibleSubset([1, 2, 3]) [1, 2] # Or [1, 3] >>> largestDivisibleSubset([1, 2, 4, 8]) [1, 2, 4, 8] ``` **Requirements**: - Your solution should use efficient time and space complexity. - Handle the edge cases where `nums` is small or consists of prime numbers. Implement the function `largestDivisibleSubset` following the requirements shown above. Your solution should demonstrate a clear understanding of dynamic programming principles and subset generation.","solution":"from typing import List def largestDivisibleSubset(nums: List[int]) -> List[int]: if not nums: return [] nums.sort() dp = [[] for _ in range(len(nums))] dp[0] = [nums[0]] for i in range(1, len(nums)): max_subset = [] for j in range(i): if nums[i] % nums[j] == 0 and len(dp[j]) > len(max_subset): max_subset = dp[j] dp[i] = max_subset + [nums[i]] return max(dp, key=len)"},{"question":"# Anagram Substrings Finder Given two strings, determine if one string is an anagram of a substring of the other string. An anagram is a rearrangement of letters to form another word. You are tasked with implementing a function that checks if any substring of the first string is an anagram of the second string. # Task 1. Implement a method to check if any substring of a given string (first string) is an anagram of another string (second string). This can be efficiently solved using a sliding window approach along with a frequency count of characters. 2. Ensure the function returns a boolean value indicating whether the anagram substring exists. Function Signature ```python def find_anagram_substring(s: str, p: str) -> bool: Check if any substring of s is an anagram of p. ``` Input and Output Specifications: - **Input**: - `s` (string): The main string to be checked for anagram substrings. - `p` (string): The string for which we need to find an anagram substring in `s`. - **Output**: - Returns `True` if an anagram of `p` exists as a substring in `s`, otherwise `False`. Constraints: - The length of `s` and `p` will be between 1 and 10^4. - Both `s` and `p` will consist of lowercase English letters only. # Example 1. Example 1 ```python s = \\"cbaebabacd\\" p = \\"abc\\" ``` Output: `True` Explanation: The substring \\"cba\\" and \\"bac\\" in `s` are anagrams of `p`. 2. Example 2 ```python s = \\"abcdefg\\" p = \\"hij\\" ``` Output: `False` Explanation: There is no substring in `s` that is an anagram of `p`. 3. Example 3 ```python s = \\"abab\\" p = \\"ab\\" ``` Output: `True` Explanation: The substring \\"ab\\", \\"ba\\", and \\"ab\\" in `s` are all anagrams of `p`. # Additional Notes - Utilize a sliding window approach instead of brute-force checking each substring. - The function should be optimized for performance considering the length constraints. Good luck!","solution":"def find_anagram_substring(s: str, p: str) -> bool: from collections import Counter if len(p) > len(s): return False p_count = Counter(p) s_count = Counter(s[:len(p)]) if p_count == s_count: return True for i in range(len(p), len(s)): s_count[s[i]] += 1 s_count[s[i - len(p)]] -= 1 if s_count[s[i - len(p)]] == 0: del s_count[s[i - len(p)]] if s_count == p_count: return True return False"},{"question":"# Task: You are required to implement a class `WordFrequencyAnalyzer` that efficiently calculates and provides summary statistics for word frequencies from a given text. This class will include methods to find the most frequent word, least frequent word, and the frequency of a particular word, all optimized for performance. # Requirements: - Implement the necessary methods to handle word frequency calculations using appropriate data structures. - Ensure efficient lookup and update operations for maintaining frequency counts. # Detailed Function Requirements: 1. **`add_text(text: str) -> None`**: Takes a string `text`, processes it to count the frequency of each word, and updates the internal storage. * **Input**: `text` - a string containing the text to be processed. * **Output**: None. * **Constraints**: Text should be non-empty. Words are case-insensitive and punctuation should be ignored. 2. **`most_frequent() -> str`**: Returns the most frequent word in the stored text. * **Input**: None. * **Output**: A string representing the most frequent word. If there are multiple words with the same highest frequency, return any one of them. * **Constraints**: Must handle ties appropriately. 3. **`least_frequent() -> str`**: Returns the least frequent word in the stored text. * **Input**: None. * **Output**: A string representing the least frequent word. If there are multiple words with the same lowest frequency, return any one of them. * **Constraints**: Must handle ties appropriately. 4. **`frequency(word: str) -> int`**: Returns the frequency count of a particular `word`. * **Input**: `word` - a string representing the word to check its frequency. * **Output**: An integer representing the frequency of the word in the stored text. If the word doesn\'t exist, return 0. * **Constraints**: Search should be case-insensitive. # Constraints: - Consider edge cases such as text with no alphabetic characters, and ensure robustness against invalid input. - Assume valid input for word-related operations (e.g., the word to check the frequency is non-empty). # Example Usage: ```python analyzer = WordFrequencyAnalyzer() analyzer.add_text(\\"Hello world! Hello, how are you? Hello everyone!\\") print(analyzer.most_frequent()) # Output: \\"hello\\" print(analyzer.least_frequent()) # Output: \\"world\\" or another word with frequency 1 print(analyzer.frequency(\\"hello\\")) # Output: 3 print(analyzer.frequency(\\"you\\")) # Output: 1 ``` # Note: Your implementation should focus on efficiency and correctness, with special attention to handling various punctuation and case insensitively. Use appropriate data structures to facilitate fast retrieval and update of word frequencies.","solution":"import re from collections import defaultdict, Counter class WordFrequencyAnalyzer: def __init__(self): self.word_freq = defaultdict(int) def add_text(self, text: str) -> None: # Use regex to normalize the text by removing punctuation and converting to lower case words = re.findall(r\'bw+b\', text.lower()) for word in words: self.word_freq[word] += 1 def most_frequent(self) -> str: if not self.word_freq: return \\"\\" max_count = max(self.word_freq.values()) for word, freq in self.word_freq.items(): if freq == max_count: return word def least_frequent(self) -> str: if not self.word_freq: return \\"\\" min_count = min(self.word_freq.values()) for word, freq in self.word_freq.items(): if freq == min_count: return word def frequency(self, word: str) -> int: return self.word_freq[word.lower()]"},{"question":"# Context We have explored various sorting algorithms, including Merge Sort, Quick Sort, and counting-based algorithms. Let\'s delve further into sorting by addressing a real-world scenario related to event management systems. # Task Implement a Python function named `sort_events_by_date` that sorts a list of event objects based on their dates in ascending order. Assume each event is represented as a dictionary with at least a `name` and `date` key, where `date` is a string in the format \'YYYY-MM-DD\'. Your goal is to implement an efficient sorting algorithm that can handle large datasets. # Input 1. A list of events, where each event is a dictionary with the keys: - `name`: The name of the event (string). - `date`: The date of the event (string in the format \'YYYY-MM-DD\'). # Output 1. A list of events sorted by their dates in ascending order. # Constraints 1. The number of events (N) is at most (10^5). 2. Each date is a valid date in the format described. 3. No two events will have the same date. # Performance Requirements 1. Ensure your solution has a time complexity of at most O(N log N). # Function Signature ```python def sort_events_by_date(events: List[Dict[str, str]]) -> List[Dict[str, str]]: pass ``` # Example ```python events = [ {\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"}, {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-12-01\\"}, {\\"name\\": \\"Event C\\", \\"date\\": \\"2023-01-10\\"} ] sorted_events = sort_events_by_date(events) print(sorted_events) # Expected output: # [ # {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-12-01\\"}, # {\\"name\\": \\"Event C\\", \\"date\\": \\"2023-01-10\\"}, # {\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"} # ] ``` Ensure your implementation adheres to the guidelines and performance constraints provided.","solution":"from typing import List, Dict def sort_events_by_date(events: List[Dict[str, str]]) -> List[Dict[str, str]]: Sorts a list of event dictionaries by their date in ascending order. Args: events (List[Dict[str, str]]): List of events where each event is represented as a dictionary. Returns: List[Dict[str, str]]: List of events sorted by date in ascending order. return sorted(events, key=lambda event: event[\'date\'])"},{"question":"# Depth-First Search Maze Solver Objective You are required to implement a function that solves a maze represented as a 2D list using the Depth-First Search (DFS) algorithm. The goal is to find a path from the starting point to the exit, if one exists. Requirements 1. **Function Signature**: `def solve_maze(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]` 2. **Input**: * `maze`: A 2D list of integers where `0` represents a free path and `1` represents a wall. * `start`: A tuple `(x, y)` representing the starting cell coordinates (x and y are zero-based indices). * `end`: A tuple `(x, y)` representing the exit cell coordinates. * The dimensions of the maze will be between 1x1 and 50x50. * The `start` and `end` positions will always be valid cells with `0`. 3. **Output**: * A list of tuples representing the path from start to end, inclusive, where each tuple represents cell coordinates. * If no path exists, return an empty list. Constraints * Implement the DFS algorithm iteratively (using a stack) rather than recursively to avoid potential recursion limits. * Ensure that your solution correctly addresses mazes with varying complexity, including edge cases like no available path or minimal-sized mazes. * Avoiding visiting a cell more than once is essential for optimal performance. Performance Requirements * The solution should ideally run in O(V + E) time complexity, where V is the number of vertices (cells) and E is the number of edges (connections between cells). Scenario Consider you are designing a maze-solving robot. The maze is presented as an array where the robot can only traverse through cells marked `0`. Implement the DFS to help the robot find its way from the start to the exit. Ensure the robot can navigate efficiently even when obstacles are densely packed within the maze. Example ```python # Example usage: maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) print(solve_maze(maze, start, end)) # Expected Output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] maze = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) print(solve_maze(maze, start, end)) # Expected Output: [] maze = [ [0] ] start = (0, 0) end = (0, 0) print(solve_maze(maze, start, end)) # Expected Output: [(0, 0)] ```","solution":"def solve_maze(maze, start, end): Solves the given maze using DFS and returns the path from start to end. Returns an empty list if no path is found. Parameters: maze (list[list[int]]): 2D list representing the maze start (tuple[int, int]): Starting coordinates (x, y) end (tuple[int, int]): Ending coordinates (x, y) Returns: list[tuple[int, int]]: Path from start to end if exists, otherwise empty list stack = [(start, [start])] visited = set() while stack: (x, y), path = stack.pop() if (x, y) in visited: continue visited.add((x, y)) if (x, y) == end: return path # List of potential moves: down, up, right, left for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0: stack.append(((nx, ny), path + [(nx, ny)])) return []"},{"question":"# Coding Assessment Question Context: You are tasked with developing a text editor feature that finds and replaces all occurrences of a given word within a paragraph. The text editor must handle case-insensitive search and only replace whole-word matches to ensure the accuracy of the operation. Task: Write a function `find_and_replace(paragraph: str, target: str, replacement: str) -> str` that accepts a paragraph, a target word to find, and a replacement word. The function should return a new string with all occurrences of the target word replaced with the replacement word, respecting case insensitivity and whole-word boundaries. Function Signature: ```python def find_and_replace(paragraph: str, target: str, replacement: str) -> str: ``` Input: * A string `paragraph` representing the text in which to perform the search and replace. Example: `\\"The quick brown fox jumps over the lazy dog.\\"` * A string `target` representing the word to find. Example: `\\"the\\"` * A string `replacement` representing the word to replace the target with. Example: `\\"a\\"` Output: * A new string with all whole-word occurrences of the target word replaced with the replacement word, considering case insensitivity. Example: `\\"a quick brown fox jumps over a lazy dog.\\"` Constraints: * The input `paragraph` will have a length between 1 and 10^5 characters. * The `target` and `replacement` words are non-empty strings containing only alphabetic characters. * The `target` and `replacement` strings will have lengths between 1 and 100 characters. Example: ```python paragraph = \\"The quick brown fox jumps over the lazy dog.\\" target = \\"the\\" replacement = \\"a\\" assert find_and_replace(paragraph, target, replacement) == \\"a quick brown fox jumps over a lazy dog.\\" ``` Performance Requirements: * The solution should operate efficiently even for large inputs up to the maximum length specified. Summary: Implement the `find_and_replace` function to accurately perform case-insensitive and whole-word-aware search and replace operations within a paragraph of text. Ensure the function handles different cases, punctuation, and maintains the integrity of the original word boundaries.","solution":"import re def find_and_replace(paragraph: str, target: str, replacement: str) -> str: Replaces all occurrences of the target word with the replacement word in the given paragraph while respecting case insensitivity and whole-word boundaries. :param paragraph: str - the text in which to perform the search and replace :param target: str - the word to find :param replacement: str - the word to replace the target with :return: str - the new paragraph with all whole-word occurrences of the target word replaced # Create a regex pattern that matches the target word with whole word boundaries pattern = re.compile(r\'b\' + re.escape(target) + r\'b\', re.IGNORECASE) # Use re.sub to replace all occurrences of the pattern with the replacement word result = pattern.sub(replacement, paragraph) return result"},{"question":"# Generate All Subsets Implement a function that generates all possible subsets of a given set of unique integers. # Explanation: The function should take a list of unique integers and return a list of lists, where each list represents a possible subset of the given set. Subsets should include the empty set and the set itself. # Function Signature: ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ... ``` # Expected Inputs and Outputs: * **Input**: * `nums`: A list of unique integers. * **Output**: * A list of lists containing all possible subsets. # Example: ```python # Input nums = [1, 2, 3] # Output # [ # [], # [1], # [2], # [3], # [1, 2], # [1, 3], # [2, 3], # [1, 2, 3] # ] assert sorted(generate_subsets([1, 2, 3])) == sorted([[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]) ``` # Constraints: 1. The length of the list `nums` will be between 0 and 15. 2. The elements of `nums` will be unique integers between `-10^9` and `10^9`. # Testing: Your solution will be tested with the following scenarios: 1. An empty list. 2. A list with one element. 3. A list with multiple elements which includes both small and large values. # Notes: The order of the subsets in the output list does not matter. Make sure your function can handle both the smallest and largest input sizes efficiently.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of a given set of unique integers. Parameters: nums (List[int]): A list of unique integers. Returns: List[List[int]]: A list of lists containing all possible subsets. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] backtrack(0, []) return result"},{"question":"**Problem Statement**: Octagonal numbers form a sequence of numbers that can be represented as octagonally arranged dots. The nth octagonal number `oₙ` is calculated using the formula: [ oₙ = n(3n - 2) ] Given a positive integer `length`, write a Python function `octagonal_numbers(length: int) -> list[int]` that returns a list of the first `length` octagonal numbers. **Function Signature**: ```python def octagonal_numbers(length: int) -> list[int]: ``` # Input * A positive integer `length` which specifies the number of octagonal numbers to generate. # Output * A list of integers containing the first `length` octagonal numbers. # Constraints * `length` should be a positive integer (greater than zero). # Examples ```python >>> octagonal_numbers(10) [0, 1, 8, 21, 40, 65, 96, 133, 176, 225] >>> octagonal_numbers(5) [0, 1, 8, 21, 40] >>> octagonal_numbers(1) [0] ``` # Notes * Ensure the function raises a `ValueError` if the input is not a positive integer. * Optimize for performance to handle reasonably large values of `length`.","solution":"def octagonal_numbers(length: int) -> list[int]: Returns the first `length` octagonal numbers. Parameters: - length (int): The number of octagonal numbers to generate. Returns: - list[int]: The list of the first `length` octagonal numbers. if not isinstance(length, int) or length <= 0: raise ValueError(\\"The input must be a positive integer.\\") result = [] for n in range(length): octagonal_number = n * (3 * n - 2) result.append(octagonal_number) return result"},{"question":"Log Analyzer for System Events **Objective**: Implement a log analyzer function that processes a list of system events and returns a count of how many times each event type occurred. **Context**: Assume you are developing software to analyze large volumes of system event logs for a server monitoring tool. Efficiently counting the number of times each event type occurs can help in identifying patterns and potential issues. Requirements You need to write a function `analyze_logs(logs: list) -> dict` that processes a list of system event logs and returns a dictionary where the keys are event types, and the values are the counts of how many times each event type occurred. The function should: 1. **Identify and count all unique event types** in the input list. 2. **Handle large input sizes** efficiently with linear time complexity O(n). 3. **Return a dictionary** with event types as keys and their respective counts as values. Specifications * **Input**: A list called `logs` where each element is a string representing an event type. The list can have up to 10^6 elements. * **Output**: A dictionary with event type strings as keys and the corresponding counts as values. Constraints * The list can contain up to 10^6 event strings. * The event strings are not empty and can consist of alphanumeric characters and underscores. * The function should handle edge cases gracefully, such as an empty list. Performance Requirements * The analysis should be memory efficient and should not use additional memory proportional to the input size. * The implementation should ensure that the execution time is proportional to the input size. Example ```python def analyze_logs(logs: list) -> dict: event_count = {} for event in logs: if event in event_count: event_count[event] += 1 else: event_count[event] = 1 return event_count # Test cases logs1 = [\\"login\\", \\"logout\\", \\"login\\", \\"file_access\\", \\"login\\"] logs2 = [\\"error\\", \\"info\\", \\"warning\\", \\"error\\", \\"info\\", \\"info\\"] print(analyze_logs(logs1)) # Output: {\'login\': 3, \'logout\': 1, \'file_access\': 1} print(analyze_logs(logs2)) # Output: {\'error\': 2, \'info\': 3, \'warning\': 1} ``` **Note**: Test the function with various log lists to ensure accurate and efficient counting of event types, including large datasets to verify performance.","solution":"def analyze_logs(logs: list) -> dict: Analyzes a list of system event logs and returns a dictionary with the count of each event type. Args: logs (list): A list of strings where each string is an event type. Returns: dict: A dictionary with event types as keys and counts as values. event_count = {} for event in logs: if event in event_count: event_count[event] += 1 else: event_count[event] = 1 return event_count"},{"question":"# Coding Assessment Question Context: You\'ve explored various sorting algorithms in the past. Now, let\'s take a step into computational optimization by working on a fundamental data structure operation. We\'ll be dealing with arrays and require efficient data retrieval by implementing a Binary Search algorithm. Task: Implement the Binary Search algorithm. Given a sorted list of integers, your function should locate a specific target integer using Binary Search. Function Signature: ```python def binary_search(arr: List[int], target: int) -> int: pass ``` Input & Output: - **Input**: - A sorted list of integers `arr` (0 <= len(arr) <= 1000). - An integer `target` to search for within the list. - **Output**: - The index of `target` in the list `arr` if `target` exists, otherwise `-1`. Constraints: - The input list can be empty. - All integers are within the range [-10^6, 10^6]. - You should not use any in-built search functions. - You must implement the search logic using the Binary Search algorithm. Performance Requirements: - Time Complexity: O(log n). - Space Complexity: O(1) for the iterative implementation. Examples: ```python assert binary_search([1, 2, 3, 4, 5], 4) == 3 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([1, 2, 3, 4, 5], 1) == 0 assert binary_search([], 10) == -1 assert binary_search([-3, -1, 2, 3, 6], 2) == 2 ```","solution":"def binary_search(arr, target): Uses Binary Search algorithm to find the index of the target in arr. Returns -1 if the target is not found. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Determining the Height of a Binary Tree Given a binary tree, determine the height of the tree. The height of a binary tree is the number of edges between the tree\'s root and its furthest leaf, i.e., the length of the longest downward path from the root to a leaf. Function Signature ```python def tree_height(root: Node | None) -> int: ``` Input * `root`: The root node of a binary tree. Output * `height`: An integer representing the height of the tree. Constraints * The number of nodes in the tree is in the range [0, 10⁴]. * The value of each node is an integer between -10⁴ and 10⁴. Example ```python # Input Tree: # 1 # / # 2 3 # / # 4 5 root = make_tree() print(tree_height(root)) # Output: # 2 # Input Tree: # 3 # / # 9 20 # / # 15 7 new_root = Node(3) new_root.left = Node(9) new_root.right = Node(20) new_root.right.left = Node(15) new_root.right.right = Node(7) print(tree_height(new_root)) # Output: # 2 ``` Notes - The height of a tree with only one node (the root) is 0. - If the tree is empty (i.e., the input `root` is `None`), the height should be considered as -1. - Implementing this will require a good understanding of tree depth traversal, either depth-first (DFS) or breadth-first (BFS).","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def tree_height(root: Node | None) -> int: Determines the height of a binary tree. :param root: The root node of a binary tree. :return: An integer representing the height of the tree. if root is None: return -1 left_height = tree_height(root.left) right_height = tree_height(root.right) return max(left_height, right_height) + 1 # Helper function to build example trees for testing def make_tree() -> Node: root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) return root def make_another_tree() -> Node: root = Node(3) root.left = Node(9) root.right = Node(20) root.right.left = Node(15) root.right.right = Node(7) return root"},{"question":"Problem: Detect Cycles in a Directed Graph # Context In various applications like task scheduling, dependency management, and course prerequisite checking, it is crucial to identify cycles within a directed graph. A cycle in a directed graph is a path that begins and ends at the same vertex. Detecting these cycles can prevent infinite loops and ensure correct ordering. # Task Write a function `detect_cycles` that takes a directed graph represented as an adjacency list and returns a list of all cycles in the graph. Each cycle should be represented as a list of vertices `[v1, v2, ..., vn, v1]` indicating the path of the cycle starting and ending at the same vertex. # Function Signature ```python def detect_cycles(graph: dict[int, list[int]]) -> list[list[int]]: pass ``` # Input - `graph`: A dictionary where keys are integers representing vertices, and values are lists of integers representing the adjacent vertices. The graph is directed, meaning if vertex `u` has `v` in its adjacency list, it does not necessarily imply that `v` has `u` as an adjacent vertex. # Output - A list of lists, where each inner list represents a cycle in the graph. The inner lists start and end at the same vertex. # Constraints - The graph can contain up to `10^5` vertices. - The graph can contain up to `10^5` edges. - The graph may contain multiple disconnected components. # Example ```python graph1 = { 0: [1], 1: [2], 2: [0], 3: [4, 5], 4: [3, 6], 5: [6], 6: [5], } graph2 = { 0: [1], 1: [2], 2: [3], 3: [4], 4: [], } graph3 = { 0: [1, 2], 1: [2], 2: [0], 3: [4], 4: [5], 5: [3], } assert detect_cycles(graph1) == [[0, 1, 2, 0], [3, 4, 3], [5, 6, 5]] assert detect_cycles(graph2) == [] assert detect_cycles(graph3) == [[0, 1, 2, 0], [3, 4, 5, 3]] ``` # Notes - Ensure to correctly identify each unique cycle without repeating the same cycle in different permutations. - Handle edge cases such as empty graphs or graphs with no cycles. - Consider optimizing for large inputs to ensure performance is within acceptable constraints.","solution":"def detect_cycles(graph): def dfs(v, stack): stack_index[v] = len(stack) stack.append(v) visited[v] = True for neighbor in graph.get(v, []): if not visited.get(neighbor, False): dfs(neighbor, stack) elif stack_index.get(neighbor, None) is not None: cycle_start_index = stack_index[neighbor] cycles.append(stack[cycle_start_index:] + [neighbor]) stack.pop() stack_index[v] = None visited = {} stack_index = {} cycles = [] for vertex in graph: if not visited.get(vertex, False): dfs(vertex, []) unique_cycles = [] for cycle in cycles: if cycle[::-1] not in unique_cycles: unique_cycles.append(cycle) return unique_cycles"},{"question":"# Scenario You are tasked with developing an efficient algorithm to find the k-th smallest element in a large list of integers. This problem is often encountered in practice when dealing with large datasets where a full sort is computationally expensive. # Task Implement a function to find and return the k-th smallest element in a list of integers using an efficient selection algorithm. # Function Signature ```python def kth_smallest_element(arr: List[int], k: int) -> int: ``` # Input - `arr`: A list of integers `arr` where the length of `arr` is between `1` and `10^5`. - `k`: An integer `k` (1 ≤ k ≤ len(arr)), representing the position (1-based) of the smallest element in the `arr`. # Output - The function should return an integer, the k-th smallest element in the list `arr`. # Constraints - The elements of `arr` can be both negative and positive integers. - The elements of `arr` are not guaranteed to be unique. # Example ```python arr = [12, 3, 5, 7, 19, 8] k = 4 print(kth_smallest_element(arr, k)) ``` Expected Output ``` 8 ``` # Notes - Ensure that your implementation efficiently handles the potential size of the input list. - Avoid using full sort algorithms (e.g., `sort()` method) to ensure scalability for large datasets. - Focus on using algorithms with average-case linear time complexity, such as the Quickselect algorithm. Ensure your function is robust and efficient, appropriate for large-scale data processing as described.","solution":"import random from typing import List def kth_smallest_element(arr: List[int], k: int) -> int: Returns the k-th smallest element in the list using the Quickselect algorithm. def partition(low, high): pivot_index = random.randint(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quickselect(low, high, k): if low == high: return arr[low] partition_index = partition(low, high) if k == partition_index: return arr[k] elif k < partition_index: return quickselect(low, partition_index - 1, k) else: return quickselect(partition_index + 1, high, k) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"**Context**: An online discussion forum needs to manage its threads efficiently. Each thread contains multiple posts, and users often need to highlight specific keywords within these posts. The forum aims to implement a function that takes a list of posts and a keyword, and returns all posts that contain the keyword, highlighting the keyword within each post using double asterisks (**keyword**). **Task**: Implement the function `highlight_keyword(posts: List[str], keyword: str) -> List[str]` that searches a list of posts for a given keyword and highlights the keyword in each post by surrounding it with double asterisks. The function should be case-insensitive, but the replacement should preserve the original case of the keyword in the post. **Function Signature**: ```python from typing import List def highlight_keyword(posts: List[str], keyword: str) -> List[str]: pass ``` **Input**: * `posts` (List[str]): A list of strings representing posts in the forum. * `keyword` (str): A string representing the keyword to be highlighted. **Output**: * (List[str]): A list of strings where each post containing the keyword has the keyword highlighted. **Constraints**: * The total number of posts does not exceed 10^5. * The length of each post does not exceed 10^6 characters. * The length of the keyword does not exceed 100 characters. **Requirements**: * Achieve linear time complexity O(n*m), where n is the number of posts and m is the average length of each post. * The keyword matching should be case-insensitive. **Examples**: ```python assert highlight_keyword( [\\"This is the first post.\\", \\"Another interesting post.\\", \\"Keyword here.\\", \\"No relevance.\\"], \\"post\\") == [\\"This is the first **post**.\\", \\"Another interesting **post**.\\", \\"Keyword here.\\", \\"No relevance.\\"] assert highlight_keyword( [\\"Python is amazing.\\", \\"I love programming in Python.\\", \\"pyThOn for data science.\\"], \\"python\\") == [\\"**Python** is amazing.\\", \\"I love programming in **Python**.\\", \\"**pyThOn** for data science.\\"] assert highlight_keyword( [\\"This is fun.\\", \\"No keyword here.\\", \\"Totally irrelevant.\\"], \\"boring\\") == [\\"This is fun.\\", \\"No keyword here.\\", \\"Totally irrelevant.\\"] ```","solution":"from typing import List import re def highlight_keyword(posts: List[str], keyword: str) -> List[str]: Searches a list of posts for a given keyword and highlights the keyword in each post by surrounding it with double asterisks. The search is case-insensitive. :param posts: List of strings representing posts in the forum. :param keyword: String representing the keyword to be highlighted. :return: A list of strings where each post containing the keyword has the keyword highlighted. keyword_pattern = re.compile(re.escape(keyword), re.IGNORECASE) highlighted_posts = [] for post in posts: highlighted_post = keyword_pattern.sub(lambda match: f\\"**{match.group()}**\\", post) highlighted_posts.append(highlighted_post) return highlighted_posts"},{"question":"# Sorting Team Scores You have been contacted by a sports event organizer who needs a program to sort and rank team scores. The input we\'ll receive is a dictionary where the keys are team names, and the values are lists of integers representing their scores in different matches. You are required to write a function that sorts these teams based on their average scores in descending order. If two teams have the same average score, their order should be determined alphabetically by their names in ascending order. # Function Specification Implement the following function in Python: ```python def sort_teams_by_scores(team_scores: dict) -> list: Sort teams based on their average scores. Parameters: - team_scores (dict): A dictionary where keys are team names (str) and values are lists of match scores (list of integers). Returns: - list: A sorted list of tuples, each containing the team name (str) and their average score (float), in the specified order. Example Usage: >>> sort_teams_by_scores({\\"TeamA\\": [10, 20, 30], \\"TeamB\\": [20, 30], \\"TeamC\\": [30, 40, 10]}) [(\'TeamC\', 26.67), (\'TeamA\', 20.0), (\'TeamB\', 25.0)] >>> sort_teams_by_scores({\\"TeamAlpha\\": [75, 85, 95], \\"TeamBeta\\": [60, 70, 80], \\"TeamGamma\\": [80, 60, 70]}) [(\'TeamAlpha\', 85.0), (\'TeamGamma\', 70.0), (\'TeamBeta\', 70.0)] ``` # Input and Output - **Input**: - `team_scores` (dict): Dictionary with team names as keys and lists of scores as values. - **Output**: A list of tuples, where each tuple contains a team name and its average score, sorted by average score in descending order and by team name in ascending order in case of a tie. # Constraints - The team names will only contain alphabetic characters. - Each team will have at least one score. # Example: ```python >>> sort_teams_by_scores({\\"TeamA\\": [10, 20, 30], \\"TeamB\\": [20, 30], \\"TeamC\\": [30, 40, 10]}) [(\'TeamC\', 26.67), (\'TeamA\', 20.0), (\'TeamB\', 25.0)] >>> sort_teams_by_scores({\\"TeamAlpha\\": [75, 85, 95], \\"TeamBeta\\": [60, 70, 80], \\"TeamGamma\\": [80, 60, 70]}) [(\'TeamAlpha\', 85.0), (\'TeamGamma\', 70.0), (\'TeamBeta\', 70.0)] ``` # Implementation To implement this, you need to: 1. Calculate the average score for each team. 2. Sort the teams based on their average scores in descending order. 3. In case of a tie, sort those teams alphabetically by their names. Here\'s the code implementation for the function: ```python def sort_teams_by_scores(team_scores: dict) -> list: # Calculate average scores averages = [(team, sum(scores)/len(scores)) for team, scores in team_scores.items()] # Sort by average score (desc) then by team name (asc) sorted_teams = sorted(averages, key=lambda x: (-x[1], x[0])) # Round scores to 2 decimal places sorted_teams = [(team, round(avg, 2)) for team, avg in sorted_teams] return sorted_teams # Example usage print(sort_teams_by_scores({\\"TeamA\\": [10, 20, 30], \\"TeamB\\": [20, 30], \\"TeamC\\": [30, 40, 10]})) print(sort_teams_by_scores({\\"TeamAlpha\\": [75, 85, 95], \\"TeamBeta\\": [60, 70, 80], \\"TeamGamma\\": [80, 60, 70]})) ``` Ensure that the provided test cases give the expected results, reflecting correct sorting by average scores and alphabetically as a secondary criterion.","solution":"def sort_teams_by_scores(team_scores: dict) -> list: Sort teams based on their average scores. Parameters: - team_scores (dict): A dictionary where keys are team names (str) and values are lists of match scores (list of integers). Returns: - list: A sorted list of tuples, each containing the team name (str) and their average score (float), in the specified order. # Calculate average scores averages = [(team, sum(scores) / len(scores)) for team, scores in team_scores.items()] # Sort by average score (desc) then by team name (asc) sorted_teams = sorted(averages, key=lambda x: (-x[1], x[0])) # Round scores to 2 decimal places sorted_teams = [(team, round(avg, 2)) for team, avg in sorted_teams] return sorted_teams"},{"question":"# Context Dijkstra\'s algorithm is a common solution for finding the shortest paths between nodes in a graph. The algorithm ensures the shortest path calculation from a starting node to all other nodes in the graph with non-negative edge weights. # Task Implement a `Graph` class to solve the shortest path problem using Dijkstra\'s algorithm. # Your Task Function Implementations **Class**: `Graph` 1. **__init__(self, vertices: int)** - **Input**: Number of vertices `vertices` in the graph. - **Functionality**: Initializes the graph with the given number of vertices. - **Time Complexity**: O(V) where `V` is the number of vertices. 2. **add_edge(self, u: int, v: int, weight: int)** - **Input**: An edge between node `u` and node `v` with a given `weight`. - **Functionality**: Adds an undirected edge with the given weight between the nodes `u` and `v` to the graph. - **Time Complexity**: O(1). 3. **shortest_path(self, start: int) -> list[int]** - **Input**: A starting node `start`. - **Output**: Returns a list of shortest distances from the starting node `start` to all other nodes. If a node is unreachable, the distance should be `float(\'inf\')`. - **Time Complexity**: O((V + E) log V) where `V` is the number of vertices and `E` is the number of edges. Constraints - The number of vertices `V` will be between `1` and `1000`. - The number of edges `E` will be between `0` and `10000`. - The weights will be non-negative integers and will not exceed `10^4`. # Example ```python # Assuming the implementation is completed. graph = Graph(5) graph.add_edge(0, 1, 2) graph.add_edge(0, 2, 4) graph.add_edge(1, 2, 1) graph.add_edge(2, 3, 7) graph.add_edge(3, 4, 3) graph.add_edge(1, 4, 8) # Find the shortest path from vertex 0 print(graph.shortest_path(0)) # Output: [0, 2, 3, 10, 10 # Find the shortest path from vertex 2 print(graph.shortest_path(2)) # Output: [3, 1, 0, 7, 10] ```","solution":"import heapq class Graph: def __init__(self, vertices: int): self.V = vertices self.adj = {i: [] for i in range(vertices)} def add_edge(self, u: int, v: int, weight: int): self.adj[u].append((v, weight)) self.adj[v].append((u, weight)) def shortest_path(self, start: int) -> list[int]: distances = [float(\'inf\')] * self.V distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adj[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Task: Implement a Recursive Solution for Generating Pascal\'s Triangle Objective Implement a recursive algorithm to generate Pascal\'s Triangle up to a given number of rows. Pascal\'s Triangle is a triangular array of numbers where each entry is the sum of the two entries directly above. Requirements 1. **Function Definition**: Define a function `generate_pascals_triangle` with the following parameters: * `num_rows: int`: The number of rows of Pascal\'s Triangle to generate. The function should return a list of lists, where each inner list corresponds to a row of Pascal\'s Triangle. 2. **Input Format**: * `num_rows`: An integer representing the number of rows in Pascal\'s Triangle. 3. **Output Format**: * A list of lists, where each inner list represents a row of Pascal\'s Triangle. 4. **Constraints**: * 0 <= num_rows <= 30 Example: ```python # Example Usage: >>> generate_pascals_triangle(5) [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] ``` Performance Requirements The recursive function should compute the entries in Pascal\'s Triangle effectively without excessive use of memory or computation. Scenario You are working on a mathematical program that includes generating Pascal\'s Triangle as a feature for observing number patterns. The recursive approach is chosen to emphasize the mathematical definition of the triangle. Implement the recursive function and test it to ensure it produces correct results for the given constraints.","solution":"def generate_pascals_triangle(num_rows): Generates Pascal\'s Triangle up to a given number of rows. Args: num_rows (int): The number of rows in the triangle. Returns: list of lists: Pascal\'s Triangle represented as a list of lists. if num_rows == 0: return [] elif num_rows == 1: return [[1]] def generate_row(previous_row): row = [1] for i in range(1, len(previous_row)): row.append(previous_row[i-1] + previous_row[i]) row.append(1) return row triangle = generate_pascals_triangle(num_rows - 1) triangle.append(generate_row(triangle[-1])) return triangle"},{"question":"# Implement a Custom HashMap Class in Python You are required to implement a custom `HashMap` class in Python without using any external libraries or built-in hash data structures. The `HashMap` class should support basic operations such as insertion, deletion, and lookup, and should handle hash collisions using separate chaining (linked list). Requirements: 1. Define the `HashMap` class with the following methods: - `put(key, value)`: Insert a key-value pair into the hash map. - `get(key)`: Retrieve the value associated with the given key. If the key does not exist, return `None`. - `remove(key)`: Delete the key-value pair from the hash map. If the key does not exist, do nothing. 2. Use separate chaining to handle hash collisions. 3. Provide appropriate documentation and tests for your implementation. Constraints: * You can assume that the keys are all strings and values are integers. * The initial size of the hash table is fixed at 10 buckets, but it should dynamically resize (double the number of buckets) when the load factor exceeds 0.7. * Implement a simple hash function based on the sum of the ASCII values of the characters in the key. Input Format: * There are no specific inputs, but your class should be able to handle various operations as mentioned. Output Format: * Methods should either return the requested values or modify the internal state of the `HashMap`. Example Usage: ```python # Create a new HashMap hash_map = HashMap() # Put key-value pairs hash_map.put(\\"apple\\", 3) hash_map.put(\\"banana\\", 6) # Retrieve values print(hash_map.get(\\"apple\\")) # Output: 3 print(hash_map.get(\\"banana\\")) # Output: 6 print(hash_map.get(\\"cherry\\")) # Output: None # Remove a key hash_map.remove(\\"apple\\") print(hash_map.get(\\"apple\\")) # Output: None # Ensuring separate chaining with collisions hash_map.put(\\"pop\\", 10) # Same hash bucket with \\"banana\\" hash_map.put(\\"zzz\\", 20) # Different key, but might share same bucket in a different implementation print(hash_map.get(\\"pop\\")) # Output: 10 print(hash_map.get(\\"banana\\")) # Output: 6 print(hash_map.get(\\"zzz\\")) # Output: 20 ``` Implement the `HashMap` class according to the above requirements.","solution":"class HashMap: def __init__(self): self.size = 10 self.buckets = [[] for _ in range(self.size)] self.item_count = 0 def hash_function(self, key): return sum(ord(char) for char in key) % self.size def put(self, key, value): index = self.hash_function(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.item_count += 1 if self.load_factor() > 0.7: self.resize() def get(self, key): index = self.hash_function(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def remove(self, key): index = self.hash_function(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.item_count -= 1 return def load_factor(self): return self.item_count / self.size def resize(self): new_size = self.size * 2 new_buckets = [[] for _ in range(new_size)] for bucket in self.buckets: for key, value in bucket: new_index = sum(ord(char) for char in key) % new_size new_buckets[new_index].append((key, value)) self.size = new_size self.buckets = new_buckets"},{"question":"# Scenario You are working for a tech company developing an internal tool for processing and analyzing sales data. One of the tasks involves calculating the top N products based on their sales in the current quarter. Your goal is to build a system that can read sales data from a CSV file, process it, and return the top N products sorted by sales in descending order. # Task Implement a function that reads sales data from a CSV file, processes the data to calculate the total sales for each product, and returns the top N products sorted by total sales in descending order. The CSV file contains two columns: \'product\' and \'sales\', where each row represents a sale of a product. # Function Signature ```python def top_n_products(filename: str, n: int) -> List[Tuple[str, float]]: # Your implementation here ``` # Explanation 1. **Filename**: The name of the CSV file containing the sales data. 2. **N**: The number of top products to return. 3. **Return**: A list of tuples, where each tuple contains the product name and the total sales amount, sorted in descending order of sales. # Example ```python # CSV file content (sales_data.csv): # product,sales # product1,100.0 # product2,200.0 # product1,150.0 # product3,300.0 # Function call print(top_n_products(\\"sales_data.csv\\", 2)) # Output: [(\'product3\', 300.0), (\'product1\', 250.0)] ``` # Constraints 1. The file may contain thousands of sales records, so the implementation should be efficient. 2. Handle edge cases, such as: - If the file does not exist, raise a FileNotFoundError. - If the N value exceeds the number of unique products, return as many products as available. - If the file has an incorrect format or is empty, handle errors gracefully. # Notes - Consider using Python\'s built-in CSV library to read and process the data. - Use appropriate data structures (e.g., dictionaries, heaps) to manage and sort the sales data efficiently. - Ensure that your implementation gracefully handles potential errors and exceptions. # Example Code Skeleton ```python def top_n_products(filename: str, n: int) -> List[Tuple[str, float]]: import csv from collections import defaultdict import heapq sales_data = defaultdict(float) try: with open(filename, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: product = row[\'product\'] sales = float(row[\'sales\']) sales_data[product] += sales top_n = heapq.nlargest(n, sales_data.items(), key=lambda item: item[1]) return top_n except FileNotFoundError: raise FileNotFoundError(f\\"The file {filename} does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return [] # Example usage: # print(top_n_products(\\"sales_data.csv\\", 2)) ```","solution":"from typing import List, Tuple import csv from collections import defaultdict import heapq def top_n_products(filename: str, n: int) -> List[Tuple[str, float]]: Reads sales data from a CSV file, processes the data to calculate the total sales for each product, and returns the top N products sorted by total sales in descending order. sales_data = defaultdict(float) try: with open(filename, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: product = row[\'product\'] sales = float(row[\'sales\']) sales_data[product] += sales return heapq.nlargest(n, sales_data.items(), key=lambda item: item[1]) except FileNotFoundError: raise FileNotFoundError(f\\"The file {filename} does not exist.\\") except Exception as e: raise Exception(f\\"An error occurred: {e}\\")"},{"question":"# Coding Question: Generate All Possible Subsets Context: As a software engineer, you are building a feature in a product recommendation system where a set of items needs to be evaluated in all possible combinations. The feature should generate all possible subsets (the power set) of a given set of distinct items. Objective: - Write a function `generate_all_subsets(item_list: list) -> list` that: - Accepts a list of distinct items. - Returns a list of lists, where each sublist is a subset of the original list, including the empty subset and the original list itself. Input and Output: - **Input**: A list `item_list` containing distinct items (e.g., `[1, 2, 3]`). - **Output**: A list of lists, where each sublist represents a subset of `item_list`. Constraints and Limitations: - The input list can have a maximum length of 10 items. - Each subset should maintain the order of items as in the original list. - The function should produce exactly (2^n) subsets for an input list of length (n). Examples: ```python >>> generate_all_subsets([1, 2, 3]) [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] >>> generate_all_subsets([\'a\', \'b\']) [[], [\'a\'], [\'b\'], [\'a\', \'b\']] >>> generate_all_subsets([]) [[]] >>> generate_all_subsets([5]) [[], [5]] ``` Function Signature: ```python def generate_all_subsets(item_list: list) -> list: pass ``` Implement the function `generate_all_subsets` to solve the problem.","solution":"def generate_all_subsets(item_list): Generates all possible subsets of the given list of distinct items. Args: item_list (list): A list of distinct items. Returns: list: A list of lists, where each sublist is a subset of the original list. from itertools import combinations n = len(item_list) all_subsets = [] for i in range(n + 1): for combo in combinations(item_list, i): all_subsets.append(list(combo)) return all_subsets"},{"question":"# Circular Buffer Implementation Task Objective: Your task is to implement a `CircularBuffer` class to manage a fixed-size buffer in a circular manner, providing efficient insertion and deletion of elements. Requirements: 1. Implement a class `CircularBuffer` which enforces a fixed-size buffer. 2. The buffer should support constant-time insertion and deletion at both the front and back. 3. Implement methods to check if the buffer is empty or full, as well as methods to add to the front, add to the back, remove from the front, and remove from the back. Class Definition: ```python class CircularBuffer: def __init__(self, size: int) -> None: self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size def add_front(self, item: Any) -> None: if self.is_full(): raise OverflowError(\\"Adding to a full buffer\\") self.start = (self.start - 1) % self.size self.buffer[self.start] = item self.count += 1 def add_back(self, item: Any) -> None: if self.is_full(): raise OverflowError(\\"Adding to a full buffer\\") self.buffer[self.end] = item self.end = (self.end + 1) % self.size self.count += 1 def remove_front(self) -> Any: if self.is_empty(): raise IndexError(\\"Removing from an empty buffer\\") item = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.size self.count -= 1 return item def remove_back(self) -> Any: if self.is_empty(): raise IndexError(\\"Removing from an empty buffer\\") self.end = (self.end - 1) % self.size item = self.buffer[self.end] self.buffer[self.end] = None self.count -= 1 return item ``` Testing: - Create multiple test cases to validate behavior: 1. Adding and removing elements from both front and back. 2. Checking buffer status with `is_full` and `is_empty` during operations. 3. Edge cases like adding to a full buffer, removing from an empty buffer, and wrap-around scenarios. Example: ```python buffer = CircularBuffer(3) print(buffer.is_empty()) # True buffer.add_back(1) buffer.add_back(2) buffer.add_front(3) print(buffer.is_full()) # True print(buffer.remove_back()) # 2 buffer.add_back(4) print(buffer.remove_front()) # 3 buffer.add_front(5) print(buffer.remove_back()) # 4 ``` **Output**: ```shell True True 2 3 4 ``` Ensure to handle edge cases, and maintain the circular nature of the buffer correctly.","solution":"class CircularBuffer: def __init__(self, size: int) -> None: self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size def add_front(self, item) -> None: if self.is_full(): raise OverflowError(\\"Adding to a full buffer\\") self.start = (self.start - 1) % self.size self.buffer[self.start] = item self.count += 1 def add_back(self, item) -> None: if self.is_full(): raise OverflowError(\\"Adding to a full buffer\\") self.buffer[self.end] = item self.end = (self.end + 1) % self.size self.count += 1 def remove_front(self) -> any: if self.is_empty(): raise IndexError(\\"Removing from an empty buffer\\") item = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.size self.count -= 1 return item def remove_back(self) -> any: if self.is_empty(): raise IndexError(\\"Removing from an empty buffer\\") self.end = (self.end - 1) % self.size item = self.buffer[self.end] self.buffer[self.end] = None self.count -= 1 return item"},{"question":"# Problem Statement You are given a class `CircularDeque` that implements a circular deque (double-ended queue) using a fixed-size array. Your task is to extend this class by implementing additional methods to provide further functionalities, which include the ability to rotate the deque and reversing the elements. 1. Implement the method `rotate(self, k: int) -> None` 2. Implement the method `reverse(self) -> None` 1. The method `rotate` shifts each element of the deque to the right by `k` positions. Elements that fall off the end are wrapped around to the beginning of the deque. **Input**: - `k` (int): The number of positions to rotate the deque. **Output**: - None: The deque is modified in place. 2. The method `reverse` reverses the order of elements in the deque. **Input**: - None (other than `self`). **Output**: - None: The deque is modified in place. # Constraints * The maximum number of elements (capacity) in the deque is 10^5. * You may assume the `deque` is implemented using a list with a fixed capacity. * All elements in the deque are integers. * The input `k` for `rotate` can be any non-negative integer. # Example ```python # Example usage of the CircularDeque class: cd = CircularDeque(capacity=5) cd.insertLast(1) cd.insertLast(2) cd.insertLast(3) cd.insertLast(4) cd.insertLast(5) # Method: rotate(k) cd.rotate(2) print(cd.getDeque()) # Output should be [4, 5, 1, 2, 3] # Method: reverse() cd.reverse() print(cd.getDeque()) # Output should be [3, 2, 1, 5, 4] ``` You need to add the above methods in the given `CircularDeque` class and ensure all the provided examples work correctly. # Note * The class `CircularDeque` should handle both `rotate` and `reverse` functionalities efficiently to operate within the input constraints.","solution":"class CircularDeque: def __init__(self, capacity: int): self.capacity = capacity self.array = [None] * capacity self.size = 0 self.front = 0 self.rear = -1 def insertLast(self, value: int) -> bool: if self.size == self.capacity: return False self.rear = (self.rear + 1) % self.capacity self.array[self.rear] = value self.size += 1 return True def getDeque(self): result = [] for i in range(self.size): index = (self.front + i) % self.capacity result.append(self.array[index]) return result def rotate(self, k: int) -> None: if self.size <= 1: return # No need to rotate if the deque has 0 or 1 elements k = k % self.size self.front = (self.front - k + self.size) % self.size self.rear = (self.front + self.size - 1) % self.capacity def reverse(self) -> None: if self.size <= 1: return # No need to reverse if the deque has 0 or 1 elements start = self.front end = (self.front + self.size - 1) % self.capacity for _ in range(self.size // 2): self.array[start], self.array[end] = self.array[end], self.array[start] start = (start + 1) % self.capacity end = (end - 1 + self.capacity) % self.capacity"},{"question":"# Problem Statement You need to implement a function that generates a zigzag pattern in a 2D matrix. Given the dimensions `n` (number of rows) and `m` (number of columns) of the matrix, the function should return a 2D list where the numbers increment sequentially in a zigzag pattern. The numbers should start from 1 and increment to `n * m`. # Function Signature ```python def generate_zigzag_pattern(n: int, m: int) -> list: Generate a zigzag pattern in a 2D matrix. :param n: The number of rows in the matrix. :param m: The number of columns in the matrix. :return: A 2D list representing the matrix filled with a zigzag pattern. ``` # Input Format * `n` (int): The number of rows in the matrix. * `m` (int): The number of columns in the matrix. # Output Format * A 2D list of dimensions `n` by `m` filled with integers in a zigzag pattern. # Constraints * The dimensions `n` and `m` will be positive integers (n > 0, m > 0). # Example ```python generate_zigzag_pattern(3, 4) # Expected output: # [ # [1, 2, 3, 4], # [8, 7, 6, 5], # [9, 10, 11, 12] # ] generate_zigzag_pattern(2, 5) # Expected output: # [ # [1, 2, 3, 4, 5], # [10, 9, 8, 7, 6] # ] ``` # Additional Notes * The numbers fill the matrix starting from 1 and increment sequentially. * The direction alternates between left-to-right and right-to-left for each row.","solution":"def generate_zigzag_pattern(n: int, m: int) -> list: matrix = [] num = 1 for i in range(n): row = [] for j in range(m): row.append(num) num += 1 if i % 2 == 1: row.reverse() matrix.append(row) return matrix"},{"question":"# Coding Assessment Question You are a software engineer tasked with developing a feature for a text processing application. One requirement is to implement a custom compression algorithm that takes a string and compresses it by replacing repeated sequences with the sequence followed by the count of repetitions. If a sequence is not repeated, it should appear in the result unchanged. The algorithm should work as follows: - Consecutive characters that are the same should be compressed into the character followed by the number of repetitions. - Characters that do not repeat consecutively should remain as they are. Task Write a Python function `compress_string` that compresses a given input string based on the aforementioned rules. Example ```python def compress_string(s): # Implement compression function here pass # Example usage: input_string = \\"aaabbccca\\" output_string = compress_string(input_string) print(output_string) # Expected: \\"a3b2c3a1\\" ``` Constraints - The input string will only contain lowercase alphabetic characters (\'a\'-\'z\'). - The input string length will be between 1 and 10^6 characters. Performance Requirement - The function should run in linear time relative to the size of the input string.","solution":"def compress_string(s): Compresses a given string by replacing repeated sequences with the sequence followed by the count of repetitions. if not s: # Edge case for empty string return \\"\\" compressed = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: count += 1 i += 1 compressed.append(s[i]) compressed.append(str(count)) i += 1 return \'\'.join(compressed)"},{"question":"# Problem Statement You are tasked with optimizing the performance of the quicksort algorithm. The goal is to enhance its efficiency for handling large datasets by employing techniques to improve its worst-case performance. Specifically, you should implement a median-of-three partitioning scheme and choose appropriate recursion on the smaller subarray to optimize the algorithm. # Task Modify the given `quick_sort` function to implement a median-of-three partitioning and optimize the recursion to improve the overall performance on large input sizes. # Function Signature ```python def optimized_quick_sort(collection: list) -> list: Your optimized quick sort implementation ``` # Input and Output * **Input**: A list of comparable elements, not necessarily sorted (e.g., `collection = [3, 1, 4, 1, 5, 9]`). * **Output**: A list of elements sorted in ascending order. * Must ensure that the sort is stable and elements can be compared. # Constraints * The input list can contain up to 100,000 elements. * Elements are comparable (integers or floats). # Example ```python >>> optimized_quick_sort([3, 1, 4, 1, 5, 9]) [1, 1, 3, 4, 5, 9] >>> optimized_quick_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> optimized_quick_sort([-2, -5, -45]) [-45, -5, -2] ``` # Additional Notes * Ensure the average time complexity remains O(n log n) while addressing the worst-case scenarios. * Provide appropriate comments and document any modifications you introduce to explain the optimization process. * Aim to maintain low space complexity, using in-place sorting techniques where possible.","solution":"def optimized_quick_sort(collection: list) -> list: Perform an optimized quick sort on the given collection using the median-of-three partitioning scheme and recursion on the smaller subarray first to improve worst-case performance. def median_of_three(lo, hi): mid = (lo + hi) // 2 if collection[lo] > collection[mid]: collection[lo], collection[mid] = collection[mid], collection[lo] if collection[lo] > collection[hi]: collection[lo], collection[hi] = collection[hi], collection[lo] if collection[mid] > collection[hi]: collection[mid], collection[hi] = collection[hi], collection[mid] collection[mid], collection[hi-1] = collection[hi-1], collection[mid] return collection[hi-1] def quick_sort(lo, hi): if hi - lo <= 10: insertion_sort(lo, hi) return pivot = median_of_three(lo, hi) left = lo + 1 right = hi - 2 while True: while collection[left] < pivot: left += 1 while collection[right] > pivot: right -= 1 if left < right: collection[left], collection[right] = collection[right], collection[left] left += 1 right -= 1 else: break collection[left], collection[hi-1] = collection[hi-1], collection[left] if left - lo < hi - left: quick_sort(lo, left - 1) quick_sort(left + 1, hi) else: quick_sort(left + 1, hi) quick_sort(lo, left - 1) def insertion_sort(lo, hi): for i in range(lo + 1, hi + 1): key = collection[i] j = i - 1 while j >= lo and collection[j] > key: collection[j + 1] = collection[j] j -= 1 collection[j + 1] = key quick_sort(0, len(collection) - 1) return collection"},{"question":"# Problem Statement You are required to implement a function that determines whether a given integer can be represented as the sum of two elements from a given list of integers. The function should return a boolean indicating if such a pair exists. # Function Signature ```python def has_two_sum(nums: list[int], target: int) -> bool: ``` # Input - `nums` (List of int): A list of integers, 0 ≤ len(nums) ≤ 10^5, -10^9 ≤ nums[i] ≤ 10^9. - `target` (int): An integer, -10^9 ≤ target ≤ 10^9. # Output - `bool`: True if there are two distinct elements in `nums` whose sum equals `target`, else False. # Constraints - The function should ideally run in O(N) time complexity. - The function should handle edge cases like an empty list, single element lists, or lists with all identical elements. # Example ```python >>> has_two_sum([2, 7, 11, 15], 9) True >>> has_two_sum([3, 2, 4], 6) True >>> has_two_sum([3, 3], 6) True >>> has_two_sum([3, 2, 4], 8) False >>> has_two_sum([], 0) False >>> has_two_sum([1], 2) False ``` # Guidelines 1. Create a set to keep track of the numbers you have seen so far as you iterate through the list. 2. For each number, check if `(target - current_number)` exists in the set. If it does, return True. 3. If the iteration completes without finding such a pair, return False. 4. Optimize for both time and space complexity. # Performance Requirements The function should efficiently handle lists with lengths up to 100,000 items. Ensure that the implementation can process such lists within reasonable time constraints by focusing on optimizing both time and space complexity.","solution":"def has_two_sum(nums: list[int], target: int) -> bool: seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"# Programming Question **Scenario** You are enhancing a library that performs various string manipulations for data cleaning and preprocessing tasks. One of the features requested is the ability to identify and correct common misspellings within a given string based on a predefined dictionary of correct spellings. **Problem Statement** Implement a function `correct_misspellings` that takes in a string and a dictionary of common misspellings mapped to their correct forms. The function should return a new string where all occurrences of misspellings are replaced with their correct versions. **Function Signature** ```python def correct_misspellings(text: str, misspellings: dict) -> str: pass ``` **Input** - `text` (str): A string that may contain misspellings. - `misspellings` (dict): A dictionary where keys are common misspellings and values are the correct forms. **Output** - (str): The input text with all misspellings corrected. **Constraints** - The function should handle case-insensitivity, i.e., \\"Teh\\" should be corrected to \\"The\\" if \\"teh\\" is in the dictionary. - Only exact matches within the text should be replaced (partial matches within words should not be touched). - Preserve the original case of the text as much as possible. **Examples** ```python # Example 1 # Correct common misspellings text = \\"Teh quik brown fox jumps ovr teh lazy dog.\\" misspellings = {\\"teh\\": \\"the\\", \\"quik\\": \\"quick\\", \\"ovr\\": \\"over\\"} print(correct_misspellings(text, misspellings)) # Output: \\"The quick brown fox jumps over the lazy dog.\\" # Example 2 # Handle multiple occurrences of the same misspelling text = \\"Recieve the parcel and acknowledge by signing recieve.\\" misspellings = {\\"recieve\\": \\"receive\\"} print(correct_misspellings(text, misspellings)) # Output: \\"Receive the parcel and acknowledge by signing receive.\\" # Example 3 # Preserve original case while correcting text = \\"i cant beleive that teh cat jumped ovr the fence.\\" misspellings = {\\"cant\\": \\"can\'t\\", \\"beleive\\": \\"believe\\", \\"teh\\": \\"the\\", \\"ovr\\": \\"over\\"} print(correct_misspellings(text, misspellings)) # Output: \\"i can\'t believe that the cat jumped over the fence.\\" # Example 4 # Correct misspellings that appear in different cases text = \\"Teh game was enjoyable, and teh final score was surprising.\\" misspellings = {\\"teh\\": \\"the\\"} print(correct_misspellings(text, misspellings)) # Output: \\"The game was enjoyable, and the final score was surprising.\\" ``` **Notes** - To handle case-insensitivity, consider normalizing the case of the text and the misspelled words while performing the replacement, then restoring the original or expected case afterward. - Regular expressions might be helpful for finding and replacing whole words only.","solution":"import re def correct_misspellings(text: str, misspellings: dict) -> str: def replace_match(match): word = match.group(0) lower_word = word.lower() if lower_word in misspellings: corrected_word = misspellings[lower_word] if word.isupper(): return corrected_word.upper() elif word[0].isupper(): return corrected_word.capitalize() else: return corrected_word return word # Create a regex pattern to find all words in the text pattern = re.compile(r\'bw+b\') # Use re.sub with a custom replace function corrected_text = pattern.sub(replace_match, text) return corrected_text"},{"question":"# Problem Statement You are tasked with creating a function that generates a text-based histogram from an input list of integers. Each integer represents the frequency of occurrence of an event, and the histogram should visually represent these frequencies using asterisks (`*`). Requirements: 1. **Function Name:** `generate_histogram` 2. **Input:** - `frequencies`: A list of non-negative integers. 3. **Output:** - A list of strings, where each string represents a row in the histogram. Each row should start with the index of the frequency (starting from 0), followed by a colon and a space, then a series of asterisks corresponding to the frequency. Each asterisk represents a single count. 4. **Constraints:** - Each string in the output list must be in the format: `<index>: <asterisks>`. - The function should handle an empty list by returning an empty list. - All frequencies will be non-negative integers. - The function should be efficient with a complexity of O(n), where n is the length of the input list. Scenario You are helping a teacher create a tool that helps visualize the results of a multiple-choice test. Each integer in the list `frequencies` represents the number of students who selected a particular answer choice. Your function will generate a histogram to visually display these results for easier analysis. Implement the function with the following signature: ```python def generate_histogram(frequencies: list[int]) -> list[str]: pass ``` # Example ```python generate_histogram([5, 1, 3, 0, 2]) ``` Output: ``` [ \\"0: *****\\", \\"1: *\\", \\"2: ***\\", \\"3: \\", \\"4: **\\" ] ``` This new question provides a succinct and clear problem statement. It explores list manipulation and string formatting, which aligns with the style, complexity, and scope of typical coding assessment questions.","solution":"def generate_histogram(frequencies): Generates a histogram from the given list of frequencies. Parameters: frequencies (list[int]): A list of non-negative integers representing frequencies. Returns: list[str]: A list of strings where each string represents a row in the histogram. histogram = [] for index, frequency in enumerate(frequencies): histogram.append(f\\"{index}: {\'*\' * frequency}\\") return histogram"},{"question":"# Problem Statement You are assigned to develop a function that processes a list of transactions to summarize the spending by category and identify the highest spending category for a given month. Each transaction has a date, category, and amount. # Objectives 1. **Summarize the total spending for each category for a specified month**. 2. **Identify the category with the highest spending for that month**. 3. **Handle transactions efficiently to provide accurate results**. # Requirements 1. Implement the function `summarize_transactions` which accepts the following parameters: * `transactions` (list of dict): A list of transactions where each transaction is represented as a dictionary with keys: `\'date\'` (string in the format \'YYYY-MM-DD\'), `\'category\'` (string), and `\'amount\'` (float). * `year` (int): The year for which the summary is to be generated. * `month` (int): The month for which the summary is to be generated (1 for January, 2 for February, etc.). 2. Validate the input parameters: * Ensure `year` is a valid four-digit year. * Ensure `month` is an integer between 1 and 12. * Ensure each transaction in the list has the required keys and valid data types. * Raise appropriate error messages for invalid inputs. 3. Process the transactions to: * Calculate the total spending for each category in the specified month. * Identify the category with the highest spending for that month. * If there are no transactions for the given month, return an empty dictionary and `None` for the highest category. 4. Return a tuple: * A dictionary where the keys are the categories and the values are the total spending for those categories in the specified month. * The category with the highest spending as a string. # Input Format * `transactions`: A list of dictionaries, each containing \'date\' as a string, \'category\' as a string, and \'amount\' as a float. * `year`: An integer representing the year. * `month`: An integer representing the month (1 to 12). # Output Format A tuple containing: 1. A dictionary with categories as keys and total spending as values. 2. A string representing the category with the highest spending. # Example ```python transactions = [ {\'date\': \'2023-01-15\', \'category\': \'Groceries\', \'amount\': 150.00}, {\'date\': \'2023-01-25\', \'category\': \'Utilities\', \'amount\': 75.50}, {\'date\': \'2023-01-15\', \'category\': \'Transport\', \'amount\': 50.00}, {\'date\': \'2023-02-10\', \'category\': \'Groceries\', \'amount\': 200.00}, {\'date\': \'2023-01-05\', \'category\': \'Entertainment\', \'amount\': 120.00} ] summarize_transactions(transactions, 2023, 1) # Output: ({\'Groceries\': 150.00, \'Utilities\': 75.50, \'Transport\': 50.00, \'Entertainment\': 120.00}, \'Groceries\') ``` # Constraint * Ensure the function operates efficiently with a linear time complexity O(n), where `n` is the number of transactions.","solution":"def summarize_transactions(transactions, year, month): Summarizes the total spending by category for the specified month and identifies the category with the highest spending. Parameters: transactions (list of dict): A list of transactions where each transaction is represented as a dictionary with keys: \'date\' (string in the format \'YYYY-MM-DD\'), \'category\' (string), and \'amount\' (float). year (int): The year for which the summary is to be generated. month (int): The month for which the summary is to be generated (1 for January, 2 for February, etc.). Returns: tuple: A dictionary with categories as keys and total spending as values, and a string representing the category with the highest spending. if not isinstance(year, int) or year < 1: raise ValueError(\\"Year must be a positive four-digit integer.\\") if not isinstance(month, int) or month < 1 or month > 12: raise ValueError(\\"Month must be an integer between 1 and 12.\\") summary = {} for transaction in transactions: date, category, amount = transaction.get(\'date\'), transaction.get(\'category\'), transaction.get(\'amount\') if not isinstance(date, str) or not isinstance(category, str) or not isinstance(amount, float): raise ValueError(\\"Transaction must have \'date\' as string, \'category\' as string, and \'amount\' as float.\\") trans_year, trans_month, _ = map(int, date.split(\'-\')) if trans_year == year and trans_month == month: if category not in summary: summary[category] = 0 summary[category] += amount if not summary: return {}, None max_category = max(summary, key=summary.get) return summary, max_category"},{"question":"# Prime Factors of a Number Problem Statement: You are given a positive integer `n`. Your task is to write a function that returns the prime factorization of `n` in the form of a dictionary where keys are the prime factors and values are their respective powers in the factorization of `n`. Function Signature: ```python def prime_factors(n: int) -> dict[int, int]: ``` Parameters: - `n (int)`: A positive integer greater than 1. Returns: A dictionary where: - Each key is an integer representing a prime factor of `n`. - Each value is an integer representing the power of the corresponding prime factor in the factorization of `n`. Constraints: - The input `n` will be a positive integer greater than 1. Examples: ```python prime_factors(28) # Expected Output: {2: 2, 7: 1} prime_factors(45) # Expected Output: {3: 2, 5: 1} prime_factors(100) # Expected Output: {2: 2, 5: 2} ``` Notes: - Ensure that your function handles large input values efficiently. - Your function should correctly identify all prime factors and their multiplicities. - You may assume `n` is always a positive integer greater than 1.","solution":"def prime_factors(n: int) -> dict[int, int]: Returns the prime factorization of n as a dictionary where keys are prime factors and values are the respective powers. factors = {} divisor = 2 while n > 1: count = 0 while n % divisor == 0: n //= divisor count += 1 if count > 0: factors[divisor] = count divisor += 1 return factors"},{"question":"Context: You are responsible for enhancing the functionality of the provided **Graph** class to include several advanced features commonly required in real-world graph-based applications. This will evaluate your understanding of graph structures, traversal algorithms, and your ability to implement new operations effectively. # Task: 1. Implement a method `shortest_path(self, start: int, end: int) -> List[int]` that finds the shortest path between two nodes using Dijkstra\'s algorithm: * If no path exists, return an empty list. 2. Implement a method `has_cycle(self) -> bool` that checks if the graph contains any cycles: * Use Depth-First Search (DFS) to determine the presence of cycles. 3. Implement a method `is_connected(self) -> bool` that checks if the graph is fully connected: * If all nodes are reachable from any starting node, the graph is connected. # Function Signature: ```python def shortest_path(self, start: int, end: int) -> List[int]: Returns the shortest path between start and end nodes using Dijkstra\'s algorithm. def has_cycle(self) -> bool: Checks if the graph contains any cycles. def is_connected(self) -> bool: Determines if the graph is fully connected. ``` # Input & Output Formats: * The `shortest_path` method takes two integers representing the start and end nodes and returns a list of integers representing the shortest path. * The `has_cycle` method takes no arguments and returns a boolean indicating the presence of cycles. * The `is_connected` method takes no arguments and returns a boolean indicating if the graph is fully connected. # Constraints: * The `shortest_path` method should handle graphs with weighted edges, with edge weights being non-negative. * The `has_cycle` method should handle both directed and undirected graphs. * The `is_connected` method assumes the graph is undirected but may have isolated nodes. # Performance Requirements: * Finding the shortest path should have a time complexity of O(E + V log V), where E is the number of edges and V is the number of vertices. * Cycle detection should run within O(V + E) time complexity. * Checking for connectivity should also have a time complexity of O(V + E). # Example: ```python # Initialize graph graph = Graph() graph.add_edge(0, 1, 4) graph.add_edge(0, 2, 1) graph.add_edge(2, 1, 2) graph.add_edge(1, 3, 1) graph.add_edge(2, 3, 5) # Shortest path from node 0 to node 3 path = graph.shortest_path(0, 3) print(path) # Expected Output: [0, 2, 1, 3] # Check for cycles cycle_exists = graph.has_cycle() print(cycle_exists) # Expected Output: False # Check if graph is connected connected = graph.is_connected() print(connected) # Expected Output: True ```","solution":"import heapq from collections import defaultdict, deque from typing import List class Graph: def __init__(self): self.graph = defaultdict(list) self.edges = [] def add_edge(self, u, v, weight): self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) # Since the graph is undirected self.edges.append((u, v, weight)) def shortest_path(self, start: int, end: int) -> List[int]: # Dijkstra\'s algorithm to find the shortest path pq = [(0, start, [])] # (cost, node, path) visited = set() while pq: (cost, node, path) = heapq.heappop(pq) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path for neighbor, weight in self.graph[node]: if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return [] def has_cycle(self) -> bool: def dfs(v, parent): visited.add(v) for neighbor, _ in self.graph[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False visited = set() for node in self.graph: if node not in visited: if dfs(node, None): return True return False def is_connected(self) -> bool: def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor, _ in self.graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Check against total number of nodes including isolated ones all_nodes = set(self.graph.keys()) visited = bfs(next(iter(self.graph))) return all_nodes == visited"},{"question":"# Question Context You are developing a simple calculator that supports basic arithmetic operations: addition, subtraction, multiplication, and division. The calculator runs on an embedded system, and thus, has limited processing power and memory. To optimize the performance, the calculator should process arithmetical expressions presented as strings. Task Write a function `evaluate_expression(expression: str) -> float` which takes an arithmetic expression as input and returns its evaluation as a float. The function must support the four basic arithmetic operations, handle operator precedence, and support parentheses for defining operation order. - **Input**: A string `expression` containing a valid arithmetic expression. The expression can contain positive numbers (including decimals), parentheses `()`, and the operators `+`, `-`, `*`, and `/`. - **Output**: A float representing the evaluation of the arithmetic expression. Constraints * The input string will always be a valid arithmetic expression. * Operations with division by zero should raise a `ZeroDivisionError`. * Whitespace in the expression should be ignored. Examples ```python assert evaluate_expression(\\"2 + 3 * 4\\") == 14.0 assert evaluate_expression(\\"10 / 2 - 3\\") == 2.0 assert evaluate_expression(\\"(1 + 2) * 3\\") == 9.0 assert evaluate_expression(\\"7 + (6 * 5^2 + 3) - 4\\") == 148.0 assert evaluate_expression(\\"10 / (2 + 3)\\") == 2.0 assert evaluate_expression(\\"3 + 4.5\\") == 7.5 # Exception Case try: evaluate_expression(\\"10 / 0\\") except ZeroDivisionError: print(\\"Caught ZeroDivisionError as expected\\") ```","solution":"def evaluate_expression(expression: str) -> float: Evaluate the arithmetic expression and return its value. Support for +, -, *, / operators and parentheses. Whitespace in the expression should be ignored. import re from operator import add, sub, mul, truediv # Removing all whitespaces from the expression expression = re.sub(r\'s+\', \'\', expression) # Defining the helper function to handle basic operations def apply_operation(operands, operator): b = operands.pop() a = operands.pop() if operands else 0 operations = { \'+\': add, \'-\': sub, \'*\': mul, \'/\': truediv } if operator == \'/\' and b == 0: raise ZeroDivisionError(\\"division by zero\\") return operations[operator](a, b) # Defining precedence of operators precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} # Convert the expression into tokens (numbers and operators) tokens = re.findall(r\'d+.?d*|[()+-*/]\', expression) operands = [] # stack for numbers operators = [] # stack for operators for token in tokens: if re.match(r\'d+.?d*\', token): # If token is a number, convert it to float and push to operands stack operands.append(float(token)) elif token in precedence: # If token is an operator, handle according to precedence while (operators and operators[-1] != \'(\' and precedence[operators[-1]] >= precedence[token]): operands.append(apply_operation(operands, operators.pop())) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': # Resolve entire expression within parenthesis while operators and operators[-1] != \'(\': operands.append(apply_operation(operands, operators.pop())) operators.pop() # remove \'(\' from stack # Apply the remaining operators to the resulting operands while operators: operands.append(apply_operation(operands, operators.pop())) return operands[0]"},{"question":"# Question: Implement a Safe Exponential Function with Clamping You are tasked with extending the existing Auto Differentiation system to handle edge cases involving exponential functions more robustly. Specifically, you need to implement a \\"safe\\" exponential function that includes clamping to avoid overflow and underflow issues. Problem Statement Modify the `GradientTracker` and `Variable` classes to add a safe exponential function which clamps the results to a predefined range to avoid overflow and underflow problems. Requirements 1. **Extend the `Variable` class**: - Implement a new method `safe_exp` within the `Variable` class. - The `safe_exp` method should compute the exponential of the variable\'s value, but clamp the result to a specified range to avoid numerical issues. 2. **Clamping Mechanism**: - Define minimum and maximum clamp values as constants (e.g., MIN_CLAMP = 1e-10 and MAX_CLAMP = 1e10). - Ensure that the exponential calculation respects these bounds. 3. **Testing and Edge Cases**: - Add test cases to ensure that the clamping works as expected and avoids overflow or underflow. - Handle input values that are very large or very small where exponentiation without clamping would lead to infinity or zero. Input and Output - The `Variable.safe_exp` function should take no additional arguments beyond the variable\'s values and return a new `Variable` containing the clamped exponential values. - Ensure compatibility with existing features of the `Variable` class. Constraints - Consider edge cases where input variables have very high or low values. - Ensure minimal changes to avoid breaking existing functionalities. - Perform the necessary validation so that users are aware when clamping occurred. Testing and Performance - Ensure that the added functionality does not introduce significant performance degradation. - Include detailed test cases to validate that the clamping mechanism works correctly. Example ```python with GradientTracker() as tracker: a = Variable([-1000.0, 0.0, 1000.0]) # Including very large and small values b = a.safe_exp() gradient_a = tracker.gradient(b, a) # Should handle exp and clamp gracefully ``` Output: ```plaintext b: expected to be clamped between MIN_CLAMP and MAX_CLAMP gradient_a: expected to provide gradients considering the clamping ``` Implement the above solution and validate using test cases to handle scenarios involving very large and very small values, ensuring that the exponential calculation is clamped appropriately.","solution":"import numpy as np # Set minimum and maximum clamp values MIN_CLAMP = 1e-10 MAX_CLAMP = 1e10 class Variable: def __init__(self, values): self.values = np.array(values) def safe_exp(self): Compute the safe exponential of the variable\'s values, clamped to avoid overflow and underflow. exp_values = np.exp(self.values) clamped_values = np.clip(exp_values, MIN_CLAMP, MAX_CLAMP) return Variable(clamped_values) class GradientTracker: def __enter__(self): # Initialize tracker return self def __exit__(self, exc_type, exc_value, traceback): # Cleanup tracker pass def gradient(self, b, a): A mock implementation for gradient computation. Assuming the gradient of e^x is e^x, modified to consider the clamping: grad_values = np.exp(a.values) grad_values = np.where(grad_values > MAX_CLAMP, 0, grad_values) # Assuming clamped high values have zero gradient grad_values = np.where(grad_values < MIN_CLAMP, 0, grad_values) # Assuming clamped low values have zero gradient return Variable(grad_values)"},{"question":"# Coding Assessment Question Problem Description You need to write a function that returns whether a given string contains any repeated characters. The function should be efficient, avoiding unnecessary computations and leveraging the properties of hash sets (or similar data structures) when appropriate. Function Signature ```python def has_repeated_characters(s: str) -> bool: pass ``` Input * `s` (str): A non-empty string with a length ( len(s) ) (1 <= len(s) <= 10^5). Output * Returns a boolean value: `True` if the string contains any repeated characters, `False` otherwise. Constraints * The input string ( s ) will contain characters only from the ASCII character set. * Optimize your solution to ensure it runs efficiently even for the maximum length of the input string. * The function should handle both uppercase and lowercase letters as distinct characters. Examples ```python assert has_repeated_characters(\\"hello\\") == True assert has_repeated_characters(\\"abcdef\\") == False assert has_repeated_characters(\\"aA\\") == False assert has_repeated_characters(\\"aa\\") == True ``` Requirements * The function should have an average time complexity close to O(n), where n is the length of the string. * Be mindful of memory usage when handling large strings. * Ensure that the function is robust enough to handle edge cases like very short strings.","solution":"def has_repeated_characters(s: str) -> bool: Returns whether a given string contains any repeated characters. Parameters: s (str): Input string to check for repeated characters. Output: bool: True if any character is repeated, False otherwise. char_set = set() for char in s: if char in char_set: return True char_set.add(char) return False"},{"question":"# Prime Factors Calculation You need to write a Python function that receives two integers `a` and `b`, and returns a list of their common prime factors. # Instructions 1. Write a function `find_prime_factors` that: * Takes two parameters `a` and `b`. * Finds and returns a sorted list of all common prime factors of `a` and `b`. # Example - For instance, for the numbers 28 and 35: - The prime factors of 28 are [2, 2, 7]. - The prime factors of 35 are [5, 7]. - The common prime factor(s) are [7]. # Objective Write the function `find_prime_factors` as described below: ```python def find_prime_factors(a: int, b: int) -> list: Finds and returns a sorted list of all common prime factors of two given integers. :param a: First integer. :param b: Second integer. :return: Sorted list of common prime factors. # Your implementation goes here. pass # Example usage: # common_factors = find_prime_factors(28, 35) # print(common_factors) # Expected output: [7] ``` # Constraints 1. Both numbers `a` and `b` will be positive integers. 2. Try to make the function efficient for larger values of `a` and `b`. 3. Your function should handle edge cases such as no common prime factors.","solution":"def find_prime_factors(a: int, b: int) -> list: Finds and returns a sorted list of all common prime factors of two given integers. :param a: First integer. :param b: Second integer. :return: Sorted list of common prime factors. def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return list(set(factors)) factors_a = prime_factors(a) factors_b = prime_factors(b) common_factors = list(set(factors_a) & set(factors_b)) common_factors.sort() return common_factors"},{"question":"# Question: Implement a Sierpinski Triangle Visualization Implement a function to generate an image of the Sierpinski Triangle using recursion. The Sierpinski Triangle is a fractal made by recursively subdividing an equilateral triangle into smaller equilateral triangles and removing the central triangle. # The Sierpinski Triangle Function Implement the function `sierpinski_triangle` with the following signature: ```python def sierpinski_triangle( image_width: int, image_height: int, max_depth: int = 5 ) -> Image.Image: Generates an image of the Sierpinski triangle up to the given recursion depth. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - max_depth (int): Maximum recursion depth. Returns: - Image.Image: The generated image of the Sierpinski triangle. pass ``` # Requirements 1. **Base Triangle**: The function should draw the initial equilateral triangle centered in the image. 2. **Recursive Subdivision**: For each recursive step, divide each triangle into four smaller triangles and remove the central one. 3. **Depth Limitation**: Stop the recursion once the specified maximum depth is reached. 4. **Color Coding**: Draw each triangle in the same color, typically black, on a white background. 5. **Performance**: Efficiently handle recursion to generate large images. # Example Usage Generate and display a Sierpinski Triangle with a depth of 6: ```python if __name__ == \\"__main__\\": img = sierpinski_triangle(800, 600, 6) img.show() ``` # Constraints * Image dimensions are positive integers, typically in the range of [100, 2000]. * Maximum recursion depth is a positive integer, typically in the range of [1, 10]. # Performance Considerations Ensure the recursive implementation is efficient and avoids excessive memory usage. Optimize drawing performance for handling large images and multiple recursive steps.","solution":"from PIL import Image, ImageDraw import math def sierpinski_triangle(image_width: int, image_height: int, max_depth: int = 5) -> Image.Image: Generates an image of the Sierpinski triangle up to the given recursion depth. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - max_depth (int): Maximum recursion depth. Returns: - Image.Image: The generated image of the Sierpinski triangle. # Create a new white image image = Image.new(\'RGB\', (image_width, image_height), \'white\') draw = ImageDraw.Draw(image) # Calculate the height of the equilateral triangle given its width def triangle_height(width): return width * (math.sqrt(3) / 2) # Sierpinski Triangle drawing function def draw_sierpinski(x, y, side_length, depth): # Calculate the three points of the equilateral triangle h = triangle_height(side_length) vertices = [ (x, y), (x + side_length / 2, y + h), (x - side_length / 2, y + h) ] # Draw the triangle using the vertices draw.polygon(vertices, outline=\'black\', fill=\'black\') # If the maximum depth is reached, stop the recursion if depth == 0: return # Calculate the side length and height for the inner triangles inner_side_length = side_length / 2 inner_h = triangle_height(inner_side_length) # Recursively draw the three inner triangles draw_sierpinski(x, y, inner_side_length, depth - 1) # Top triangle draw_sierpinski(x - inner_side_length / 2, y + inner_h, inner_side_length, depth - 1) # Bottom-left draw_sierpinski(x + inner_side_length / 2, y + inner_h, inner_side_length, depth - 1) # Bottom-right # Initial coordinates (center the triangle horizontally, top vertically) initial_x = image_width // 2 initial_y = 0 # Starting from the top # Initial side length of the base triangle initial_side_length = image_width # Draw the Sierpinski Triangle draw_sierpinski(initial_x, initial_y, initial_side_length, max_depth) return image"},{"question":"# Coding Question Task: You are given a list of integers where each element represents the amount of rainwater that can be stored in that column. Your task is to write a function that calculates the total amount of trapped rainwater. The amount of water trapped at any given column can be determined by finding the minimum of the maximum heights from the left and right, subtracting the height of the current column, and summing these values for all columns. Function Signature: ```python def trap_rainwater(heights: List[int]) -> int: pass ``` Input: * `heights` (List[int]): A list of non-negative integers representing the height of columns. Output: * The function should return an integer which is the total amount of trapped rainwater. Constraints: * `0 <= len(heights) <= 3 * 10^4` * `0 <= heights[i] <= 10^5` Example: ```python print(trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) ``` Expected Output: ``` 6 ``` Performance Requirements: The solution should aim to minimize the execution time and utilize O(n) space complexity if possible. Hints: 1. Use two pointers to keep track of the maximum heights from the left and right. 2. Iterate through the list, updating the pointers, and calculating the trapped water at each step. 3. Sum the trapped water for each column to get the total amount.","solution":"from typing import List def trap_rainwater(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += max(0, right_max - heights[right]) return trapped_water"},{"question":"# Consecutive Subsequence Sum You are required to write a function that determines if a list contains a consecutive subsequence of positive integers that adds up to a given target sum. The function should return `True` if such a subsequence exists, otherwise `False`. Consider the following example: * Given the sequence `[1, 2, 3, 4, 5]` and the target sum `12`, the function should return `True` because the subsequence `[3, 4, 5]` adds up to `12`. * Given the sequence `[1, 2, 3]` and the target sum `7`, the function should return `False` because no consecutive subsequence adds up to `7`. Function Signature: ```python def consecutive_subsequence_sum(nums: list, target: int) -> bool: ``` # Parameters: - **nums**: A list of integers (1 ≤ len(nums) ≤ 10^3, 1 ≤ nums[i] ≤ 10^3) - **target**: An integer (1 ≤ target ≤ 10^6) # Returns: - A boolean value `True` if there is a consecutive subsequence that adds up to `target`, otherwise `False`. # Examples: ```python consecutive_subsequence_sum([1, 2, 3, 4, 5], 12) # Should return True consecutive_subsequence_sum([1, 2, 3], 7) # Should return False consecutive_subsequence_sum([1, 2, 3, 7], 10) # Should return True consecutive_subsequence_sum([5, 5, 5, 5], 15) # Should return True ``` # Constraints: - You can assume the input list contains only positive integers. - Ensure the algorithm efficiently handles the maximum input constraints.","solution":"def consecutive_subsequence_sum(nums, target): n = len(nums) for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum == target: return True elif current_sum > target: break return False"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},L={class:"card-container"},z={key:0,class:"empty-state"},R=["disabled"],N={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",N,"See more"))],8,R)):u("",!0)])}const Y=h(F,[["render",D],["__scopeId","data-v-b9e23900"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/34.md","filePath":"drive/34.md"}'),j={name:"drive/34.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,V as default};
