import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-20ca3750"]]),S=JSON.parse('[{"question":"# Question: Detect Cycles in a Directed Graph **Context**: In graph theory, a cycle is a path of edges and vertices wherein a vertex is reachable from itself. In many practical applications, it is important to detect cycles to prevent infinite loops, identify dependencies, or understand the structure of the graph. **Problem Statement**: Write a Python function `detect_cycle(graph: Dict[int, List[int]]) -> bool` that determines whether a directed graph contains a cycle. **Input Format**: - A directed graph represented as an adjacency list using a dictionary. The keys are integers representing nodes, and the values are lists of integers representing the nodes that each key node has directed edges to. **Output Format**: - Return `True` if the graph contains a cycle. - Return `False` otherwise. **Constraints**: - The graph will be non-empty and can consist of any number of nodes. - You can assume that node values are non-negative integers. - The graph may be disconnected, meaning there can be nodes that do not have any incoming or outgoing edges. **Performance Requirements**: - The solution should have O(V + E) time complexity, where V is the number of vertices and E is the number of edges in the graph. - Utilize O(V) space complexity due to the storage of visited and recursion stack data structures. # Function Signature ```python def detect_cycle(graph: Dict[int, List[int]]) -> bool: pass ``` # Example Consider the following directed graph: - Input: `{0: [1], 1: [2], 2: [0], 3: [4], 4: []}` - Output: `True` because the graph contains a cycle (0 -> 1 -> 2 -> 0). Additional Example: - Input: `{0: [1], 1: [2], 2: [], 3: [4], 4: []}` - Output: `False` because the graph does not contain any cycles. Use these definitions to implement the function and validate its correctness.","solution":"def detect_cycle(graph): Function to detect a cycle in a directed graph. :param graph: Dict[int, List[int]], a directed graph represented as an adjacency list :return: bool, True if the graph contains a cycle, False otherwise def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in graph} rec_stack = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Coding Assessment Question: Context: You are developing an application for a local bakery that offers online ordering and delivery. To customize orders, the bakery wants to recommend additional items based on customers\' current cart content. This requires analyzing purchase patterns from past orders to identify commonly bought-together items. Task: Implement a function called `recommend_additional_items` that analyzes previous orders and suggests additional items for a given cart. This function should: 1. Parse a list of previous orders and create a mapping of frequently bought-together items. 2. For a given cart (a list of items), recommend up to 5 additional items that are most commonly purchased together with the items in the cart. 3. Handle edge cases such as empty carts or items with no purchase history. Requirements: 1. Use provided library (`collections.Counter`) for counting occurrences and relationships between items. 2. Implement error-handling mechanisms for edge cases. 3. Optimize the function to efficiently process large lists of past orders and quickly generate recommendations. 4. Include docstrings and comments for clarity. Expected Input and Output: **Input**: - `past_orders` (List[List[String]]): A list where each element is an order containing a list of items purchased together. - `current_cart` (List[String]): A list of items currently in the customer\'s cart. **Output**: - List[String]: A list of up to 5 recommended items based on the current cart content. **Example**: ```python # Example Past Orders: past_orders = [ [\'bread\', \'butter\', \'jam\'], [\'bread\', \'butter\'], [\'bread\', \'jam\'], [\'coffee\', \'pastry\'], [\'coffee\', \'bread\'], [\'pastry\', \'jam\'] ] # Function Call >>> recommend_additional_items(past_orders, [\'bread\']) [\'butter\', \'jam\', \'coffee\'] >>> recommend_additional_items(past_orders, [\'coffee\']) [\'pastry\', \'bread\'] >>> recommend_additional_items(past_orders, []) [] ``` Constraints: - Consider the complexity of analyzing orders to ensure the function runs efficiently with large datasets. - If there are ties in item popularity, sort the items alphabetically. Implementation Notes: - Use a dictionary to maintain a mapping of item pairs and their co-occurrence counts. - Consider both individual items and their combinations when recommending additional items. - Use a priority queue or a similar structure to efficiently manage the top recommendations.","solution":"from collections import Counter, defaultdict from itertools import combinations def recommend_additional_items(past_orders, current_cart): Recommends additional items based on past orders and the current cart content. Args: - past_orders (List[List[str]]): A list of past orders, each order is a list of items. - current_cart (List[str]): A list of items currently in the customer\'s cart. Returns: - List[str]: A list of up to 5 recommended items based on the current cart. # Edge case: Empty cart should return an empty list if not current_cart: return [] # Create a dictionary to count co-occurrences of items item_counter = defaultdict(Counter) # Populate the co-occurrence dictionary for order in past_orders: for item1, item2 in combinations(order, 2): item_counter[item1][item2] += 1 item_counter[item2][item1] += 1 # Count the potential recommendations recommendation_counter = Counter() for item in current_cart: for other_item, count in item_counter[item].items(): if other_item not in current_cart: recommendation_counter[other_item] += count # Get the top 5 most common recommendations, sorted alphabetically in case of tie most_common_recommendations = recommendation_counter.most_common() sorted_recommendations = sorted(most_common_recommendations, key=lambda x: (-x[1], x[0])) return [item for item, count in sorted_recommendations[:5]]"},{"question":"# Problem Statement Streamlining Data Processing with Custom Pipelines Overview You are given a data processing Pipeline class that consists of several steps, each representing a data transformation or processing task. Initially, this class supports simple built-in steps. Your task is to extend the Pipeline class to support custom processing steps provided by the user. Task Modify the provided `Pipeline` class to accept custom processing steps. A custom processing step should be a callable that takes a dataset and returns the processed dataset. You have to ensure that the pipeline can seamlessly integrate and execute custom steps alongside the built-in ones. Requirements 1. **Custom Step Function Parameter**: Add a new parameter for custom steps that should be a list of callables. 2. **Step Integration**: Update the pipeline to include the custom steps at the appropriate stage. 3. **Validation**: Validate that each custom step is a callable that takes one argument (the dataset) and returns a modified dataset. 4. **Execution**: Ensure that all steps, including the custom ones, are executed in sequence when the pipeline is run. Input - **Initialization Parameter**: ```python Pipeline(built_in_steps: list of str, custom_steps: list of callable = None) ``` - **Dataset**: ```text A pandas DataFrame. ``` Output - The pipeline should be able to: 1. Execute the `run` method that processes the dataset through all steps. 2. Return the final processed dataset after executing all steps. Constraints - The custom steps, if provided, must be callables that take a pandas DataFrame and return a modified pandas DataFrame. - The input dataset will always be a valid pandas DataFrame. - An empty dataset must be handled gracefully without throwing errors. Example ```python import pandas as pd import numpy as np class Pipeline: def __init__(self, built_in_steps, custom_steps=None): self.built_in_steps = built_in_steps self.custom_steps = custom_steps or [] def run(self, dataset): for step in self.built_in_steps: # Simple built-in steps implementation. if step == \\"drop_na\\": dataset = dataset.dropna() elif step == \\"fill_na\\": dataset = dataset.fillna(0) elif step == \\"normalize\\": dataset = (dataset - dataset.min()) / (dataset.max() - dataset.min()) for custom_step in self.custom_steps: if callable(custom_step): dataset = custom_step(dataset) return dataset # Define a custom processing step def custom_step_add_column(df: pd.DataFrame) -> pd.DataFrame: df[\'new_column\'] = np.random.randn(len(df)) return df # Sample data data = { \'A\': [1, 2, np.nan, 4], \'B\': [5, np.nan, np.nan, 8], \'C\': [9, 10, 11, np.nan] } df = pd.DataFrame(data) # Instantiate the Pipeline with built-in and custom steps pipeline = Pipeline(built_in_steps=[\\"drop_na\\", \\"normalize\\"], custom_steps=[custom_step_add_column]) # Execute the pipeline and process the dataset processed_df = pipeline.run(df) print(processed_df) ``` **Note**: Ensure the custom steps are applied correctly without breaking the existing built-in step functionality. The processed DataFrame should reflect all transformations.","solution":"import pandas as pd import numpy as np class Pipeline: def __init__(self, built_in_steps, custom_steps=None): self.built_in_steps = built_in_steps self.custom_steps = custom_steps or [] def run(self, dataset): for step in self.built_in_steps: # Simple built-in steps implementation. if step == \\"drop_na\\": dataset = dataset.dropna() elif step == \\"fill_na\\": dataset = dataset.fillna(0) elif step == \\"normalize\\": dataset = (dataset - dataset.min()) / (dataset.max() - dataset.min()) for custom_step in self.custom_steps: if callable(custom_step): dataset = custom_step(dataset) else: raise ValueError(f\\"Custom step {custom_step} is not callable\\") return dataset # Define a custom processing step def custom_step_add_column(df: pd.DataFrame) -> pd.DataFrame: df[\'new_column\'] = np.random.randn(len(df)) return df # Sample data data = { \'A\': [1, 2, np.nan, 4], \'B\': [5, np.nan, np.nan, 8], \'C\': [9, 10, 11, np.nan] } df = pd.DataFrame(data) # Instantiate the Pipeline with built-in and custom steps pipeline = Pipeline(built_in_steps=[\\"drop_na\\", \\"normalize\\"], custom_steps=[custom_step_add_column]) # Execute the pipeline and process the dataset processed_df = pipeline.run(df) print(processed_df)"},{"question":"# Flatten Nested List Given a nested list of integers where some elements are integers and some are lists of integers, implement a function `flatten_list(nested_list: list) -> list` that returns a flattened version of the nested list. Input Format * A single list `nested_list` which contains integers and/or other lists of integers. Output Format * A list of integers which is a flattened version of the input list. Constraints * The depth of the nested lists can be up to 20 levels. * Each individual list contains at most 1000 elements. * The elements can be either integers or another list. Examples ```python assert flatten_list([1, [2, 3], [[4, 5], 6], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_list([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] assert flatten_list([1, [], [2, [3, [4, 5]]]]) == [1, 2, 3, 4, 5] assert flatten_list([]) == [] assert flatten_list([[[[[[6]]]]]]) == [6] ``` Guidelines 1. Use recursion to handle the nested structure. 2. Ensure the function can handle deeply nested lists efficiently. 3. Optimize the function to avoid exceeding maximum recursion depth where applicable.","solution":"def flatten_list(nested_list): Flattens a nested list of integers. :param nested_list: List of integers or other lists. :return: A flat list of integers. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten_list(element)) else: flat_list.append(element) return flat_list"},{"question":"# Scenario: Imagine you are developing a social media platform that requires efficient handling of its user posts and friendships. To optimize various functionalities like finding common friends, suggesting new connections, or finding the shortest connection path between two users, you need a robust data structure. # Task: Given a set of users and their friendships represented as a graph, implement a data structure (Graph with Adjacency List) that supports the following operations efficiently: 1. **Add User**: Add a new user to the platform. 2. **Add Friendship**: Establish a friendship (bi-directional edge) between two users. 3. **Common Friends**: Determine the list of mutual friends between two given users. 4. **Shortest Path**: Find the shortest path (in terms of the number of friendships) between two users. # Implementation Requirements: 1. **Class Definition**: - `class SocialNetwork`: Manages the user graph and supports various operations. 2. **Function Definitions**: - `add_user(self, user: int) -> None`: Adds a user to the social network. - `add_friendship(self, user1: int, user2: int) -> None`: Creates a friendship between `user1` and `user2`. - `common_friends(self, user1: int, user2: int) -> list[int]`: Returns a list of mutual friends between `user1` and `user2`. - `shortest_path(self, user1: int, user2: int) -> list[int]`: Returns the shortest path between `user1` and `user2`. If no path exists, return an empty list. 3. **Input**: - User IDs are integers. - Friendship relationships are pairs of integers. - Operations include user IDs as input parameters. 4. **Output**: - Outputs and return values should be based on the specified function requirements. 5. **Constraints**: - The number of users and friendships can be large, but operations need to handle this efficiently. - All user IDs are distinct. - Assume all input constraints (valid user IDs and friendships). # Example: ```python network = SocialNetwork() network.add_user(1) network.add_user(2) network.add_user(3) network.add_user(4) network.add_friendship(1, 2) network.add_friendship(2, 3) network.add_friendship(3, 4) network.add_friendship(1, 4) print(network.common_friends(1, 3)) # Output: [2, 4] print(network.shortest_path(1, 4)) # Output: [1, 4] or [1, 2, 3, 4] ``` Implement the required functions considering edge cases and efficiency.","solution":"from collections import deque, defaultdict class SocialNetwork: def __init__(self): self.adj_list = defaultdict(set) def add_user(self, user: int) -> None: if user not in self.adj_list: self.adj_list[user] = set() def add_friendship(self, user1: int, user2: int) -> None: if user1 in self.adj_list and user2 in self.adj_list: self.adj_list[user1].add(user2) self.adj_list[user2].add(user1) def common_friends(self, user1: int, user2: int) -> list[int]: if user1 in self.adj_list and user2 in self.adj_list: return list(self.adj_list[user1].intersection(self.adj_list[user2])) return [] def shortest_path(self, user1: int, user2: int) -> list[int]: if user1 not in self.adj_list or user2 not in self.adj_list: return [] if user1 == user2: return [user1] queue = deque([(user1, [user1])]) visited = set() while queue: current_user, path = queue.popleft() visited.add(current_user) for friend in self.adj_list[current_user]: if friend == user2: return path + [friend] if friend not in visited: queue.append((friend, path + [friend])) visited.add(friend) return []"},{"question":"# Problem: Weather Data Analyzer You are provided with a function that retrieves weather data from an API. The API returns a JSON object that includes various data points such as temperature, humidity, wind speed, and a weather description. Your task is to enhance this function in the following ways: 1. **Error Handling**: Ensure proper error handling for cases where the API request fails, the JSON response is incorrect, or the data is missing. 2. **Data Validation**: Implement validation to check that the retrieved data points are within reasonable limits (e.g., temperature should be within -100 to 150 degrees Fahrenheit). 3. **Detailed Report**: Modify the function to output a more comprehensive report of the weather data, including additional calculated values like \\"Feels Like\\" temperature based on the provided temperature and humidity. # Input - `location` (string): The name of the location for which the weather data needs to be fetched. - `api_key` (string): A valid API key to access the weather data. # Output - A dictionary containing detailed weather information including keys like `temperature`, `humidity`, `wind_speed`, `description`, and `feels_like`. # Constraints - The function should handle various types of request failures gracefully, including network issues and invalid API responses. - Ensure the data points are within reasonable and expected ranges. - The solution should provide a calculated \\"Feels Like\\" value using a suitable formula based on temperature and humidity. - The function should complete in a reasonable timeframe for typical API responses. # Example Usage ```python location = \\"New York\\" api_key = \\"your_api_key_here\\" result = enhanced_weather_report(location, api_key) print(result) # Expected output: # { # \\"temperature\\": 78, # \\"humidity\\": 65, # \\"wind_speed\\": 5.0, # \\"description\\": \\"Clear sky\\", # \\"feels_like\\": 80 # // Additional data points if available in the future # } ``` # Implementation Tips - Use `try-except` blocks to handle network errors and unexpected API responses. - Validate temperature, humidity, and wind speed values to ensure they fall within realistic ranges. - Calculate the \\"Feels Like\\" temperature using an appropriate formula and ensure all required data points are present. - Consider additional future data points and make the function adaptable for them without requiring code changes.","solution":"import requests def calculate_feels_like(temp_f, humidity): Calculate the \'feels like\' temperature using a basic heat index formula. This is simplified and for more accurate results, more complex equations can be used. feels_like = temp_f + 0.33 * humidity - 0.7 return feels_like def enhanced_weather_report(location, api_key): Fetch and provide enhanced weather information for a given location. url = f\\"http://api.weatherapi.com/v1/current.json?key={api_key}&q={location}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() # Extract relevant weather data temp_f = data.get(\'current\', {}).get(\'temp_f\') humidity = data.get(\'current\', {}).get(\'humidity\') wind_speed = data.get(\'current\', {}).get(\'wind_mph\') description = data.get(\'current\', {}).get(\'condition\', {}).get(\'text\') # Data validation if temp_f is None or not (-100 <= temp_f <= 150): raise ValueError(\\"Temperature out of realistic bounds.\\") if humidity is None or not (0 <= humidity <= 100): raise ValueError(\\"Humidity out of realistic bounds.\\") if wind_speed is None or wind_speed < 0: raise ValueError(\\"Wind speed cannot be negative.\\") feels_like = calculate_feels_like(temp_f, humidity) result = { \\"temperature\\": temp_f, \\"humidity\\": humidity, \\"wind_speed\\": wind_speed, \\"description\\": description, \\"feels_like\\": feels_like } return result except requests.exceptions.RequestException as e: return {\\"error\\": \\"Request error\\", \\"message\\": str(e)} except (ValueError, KeyError) as e: return {\\"error\\": \\"Data validation error\\", \\"message\\": str(e)}"},{"question":"Given a deeper understanding of dynamic programming principles, write a Python function `knapsack(weights: list[int], values: list[int], W: int) -> int` that implements the 0/1 Knapsack problem. The function should return the maximum total value that can be put in a knapsack with a weight limit of W. # Requirements: 1. **Input**: - A list of non-negative integers `weights` where each integer represents the weight of an item. Ensure the input `weights` is a list of non-negative integers and raise an appropriate error if it’s not. - A list of non-negative integers `values` where each integer represents the value of an item corresponding to the same index in the `weights` list. Ensure the input `values` is a list of non-negative integers and raise an appropriate error if it’s not. - A non-negative integer `W` representing the maximum weight capacity of the knapsack. 2. **Output**: An integer representing the maximum total value of items that can be included in the knapsack without exceeding the weight limit. 3. **Constraints**: - The length of the `weights` and `values` lists are equal and both are between 1 and (10^3). - Each weight is a non-negative integer less than or equal to (10^3). - Each value is a non-negative integer less than or equal to (10^3). - The maximum weight capacity `W` is between 1 and (10^3). # Performance: - Ensure the implementation is optimized with a dynamic programming approach, achieving a time complexity of (O(n times W)), where (n) is the number of items. # Implementation: - Use a 2D list (or a 1D list for space optimization) to keep track of the maximum value attainable for each weight capacity up to `W`. - Ensure that the inputs are valid and handle any invalid inputs with appropriate errors. # Example: ```python >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 >>> knapsack([2, 3, 4, 5], [3, 4, 5, 6], 5) 7 >>> knapsack([], [], 10) 0 >>> knapsack([5, 4, 6, 3], [10, 40, 30, 50], 10) 90 >>> knapsack([1, 2, 3], [10, 40, 50], 1) 10 ``` # Special Considerations: - Handle the edge case where the input list length is zero by returning 0. - Handle invalid inputs gracefully by raising an appropriate error.","solution":"def knapsack(weights: list[int], values: list[int], W: int) -> int: Returns the maximum total value that can be put in a knapsack with a weight limit of W. if not all(isinstance(x, int) and x >= 0 for x in weights): raise ValueError(\'All weights must be non-negative integers.\') if not all(isinstance(x, int) and x >= 0 for x in values): raise ValueError(\'All values must be non-negative integers.\') if not (isinstance(W, int) and W >= 0): raise ValueError(\'The maximum weight capacity W must be a non-negative integer.\') n = len(weights) if n == 0: return 0 if n != len(values): raise ValueError(\'The lengths of weights and values must be equal.\') dp = [0] * (W + 1) for i in range(n): for w in range(W, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[W]"},{"question":"# Problem Statement Design a `FibonacciCalculator` class that computes the nth Fibonacci number using three different methods: 1. **Recursive**: A method `recursive_fibonacci` that computes the nth Fibonacci number using a straightforward recursive approach. 2. **Dynamic Programming (Memoization)**: A method `dp_fibonacci` that uses memoization to store previously computed Fibonacci numbers to avoid redundant calculations. 3. **Iterative**: A method `iterative_fibonacci` that uses an iterative approach to compute the nth Fibonacci number. Input Format - An integer, `n`, representing the position (starting from 0) in the Fibonacci sequence to compute. Output Format - An integer representing the nth Fibonacci number for each method. Constraints - The input integer `n` will be in the range of 0 to 10^5. Functions to Implement ```python class FibonacciCalculator: def recursive_fibonacci(self, n: int) -> int: pass def dp_fibonacci(self, n: int) -> int: pass def iterative_fibonacci(self, n: int) -> int: pass ``` Example ```python fib_calculator = FibonacciCalculator() # Recursive method print(fib_calculator.recursive_fibonacci(10)) # Output: 55 # Dynamic Programming (Memoization) method print(fib_calculator.dp_fibonacci(10)) # Output: 55 # Iterative method print(fib_calculator.iterative_fibonacci(10)) # Output: 55 ``` Note: Although the recursive approach is straightforward, it becomes inefficient for larger values of `n` due to its exponential time complexity. It is advisable to use the dynamic programming or iterative methods for larger values.","solution":"class FibonacciCalculator: def recursive_fibonacci(self, n: int) -> int: if n <= 1: return n return self.recursive_fibonacci(n - 1) + self.recursive_fibonacci(n - 2) def dp_fibonacci(self, n: int) -> int: memo = {0: 0, 1: 1} def fib(n): if n in memo: return memo[n] memo[n] = fib(n - 1) + fib(n - 2) return memo[n] return fib(n) def iterative_fibonacci(self, n: int) -> int: if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Task: Implement a Circular Buffer Develop a Python class `CircularBuffer` that supports the following operations: 1. `write(value)`: Writes a value to the buffer. If the buffer is full, the oldest value will be overwritten with the new value. 2. `read()`: Reads and removes the oldest value from the buffer. Returns `None` if the buffer is empty. 3. `is_empty()`: Checks if the buffer is empty. Returns `True` if it is empty, otherwise returns `False`. 4. `is_full()`: Checks if the buffer is full. Returns `True` if it is full, otherwise returns `False`. # Class Interface ```python class CircularBuffer: def __init__(self, capacity: int) -> None: Initialize the Circular Buffer with a given capacity. pass def write(self, value: int) -> None: Writes a value to the buffer. If the buffer is full, the oldest value will be overwritten. pass def read(self) -> int | None: Reads and removes the oldest value from the buffer. Returns None if the buffer is empty. pass def is_empty(self) -> bool: Checks if the buffer is empty. Returns True if it is empty, otherwise False. pass def is_full(self) -> bool: Checks if the buffer is full. Returns True if it is full, otherwise False. pass ``` # Constraints * `1 <= capacity <= 1000` * `0 <= value <= 10000` * `Since the number of operations can be large, your implementation should be efficient in time and space complexity`. # Example ```python # Testing the Circular Buffer buffer = CircularBuffer(3) # Writing values buffer.write(1) buffer.write(2) buffer.write(3) # Check buffer status assert buffer.is_full() == True # Buffer is full assert buffer.is_empty() == False # Buffer is not empty # Reading values assert buffer.read() == 1 # Returns 1 assert buffer.read() == 2 # Returns 2 # Write more values buffer.write(4) buffer.write(5) # Check buffer status assert buffer.is_full() == True # Buffer is full assert buffer.read() == 3 # Returns 3 assert buffer.read() == 4 # Returns 4 assert buffer.read() == 5 # Returns 5 assert buffer.read() == None # Buffer is empty ```","solution":"class CircularBuffer: def __init__(self, capacity: int) -> None: self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def write(self, value: int) -> None: if self.is_full(): self.tail = (self.tail + 1) % self.capacity else: self.size += 1 self.buffer[self.head] = value self.head = (self.head + 1) % self.capacity def read(self) -> int | None: if self.is_empty(): return None value = self.buffer[self.tail] self.buffer[self.tail] = None self.tail = (self.tail + 1) % self.capacity self.size -= 1 return value def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Task: Implement a Custom Sum Function with Validation Your task is to develop a custom sum function that calculates the sum of numbers with enhanced validation and support for both individual integers and lists of integers. Specifically: 1. **Input Validation**: Ensure all provided inputs are integers. In case of any invalid input type, raise a TypeError with the message \\"All inputs must be integers\\". 2. **List Support**: Extend the function to support lists of integers. The function should return the sum of all elements in the list. # Function Signature ```python def custom_sum(*args): Calculate the sum of the input values with enhanced validation. :param args: int or list of int :return: int: Sum of input values >>> custom_sum(1, 2, 3) 6 >>> custom_sum([1, 2, 3]) 6 >>> custom_sum([1, 2], 3, [4, 5]) 15 >>> custom_sum(1, \'a\', 3) Traceback (most recent call last): ... TypeError: All inputs must be integers >>> custom_sum([1, \'a\', 3]) Traceback (most recent call last): ... TypeError: All inputs must be integers # Your implementation here ``` # Constraints 1. The inputs can be individual integers or lists of integers. 2. All inputs must be integers. If any input is not an integer, the function should raise a TypeError. 3. The function can accept any number of arguments. # Example Usages - `custom_sum(1, 2, 3)` should return `6`. - `custom_sum([1, 2, 3])` should return `6`. - `custom_sum([1, 2], 3, [4, 5])` should return `15`. - `custom_sum(1, \'a\', 3)` should raise `TypeError: All inputs must be integers`. - `custom_sum([1, \'a\', 3])` should raise `TypeError: All inputs must be integers`.","solution":"def custom_sum(*args): Calculate the sum of the input values with enhanced validation. :param args: int or list of int :return: int: Sum of input values >>> custom_sum(1, 2, 3) 6 >>> custom_sum([1, 2, 3]) 6 >>> custom_sum([1, 2], 3, [4, 5]) 15 >>> custom_sum(1, \'a\', 3) Traceback (most recent call last): ... TypeError: All inputs must be integers >>> custom_sum([1, \'a\', 3]) Traceback (most recent call last): ... TypeError: All inputs must be integers def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item total = 0 for arg in args: if isinstance(arg, list): for item in flatten(arg): if not isinstance(item, int): raise TypeError(\\"All inputs must be integers\\") total += item else: if not isinstance(arg, int): raise TypeError(\\"All inputs must be integers\\") total += arg return total"},{"question":"**Powerful Digit Sum:** Given a number `n`, compute the sum of the digits of the number `n^m`, where `m` is a positive integer. The objective is to determine the sum of the digits of the result of raising `n` to the power of `m`. Write a function `powerful_digit_sum(n: int, m: int) -> int` that calculates and returns the sum of the digits of `n` raised to the power of `m`. # Input * An integer `n` (1 ≤ n ≤ 1000) * An integer `m` (1 ≤ m ≤ 1000) # Output * An integer representing the sum of the digits of `n^m`. # Constraints * Both input integers must be positive. * The input integers must be integer values. # Example ```python assert powerful_digit_sum(2, 10) == 7 # 2^10 = 1024, sum of digits = 1 + 0 + 2 + 4 = 7 assert powerful_digit_sum(5, 3) == 8 # 5^3 = 125, sum of digits = 1 + 2 + 5 = 8 assert powerful_digit_sum(9, 4) == 18 # 9^4 = 6561, sum of digits = 6 + 5 + 6 + 1 = 18 ``` # Notes * Pay attention to handling edge cases where the input is non-integer or less than 1. * Consider the performance and ensure your code is efficient enough to handle large numbers. * You must handle incorrect inputs appropriately by raising a `ValueError` for non-positive integers and a `TypeError` for non-integer inputs.","solution":"def powerful_digit_sum(n: int, m: int) -> int: Calculate the sum of the digits of n raised to the power of m. Parameters: n (int): Base number (1 ≤ n ≤ 1000) m (int): Exponent (1 ≤ m ≤ 1000) Returns: int: The sum of the digits of n^m if not isinstance(n, int) or not isinstance(m, int): raise TypeError(\\"Both n and m must be integers\\") if n < 1 or m < 1: raise ValueError(\\"Both n and m must be greater than or equal to 1\\") # Calculate n^m result = n ** m # Calculate the sum of the digits of the result digit_sum = sum(int(digit) for digit in str(result)) return digit_sum"},{"question":"# Context String transformations are a common task in text processing. Given two strings `s` and `t`, we want to determine if `s` can be transformed into `t` using a series of operations. The allowed operations are: 1. Insert a character. 2. Delete a character. 3. Replace a character. To solve this problem, we will need to calculate the minimum number of operations required to transform `s` into `t`. # Task Write a function that computes the minimum number of operations required to transform the string `s` into the string `t`. # Function Signature ```python def min_operations(s: str, t: str) -> int: # Your code here ``` # Example ```python >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 ``` # Constraints - (0 leq text{len}(s), text{len}(t) leq 1000) - All characters in `s` and `t` are lowercase English letters. # Notes - Consider using dynamic programming to solve this problem efficiently. - Optimize your solution to handle the upper constraints within a reasonable time complexity.","solution":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of t elif j == 0: dp[i][j] = i # Delete all characters of s elif s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"# Coding Assessment Question Scenario You are working on a text analysis project. Your task is to identify and return the longest substring without repeating characters from a given string. This problem is critical in applications like text compression or enhancing search algorithms. Problem Statement Write a function `longest_unique_substring(s: str) -> str` that finds the longest substring without repeating characters and returns it. Input - `s`: A string consisting of ASCII characters. Output - The function should return a string representing the longest substring without repeating characters. Constraints - 1 <= len(s) <= 10^5 - The string may contain characters from the ASCII set. Example ```python def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters >>> longest_unique_substring(\\"abcabcbb\\") \'abc\' >>> longest_unique_substring(\\"bbbbb\\") \'b\' >>> longest_unique_substring(\\"pwwkew\\") \'wke\' >>> longest_unique_substring(\\"\\") \'\' start = 0 max_len = 0 max_substr = \\"\\" char_index_map = {} for i in range(len(s)): if s[i] in char_index_map and char_index_map[s[i]] >= start: start = char_index_map[s[i]] + 1 char_index_map[s[i]] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:i+1] return max_substr if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` Ensure your solution handles edge cases and performs efficiently within the given constraints.","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters >>> longest_unique_substring(\\"abcabcbb\\") \'abc\' >>> longest_unique_substring(\\"bbbbb\\") \'b\' >>> longest_unique_substring(\\"pwwkew\\") \'wke\' >>> longest_unique_substring(\\"\\") \'\' start = 0 max_len = 0 max_substr = \\"\\" char_index_map = {} for i in range(len(s)): if s[i] in char_index_map and char_index_map[s[i]] >= start: start = char_index_map[s[i]] + 1 char_index_map[s[i]] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:i+1] return max_substr"},{"question":"# Context You are given a robot with a set of movement instructions (a string consisting of \'L\', \'R\', \'U\', and \'D\' characters) that dictate how the robot moves in a 2D grid. The robot starts at position (0, 0). You need to determine the final position of the robot after executing all the instructions. # Problem Statement Write a function `final_robot_position(movements: str) -> tuple[int, int]` that determines the final coordinates of the robot after completing the movement instructions. # Function Signature ```python def final_robot_position(movements: str) -> tuple[int, int]: Returns the final position of the robot after performing a series of movements given as a string. ``` # Input - `movements`: A string of length ( (0 leq text{len}(movements) leq 10^6) ) consisting of the characters \'L\', \'R\', \'U\', \'D\'. # Output - Returns a tuple (x, y) representing the final coordinates of the robot. # Example ```python assert final_robot_position(\\"RRULDD\\") == (1, -1) assert final_robot_position(\\"L\\") == (-1, 0) assert final_robot_position(\\"\\") == (0, 0) ``` # Constraints - You need to ensure that your function runs efficiently and handles the maximum input size within a reasonable timeframe. - The grid coordinates can be negative. # Notes - The robot\'s movements are as follows: - \'L\' moves the robot left (decrement x coordinate by 1) - \'R\' moves the robot right (increment x coordinate by 1) - \'U\' moves the robot up (increment y coordinate by 1) - \'D\' moves the robot down (decrement y coordinate by 1)","solution":"def final_robot_position(movements: str) -> tuple[int, int]: Returns the final position of the robot after performing a series of movements given as a string. x, y = 0, 0 for move in movements: if move == \'L\': x -= 1 elif move == \'R\': x += 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return (x, y)"},{"question":"# Base64 Encoding and Decoding Background: Base64 encoding is a method of converting binary data into a text string composed of 64 different ASCII characters. This encoding is often used to encode binary data, such as images and audio files, into text that can be easily transmitted over text-based communication channels such as email and HTTP protocols. Task: You need to implement two functions, `base64_encode` and `base64_decode`, to convert between byte data and its Base64 string representation. Your implementation should ensure the proper encoding and decoding according to the Base64 standard. Function Definitions and Requirements: 1. `base64_encode(data: bytes) -> str`: * **Input**: A byte array. * **Output**: A string representing the Base64 encoding of the input byte array. * **Constraints**: * The output should be padded with `=` characters if necessary to ensure the total length is a multiple of 4. 2. `base64_decode(data: str) -> bytes`: * **Input**: A string representing Base64 encoded data. * **Output**: A byte array decoded from the input Base64 string. * **Constraints**: * The input string must only contain valid Base64 characters (A-Z, a-z, 0-9, +, /) and padding characters (`=`). * If the input string is invalid, raise a `ValueError` with an appropriate error message. Example Usage: ```python >>> base64_encode(b\'Hello World!\') \'SGVsbG8gV29ybGQh\' >>> base64_encode(b\'\') \'\' >>> base64_decode(\'SGVsbG8gV29ybGQh\') b\'Hello World!\' >>> base64_decode(\'U29mdHdhcmUgRW5naW5lZXJpbmc=\') b\'Software Engineering\' >>> base64_decode(\'SGVsbG8gV29ybGQh==\') Traceback (most recent call last): ValueError: Data contains invalid Base64 characters. >>> base64_decode(\'SGVsbG oito V29ybGQh\') Traceback (most recent call last): ValueError: Data contains invalid Base64 characters. ``` # Guidelines: * Ensure correct Base64 encoding and decoding according to the RFC 4648 standard. * Focus on handling different edge cases, including special characters and padding. * Use built-in libraries where it simplifies the implementation but ensure to showcase understanding of the encoding and decoding process.","solution":"import base64 def base64_encode(data: bytes) -> str: Encodes a byte array into a Base64 string. :param data: Bytes to be encoded. :return: Base64 encoded string. return base64.b64encode(data).decode(\'utf-8\') def base64_decode(data: str) -> bytes: Decodes a Base64 string into bytes. :param data: Base64 encoded string. :return: Decoded bytes. :raises ValueError: If the input string contains invalid Base64 characters. if not all(c in \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\' for c in data): raise ValueError(\\"Data contains invalid Base64 characters.\\") try: return base64.b64decode(data, validate=True) except Exception: raise ValueError(\\"Data contains invalid Base64 characters.\\")"},{"question":"# Question: Implement a Graph Class with Additional Traversal Methods Given the Graph data structure, extend its functionality with additional methods to meet the following requirements: 1. **Breadth-First Search (BFS)**: Implement a method `bfs(self, start_vertex: int) -> List[int]` that performs a breadth-first search starting from a given vertex and returns a list of vertices in the order they are visited. 2. **Depth-First Search (DFS)**: Implement a method `dfs(self, start_vertex: int) -> List[int]` that performs a depth-first search starting from a given vertex and returns a list of vertices in the order they are visited. # Implementation: Method Definitions: ```python class Graph: def __init__(self) -> None: self.graph: dict[int, List[int]] = {} # adjacency list representation def add_edge(self, u: int, v: int) -> None: Adds an edge to the graph. :param u: Vertex u :param v: Vertex v if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append(v) self.graph[v].append(u) # assuming an undirected graph def bfs(self, start_vertex: int) -> List[int]: Performs BFS starting from the given vertex. :param start_vertex: Vertex to start BFS from :return: List of vertices in the order they are visited def dfs(self, start_vertex: int) -> List[int]: Performs DFS starting from the given vertex. :param start_vertex: Vertex to start DFS from :return: List of vertices in the order they are visited ``` Expected Input/Output: 1. **bfs(self, start_vertex: int) -> List[int]** - **Input**: A starting vertex integer. - **Output**: List of vertices in the order they are visited using BFS. - **Example**: ```python graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 5) graph.bfs(1) ``` If the graph has edges [(1, 2), (1, 3), (2, 4), (3, 5)], the output should be: ```python [1, 2, 3, 4, 5] ``` 2. **dfs(self, start_vertex: int) -> List[int]** - **Input**: A starting vertex integer. - **Output**: List of vertices in the order they are visited using DFS. - **Example**: ```python graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 5) graph.dfs(1) ``` If the graph has edges [(1, 2), (1, 3), (2, 4), (3, 5)], the output should be: ```python [1, 2, 4, 3, 5] ``` # Constraints: 1. The graph is connected and undirected. 2. The graph can have any number of vertices and edges. 3. The input starting vertex is guaranteed to be present in the graph. # Performance Requirements: 1. The methods should be efficient in terms of time and space complexity. 2. Ensure the implementation can handle large graphs effectively.","solution":"from collections import deque from typing import List, Dict class Graph: def __init__(self) -> None: self.graph: Dict[int, List[int]] = {} # adjacency list representation def add_edge(self, u: int, v: int) -> None: Adds an edge to the graph. :param u: Vertex u :param v: Vertex v if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append(v) self.graph[v].append(u) # assuming an undirected graph def bfs(self, start_vertex: int) -> List[int]: Performs BFS starting from the given vertex. :param start_vertex: Vertex to start BFS from :return: List of vertices in the order they are visited visited = set() queue = deque([start_vertex]) result = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend(v for v in self.graph[vertex] if v not in visited) return result def dfs(self, start_vertex: int) -> List[int]: Performs DFS starting from the given vertex. :param start_vertex: Vertex to start DFS from :return: List of vertices in the order they are visited visited = set() stack = [start_vertex] result = [] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) result.append(vertex) stack.extend(v for v in self.graph[vertex] if v not in visited) return result"},{"question":"# Prime Product Checker You need to implement a function that checks whether a given positive integer `n` (greater than 1) can be expressed as the product of two distinct prime numbers. If it can, the function should return the two primes as a tuple. If it cannot, the function should return `None`. For example: * The number 15 can be expressed as 3 * 5, so the function should return (3, 5). * The number 20 cannot be expressed as the product of two distinct primes, so the function should return `None`. Function Signature: ```python def prime_product_checker(n: int) -> Optional[Tuple[int, int]]: ``` # Parameters: - **n**: An integer (2 < n < 10**6). # Returns: - A tuple of two integers representing the distinct prime factors if `n` can be expressed as a product of two distinct primes. - `None` if `n` cannot be expressed as such a product. # Constraints: - Assume the function `is_prime(x)` is available and correctly determines if `x` is a prime number. - The function should be efficient considering the constraints. # Examples: ```python prime_product_checker(15) # Should return (3, 5) prime_product_checker(20) # Should return None prime_product_checker(21) # Should return (3, 7) prime_product_checker(35) # Should return (5, 7) prime_product_checker(77) # Should return (7, 11) ``` Your solution should consider optimal prime-checking and efficiently handle the constraints provided.","solution":"from typing import Optional, Tuple def is_prime(x: int) -> bool: Helper function to check if a number is prime. if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def prime_product_checker(n: int) -> Optional[Tuple[int, int]]: Function to check if the given number n can be expressed as a product of two distinct prime numbers. for i in range(2, int(n**0.5) + 1): if n % i == 0: j = n // i if is_prime(i) and is_prime(j) and i != j: return (i, j) return None"},{"question":"# Compiling Large-Scale Statistical Summaries Scenario You have a large log file composed of individual records, each containing an entry for a user, a timestamp, and an associated numeric value. You need to process this file to compute statistical summaries for each user efficiently, leveraging multi-threading to handle the large size of the dataset. # Problem Statement Write a Python function `compute_user_statistics(logfile, num_threads)` that processes a log file and computes basic statistical summaries (mean, median, and standard deviation) for each user, using multi-threading to improve performance. Requirements: 1. **Input**: - `logfile`: a string representing the path to the log file to be processed. - `num_threads`: an integer representing the number of threads to use for parallel processing. 2. **Output**: - The function should return a dictionary where each key is a user ID and the value is another dictionary containing `mean`, `median`, and `std_dev` (standard deviation) of the numeric values associated with that user. 3. **Constraints**: - Ensure that the log file may be too large to fit into memory, so line-by-line processing or chunked reading strategies should be considered. - Make optimal use of available memory and CPU resources, leveraging Python\'s `threading` or `concurrent.futures` modules. 4. **Performance**: - Optimize the implementation to minimize disk I/O while maintaining thread safety. 5. **LogFile Format**: - Each line in the log file is formatted as `\\"user_id timestamp value\\"` where `user_id` is a string, `timestamp` is an ISO-8601 formatted string, and `value` is a floating-point number. # Example: ```python summaries = compute_user_statistics(\\"activity_log.txt\\", 4) ``` This call should process `activity_log.txt` using 4 threads and return the statistical summaries for each user. # Additional Notes: - Handle edge cases such as users with no records, files with missing or malformed data, or extremely skewed distributions. - Ensure proper synchronization when accessing shared resources. - Validate the accuracy of statistical computations considering numerical precision and robustness.","solution":"import csv import os import threading from collections import defaultdict from statistics import mean, median, stdev from concurrent.futures import ThreadPoolExecutor def compute_statistics(values): return { \'mean\': mean(values), \'median\': median(values), \'std_dev\': stdev(values) if len(values) > 1 else 0.0 } def process_chunk(chunk, user_data): local_data = defaultdict(list) for line in chunk: try: user_id, _, value = line.split() value = float(value) local_data[user_id].append(value) except ValueError: continue # Skip malformed lines for user, values in local_data.items(): user_data[user].extend(values) def read_in_chunks(file_object, chunk_size=1024*1024): while True: data = file_object.readlines(chunk_size) if not data: break yield data def compute_user_statistics(logfile, num_threads): user_data = defaultdict(list) lock = threading.Lock() def process_file_chunk(chunk): local_data = defaultdict(list) process_chunk(chunk, local_data) with lock: for user, values in local_data.items(): user_data[user].extend(values) with open(logfile, newline=\'\') as file: with ThreadPoolExecutor(max_workers=num_threads) as executor: futures = [] for chunk in read_in_chunks(file): futures.append(executor.submit(process_file_chunk, chunk)) for future in futures: future.result() # wait for all to complete return {user: compute_statistics(values) for user, values in user_data.items()}"},{"question":"# Problem Statement You are creating a simple drawing application that needs to render a series of shapes on a canvas. One of the first functionalities required is the ability to draw circles. You must implement a function that generates a list of points representing the perimeter of a circle given its center coordinates and radius. Use Bresenham\'s circle drawing algorithm to achieve this. # Function Signature ```python def draw_circle(center_x, center_y, radius): Generates a list of points representing the perimeter of a circle using Bresenham\'s circle drawing algorithm. Arguments: center_x -- the x-coordinate of the center of the circle center_y -- the y-coordinate of the center of the circle radius -- the radius of the circle Returns: A list of tuples, each representing the (x, y) coordinates of a point on the perimeter of the circle. pass ``` # Input * `center_x` (int): The x-coordinate of the center of the circle. * `center_y` (int): The y-coordinate of the center of the circle. * `radius` (int): The radius of the circle. # Output * List of tuples `(int, int)` representing the (x, y) coordinates of points on the perimeter of the circle. # Constraints * ( 0 leq center_x, center_y leq 1000 ) * ( 1 leq radius leq 100 ) # Example ```python # Define the parameters center_x = 50 center_y = 50 radius = 10 # Call the function points = draw_circle(center_x, center_y, radius) # Example output (first few points) # [(60, 50), (59, 51), (59, 49), ... ] ``` # Explanation The function generates a list of points that form the perimeter of a circle centered at `(center_x, center_y)` with the specified `radius`. The points are calculated using Bresenham’s algorithm, which exploits symmetry to efficiently compute the circle coordinates. The example output only shows a few points, but the complete list should contain all points on the circle’s perimeter.","solution":"def draw_circle(center_x, center_y, radius): Generates a list of points representing the perimeter of a circle using Bresenham\'s circle drawing algorithm. Arguments: center_x -- the x-coordinate of the center of the circle center_y -- the y-coordinate of the center of the circle radius -- the radius of the circle Returns: A list of tuples, each representing the (x, y) coordinates of a point on the perimeter of the circle. points = [] x = 0 y = radius d = 3 - 2 * radius def add_points(cx, cy, x, y): points.append((cx + x, cy + y)) points.append((cx - x, cy + y)) points.append((cx + x, cy - y)) points.append((cx - x, cy - y)) points.append((cx + y, cy + x)) points.append((cx - y, cy + x)) points.append((cx + y, cy - x)) points.append((cx - y, cy - x)) while y >= x: add_points(center_x, center_y, x, y) if d <= 0: d = d + 4 * x + 6 else: d = d + 4 * (x - y) + 10 y -= 1 x += 1 return points"},{"question":"# Problem: Sort Words by Frequency and Alphabetically You are given a list of words. Your task is to sort and return the words. The sorting should first be based on the frequency of each word in descending order, and for words with the same frequency, they should be sorted lexicographically in ascending order. Function Signature ```python def sort_words_by_frequency(words: List[str]) -> List[str]: pass ``` # Description Given: - `words`: A list of strings representing words. Your implementation should: 1. Count the frequency of each word in the list. 2. Sort the words primarily by their frequency in descending order. 3. For words with the same frequency, sort them alphabetically (lexicographically) in ascending order. 4. Return the sorted list of words. # Constraints - The words list will have at most `10^6` words. - Each word will have a length between `1` and `100` characters. - Words consist only of lowercase English letters. # Input/Output Example ```python # Example 1 words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] print(sort_words_by_frequency(words)) # Output: [\\"banana\\", \\"apple\\", \\"orange\\"] # Example 2 words = [\\"word\\", \\"word\\", \\"test\\", \\"word\\", \\"example\\", \\"test\\", \\"another\\"] print(sort_words_by_frequency(words)) # Output: [\\"word\\", \\"test\\", \\"another\\", \\"example\\"] # Example 3 words = [\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"a\\"] print(sort_words_by_frequency(words)) # Output: [\\"a\\", \\"b\\", \\"c\\"] ``` # Edge Cases to Consider - If the list is empty, return an empty list. - Single-word list should return the word itself. - Handle ties correctly using lexicographical order as specified. # Important Notes - Use efficient data structures to handle counting and sorting large numbers of words. - Ensure that the solution performs well with the upper limit of the constraints.","solution":"from collections import Counter from typing import List def sort_words_by_frequency(words: List[str]) -> List[str]: Sort words by their frequency in descending order. For words with the same frequency, sort them lexicographically in ascending order. # Count the frequency of each word word_count = Counter(words) # Sort words by frequency and then lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the words and ignore the counts result = [word for word, count in sorted_words] return result"},{"question":"# Fibonacci Sequence Calculation Objective You are required to write a Python function that computes the nth term of the Fibonacci sequence. The implementation can be recursive with memoization or iterative based on your preference. Problem Statement Given a positive integer `n`, implement a function `fibonacci(n: int) -> int` that returns the nth term of the Fibonacci sequence. You should also write a test suite to verify your implementation handles various cases correctly. Input and Output Format * **Input**: A positive integer `n`, where (1 <= n <= 10^5). * **Output**: An integer representing the nth term in the Fibonacci sequence. Constraints * The input value will be a positive integer within the specified range. * The solution should efficiently handle cases where `n` is large. Performance Requirements * Time Complexity: O(n) for iterative or O(n) with memoization for recursive. * Space Complexity: O(1) for iterative, O(n) for recursive with memoization. Example 1 * **Input**: `n = 5` * **Output**: `5` Example 2 * **Input**: `n = 10` * **Output**: `55` Example 3 * **Input**: `n = 1` * **Output**: `1` Example 4 * **Input**: `n = 20` * **Output**: `6765` Tasks 1. Implement the function `fibonacci(n: int) -> int`. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases like the smallest and largest values. Notes * Pay attention to efficiently handle large values of `n`. * Ensure your function is well-tested for edge cases and performance limits. * If using a recursive approach, use memoization to avoid excessive recalculations.","solution":"def fibonacci(n: int) -> int: Returns the nth term of the Fibonacci sequence. if n <= 0: raise ValueError(\\"The input must be a positive integer.\\") elif n == 1 or n == 2: return 1 prev, curr = 1, 1 for _ in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a part of a banking application. One key functionality is to maintain a record of transactions and quickly determine the current balance based on the transaction history. Each transaction record is either a credit (deposit) or debit (withdrawal) operation. Task Write a class `BankAccount` that keeps track of the balance based on a given list of transactions. Each transaction is a tuple with the type of transaction (\'credit\' or \'debit\') and the amount. The class should provide a method `current_balance()` to return the current balance after processing the list of transactions. Input - The class is initialized with a list of transactions where each transaction is represented as a tuple `(type: str, amount: int)`. Output - The method `current_balance()` should return the current balance as an integer. Constraints - All transaction amounts are positive integers. - A debit transaction will not exceed the current balance. Performance Requirements - The methods must execute efficiently within reasonable constraints of typical usage. Function Signature ```python class BankAccount: def __init__(self, transactions: List[Tuple[str, int]]): # Initializes the BankAccount with a list of transactions def current_balance(self) -> int: # Returns the current balance ``` Example ```python # Create a BankAccount instance with the given transaction list account = BankAccount([(\'credit\', 1000), (\'debit\', 200), (\'credit\', 500), (\'debit\', 800)]) # Get the current balance assert account.current_balance() == 500 ```","solution":"from typing import List, Tuple class BankAccount: def __init__(self, transactions: List[Tuple[str, int]]): self.transactions = transactions self.balance = self.calculate_balance() def calculate_balance(self) -> int: balance = 0 for transaction in self.transactions: if transaction[0] == \'credit\': balance += transaction[1] elif transaction[0] == \'debit\': balance -= transaction[1] return balance def current_balance(self) -> int: return self.balance"},{"question":"# Coding Question Instructions: You are given the logs of user search queries on an e-commerce website. Each log entry records the time and the keywords of the query. Implement a function to identify the top `k` most frequently searched keywords within a given time range. Function Signature: ```python def top_k_search_queries(logs: List[Tuple[str, List[str]]], k: int, start_time: str, end_time: str) -> List[Tuple[str, int]]: pass ``` Input: * `logs` (List[Tuple[str, List[str]]]): A list of log entries, where each entry is a tuple with a timestamp (string in the format \\"YYYY-MM-DD HH:MM:SS\\") and a list of keywords (strings) from the query. * `k` (int): The number of top search keywords to return. * `start_time` (str): The starting timestamp (string in the format \\"YYYY-MM-DD HH:MM:SS\\") for the query time range. * `end_time` (str): The ending timestamp (string in the format \\"YYYY-MM-DD HH:MM:SS\\") for the query time range. Output: * Returns a list of tuples, where each tuple contains a keyword (string) and its frequency count (int), representing the top `k` most frequently searched keywords in the given time range. Constraints: * 1 ≤ len(logs) ≤ 1000 * 1 ≤ len(logs[i][1]) ≤ 20 * 1 ≤ len(keywords) ≤ 5 * 1 ≤ len(keyword) ≤ 20 * 1 ≤ k ≤ 20 Example: ```python logs = [ (\\"2023-01-01 08:00:00\\", [\\"shoes\\", \\"sneakers\\"]), (\\"2023-01-01 08:05:00\\", [\\"shoes\\", \\"boots\\"]), (\\"2023-01-01 08:10:00\\", [\\"sneakers\\", \\"sports\\"]), (\\"2023-01-01 09:00:00\\", [\\"boots\\"]), (\\"2023-01-02 08:00:00\\", [\\"shoes\\"]), (\\"2023-01-02 08:05:00\\", [\\"shoes\\", \\"sneakers\\"]), (\\"2023-01-02 08:10:00\\", [\\"sneakers\\", \\"clothing\\"]), (\\"2023-01-02 08:12:00\\", [\\"shoes\\", \\"boots\\"]) ] k = 2 start_time = \\"2023-01-01 08:00:00\\" end_time = \\"2023-01-01 08:30:00\\" # Expected output [ (\\"shoes\\", 2), (\\"sneakers\\", 2) ] ``` Notes: * Timestamps in the logs are guaranteed to be in ascending order. * Handle edge cases where no logs fall within the specified time range. * If there are ties in the frequency counts, return the keywords in lexicographical order.","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime def top_k_search_queries(logs: List[Tuple[str, List[str]]], k: int, start_time: str, end_time: str) -> List[Tuple[str, int]]: # Convert string times to datetime objects for comparison start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") # Dictionary to count keyword frequencies keyword_count = defaultdict(int) # Iterate over the logs within the given time range for log_time, keywords in logs: log_dt = datetime.strptime(log_time, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= log_dt <= end_dt: for keyword in keywords: keyword_count[keyword] += 1 # Sort the keywords by frequency (descending) and then by keyword (lexicographically) sorted_keywords = sorted(keyword_count.items(), key=lambda x: (-x[1], x[0])) # Return the top k keywords return sorted_keywords[:k]"},{"question":"# Maximum Subarray Sum with Negative Values You have been tasked to demonstrate your understanding of dynamic programming by implementing a function that finds the maximum sum of a contiguous subarray from a list of integers, which can include both positive and negative values. **Function Signature:** ```python def max_subarray_sum(arr: list) -> int: ``` **Input:** * `arr` - A list of integers, which may contain negative values. **Output:** * An integer representing the maximum sum of a contiguous subarray. **Constraints:** * The function should handle cases where all elements are negative. * The solution should employ an efficient approach, ideally Kadane\'s algorithm, to ensure optimal performance for large inputs. * Edge cases such as empty lists and single-element lists must be managed appropriately. **Scenario:** Imagine you are working on a financial application that analyzes daily stock price changes. Identifying the period with the maximum net gain, despite some potential losses (negative values), is crucial. Implementing this function will help in formulating strategies based on the market analysis. **Example:** ```python >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([-4, -3, -2, -1]) -1 >>> max_subarray_sum([10]) 10 ``` You can use the following code as a starting point for your solution: ```python def max_subarray_sum(arr: list) -> int: if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global ``` **Note:** Comprehensive testing with various types of input lists, including those with all negative values and large lists, is encouraged to ensure robustness and correctness of the implementation.","solution":"def max_subarray_sum(arr: list) -> int: if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Context You are developing a utility to assist in analyzing sequences and predicting next elements based on observed patterns. One common method is to identify the arithmetic progression in the sequence. # Task Write a function that determines if a sequence of numbers forms an arithmetic progression, and if so, computes the next number in the sequence. # Function Specification **Function Name**: `next_in_arithmetic_sequence` Input * `sequence`: list - A list of integers representing the sequence. Output * `int` - The next number in the sequence if it forms an arithmetic progression. * `str` - A message indicating the sequence is not an arithmetic progression if it doesn\'t. **Constraints** * The sequence will contain at least 2 integers. # Example Example 1 ```python sequence = [3, 5, 7, 9, 11] result = next_in_arithmetic_sequence(sequence) print(result) # Output: 13 ``` Example 2 ```python sequence = [2, 4, 8, 16] result = next_in_arithmetic_sequence(sequence) print(result) # Output: \'The sequence is not an arithmetic progression\' ``` # Notes * An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant. * If the sequence is `[a, b, c, ...]`, the common difference `d` should satisfy `b-a == c-b == d`. If the sequence confirms this property, the next number after the list can be computed as the last term plus `d`. * Ensure robust handling of different integer inputs while adhering to constraints.","solution":"def next_in_arithmetic_sequence(sequence): Determines if a sequence of numbers forms an arithmetic progression, and if so, computes the next number in the sequence. Otherwise, returns a message indicating it is not an arithmetic progression. :param sequence: List of integers :return: The next number in the sequence or a message stating the sequence is not an arithmetic progression if len(sequence) < 2: return \\"The sequence must contain at least two integers\\" # Calculate the common difference d = sequence[1] - sequence[0] # Check if all consecutive pairs have the same difference for i in range(1, len(sequence) - 1): if sequence[i+1] - sequence[i] != d: return \\"The sequence is not an arithmetic progression\\" # If it is an arithmetic progression, return the next number return sequence[-1] + d"},{"question":"# Stack-based Balancer for Matched Parentheses You are given a string containing only three types of characters: \'(\', \')\', and \'*\'. Write a function to check if this string can be considered balanced. The character \'*\' can be considered as an opening parenthesis \'(\', a closing parenthesis \')\', or an empty string. Your task is to implement a function `is_balanced` that determines if the given string can be balanced by interpreting each \'*\' as described above. Below is the signature of the function you need to complete: ```python def is_balanced(s: str) -> bool: # Implement this function to check balanced parentheses pass ``` # Implementation Requirements: 1. **Balanced Parentheses Check**: Return `True` if the string can be balanced by interpreting \'*\' as \'(\', \')\', or an empty string. Otherwise, return `False`. 2. **Stack Utilization**: Utilize a stack-based approach to solve this problem efficiently. # Input: - A single string `s` containing only characters \'(\', \')\', and \'*\'. - `1 <= len(s) <= 1000`. # Output: - Return `True` if the string can be balanced, otherwise return `False`. # Constraints: - The length of the string will not exceed 1000 characters. # Example 1: Input: ``` s = \\"(*))\\" ``` Output: ``` True ``` # Example 2: Input: ``` s = \\"(*()\\" ``` Output: ``` True ``` # Example 3: Input: ``` s = \\"(*))(\\" ``` Output: ``` False ``` # Explanation: - In the first example, the \'*\' can be considered as \'(\', making the string a balanced \'(()))\'. - In the second example, the \'*\' can be considered as an empty string, making the string balanced. - In the third example, no interpretation of \'*\' can balance the string due to the extra \'(\'. By implementing the `is_balanced` function, you will handle different interpretations of the \'*\' character and check if the string can be balanced accordingly.","solution":"def is_balanced(s: str) -> bool: max_open = 0 min_open = 0 for char in s: if char == \'(\': max_open += 1 min_open += 1 elif char == \')\': max_open -= 1 min_open = max(min_open - 1, 0) else: # char == \'*\' max_open += 1 min_open = max(min_open - 1, 0) if max_open < 0: return False return min_open == 0"},{"question":"# Binary Tree Right Side View Scenario As part of developing a visualization tool for hierarchical data, you need to implement a feature that displays the rightmost view of the binary tree structure. This feature helps users quickly identify the essential elements visible from the tree\'s right boundary, ensuring a clear hierarchical overview. Problem Statement Write a function `right_side_view` that returns the values of the nodes visible from the right side of a binary tree. The right side view of a binary tree contains the last node at each level when viewed from the right. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode) -> list[int]: ``` Input - `root` (TreeNode): The root node of the binary tree. Output - Returns a list of integers representing the values of the nodes visible from the right side. Examples ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2, right=TreeNode(5)) root.right = TreeNode(3, right=TreeNode(4)) assert right_side_view(root) == [1, 3, 4] # Example 2 root = None assert right_side_view(root) == [] # Example 3 root = TreeNode(1) assert right_side_view(root) == [1] # Example 4 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(4) root.right = TreeNode(3) assert right_side_view(root) == [1, 3, 4] # Example 5 root = TreeNode(1) root.left = TreeNode(2, TreeNode(4)) root.right = TreeNode(3, None, TreeNode(5)) assert right_side_view(root) == [1, 3, 5] ``` Constraints - The number of nodes in the binary tree is in the range `[0, 100]`. - `-100 ≤ Node.val ≤ 100` Performance Requirements - The function should efficiently traverse the tree and correctly identify the right side view nodes in a time complexity of O(n), where n is the number of nodes in the tree. Notes - Consider edge cases such as an empty tree, single node tree, and trees with various shapes (e.g., skew trees). - Ensure that the solution uses optimal space complexity and handles recursion depth appropriately.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode) -> list[int]: if not root: return [] view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return view"},{"question":"# Problem Statement You need to implement a simplified filesystem in memory using a tree structure. Each node in the tree represents either a file or a directory. The filesystem should support creating files and directories, retrieving the contents of directories, and reading the contents of files. Requirements 1. **`mkdir(path: str) -> None`**: * Create a new directory at the specified path. * If intermediate directories in the path do not exist, create them as needed. 2. **`touch(path: str) -> None`**: * Create a new, empty file at the specified path. * If intermediate directories in the path do not exist, create them as needed. 3. **`ls(path: str) -> List[str]`**: * List the contents of the directory at the specified path. * If the path is a file, return a list containing just the file name. 4. **`read(path: str) -> str`**: * Return the contents of the file at the specified path. * If the path is a directory, return an appropriate error message. 5. **`write(path: str, content: str) -> None`**: * Write the specified content to the file at the given path. * If the path represents a directory, return an appropriate error message. Constraints * Paths are given as strings with components separated by \\"/\\" (e.g., \\"/a/b/c\\"). * Directory names and file names consist of alphanumeric characters. * The root directory is represented as \\"/\\" and exists by default. * The filesystem should support nested directory structures. * Return appropriate error messages for invalid operations, such as reading from a directory or writing to a non-existent file. Example ```python class FileSystem: def __init__(self): # Initialize the filesystem with the root directory. def mkdir(self, path: str) -> None: # Implement the method to create directories. def touch(self, path: str) -> None: # Implement the method to create files. def ls(self, path: str) -> List[str]: # Implement the method to list directory contents. def read(self, path: str) -> str: # Implement the method to read file contents. def write(self, path: str, content: str) -> None: # Implement the method to write file contents. ``` Testing * Initialize the filesystem and create a series of nested directories and files. * Test listing the contents of directories at various levels. * Attempt to read files and directories, validating that the tree structure behaves as expected. * Write new content to files and verify the changes are accurately reflected. * Handle edge cases such as attempting to write to a directory or reading from a non-existent file.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} def mkdir(self, path: str) -> None: components = path.strip(\'/\').split(\'/\') d = self.fs[\'/\'] for comp in components: if comp not in d: d[comp] = {} d = d[comp] def touch(self, path: str) -> None: components = path.strip(\'/\').split(\'/\') d = self.fs[\'/\'] for comp in components[:-1]: if comp not in d: d[comp] = {} d = d[comp] d[components[-1]] = \'\' def ls(self, path: str) -> list: components = path.strip(\'/\').split(\'/\') d = self.fs[\'/\'] for comp in components: if comp != \'\': d = d[comp] if isinstance(d, str): return [components[-1]] return sorted(d.keys()) def read(self, path: str) -> str: components = path.strip(\'/\').split(\'/\') d = self.fs[\'/\'] for comp in components: if comp != \'\': d = d[comp] if isinstance(d, dict): return \\"Error: Path is a directory\\" return d def write(self, path: str, content: str) -> None: components = path.strip(\'/\').split(\'/\') d = self.fs[\'/\'] for comp in components[:-1]: if comp not in d: return \\"Error: Path does not exist\\" d = d[comp] if isinstance(d[components[-1]], dict): return \\"Error: Path is a directory\\" d[components[-1]] = content"},{"question":"**Problem Statement**: You are assigned to create an implementation of a simple cache mechanism using the Least Recently Used (LRU) eviction policy. This is a common technique used to manage a limited amount of valuable data in memory. # Features to Implement: 1. **Add/Update Item**: - Method: `put(key: K, value: V) -> None` - Description: Adds a new item or updates an existing item with the given key and value in the cache. If the cache reaches its capacity, it should evict the least recently used item before adding the new item. 2. **Retrieve Item**: - Method: `get(key: K) -> V` - Description: Retrieves the value associated with the given key if present in the cache and marks the item as recently used. If the key is not found, raise a `KeyError`. 3. **Check Existence**: - Method: `contains(key: K) -> bool` - Description: Returns `True` if the key is present in the cache, `False` otherwise. 4. **Remove Item**: - Method: `remove(key: K) -> None` - Description: Removes the specified key and its associated value from the cache. If the key does not exist, raise a `KeyError`. 5. **Clear Cache**: - Method: `clear() -> None` - Description: Clears all items from the cache. # Constraints: - You can assume that `K` will always be hashable and comparable. - The maximum capacity of the cache will be provided during the initialization of the class. - Make sure the get and put operations have an average time complexity of O(1). # Implementation: - Use any appropriate data structures such as `OrderedDict` or a custom combination of a doubly linked list and hash map to achieve the desired time complexities. # Example: ```python # Example Usage cache = LRUCache(capacity=2) cache.put(1, \'A\') cache.put(2, \'B\') assert cache.get(1) == \'A\' # Returns \'A\' cache.put(3, \'C\') # Evicts key 2 try: cache.get(2) # Raises KeyError except KeyError: pass assert cache.get(3) == \'C\' # Returns \'C\' cache.put(4, \'D\') # Evicts key 1 try: cache.get(1) # Raises KeyError except KeyError: pass cache.remove(3) try: cache.get(3) # Raises KeyError except KeyError: pass cache.clear() assert not cache.contains(4) # Returns False ``` Implement the `LRUCache` class following the above description and ensure your implementation handles all edge cases effectively.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key, value): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def get(self, key): if key not in self.cache: raise KeyError(\'Key not found\') self.cache.move_to_end(key) return self.cache[key] def contains(self, key) -> bool: return key in self.cache def remove(self, key): if key not in self.cache: raise KeyError(\'Key not found\') del self.cache[key] def clear(self): self.cache.clear()"},{"question":"# Problem Statement A `k-ary` tree is a tree in which each node has no more than `k` children. Given an array `edges` where `edges[i]` is of the format `[parent, child]` representing a directed edge from `parent` to `child` in the tree, write a function to determine if the given edges form a valid `k-ary` tree. Function Signature ```python def is_valid_k_ary_tree(edges: List[List[int]], k: int) -> bool: pass ``` Input - `edges`: List[List[int]] - List of edges representing the tree (1 <= len(edges) <= 10^4) - `k`: int - Maximum number of children a node can have in the tree (1 <= k <= 10^5) Output - `returns`: bool - Return True if the edges form a valid `k-ary` tree, else return False. Constraints - The input graph is a directed acyclic graph. - Each node is represented by a unique integer. # Examples ```python >>> is_valid_k_ary_tree([[1, 2], [1, 3], [3, 4]], 2) True >>> is_valid_k_ary_tree([[1, 2], [1, 3], [1, 4]], 2) False >>> is_valid_k_ary_tree([[1, 2], [2, 3], [3, 4], [4, 1]], 2) False >>> is_valid_k_ary_tree([[1, 2], [1, 3]], 3) True >>> is_valid_k_ary_tree([], 1) True ``` # Note - Ensure that the code checks for potential cycles in the graph. - Validate that no node has more than `k` children. - Handle edge cases where the tree is empty or consists of only one node. # Performance Requirements: Your solution should be efficient enough to handle the upper constraints effectively.","solution":"from collections import defaultdict, deque def is_valid_k_ary_tree(edges, k): Determines if the given edges form a valid k-ary tree. if not edges: return True # An empty tree is a valid k-ary tree. children_count = defaultdict(int) in_degree = defaultdict(int) for parent, child in edges: children_count[parent] += 1 in_degree[child] += 1 # Check that no node has more than k children for count in children_count.values(): if count > k: return False # To ensure no cycles, we will use Kahn\'s algorithm for topological sorting # Find nodes with zero in-degree zero_in_degree_nodes = deque([node for node in children_count if in_degree[node] == 0]) visited_count = 0 while zero_in_degree_nodes: node = zero_in_degree_nodes.popleft() visited_count += 1 for child in [child for parent, child in edges if parent == node]: in_degree[child] -= 1 if in_degree[child] == 0: zero_in_degree_nodes.append(child) # If we visited all unique nodes, it means no cycle and valid tree structure unique_nodes = set(node for edge in edges for node in edge) return visited_count == len(unique_nodes)"},{"question":"# Coding Assessment Question You are given a list of integers representing the heights of buildings in a cityscape, where the width of each building is 1. The task is to find the maximum area of a rectangle formed from the contiguous buildings. You are required to implement a function `max_rectangle_area(heights: Sequence[int]) -> int` in Python, which finds the maximum possible rectangular area formed in the histogram. Function Signature ```python def max_rectangle_area(heights: Sequence[int]) -> int: ``` Input * `heights` (Sequence[int]): A list of integers representing the heights of buildings, where each integer is greater than or equal to 0. The length of the list is between 0 and 10^5. Output * Return the maximum rectangular area that can be formed by any number of contiguous buildings. Constraints * Heights array could be empty, in which case return 0. * You should aim for an optimized O(n) solution. * Each building has a width of 1. Example ```python >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 # The maximum rectangle area is 10, formed by heights 5 and 6: width 2. >>> max_rectangle_area([2, 4]) 4 # The maximum rectangle area is 4, formed by height 4: width 1. >>> max_rectangle_area([1, 1, 1]) 3 # The maximum rectangle area is 3, formed by the three heights of 1: width 3. >>> max_rectangle_area([]) 0 # Empty list, should return 0. ``` Notes * Assume all heights are in whole units. * The skyline might include buildings of height 0.","solution":"from typing import Sequence def max_rectangle_area(heights: Sequence[int]) -> int: Finds the maximum rectangular area formed by contiguous buildings represented by the input \'heights\', where each building width is 1. Args: heights (Sequence[int]): List of non-negative integers representing the heights of the buildings. Returns: int: Maximum area of a rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Scenario: You are working as a software engineer to optimize a search feature for a travel booking website. One requirement is to quickly find the n-th longest flight duration from a list of all available flight durations. Considering the potential large number of flights and the necessity for a fast response time, implement an efficient solution to determine the n-th longest duration. # Task: Implement a function `find_nth_longest(flight_durations: list, n: int) -> int` using the provided `quick_select` algorithm that efficiently determines the n-th longest flight duration from the given list. You need to repurpose and incorporate the `quick_select` method as necessary. # Function Signature: ```python def find_nth_longest(flight_durations: list, n: int) -> int: pass ``` # Input: * `flight_durations`: A list of integers representing flight durations in minutes. * `n`: An integer denoting the position (1-based) of the longest flight duration to find, where `1` ≤ `n` ≤ len(flight_durations). # Output: * Return the n-th longest flight duration in the list. # Example: ```python >>> find_nth_longest([300, 400, 700, 600, 200], 2) 600 >>> find_nth_longest([120, 180, 240, 200, 300], 1) 300 >>> find_nth_longest([90, 45, 180, 150, 60], 3) 90 ``` # Constraints: * Expect to handle lists with a length up to 15,000 elements efficiently. # Notes: * Implement and test your `find_nth_longest` function thoroughly. * Assume the `quick_select` implementation is functioning as described and adapt it if necessary.","solution":"def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] > pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quick_select(arr, left, right, n): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(arr, left, right, pivot_index) if n == pivot_index: return arr[n] elif n < pivot_index: return quick_select(arr, left, pivot_index - 1, n) else: return quick_select(arr, pivot_index + 1, right, n) def find_nth_longest(flight_durations, n): return quick_select(flight_durations, 0, len(flight_durations) - 1, n - 1)"},{"question":"# Coding Assessment Question Scenario You are working on a text-processing module that includes various utility functions. One of the required functions is `reverse_words`, which reverses the order of words in a given sentence. # Objective Implement the `reverse_words` function that takes a string containing a sentence and returns a new string where the words appear in reverse order. # Function Signature ```python def reverse_words(sentence: str) -> str: pass ``` # Constraints - Assume the input string contains only alphabets and spaces. - The words in the string will be separated by single spaces. - There should be no leading or trailing spaces in the output string. - The function should operate in O(n) time complexity, where n is the length of the input string. # Input - `sentence` (str): A string containing a sentence with words separated by single spaces. # Output - (str): A string with the words reversed in order. # Examples ```python assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"the quick brown fox\\") == \\"fox brown quick the\\" assert reverse_words(\\"a b c d e\\") == \\"e d c b a\\" assert reverse_words(\\"one\\") == \\"one\\" assert reverse_words(\\"\\") == \\"\\" # Test with leading and trailing spaces assert reverse_words(\\" hello world \\") == \\"world hello\\" ``` # Implementation Details 1. Implement the `reverse_words` function to reverse the order of words without changing the letters within the words. 2. Ensure that the function handles empty strings and single-word sentences correctly. 3. Write a test function `test_reverse_words()` to verify the correctness of `reverse_words`, covering various cases including edge cases.","solution":"def reverse_words(sentence: str) -> str: Reverse the order of words in a given sentence. # Split the sentence into words words = sentence.strip().split() # Reverse the list of words words_reversed = words[::-1] # Join the reversed list of words into a string return \' \'.join(words_reversed)"},{"question":"# Number of Ways to Climb Stairs with Constraints **Scenario**: Consider a staircase with `n` steps. You can climb 1, 2, or 3 steps at a time. However, you must alternate the number of steps taken in consecutive jumps. For example, if you climb 1 step, the next jump must be either 2 or 3 steps, and so on. Your task is to determine the number of distinct ways to reach the top of the staircase given these constraints. Task: Implement the function `count_ways_to_climb(n: int) -> int`. Given an integer `n`, the function should return the number of distinct ways to climb the staircase under the specified conditions. Input: - `n` (1 ≤ n ≤ 1000): An integer representing the number of steps in the staircase. Output: - An integer representing the number of distinct ways to climb the staircase. Constraints: - You can assume the input `n` will always be a valid integer between 1 and 1000. Examples: - When `n` is `1`, the function should return `1` (Only one way: [1]). - When `n` is `2`, the function should return `2` (Two ways: [1,2] or [2,1]). - When `n` is `3`, the function should return `3` (Three ways: [1,2,3], [2,1,3], [3]). # Performance requirements: - The solution should efficiently calculate the number of ways, considering the constraints of alternation in steps. - Use dynamic programming or other optimization techniques to ensure performance for larger values of `n`. # Notes: - Consider creating a dynamic programming table where each entry represents the number of ways to reach a certain step with different last jumps. - Ensure that alternating steps are correctly implemented within the solution. Example code snippet to start: ```python def count_ways_to_climb(n: int) -> int: Return the number of distinct ways to climb the staircase considering alternating steps of 1, 2, and 3 steps at a time. # Your implementation here ```","solution":"def count_ways_to_climb(n: int) -> int: Return the number of distinct ways to climb the staircase considering alternating steps of 1, 2, and 3 steps at a time. if n == 1: return 1 if n == 2: return 2 if n == 3: return 3 dp = [[[0 for _ in range(3)] for _ in range(3)] for _ in range(n + 1)] dp[1][0][0] = 1 dp[2][1][0] = 1 dp[2][0][1] = 1 dp[3][2][0] = 1 dp[3][0][2] = 1 dp[3][1][1] = 1 for i in range(4, n + 1): dp[i][0][1] = dp[i - 1][1][0] + dp[i - 1][2][0] dp[i][0][2] = dp[i - 1][1][1] + dp[i - 1][2][1] dp[i][1][0] = dp[i - 2][0][1] + dp[i - 2][2][1] dp[i][1][2] = dp[i - 2][0][2] + dp[i - 2][2][2] dp[i][2][0] = dp[i - 3][0][1] + dp[i - 3][1][1] dp[i][2][1] = dp[i - 3][0][2] + dp[i - 3][1][2] return sum(dp[n][i][j] for j in range(3) for i in range(3))"},{"question":"# Assessment Question: Context: You are working on a project to analyze user behavior on a website. As part of this analysis, you need to write a utility function that detects the presence of duplicate entries in user session logs. Each session log contains details about a user\'s interaction with the website, including the user\'s ID and the timestamp of the interaction. Task: Implement a function `has_duplicate_sessions` that checks whether there are any duplicate sessions for any user during a single day. For simplicity, assume a session is represented by a tuple of (user_id, timestamp), where \'timestamp\' is given as an integer representing seconds since the start of the day. # Function Signature: ```python def has_duplicate_sessions(sessions: list) -> bool: ``` # Input: - `sessions`: a list of tuples, where each tuple contains `(user_id: int, timestamp: int)`. # Output: - Return `True` if there is any user who has more than one session at the same timestamp on the same day, otherwise return `False`. # Constraints: - The list `sessions` can contain up to 10^6 entries. - `user_id` will be a non-negative integer. - `timestamp` will be a non-negative integer less than 86400 (number of seconds in a day). # Example: ```python >>> sessions = [(1, 3600), (2, 7200), (1, 3600)] >>> has_duplicate_sessions(sessions) True >>> sessions = [(1, 3600), (2, 7200), (1, 3700)] >>> has_duplicate_sessions(sessions) False ``` # Requirements: - Iterate through the list of sessions and determine if there are any duplicate sessions based on `user_id` and `timestamp`. - Ensure that your function works efficiently with the maximum input size. Notes: - Utilize appropriate data structures to achieve efficient lookup and comparison. - The input and output formats should match the examples.","solution":"def has_duplicate_sessions(sessions): Check if there are duplicate session entries for any user at the same timestamp. Args: sessions (list of tuples): A list of tuples where each tuple contains (user_id: int, timestamp: int). Returns: bool: True if there are duplicate sessions for any user, False otherwise. session_set = set() for user_id, timestamp in sessions: if (user_id, timestamp) in session_set: return True session_set.add((user_id, timestamp)) return False"},{"question":"**Problem:** Equilibrium Index Finder You are given the following problem to solve using Python: An equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. For example, given array `A`, index `i` is an equilibrium index if [ sum_{j=0}^{i-1} A[j] = sum_{j=i+1}^{n-1} A[j] ] where ( n ) is the length of the array ( A ). **Task**: Write a function `find_equilibrium_index(arr: List[int]) -> int` that returns the first (leftmost) equilibrium index found in the list. If no such index exists, return `-1`. **Input/Output Format**: - **Input**: A list of integers `arr` representing the array. - **Output**: An integer representing the equilibrium index. If no such index exists, return `-1`. **Constraints**: 1. The length of the array ( n ) will be in the range ( 1 leq n leq 10^5 ). 2. Each element of the array will be in the range (-10^4 leq text{arr}[i] leq 10^4). 3. If the array contains only one element, it is the equilibrium index. You must ensure your solution is efficient in terms of time complexity. **Function Signature**: ```python def find_equilibrium_index(arr: List[int]) -> int: pass ``` **Example**: ``` >>> find_equilibrium_index([1, 3, 5, 2, 2]) 2 # Explanation: The first equilibrium index is at position 2 where sum of elements before it (1+3) = sum of elements after it (2+2). ``` ``` >>> find_equilibrium_index([1, 2, 3]) -1 # Explanation: No equilibrium index exists. ``` **Hints**: - Consider computing the total sum of the array first. - Use a single pass through the array to find the equilibrium index efficiently.","solution":"from typing import List def find_equilibrium_index(arr: List[int]) -> int: total_sum = sum(arr) left_sum = 0 for i, value in enumerate(arr): total_sum -= value if left_sum == total_sum: return i left_sum += value return -1"},{"question":"# Coding Assessment Question **Context**: Efficient data retrieval and manipulation are key tasks in many software applications. A common problem involves searching for the longest subarray within an array that satisfies a specific condition. **Question**: Implement a function `longest_subarray_with_sum(nums: List[int], target_sum: int) -> int` that finds the length of the longest subarray where the sum of the elements is equal to the given `target_sum`. **Function Signature**: ```python def longest_subarray_with_sum(nums: List[int], target_sum: int) -> int: ``` **Input**: * `nums` (List[int]): A list of integers. * `target_sum` (int): The target sum for the subarray. **Output**: * An integer representing the length of the longest subarray that sums to `target_sum`. If no such subarray exists, return `0`. **Constraints**: * The input list `nums` can contain any integers and can have a length up to 10,000 elements. * The solution should operate efficiently on large input sizes. **Performance Requirements**: * Aim for a solution with time complexity O(n), where n is the number of elements in the input list. * Minimize the use of additional space; aim for O(n) auxiliary space at most. **Examples**: 1. `longest_subarray_with_sum([1, -1, 5, -2, 3], 3) -> 4` (Subarray [1, -1, 5, -2] sums to 3) 2. `longest_subarray_with_sum([-2, -1, 2, 1], 1) -> 2` (Subarray [-1, 2] sums to 1) 3. `longest_subarray_with_sum([1, 2, 3, 4, 5], 15) -> 5` (Entire array sums to 15) 4. `longest_subarray_with_sum([1, 2, 3, 4, 5], 20) -> 0` (No subarray sums to 20) 5. `longest_subarray_with_sum([], 0) -> 0` (Empty array has no subarray) **Notes**: * Consider edge cases such as an empty array or when the target sum is not present in any subarray. * The function should handle cases with negative numbers and different sum scenarios. * Ensure the function is robust and produces correct results for varied input sizes and arrays containing mixed positive and negative integers.","solution":"from typing import List def longest_subarray_with_sum(nums: List[int], target_sum: int) -> int: sum_indices = {} current_sum = 0 longest_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target_sum: longest_length = i + 1 if (current_sum - target_sum) in sum_indices: subarray_length = i - sum_indices[current_sum - target_sum] longest_length = max(longest_length, subarray_length) if current_sum not in sum_indices: sum_indices[current_sum] = i return longest_length"},{"question":"# Student Marks Analysis with Different Evaluation Models You are tasked with implementing evaluation algorithms to analyze student marks using various models: average calculation, weighted average calculation, and standard deviation calculation. The provided functions must handle various input scenarios and edge cases effectively. Requirements 1. **Average Marks Calculation**: - Implement the `average_marks` function, which calculates the average marks for a given list of student marks. - Ensure error handling for invalid inputs, such as an empty list or negative marks. 2. **Weighted Average Marks Calculation**: - Implement the `weighted_average_marks` function, which calculates the weighted average marks based on the marks and their corresponding weights. - Handle cases where the inputs are invalid, such as mismatched lengths of marks and weights or non-positive weights. 3. **Standard Deviation Calculation**: - Implement the `standard_deviation` function, which calculates the standard deviation of a given list of student marks. - Ensure accurate computation and proper handling of edge cases, such as an empty list or a single mark. Function Signatures ```python def average_marks(marks: list[float]) -> float: pass def weighted_average_marks(marks: list[float], weights: list[float]) -> float: pass def standard_deviation(marks: list[float]) -> float: pass ``` Input and Output Formats - **Average Marks**: - **Input**: `marks` (list of floats) - **Output**: `float` representing the calculated average marks - **Weighted Average Marks**: - **Input**: `marks` (list of floats), `weights` (list of floats) - **Output**: `float` representing the calculated weighted average marks - **Standard Deviation**: - **Input**: `marks` (list of floats) - **Output**: `float` representing the calculated standard deviation Constraints - Marks and weights must be non-negative values, and lists should not be empty. If invalid inputs are provided, raise a ValueError with a relevant message. - The lengths of marks and weights lists must match for the weighted average calculation. - The calculations should maintain precision and handle large input sizes efficiently. Performance Requirements All operations are expected to be performed in linear time O(n), where n is the number of elements in the input list. Example Usage ```python print(average_marks([85, 90, 78, 92])) # Output: ~86.25 print(weighted_average_marks([85, 90, 78], [0.3, 0.4, 0.3])) # Output: ~84.9 print(standard_deviation([85, 90, 78, 92])) # Output: ~5.63 ``` Implement the given functions based on these details while adhering to the input-output formats, constraints, and performance requirements.","solution":"from math import sqrt def average_marks(marks: list[float]) -> float: Calculate the average of a list of marks. :param marks: list of float, the marks to calculate the average of. :return: float, the average of the marks. if not marks: raise ValueError(\\"Marks list should not be empty.\\") if any(mark < 0 for mark in marks): raise ValueError(\\"Marks should be non-negative.\\") return sum(marks) / len(marks) def weighted_average_marks(marks: list[float], weights: list[float]) -> float: Calculate the weighted average of a list of marks with corresponding weights. :param marks: list of float, the marks. :param weights: list of float, the weights of each mark. :return: float, the weighted average. if len(marks) != len(weights): raise ValueError(\\"Marks and weights must be the same length.\\") if not marks: raise ValueError(\\"Marks list should not be empty.\\") if any(mark < 0 for mark in marks): raise ValueError(\\"Marks should be non-negative.\\") if any(weight <= 0 for weight in weights): raise ValueError(\\"Weights should be positive.\\") total_weight = sum(weights) weighted_sum = sum(mark * weight for mark, weight in zip(marks, weights)) return weighted_sum / total_weight def standard_deviation(marks: list[float]) -> float: Calculate the standard deviation of a list of marks. :param marks: list of float, the marks. :return: float, the standard deviation of the marks. if not marks: raise ValueError(\\"Marks list should not be empty.\\") if any(mark < 0 for mark in marks): raise ValueError(\\"Marks should be non-negative.\\") mean = average_marks(marks) variance = sum((mark - mean) ** 2 for mark in marks) / len(marks) return sqrt(variance)"},{"question":"# Problem Statement You are given a list of strings and you need to write a function to return all the unique permutations of the given list. # Specifications * **Function Signature**: `def unique_permutations(lst: List[str]) -> List[List[str]]:` * **Input**: A list of strings `lst`. * **Output**: A list of lists, where each inner list is a unique permutation of the input list. # Constraints * The input list will have at most 8 strings. * Each string in the list will have at most 10 characters. # Example ```python from typing import List def unique_permutations(lst: List[str]) -> List[List[str]]: from itertools import permutations perms = set(permutations(lst)) return [list(p) for p in perms] # Example Usage: lst1 = [\\"a\\", \\"b\\", \\"c\\"] print(unique_permutations(lst1)) # Output could be (order of permutations may vary): # [[\'a\', \'b\', \'c\'], [\'a\', \'c\', \'b\'], [\'b\', \'a\', \'c\'], # [\'b\', \'c\', \'a\'], [\'c\', \'a\', \'b\'], [\'c\', \'b\', \'a\']] lst2 = [\\"a\\", \\"a\\", \\"b\\"] print(unique_permutations(lst2)) # Output could be (order of permutations may vary): # [[\'a\', \'a\', \'b\'], [\'a\', \'b\', \'a\'], [\'b\', \'a\', \'a\']] ``` # Notes * The order of permutations in the output does not matter. * Duplicate values in the input list should result in only unique permutations being included in the output. * The solution should efficiently handle the constraints and generate permutations without redundancy.","solution":"from typing import List from itertools import permutations def unique_permutations(lst: List[str]) -> List[List[str]]: Returns all unique permutations of the given list of strings. perms = set(permutations(lst)) return [list(p) for p in perms]"},{"question":"# Question: Dynamic Inventory Management System You are required to implement a dynamic inventory management system for a small retail store. This system should be able to keep track of the inventory of items and provide functionalities to add, remove, update, and view items in the inventory. Each item in the inventory is identified by a unique item code. Requirements: 1. **Inventory Storage**: Maintain the inventory using a dictionary where the keys are item codes and the values are dictionaries containing item attributes (`name`, `quantity`, and `price`). 2. **Item Addition**: Add a new item to the inventory. If the item already exists, update its details. 3. **Item Removal**: Remove an item from the inventory using its item code. 4. **Item Update**: Update the quantity or price of an existing item. 5. **Inventory Viewing**: Provide a summary of the entire inventory. Input/Output: - `add_item(inventory: dict, item_code: str, name: str, quantity: int, price: float) -> dict` - `remove_item(inventory: dict, item_code: str) -> dict` - `update_item(inventory: dict, item_code: str, quantity: int = None, price: float = None) -> dict` - `view_inventory(inventory: dict) -> str` Example: ```python # Initial empty inventory inventory = {} inventory = add_item(inventory, \\"A101\\", \\"Apple\\", 10, 0.50) # Inventory: {\'A101\': {\'name\': \'Apple\', \'quantity\': 10, \'price\': 0.50}} inventory = add_item(inventory, \\"B202\\", \\"Banana\\", 20, 0.30) # Inventory: {\'A101\': {\'name\': \'Apple\', \'quantity\': 10, \'price\': 0.50}, \'B202\': {\'name\': \'Banana\', \'quantity\': 20, \'price\': 0.30}} inventory = update_item(inventory, \\"A101\\", quantity=15) # Inventory: {\'A101\': {\'name\': \'Apple\', \'quantity\': 15, \'price\': 0.50}, \'B202\': {\'name\': \'Banana\', \'quantity\': 20, \'price\': 0.30}} inventory = remove_item(inventory, \\"B202\\") # Inventory: {\'A101\': {\'name\': \'Apple\', \'quantity\': 15, \'price\': 0.50}} inventory_summary = view_inventory(inventory) # Output: # Item Code: A101, Name: Apple, Quantity: 15, Price: 0.50 ``` # Implementation: Define the following four functions to complete this task: 1. `add_item(inventory: dict, item_code: str, name: str, quantity: int, price: float) -> dict` 2. `remove_item(inventory: dict, item_code: str) -> dict` 3. `update_item(inventory: dict, item_code: str, quantity: int = None, price: float = None) -> dict` 4. `view_inventory(inventory: dict) -> str` Function Specs: 1. `add_item`: - Args: `inventory` (dict), `item_code` (str), `name` (str), `quantity` (int), `price` (float). - Returns: updated `inventory` (dict). - Functionality: Add or update an item in the inventory. 2. `remove_item`: - Args: `inventory` (dict), `item_code` (str). - Returns: updated `inventory` (dict). - Functionality: Remove an item from the inventory. 3. `update_item`: - Args: `inventory` (dict), `item_code` (str), `quantity` (int, optional), `price` (float, optional). - Returns: updated `inventory` (dict). - Functionality: Update the quantity and/or price of an existing item. 4. `view_inventory`: - Args: `inventory` (dict). - Returns: `inventory_summary` (str). - Functionality: Provide a string summary of the entire inventory in the specified format.","solution":"def add_item(inventory, item_code, name, quantity, price): Adds a new item to the inventory or updates the item if it already exists. Args: - inventory (dict): The current inventory. - item_code (str): Unique identifier for the item. - name (str): Name of the item. - quantity (int): Quantity of the item. - price (float): Price of the item. Returns: - dict: Updated inventory. inventory[item_code] = {\'name\': name, \'quantity\': quantity, \'price\': price} return inventory def remove_item(inventory, item_code): Removes an item from the inventory. Args: - inventory (dict): The current inventory. - item_code (str): Unique identifier for the item. Returns: - dict: Updated inventory. if item_code in inventory: del inventory[item_code] return inventory def update_item(inventory, item_code, quantity=None, price=None): Updates the quantity or price of an existing item in the inventory. Args: - inventory (dict): The current inventory. - item_code (str): Unique identifier for the item. - quantity (int, optional): New quantity of the item. - price (float, optional): New price of the item. Returns: - dict: Updated inventory. if item_code in inventory: if quantity is not None: inventory[item_code][\'quantity\'] = quantity if price is not None: inventory[item_code][\'price\'] = price return inventory def view_inventory(inventory): Provides a summary of the inventory. Args: - inventory (dict): The current inventory. Returns: - str: Summary of the inventory. summary = [] for item_code, details in inventory.items(): item_summary = f\\"Item Code: {item_code}, Name: {details[\'name\']}, Quantity: {details[\'quantity\']}, Price: {details[\'price\']:.2f}\\" summary.append(item_summary) return \\"n\\".join(summary)"},{"question":"# Problem Statement Implement a function that finds the longest path in a matrix where each path starts at a cell containing a specific value and can move to an adjacent cell if it contains the next integer value (step size of 1). The path should only move horizontally, vertically, or diagonally. # Input * A 2D list of integers where each element can be any integer (represented as `matrix`). - `matrix`: A list of lists of integers `list[list[int]]` * Dimensions of the matrix: - `ROW`: Number of rows `int` - `COL`: Number of columns `int` * Starting value for the path: - `start_val`: Integer value `int` # Output * An integer representing the length of the longest path starting from `start_val` and moving to adjacent cells containing the next integer value. # Function Signature ```python def longest_path(ROW: int, COL: int, matrix: list[list[int]], start_val: int) -> int: pass ``` # Constraints * `0 <= ROW, COL <= 1000` * `-10^6 <= matrix[i][j], start_val <= 10^6` # Example ```python matrix = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] ROW = 3 COL = 3 start_val = 1 # Expected output: 9 ``` # Notes * Ensure to consider all 8 possible movements (horizontally, vertically, and diagonally) from a cell. * The solution should have efficient time complexity relative to the constraints provided. * Properly handle edge cases such as a matrix with no cells containing `start_val`.","solution":"def longest_path(ROW: int, COL: int, matrix: list[list[int]], start_val: int) -> int: def dfs(r, c): if dp[r][c] != -1: return dp[r][c] max_path = 1 # Each cell is a path of length 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < ROW and 0 <= nc < COL and matrix[nr][nc] == matrix[r][c] + 1: max_path = max(max_path, 1 + dfs(nr, nc)) dp[r][c] = max_path return max_path directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # 8 possible directions dp = [[-1 for _ in range(COL)] for _ in range(ROW)] longest = 0 for r in range(ROW): for c in range(COL): if matrix[r][c] == start_val: longest = max(longest, dfs(r, c)) return longest"},{"question":"# Problem Statement You have been provided with a class `DigitCounter` that is used for counting the frequency of each digit (0-9) in a given string representing a large number. Your task is to extend the functionality of this class by adding a new method `most_frequent_digit` which returns the digit(s) that occurs the most frequently in the given string. If there are multiple digits with the same maximum frequency, the method should return a list of these digits in ascending order. # Function Signature ```python class DigitCounter: ... def most_frequent_digit(self) -> List[int]: This method should return a list containing the digit(s) with the highest frequency. ``` # Input & Output - **Input**: - No input parameters are required for the method. Use the internal state of the string representing the large number. - **Output**: - The method should return a list of integer(s) representing the digit(s) with the highest frequency in ascending order. # Examples 1. **Example 1**: ```python dc = DigitCounter(\'123123456654\') print(dc.most_frequent_digit()) ``` **Output**: ``` [1, 2, 3, 4, 5, 6] ``` 2. **Example 2**: ```python dc = DigitCounter(\'987665432220\') print(dc.most_frequent_digit()) ``` **Output**: ``` [2] ``` 3. **Example 3**: ```python dc = DigitCounter(\'1112234567890\') print(dc.most_frequent_digit()) ``` **Output**: ``` [1] ``` # Constraints - The input string will only contain digits (0-9). - The length of the input string will not exceed 100,000 characters. # Notes - In case multiple digits have the same frequency, the output should be a list of those digits sorted in ascending order. Implement the `most_frequent_digit` method in the `DigitCounter` class.","solution":"from typing import List from collections import Counter class DigitCounter: def __init__(self, large_number: str): self.large_number = large_number self.digit_counts = Counter(large_number) def most_frequent_digit(self) -> List[int]: if not self.large_number: return [] max_frequency = max(self.digit_counts.values()) most_frequent_digits = [int(digit) for digit, count in self.digit_counts.items() if count == max_frequency] return sorted(most_frequent_digits)"},{"question":"# Largest Common Subarray Challenge Context In computer science, finding common subarrays in sequences of data is a common problem that can be applied in various fields, including bioinformatics, text processing, and data compression. The longest common subarray and its length help determine the degree of similarity between two sequences. Problem Statement You are given two one-dimensional integer arrays. Your task is to write a function `find_largest_common_subarray` that takes these two arrays and returns the length of the longest subarray (continuous subset) that appears in both arrays. Function Signature ```python def find_largest_common_subarray(arr1: list[int], arr2: list[int]) -> int: pass ``` Parameters - `arr1`: A list of integers representing the first array. - `arr2`: A list of integers representing the second array. Constraints - Both arrays can have lengths ranging from 1 to 3000. - Values in the arrays can range from -1000 to 1000. Expected Output - The function should return an integer representing the length of the longest common subarray in both input arrays. Example ```python >>> find_largest_common_subarray([1, 2, 3, 2, 1], [3, 2, 1, 4, 5]) 3 >>> find_largest_common_subarray([0, 1, 1, 1], [1, 1, 0, 1]) 2 ``` Performance Requirements - Your implementation should handle the maximum input size efficiently within reasonable time and space limits. Notes - The subarray must be contiguous (continuous subset). - Optimize for accuracy and performance where possible. - Consider using dynamic programming or efficient search techniques to improve performance.","solution":"def find_largest_common_subarray(arr1, arr2): Returns the length of the longest contiguous subarray that appears in both arr1 and arr2. m, n = len(arr1), len(arr2) dp = [[0] * (n + 1) for _ in range(m + 1)] max_len = 0 for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"Question: Evaluating Conversion Sequences in Dictionaries Context: You are working on a linguistics project involving word transformations. Words are being transformed using specific rules that dictate how letters can be replaced. These rules can be represented as a directed graph where nodes are words and edges represent valid one-letter transformations from one word to another. Your task is to determine the shortest sequence of transformations needed to change one word into another using these rules. Task: Using breadth-first search (BFS), implement the function `word_ladder(begin_word, end_word, word_list)` that calculates the minimum number of transformations required to convert `begin_word` to `end_word`. Each transformation must involve changing exactly one letter at a time, and each intermediate word must be in the provided word list. Function Signature: ```python def word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> int: pass ``` Input: - `begin_word`: A string representing the initial word. - `end_word`: A string representing the target word. - `word_list`: A list of strings representing the valid intermediate words. Output: - An integer representing the number of transformations required to convert `begin_word` to `end_word`. If no such transformation sequence exists, return `0`. Constraints: - All words have the same length. - All words consist of lowercase English letters. - The number of words in the list does not exceed `5000`. - No word appears more than once in the word list. Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert word_ladder(begin_word, end_word, word_list) == 5 # Explanation: \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\" (5 steps) begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert word_ladder(begin_word, end_word, word_list) == 0 # Explanation: No sequence of transformations exists that transforms \\"hit\\" to \\"cog\\". ``` Notes: - Use a queue to implement the breadth-first search algorithm. - Consider using a set for `word_list` to efficiently check if a word exists in the list. - Handle edge cases gracefully, such as when the `begin_word` is the same as the `end_word`. By creating a problem around a linguistics transformation task, this question complements the algorithmic and graph-based problems seen in the previous context, challenging problem-solving and implementation skills similarly in a different yet related scenario.","solution":"from collections import deque from typing import List def word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> int: word_set = set(word_list) if end_word not in word_set: return 0 queue = deque([(begin_word, 1)]) # (current_word, current_depth) visited = set([begin_word]) while queue: current_word, level = queue.popleft() if current_word == end_word: return level for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set and next_word not in visited: visited.add(next_word) queue.append((next_word, level + 1)) return 0"},{"question":"# Context You are given an array of integers and an integer target. Your task is to determine if there are two distinct elements in the array that sum up to the target value. # Function Signature Write a function called `two_sum` that takes in a list of integers and a single integer value as its target and returns a boolean value indicating whether there are two different elements in the list that add up to the target. # Input * A list of integers ( nums ) and a single integer ( target ). - ( 0 leq |nums| leq 10^5 ) - ( -10^9 leq nums[i], target leq 10^9 ) # Output * Returns `True` if there are two distinct elements in the array that sum to the target, otherwise returns `False`. # Constraints 1. Elements in the array can be positive, negative, or zero. 2. The solution should have a time complexity of ( O(n) ). 3. Elements in the list can repeat. # Examples * `two_sum([2, 7, 11, 15], 9)` should return `True` because 2 + 7 = 9. * `two_sum([1, 2, 3, 4], 8)` should return `False` because no two elements sum up to 8. * `two_sum([3, 3], 6)` should return `True` because 3 + 3 = 6. * `two_sum([-1, -2, -3, -4, -5], -8)` should return `True` because -3 + -5 = -8. # Implementation Make sure to consider edge cases such as when the array has fewer than two elements or when the elements are all the same.","solution":"def two_sum(nums, target): Determines if there are two distinct elements in nums that sum to target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are two distinct elements that sum to target, False otherwise. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"**Question:** You are designing a simple command-line utility to iterate through a list of tasks and mark them as complete. Each task has a unique identifier and a status indicating whether it is complete. You need to implement utilities in a task manager that can: 1. Add a new task with a unique identifier. 2. Complete a task by its identifier. 3. Get a report of all tasks, displaying their identifiers and statuses. # Task: Implement a `TaskManager` class with the following method signatures: - `add_task(task_id: int) -> None`: Adds a new task with the provided `task_id`. Initially, the status of the task is set to incomplete (False). - `complete_task(task_id: int) -> None`: Marks the task with the provided `task_id` as complete (True). - `get_report() -> List[Tuple[int, bool]]`: Returns a list of tuples, each containing a task identifier and its completion status. # Constraints: - Task identifiers are unique integers. - Methods that modify the task list should ensure no duplicate task identifiers are added. - The system should handle invalid task identifier inputs gracefully during completion (e.g., trying to complete a non-existent task should not raise an error but may log a warning). - Tasks can only be marked as complete; once complete, they cannot be marked as incomplete again. # Example Usage: ```python if __name__ == \\"__main__\\": task_mgr = TaskManager() task_mgr.add_task(1) task_mgr.add_task(2) task_mgr.complete_task(1) print(task_mgr.get_report()) # Expected output: [(1, True), (2, False)] ``` # Implementation: Create the `TaskManager` class with the specified methods to manage and report the tasks. ```python class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id: int) -> None: if task_id not in self.tasks: self.tasks[task_id] = False def complete_task(self, task_id: int) -> None: if task_id in self.tasks: self.tasks[task_id] = True def get_report(self) -> List[Tuple[int, bool]]: return [(task_id, status) for task_id, status in self.tasks.items()] if __name__ == \\"__main__\\": task_mgr = TaskManager() task_mgr.add_task(1) task_mgr.add_task(2) task_mgr.complete_task(1) print(task_mgr.get_report()) # Expected output: [(1, True), (2, False)] ``` This class will allow you to manage a list of tasks, mark them as complete, and generate a report of their statuses. Ensure the examples are run in a suitable environment where the code above is executed as expected.","solution":"from typing import List, Tuple class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_id: int) -> None: if task_id not in self.tasks: self.tasks[task_id] = False def complete_task(self, task_id: int) -> None: if task_id in self.tasks: self.tasks[task_id] = True def get_report(self) -> List[Tuple[int, bool]]: return [(task_id, status) for task_id, status in self.tasks.items()]"},{"question":"# Task You are given an NxM grid that represents a binary matrix, where each cell contains either 0 or 1. The grid is guaranteed to have at least one cell containing 1. Your task is to find the largest square that can be formed only by cells containing 1s and return its area. # Requirements 1. **Function**: Implement a function `maximal_square_area(grid: List[List[int]]) -> int` that computes the largest square of 1s in the given binary matrix and returns its area. 2. **Input**: A 2D list `grid` of integers with dimensions NxM, where each element is either 0 or 1. 3. **Output**: An integer representing the area of the largest square containing only 1s. 4. **Constraints**: * (1 leq N, M leq 300) * Each element in the grid is either 0 or 1. * There is at least one cell with value 1 in the grid. # Example ```python from typing import List def maximal_square_area(grid: List[List[int]]) -> int: # Your implementation here # Test cases grid1 = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] print(maximal_square_area(grid1)) # Output: 4 grid2 = [ [0, 1], [1, 1] ] print(maximal_square_area(grid2)) # Output: 1 grid3 = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] print(maximal_square_area(grid3)) # Output: 9 ``` # Explanation - The function should iterate through each cell in the grid. - For each cell that contains a 1, determine the size of the largest square that can be formed with that cell as the bottom-right corner. - Use dynamic programming to track the largest squares ending at each cell, thus avoiding redundant computations. - Eventually, return the area of the largest square found in the entire grid.","solution":"from typing import List def maximal_square_area(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) max_side = 0 # Create a DP table with the same size as grid, initialized to 0 dp = [[0] * m for _ in range(n)] # Iterate through the grid to fill the DP table for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # Edge cells can only be 1 if they are 1 in grid else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) # The area of the largest square is the side length squared return max_side * max_side"},{"question":"# Problem Statement You are given a set of 2D points representing a polygon and a target point. Your task is to implement a function that determines whether the target point is inside the given polygon. # Function Signature ```python def is_point_inside_polygon(polygon_points: list[tuple[float, float]], target_point: tuple[float, float]) -> bool: pass ``` # Input - `polygon_points`: a list of tuples representing the vertices of a polygon in the 2D plane. The vertices are given in counterclockwise order, forming a simple polygon (no holes or self-intersections). The list will contain at least three points. - `target_point`: a tuple `(x, y)` representing the coordinates of the point to check. # Output - Returns a boolean value `True` if the `target_point` is inside the polygon, `False` otherwise. # Constraints - All coordinates are floating-point numbers. - The number of points in `polygon_points` will be between 3 and 100 inclusive. # Example ```python polygon_points = [(0, 0), (4, 0), (4, 4), (0, 4)] target_point = (2, 2) print(is_point_inside_polygon(polygon_points, target_point)) # Expected Output: True target_point = (5, 5) print(is_point_inside_polygon(polygon_points, target_point)) # Expected Output: False ``` # Notes - Consider using the ray-casting algorithm or the winding number algorithm to determine whether the point is inside the polygon. - Ensure that the function handles edge cases such as points lying exactly on the boundary of the polygon. - Floating-point precision should be handled carefully to avoid inaccuracies during computation. # Guidelines - Implement helper functions if needed to break down the problem for modular design. - Test your function with various shapes and locations of the `target_point` for comprehensive validation. - Ensure optimized performance to handle the maximum constraint efficiently.","solution":"def is_point_inside_polygon(polygon_points, target_point): Determines if a point is inside a polygon using the ray-casting algorithm. x, y = target_point n = len(polygon_points) inside = False p1x, p1y = polygon_points[0] for i in range(n + 1): p2x, p2y = polygon_points[i % n] if y > min(p1y, p2y): if y <= max(p1y, p2y): if x <= max(p1x, p2x): if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x if p1x == p2x or x <= xinters: inside = not inside p1x, p1y = p2x, p2y return inside"},{"question":"# **Binary Search Optimization with Constraints** You are given a sorted array of integers and a target number. Your task is to implement an optimized binary search function that not only finds whether the target number exists in the array but also counts the number of occurrences of the target number. # Task 1. **Count Target Occurrences**: Modify the binary search algorithm such that it counts the total occurrences of the target number in the sorted array. 2. **Optimize for Performance**: Ensure the efficiency of the function by leveraging the binary search approach rather than a linear scan. # Function Signature Implement the function using the signature below: ```python def count_occurrences(arr: list[int], target: int) -> int: pass ``` # Input - **arr**: List of integers sorted in non-decreasing order. - **target**: Integer, the number to search for and count in the array. # Output - Return an integer representing the number of occurrences of the target number in the array. # Constraints - The length of `arr` will be between `1` and `10^5`. - Each element in `arr` and the `target` will be an integer within the range `-10^9` to `10^9`. # Examples ```python # Example 1: arr = [1, 2, 2, 2, 3, 4, 5] target = 2 # Expected Output: 3 print(count_occurrences(arr, target)) # Example 2: arr = [1, 1, 1, 2, 2, 3, 3, 3, 3, 4] target = 3 # Expected Output: 4 print(count_occurrences(arr, target)) # Example 3: arr = [1, 3, 5, 7, 9] target = 4 # Expected Output: 0 print(count_occurrences(arr, target)) ``` # Notes - Consider edge cases such as when the array is empty or when the target is not present in the array. - Utilize `bisect` module from Python\'s standard library to help with locating the boundaries of the target number efficiently.","solution":"from bisect import bisect_left, bisect_right def count_occurrences(arr: list[int], target: int) -> int: Count the number of occurrences of target in the sorted array arr. Parameters: arr (list[int]): A sorted list of integers. target (int): The target integer to count in the list. Returns: int: The count of target occurrences in arr. # Find the index of the first occurrence of target left_index = bisect_left(arr, target) # If target is not present, return 0 if left_index == len(arr) or arr[left_index] != target: return 0 # Find the index of the first occurrence of a number greater than target right_index = bisect_right(arr, target) # The count of target is the difference between right_index and left_index return right_index - left_index"},{"question":"# String Pattern Matching in Rotated Strings Your task is to implement a function `is_rotated_substring` that determines if one string is a substring of any rotation of another string. A rotation of a string can be obtained by moving any number of characters from the beginning of the string to the end. The function should: 1. Take two input strings: `s1` and `s2`. 2. Return `True` if `s2` is a substring of any rotation of `s1`, otherwise return `False`. **Function Signature**: ```python def is_rotated_substring(s1: str, s2: str) -> bool: pass ``` # Example: ```python # Example 1 s1 = \\"waterbottle\\" s2 = \\"erbottlewat\\" # \'erbottlewat\' is a rotation of \'waterbottle\', so it should return True assert is_rotated_substring(s1, s2) == True # Example 2 s1 = \\"hello\\" s2 = \\"ole\\" # No rotation of \'hello\' contains \'ole\' as a substring, so it should return False assert is_rotated_substring(s1, s2) == False # Example 3 s1 = \\"abcde\\" s2 = \\"cdeab\\" # \'cdeab\' is a rotation of \'abcde\', so it should return True assert is_rotated_substring(s1, s2) == True ``` # Constraints: 1. The length of `s1` and `s2` will be between 1 and 1000. 2. Both strings will contain only lowercase English letters. # Performance: Ensure that your implementation adheres to O(N) complexity in terms of the length of the strings involved.","solution":"def is_rotated_substring(s1: str, s2: str) -> bool: Determines if s2 is a substring of any rotation of s1. if len(s1) < len(s2): return False # Concatenating s1 with itself covers all possible rotations s1s1 = s1 + s1 return s2 in s1s1"},{"question":"# Coding Question: Implement a Palindrome Permutation Checker **Objective**: Write a Python function that checks if any permutation of a given string can form a palindrome. To achieve this, your function should: 1. Count the frequency of each character in the input string. 2. Determine if the characters can be rearranged to form a palindrome. 3. Return `True` if a palindrome permutation exists, otherwise return `False`. **Function Signature**: ```python def can_form_palindrome(s: str) -> bool: pass ``` **Input**: - `s` (str): A string to check for palindrome permutations. **Output**: - `bool`: `True` if any permutation of the string can form a palindrome, otherwise `False`. **Constraints**: - The string `s` will contain only lowercase alphabets [a-z]. - The length of the string `s` will not exceed 1000 characters. **Performance Requirements**: - The function should run efficiently even for the maximum input size. - Use appropriate data structures to ensure optimal time and space complexity. **Example**: ```python result = can_form_palindrome(\\"carrace\\") print(result) # Should print True, since \\"carrace\\" can be rearranged to \\"racecar\\" which is a palindrome result = can_form_palindrome(\\"hello\\") print(result) # Should print False, since there is no permutation of \\"hello\\" that can form a palindrome ``` **Additional Notes**: - A string can be permuted to form a palindrome if at most one character has an odd frequency. - Utilize collections.Counter or a similar efficient method to count character frequencies. **Testing**: - Test with strings of various lengths and character compositions. - Consider edge cases such as empty strings and strings with all identical characters.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Count the frequency of each character char_count = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"# Shortest Path in a Weighted Graph You are developing a navigation application that finds the shortest route between locations on a map. The application represents the map as a weighted graph, where nodes correspond to locations and edges correspond to the travel distances between them. Your task is to implement an algorithm to determine the shortest path between two given locations. Objective: Implement Dijkstra\'s algorithm to compute the shortest path from a given starting node to a target node in a weighted graph. Requirements: 1. Implement the function `shortest_path` that takes in an adjacency list representation of a graph, a starting node, and a target node, and returns a list of nodes representing the shortest path. 2. Ensure the function handles sparse and dense graphs efficiently with a time complexity of O((V + E) log V). 3. Consider edge cases such as disconnected graphs or when the target node is unreachable from the starting node. 4. Include comprehensive test cases demonstrating functionality, particularly focusing on graphs of varying sizes and complexities. Input: * An adjacency list `graph`, where `graph[node]` is a list of tuples `(neighbor, weight)` representing the neighbors of the node and the edge weights. * An integer representing the `start_node`. * An integer representing the `target_node`. Output: * A list of integers representing the shortest path from `start_node` to `target_node`. Return an empty list if no such path exists. Constraints: * `1 <= len(graph) <= 10000` * Each node is an integer between `0` and `len(graph) - 1`. * The weights are positive integers. Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } print(shortest_path(graph, 0, 3)) # Output: [0, 2, 1, 3] print(shortest_path(graph, 0, 1)) # Output: [0, 2, 1] print(shortest_path(graph, 1, 0)) # Output: [] ``` Note: * Use a priority queue (min-heap) to efficiently retrieve the smallest distance node. * Include comments explaining critical parts of your code. * Ensure your implementation checks for cases where the start node is the same as the target node and handles it appropriately.","solution":"import heapq def shortest_path(graph, start_node, target_node): Implements Dijkstra\'s algorithm to find the shortest path from start_node to target_node in a weighted graph represented as an adjacency list. if start_node == target_node: return [start_node] # Priority queue to store (distance, node) and dictionary for distances pq = [(0, start_node)] distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Dictionary to store the path previous_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target_node: path = [] while current_node is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] return path if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) return []"},{"question":"# Question: Implement a Balanced Binary Search Tree with In-Order Traversal You are provided with a simple implementation of a binary search tree (BST). Your task is to enhance it by ensuring that the tree remains balanced after inserting each element. Also, you need to implement an in-order traversal to return the elements in ascending order. Objective Create a balanced binary search tree and implement its in-order traversal properly. Expected Input and Output * **Input**: A list of integers. ```python [int, int, ..., int] ``` * **Output**: A list of integers sorted in ascending order using the in-order traversal of the balanced BST. ```python [int, int, ..., int] ``` Constraints * The input list will contain at most 50,000 elements. * Each integer in the list will fit within the 32-bit signed integer range: [−2³¹, 2³¹ − 1]. Performance Requirements * Time complexity for insertions: O(log n) for each insertion if the tree remains balanced * Space complexity: O(n) Scenario Imagine you are working on a feature for a large-scale data analytics application where you need to manage and analyze sorted data efficiently. Ensuring the BST remains balanced is crucial for optimal performance during insertions and lookups. # Your Task: Write a Python class `BalancedBST` that implements a balanced binary search tree with an in-order traversal method. ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class BalancedBST: def __init__(self): self.root = None def insert(self, key): Insert a key into the BST and balance the tree. # Implement your insertion and balancing logic here pass def in_order_traversal(self): Perform in-order traversal and return the sorted list. # Implement your in-order traversal logic here pass # You may add any helper methods if needed # Example usage bst = BalancedBST() elements = [3, 1, 4, 1, 5, 9, 2, 6] for elem in elements: bst.insert(elem) print(bst.in_order_traversal()) # Output should be [1, 1, 2, 3, 4, 5, 6, 9] ``` **Note**: Do not use any external libraries or built-in functions that directly provide BST or balancing capabilities. Focus on implementing the principles of a balanced BST yourself, such as AVL tree rotations or any similar mechanism. **Example**: ```python >>> bst = BalancedBST() >>> bst.insert(3) >>> bst.insert(1) >>> bst.insert(4) >>> bst.insert(1) >>> bst.insert(5) >>> bst.insert(9) >>> bst.insert(2) >>> bst.insert(6) >>> bst.in_order_traversal() [1, 1, 2, 3, 4, 5, 6, 9] ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class BalancedBST: def __init__(self): self.root = None def insert(self, key): Insert a key into the BST and balance the tree. self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traversal(self): Perform in-order traversal and return the sorted list. res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, node, res): if not node: return self._in_order_traversal(node.left, res) res.append(node.key) self._in_order_traversal(node.right, res)"},{"question":"# Coding Assessment Question Objective: Implement a function to determine the winners of multiple rounds of a game based on player scores saved in a list of dictionaries. Your function should accept a list of rounds (each round being a dictionary with player names as keys and their corresponding scores as values) and return a list of round winners. Description: You are given multiple rounds of a game where players compete and get individual scores for each round. Write a function `determine_round_winners` that calculates the winner of each round based on the highest score. If there is a tie for the highest score, all tied players are considered winners for that round. Input: - A list of dictionaries where each dictionary represents a round of the game. Each dictionary will have player names as keys and their corresponding scores as values. Output: - Return a list of lists where each inner list contains the names of the winners (could be one or more in case of a tie) for each corresponding round. Constraints: - It\'s guaranteed that no two identical scores will lead to different winners within the same round. - Assume the number of rounds is between 1 and 10, and the number of players in each round is between 1 and 10. - Scores are non-negative integers. Example: ```python rounds = [ {\\"Alice\\": 95, \\"Bob\\": 85, \\"Charlie\\": 95}, {\\"Alice\\": 78, \\"Bob\\": 92, \\"Charlie\\": 88}, {\\"Alice\\": 100, \\"Bob\\": 100, \\"Charlie\\": 90} ] expected_output = [ [\\"Alice\\", \\"Charlie\\"], [\\"Bob\\"], [\\"Alice\\", \\"Bob\\"] ] ``` Function Signature: ```python def determine_round_winners(rounds: list) -> list: pass ``` Implementation Instructions: 1. Iterate through each round to find the highest score(s) and corresponding player(s). 2. Group players with the highest score for each round. 3. Ensure the function handles ties appropriately by including all players with the highest score. 4. Write clean, readable, and efficient code.","solution":"def determine_round_winners(rounds): Determine the winners of each round based on the highest score. Parameters: rounds (list of dict): A list where each dictionary represents a round in the game with player names as keys and their corresponding scores as values. Returns: list of list: A list where each inner list contains the names of the winners for each round. winners = [] for round_scores in rounds: max_score = max(round_scores.values()) round_winners = [player for player, score in round_scores.items() if score == max_score] winners.append(round_winners) return winners"},{"question":"# Context: You are a developer working on a data processing application. One critical feature involves reading a file containing a list of key-value pairs, parsing these pairs, and storing them in a dictionary for quick lookup and modification. An enhanced storage function needs to be implemented for parsing the file content and handling edge cases where data might be malformed. # Problem: Given the utility functions for reading and parsing file contents into a dictionary, write a function `read_kv_file` that reads a file, processes its content, and returns a dictionary. Your function should handle edge cases gracefully, such as empty lines, lines without a key-value delimiter, and malformed lines. If a line is malformed, it should be skipped. # Function Signature: ```python def read_kv_file(file_path: str) -> dict: Reads a file and processes its content into a dictionary. :param file_path: The path to the file to read. :return: A dictionary containing valid key-value pairs from the file. ``` # Input: - `file_path`: The file path as a string. `[str]` # Output: - A dictionary containing key-value pairs from the file. Lines that are empty or malformed should be ignored. # Constraints: 1. The file contains one key-value pair per line, separated by a colon (`:`). 2. Lines can be empty or malformed. 3. Keys and values are strings; keys must be unique. # Examples: ```python # Content of the file at \\"example.txt\\": # name: John Doe # age: 29 # email: john.doe@example.com # address >>> read_kv_file(\\"example.txt\\") {\\"name\\": \\"John Doe\\", \\"age\\": \\"29\\", \\"email\\": \\"john.doe@example.com\\"} # The line \\"address\\" is ignored because it does not contain a colon. ``` # Notes: - Ensure you properly handle file reading and exceptions that might occur due to invalid file paths. - Skip lines that do not contain a valid key-value pair separated by a colon. - The function should work with large files efficiently, reading line by line.","solution":"def read_kv_file(file_path: str) -> dict: Reads a file and processes its content into a dictionary. :param file_path: The path to the file to read. :return: A dictionary containing valid key-value pairs from the file. kv_dict = {} try: with open(file_path, \'r\') as file: for line in file: line = line.strip() if not line or \':\' not in line: continue key, value = line.split(\':\', 1) key = key.strip() value = value.strip() if key: kv_dict[key] = value except FileNotFoundError: print(f\\"File not found: {file_path}\\") except Exception as e: print(f\\"An error occurred: {e}\\") return kv_dict"},{"question":"# Inventory Management System **Objective**: Design an inventory management system that can track the quantity of different products and handle updates in stock levels efficiently. **Scenario**: You are tasked with creating a simple inventory management system for a small retail store. The system should allow for adding new products to the inventory, updating the quantity of existing products, and retrieving the current stock levels for a specific product. **Requirements**: - Define a class `Inventory` with the following methods: - `add_product(name: str, quantity: int) -> None`: Adds a new product with the given name and quantity. If the product already exists, increment its quantity by the provided amount. - `update_quantity(name: str, quantity: int) -> bool`: Updates the quantity of the specified product. If the product does not exist, return `False`. Otherwise, update the quantity and return `True`. - `get_stock_level(name: str) -> int`: Returns the current quantity of the specified product. If the product does not exist, return `-1`. **Class Signature**: ```python class Inventory: def add_product(self, name: str, quantity: int) -> None: pass def update_quantity(self, name: str, quantity: int) -> bool: pass def get_stock_level(self, name: str) -> int: pass ``` **Constraints**: - The product name is a non-empty string with a maximum length of 100. - The quantity is a non-negative integer. **Examples**: ```python inventory = Inventory() inventory.add_product(\\"Apple\\", 50) # Adds 50 Apples to the inventory inventory.add_product(\\"Banana\\", 30) # Adds 30 Bananas to the inventory assert inventory.get_stock_level(\\"Apple\\") == 50 # Retrieves the stock level for Apple assert inventory.get_stock_level(\\"Banana\\") == 30 # Retrieves the stock level for Banana inventory.update_quantity(\\"Apple\\", 70) # Updates the quantity of Apples to 70 inventory.update_quantity(\\"Orange\\", 20) # Trying to update quantity for a non-existing product assert inventory.get_stock_level(\\"Apple\\") == 70 # Retrieves the updated stock level for Apple assert inventory.get_stock_level(\\"Orange\\") == -1 # Retrieves the stock level for a non-existing product ```","solution":"class Inventory: def __init__(self): self.stock = {} def add_product(self, name: str, quantity: int) -> None: if name in self.stock: self.stock[name] += quantity else: self.stock[name] = quantity def update_quantity(self, name: str, quantity: int) -> bool: if name in self.stock: self.stock[name] = quantity return True return False def get_stock_level(self, name: str) -> int: return self.stock.get(name, -1)"},{"question":"# Coding Assessment Question **Scenario**: As part of a new initiative to improve data analytics, you are tasked with creating a tool that processes sales data for an e-commerce platform. The data consists of transaction records in JSON format. Each transaction record contains the product name, quantity sold, and total sale amount. Your job is to write a function that calculates the total revenue for each product and identifies the product with the highest total revenue. **Objective**: Write a function `calculate_revenue` that reads a list of transaction records in JSON format and returns a tuple containing: 1. A dictionary with product names as keys and their corresponding total revenue as values. 2. The product name with the highest total revenue. **Function Signature**: ```python from typing import List, Tuple, Dict def calculate_revenue(transactions: List[Dict]) -> Tuple[Dict[str, float], str]: Calculate the total revenue for each product and identify the product with the highest revenue. Args: - transactions (List[Dict]): A list of dictionaries where each dictionary contains: - \\"product\\": (str) name of the product - \\"quantity\\": (int) quantity sold - \\"total_amount\\": (float) total sale amount for the transaction Returns: - Tuple[Dict[str, float], str]: A tuple where: - The first element is a dictionary with product names as keys and their total revenue as values. - The second element is the product name with the highest total revenue. ``` **Constraints**: - **Input**: - `transactions`: A non-empty list of dictionaries, with each dictionary having the following structure: ```python { \\"product\\": <product_name> (str), \\"quantity\\": <quantity_sold> (int), \\"total_amount\\": <total_sale_amount> (float) } ``` - **Output**: - A dictionary where each key is a product name, and the value is the total revenue (float) for that product. - A string representing the product name with the highest total revenue. - If two or more products have the same highest total revenue, return the first one that achieved it. **Example**: ```python transactions = [ {\\"product\\": \\"Laptop\\", \\"quantity\\": 1, \\"total_amount\\": 1000.00}, {\\"product\\": \\"Smartphone\\", \\"quantity\\": 2, \\"total_amount\\": 1200.00}, {\\"product\\": \\"Laptop\\", \\"quantity\\": 1, \\"total_amount\\": 1000.00}, {\\"product\\": \\"Headphones\\", \\"quantity\\": 3, \\"total_amount\\": 300.00} ] result = calculate_revenue(transactions) Expected Output: ({\\"Laptop\\": 2000.00, \\"Smartphone\\": 1200.00, \\"Headphones\\": 300.00}, \\"Laptop\\") ``` **Guidelines for Implementation**: 1. **Data Aggregation**: Effectively aggregate the total revenue for each product name. 2. **Error Handling**: Handle potential edge cases such as: - Transactions with zero or negative quantities or sale amounts. 3. **Performance Considerations**: Optimize for large lists of transactions without exhausting memory. 4. **Output Consistency**: Ensure the output dictionary\'s keys are consistently sorted alphabetically for easier verification. **Additional Notes**: - Transactions with invalid data (e.g., missing keys) should be skipped. - Products should be case-sensitive (e.g., \\"Laptop\\" and \\"laptop\\" are considered different products).","solution":"from typing import List, Tuple, Dict def calculate_revenue(transactions: List[Dict]) -> Tuple[Dict[str, float], str]: revenue_dict = {} for transaction in transactions: try: product = transaction[\'product\'] total_amount = transaction[\'total_amount\'] if total_amount < 0: continue if product in revenue_dict: revenue_dict[product] += total_amount else: revenue_dict[product] = total_amount except KeyError: continue highest_revenue_product = max(revenue_dict, key=revenue_dict.get, default=None) return revenue_dict, highest_revenue_product"},{"question":"# Scenario You are working on a recommendation system that suggests books to users based on their reading history. The recommendation algorithm should find books that were frequently read after a given pair of books by the same user. # Task Implement a function `recommend_books` that finds and returns the most frequent books that users read immediately after completing a given pair of books. # Function Signature ```python def recommend_books(reading_histories: List[List[str]], book_pair: Tuple[str, str]) -> List[str]: ``` # Input 1. `reading_histories`: A list of lists, where each inner list represents the chronological order of books read by a user. Each book is represented by a unique string. 2. `book_pair`: A tuple of two strings representing the given pair of books. The goal is to find books that are read immediately after this pair by the same user in their reading history. # Output A list of strings representing the most frequent books read immediately after the given book pair. If there are multiple books with the same highest frequency, include all of them in the output list. # Constraints - The length of each user\'s reading history list is between 0 and 1000 inclusive. - The input book pair is guaranteed to exist in at least one user\'s reading history. - There are no duplicate book entries within a single user\'s reading history. # Example ```python reading_histories = [ [\'bookA\', \'bookB\', \'bookC\', \'bookD\'], [\'bookB\', \'bookA\', \'bookC\', \'bookD\'], [\'bookA\', \'bookB\', \'bookC\', \'bookE\'], [\'bookA\', \'bookB\', \'bookF\'] ] book_pair = (\'bookA\', \'bookB\') # Expected Output: [\'bookC\'] ``` # Notes 1. Your implementation should correctly handle cases where the given book pair is at the end of a user\'s reading history by excluding such cases from the frequency count. 2. Ensure to test with edge cases such as empty reading histories, multiple pairs in a single history, and different frequencies of books following the pair. 3. Optimize your solution for performance and clarity.","solution":"from typing import List, Tuple from collections import defaultdict def recommend_books(reading_histories: List[List[str]], book_pair: Tuple[str, str]) -> List[str]: book_after_pair_count = defaultdict(int) most_frequent_books = [] max_count = 0 # Extract the books read immediately after the given pair for history in reading_histories: for i in range(len(history) - 2): if history[i] == book_pair[0] and history[i + 1] == book_pair[1]: next_book = history[i + 2] book_after_pair_count[next_book] += 1 if book_after_pair_count[next_book] > max_count: max_count = book_after_pair_count[next_book] # Collect books with max_count for book, count in book_after_pair_count.items(): if count == max_count: most_frequent_books.append(book) return most_frequent_books"},{"question":"# Scenario You are contributing to a software project focused on data manipulation and transformation. One of the features you need to implement involves handling large text data and ensuring that the words in the text are reversed, without changing the order of the words themselves. # Problem Statement Given a string `text`, you are to write a function `reverse_words_in_text(text: str) -> str` that reverses each word in the string without altering the order of the words. # Input * `text` (String): A string of words separated by spaces (1 ≤ length of text ≤ 1000). # Output * Return the transformed string with each word reversed but the order of words maintained. # Example ```python >>> reverse_words_in_text(\\"hello world this is a test\\") \\"olleh dlrow siht si a tset\\" >>> reverse_words_in_text(\\"data structures are fun\\") \\"atad serutcurts era nuf\\" >>> reverse_words_in_text(\\"reverse each word individually\\") \\"esrever hcae drow yllaudividni\\" ``` # Constraints * The function should handle strings with varying lengths and whitespace distributions. * Ensure the solution is efficient and handles edge cases, such as empty strings or single-word strings. # Note Use appropriate string manipulation techniques and consider edge cases where the input might have multiple spaces between words. The integrity of spaces should be maintained as in the original string.","solution":"def reverse_words_in_text(text: str) -> str: Reverses each word in the string without altering the order of the words. Args: - text (str): A string of words separated by spaces. Returns: - str: Transformed string with each word reversed but the order of words maintained. # Split the text into words words = text.split(\' \') # Reverse each word and join them back with a space reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Question: Implement an Efficient Radix Sort Context Radix Sort is a non-comparative integer sorting algorithm that sorts data by processing individual digits. Given its efficiency, it’s particularly useful for sorting large datasets. Task Implement the Radix Sort algorithm that can efficiently handle large lists of integers by making use of counting sort as its intermediate stable sorting algorithm. Implementation Requirements 1. **Input**: * An unsorted list `lst` containing non-negative integers. * The list may contain duplicates. * Assume the list length (`n`) could be large: `1 ≤ n ≤ 10^6`. * Assume integers can be up to `10^9`. 2. **Output**: * A sorted list containing all elements from the input list in ascending order. 3. **Constraints**: * Use Radix Sort logic with Counting Sort for intermediate sorting. * Optimize the solution to ensure it handles the maximum input size within a reasonable time. 4. **Performance**: * The solution should efficiently handle worst-case time complexity of O(d*(n + k)), where `d` is the number of digits in the largest number and `k` is the range of the digits (0 to 9 for decimal numbers). Write a function `radix_sort(lst)` that implements the required functionality. Example ```python def radix_sort(lst): # Helper function to do counting sort according to the digit represented by exp. def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 # Because there are 10 possible digits (0 to 9) # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[(index % 10)] += 1 # Change count[i] so that it contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr[] now contains sorted numbers for i in range(n): arr[i] = output[i] # Main function to do Radix Sort max_val = max(lst) # Do counting sort for every digit. Instead of passing digit number, exp is passed. # exp is 10^i, i is current digit number. exp = 1 while max_val / exp > 1: counting_sort(lst, exp) exp *= 10 return lst # Example usage: lst = [170, 45, 75, 90, 802, 24, 2, 66] sorted_lst = radix_sort(lst) print(sorted_lst) # Expected output: [2, 24, 45, 66, 75, 90, 170, 802] ```","solution":"def radix_sort(lst): Perform Radix Sort on a list of non-negative integers. def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if not lst: # Handle empty input list return lst max_val = max(lst) exp = 1 while max_val // exp > 0: counting_sort(lst, exp) exp *= 10 return lst"},{"question":"# Calculate Product of All Elements Except Self Implement the function `product_except_self(nums: list) -> list` which returns a list where each element at index `i` is the product of all the numbers in the original array except the one at `i`. The function must handle non-zero integers in the input list. Input - A list of integers `nums`. Output - A list of integers representing the product array, where each element is the product of all the other elements except itself. Constraints - The function must not use division and run in O(n) time complexity. - The length of the list is guaranteed to be greater than 1. - The input list will not contain any zeroes. - If the input is not a list of integers, the function should raise a `TypeError`. Implementation ```python def product_except_self(nums: list) -> list: Returns a list where each element at index i is the product of all the numbers in the original list except the one at i. Exceptions: - Raises TypeError if input is not a list of integers. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] if not all(isinstance(x, int) for x in nums): raise TypeError(\\"Input must be a list of integers\\") length = len(nums) res = [1] * length left_product = 1 for i in range(length): res[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): res[i] *= right_product right_product *= nums[i] return res if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` Write the implementation for the `product_except_self` function to satisfy the given problem statement and constraints. Ensure your code handles all edge cases efficiently including checking for valid input types and maintaining optimal time complexity.","solution":"def product_except_self(nums: list) -> list: Returns a list where each element at index i is the product of all the numbers in the original list except the one at i. Exceptions: - Raises TypeError if input is not a list of integers. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise TypeError(\\"Input must be a list of integers\\") length = len(nums) res = [1] * length left_product = 1 for i in range(length): res[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): res[i] *= right_product right_product *= nums[i] return res"},{"question":"# Scenario: You are designing a system that processes a continuous stream of temperature data from multiple sensors placed across a city. The system needs to identify significant temperature drops, which could indicate potential issues such as equipment failures or sudden weather changes. A significant temperature drop is defined as a decrease of a certain threshold within a specified time window. # Task: Write a function that determines if there is a significant temperature drop in the given data. Your function should take a list of temperature readings and identify if there exists any time window of specified length where the temperature drops by a given threshold. # Function Signature: ```python def significant_temperature_drop( temperatures: List[float], window_size: int, threshold: float ) -> bool: pass ``` # Input: - `temperatures`: A list of n floating-point numbers representing temperature readings. - `window_size`: An integer specifying the length of the time window to check for significant drops. - `threshold`: A floating-point number representing the minimum temperature drop to be considered significant. # Output: - Returns a boolean value indicating whether a significant temperature drop exists within any time window of the specified length. # Constraints: - The length of the `temperatures` list is between 1 and 10^6. - The `window_size` will be <= n. - The `threshold` will be a non-negative value. # Example: ```python >>> temperatures = [22.4, 21.8, 19.5, 18.1, 20.3, 17.7, 16.0, 15.5] >>> significant_temperature_drop(temperatures, 3, 3.0) True >>> temperatures = [22.4, 21.8, 22.0, 21.9, 21.8, 21.7, 21.4, 21.0] >>> significant_temperature_drop(temperatures, 3, 5.0) False ``` # Notes: - The order of the temperature readings in the list corresponds to their chronological order. - A window size of 1 means you are looking at individual readings. - Ensure you handle edge cases, such as a window size larger than the list length gracefully (which should return `False` in such cases). - Focus on optimizing the function for efficiency with large input sizes.","solution":"from typing import List def significant_temperature_drop( temperatures: List[float], window_size: int, threshold: float ) -> bool: Determines if there is a significant temperature drop in any window of specified size. A significant temperature drop is defined as a drop of at least \'threshold\' within any \'window_size\' length of the temperature readings. :param temperatures: List of temperature readings. :param window_size: Integer length of the window to check for drops. :param threshold: Floating point temperature drop to be considered significant. :return: Boolean indicating if a significant drop was found. n = len(temperatures) for i in range(n - window_size + 1): window_start_temp = temperatures[i] window_end_temp = temperatures[i + window_size - 1] if window_start_temp - window_end_temp >= threshold: return True return False"},{"question":"# Question Design a Python function called `sort_by_factor_count` that sorts a list of integers based on the number of factors they have. If two integers have the same number of factors, they should remain in their original order relative to each other (i.e., the sort should be stable). Function Signature ```python def sort_by_factor_count(nums: list[int]) -> list[int]: pass ``` Input - `nums`: A list of integers. Output - Returns a list of integers sorted by the number of factors in ascending order. Constraints - The length of `nums` will be in the range [1, 10^4]. - Each integer in `nums` will be in the range [1, 10^6]. Requirements - The function should not modify the input list `nums`. - The sorting should be stable; that is, if two integers have the same number of factors, their relative order should not change from the input list. Example ```python >>> sort_by_factor_count([6, 8, 9, 10, 12]) [8, 6, 9, 10, 12] >>> sort_by_factor_count([1, 2, 3, 4]) [1, 2, 3, 4] >>> sort_by_factor_count([16, 18, 17, 20]) [17, 16, 18, 20] ``` Explanation - In the first example, the number of factors for each number is as follows: - 6 has 4 factors: 1, 2, 3, 6 - 8 has 4 factors: 1, 2, 4, 8 - 9 has 3 factors: 1, 3, 9 - 10 has 4 factors: 1, 2, 5, 10 - 12 has 6 factors: 1, 2, 3, 4, 6, 12 Sorting by the number of factors, the list becomes: [8, 6, 9, 10, 12] - In the second example, each number has a different number of factors, so their order remains unchanged. - In the third example, the number of factors for each number is as follows: - 16 has 5 factors: 1, 2, 4, 8, 16 - 18 has 6 factors: 1, 2, 3, 6, 9, 18 - 17 has 2 factors: 1, 17 - 20 has 6 factors: 1, 2, 4, 5, 10, 20 Sorting by the number of factors, the list becomes: [17, 16, 18, 20]","solution":"def sort_by_factor_count(nums: list[int]) -> list[int]: def count_factors(n): count = 0 for i in range(1, int(n ** 0.5) + 1): if n % i == 0: if i * i == n: count += 1 else: count += 2 return count return sorted(nums, key=lambda x: count_factors(x))"},{"question":"# Question: Smallest Multiple of Primes Up to N Given a positive integer `n`, write a function `smallest_prime_multiple(n: int) -> int` that returns the smallest positive number that is divisible by all prime numbers less than or equal to `n`. You will need to implement two functions: `is_prime(num: int) -> bool` that checks if a number is prime and `smallest_prime_multiple(n: int) -> int` which calculates the smallest multiple of all primes up to `n`. Constraints - The input `n` will always be a positive integer (1 ≤ n ≤ 30). Function Signature ```python def is_prime(num: int) -> bool: # Your implementation here def smallest_prime_multiple(n: int) -> int: # Your implementation here ``` Example ```python assert smallest_prime_multiple(10) == 210 assert smallest_prime_multiple(5) == 30 assert smallest_prime_multiple(6) == 30 assert smallest_prime_multiple(1) == 1 assert smallest_prime_multiple(2) == 2 ``` Explanation For `n = 10`, the prime numbers less than or equal to 10 are: - 2, 3, 5, and 7. The smallest number that is divisible by all of these prime numbers is: - 2 * 3 * 5 * 7 = 210. Therefore, for `n = 10`, the function should return 210. For `n = 5`, the prime numbers less than or equal to 5 are: - 2, 3, and 5. The smallest number that is divisible by all of these prime numbers is: - 2 * 3 * 5 = 30. Therefore, for `n = 5`, the function should return 30. Implement the functions to pass the provided examples and handle edge cases appropriately.","solution":"def is_prime(num: int) -> bool: Returns True if num is a prime number, False otherwise. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def smallest_prime_multiple(n: int) -> int: Returns the smallest positive number that is divisible by all prime numbers less than or equal to n. if n < 2: return 1 result = 1 for i in range(2, n + 1): if is_prime(i): result *= i return result"},{"question":"# Invert Binary Tree You need to write a function that inverts a binary tree. Inverting a binary tree means every left child of a node will become the right child, and every right child will become the left child. Write a function `invert_binary_tree` that takes the root of a binary tree and returns the root of the inverted binary tree. For example: Given the binary tree: ``` 4 / 2 7 / / 1 3 6 9 ``` The inverted binary tree would be: ``` 4 / 7 2 / / 9 6 3 1 ``` Function Signature: ```python def invert_binary_tree(root: TreeNode) -> TreeNode: ``` # Parameters: - **root**: `TreeNode` - The root node of the binary tree. # Returns: - `TreeNode` - The root node of the inverted binary tree. # Constraints: - The number of nodes in the tree is in the range `[0, 100]`. - `-100 <= Node.val <= 100` # Examples: Given the tree: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) inverted_root = invert_binary_tree(root) ``` After inverting, the tree would look like: ```python TreeNode(4, TreeNode(7, TreeNode(9), TreeNode(6)), TreeNode(2, TreeNode(3), TreeNode(1))) ``` Your function should handle edge cases such as an empty tree and should be efficient for the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert left and right subtrees invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"# Binary Search Tree Implementation Challenge In this task, you will be required to implement a basic binary search tree (BST) class based on given specifications. There are two parts to this task: Part A: BasicBST A binary search tree with standard insert, search, and traversal functionalities. Implement the following methods: 1. `__init__(self)`: Initializes an empty tree. 2. `insert(self, value: int)`: Inserts a value into the BST. Duplicate values should be ignored. 3. `search(self, value: int) -> bool`: Searches for a value in the BST and returns `True` if found, `False` otherwise. 4. `inorder_traversal(self) -> list`: Returns a list of elements in the BST sorted in ascending order. 5. `__str__(self) -> str`: Returns a string representation of the BST in in-order traversal. Part B: ExtendedBST An extended binary search tree with additional functionalities for deletion and finding minimum/maximum values. 1. `__init__(self)`: Initializes an empty tree. 2. `insert(self, value: int)`: Inserts a value into the BST. Duplicate values should be ignored. 3. `search(self, value: int) -> bool`: Searches for a value in the BST and returns `True` if found, `False` otherwise. 4. `delete(self, value: int)`: Deletes a value from the BST. If the value does not exist, do nothing. 5. `find_min(self) -> int`: Returns the minimum value in the BST. Raise `ValueError` if the tree is empty. 6. `find_max(self) -> int`: Returns the maximum value in the BST. Raise `ValueError` if the tree is empty. 7. `inorder_traversal(self) -> list`: Returns a list of elements in the BST sorted in ascending order. 8. `__str__(self) -> str`: Returns a string representation of the BST in in-order traversal. # Input and Output * `insert(value)` accepts a single integer value. * `search(value)` returns a boolean indicating the presence of the value in the tree. * `delete(value)` removes the specified value from the tree. * `find_min()` returns the smallest value in the tree. * `find_max()` returns the largest value in the tree. * `inorder_traversal()` returns a list of sorted elements. * Instances of the classes should handle standard exceptions for invalid operations. # Performance Requirements Ensure that your implementation meets the specified time complexities: * `insert`: O(log n) on average * `search`: O(log n) on average * `delete`: O(log n) on average * `inorder_traversal`: O(n) * Finding min and max values should be efficient. # Example ```python # Part A: BasicBST basic_bst = BasicBST() basic_bst.insert(10) basic_bst.insert(5) basic_bst.insert(15) print(basic_bst) # [5, 10, 15] print(basic_bst.search(10)) # True print(basic_bst.search(20)) # False print(basic_bst.inorder_traversal()) # [5, 10, 15] # Part B: ExtendedBST extended_bst = ExtendedBST() extended_bst.insert(20) extended_bst.insert(10) extended_bst.insert(30) extended_bst.delete(10) print(extended_bst) # [20, 30] print(extended_bst.find_min()) # 20 print(extended_bst.find_max()) # 30 print(extended_bst.inorder_traversal()) # [20, 30] ``` Implement the classes `BasicBST` and `ExtendedBST` with the specified methods and ensure your code passes the above examples.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BasicBST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def inorder_traversal(self): elements = [] self._inorder_recursive(self.root, elements) return elements def _inorder_recursive(self, node, elements): if node: self._inorder_recursive(node.left, elements) elements.append(node.value) self._inorder_recursive(node.right, elements) def __str__(self): return str(self.inorder_traversal()) class ExtendedBST(BasicBST): def delete(self, value): self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.right = self._delete_recursive(node.right, temp.value) return node def find_min(self): if not self.root: raise ValueError(\\"The BST is empty\\") return self._min_value_node(self.root).value def _min_value_node(self, node): current = node while current.left: current = current.left return current def find_max(self): if not self.root: raise ValueError(\\"The BST is empty\\") return self._max_value_node(self.root).value def _max_value_node(self, node): current = node while current.right: current = current.right return current"},{"question":"# Scenario: You are working on a system that monitors stock prices and detects significant movements. One of the tasks is to identify the maximum possible profit from a single buy and sell transaction. Given an array of stock prices recorded chronologically, you need an efficient algorithm to determine the maximum profit that could have been achieved. # Task: Write a function `max_profit(prices: List[int]) -> int` that calculates the maximum profit from one buy and one sell transaction. Your algorithm should be optimized for performance. # Input: * A list of integers `prices`, where each integer represents the stock price on a given day. The length of the list can be up to 10^5. # Output: * An integer representing the maximum profit possible. If no profit can be made, return 0. # Example: ```python def max_profit(prices: List[int]) -> int: pass print(max_profit([7, 1, 5, 3, 6, 4])) # Output: 5 print(max_profit([7, 6, 4, 3, 1])) # Output: 0 ``` # Constraints: * Your function should emphasize efficiency in terms of time complexity. * Consider edge cases where the input list is empty or contains only one price entry. * Avoid brute force methods that iterate through all possible buy/sell pairs.","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and sell transaction. If no profit can be made, returns 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Problem Description You are building a data parser that needs to clean up and format text data by removing specific unwanted characters and capitalizing every first letter of the words. We need to ensure that the parser can handle various delimiters correctly and strip any leading or trailing whitespace. # Your Task Implement a function that receives a string and a list of delimiters. The function should remove all instances of the delimiters from the string, capitalize the first letter of each word, and return the cleaned-up string. # Input Your function will take two parameters: 1. `text` (a string): The input text that contains words separated by various delimiters. 2. `delimiters` (a list of strings): Each string represents a delimiter that needs to be removed from the input text. # Output Your function should return the cleaned-up string with every word\'s first letter capitalized and all unwanted characters removed. # Constraints - The input text will have a maximum length of 5000 characters. - The delimiters list will have at most 10 different delimiters. - Each delimiter is a single character. - Words are separated by the given delimiters. - The string might have leading or trailing whitespace that needs to be stripped. # Example ```python text = \\"hello,world;this-is a:test\\" delimiters = [\\",\\", \\";\\", \\"-\\", \\":\\"] ``` * Expected Output: `\\"Hello World This Is A Test\\"` # Function Signature ```python def clean_and_format_text(text: str, delimiters: List[str]) -> str: pass # You might include the following example usage if __name__ == \\"__main__\\": text = \\"hello,world;this-is a:test\\" delimiters = [\\",\\", \\";\\", \\"-\\", \\":\\"] print(clean_and_format_text(text, delimiters)) # Should return \\"Hello World This Is A Test\\" ``` Use the provided function signature and complete the implementation.","solution":"from typing import List def clean_and_format_text(text: str, delimiters: List[str]) -> str: Cleans up and formats the text by removing the specified delimiters and capitalizing the first letter of each word. Removes leading and trailing whitespace. # Remove all delimiters from the text for delimiter in delimiters: text = text.replace(delimiter, \' \') # Split text into words by default whitespace words = text.split() # Capitalize the first letter of each word capitalized_words = [word.capitalize() for word in words] # Join the capitalized words with a single space formatted_text = \' \'.join(capitalized_words) return formatted_text"},{"question":"# Problem Statement You need to implement two utility functions: `snake_to_camel` and `camel_to_snake`. These functions will perform conversions between snake_case strings and camelCase strings. **Function 1: `snake_to_camel`** - **Input**: A `str` object `data` representing a string in snake_case format. - **Output**: A `str` object which is the converted camelCase representation of the input data. - **Constraints**: - The input `data` can be an empty string. - The input `data` will only contain lowercase letters and underscores. - The output should have the first word in lowercase and subsequent words capitalized. **Function 2: `camel_to_snake`** - **Input**: A `str` object `data` representing a string in camelCase format. - **Output**: A `str` object which is the converted snake_case representation of the input data. - **Constraints**: - The input `data` can be an empty string. - The input `data` will only contain alphanumeric characters. - The output should have all characters in lowercase and words separated by underscores. # Example ```python def snake_to_camel(data: str) -> str: \'\'\' This function converts a snake_case string into camelCase string. \'\'\' pass # TODO: Write the implementation here def camel_to_snake(data: str) -> str: \'\'\' This function converts a camelCase string into snake_case string. \'\'\' pass # TODO: Write the implementation here # Test Cases assert snake_to_camel(\'hello_world\') == \'helloWorld\' assert snake_to_camel(\'my_variable\') == \'myVariable\' assert snake_to_camel(\'\') == \'\' assert snake_to_camel(\'alreadycamelcase\') == \'alreadycamelcase\' assert camel_to_snake(\'helloWorld\') == \'hello_world\' assert camel_to_snake(\'myVariable\') == \'my_variable\' assert camel_to_snake(\'\') == \'\' assert camel_to_snake(\'justonestring\') == \'justonestring\' ``` **Additional Note**: - Ensure your code handles edge cases appropriately and follows the constraints. - The implementation should be efficient and correctly handle varying lengths of input strings.","solution":"def snake_to_camel(data: str) -> str: Converts a snake_case string into camelCase string. if not data: return data words = data.split(\'_\') return words[0] + \'\'.join(word.capitalize() for word in words[1:]) def camel_to_snake(data: str) -> str: Converts a camelCase string into snake_case string. if not data: return data result = [data[0].lower()] for char in data[1:]: if char.isupper(): result.append(\'_\') result.append(char.lower()) else: result.append(char) return \'\'.join(result)"},{"question":"# Binary Search Tree (BST) Implementation with Additional Operations Extend the functionality of a Binary Search Tree (BST) by implementing additional operations. Besides standard operations, you are to incorporate methods for finding the Kth smallest element in the tree and checking if the tree is a valid BST. # Task 1. Define a class `TreeNode` representing a node in the BST. 2. Define a class `BST` with methods for inserting nodes, finding the Kth smallest element, and verifying the BST property. # Class and Function Specifications 1. **Class `TreeNode`**: * Attributes: - `val` (int): The value stored in the node. - `left` (`TreeNode`): The left child of the node. - `right` (`TreeNode`): The right child of the node. 2. **Class `BST`**: * Method: `insert(val: int)`: - Inserts a value into the BST while maintaining the BST property. * Method: `find_kth_smallest(k: int) -> int`: - Finds the Kth smallest element in the BST. - Assumes 1 ≤ k ≤ number of nodes in the tree. * Method: `is_valid_bst() -> bool`: - Checks if the tree is a valid BST. - A valid BST is defined as a binary tree in which for each node, the value of all the nodes in the left subtree is less than the node\'s value, and the value of all the nodes in the right subtree is greater than the node\'s value. # Input and Output Formats * **Input**: * For `insert`: An integer `val` representing the value to be inserted into the BST. * For `find_kth_smallest`: An integer `k` representing the position of the smallest element to find. * No input for `is_valid_bst`. * **Output**: * For `find_kth_smallest`: Returns the value of the Kth smallest element. * For `is_valid_bst`: Returns `True` if the tree is a valid BST, otherwise `False`. # Constraints * The `find_kth_smallest` function assumes that the tree has at least `k` nodes. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val: int): # Your code here for inserting a value while maintaining the BST property def find_kth_smallest(self, k: int) -> int: # Your code here for finding the Kth smallest element def is_valid_bst(self) -> bool: # Your code here for checking if the tree is a valid BST # Example Usage: bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.is_valid_bst()) # Expected output: True print(bst.find_kth_smallest(2)) # Expected output: 5 bst.insert(4) print(bst.is_valid_bst()) # Expected output: True bst.insert(6) bst.insert(8) print(bst.find_kth_smallest(4)) # Expected output: 6 ``` Ensure to test your implementation with various insertion sequences and tree shapes to cover different edge cases. Document assumptions and approach for better clarity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val: int): Inserts a value into the BST while maintaining the BST property. if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def find_kth_smallest(self, k: int) -> int: Finds the Kth smallest element in the BST. Assumes 1 ≤ k ≤ number of nodes in the tree. def in_order_traverse(node): if node: yield from in_order_traverse(node.left) yield node.val yield from in_order_traverse(node.right) gen = in_order_traverse(self.root) for _ in range(k - 1): next(gen) return next(gen) def is_valid_bst(self) -> bool: Checks if the tree is a valid BST. def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if node.val <= low or node.val >= high: return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(self.root)"},{"question":"**Implementing a Rate Limiter for API Requests** In a web service environment, it\'s common practice to limit the number of API requests that can be made by a user within a certain time frame to prevent misuse of the service. Your task is to implement a simple rate limiter using Python. # Task 1. **RateLimiter Class** - Design a class `RateLimiter` that initializes with a `max_requests` integer and a `time_window` integer (in seconds). - The class should have a method `allow_request(user_id: str) -> bool`. 2. **allow_request(user_id: str) -> bool** - Input: A `user_id` string that uniquely identifies a user making the request. - Output: A boolean value indicating whether the user is allowed to make the request (i.e., `True` if within limit, `False` if exceeded). - Constraints: - Each user can only make up to `max_requests` within the specified `time_window`. - Requests are continuously evaluated within the sliding window of `time_window`. # Example Usage ```python rate_limiter = RateLimiter(max_requests=5, time_window=60) print(rate_limiter.allow_request(\\"user1\\")) # True print(rate_limiter.allow_request(\\"user1\\")) # True print(rate_limiter.allow_request(\\"user1\\")) # True print(rate_limiter.allow_request(\\"user1\\")) # True print(rate_limiter.allow_request(\\"user1\\")) # True print(rate_limiter.allow_request(\\"user1\\")) # False (6th request within 60 seconds) ``` # Additional Requirements 1. **Efficiency**: - Ensure that the class can handle multiple users making requests efficiently. 2. **Edge Cases**: - Handle cases where `max_requests` or `time_window` are set to very small values (e.g., `max_requests=1` or `time_window=1` second). - Ensure that each request is timestamped correctly to accurately reflect the sliding time window. Implement the `RateLimiter` class and the `allow_request` method to meet the above requirements.","solution":"from collections import defaultdict from time import time class RateLimiter: def __init__(self, max_requests, time_window): self.max_requests = max_requests self.time_window = time_window self.request_logs = defaultdict(list) def allow_request(self, user_id): current_time = time() if user_id in self.request_logs: self.request_logs[user_id] = [timestamp for timestamp in self.request_logs[user_id] if current_time - timestamp < self.time_window] if len(self.request_logs[user_id]) < self.max_requests: self.request_logs[user_id].append(current_time) return True else: return False"},{"question":"# Problem Statement Consider a grid or matrix where each cell contains a non-negative integer representing the cost of stepping on that cell. Your task is to determine the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move right or down from a given cell. # Specific Requirements 1. **Input**: - A file named \\"grid.txt\\" containing the grid of non-negative integers. Each line in the file represents a row of the grid, with integers separated by spaces. 2. **Output**: - An integer representing the minimum cost to travel from the top-left to the bottom-right corner of the grid. # Example Consider the following grid: ``` 1 3 1 1 5 1 4 2 1 ``` The minimum cost path would be 1 -> 3 -> 1 -> 1 -> 1, which leads to a total cost of 7. # Constraints - The grid in the file will contain non-negative integers. - The file can be large (up to 100x100 grid). # Function Implementation You are required to implement the function `min_cost_path(file_path: str) -> int` that reads the grid from the given file path and returns the minimum cost to traverse from the top-left to the bottom-right corner. # Additional Guidance Ensure to handle edge cases such as: - The file containing an irregular or non-rectangular grid. - Proper parsing of the file to handle varying amounts of whitespace. # Example Implementation ```python def min_cost_path(file_path: str) -> int: Finds the minimum cost path in a grid from the given file path. :param file_path: Path to the file containing the grid. :return: Minimum cost to travel from top-left to bottom-right. with open(file_path) as in_file: grid = [[int(i) for i in line.split()] for line in in_file] rows = len(grid) cols = len(grid[0]) # Initialize DP table with the same size as grid dp = [[0]*cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row of the DP table for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column of the DP table for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1] if __name__ == \\"__main__\\": file_path = \\"path/to/grid.txt\\" print(min_cost_path(file_path)) ``` This question should align with the given criteria.","solution":"def min_cost_path(file_path: str) -> int: Finds the minimum cost path in a grid from the given file path. :param file_path: Path to the file containing the grid. :return: Minimum cost to travel from top-left to bottom-right. with open(file_path) as in_file: grid = [[int(num) for num in line.split()] for line in in_file] if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) if rows == 1 and cols == 1: return grid[0][0] # Initialize DP table with the same size as grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row of the DP table for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column of the DP table for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1]"},{"question":"**Objective**: Develop a function that calculates the longest consecutive sequence of integers in an unsorted list using efficient techniques. **Scenario**: You are working with a dataset of integer readings collected from various sensors over time. The goal is to determine the longest consecutive sequence of readings to analyze periods of stable data collection. **Function Signature**: ```python def longest_consecutive_sequence(arr: list[int]) -> int: Return the length of the longest consecutive elements sequence in the given list. Parameters: arr (list[int]): A list of integers that may contain duplicates. Returns: int: The length of the longest consecutive elements sequence. Example: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 # The longest consecutive elements sequence is [1, 2, 3, 4] >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 # The longest consecutive elements sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8] Constraints: 1. The list `arr` is not empty. 2. The elements in the list can be negative or positive integers. Raises: ValueError: If the list is empty. pass ``` **Constraints**: 1. The list `arr` is not empty. **Requirements**: 1. The algorithm should ideally have a time complexity of O(n). 2. Handle edge cases such as lists with duplicate elements. **Examples**: ```python # Example 1 arr = [100, 4, 200, 1, 3, 2] assert longest_consecutive_sequence(arr) == 4 # Sequence is [1, 2, 3, 4] # Example 2 arr = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1] assert longest_consecutive_sequence(arr) == 9 # Sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8] # Example 3 arr = [10, 5, 12, 21, 9, 11, 8, 1, 2, 13] assert longest_consecutive_sequence(arr) == 6 # Sequence is [8, 9, 10, 11, 12, 13] # Example 4 arr = [-1, -9, 0, -8, -10, -7] assert longest_consecutive_sequence(arr) == 4 # Sequence is [-10, -9, -8, -7] ``` **Hint**: To achieve optimal performance, consider using a hash set to store the elements and then find the sequences by checking for the starting points of sequences.","solution":"def longest_consecutive_sequence(arr: list[int]) -> int: if not arr: raise ValueError(\\"List must not be empty\\") num_set = set(arr) longest_length = 0 for num in num_set: if num - 1 not in num_set: # Check if it is the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"# Context You are given an implementation of a trie (also known as a prefix tree) for handling a collection of words. The trie supports insertion and search operations. You need to extend this understanding to solve a problem that involves autocomplete functionality. # Problem Statement Given a list of words `word_list` and a prefix `prefix`, write a function `autocomplete(word_list: List[str], prefix: str) -> List[str]` that returns a list of all words in `word_list` that start with the given `prefix`. The list of words should be returned in lexicographical order. # Input * `word_list` - A list of words where each word consists of lowercase English letters. (1 <= len(word_list) <= 10^4, 1 <= len(word) <= 100) * `prefix` - A string containing lowercase English letters representing the prefix. (1 <= len(prefix) <= 100) # Output * Returns a list of words starting with the given prefix in lexicographical order. # Example ```python word_list = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"blueberry\\"] prefix = \\"ap\\" print(autocomplete(word_list, prefix)) # Output: [\\"app\\", \\"apple\\", \\"apricot\\"] word_list = [\\"transaction\\", \\"transmit\\", \\"translucent\\", \\"tree\\", \\"trick\\"] prefix = \\"tri\\" print(autocomplete(word_list, prefix)) # Output: [\\"trick\\"] ``` # Function Signature ```python def autocomplete(word_list: List[str], prefix: str) -> List[str]: pass ``` # Hints 1. Consider using a Trie data structure to efficiently handle the insertion and prefix search operations. 2. Ensure to build the Trie from `word_list` and perform a prefix search to gather all matching words. 3. Since the words need to be returned in lexicographical order, you can leverage the properties of the Trie to achieve this.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True def search_prefix(self, prefix: str) -> TrieNode: current = self.root for letter in prefix: if letter in current.children: current = current.children[letter] else: return None return current def collect_words(self, node: TrieNode, prefix: str) -> List[str]: words = [] if node.is_end_of_word: words.append(prefix) for letter, child_node in sorted(node.children.items()): words.extend(self.collect_words(child_node, prefix + letter)) return words def autocomplete(word_list: List[str], prefix: str) -> List[str]: trie = Trie() for word in word_list: trie.insert(word) prefix_node = trie.search_prefix(prefix) if not prefix_node: return [] return trie.collect_words(prefix_node, prefix)"},{"question":"# Prime Palindrome Number Generation Background: A prime palindrome is a number that is both a prime and a palindrome. For example, 131 is both prime (divisible only by 1 and itself) and a palindrome (reads the same backward as forward). Task: You are required to implement the function `prime_palindrome` as described in the code snippet provided to find the smallest prime palindrome greater than or equal to a given integer `n`. Function Signature: ```python def prime_palindrome(n: int) -> int: Finds the smallest prime palindrome number which is greater than or equal to the given integer n. Input Parameter: n (int): A positive integer to start the search for prime palindromes. Returns: int: The smallest prime palindrome number greater than or equal to n. ``` Example Tests: ```python >>> prime_palindrome(6) 7 >>> prime_palindrome(8) 11 >>> prime_palindrome(13) 101 >>> prime_palindrome(1) 2 >>> prime_palindrome(31) 101 ``` Constraints: * The input number `n` will be a positive integer. * The function must efficiently handle searching for prime palindromes even for values as large as (10^6). * Ensure realistic implementation that can handle edge cases like very small values (e.g., 1) and large search spaces.","solution":"def prime_palindrome(n: int) -> int: Finds the smallest prime palindrome number which is greater than or equal to the given integer n. def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num: int) -> bool: return str(num) == str(num)[::-1] candidate = n while True: if is_palindrome(candidate) and is_prime(candidate): return candidate candidate += 1"},{"question":"# Problem Statement You are tasked with implementing a simple chat application featuring a message history that can dynamically be loaded as the user scrolls up. Specifically, you will modify an existing chat UI to implement lazy loading of chat messages. # Requirements 1. **Lazy Loading Mechanism**: Adjust the chat interface to load older messages only when the user scrolls to the top of the current message list. 2. **Message Retrieval Function**: Implement a function to fetch additional chat messages from a server or a data source when necessary. # Input/Output - **Input**: User scroll events (upward scrolling near the top of the message list). - **Output**: Updated list of chat messages displayed in the UI, with older messages added to the top as the user scrolls up. # Constraints 1. Initially, only the most recent set of messages should be loaded with a specified limit (e.g., last 20 messages). 2. Additional messages should be dynamically loaded in batches when the user scrolls up to the top and reaches the end of the currently loaded messages. 3. Ensure smooth transitions and avoid reloading messages that are already displayed. # Function Signature ```python def load_more_messages(message_list: list[str], current_top_message_id: int) -> list[str]: pass ``` # Example ```python def main(): chat_ui = ChatInterface() chat_ui.load_initial_messages() chat_ui.on_scroll_to_top = lambda: chat_ui.update_message_list( load_more_messages(chat_ui.message_list, chat_ui.get_current_top_message_id()) ) if __name__ == \\"__main__\\": main() ``` In this example, when the user initially opens the chat, the last 20 messages are loaded. As the user scrolls up and reaches the top of the message list, `load_more_messages` is called to fetch older messages, which are then displayed above the current messages. # Implementation Details 1. Implement a mock data source or a function to simulate fetching old messages from a server. 2. Set up a scroll event listener within your chat UI framework to detect when the user scrolls to the top of the message list. 3. Ensure that newly loaded messages are added to the top of the list in the UI without affecting the currently displayed messages.","solution":"def load_more_messages(message_list, current_top_message_id): Fetch more chat messages given the current top message ID. Parameters: message_list (list of str): The current list of chat messages. current_top_message_id (int): The message ID at the top of the current list. Returns: list of str: Updated list of chat messages with older messages added. # Simulating fetching older messages by decreasing the message ID additional_messages = [] batch_size = 10 # Number of messages to load at a time for i in range(current_top_message_id - 1, current_top_message_id - 1 - batch_size, -1): additional_messages.append(f\\"Message {i}\\") # Prepend new messages to the beginning updated_message_list = additional_messages + message_list return updated_message_list"},{"question":"**Scenario**: A developer is building a data processing pipeline to handle various operations on a stream of integers. One of the requirements is to implement an operation that shifts each integer in a list to the left by a specified number of positions, wrapping around the list as needed. **Task**: Implement the function `left_rotate` that performs a left circular rotation on a list of integers by a given number of positions. The function should take two arguments: `nums`, a list of integers, and `k`, the number of positions to rotate the list to the left. # Input Format: - `nums` (List[int]): A list of integers. - `k` (int): The number of positions to rotate the list to the left. `k` is non-negative. # Output Format: - Return a new list that represents the left-rotated list. # Example: ```python def left_rotate(nums: list[int], k: int) -> list[int]: Perform a left circular rotation on the list. >>> left_rotate([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> left_rotate([1, 2, 3], 4) [2, 3, 1] >>> left_rotate([1], 3) [1] >>> left_rotate([], 1) [] >>> left_rotate([10, 20, 30, 40], 0) [10, 20, 30, 40] if not nums: return [] k = k % len(nums) return nums[k:] + nums[:k] ``` # Constraints: - The `nums` list can be empty. - The elements in the `nums` list are integers. - `k` is a non-negative integer. - Ensure the function handles edge cases, such as an empty list or when `k` is larger than the length of the list. **Notes**: - Ensure your solution is efficient and works for large lists. - You must consider the effect of `k` being multiple times larger than the length of the list.","solution":"def left_rotate(nums: list[int], k: int) -> list[int]: Perform a left circular rotation on the list. Parameters: nums (List[int]): A list of integers. k (int): The number of positions to rotate the list to the left. k is non-negative. Returns: List[int]: A new list that represents the left-rotated list. if not nums: return [] k = k % len(nums) return nums[k:] + nums[:k]"},{"question":"# String Rotation Checker **Problem Statement:** You are given two strings, `s` and `goal`. Write a function that returns `True` if and only if `s` can become `goal` after some number of shifts to the left. A shift to the left is defined as moving the first character of `s` to the end of the string. Function Signature: ```python def is_rotation(s: str, goal: str) -> bool: ``` Input: - `s`: A string of length `n` (1 ≤ `n` ≤ 100). - `goal`: A string of length `n`. Output: - Returns `True` if `s` can become `goal` after some number of shifts to the left; otherwise, it returns `False`. Constraints: 1. Both strings are of the same length. 2. All characters in the strings are lowercase English letters. Example: ```python # Example 1: s = \\"abcde\\" goal = \\"cdeab\\" assert is_rotation(s, goal) == True ``` ```python # Example 2: s = \\"abcde\\" goal = \\"abced\\" assert is_rotation(s, goal) == False ``` ```python # Example 3: s = \\"aaaaa\\" goal = \\"aaaaa\\" assert is_rotation(s, goal) == True ``` Edge Cases to Consider: 1. Both strings are empty. 2. Both strings are identical. 3. `goal` contains characters not found in `s`. Expected Solution Quality: - Ensure your function handles all edge cases, maintains good performance, and produces accurate results. **Your Task:** Implement the function `is_rotation` to check if `s` can become `goal` through any number of left shifts.","solution":"def is_rotation(s: str, goal: str) -> bool: Returns True if the string s can become the string goal after some number of left shifts, otherwise False. # Concatenate s with itself to cover all rotation cases concatenated_s = s + s # Check if goal is a substring of the concatenated result return len(s) == len(goal) and goal in concatenated_s"},{"question":"# Dynamic Programming for Longest Increasing Subsequence Given a class `LongestIncreasingSubsequence` (LIS) which you need to implement, the goal is to find the length of the longest strictly increasing subsequence in a given integer array. You will need to: 1. **Implement the `find_lis_length` method** in the `LIS` class that uses dynamic programming to solve the problem. 2. **Implement the `find_lis_sequence` method** in the `LIS` class that reconstructs the longest increasing subsequence found by the dynamic programming algorithm. # Implementation Details: 1. **`find_lis_length` method** should: - Accept an integer array. - Use dynamic programming to calculate the length of the longest increasing subsequence. - Return the length of this subsequence. 2. **`find_lis_sequence` method** should: - Accept an integer array. - Use the results from the `find_lis_length` method to reconstruct the actual subsequence. - Return the longest increasing subsequence as a list of integers. # Input/Output: - **Input**: - For `find_lis_length` method: ```python def find_lis_length(self, arr): # arr: List[int], the input array of integers ``` - For `find_lis_sequence` method: ```python def find_lis_sequence(self, arr): # arr: List[int], the input array of integers ``` - **Output**: - For `find_lis_length` method: Return length of the longest increasing subsequence. - For `find_lis_sequence` method: Return the longest increasing subsequence as a list. # Constraints: 1. The array can be of length up to (10^4). 2. Elements in the array are integers and can be negative, zero, or positive. # Notes: - The `find_lis_length` method should efficiently solve the problem with a time complexity of ( O(n^2) ). - The `find_lis_sequence` method should correctly reconstruct the sequence from the dynamic programming table. # Example Scenario: ```python # Assuming class is implemented lis = LongestIncreasingSubsequence() arr = [10, 22, 9, 33, 21, 50, 41, 60] length = lis.find_lis_length(arr) print(f\\"LIS Length: {length}\\") # Output: 5 sequence = lis.find_lis_sequence(arr) print(f\\"LIS Sequence: {sequence}\\") # Output: [10, 22, 33, 50, 60] ``` Above example clarifies how the methods should behave with a given input list `[10, 22, 9, 33, 21, 50, 41, 60]` where the longest increasing subsequence is `[10, 22, 33, 50, 60]`, being of length 5.","solution":"class LongestIncreasingSubsequence: def find_lis_length(self, arr): if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def find_lis_sequence(self, arr): if not arr: return [] n = len(arr) lis = [1] * n prev = [-1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 prev[i] = j lis_length = max(lis) index = lis.index(lis_length) sequence = [] while index != -1: sequence.append(arr[index]) index = prev[index] return sequence[::-1]"},{"question":"# Custom Stack Implementation with Minimum Element Retrieval Objective: You are tasked to implement a new stack class, `MinStack`, that supports the following core functionalities: 1. Push elements onto the stack. 2. Pop elements from the stack. 3. Retrieve the minimum element in constant time. Requirements: 1. Implement the class `MinStack` without using any additional imports. 2. Ensure the `get_min` method retrieves the current minimum element in O(1) time. 3. Implement and maintain all necessary methods to achieve the task correctly. Class Definition: ```python class MinStack: def __init__(self) -> None: self.stack = [] # Main stack to store elements self.min_stack = [] # Stack to keep track of minimum elements def push(self, item: int) -> None: self.stack.append(item) # Only push the item onto the min_stack if it\'s smaller than or equal to the current minimum if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") item = self.stack.pop() # If the popped item is the current minimum, pop it from min_stack as well if item == self.min_stack[-1]: self.min_stack.pop() return item def top(self) -> int: if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1] ``` Testing: - Develop multiple test cases to verify: 1. Normal push and pop sequences. 2. Correct retrieval of the minimum element after various operations. 3. Edge cases like empty stack operations, stacks with duplicate elements, and single element stacks. Example: ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.get_min()) # 3 stack.push(2) stack.push(2) print(stack.get_min()) # 2 stack.pop() print(stack.get_min()) # 2 stack.pop() print(stack.get_min()) # 3 stack.pop() print(stack.get_min()) # 3 stack.pop() try: print(stack.get_min()) except IndexError as e: print(e) # get_min from empty stack ``` **Output**: ```shell 3 2 2 3 3 get_min from empty stack ``` Ensure to handle edge cases and validate the constant time complexity of `get_min` through comprehensive testing.","solution":"class MinStack: def __init__(self) -> None: self.stack = [] # Main stack to store elements self.min_stack = [] # Stack to keep track of minimum elements def push(self, item: int) -> None: self.stack.append(item) # Only push the item onto the min_stack if it\'s smaller than or equal to the current minimum if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") item = self.stack.pop() # If the popped item is the current minimum, pop it from min_stack as well if item == self.min_stack[-1]: self.min_stack.pop() return item def top(self) -> int: if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"Coding Assessment Question # Context You are developing a text search engine and need to implement a function that efficiently finds all documents containing a specific keyword. To optimize the search, you decide to use a Trie (prefix tree) data structure. # Task Implement a Trie data structure and provide a function to find all documents containing a given keyword. # Function Specifications **Function 1: Build the Trie** - **Function Name**: `build_trie` - **Input**: A dictionary where the key is the document ID (an integer), and the value is the document text (a string) (`documents: Dict[int, str]`). - **Output**: The root of the Trie (`TrieNode`). **Function 2: Search for Keyword** - **Function Name**: `search_keyword` - **Input**: - The root of the Trie (`root: TrieNode`). - A keyword string (`keyword: str`). - **Output**: A list of document IDs (`List[int]`) that contain the keyword. # Constraints - Document IDs are unique integers. - Document text is comprised of lowercase alphabetic characters and spaces only. - The keyword search is case-sensitive. - Assume that documents and keywords are non-empty. # Performance Requirements - Building the Trie should aim to be efficient in terms of both time and space complexity. - Searching for a keyword should aim for logarithmic time complexity, particularly for large sets of documents. # Example Usage ```python documents = { 1: \\"machine learning is fascinating\\", 2: \\"artificial intelligence is a subset of machine learning\\", 3: \\"deep learning is a crucial part of machine learning\\", 4: \\"natural language processing is a field of machine learning\\" } root = build_trie(documents) keyword = \\"machine\\" result = search_keyword(root, keyword) print(result) # Expected output: [1, 2, 3, 4] ``` # Notes - Ensure that your Trie data structure efficiently handles the given constraints. - Be mindful of edge cases, such as searching for a keyword not present in any documents. - Consider the preprocessing steps required to convert and store documents in the Trie format. [Use the following helper class as a template for TrieNode if needed] ```python class TrieNode: def __init__(self): self.children = {} self.document_ids = set() ```","solution":"from typing import Dict, List class TrieNode: def __init__(self): self.children = {} self.document_ids = set() def build_trie(documents: Dict[int, str]) -> TrieNode: root = TrieNode() for doc_id, text in documents.items(): words = text.split() for word in words: current = root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.document_ids.add(doc_id) return root def search_keyword(root: TrieNode, keyword: str) -> List[int]: current = root for char in keyword: if char not in current.children: return [] current = current.children[char] return list(current.document_ids)"},{"question":"# Coding Assessment Question Scenario & Context You are developing a traffic simulation program that models the behavior of vehicles at intersections. One of the critical components of this simulation is to ensure that all vehicles follow the traffic light rules properly and do not collide. Specifically, you need to implement functionalities to determine whether a vehicle can proceed through an intersection based on the current traffic light state and the vehicle\'s position. Problem Statement Implement two functions `can_proceed_through_red` and `distance_to_stop` to evaluate the behavior of vehicles at intersections. 1. **can_proceed_through_red**: This function should determine if a vehicle can legally proceed through an intersection when the light is red, depending on the vehicle\'s speed and distance to the intersection. 2. **distance_to_stop**: This function should calculate the minimum distance required for a vehicle to come to a complete stop, given its current speed and the deceleration rate. Function Specifications 1. **can_proceed_through_red** function: - **Input**: - `vehicle_speed` (float): Speed of the vehicle in meters per second. - `distance_to_intersection` (float): Distance from the vehicle to the intersection in meters. - **Output**: - (bool): True if the vehicle can legally proceed through the red light; False otherwise. - **Constraints**: - The vehicle speed must be a positive float or zero. - The distance to the intersection must be a non-negative float. - **Error Handling**: - Raise an error if vehicle speed is negative. - Raise an error if distance to the intersection is negative. - **Assumptions**: - The vehicle can only proceed legally if it cannot stop safely before the intersection when the light is red. 2. **distance_to_stop** function: - **Input**: - `vehicle_speed` (float): Speed of the vehicle in meters per second. - `deceleration_rate` (float): Deceleration rate of the vehicle in meters per second squared. - **Output**: - (float): Distance required to stop in meters. - **Constraints**: - The vehicle speed must be a positive float or zero. - The deceleration rate must be a positive float. - **Error Handling**: - Raise an error if vehicle speed is negative. - Raise an error if deceleration rate is non-positive. Example ```python # Example 1 can_proceed_through_red(15.0, 10.0) # Output: False # Example 2 distance_to_stop(25.0, 5.0) # Output: 62.5 ``` Note * Ensure to account for all specified constraints and raise appropriate errors where necessary. * For the purpose of these calculations, assume constant deceleration and no other forces acting on the vehicle (like friction, air resistance, etc.).","solution":"def can_proceed_through_red(vehicle_speed, distance_to_intersection): Determines if a vehicle can legally proceed through an intersection when the light is red. Parameters: - vehicle_speed (float): Speed of the vehicle in meters per second. - distance_to_intersection (float): Distance from the vehicle to the intersection in meters. Returns: - bool: True if the vehicle can legally proceed through the red light; False otherwise. Raises: - ValueError: If vehicle speed is negative or distance to intersection is negative. if vehicle_speed < 0: raise ValueError(\\"Vehicle speed cannot be negative.\\") if distance_to_intersection < 0: raise ValueError(\\"Distance to intersection cannot be negative.\\") # Assuming a typical deceleration rate of 8 m/s^2 which is common for cars deceleration_rate = 8.0 # Calculate the stopping distance stopping_distance = distance_to_stop(vehicle_speed, deceleration_rate) # If the stopping distance is greater than or equal to the distance to the intersection, the vehicle cannot stop safely return stopping_distance > distance_to_intersection def distance_to_stop(vehicle_speed, deceleration_rate): Calculates the minimum distance required for a vehicle to come to a complete stop given its speed and deceleration rate. Parameters: - vehicle_speed (float): Speed of the vehicle in meters per second. - deceleration_rate (float): Deceleration rate of the vehicle in meters per second squared. Returns: - float: Distance required to stop in meters. Raises: - ValueError: If vehicle speed is negative or deceleration rate is non-positive. if vehicle_speed < 0: raise ValueError(\\"Vehicle speed cannot be negative.\\") if deceleration_rate <= 0: raise ValueError(\\"Deceleration rate must be positive.\\") # Using the formula: stopping_distance = (vehicle_speed)^2 / (2 * deceleration_rate) stopping_distance = (vehicle_speed ** 2) / (2 * deceleration_rate) return stopping_distance"},{"question":"# Problem Statement Context: You are asked to develop a simple simulation of a queue system to manage customers in a bank. This simulation will help in understanding how queues operate in a practical scenario and to ensure smooth handling of customer service operations. Instructions: 1. **Create a `CustomerQueue` class**: - Implement methods to add a customer to the queue and to serve (remove) a customer from the queue. - Add input validation to handle non-string values by raising a `TypeError` exception when adding a customer. 2. **Implement the following methods**: - `enqueue(customer: str) -> None`: Adds a customer to the end of the queue. - `dequeue() -> str`: Removes and returns the customer from the front of the queue. Raises `IndexError` if the queue is empty. - `size() -> int`: Returns the current number of customers in the queue. Specifications: - **Class and Method Signatures**: ```python class CustomerQueue: def __init__(self): ... def enqueue(self, customer: str) -> None: ... def dequeue(self) -> str: ... def size(self) -> int: ... ``` - **Input/Output Examples**: ```python >>> queue = CustomerQueue() >>> queue.enqueue(\\"Alice\\") >>> queue.enqueue(\\"Bob\\") >>> queue.size() 2 >>> queue.dequeue() \'Alice\' >>> queue.size() 1 >>> queue.dequeue() \'Bob\' >>> queue.dequeue() Traceback (most recent call last): ... IndexError: Cannot dequeue from an empty queue. >>> queue.enqueue(123) Traceback (most recent call last): ... TypeError: Customer name must be a string. ``` - **Constraints**: - The `enqueue` method should only accept strings as valid customer names. - The queue should handle incorrect types by raising appropriate exceptions. - The `dequeue` method should raise an `IndexError` if an attempt is made to remove a customer from an empty queue. - **Performance Requirements**: - Ensure that the queue operations (`enqueue` and `dequeue`) are implemented efficiently with an average time complexity of O(1) for both operations. Use the given information to implement the `CustomerQueue` class and its methods as specified. Ensure proper handling of edge cases and exceptions as outlined.","solution":"class CustomerQueue: def __init__(self): self._queue = [] def enqueue(self, customer: str) -> None: if not isinstance(customer, str): raise TypeError(\\"Customer name must be a string.\\") self._queue.append(customer) def dequeue(self) -> str: if len(self._queue) == 0: raise IndexError(\\"Cannot dequeue from an empty queue.\\") return self._queue.pop(0) def size(self) -> int: return len(self._queue)"},{"question":"# Context: You have been given an implementation of a priority queue using a binary min-heap. Your task is to ensure the queue maintains its integrity and efficiency as elements are added and removed. The heap should dynamically handle these operations while preserving the min-heap property. # Problem: 1. Write a method `heapify_down(self, index)` that ensures the element at the given index satisfies the min-heap property, adjusting the position of elements as needed. 2. Write a method `delete_min(self)` that removes and returns the smallest element from the heap while maintaining the min-heap property. # Implementation Details: - Class definition: `class MinHeapPriorityQueue:` - Methods to implement: * `def heapify_down(self, index):` * `def delete_min(self):` # Input: - `heapify_down()` takes a single parameter: * `index` (int): The index of the element to heapify down. - `delete_min()` takes no parameters. # Output: - `heapify_down()` will adjust the internal state of the heap to maintain the min-heap property and return `None`. - `delete_min()` will remove and return the smallest element from the heap. # Constraints: - You can assume all elements are comparable. - Do not use any built-in heap libraries or functions. # Performance Requirements: - `heapify_down(self, index)` should have a time complexity of O(log n), where n is the number of elements in the heap. - `delete_min(self)` should have a time complexity of O(log n). # Example Usage: ```python heap = MinHeapPriorityQueue() # Adding elements to the heap heap.insert(5) heap.insert(3) heap.insert(8) # Deleting the minimum element min_element = heap.delete_min() # Should return 3 # Adjusting the heap starting from a specific index heap.heapify_down(1) ``` # Your Task: Implement the methods `heapify_down` and `delete_min` in the class `MinHeapPriorityQueue` to ensure the priority queue operates efficiently and maintains the min-heap property.","solution":"class MinHeapPriorityQueue: def __init__(self): self.heap = [] def insert(self, value): self.heap.append(value) self.heapify_up(len(self.heap) - 1) def heapify_up(self, index): parent = (index - 1) // 2 if index and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self.heapify_up(parent) def heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self.heapify_down(smallest) def delete_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self.heapify_down(0) return root"},{"question":"# Coding Assessment Question Context: Binary trees are a fundamental data structure in computer science, used in various applications such as searching, sorting, and hierarchical representations. They provide a basis for more complex structures like binary search trees, heaps, and syntax trees. Problem Statement: Given a binary tree, determine the length of the longest path where each consecutive pair of nodes in the path have an increasing value. The path can start and end at any node in the tree, but the values must be strictly increasing along the path. Guidelines: 1. Implement a class `TreeNode` to represent the nodes of the tree. 2. Write a function `longest_increasing_path(root: TreeNode) -> int` that returns the length of the longest path with strictly increasing values. Input Format: - A `TreeNode` object `root` representing the root of the binary tree. Output Format: - An integer representing the length of the longest path with strictly increasing values. Example: Input: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(20) root.right.right.left = TreeNode(18) ``` Output: ```python 4 ``` Explanation: The longest path with strictly increasing values is [10 -> 15 -> 18 -> 20], which has length 4. Constraints: - The number of nodes in the tree is in the range ([1, 10^4]). - The values of the nodes are integers within the range ([-10^4, 10^4]). Function Signature: ```python def longest_increasing_path(root: TreeNode) -> int: pass ``` Performance Requirements: - The solution should efficiently traverse the tree to compute the required increasing paths within a reasonable time frame.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root: TreeNode) -> int: def dfs(node, parent_val): if not node: return 0 left_length = dfs(node.left, node.val) right_length = dfs(node.right, node.val) max_length = 1 # Single node path if node.left and node.left.val > node.val: max_length = max(max_length, 1 + left_length) if node.right and node.right.val > node.val: max_length = max(max_length, 1 + right_length) longest_path[0] = max(longest_path[0], max_length) return max_length if not root: return 0 longest_path = [0] dfs(root, float(\'-inf\')) return longest_path[0]"},{"question":"# Coding Assessment Question Context: In various applications of computer science, understanding the properties of Fibonacci sequences can help solve complex computational problems. A special variant of Fibonacci sequence, called \\"Tribonacci\\", extends the concept by summing the last three terms to generate the next term. Problem Statement: Given an integer ( n ), compute the ( n )-th Tribonacci number, where the sequence is defined as: [ T_0 = 0, quad T_1 = 1, quad T_2 = 1 ] [ T_n = T_{n-1} + T_{n-2} + T_{n-3} quad text{for} quad n geq 3 ] Write a function `tribonacci_number(n: int) -> int` that returns the ( n )-th Tribonacci number. Input Format: - A single integer ( n ) representing the position in the Tribonacci sequence. Output Format: - An integer representing the ( n )-th Tribonacci number. Example: Input: ```python n = 10 ``` Output: ```python 149 ``` Constraints: - Assume ( 0 leq n leq 10^4 ). Function Signature: ```python def tribonacci_number(n: int) -> int: pass ``` Performance Requirements: - The solution should efficiently compute the nth Tribonacci number even for large values of ( n ).","solution":"def tribonacci_number(n: int) -> int: Returns the nth Tribonacci number. if n == 0: return 0 elif n == 1 or n == 2: return 1 a, b, c = 0, 1, 1 for _ in range(3, n + 1): a, b, c = b, c, a + b + c return c"},{"question":"# Coding Assessment Question Scenario: You\'re working with a database system and often need to calculate the Least Common Multiple (LCM) of large sets of integers. This is particularly important for synchronizing processes running at different intervals. You need to create a function that efficiently computes the LCM of an array of integers. Task: Write a Python function to compute the Least Common Multiple (LCM) of an array of positive integers. The function should be efficient even for large inputs. Function Signature: ```python def compute_lcm(arr: List[int]) -> int: ``` Input: * A list of integers `arr` (1 ≤ len(arr) ≤ 10^5) (1 ≤ arr[i] ≤ 10^9) Output: * An integer representing the LCM of the given array. Examples: ```python assert compute_lcm([2, 7, 3, 9, 4]) == 252 assert compute_lcm([5, 10, 20]) == 20 assert compute_lcm([1, 1, 1]) == 1 assert compute_lcm([3, 15, 27]) == 135 assert compute_lcm([6, 8, 12]) == 24 ``` Notes: - The LCM of two numbers `a` and `b` can be found using the formula `LCM(a, b) = abs(a*b) // GCD(a, b)`, where GCD is the Greatest Common Divisor. - Extend this formula to find the LCM of an array by iteratively applying it to pairs of numbers. - Ensure the function handles large numbers and large arrays efficiently. - You may use libraries such as `math` for GCD computation.","solution":"from typing import List from math import gcd from functools import reduce def lcm(a, b): return abs(a * b) // gcd(a, b) def compute_lcm(arr: List[int]) -> int: return reduce(lcm, arr)"},{"question":"# Scenario You are tasked with creating an application that is able to extract and manipulate information from a large collection of user logs. Each log entry contains a timestamp and a user action. Users may perform multiple actions, and the application should provide efficient ways to track and analyze these actions over varying time periods. # Task Implement a Segment Tree data structure to handle the following query types efficiently: 1. **Sum Query**: Return the total number of user actions in a given time interval. 2. **Maximum Query**: Identify the maximum number of actions performed by any user in a given time interval. 3. **Update Query**: Increment the count of user actions at a specific timestamp. # Input and Output Format * **Input**: 1. `logs` - An initial list of `m` integers where each integer represents the count of user actions at that timestamp. 2. `queries` - A list of dictionary objects, each with: - `type` - One of `\'sum\'`, `\'max\'`, or `\'update\'`. - Additional parameters based on `type`: - For `\'sum\'`: `start`, `end` (time interval). - For `\'max\'`: `start`, `end` (time interval). - For `\'update\'`: `timestamp`, `increment`. * **Output**: - A list of integers, each being the result of a corresponding query. # Constraints - The list `logs` will contain integers where (0 leq logs[i] leq 10^3). - The length of `logs` `m` will be up to (2 times 10^5). - The number of queries will be up to (2 times 10^4). Your implementation should prioritize efficient handling of queries. # Example ```python from typing import List, Dict, Union Query = Dict[str, Union[str, int]] def segment_tree(queries: List[Query], logs: List[int]) -> List[int]: # Your implementation here with the Segment Tree for efficient query handling pass # Example usage: test_logs = [1, 3, 2, 5, 4, 1, 0, 6, 2, 3, 4, 5] test_queries = [ {\\"type\\": \\"sum\\", \\"start\\": 2, \\"end\\": 5}, {\\"type\\": \\"max\\", \\"start\\": 1, \\"end\\": 7}, {\\"type\\": \\"update\\", \\"timestamp\\": 4, \\"increment\\": 3} ] print(segment_tree(test_queries, test_logs)) # Expected output: [12, 6, None] # Explanation: sum(2-5) = 12, max(1-7) = 6, after update logs[4] should have incremented by 3 ```","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree_sum = [0] * (2 * self.n) self.tree_max = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree_sum[self.n + i] = data[i] self.tree_max[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree_sum[i] = self.tree_sum[2 * i] + self.tree_sum[2 * i + 1] self.tree_max[i] = max(self.tree_max[2 * i], self.tree_max[2 * i + 1]) def update(self, pos, value): pos += self.n self.tree_sum[pos] += value self.tree_max[pos] += value pos //= 2 while pos > 0: self.tree_sum[pos] = self.tree_sum[2 * pos] + self.tree_sum[2 * pos + 1] self.tree_max[pos] = max(self.tree_max[2 * pos], self.tree_max[2 * pos + 1]) pos //= 2 def sum_range(self, l, r): l += self.n r += self.n sum_val = 0 while l < r: if l % 2: sum_val += self.tree_sum[l] l += 1 if r % 2: r -= 1 sum_val += self.tree_sum[r] l //= 2 r //= 2 return sum_val def max_range(self, l, r): l += self.n r += self.n max_val = float(\'-inf\') while l < r: if l % 2: max_val = max(max_val, self.tree_max[l]) l += 1 if r % 2: r -= 1 max_val = max(max_val, self.tree_max[r]) l //= 2 r //= 2 return max_val def segment_tree(queries, logs): seg_tree = SegmentTree(logs) results = [] for query in queries: qtype = query[\\"type\\"] if qtype == \\"sum\\": l = query[\\"start\\"] r = query[\\"end\\"] results.append(seg_tree.sum_range(l, r + 1)) elif qtype == \\"max\\": l = query[\\"start\\"] r = query[\\"end\\"] results.append(seg_tree.max_range(l, r + 1)) elif qtype == \\"update\\": timestamp = query[\\"timestamp\\"] increment = query[\\"increment\\"] seg_tree.update(timestamp, increment) results.append(None) return results"},{"question":"# Matrix Transpose You are tasked with performing a common operation on matrices: transposing. Transposing a matrix means switching the rows and columns of the matrix. Objective Write a function `transpose` that takes a 2D list (matrix) and returns its transpose. Function Signature ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: ``` # Input - A 2D list of integers `matrix` with `m` rows and `n` columns. # Output - A 2D list representing the transpose of the input matrix, which will have `n` rows and `m` columns. # Constraints - `1 <= m, n <= 1000` - `-10^9 <= matrix[i][j] <= 10^9` for all valid `i` and `j` # Examples ```python assert transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert transpose([[1]]) == [[1]] assert transpose([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert transpose([[2]]) == [[2]] ``` **Explanation**: 1. For the first example, transposing `[[1, 2, 3], [4, 5, 6]]` produces `[[1, 4], [2, 5], [3, 6]]`. 2. For the second example, transposing `[[1]]` produces `[[1]]` as a single element matrix remains the same. 3. For the third example, transposing `[[1, 2], [3, 4], [5, 6]]` produces `[[1, 3, 5], [2, 4, 6]]`. 4. For the fourth example, transposing a single element matrix `[[2]]` produces `[[2]]`. # Requirements - Ensure your implementation handles varying sizes of matrices efficiently. - Consider and handle edge cases such as the function receiving matrices with only one element or matrices that are already transposed.","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a given 2D list (matrix). Parameters: matrix (List[List[int]]): A 2D list of integers with `m` rows and `n` columns Returns: List[List[int]]: The transposed matrix with `n` rows and `m` columns return [list(row) for row in zip(*matrix)]"},{"question":"**Context**: A software company is developing an application to analyze financial investments, focusing on stock portfolio performance over time. The software must provide key performance indicators and insights based on historical price data for different stocks. **Task**: Write a function that calculates the Compound Annual Growth Rate (CAGR) of a stock given its initial price, final price, and the number of years. # Requirements: * Implement a function named `calculate_cagr` in Python. * The inputs will be: - `initial_price`: float, Initial price of the stock. - `final_price`: float, Final price of the stock. - `years`: float, Number of years over which the growth is measured. * The output should be the CAGR value as a float, rounded to 4 decimal places. # Additional Constraints: * Handle cases where the initial price or final price might be zero (which should not occur in a real-world scenario, but the function should handle it gracefully). * Assume the number of years is always greater than zero and is a positive float. * Ensure to return a result even for very large or very small inputs. # Function Signature: ```python def calculate_cagr( initial_price: float, final_price: float, years: float ) -> float: pass ``` # Example: ```python >>> calculate_cagr(100, 200, 5) 0.1487 >>> calculate_cagr(1000, 500, 2) -0.2929 ``` # Hint: Use the formula for CAGR: [ text{CAGR} = left(frac{text{final_price}}{text{initial_price}}right)^{frac{1}{text{years}}} - 1 ]","solution":"def calculate_cagr(initial_price, final_price, years): Calculates the Compound Annual Growth Rate (CAGR). Parameters: initial_price (float): Initial price of the stock. final_price (float): Final price of the stock. years (float): Number of years over which the growth is measured. Returns: float: The CAGR value rounded to 4 decimal places. if initial_price <= 0 or final_price < 0: return 0.0 cagr = (final_price / initial_price) ** (1 / years) - 1 return round(cagr, 4) # Examples print(calculate_cagr(100, 200, 5)) # Should be 0.1487 print(calculate_cagr(1000, 500, 2)) # Should be -0.2929"},{"question":"# Question **Generate and Sort Random Matrix Diagonally** Your task is to write a function that generates a square matrix of arbitrary size with random integers and then returns a new matrix where each diagonal from top-left to bottom-right is sorted in non-decreasing order. Requirements 1. Implement the `generate_and_sort_matrix` function. 2. The function should take the following parameters: - `n` (int): The size of the matrix (n x n). - `min_value` (int): The minimum value for the random integers. - `max_value` (int): The maximum value for the random integers. 3. The function should return an n x n numpy array where each diagonal is sorted in non-decreasing order. **Constraints:** - `n` should be a positive integer greater than 1. - `min_value` should be less than or equal to `max_value`. Notes: - You can use `numpy` for matrix operations and `random` for generating the integers. - Run the sorting algorithm on each diagonal independently, ensuring that the starting and ending points of the diagonals are correctly identified. **Example:** ```python import numpy as np def generate_and_sort_matrix(n, min_value, max_value): # Your implementation here pass # Example usage: matrix = generate_and_sort_matrix(4, 0, 9) print(matrix) ``` If the generated matrix was: ``` [3, 4, 2, 1] [4, 6, 5, 2] [9, 0, 1, 8] [4, 7, 3, 6] ``` A possible output after sorting diagonals would be: ``` [3, 4, 2, 1] [4, 3, 5, 2] [4, 0, 1, 6] [9, 6, 7, 8] ``` **Additional Tests:** ```python def test_case_1(): matrix = generate_and_sort_matrix(2, 0, 3) assert matrix.shape == (2, 2) assert np.all(matrix >= 0) and np.all(matrix <= 3) def test_case_2(): matrix = generate_and_sort_matrix(3, -5, 5) assert matrix.shape == (3, 3) assert np.all(matrix >= -5) and np.all(matrix <= 5) def test_case_3(): matrix = generate_and_sort_matrix(5, 10, 20) assert matrix.shape == (5, 5) assert np.all(matrix >= 10) and np.all(matrix <= 20) # Ensure diagonals are sorted for d in range(5): diag = [matrix[i][d+i] for i in range(5-d)] assert diag == sorted(diag) ``` Write your implementation to fulfill these requirements and pass the provided test cases.","solution":"import numpy as np import random def generate_and_sort_matrix(n, min_value, max_value): Generates an n x n matrix with random integers between min_value and max_value, and then returns the matrix with each diagonal sorted in non-decreasing order. :param n: int - the size of the matrix (n x n) :param min_value: int - the minimum value for the random integers :param max_value: int - the maximum value for the random integers :return: numpy array - the n x n matrix with sorted diagonals # Generate the n x n matrix with random integers matrix = np.array([[random.randint(min_value, max_value) for _ in range(n)] for _ in range(n)]) # Function to sort and set a diagonal def sort_and_set_diagonal(matrix, i, j): vals = [] x, y = i, j while x < n and y < n: vals.append(matrix[x][y]) x += 1 y += 1 vals.sort() x, y = i, j idx = 0 while x < n and y < n: matrix[x][y] = vals[idx] x += 1 y += 1 idx += 1 # Sort diagonals starting from each element in the first row for j in range(n): sort_and_set_diagonal(matrix, 0, j) # Sort diagonals starting from each element in the first column (excluding the [0,0]) for i in range(1, n): sort_and_set_diagonal(matrix, i, 0) return matrix"},{"question":"# Question: Smallest Divisible Number Context Finding the smallest number that is divisible by a subset of integers enhances understanding of number theory and efficient algorithm design. Task Write a function `smallest_divisible(max_divisor: int) -> int` that computes the smallest positive number that is evenly divisible by all numbers from 1 to (max_divisor). Input - An integer (max_divisor) (1 ≤ (max_divisor) ≤ 20). Output - Return an integer which is the smallest number divisible by all integers from 1 to (max_divisor). Constraints - You may use built-in functions from the `math` module for efficient calculation. - Ensure your solution handles edge cases, such as the smallest and largest possible values of (max_divisor). Example ```python def smallest_divisible(max_divisor: int) -> int: # Implement your function here pass # Example usage: print(smallest_divisible(10)) # Output: 2520 print(smallest_divisible(15)) # Output: 360360 ``` Note - Consider the mathematical properties of the least common multiple (LCM) to optimize your function. - Efficiently handle the computation to avoid overflow and ensure the function runs within a reasonable time for the given constraints.","solution":"import math from functools import reduce def lcm(a, b): Compute the least common multiple of a and b. return abs(a * b) // math.gcd(a, b) def smallest_divisible(max_divisor: int) -> int: Returns the smallest positive number that is evenly divisible by all numbers from 1 to max_divisor. return reduce(lcm, range(1, max_divisor + 1))"},{"question":"# Problem Statement: You are tasked with implementing a function to compute the average distance between points in a 2D plane, given in Cartesian coordinates. This function will be useful in analyzing the spatial distribution of points, such as in geographical information systems or sensor networks. # Function Signature: ```python def average_distance(points: List[Tuple[float, float]]) -> float: pass ``` # Input: * `points` (List[Tuple[float, float]]): A list of tuples, each containing two float values representing the x and y coordinates of a point. # Output: * Returns a float value representing the average distance between all pairs of points. # Constraints: * The list `points` will contain at least two points. * The coordinates of the points can be very small or very large (absolute values up to `10^6`). # Example: ```python def average_distance(points: List[Tuple[float, float]]) -> float: from math import sqrt total_distance = 0 num_pairs = 0 for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] distance = sqrt((x2 - x1)**2 + (y2 - y1)**2) total_distance += distance num_pairs += 1 if num_pairs == 0: return 0 return total_distance / num_pairs # Example Usage print(average_distance([(0, 0), (1, 0), (0, 1)])) # Output: 0.943396 ``` # Requirements: 1. Implement the function `average_distance` that fulfills the objectives. 2. Ensure the function handles potential edge cases, such as extremely close or extremely distant points. 3. Test the function thoroughly with various distributions and quantities of points. # Hints: 1. Consider the Euclidean distance formula for calculating the distance between two points. 2. Use nested loops to calculate the distance between every pair of points efficiently. 3. To improve readability and maintainability, utilize Python\'s standard math library for calculations.","solution":"from typing import List, Tuple from math import sqrt def average_distance(points: List[Tuple[float, float]]) -> float: total_distance = 0 num_pairs = 0 for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] distance = sqrt((x2 - x1)**2 + (y2 - y1)**2) total_distance += distance num_pairs += 1 if num_pairs == 0: return 0 return total_distance / num_pairs"},{"question":"# Coding Assessment Question Context In certain digital systems, cyclic patterns are used to represent and analyze periodic signals. One common way to represent a cycle is by using a modulo operation to wrap the values within a specific range. Task Implement a function `cyclic_pattern` that generates a list of integers representing a cyclic pattern given a specific length and range. The pattern should start from 0 and cycle through values from 0 to `m-1`. Function Signature ```python def cyclic_pattern(length: int, m: int) -> List[int]: ``` Input - `length` (integer): The length of the resulting list. `1 <= length <= 100`. - `m` (integer): The range for the cycle. `1 <= m <= 50`. Output - A list of integers of specified length, where each integer is between `0` and `m-1`, inclusive, and they follow a cyclic pattern: `[0, 1, 2, ..., m-1, 0, 1, 2, ..., m-1, ...]`. Example - Input: `length = 7`, `m = 3` - Output: `[0, 1, 2, 0, 1, 2, 0]` - Explanation: The sequence repeats every 3 numbers in the pattern `[0, 1, 2]`. Constraints - Ensure the generated pattern wraps correctly at the specified range without going out of bounds. Requirements * **Edge Cases**: Handle cases where `length` or `m` is at its minimum value. * **Performance**: The function should run efficiently within the given constraints. Write a well-tested function to generate the cyclic pattern. Make sure your implementation is robust and handles all edge cases.","solution":"from typing import List def cyclic_pattern(length: int, m: int) -> List[int]: Generates a list that represents a cyclic pattern given a specific length and range. Parameters: - length (int): The length of the resulting list. - m (int): The range for the cycle. Returns: - List[int]: A list of integers of specified length, cycling through numbers 0 to m-1. pattern = [] for i in range(length): pattern.append(i % m) return pattern"},{"question":"# Sorting a List of Points Based on Distance Given a list of points in a 2D plane, write a program to sort the points based on their distance from the origin (0, 0). The distance between a point (x, y) and the origin is given by the Euclidean distance formula: √(x² + y²). If two points have the same distance from the origin, they should appear in the output based on the order they appear in the input list. # Task 1. Implement a method to calculate the Euclidean distance of each point from the origin. 2. Create a function to sort the list of points based on their distance from the origin. Function Signature ```python def sort_points(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts the list of points based on their distance from the origin. ``` Input and Output Specifications: - **Input**: A list of tuples, where each tuple contains two integers representing the x and y coordinates of a point respectively. - **Output**: A list of tuples representing the sorted points based on their Euclidean distance from the origin. Constraints: - The list may contain zero or more points. - The coordinates of the points are within the range of -10,000 to 10,000. # Example 1. Given input: ```python points = [(3, 4), (1, 1), (0, 5), (2, 2), (5, 0)] ``` 2. After sorting: ```python sorted_points = sort_points(points) # Output: [(1, 1), (2, 2), (3, 4), (0, 5), (5, 0)] ``` - Explanation: - (1, 1) has a distance of √2. - (2, 2) has a distance of √8. - (3, 4) has a distance of √25. - (0, 5) has a distance of √25. - (5, 0) has a distance of √25. # Additional Notes - Ensure your sorting logic maintains stability, i.e., if two points have the same distance from the origin, they should appear in the output in the same order as they appear in the input list. - This exercise tests understanding of list operations, sorting algorithms, and handling geometric data properly in python. Good luck!","solution":"from typing import List, Tuple import math def sort_points(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts the list of points based on their distance from the origin. # Calculate the Euclidean distance for each point def distance(point: Tuple[int, int]) -> float: return math.sqrt(point[0]**2 + point[1]**2) # Sort the points based on their distances return sorted(points, key=distance)"},{"question":"# Scenario You are developing an optimized real-time tracking system for a fleet of delivery vehicles. Each vehicle transmits its location periodically, and you need to ensure that this data is efficiently managed and can be queried for various purposes. Part of this system includes the ability to retrieve the latest location for any given vehicle at any time. # Task You need to write two functions, `add_location` and `get_latest_location`, that will handle adding locations and retrieving the latest location for vehicles. # Details 1. **add_location(vehicle_id: str, location: tuple) -> None**: * Takes a vehicle ID and a tuple representing the location `(latitude, longitude)`, and updates the location for that vehicle. 2. **get_latest_location(vehicle_id: str) -> tuple**: * Takes a vehicle ID and returns the latest location tuple `(latitude, longitude)` for that vehicle. If the vehicle ID does not exist, return `None`. # Input and Output * **Input Format**: * For `add_location`: The input consists of a string `vehicle_id` and a tuple `location` with two float elements representing latitude and longitude. * For `get_latest_location`: The input consists of a string `vehicle_id`. * **Output Format**: * The `add_location` function does not return anything. * The `get_latest_location` function returns a tuple `(latitude, longitude)` or `None` if the vehicle ID does not exist. # Constraints * Vehicle IDs are unique strings. * Location tuples consist of two floats, representing valid latitude and longitude values. * The system may receive numerous location updates, so the solution should handle high-frequency updates efficiently. # Examples * Example 1: ```python add_location(\'V123\', (34.0522, -118.2437)) get_latest_location(\'V123\') # (34.0522, -118.2437) ``` * Example 2: ```python add_location(\'V123\', (34.0522, -118.2437)) add_location(\'V123\', (34.0523, -118.2440)) get_latest_location(\'V123\') # (34.0523, -118.2440) ``` * Example 3: ```python get_latest_location(\'V999\') # None ``` # Additional Considerations 1. Ensure your solution handles the edge cases correctly, such as querying a vehicle ID that has never been added or updating the location of multiple vehicles. 2. Implement the solution efficiently to handle numerous updates and queries without significant performance degradation. 3. Consider using appropriate data structures to manage the locations for quick retrieval and updates.","solution":"vehicle_locations = {} def add_location(vehicle_id, location): Updates the location for the given vehicle ID. Args: vehicle_id (str): The ID of the vehicle. location (tuple): A tuple containing (latitude, longitude) floats. Returns: None vehicle_locations[vehicle_id] = location def get_latest_location(vehicle_id): Retrieves the latest location for the given vehicle ID. Args: vehicle_id (str): The ID of the vehicle. Returns: tuple or None: The latest (latitude, longitude) tuple, or None if the vehicle ID does not exist. return vehicle_locations.get(vehicle_id)"},{"question":"# Matrix Product Computation To further enhance your skills in handling multidimensional arrays and performing matrix operations, your task is to implement a function that computes the product of two square matrices using the classical algorithm. The product ( C ) of two matrices ( A ) and ( B ) of size ( n times n ) is defined as: [ C[i][j] = sum_{k=0}^{n-1} A[i][k] times B[k][j] ] # Function Signature ```python def matrix_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: ``` # Parameters - `matrix_a` (List[List[int]]): A square matrix of integers ( n times n ). - `matrix_b` (List[List[int]]): Another square matrix of integers ( n times n ). # Returns - `List[List[int]]`: A new ( n times n ) matrix representing the product of `matrix_a` and `matrix_b`. # Constraints - Both matrices `matrix_a` and `matrix_b` are guaranteed to be square matrices with dimensions ( n times n ), where ( 0 < n leq 100 ). - The elements of the matrices are integers within the range ([-10^4, 10^4]). # Notes - Implement the matrix product using a straightforward, classical algorithm with triple for-loops. - Validate the dimensions of the input matrices before proceeding with the calculation. # Usage Example ```python >>> matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> matrix_b = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] >>> matrix_product(matrix_a, matrix_b) [[30, 24, 18], [84, 69, 54], [138, 114, 90]] >>> matrix_a = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] >>> matrix_b = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> matrix_product(matrix_a, matrix_b) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` Implement the function to ensure correct matrix multiplication and handle possible errors such as mismatched dimensions by raising appropriate exceptions where necessary.","solution":"from typing import List def matrix_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: n = len(matrix_a) # Initialize the result matrix with zeros result = [[0] * n for _ in range(n)] # Perform matrix multiplication for i in range(n): for j in range(n): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Coding Assessment Question **Objective:** Implement a function to calculate the median of values from data streams using two heaps. Problem Statement You are required to build a system that efficiently calculates the median value from a stream of integers. The system should support the addition of numbers from the stream and retrieval of the current median at any point in time. Write a class `MedianFinder` with the following methods: - `def __init__(self) -> None`: Initializes the data structure. - `def add_num(self, num: int) -> None`: Adds a number from the stream to the data structure. - `def find_median(self) -> float`: Returns the median of the current numbers in the stream. The median is the middle value in the list of numbers ordered from smallest to largest. If there is no middle value (i.e., the list has an even number of elements), the median is the average of the two middle values. You must use two heaps (a max-heap and a min-heap) to implement the `MedianFinder` class efficiently. Constraints - The class should handle at least `10^5` calls to `add_num` and `find_median`. - Integers added to the data stream are in the range `[-10^6, 10^6]`. Expected Input and Output ```python class MedianFinder: def __init__(self) -> None: # your implementation here def add_num(self, num: int) -> None: # your implementation here def find_median(self) -> float: # your implementation here # Example usage: mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2.0 ``` * `Input`: * Sequence of method calls and their parameters: * `MedianFinder()` -> Initializes the data structure. * `add_num(1)` * `add_num(2)` * `find_median()` * `add_num(3)` * `find_median()` * `Output`: * The output of `find_median` calls: * `1.5` * `2.0` Notes 1. Use two heaps (max-heap for the lower half and min-heap for the upper half) to store the numbers. 2. Ensure the heaps are balanced such that their sizes differ by at most one. 3. Provide meaningful comments and ensure the code is readable. 4. Handle any edge cases, such as the stream containing only one element.","solution":"import heapq class MedianFinder: def __init__(self) -> None: Initialize two heaps: one max-heap for the lower half and one min-heap for the upper half. In Python, heapq only provides a min-heap, so we use negative values to simulate a max-heap. self.lower_half = [] # max-heap simulated by pushing negative values self.upper_half = [] # min-heap def add_num(self, num: int) -> None: Add a number to the data structure. # Add to the max-heap (lower half) heapq.heappush(self.lower_half, -num) # Move the largest value from lower_half to upper_half to maintain order property if self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0]): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Balance the heaps: ensure the sizes differ by at most one if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: Return the median of the current numbers in the data structure. if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"# Coding Assessment Question: Implement and Validate a Binary Search Tree (BST) Iterator You are provided with an initial implementation of a Binary Search Tree (BST) with basic insertion and traversal methods. However, the current implementation does not support an efficient in-order iterator that allows traversal through the BST in ascending order without using additional space for storing the nodes. Your task is to implement this functionality. # Task Implement a `BSTIterator` class that allows efficient in-order traversal of a given binary search tree. The iterator should traverse the nodes in ascending order and use O(h) space, where h is the height of the BST. # Details * **Input**: The input is a root node of the BST. * **Output**: The output should be the next smallest number in the BST each time the iterator\'s `next()` method is called, and a boolean indicating whether there are more nodes to traverse using the `hasNext()` method. * **Constraints**: - The number of nodes in the tree will be at least 1 and at most 10,000. # Example ```python # Define a simple BSTNode class class BSTNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Build a sample BST # 7 # / # 3 15 # / # 9 20 root = BSTNode(7) root.left = BSTNode(3) root.right = BSTNode(15) root.right.left = BSTNode(9) root.right.right = BSTNode(20) # Initialize the iterator with the root of the BST iterator = BSTIterator(root) # Call to iterator methods should produce the following : # iterator.next() -> returns 3 # iterator.hasNext() -> returns True # iterator.next() -> returns 7 # iterator.hasNext() -> returns True # iterator.next() -> returns 9 # iterator.hasNext() -> returns True # iterator.next() -> returns 15 # iterator.hasNext() -> returns True # iterator.next() -> returns 20 # iterator.hasNext() -> returns False ``` # Implementation Requirements: 1. Implement the `BSTIterator` class with the following methods: - `__init__(self, root: BSTNode)`: Initializes the iterator with the root of the binary search tree. - `next(self) -> int`: Returns the next smallest number in the BST. - `hasNext(self) -> bool`: Returns whether there is a next smallest number. 2. Ensure the in-order traversal is performed in O(h) memory, where h is the height of the tree. Here\'s the signature of the `BSTIterator` class you need to implement: ```python class BSTIterator: def __init__(self, root: BSTNode): pass def next(self) -> int: pass def hasNext(self) -> bool: pass ``` Implement a solution that satisfies the outlined requirements, then write a couple of test cases to ensure your iterator functions correctly.","solution":"class BSTNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: BSTNode): Initialize the stack and push the leftmost path of the tree. self.stack = [] self._push_left_nodes(root) def _push_left_nodes(self, node: BSTNode): while node: self.stack.append(node) node = node.left def next(self) -> int: Returns the next smallest number in the BST. node = self.stack.pop() self._push_left_nodes(node.right) return node.val def hasNext(self) -> bool: Returns whether there is a next smallest number. return len(self.stack) > 0"},{"question":"# Scenario Given an integer array `arr`, your task is to find the pair of elements with the smallest absolute difference between them. # Problem Statement Write a function `smallest_abs_diff_pair` that takes an array of integers `arr` and returns a list of pairs (tuples), each containing two integers from the array that have the smallest absolute difference. If there are multiple pairs with the same smallest difference, include all such pairs in the result. # Input Format * A single list of integers `arr`. # Output Format * A list of tuples, each containing a pair of integers with the smallest absolute difference from the array. # Constraints * 2 <= len(arr) <= 10^5 * -10^6 <= arr[i] <= 10^6 # Function Signature ```python def smallest_abs_diff_pair(arr: List[int]) -> List[Tuple[int, int]]: # implementation here ``` # Examples Example 1 **Input**: ```python [4, 2, 1, 3] ``` **Output**: ```python [(1, 2), (2, 3), (3, 4)] ``` **Explanation**: The pairs with the smallest absolute difference of 1 are: (1, 2), (2, 3), and (3, 4). Example 2 **Input**: ```python [1, 3, 6, 10, 15] ``` **Output**: ```python [(1, 3)] ``` **Explanation**: The pair with the smallest absolute difference of 2 is: (1, 3). # Implementation Notes * Sort the array first to make it easier to find pairs with the smallest absolute difference. * Iterate through the sorted array to find the minimum absolute difference and then collect all pairs that have this minimum difference.","solution":"from typing import List, Tuple def smallest_abs_diff_pair(arr: List[int]) -> List[Tuple[int, int]]: if len(arr) < 2: return [] # Sort the input array arr.sort() # Initialize the minimum difference to a large number min_diff = float(\'inf\') result = [] # Traverse the sorted array to find pairs with the smallest absolute difference for i in range(1, len(arr)): diff = abs(arr[i] - arr[i - 1]) # If a new smaller difference is found, update min_diff and reset result list if diff < min_diff: min_diff = diff result = [(arr[i - 1], arr[i])] # If the same smallest difference is found, append the pair to result list elif diff == min_diff: result.append((arr[i - 1], arr[i])) return result"},{"question":"# Median of Two Sorted Arrays You have been asked to find the median of two sorted arrays. The median is the middle value in an ordered list of numbers. If the combined list of numbers has an even number of elements, the median is the average of the two middle values. Objective: Write a function that takes in two sorted lists of integers and returns their median. # Input Format: - Two sorted lists of integers `arr1` and `arr2`. # Output Format: - A single floating-point number representing the median of the two sorted arrays. # Constraints: - Each list contains between 0 and 10^6 elements. - All integers in the lists are within the range [-10^6, 10^6]. - The combined length of the two lists is between 1 and 2 * 10^6. # Performance Requirements: - The function should run efficiently with the provided input sizes. # Function Signature: ```python def find_median_sorted_arrays(arr1: List[int], arr2: List[int]) -> float: ``` # Example: ```python # Example 1 input: arr1 = [1, 3] arr2 = [2] output: 2.0 # Example 2 input: arr1 = [1, 2] arr2 = [3, 4] output: 2.5 ``` Notes: - The solution should handle edge cases, such as one list being empty. - Ensure the implementation is optimized for handling large input sizes within the specified constraints. # Challenge: Write the implementation of `find_median_sorted_arrays` function to efficiently compute the median of two sorted arrays.","solution":"def find_median_sorted_arrays(arr1, arr2): Finds the median of two sorted arrays. Parameters: arr1 (List[int]): First sorted list of integers. arr2 (List[int]): Second sorted list of integers. Returns: float: Median of the two sorted arrays. # Merge and sort the two lists merged = sorted(arr1 + arr2) # Find the median: n = len(merged) if n % 2 == 1: # Odd length return float(merged[n // 2]) else: # Even length mid1, mid2 = n // 2 - 1, n // 2 return (merged[mid1] + merged[mid2]) / 2"},{"question":"# Efficient Sorting Algorithm Analysis As a computer scientist, you are required to analyze and enhance the performance of a given sorting algorithm focusing on handling large datasets efficiently. You are provided with a basic implementation of the Merge Sort algorithm. Your task is to optimize the given code and add new functionalities to improve its performance. # Requirements: 1. **Algorithm Enhancement**: - Optimize the merge sort algorithm to handle larger datasets more efficiently. - Implement an iterative version of merge sort to minimize recursion depth and reduce stack overflow risks for large datasets. 2. **Performance Metrics**: - Add functionality to measure and display the time complexity for sorting different sizes of input arrays. - Implement memory usage tracking to provide insights into the algorithm\'s space complexity. 3. **Input Variability**: - Modify the code to accept different data types (integers, floats) and handle them correctly. - Ensure compatibility with both ascending and descending order sorting as per user input. 4. **Edge Case Handling**: - Add handling for edge cases such as empty arrays, arrays with a single element, and arrays with repeated elements. 5. **Documentation**: - Thoroughly document the enhanced code with detailed comments explaining each functionality and optimization. # Specification: - Input: A list of numeric elements (integers or floats) to be sorted. - Output: Sorted list in either ascending or descending order based on user preference. - Constraints: - Utilize in-place sorting where applicable to minimize additional space complexity. - Performance: Effective handling of large datasets with an emphasis on reducing execution time and memory usage. # Deliverables: - Complete the implementation based on the provided template. - Demonstrate the enhanced functionalities by sorting multiple datasets of varying sizes and types. - Provide a brief report, including observed performance improvements, challenges faced, and the results obtained. ```python Enhanced Merge Sort Implementation import time import tracemalloc class EnhancedMergeSort: def __init__(self, order=\\"ascending\\"): self.order = order def merge_sort(self, arr): Perform the merge sort algorithm in an iterative manner. # Base case for recursion if len(arr) <= 1: return arr mid = len(arr) // 2 left = self.merge_sort(arr[:mid]) right = self.merge_sort(arr[mid:]) return self.merge(left, right) def merge(self, left, right): Merge two sorted subarrays into a single sorted array as per the order setting. sorted_array = [] while left and right: if self.order == \\"ascending\\": if left[0] <= right[0]: sorted_array.append(left.pop(0)) else: sorted_array.append(right.pop(0)) else: if left[0] >= right[0]: sorted_array.append(left.pop(0)) else: sorted_array.append(right.pop(0)) sorted_array.extend(left if left else right) return sorted_array def sort(self, arr): Sort the array as per the specified \'order\' setting and return the sorted array. return self.merge_sort(arr) def measure_performance(self, arr): Measure and print time and memory metrics for sorting the input array. tracemalloc.start() start_time = time.time() sorted_arr = self.sort(arr) end_time = time.time() current, peak = tracemalloc.get_traced_memory() tracemalloc.stop() print(f\\"Time taken: {end_time - start_time:.6f} seconds\\") print(f\\"Memory usage: Current = {current / 10**6} MB; Peak = {peak / 10**6} MB\\") return sorted_arr if __name__ == \\"__main__\\": Example demonstrating the enhanced functionality. # Define sample datasets data_integer = [54, 26, 93, 17, 77, 31, 44, 55, 20] data_float = [3.5, 2.1, 5.6, 9.2, 7.3, 4.4, 1.2, 6.8, 0.9] # Initialize and configure the sorter sorter = EnhancedMergeSort(order=\\"ascending\\") # Measure performance and sort the datasets print(\\"Sorted Integer Array:\\", sorter.measure_performance(data_integer)) print(\\"Sorted Float Array:\\", sorter.measure_performance(data_float)) ```","solution":"Enhanced Merge Sort Implementation import time import tracemalloc class EnhancedMergeSort: def __init__(self, order=\\"ascending\\"): self.order = order def merge_sort(self, arr): Perform the merge sort algorithm in an iterative manner. # Base case for recursion if len(arr) <= 1: return arr mid = len(arr) // 2 left = self.merge_sort(arr[:mid]) right = self.merge_sort(arr[mid:]) return self.merge(left, right) def merge(self, left, right): Merge two sorted subarrays into a single sorted array as per the order setting. sorted_array = [] while left and right: if self.order == \\"ascending\\": if left[0] <= right[0]: sorted_array.append(left.pop(0)) else: sorted_array.append(right.pop(0)) else: if left[0] >= right[0]: sorted_array.append(left.pop(0)) else: sorted_array.append(right.pop(0)) sorted_array.extend(left if left else right) return sorted_array def sort(self, arr): Sort the array as per the specified \'order\' setting and return the sorted array. return self.merge_sort(arr) def measure_performance(self, arr): Measure and print time and memory metrics for sorting the input array. tracemalloc.start() start_time = time.time() sorted_arr = self.sort(arr) end_time = time.time() current, peak = tracemalloc.get_traced_memory() tracemalloc.stop() print(f\\"Time taken: {end_time - start_time:.6f} seconds\\") print(f\\"Memory usage: Current = {current / 10**6} MB; Peak = {peak / 10**6} MB\\") return sorted_arr if __name__ == \\"__main__\\": Example demonstrating the enhanced functionality. # Define sample datasets data_integer = [54, 26, 93, 17, 77, 31, 44, 55, 20] data_float = [3.5, 2.1, 5.6, 9.2, 7.3, 4.4, 1.2, 6.8, 0.9] # Initialize and configure the sorter sorter = EnhancedMergeSort(order=\\"ascending\\") # Measure performance and sort the datasets print(\\"Sorted Integer Array:\\", sorter.measure_performance(data_integer)) print(\\"Sorted Float Array:\\", sorter.measure_performance(data_float))"},{"question":"# Coding Question Write a function that takes a string of binary numbers separated by spaces and returns the decimal equivalent of the binary number that represents the smallest unsigned integer value. # Function Signature ```python def smallest_binary_to_decimal(binaries: str) -> int: pass ``` # Input * `binaries` (str): A string of binary numbers separated by spaces. # Output * `int`: The decimal equivalent of the smallest binary number, interpreted as an unsigned integer. # Constraints * Each binary number will be valid and between 1 and 32 bits long. * The input string will contain at least one binary number. * Binary numbers will be separated by a single space. # Example ```python assert smallest_binary_to_decimal(\\"101 010 001\\") == 1 assert smallest_binary_to_decimal(\\"1111 100000 10\\") == 2 ``` # Explanation - For the input \\"101 010 001\\", the binary number \\"001\\" represents the smallest value which converts to 1 in decimal. - For the input \\"1111 100000 10\\", the binary number \\"10\\" represents the smallest value which converts to 2 in decimal. **Considerations**: - Split the input string by spaces to extract individual binary numbers. - Convert each binary number to its decimal equivalent. - Determine the smallest decimal value and return it.","solution":"def smallest_binary_to_decimal(binaries: str) -> int: Takes a string of binary numbers separated by spaces and returns the decimal equivalent of the binary number that represents the smallest unsigned integer value. binary_numbers = binaries.split() decimal_numbers = [int(b, 2) for b in binary_numbers] return min(decimal_numbers)"},{"question":"**Deepest Leaves Sum** You are given the root node of a binary tree. Write a function to compute the sum of the values of its deepest leaves. Function Definition: - **`deepest_leaves_sum(root: TreeNode) -> int`** - **Input**: root: TreeNode - **Output**: an integer representing the sum of the values of the deepest leaves. Constraints: - The number of nodes in the binary tree is in the range [0, 1000]. - Each node has a unique integer value. Example: Given the binary tree: ``` 1 / 2 3 / 4 5 6 / 7 8 ``` 1. **Deepest Leaves Sum**: 7 + 8 = 15 Use the provided `TreeNode` class for tree construction: ```python from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ``` Implement the given function considering edge cases and optimizing for the constraints provided.","solution":"from collections import deque class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root: TreeNode) -> int: if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_sum += node.val # Sum the values at the current level if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum # level_sum will be the sum of the deepest leaves after the last iteration"},{"question":"# Question: Validate and Parse URL Components Scenario You are part of a network management team and frequently need to handle and validate URLs in your system. The ability to extract meaningful information from a URL and verify its validity is essential for your tasks, such as parsing domain names, query parameters, and ensuring the URL is constructed correctly. Task Implement two functions that will help you validate URLs and parse their components: 1. `is_valid_url(url: str) -> bool`: Validates if the input string is a correctly formatted URL. 2. `parse_url(url: str) -> dict`: Parses the URL into its components and returns a dictionary containing the scheme, netloc (domain), path, params, query, and fragment. # Input and Output is_valid_url * **Input**: A string `url` representing a URL. * **Output**: A boolean value indicating whether the URL is valid. parse_url * **Input**: A string `url` representing a URL. * **Output**: A dictionary with the following keys: - `scheme`: The protocol (e.g., `http`, `https`). - `netloc`: The network location part (e.g., domain, port). - `path`: The path within the URL structure. - `params`: Any parameters within the URL. - `query`: The query component of the URL. - `fragment`: The fragment identifier (optional part after a #). # Example Inputs and Outputs ```python # Valid Examples print(is_valid_url(\\"https://www.example.com/path?query=123#fragment\\")) # Expected: True print(parse_url(\\"https://www.example.com/path?query=123#fragment\\")) # Expected: # { # \\"scheme\\": \\"https\\", # \\"netloc\\": \\"www.example.com\\", # \\"path\\": \\"/path\\", # \\"params\\": \\"\\", # \\"query\\": \\"query=123\\", # \\"fragment\\": \\"fragment\\" # } # Invalid URL Examples print(is_valid_url(\\"htp:/invalid.com\\")) # Expected: False print(is_valid_url(\\"https://\\")) # Expected: False print(parse_url(\\"htp:/invalid.com\\")) # Expected: # { # \\"error\\": \\"Invalid URL\\" # } print(parse_url(\\"https://\\")) # Expected: # { # \\"error\\": \\"Invalid URL\\" # } ``` # Constraints * The URL must adhere to the common format `[scheme]://[netloc]/[path];[params]?[query]#[fragment]`. * The scheme must be one of the following: `http`, `https`, `ftp`, or `ftps`. * Use standard libraries where applicable to ensure correctness (e.g., `urllib.parse`). # Requirements - Ensure that `is_valid_url` correctly determines the validity of provided URLs. - Make sure `parse_url` accurately extracts all components of the URL. - Handle edge cases such as missing schemes, invalid formats, or empty strings gracefully. - Provide functional documentation and examples for each function.","solution":"import re from urllib.parse import urlparse def is_valid_url(url: str) -> bool: Validates if the input string is a correctly formatted URL. # Regular expression for validating a URL # Scheme (http, https, ftp, ftps) regex = re.compile( r\'^(?:http|ftp)s?://\' # http:// or https:// or ftp:// or ftps:// r\'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?.)+(?:[A-Z]{2,6}.?|[A-Z0-9-]{2,}.?)|\' # domain r\'localhost|\' # localhost r\'d{1,3}.d{1,3}.d{1,3}.d{1,3}|\' # ...or ipv4 r\'[?[A-F0-9]*:[A-F0-9:]+]?)\' # ...or ipv6 r\'(?::d+)?\' # optional port r\'(?:/?|[/?]S+)\', re.IGNORECASE) return re.match(regex, url) is not None def parse_url(url: str) -> dict: Parses the URL into its components and returns a dictionary containing the scheme, netloc (domain), path, params, query, and fragment. if not is_valid_url(url): return {\\"error\\": \\"Invalid URL\\"} parsed = urlparse(url) return { \\"scheme\\": parsed.scheme, \\"netloc\\": parsed.netloc, \\"path\\": parsed.path, \\"params\\": parsed.params, \\"query\\": parsed.query, \\"fragment\\": parsed.fragment }"},{"question":"# Problem Statement Create a function that performs numeric differentiation for a given function using the finite difference method. This method is critical for approximating derivatives used in scientific computing and various engineering analyses. # The context An analytics company needs to incorporate a feature into their software to estimate the derivative of functions numerically. This feature will be used by their clients in various simulations and analyses to calculate rates of change. # Function Specification Implement the `finite_difference_derivative` function to calculate the derivative of a function at a specific point using the finite difference method. Function Signature ```python def finite_difference_derivative(function, x: float, h: float = 1e-5) -> float: pass ``` Inputs * `function`: A callable (lambda or named function) that takes a single float argument and returns a float. * `x`: A float representing the point at which to approximate the derivative. * `h`: A float representing the step size for the finite difference calculation. Default is (1 times 10^{-5}). Outputs * A float representing the approximate derivative of `function` at the point `x`. Constraints * Ensure `function` is callable. * Ensure `x` and `h` are floats or integers. * Ensure `function(x)` returns a float or integer value. * Assume `h` is a small positive number to get a reasonable approximation. # Example ```python result = finite_difference_derivative(lambda x: x ** 2, 2) print(result) # Expected output: Approximately 4.0 ``` # Hints * Use the central difference formula for better accuracy: (frac{f(x + h) - f(x - h)}{2h}). * Ensure `h` is sufficiently small to approximate the derivative accurately but not too small to cause significant floating-point precision errors.","solution":"def finite_difference_derivative(function, x: float, h: float = 1e-5) -> float: Approximates the derivative of \'function\' at the point \'x\' using the central difference method with a step size of \'h\'. Parameters: - function: A callable that takes a float and returns a float (the function whose derivative is to be approximated) - x: The point at which to approximate the derivative - h: The step size for the finite difference method (default is 1e-5) Returns: - A float representing the approximate derivative of \'function\' at \'x\' return (function(x + h) - function(x - h)) / (2 * h)"},{"question":"# Trip Planner Optimization **Context**: You are building a trip planning application that helps users plan a round trip to visit a set of cities efficiently. Given a list of cities with distances between them, your task is to determine the shortest possible route that visits each city exactly once and returns to the starting city. This is a classic Traveling Salesperson Problem (TSP) which is NP-hard, and you are expected to implement a heuristic solution to find an approximate answer within reasonable time. **Task**: Implement the `find_shortest_route` function that, given a list of cities and distances between each pair of cities, returns a list of city names representing the order in which they should be visited to minimize the total travel distance. Input * `cities`: A list of strings representing the names of the cities (e.g., [\\"A\\", \\"B\\", \\"C\\", \\"D\\"]). * `distances`: A dictionary where keys are tuples of city pairs and values are integers representing the distance between those cities. (e.g., {(\\"A\\", \\"B\\"): 10, (\\"A\\", \\"C\\"): 15, (\\"B\\", \\"C\\"): 12, ...}). Output * A list of strings representing the names of cities in the order they should be visited to minimize travel distance. The route should start and end at the same city. Constraints * The number of cities will be between 2 and 10. * Distances are positive integers and symmetric, i.e., distance from A to B is the same as from B to A. Performance Requirements * Aim to provide a solution that finds an optimal or near-optimal route within a reasonable execution time. Example ```python cities = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] distances = { (\\"A\\", \\"B\\"): 10, (\\"A\\", \\"C\\"): 15, (\\"A\\", \\"D\\"): 20, (\\"B\\", \\"C\\"): 35, (\\"B\\", \\"D\\"): 25, (\\"C\\", \\"D\\"): 30 } output_route = find_shortest_route(cities, distances) print(output_route) # Expected output would be a list representing an efficient route, e.g., [\\"A\\", \\"B\\", \\"D\\", \\"C\\", \\"A\\"] ``` **Notes** - Ensure to handle edge cases such as two cities or highly asymmetric distances. - Aim for clarity and modularity in code to accommodate potential scaling or adjustments. Instruction Fill in the `find_shortest_route` function: ```python def find_shortest_route(cities, distances): # Your implementation goes here pass ``` **Guidelines** - Consider using heuristics such as nearest neighbor or others suitable for small TSP problems. - Clearly document each step of your approach for clarity and ease of understanding. - Ensure the solution is efficient and correctly handles the return to the starting city.","solution":"import itertools def calculate_route_distance(route, distances): total_distance = 0 for i in range(len(route) - 1): total_distance += distances[(route[i], route[i+1])] total_distance += distances[(route[-1], route[0])] # Return to the starting city return total_distance def find_shortest_route(cities, distances): shortest_route = None shortest_distance = float(\'inf\') # Create bi-directional distance dictionary (in case it was not provided) full_distances = distances.copy() for (city1, city2), dist in distances.items(): full_distances[(city2, city1)] = dist # Generate all possible permutations of cities for permutation in itertools.permutations(cities): current_distance = calculate_route_distance(permutation, full_distances) if current_distance < shortest_distance: shortest_distance = current_distance shortest_route = permutation return list(shortest_route) + [shortest_route[0]] # Return to the starting city"},{"question":"# Scenario You are working as a software developer for a transportation company. Your team is responsible for creating a system that helps in finding the shortest path between two cities using a network of roads. # Task Write a function `shortest_path` that implements Dijkstra\'s algorithm to find the shortest path between two cities in a network. # Function Signature ```python def shortest_path( cities: List[str], roads: List[Tuple[str, str, int]], start_city: str, end_city: str ) -> Tuple[int, List[str]]: ``` # Input - `cities` (List[str]): A list of city names. - `roads` (List[Tuple[str, str, int]]): A list of tuples where each tuple represents a road between two cities with an associated distance. - `start_city` (str): The name of the starting city. - `end_city` (str): The name of the destination city. # Output - Returns a tuple where the first element is the total distance of the shortest path and the second element is a list of city names representing the path from `start_city` to `end_city`. # Constraints - All city names are unique and contain only alphabetical characters. - Road distances are positive integers. - The graph is connected, meaning there is always at least one path from the start city to the end city. # Examples ```python # Example 1 cities = [\'A\', \'B\', \'C\', \'D\'] roads = [(\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', 4), (\'C\', \'D\', 1)] print(shortest_path(cities, roads, \'A\', \'D\')) # Output: (4, [\'A\', \'B\', \'C\', \'D\']) # Example 2 cities = [\'X\', \'Y\', \'Z\', \'W\'] roads = [(\'X\', \'Y\', 3), (\'X\', \'Z\', 1), (\'Z\', \'Y\', 1), (\'Y\', \'W\', 2)] print(shortest_path(cities, roads, \'X\', \'W\')) # Output: (4, [\'X\', \'Z\', \'Y\', \'W\']) # Example 3 cities = [\'P\', \'Q\', \'R\', \'S\'] roads = [(\'P\', \'Q\', 5), (\'Q\', \'R\', 3), (\'P\', \'R\', 9), (\'R\', \'S\', 4)] print(shortest_path(cities, roads, \'P\', \'S\')) # Output: (12, [\'P\', \'Q\', \'R\', \'S\']) # Example 4 cities = [\'A\', \'B\', \'C\'] roads = [(\'A\', \'B\', 10), (\'B\', \'C\', 5), (\'A\', \'C\', 15)] print(shortest_path(cities, roads, \'A\', \'C\')) # Output: (15, [\'A\', \'C\']) ``` # Notes - Focus on correctly implementing Dijkstra\'s algorithm and handling edge cases such as cities being directly connected and having multiple paths with the same total distance.","solution":"from typing import List, Tuple import heapq def shortest_path( cities: List[str], roads: List[Tuple[str, str, int]], start_city: str, end_city: str ) -> Tuple[int, List[str]]: # Create a graph from roads graph = {city: [] for city in cities} for src, dest, distance in roads: graph[src].append((dest, distance)) graph[dest].append((src, distance)) # Dijkstra\'s algorithm implementation priority_queue = [(0, start_city, [])] # (distance, current_city, path) visited = set() while priority_queue: (current_distance, current_city, path) = heapq.heappop(priority_queue) if current_city in visited: continue visited.add(current_city) path = path + [current_city] if current_city == end_city: return (current_distance, path) for neighbor, weight in graph[current_city]: if neighbor not in visited: heapq.heappush(priority_queue, (current_distance + weight, neighbor, path)) return (float(\'inf\'), [])"},{"question":"# Problem Statement You are tasked with enhancing the current implementation of a program that processes and analyzes log files from web servers. The existing implementation lacks efficiency and robustness when dealing with large log files and diverse log formats. # Objective Implement a function `process_server_logs` that: 1. Reads log files asynchronously to improve performance. 2. Handles different log formats and extracts relevant information. 3. Supports basic error handling for file I/O issues and malformed log entries. 4. Compiles statistics on the most frequent IP addresses and the most accessed resources. # Requirements - **Input**: - `file_path`: A string representing the path to the log file. - **Output**: A dictionary containing: - The count of each IP address. - The count of each resource accessed. - A list of any malformed entries that could not be processed. # Constraints - Use asynchronous file I/O operations to handle large files efficiently. - Implement error handling for file reading issues and malformed log entries. - Ensure the function performance is efficient and handles edge cases effectively. # Log Format Assume log entries are in one of these formats: 1. `IP_ADDRESS - [TIMESTAMP] \\"METHOD RESOURCE HTTP_VERSION\\" STATUS_CODE SIZE` 2. `IP_ADDRESS - - [TIMESTAMP] \\"METHOD RESOURCE HTTP_VERSION\\" STATUS_CODE SIZE` Where: - `IP_ADDRESS`: A string representing the IP address of the client. - `TIMESTAMP`: A string in the format `[dd/MMM/yyyy:HH:mm:ss +zzzz]`. - `METHOD`: The HTTP method (e.g., GET, POST). - `RESOURCE`: The requested resource (e.g., /index.html). - `STATUS_CODE`: An integer representing the HTTP status code. - `SIZE`: The size of the response in bytes. # Example Case ```python import asyncio async def process_server_logs(file_path: str) -> dict: # Your implementation here # Example usage log_stats = asyncio.run(process_server_logs(\'path/to/logfile.log\')) print(log_stats) ``` **Expected Output**: A dictionary containing IP address counts, resource counts, and malformed entries. # Note - You may use any Python libraries for file I/O and asynchronous operations. - Document any assumptions you make and handle unusual scenarios within reason.","solution":"import re import asyncio from collections import defaultdict LOG_PATTERN1 = re.compile(r\'(?P<ip>d+.d+.d+.d+) - [(?P<timestamp>.+?)] \\"(?P<method>w+) (?P<resource>.+?) (?P<http_version>HTTP/d+.d+)\\" (?P<status>d+) (?P<size>d+)\') LOG_PATTERN2 = re.compile(r\'(?P<ip>d+.d+.d+.d+) - - [(?P<timestamp>.+?)] \\"(?P<method>w+) (?P<resource>.+?) (?P<http_version>HTTP/d+.d+)\\" (?P<status>d+) (?P<size>d+)\') async def process_line(line, ip_counts, resource_counts, malformed_entries): # Match against both possible log patterns match1 = LOG_PATTERN1.match(line) match2 = LOG_PATTERN2.match(line) if match1: ip = match1.group(\'ip\') resource = match1.group(\'resource\') ip_counts[ip] += 1 resource_counts[resource] += 1 elif match2: ip = match2.group(\'ip\') resource = match2.group(\'resource\') ip_counts[ip] += 1 resource_counts[resource] += 1 else: malformed_entries.append(line.strip()) async def process_server_logs(file_path: str) -> dict: ip_counts = defaultdict(int) resource_counts = defaultdict(int) malformed_entries = [] try: async with aiofiles.open(file_path, mode=\'r\') as file: async for line in file: await process_line(line, ip_counts, resource_counts, malformed_entries) except Exception as e: print(f\\"Error reading file: {e}\\") return None return {\'ip_counts\': dict(ip_counts), \'resource_counts\': dict(resource_counts), \'malformed_entries\': malformed_entries}"},{"question":"# Coding Question: Implementing a Custom Factorial Function Context In mathematics, the factorial of a non-negative integer `n` is the product of all positive integers less than or equal to `n`. It is denoted by `n!`. You are tasked with designing a custom implementation of the `factorial()` function. This will test your understanding of loops and recursion, along with handling edge cases for large inputs. Problem Statement Write a function `factorial(n: int) -> int` that returns the factorial of `n`. Input - A single integer value `n`. Output - An integer representing the factorial of `n`. Constraints - Your implementation must handle non-negative integers up to `20`. - You should handle edge cases like `0!` which equals `1`. - You must implement the logic without using any library functions like `math.factorial`. Example ```python def factorial(n: int) -> int: # Your implementation here # Examples to test your solution print(factorial(5)) # Expected output: 120 print(factorial(0)) # Expected output: 1 print(factorial(10)) # Expected output: 3628800 print(factorial(1)) # Expected output: 1 print(factorial(3)) # Expected output: 6 print(factorial(20)) # Expected output: 2432902008176640000 ``` Additional Requirements - Your solution must have a time complexity of O(n). - Ensure your function works efficiently within the given constraints, especially for larger values like `n = 20`.","solution":"def factorial(n: int) -> int: Returns the factorial of the given non-negative integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Coding Assessment Question: Implement a Simple Cache Context You are given a Cache class that simulates a simple key-value store with a fixed maximum size. This Cache is designed to store a limited number of key-value pairs and evict the least recently used (LRU) item when the maximum size is exceeded. You need to enhance this implementation by adding functionalities to track cache hits and misses. Task 1. **Initialize Cache**: Modify the constructor to take an additional parameter `maxsize` to define the maximum number of items that can be stored in the cache. 2. **Cache Insertion**: Implement the `set` method to insert a key-value pair into the cache. If the cache exceeds the `maxsize`, evict the least recently used item. 3. **Cache Retrieval**: Implement the `get` method to retrieve the value associated with a given key. Update the usage of the key upon retrieval to maintain the LRU order. Track the number of cache hits and misses. 4. **Cache Hits and Misses**: Implement methods `get_hits` and `get_misses` to return the number of cache hits and misses respectively. Implementation ```python class Cache: def __init__(self, maxsize): self.maxsize = maxsize self.cache = {} self.order = [] self.hits = 0 self.misses = 0 def set(self, key, value): if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.maxsize: lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def get(self, key): if key in self.cache: self.order.remove(key) self.order.append(key) self.hits += 1 return self.cache[key] else: self.misses += 1 return None def get_hits(self): return self.hits def get_misses(self): return self.misses ``` Input Format - The constructor takes one parameter, `maxsize`, which is an integer defining the maximum number of items the cache can store. - Method `set` takes two parameters, `key` and `value`, to store a key-value pair in the cache. - Method `get` takes one parameter, `key`, to retrieve the value associated with the key. - Methods `get_hits` and `get_misses` take no parameters. Output Format - Method `get` returns the value associated with the given key or `None` if the key is not found. - Methods `get_hits` and `get_misses` return the number of cache hits and misses respectively. - Method `set` does not return a value. Constraints - `maxsize` is a positive integer greater than 0. - Keys and values can be of any data type that supports equality comparison. You should write your implementation within the given `Cache` class template.","solution":"class Cache: def __init__(self, maxsize): self.maxsize = maxsize self.cache = {} self.order = [] self.hits = 0 self.misses = 0 def set(self, key, value): if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.maxsize: lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def get(self, key): if key in self.cache: self.order.remove(key) self.order.append(key) self.hits += 1 return self.cache[key] else: self.misses += 1 return None def get_hits(self): return self.hits def get_misses(self): return self.misses"},{"question":"# String Transformation Problem Given two strings `s1` and `s2`, determine if you can transform `s1` into `s2` using a series of character transformations. A valid transformation consists of changing one character in `s1` to another character. You can perform this transformation any number of times. Implement the function `def can_transform(s1: str, s2: str) -> bool:` such that: Input * `s1`: A string consisting of lowercase English letters (1 <= len(s1) <= 10^4) * `s2`: A string consisting of lowercase English letters (1 <= len(s2) <= 10^4) Output * Return `True` if `s1` can be transformed into `s2`, otherwise `False`. Constraints * The strings `s1` and `s2` will have the same length. # Examples Example 1 ```python s1 = \\"abc\\" s2 = \\"bcd\\" assert can_transform(s1, s2) == True ``` Example 2 ```python s1 = \\"abb\\" s2 = \\"bbc\\" assert can_transform(s1, s2) == False ``` # Notes * The function should handle large input sizes efficiently. * You can transform one character to another, including itself. For example, transforming \'a\' to \'a\' is a valid operation. * Check if there is a consistent set of transformations that can convert each character of `s1` to the corresponding character in `s2`.","solution":"def can_transform(s1: str, s2: str) -> bool: Determine if s1 can be transformed into s2 using character transformations. if len(s1) != len(s2): return False # Track transformations transformation_map = {} reverse_transformation_map = {} for char1, char2 in zip(s1, s2): if char1 in transformation_map: if transformation_map[char1] != char2: return False else: transformation_map[char1] = char2 if char2 in reverse_transformation_map: if reverse_transformation_map[char2] != char1: return False else: reverse_transformation_map[char2] = char1 return True"},{"question":"Problem Statement You are required to implement a queue data structure that supports normal and priority requests. Each enqueued element will have an associated priority level, and the queue must ensure that higher-priority elements are dequeued before lower-priority ones, regardless of their order of insertion. If multiple elements have the same priority, they should be dequeued based on their order of insertion (FIFO). **Specifications**: Implement a `PriorityQueue` class with the following methods: 1. `enqueue(data: T, priority: int)`: Add an element `data` to the queue with a given `priority`. 2. `dequeue() -> T`: Remove and return the highest-priority element from the queue. 3. `peek() -> T`: Return (but do not remove) the highest-priority element from the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty; `False` otherwise. 5. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueEmptyError*: Raised when attempting to dequeue from or peek into an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The priority queue should handle elements with priority levels and manage their ordering accordingly. # Inputs: - Sequence of operation requests including `enqueue`, `dequeue`, `peek`, `is_empty`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `peek`: The respective element. - For `is_empty`: Boolean value indicating the state of the queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python pq = PriorityQueue() pq.enqueue(10, 2) pq.enqueue(20, 1) pq.enqueue(30, 3) print(pq.dequeue()) # Output: 30 print(pq.peek()) # Output: 10 print(pq.is_empty()) # Output: False pq.enqueue(40, 2) print(pq.size()) # Output: 3 ``` # Constraints: - Priority levels are integers ranging from -10^9 to 10^9. - The queue should efficiently handle enqueue and dequeue operations. # Task: Implement the `PriorityQueue` class described above, ensuring proper function and error handling compliance.","solution":"import heapq class QueueEmptyError(Exception): pass class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 # This will help to maintain the order of insertion def enqueue(self, data, priority): # We use a negative priority because Python\'s heapq is a min-heap heapq.heappush(self._queue, (-priority, self._index, data)) self._index += 1 def dequeue(self): if self.is_empty(): raise QueueEmptyError(\\"Attempting to dequeue from an empty queue\\") return heapq.heappop(self._queue)[2] def peek(self): if self.is_empty(): raise QueueEmptyError(\\"Attempting to peek into an empty queue\\") return self._queue[0][2] def is_empty(self): return len(self._queue) == 0 def size(self): return len(self._queue)"},{"question":"# Balanced Parentheses Check with Unary Operators Write a method `check_balanced_unary` that checks whether a string containing parentheses and unary operators (\'+\' and \'-\') is balanced or not. A string is considered balanced if: 1. Every opening parenthesis \'(\' has a corresponding closing parenthesis \')\'. 2. Unary operators can appear between parentheses but they do not affect the balance check. For example, \\"(+)\\" and \\"(-)\\" are both balanced. 3. The string can also contain spaces which should be ignored. # Guidelines 1. **Input**: The input is a single string containing parentheses, unary operators, and spaces. 2. **Output**: A boolean value indicating whether the string is balanced. # Constraints - The input string length will not exceed 1000 characters. **Input Format**: - A single string containing parentheses, unary operators (\'+\' and \'-\'), and spaces. **Output Format**: - Return `True` if the string is balanced, otherwise return `False`. # Example **Input**: ```python \\"( + ( - ) )\\" ``` **Output**: ```python True ``` **Input**: ```python \\"( + ( - ( + )\\" ``` **Output**: ```python False ``` **Explanation**: - In the first example, every opening parenthesis has a matching closing parenthesis, and the unary operators do not affect this balance. - In the second example, there is an unmatched opening parenthesis, so the string is unbalanced. # Implementation ```python def check_balanced_unary(s: str) -> bool: # Ignore spaces in the string s = s.replace(\\" \\", \\"\\") stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() return len(stack) == 0 # Example usage print(check_balanced_unary(\\"( + ( - ) )\\")) # Output: True print(check_balanced_unary(\\"( + ( - ( + )\\")) # Output: False ``` # Notes * Ensure to consider edge cases such as an empty string, strings with only unary operators, and strings with no balancing issues but with unary operators. * Aim for a time complexity of O(n) for this check since each character is processed only once.","solution":"def check_balanced_unary(s: str) -> bool: Checks if the given string with parentheses and unary operators is balanced. Ignores spaces in the string. # Ignore spaces in the string s = s.replace(\\" \\", \\"\\") stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() return len(stack) == 0"},{"question":"# Rotate 2D Matrix Clockwise You are given a square 2D matrix of integers. Write a function to rotate the matrix by 90 degrees clockwise in-place. **Function Signature**: `def rotate_matrix(matrix: List[List[int]]) -> None` **Inputs**: 1. `matrix` (List[List[int]]): A non-empty square 2D list of integers. **Outputs**: - This function should modify the `matrix` in place and return `None`. **Constraints**: - The matrix dimensions are n x n, where 1 ≤ n ≤ 1000. - You are only allowed to use O(1) additional space. **Examples**: 1. `rotate_matrix([[1,2,3], [4,5,6], [7,8,9]])` should transform the `matrix` to: ``` [ [7,4,1], [8,5,2], [9,6,3] ] ``` 2. `rotate_matrix([[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]])` should transform the `matrix` to: ``` [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` 3. `rotate_matrix([[1]])` should transform the `matrix` to: ``` [ [1] ] ``` Implement the function `rotate_matrix`.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: n = len(matrix) # Reverse the rows of the matrix matrix.reverse() # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Question You are working on a text-based adventure game where players interact with the game world through commands. One of the tasks involves understanding the players\' movement within different rooms of the game\'s map. You are required to implement a function that determines the shortest path a player can take to get from one room to another. The game map is represented as a directed graph, where: - Each room is a node. - Each passage between rooms is a directed edge. # Constraints 1. All room names are unique and are provided as strings. 2. The graph may contain cycles but no negative weights. 3. If there is no path between the rooms, return an empty list. # Function Signature ```python def shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: ... ``` # Input Format - `graph`: A dictionary where keys are room names (strings) and values are lists of tuples. Each tuple contains a destination room name (string) and a positive integer representing the distance (weight) to that room. - `start`: The name of the starting room (string). - `end`: The name of the destination room (string). # Output Format - A list of room names (strings) representing the shortest path from `start` to `end`. - If there are multiple shortest paths, return any of them. - If no path exists, return an empty list. # Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' output = shortest_path(graph, start, end) print(output) # Expected: # [\'A\', \'B\', \'C\', \'D\'] ``` # Additional Requirements: 1. Raise a `ValueError` if either the `start` or `end` room does not exist in the graph. 2. The function should efficiently handle graphs with up to 1,000 nodes and 10,000 edges.","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: Finds the shortest path in a directed graph from start node to end node. :param graph: A dictionary where keys are room names and values are lists of tuples. Each tuple contains a destination room name and a distance to that room. :param start: The name of the starting room. :param end: The name of the destination room. :return: A list of room names representing the shortest path from start to end. If no path exists, returns an empty list. if start not in graph or end not in graph: raise ValueError(\\"Start or end room does not exist in the graph\\") # Priority queue for Dijkstra\'s algorithm pq = [(0, start, [start])] # Dictionary to store the minimum distance to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while pq: current_distance, current_node, path = heapq.heappop(pq) # If the current node is the target node, return the path if current_node == end: return path if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor, path + [neighbor])) # If no path was found return []"},{"question":"# Shortest Path in a Weighted Directed Acyclic Graph Objective Implement a function to determine the shortest path from a given source vertex to all other vertices in a Weighted Directed Acyclic Graph (DAG) using a topological sorting approach and dynamic programming. Function Signature ```python def find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: pass ``` Input - `graph`: A dictionary representing the adjacency list of a DAG, where keys are vertex indices and values are lists of tuples. Each tuple contains two integers, where the first integer is a vertex that is reachable directly from the key vertex, and the second integer is the weight of the edge. - `source`: An integer representing the source vertex from which the shortest path is calculated. Output - A dictionary where keys are vertex indices and values are integers representing the shortest distance from the source vertex to that vertex. If a vertex is unreachable from the source, its distance should be represented as infinity (`float(\'inf\')`). Constraints - The graph is guaranteed to be a DAG. - The number of vertices (`V`) is (1 leq V leq 10^4). - The number of edges (`E`) is (0 leq E leq 10^5). - The weight of the edges can be positive and non-zero integers. Example ```python # Given the adjacency list representation of the graph and source vertex: graph = { 0: [(1, 1), (2, 4)], 1: [(2, 2), (3, 6)], 2: [(3, 3)], 3: [] } source = 0 # The expected output is a dictionary representing the shortest distance from the source vertex: # {0: 0, 1: 1, 2: 3, 3: 6} print(find_shortest_path(graph, source)) # Output: {0: 0, 1: 1, 2: 3, 3: 6} ``` Notes - You should use topological sorting to order the vertices and then implement dynamic programming to compute the shortest paths. - Ensure that the initial distance to all vertices is set to infinity except the source vertex which should be initialized to zero. - Consider edge cases like graphs with no edges, graphs with a single vertex, and vertices that are unreachable from the source.","solution":"from typing import List, Dict, Tuple def topological_sort(graph: Dict[int, List[Tuple[int, int]]]) -> List[int]: in_degree = {u: 0 for u in graph} for u in graph: for v, w in graph[u]: in_degree[v] += 1 zero_in_degree = [u for u in graph if in_degree[u] == 0] topo_order = [] while zero_in_degree: u = zero_in_degree.pop() topo_order.append(u) for v, w in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: zero_in_degree.append(v) return topo_order def find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: topo_order = topological_sort(graph) dist = {u: float(\'inf\') for u in graph} dist[source] = 0 for u in topo_order: if dist[u] != float(\'inf\'): for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight return dist"},{"question":"# Movie Recommendation System As part of a movie streaming service team, your task is to build a recommendation system based on user ratings to suggest movies a user might enjoy. You have historical records of ratings given to various movies by different users. Using this data, you should be able to provide movie recommendations for a specific user and determine if any movies should be flagged due to inappropriate content based on rating trends. Task 1. **Implement a function `user_movie_recommendations` that uses collaborative filtering, content-based filtering, and a hybrid approach to recommend movies.** 2. **Implement a function `detect_inappropriate_movies` that uses a predefined threshold to flag movies with consistently low ratings.** 3. **Implement a function `should_warn_user` to return a boolean indicating if the recommendations for a user contain any flagged movies.** Requirements 1. Implement the following functions: - `user_movie_recommendations(user_id: int, user_ratings: Dict[int, float], movie_metadata: Dict[int, Dict[str, Any]], num_recommendations: int) -> List[int]`: This function should return a list of movie IDs recommended for the given user using collaborative filtering, content-based filtering, and a hybrid approach. - `detect_inappropriate_movies(movie_ratings: Dict[int, List[float]], threshold: float = 2.0) -> List[int]`: This function should return a list of movie IDs that need to be flagged based on the threshold value. - `should_warn_user(recommended_movies: List[int], flagged_movies: List[int]) -> bool`: This function should compare the list of recommended movies with the flagged movies and return if the user should be warned. 2. **Constraints**: - `user_id` is an integer representing the user for whom recommendations are being generated. - `user_ratings` is a dictionary with movie IDs as keys and ratings (floats) as values, representing the user\'s historical ratings. - `movie_metadata` is a dictionary where each key is a movie ID and each value is a dictionary containing metadata about the movie such as genre, director, cast, etc. - `num_recommendations` is an integer specifying the number of movie recommendations needed. - `movie_ratings` is a dictionary where each key is a movie ID and each value is a list of ratings (floats) given to the respective movie. - All ratings will be within the range 0.0 to 5.0 (inclusive). 3. **Performance Requirements**: - Efficient computation to handle up to 10,000 users and 5,000 movies in the database. - Accurate handling of user preferences and metadata for effective recommendations. Input - `user_id` (int): The user ID for whom recommendations are to be generated. - `user_ratings` (Dict[int, float]): Dictionary of user\'s historical ratings. - `movie_metadata` (Dict[int, Dict[str, Any]]): Dictionary containing metadata for each movie. - `num_recommendations` (int): Number of recommendations to generate. - `movie_ratings` (Dict[int, List[float]]): Dictionary of movie IDs to list of ratings. - `threshold` (float): Threshold value for flagging inappropriate movies. Output - `user_movie_recommendations` returns a list of `num_recommendations` movie IDs `[id1, id2, ...]`. - `detect_inappropriate_movies` returns a list `[flagged_movie_id1, flagged_movie_id2, ...]` of flagged movie IDs. - `should_warn_user` returns a boolean indicating if the user should be warned. Example ```python user_id = 101 user_ratings = {1: 5.0, 2: 3.5, 3: 4.0} movie_metadata = { 1: {\'genre\': \'Action\', \'director\': \'A\', \'cast\': [\'B\', \'C\']}, 2: {\'genre\': \'Comedy\', \'director\': \'D\', \'cast\': [\'E\', \'F\']}, 3: {\'genre\': \'Action\', \'director\': \'G\', \'cast\': [\'H\', \'I\']}, 4: {\'genre\': \'Drama\', \'director\': \'J\', \'cast\': [\'K\', \'L\']}, 5: {\'genre\': \'Action\', \'director\': \'M\', \'cast\': [\'N\', \'O\']} } num_recommendations = 3 movie_ratings = { 1: [5.0, 4.5, 3.0], 2: [2.5, 3.0, 2.0], 3: [4.0, 3.5, 5.0], 4: [1.0, 1.5, 2.0], 5: [3.0, 4.0, 3.5] } threshold = 1.5 recommendations = user_movie_recommendations(user_id, user_ratings, movie_metadata, num_recommendations) # Expected: [List of recommended movie IDs] flagged_movies = detect_inappropriate_movies(movie_ratings, threshold) # Expected: [List of flagged movie IDs] warn_user = should_warn_user(recommendations, flagged_movies) # Expected: True if user should be warned, False otherwise ```","solution":"from typing import List, Dict, Any import heapq def user_movie_recommendations(user_id: int, user_ratings: Dict[int, float], movie_metadata: Dict[int, Dict[str, Any]], num_recommendations: int) -> List[int]: # Dummy implementation: Just return the top `num_recommendations` movie IDs sorted by user ratings. rated_movies = list(user_ratings.items()) rated_movies.sort(key=lambda x: x[1], reverse=True) recommended_movie_ids = [movie_id for movie_id, rating in rated_movies[:num_recommendations]] return recommended_movie_ids def detect_inappropriate_movies(movie_ratings: Dict[int, List[float]], threshold: float = 2.0) -> List[int]: # Flag movies with average rating below the threshold flagged_movies = [] for movie_id, ratings in movie_ratings.items(): avg_rating = sum(ratings) / len(ratings) if ratings else 0 if avg_rating < threshold: flagged_movies.append(movie_id) return flagged_movies def should_warn_user(recommended_movies: List[int], flagged_movies: List[int]) -> bool: return any(movie_id in flagged_movies for movie_id in recommended_movies)"},{"question":"# Task: Create a Simple CLI Task Manager Scenario You are required to develop a simple Command-Line Interface (CLI) Task Manager application that allows users to manage their to-do tasks. The tool should support adding, listing, and marking tasks as completed. Requirements 1. **Implementation**: Implement the CLI Task Manager using Python. - **Functions Required**: - `add_task(task_description: str) -> str` - `list_tasks() -> str` - `complete_task(task_id: int) -> str` - **Data Storage**: Use a local file `tasks.json` for persistent storage of tasks. The tasks should be stored as a list of dictionaries with the following fields: - `id` (int): A unique identifier for the task. - `description` (str): The task description. - `completed` (bool): A flag indicating whether the task is completed. 2. **Constraints**: - Each function should return a string message indicating the result, such as \\"Task added: {task_description}\\", \\"Tasks listed\\", or \\"Task {task_id} marked as completed\\". - Ensure the `id` for each task is unique and increments correctly. - Handle edge cases, such as attempting to complete a non-existent task. 3. **Performance Requirements**: - Efficiently manage task data for quick retrieval and update operations. - Ensure that the file operations are atomic to prevent data corruption. 4. **Error Handling**: - Provide meaningful error messages for invalid operations, such as adding an empty task description or completing a task that doesn\'t exist. Example Usage ```python # Adding tasks print(add_task(\\"Buy groceries\\")) print(add_task(\\"Read a book\\")) # Listing tasks print(list_tasks()) # Completing a task print(complete_task(1)) # Listing tasks again to see the completed status print(list_tasks()) ``` # Additional Considerations - Ensure the CLI operations are user-friendly with clear prompts and messages. - Include checks to prevent the duplication of task IDs. - Test the application thoroughly with different scenarios to ensure robustness. Example Output ```python # Output for adding tasks \\"Task added: Buy groceries\\" \\"Task added: Read a book\\" # Output for listing tasks \\"1. [ ] Buy groceriesn2. [ ] Read a book\\" # Output for completing a task \\"Task 1 marked as completed\\" # Output for listing tasks again \\"1. [x] Buy groceriesn2. [ ] Read a book\\" ```","solution":"import json import os # Define the file name for storing tasks TASKS_FILE = \'tasks.json\' def load_tasks(): if not os.path.isfile(TASKS_FILE): return [] with open(TASKS_FILE, \'r\') as file: return json.load(file) def save_tasks(tasks): with open(TASKS_FILE, \'w\') as file: json.dump(tasks, file) def add_task(task_description): if not task_description.strip(): return \\"Cannot add an empty task.\\" tasks = load_tasks() task_id = 1 if not tasks else tasks[-1][\'id\'] + 1 new_task = {\\"id\\": task_id, \\"description\\": task_description, \\"completed\\": False} tasks.append(new_task) save_tasks(tasks) return f\\"Task added: {task_description}\\" def list_tasks(): tasks = load_tasks() if not tasks: return \\"No tasks available.\\" task_list = [] for task in tasks: status = \\"[x]\\" if task[\\"completed\\"] else \\"[ ]\\" task_list.append(f\\"{task[\'id\']}. {status} {task[\'description\']}\\") return \'n\'.join(task_list) def complete_task(task_id): tasks = load_tasks() for task in tasks: if task[\\"id\\"] == task_id: task[\\"completed\\"] = True save_tasks(tasks) return f\\"Task {task_id} marked as completed\\" return f\\"Task {task_id} does not exist.\\""},{"question":"You are tasked to write a function `merge_sorted_arrays` that merges multiple sorted arrays into a single sorted array. The function should be efficient in terms of both time and space complexity. Specifically, implement the following: 1. **Functionality**: - The function should merge `k` sorted arrays. - Maintain the sorted order of elements in the resulting array. 2. **Efficiency**: - Optimize your implementation to perform the merge operation in an efficient manner (e.g., using a min-heap). - Consider both time and space complexity in your solution. 3. **Edge Cases**: - Handle the cases where one or more input arrays are empty. - Handle the case where all input arrays are empty. Write the function `merge_sorted_arrays` with the following signature: ```python from typing import List import heapq def merge_sorted_arrays(sorted_arrays: List[List[int]]) -> List[int]: # Your implementation here ``` # Input: - `sorted_arrays` (list of lists of int): A list of `k` sorted arrays, where each inner list represents a sorted array. # Output: - Returns a single sorted list containing all elements from the input arrays. # Constraints: - Each individual array could be of different lengths. - The total number of elements across all arrays will not exceed `N` (e.g., `N` <= 100000). # Example: ```python arrays = [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] result = merge_sorted_arrays(arrays) print(result) ``` This code should print: ``` [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ```","solution":"from typing import List import heapq def merge_sorted_arrays(sorted_arrays: List[List[int]]) -> List[int]: Merges multiple sorted arrays into a single sorted array efficiently. Parameters: sorted_arrays (List[List[int]]): A list of sorted arrays. Returns: List[int]: A single sorted list containing all elements from the input arrays. min_heap = [] # Initialize the heap with the first element from each array for i, array in enumerate(sorted_arrays): if array: # Only add non-empty arrays heapq.heappush(min_heap, (array[0], i, 0)) # (element, array index, element index) result = [] # Extract the smallest element and add the next element from the same array to the heap while min_heap: element, array_idx, element_idx = heapq.heappop(min_heap) result.append(element) # If there is a next element in the same array, add it to the heap if element_idx + 1 < len(sorted_arrays[array_idx]): next_element = sorted_arrays[array_idx][element_idx + 1] heapq.heappush(min_heap, (next_element, array_idx, element_idx + 1)) return result"},{"question":"```python class BinarySearchTree: class Node: def __init__(self, label): self.label = label self.left = None self.right = None def __init__(self): self.root = None def put(self, label): if not self.root: self.root = BinarySearchTree.Node(label) else: self._put(label, self.root) def _put(self, label, node): if label < node.label: if node.left: self._put(label, node.left) else: node.left = BinarySearchTree.Node(label) else: if node.right: self._put(label, node.right) else: node.right = BinarySearchTree.Node(label) def inorder_traversal(self): nodes = [] self._inorder_traversal(self.root, nodes) return nodes def _inorder_traversal(self, node, nodes): if node: self._inorder_traversal(node.left, nodes) nodes.append(node) self._inorder_traversal(node.right, nodes) def balance(self): # Your code goes here pass # You need to implement the tree balancing algorithm here # Task Implement a method `height(self) -> int` in the `BinarySearchTree` class which returns the height of the tree. If the tree is empty, the height should be -1. # Input This implementation does not require any input as it operates on the `BinarySearchTree` instance itself. # Output Return an integer representing the height of the tree. # Constraints * The tree may contain any number of nodes, including none. # Example Consider the following sequence of events: ```python t = BinarySearchTree() print(t.height()) # Output: -1 (tree is empty) t.put(1) print(t.height()) # Output: 0 (single node tree) t.put(2) t.put(3) t.put(4) print(t.height()) # Output: 3 # Tree looks like: # 1 # # 2 # # 3 # # 4 ``` # Tips 1. Define a helper method that computes the height of a given node recursively. 2. Base case: if the node is `None`, return -1. 3. Recursively compute the height of left and right subtrees and take the maximum of both, adding 1 for the current node. Implement your solution inside the `BinarySearchTree` class below. ```python class BinarySearchTree: class Node: def __init__(self, label): self.label = label self.left = None self.right = None def __init__(self): self.root = None def put(self, label): if not self.root: self.root = BinarySearchTree.Node(label) else: self._put(label, self.root) def _put(self, label, node): if label < node.label: if node.left: self._put(label, node.left) else: node.left = BinarySearchTree.Node(label) else: if node.right: self._put(label, node.right) else: node.right = BinarySearchTree.Node(label) def inorder_traversal(self): nodes = [] self._inorder_traversal(self.root, nodes) return nodes def _inorder_traversal(self, node, nodes): if node: self._inorder_traversal(node.left, nodes) nodes.append(node) self._inorder_traversal(node.right, nodes) def balance(self): # Implementation for balance method pass def height(self): # Your code goes here pass # You need to implement the height calculation here ```","solution":"class BinarySearchTree: class Node: def __init__(self, label): self.label = label self.left = None self.right = None def __init__(self): self.root = None def put(self, label): if not self.root: self.root = BinarySearchTree.Node(label) else: self._put(label, self.root) def _put(self, label, node): if label < node.label: if node.left: self._put(label, node.left) else: node.left = BinarySearchTree.Node(label) else: if node.right: self._put(label, node.right) else: node.right = BinarySearchTree.Node(label) def inorder_traversal(self): nodes = [] self._inorder_traversal(self.root, nodes) return nodes def _inorder_traversal(self, node, nodes): if node: self._inorder_traversal(node.left, nodes) nodes.append(node) self._inorder_traversal(node.right, nodes) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 else: left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1"},{"question":"# Problem Statement You are tasked with implementing a function to traverse a maze represented as a 2D grid. The maze contains walls marked with a `1` and open spaces marked with a `0`. Your starting position is at the top-left corner (0,0), and your goal is to determine if there is a path from the start to the bottom-right corner (N-1, M-1). You can only move up, down, left, or right. Return `True` if such a path exists and `False` otherwise. # Input * An integer N (2 <= N <= 100) representing the number of rows. * An integer M (2 <= M <= 100) representing the number of columns. * A 2D list of size NxM containing only `0`s and `1`s representing the maze grid. # Output * A boolean value `True` if a path exists from (0,0) to (N-1,M-1), otherwise `False`. # Constraints * The top-left corner and bottom-right corner are guaranteed to be open spaces (`0`). * The input grid elements are restricted to 0 or 1. # Example ```python Input N = 5 M = 5 maze = [ [0, 1, 1, 1, 1], [0, 0, 0, 1, 1], [1, 1, 0, 1, 1], [1, 1, 0, 0, 0], [1, 1, 1, 1, 0] ] Output True ``` # Explanation A possible path from (0,0) to (4,4) is: (0,0) -> (1,0) -> (1,1) -> (1,2) -> (2,2) -> (3,2) -> (3,3) -> (3,4) -> (4,4). # Function Signature ```python def is_path_exist(N: int, M: int, maze: [[int]]) -> bool: # Implement your solution here ``` # Notes 1. Ensure to handle diverse configurations and edge cases of the maze appropriately. 2. Implement the solution efficiently regarding time and space complexity.","solution":"def is_path_exist(N, M, maze): Returns True if there is a path from the top-left corner to the bottom-right corner in the maze grid, otherwise returns False. def is_safe(x, y): return 0 <= x < N and 0 <= y < M and maze[x][y] == 0 def dfs(x, y): if x == N-1 and y == M-1: # reached the bottom-right corner return True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] maze[x][y] = -1 # mark as visited for dx, dy in directions: nx, ny = x + dx, y + dy if is_safe(nx, ny) and dfs(nx, ny): return True maze[x][y] = 0 # reset mark return False return dfs(0, 0)"},{"question":"# Question: Implement a Secure Hash-based File Verifier You are required to implement a function, `verify_file`, which verifies the integrity of a received file by comparing its hash with a provided hash value. The function should support multiple hash algorithms (e.g., MD5, SHA-256) and handle different types of errors gracefully. Function Signature ```python def verify_file(filepath: str, expected_hash: str, algorithm: str = \'sha256\') -> bool: pass ``` Input * `filepath` (str): The path of the file to be verified. * `expected_hash` (str): The expected hash value of the file. * `algorithm` (str): The hash algorithm to be used for verification. Defaults to \'sha256\'. Output * The function should return `True` if the file\'s hash matches the provided hash value, otherwise `False`. Constraints * Support at least \'md5\', \'sha1\', and \'sha256\' hash algorithms. * Handle invalid `algorithm` input by raising an appropriate exception. * The function should handle file reading errors and non-existent files gracefully. * Optimize for performance when hashing large files. Example Scenario ```python # Assuming \'example.txt\' is a file whose correct SHA-256 hash value is \'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\'. verify_file(\\"example.txt\\", \\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\") ``` This function call should return `True` if the hash of \'example.txt\' matches the provided SHA-256 hash value.","solution":"import hashlib def verify_file(filepath: str, expected_hash: str, algorithm: str = \'sha256\') -> bool: Verifies the integrity of a file by comparing its hash with a provided hash value. :param filepath: The path of the file to be verified. :param expected_hash: The expected hash value of the file. :param algorithm: The hash algorithm to be used for verification. Defaults to \'sha256\'. :return: True if the file\'s hash matches the provided hash value, otherwise False. try: hash_func = None if algorithm == \'md5\': hash_func = hashlib.md5() elif algorithm == \'sha1\': hash_func = hashlib.sha1() elif algorithm == \'sha256\': hash_func = hashlib.sha256() else: raise ValueError(\\"Unsupported hash algorithm\\") with open(filepath, \'rb\') as file: while chunk := file.read(8192): hash_func.update(chunk) file_hash = hash_func.hexdigest() return file_hash == expected_hash except FileNotFoundError: print(f\\"File not found: {filepath}\\") return False except Exception as e: print(f\\"An error occurred: {e}\\") return False"},{"question":"# Problem Statement You are tasked with developing a function that determines the minimum number of operations required to convert one string into another through a series of allowed operations. Given two strings, `source` and `target`, only the following operations are permitted: - Insert a character - Remove a character - Replace a character The function must compute the minimum number of these operations required to transform the `source` string into the `target` string. # Function Signature ```python def min_edit_distance(source: str, target: str) -> int: Given two strings `source` and `target`, returns the minimum number of operations required to convert `source` to `target`. Parameters: source (str): the original string. target (str): the string to transform to. Returns: int: the minimum number of operations required. ``` # Input - Two strings `source` and `target`, both with lengths in the range (0 ≤ length ≤ 100). # Output - An integer representing the minimum number of operations required to transform `source` into `target`. # Example Usage ```python assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert min_edit_distance(\\"\\", \\"abc\\") == 3 assert min_edit_distance(\\"abc\\", \\"\\") == 3 ``` # Constraints - The function should efficiently handle both small and large input sizes within the given constraint. - Consider edge cases where one or both strings may be empty. # Explanation The solution will involve setting up a dynamic programming table to compare substrings of `source` and `target`, and computing the minimum operations for every possible pair of initial segments from both strings. # Additional Notes - Ensure the implementation uses an optimized approach to minimize time and space complexity. - Demonstrate understanding of the edit distance (Levenshtein distance) algorithm and dynamic programming techniques. This should thoroughly test the candidate\'s ability to devise and implement dynamic programming solutions to string transformation problems.","solution":"def min_edit_distance(source: str, target: str) -> int: Given two strings `source` and `target`, returns the minimum number of operations required to convert `source` to `target`. Parameters: source (str): the original string. target (str): the string to transform to. Returns: int: the minimum number of operations required. m = len(source) n = len(target) # Create a DP table to hold the minimum edit distance. dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize the table for base cases. for i in range(m + 1): dp[i][0] = i # If target is empty, the cost is removing all characters from source for j in range(n + 1): dp[0][j] = j # If source is empty, the cost is inserting all characters to form target # Fill the DP table. for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation else: dp[i][j] = min( dp[i - 1][j] + 1, # Remove operation dp[i][j - 1] + 1, # Insert operation dp[i - 1][j - 1] + 1 # Replace operation ) return dp[m][n]"},{"question":"# Temperature Conversion Between Celsius and Fahrenheit Scenario You are developing a software application that requires functionality to convert temperature values between Celsius and Fahrenheit scales. This is important for users who may prefer one scale over the other based on their regional or personal preferences. Task Your task is to implement two functions to convert temperatures between Celsius and Fahrenheit. The first function converts from Celsius to Fahrenheit, and the second function converts from Fahrenheit to Celsius. You are provided with the skeleton of these functions, and you need to implement them as described below. Functions 1. **Function `celsius_to_fahrenheit`:** - **Input**: A single float value `celsius` representing the temperature in Celsius. - **Output**: A float value representing the temperature in Fahrenheit. 2. **Function `fahrenheit_to_celsius`:** - **Input**: A single float value `fahrenheit` representing the temperature in Fahrenheit. - **Output**: A float value representing the temperature in Celsius. The conversion formulas are as follows: - To convert from Celsius to Fahrenheit: (F = (C times frac{9}{5}) + 32) - To convert from Fahrenheit to Celsius: (C = (F - 32) times frac{5}{9}) You also need to ensure that the conversions can be done back and forth accurately. ```python def celsius_to_fahrenheit(celsius: float) -> float: Convert Celsius temperature to Fahrenheit. Parameters: - celsius (float): Temperature in Celsius Returns: - float: Temperature in Fahrenheit # Your code here def fahrenheit_to_celsius(fahrenheit: float) -> float: Convert Fahrenheit temperature to Celsius. Parameters: - fahrenheit (float): Temperature in Fahrenheit Returns: - float: Temperature in Celsius # Your code here ``` Examples ```python # Example for celsius_to_fahrenheit print(celsius_to_fahrenheit(0)) # 32.0 print(celsius_to_fahrenheit(100)) # 212.0 print(celsius_to_fahrenheit(-40)) # -40.0 print(celsius_to_fahrenheit(37)) # 98.6 # Example for fahrenheit_to_celsius print(fahrenheit_to_celsius(32)) # 0.0 print(fahrenheit_to_celsius(212)) # 100.0 print(fahrenheit_to_celsius(-40)) # -40.0 print(fahrenheit_to_celsius(98.6)) # 37.0 ``` Constraints * Ensure the functions handle edge cases and error inputs gracefully. * It’s important to check for potential floating-point arithmetic issues and round off as necessary to achieve accurate results. * Exceptions should be raised if any nonsensical inputs are provided (e.g., temperatures below absolute zero). **Note:** While rounding is not always required in temperature conversion, your function should strive for a high degree of precision, ideally to at least one decimal place.","solution":"def celsius_to_fahrenheit(celsius: float) -> float: Convert Celsius temperature to Fahrenheit. Parameters: - celsius (float): Temperature in Celsius Returns: - float: Temperature in Fahrenheit return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit: float) -> float: Convert Fahrenheit temperature to Celsius. Parameters: - fahrenheit (float): Temperature in Fahrenheit Returns: - float: Temperature in Celsius return (fahrenheit - 32) * 5/9"},{"question":"# Longest Common Subsequence in Two Strings Objective Given two strings `s1` and `s2`, write a function to determine the length of their longest common subsequence (LCS). A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: pass ``` Input 1. `s1` (str): The first string. 2. `s2` (str): The second string. Output An integer representing the length of the longest common subsequence of the given two strings. Constraints - `1 <= len(s1), len(s2) <= 1000` - The strings `s1` and `s2` consist only of lowercase English letters. Performance Requirements - The implementation should aim for a time complexity of O(m * n) and space complexity of O(m * n), where `m` is the length of `s1` and `n` is the length of `s2`. Scenario Consider a scenario where you want to find the maximum possible common sequence of activities or events from two different activity logs, which might help in understanding common user behavior patterns or synchronizing different data sources. Example ```python s1 = \\"abcdef\\" s2 = \\"axcyeff\\" result = longest_common_subsequence(s1, s2) # Expected output: # 4 # Explanation: The LCS is \\"acef\\" (or could also be \\"acef\\" from the end). ```","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Function to determine length of the longest common subsequence between two strings. # initialize the 2D dp array dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)] # build the dp array from bottom up for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # the last cell contains the length of the LCS return dp[-1][-1]"},{"question":"# Coding Assessment Question Question: You are tasked with creating a function that identifies the strongly connected components (SCCs) in a directed graph. An SCC in a directed graph is a maximal strongly connected subgraph. In other words, an SCC is a subgraph in which any two vertices are reachable from each other. Input: - An integer `n` representing the number of nodes. - A list of tuples `edges` where each tuple `(u, v)` indicates a directed edge from node `u` to node `v`. Output: - A list of lists, where each inner list contains the nodes of one SCC. Each SCC should be represented by the list of its node identifiers. Constraints: - `1 <= n <= 1000` - `0 <= len(edges) <= 10000` Performance Requirements: - Optimize the algorithm to handle large numbers of nodes and edges efficiently. Implementation: Write a function `find_scc` in Python that takes the above inputs and outputs the list of SCCs. Function signature: ```python def find_scc(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` Example: ```python # Input n = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] # Output [[0, 1, 2], [3], [4]] ``` Description: Implement the algorithm to find all strongly connected components in the given directed graph. Each SCC should be sorted in ascending order. The output list of SCCs should also be sorted in the ascending order based on the smallest node in each SCC. > Note: It is recommended to use algorithms like Kosaraju\'s or Tarjan\'s algorithm to efficiently identify SCCs in the graph.","solution":"from typing import List, Tuple def find_scc(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: from collections import defaultdict def kosaraju_scc(n, graph): def dfs1(v): visited[v] = True for u in graph[v]: if not visited[u]: dfs1(u) stack.append(v) def dfs2(v, component): visited[v] = True component.append(v) for u in transpose[v]: if not visited[u]: dfs2(u, component) graph = defaultdict(list) for u, v in edges: graph[u].append(v) transpose = defaultdict(list) for u in graph: for v in graph[u]: transpose[v].append(u) visited = [False] * n stack = [] for i in range(n): if not visited[i]: dfs1(i) visited = [False] * n sccs = [] while stack: node = stack.pop() if not visited[node]: component = [] dfs2(node, component) sccs.append(sorted(component)) sccs.sort(key=lambda x: x[0]) return sccs return kosaraju_scc(n, edges)"},{"question":"**Scenario**: You are given an array `logs`, where each element `logs[i] = (u, v)` indicates a directed edge from node `u` to node `v`. Your task is to determine if there is a cycle in the directed graph comprised of `m` edges and `n` nodes labeled from `0` to `n-1`. **Instructions**: - Implement the `Graph` class as described. - The `add_edge` method should add a directed edge from `u` to `v`. - The `has_cycle` method should return `True` if there is a cycle in the graph and `False` otherwise. **Function Signature**: The function signatures should be as follows: ```python class Graph: def __init__(self, n: int): # Initialization code goes here def add_edge(self, u: int, v: int): # Code to add edge (u, v) goes here def has_cycle(self) -> bool: # Code to check for cycle goes here ``` # Expected Input and Output **Input**: - `n` (int): Number of nodes in the graph. - `logs` (List[Tuple[int, int]]): List of directed edges, where each edge is represented as a tuple `(u, v)`, indicating an edge from node `u` to node `v`. **Output**: - `has_cycle` method should return `True` if there is a cycle in the graph, `False` otherwise. # Sample Input: ```python n = 4 logs = [ (0, 1), (1, 2), (2, 0), (2, 3) ] g = Graph(n) for u, v in logs: g.add_edge(u, v) print(g.has_cycle()) # Output should be True logs = [ (0, 1), (1, 2), (2, 3) ] g = Graph(n) for u, v in logs: g.add_edge(u, v) print(g.has_cycle()) # Output should be False ``` **Constraints**: - Number of nodes `1 <= n <= 1000`. - Number of edges `0 <= m <= 2000`. **Performance Requirements**: The solution should efficiently detect cycles using algorithms such as Depth-First Search (DFS) with proper handling for directed graphs.","solution":"class Graph: def __init__(self, n: int): self.n = n self.adj_list = [[] for _ in range(n)] def add_edge(self, u: int, v: int): self.adj_list[u].append(v) def has_cycle_util(self, node, visited, rec_stack): # Mark the current node as visited and part of recursion stack visited[node] = True rec_stack[node] = True # Recur for all vertices adjacent to this vertex for neighbour in self.adj_list[node]: if not visited[neighbour]: if self.has_cycle_util(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: return True # Remove the vertex from recursion stack rec_stack[node] = False return False def has_cycle(self) -> bool: visited = [False] * self.n rec_stack = [False] * self.n # Call the recursive helper function to detect cycle in different DFS trees for node in range(self.n): if not visited[node]: if self.has_cycle_util(node, visited, rec_stack): return True return False"},{"question":"# Scenario: You are working on a network simulation tool that models data transmission between nodes. One of the essential components is determining whether a packet is successfully transmitted based on the status codes of the sender and receiver. A packet is considered successfully transmitted if both the sender and the receiver have a status code of \\"ready\\". # Function Specification **Function name**: `is_transmission_successful` **Input**: - `sender_status` (str): The status code of the sender (\\"ready\\" or \\"not ready\\"). - `receiver_status` (str): The status code of the receiver (\\"ready\\" or \\"not ready\\"). **Output**: - (bool): `True` if the packet is successfully transmitted, `False` otherwise. **Constraints**: - The inputs will always be non-empty strings containing either \\"ready\\" or \\"not ready\\". - The function should be implemented in constant time, O(1). **Examples**: ```python >>> is_transmission_successful(\\"ready\\", \\"ready\\") True >>> is_transmission_successful(\\"ready\\", \\"not ready\\") False >>> is_transmission_successful(\\"not ready\\", \\"ready\\") False >>> is_transmission_successful(\\"not ready\\", \\"not ready\\") False ``` # Task: Complete the implementation of the `is_transmission_successful` function to correctly determine if the packet is successfully transmitted based on the given status codes.","solution":"def is_transmission_successful(sender_status, receiver_status): Determines whether the packet is successfully transmitted based on the status codes. Args: sender_status (str): The status code of the sender (\\"ready\\" or \\"not ready\\"). receiver_status (str): The status code of the receiver (\\"ready\\" or \\"not ready\\"). Returns: bool: True if the packet is successfully transmitted, False otherwise. return sender_status == \\"ready\\" and receiver_status == \\"ready\\""},{"question":"# Binary Search Tree Node Count Context In Computer Science, a Binary Search Tree (BST) is a tree data structure where each node has at most two children, referred to as the left child and the right child. For each node, its left descendants\' values are less than its own value, and its right descendants\' values are greater. Task You are required to implement a function `count_nodes_in_bst` that calculates the number of nodes in a given Binary Search Tree. Requirements 1. **Function Name**: `count_nodes_in_bst` 2. **Input**: - `root`: A `TreeNode` object representing the root of the BST, where `TreeNode` is a class defined with attributes for the node value and its left and right children. 3. **Output**: - Returns an integer representing the total number of nodes in the BST. Constraints * The tree can have at most 10^4 nodes. * Node values will be distinct integers within the range of -10^6 to 10^6. Performance Requirements The implemented function should traverse all nodes to count them, so it should have a time complexity of O(n), where `n` is the number of nodes in the tree. Class Definition for TreeNode ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Function Signature ```python def count_nodes_in_bst(root): pass ``` Example ```python # Example 1: # Input: root = TreeNode(10, TreeNode(5), TreeNode(15)) # Output: 3 # Explanation: # 10 # / # 5 15 # There are 3 nodes in this BST. # Example 2: # Input: root = None # Output: 0 # Explanation: The tree is empty, so the count is 0. # Example 3: # Input: root = TreeNode(7, TreeNode(3), TreeNode(10, TreeNode(8), TreeNode(15))) # Output: 5 # Explanation: # 7 # / # 3 10 # / # 8 15 # There are 5 nodes in this BST. ``` # Notes * You should write your solution considering optimal traversal methods to achieve the required time complexity. * Assume the function will be tested with various inputs to ensure correctness and efficiency.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes_in_bst(root): Returns the total number of nodes in the given Binary Search Tree. :param root: TreeNode object representing the root of the BST :return: Integer count of nodes if root is None: return 0 left_count = count_nodes_in_bst(root.left) right_count = count_nodes_in_bst(root.right) return 1 + left_count + right_count"},{"question":"# Question Statement - Compute Maximum Sum of Non-Adjacent Elements Given an array of integers, write a function `max_non_adj_sum` that computes the maximum sum of its elements such that no two elements selected are adjacent in the array. Ensure an optimal O(n) time complexity solution with O(1) space complexity. # Input Format: * A single integer n, the number of elements in the array. * A single line of n integers, the elements of the array. # Output Format: * A single integer - the maximum sum of non-adjacent elements in the array. # Constraints: * 1 ≤ n ≤ 10000 * -10^4 ≤ array[i] ≤ 10^4 # Example: Input: ``` 6 3 2 5 10 7 ``` Output: ``` 15 ``` Explanation: The maximum sum can be obtained by selecting elements 3, 10, and 2, resulting in a sum of 3 + 10 + 2 = 15. # Example 2: Input: ``` 4 3 2 7 10 ``` Output: ``` 13 ``` Explanation: The maximum sum can be obtained by selecting elements 3 and 10, resulting in a sum of 3 + 10 = 13. # Example 3: Input: ``` 2 -1 5 ``` Output: ``` 5 ``` Explanation: The maximum sum can be obtained by selecting the single element 5. # Function Signature: ```python def max_non_adj_sum(arr: List[int]) -> int: # Complete the function implementation ``` Implement this function with the above specifications ensuring an optimized approach for both time and space efficiency.","solution":"def max_non_adj_sum(arr): Computes the maximum sum of non-adjacent elements in the given array. if not arr: return 0 n = len(arr) if n == 1: return max(0, arr[0]) prev_prev = max(0, arr[0]) prev = max(prev_prev, arr[1]) for i in range(2, n): current = max(prev, prev_prev + arr[i]) prev_prev = prev prev = current return prev"},{"question":"# Problem Statement: You are given a directed graph where each node represents an employee and each directed edge `(u, v)` indicates that employee `u` reports to employee `v`. The company\'s highest-ranking employee (the CEO) does not report to anyone and is considered the root of this organizational hierarchy. Your task is to find the lowest common manager (LCM) of two given employees. The LCM of two nodes `a` and `b` is defined as the deepest node that is an ancestor of both `a` and `b`. Implement the `find_lowest_common_manager` function, which takes as input the root of the organization, the two employees for which the LCM is to be found, and the adjacency list representation of the graph. # Functions to Implement: 1. `find_lowest_common_manager(root, emp1, emp2, hierarchy) -> int` **Parameters**: - `root` (int): The highest-ranking employee (CEO) in the company. - `emp1` (int): The first employee. - `emp2` (int): The second employee. - `hierarchy` (dict): The adjacency list representation of the graph, where key is the node and value is the list of employees reporting directly to that node. **Returns**: - `lcm` (int): The lowest common manager for the given employees. # Constraints: - Each node (employee) has a unique integer ID. - There is exactly one root (CEO). - The graph is a valid tree with each employee (except the root) having exactly one direct manager. # Example: ```python root = 1 emp1 = 4 emp2 = 5 hierarchy = { 1: [2, 3], 2: [4, 5], 3: [6, 7] } print(find_lowest_common_manager(root, emp1, emp2, hierarchy)) # Output should be 2 emp1 = 4 emp2 = 6 print(find_lowest_common_manager(root, emp1, emp2, hierarchy)) # Output should be 1 ``` # Hints: - Perform a depth-first traversal (DFS) to find the paths from the root to both employees. - Compare the paths to determine the deepest common ancestor.","solution":"def find_lowest_common_manager(root, emp1, emp2, hierarchy): def find_path(current, target, path): path.append(current) if current == target: return True if current in hierarchy: for child in hierarchy[current]: if find_path(child, target, path): return True path.pop() return False path1 = [] path2 = [] find_path(root, emp1, path1) find_path(root, emp2, path2) i = 0 while i < len(path1) and i < len(path2) and path1[i] == path2[i]: i += 1 return path1[i-1]"},{"question":"# Scenario You are given a list of integers where each integer represents the number of matches won by a player in a league. Players are ranked based on the number of matches they have won. You need to determine the ranking of each player. Players with the same number of wins should be given the same rank, and the subsequent rank should skip the appropriate number of positions. # Problem Statement Write a function `calculate_ranks` that receives a list of integers `matches_won` and returns a list of integers representing the rank of each player. The ranking should be in descending order of matches won. # Input Format A single list of integers `matches_won`, where each integer represents the number of matches a player has won. # Output Format A list of integers representing the rank of each player. # Constraints * The length of `matches_won` is at most 10,000. * Each value in `matches_won` is a non-negative integer and at most 10,000. # Function Signature ```python def calculate_ranks(matches_won: list) -> list: # implementation here ``` # Examples Example 1 **Input**: ```python [10, 3, 8, 8, 7, 5] ``` **Output**: ```python [1, 6, 2, 2, 4, 5] ``` **Explanation**: * Player 1 has the highest number of wins (10) and is ranked 1. * Players 2, 5, and 6 have 3, 7, and 5 wins respectively and are ranked 6, 4, and 5. * Players 3 and 4 have tied with 8 wins and are ranked 2. Example 2 **Input**: ```python [4, 2, 2, 3] ``` **Output**: ```python [1, 3, 3, 2] ``` **Explanation**: * Player 1 has the highest number of wins (4) and is ranked 1. * Players 2 and 3 have tied with 2 wins and are ranked 3. * Player 4 has 3 wins and is ranked 2.","solution":"def calculate_ranks(matches_won): Calculate the ranks of players based on matches won. Parameters: matches_won (list): A list of integers where each integer represents the number of matches won by a player. Returns: list: A list of integers representing the rank of each player. # Tuple of (matches_won, index), and sort the players by wins in descending order sorted_players = sorted(enumerate(matches_won), key=lambda x: x[1], reverse=True) ranks = [0] * len(matches_won) current_rank = 1 # Iterate over the sorted players for i, (index, wins) in enumerate(sorted_players): if i > 0 and wins < sorted_players[i - 1][1]: current_rank = i + 1 ranks[index] = current_rank return ranks"},{"question":"# Tic-Tac-Toe Winner Checker **Context**: You are developing a function to determine the winner of a Tic-Tac-Toe game. In this game, each player is represented by \'X\' or \'O\', and the board is a 3x3 grid represented as a list of lists. Your function should identify if there is a winner or if the game is still ongoing. **Task**: Implement a function `check_tic_tac_toe_winner(board: List[List[str]]) -> str` that checks the current state of the board and returns the winner or the game state. **Requirements**: 1. The function should identify if a player has won by having three of their markers in a row, column, or diagonal. 2. If there is a winner, return \'X\' or \'O\' based on which player won. 3. If the game is still ongoing (i.e., there are empty spaces represented by \'.\'), return \'Ongoing\'. 4. If the game is a draw (i.e., no empty spaces and no winner), return \'Draw\'. 5. Ensure the function handles all potential game states appropriately. **Input**: * A list `board` of 3 lists, each containing 3 strings: \'X\', \'O\', or \'.\'. **Output**: * A string indicating the game state: \'X\', \'O\', \'Ongoing\', or \'Draw\'. **Constraints**: * The board is always a 3x3 grid. * The elements of the board are limited to \'X\', \'O\', or \'.\'. **Examples**: ```python board = [[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'.\', \'O\', \'X\']] print(check_tic_tac_toe_winner(board)) # Output: \'Ongoing\' board = [[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'O\', \'X\', \'X\']] print(check_tic_tac_toe_winner(board)) # Output: \'X\' board = [[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'X\'], [\'O\', \'X\', \'O\']] print(check_tic_tac_toe_winner(board)) # Output: \'Draw\' ``` **Edge Cases**: - `check_tic_tac_toe_winner([[\'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\']])` should return `Ongoing`. - `check_tic_tac_toe_winner([[\'X\', \'X\', \'X\'], [\'.\', \'O\', \'O\'], [\'O\', \'.\', \'.\']])` should return `X`.","solution":"from typing import List def check_tic_tac_toe_winner(board: List[List[str]]) -> str: Determines the winner of a Tic Tac Toe game or if the game is ongoing or a draw. # Check rows for row in board: if row[0] == row[1] == row[2] and row[0] != \'.\': return row[0] # Check columns for col in range(3): if board[0][col] == board[1][col] == board[2][col] and board[0][col] != \'.\': return board[0][col] # Check diagonals if board[0][0] == board[1][1] == board[2][2] and board[0][0] != \'.\': return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != \'.\': return board[0][2] # Check for ongoing game for row in board: if \'.\' in row: return \'Ongoing\' return \'Draw\'"},{"question":"# Problem Statement You are tasked with adding a new feature to a geometry processing library. This library needs a function to determine if a point lies within a polygon on a 2D plane. The vertices of the polygon are provided in a sequential order (either clockwise or counterclockwise). Your function should efficiently check if a given point is inside the polygon. Function Signature ```python def is_point_in_polygon(polygon: list[tuple[int, int]], point: tuple[int, int]) -> bool: Determine if a point lies within a polygon. Args: polygon (list): A list of tuples representing the vertices of the polygon in order. point (tuple): A tuple representing the (x, y) coordinates of the point. Returns: bool: True if the point lies inside the polygon, False otherwise. Example: >>> is_point_in_polygon([(0,0), (4,0), (4,4), (0,4)], (2,2)) True >>> is_point_in_polygon([(0,0), (4,0), (4,4), (0,4)], (5,5)) False pass ``` # Constraints: * The `polygon` list will contain at least 3 vertices and at most 10,000 vertices. * Each vertex and the point will have integer coordinates within the range ([-10^4, 10^4]). # Requirements: * The function should return `True` if the point lies strictly inside the polygon, and `False` if it lies outside or on the boundary. * Use an efficient algorithm suitable for large polygons. * Include edge cases in testing such as points on the vertices, edges, and colinear points. # Example: ```python >>> is_point_in_polygon([(0,0), (4,0), (4,4), (0,4)], (2,2)) True >>> is_point_in_polygon([(0,0), (4,0), (4,4), (0,4)], (5,5)) False >>> is_point_in_polygon([(1,1), (1,5), (5,5), (5,1)], (3,1)) False ``` # Performance: * Aim for a computational complexity of O(n), where n is the number of vertices in the polygon.","solution":"def is_point_in_polygon(polygon: list[tuple[int, int]], point: tuple[int, int]) -> bool: Determine if a point lies within a polygon. Args: polygon (list): A list of tuples representing the vertices of the polygon in order. point (tuple): A tuple representing the (x, y) coordinates of the point. Returns: bool: True if the point lies inside the polygon, False otherwise. x, y = point n = len(polygon) inside = False p1x, p1y = polygon[0] for i in range(n + 1): p2x, p2y = polygon[i % n] if y > min(p1y, p2y): if y <= max(p1y, p2y): if x <= max(p1x, p2x): if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / float(p2y - p1y) + p1x if p1x == p2x or x <= xinters: inside = not inside p1x, p1y = p2x, p2y return inside"},{"question":"# Problem Statement: You are required to implement a function that rotates a given image 90 degrees clockwise. The function should take in a list of lists representation of the image and return the rotated image in the same format. # Function Signature: ```python def rotate_image_90_clockwise(image: List[List[List[int]]]) -> List[List[List[int]]]: pass ``` # Input: - `image`: A list of lists where each sublist represents a row of the image, and each element in the row is a list [R, G, B] representing the color of a pixel. # Output: - Returns a list of lists representing the image rotated 90 degrees clockwise. # Constraints: - 0 < len(image) <= 1000 - 0 < len(image[0]) <= 1000 - All RGB values are integers between 0 and 255. # Performance Requirements: - The function should be efficient and run within a reasonable time for images of maximum size. # Example: ```python original_image = [ [[255, 0, 0], [0, 255, 0], [0, 0, 255]], [[255, 255, 0], [0, 255, 255], [255, 0, 255]], [[0, 0, 0], [128, 128, 128], [255, 255, 255]] ] rotated_image = rotate_image_90_clockwise(original_image) # Expected output: # [ # [[0, 0, 0], [255, 255, 0], [255, 0, 0]], # [[128, 128, 128], [0, 255, 255], [0, 255, 0]], # [[255, 255, 255], [255, 0, 255], [0, 0, 255]] # ] ``` # Notes: - Ensure your function handles edge cases gracefully, such as images that are already symmetric or have only one row or column. - Pay attention to performance and try to avoid unnecessary computations to keep the process efficient. - The dimensions of the input image and the output rotated image will be different (i.e., the height of the input will be the width of the output and vice versa).","solution":"from typing import List def rotate_image_90_clockwise(image: List[List[List[int]]]) -> List[List[List[int]]]: Rotates the given image 90 degrees clockwise. :param image: List of Lists where each sublist represents a row of the image, and each element in the row is a list [R, G, B]. :return: Rotated image as a list of lists. n = len(image) m = len(image[0]) rotated_image = [] for col in range(m): new_row = [] for row in range(n - 1, -1, -1): new_row.append(image[row][col]) rotated_image.append(new_row) return rotated_image"},{"question":"Problem Statement Design a function to determine if a given matrix of integers contains a path from the top-left corner to the bottom-right corner. You can only move right or down, and you can only step on cells that have a non-zero value. # Function Signature: ```python def has_path(matrix: list[list[int]]) -> bool: pass ``` # Input: * `matrix`: A list of lists of integers representing the matrix, where 0 <= len(matrix), len(matrix[0]) <= 1000, and -10^6 <= matrix[i][j] <= 10^6 # Output: * Returns `True` if there exists a path from the top-left corner to the bottom-right corner of the matrix by only moving right or down, and only through non-zero cells, otherwise `False`. # Examples: ```python assert has_path([[1, 1, 0], [1, 0, 0], [1, 1, 1]]) == True assert has_path([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) == False assert has_path([[1]]) == True assert has_path([[0]]) == False assert has_path([[1, 1], [0, 1], [1, 1]]) == True ``` # Constraints and Requirements: 1. Your solution should be optimized for performance in both time and space complexity. 2. Consider edge cases such as the matrix having only one cell, all cells being zero, or having large dimensions. 3. Include error checking and handle possible exceptions that might arise. 4. You may assume that the input matrix consists only of integers and is non-empty. # Note: The problem involves finding a viable path in the given matrix by employing a search algorithm. Common approaches include depth-first search (DFS) or breadth-first search (BFS). Ensure that the implemented algorithm efficiently handles large matrices and properly addresses all edge cases.","solution":"from collections import deque def has_path(matrix: list[list[int]]) -> bool: if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) if matrix[0][0] == 0 or matrix[rows-1][cols-1] == 0: return False directions = [(1, 0), (0, 1)] # Only move down or right queue = deque([(0, 0)]) # Start BFS from the top-left corner visited = set((0, 0)) while queue: r, c = queue.popleft() if (r, c) == (rows-1, cols-1): return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] != 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) return False"},{"question":"Merge K Sorted Lists Context: Merging multiple sorted lists into a single sorted list is a common problem in computer science. You are tasked to merge `k` sorted linked lists into one sorted linked list efficiently. Task: Write a function to merge `k` sorted linked lists and return it as one sorted list. Analyze the complexity and consider optimizations for handling a large number of lists. Requirements: 1. **Input**: A list of `k` linked lists, where each linked list is sorted in ascending order. 2. **Output**: A single linked list merged from all the input lists, maintaining the sorted order. Input and Output Constraints: * Each linked list contains between 0 and 10^4 nodes. * All values in the linked lists are between -10^4 and 10^4. * The total number of linked lists `k` can be up to 10^3. Implementation: Your solution should: 1. Utilize an efficient algorithm to minimize the overall time complexity. 2. Consider using data structures that support efficient retrieval and insertion of minimum elements. Function Signature: ```python from typing import List, Optional class ListNode: def __init__(self, val:int=0, next:Optional[\'ListNode\']=None): self.val = val self.next = next def merge_k_lists(lists:List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` Example: ```python # Helper function to convert list to linked list def build_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Test linked lists lists = [build_linked_list([1,4,5]), build_linked_list([1,3,4]), build_linked_list([2,6])] # Call the function result = merge_k_lists(lists) # Convert resulting linked list to a list for easy verification def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result print(linked_list_to_list(result)) # Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` In this question, you are expected to implement the `merge_k_lists` function to handle the merging of multiple sorted linked lists into one sorted linked list. This will test your understanding of linked lists, efficient sorting algorithms, and handling large inputs.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val:int=0, next:Optional[\'ListNode\']=None): self.val = val self.next = next def __lt__(self, other): # Define a less-than function so ListNode can be compared in the heap return self.val < other.val def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: # Create a min-heap min_heap = [] # Initialize the heap with the head of each linked list for l in lists: if l: heapq.heappush(min_heap, l) # Dummy node to start the final sorted list dummy = ListNode() current = dummy # While we have elements in the heap while min_heap: # Get the smallest element smallest_node = heapq.heappop(min_heap) # Add that node to the result current.next = smallest_node current = current.next # If there is a next node in the list, add it to the heap if smallest_node.next: heapq.heappush(min_heap, smallest_node.next) return dummy.next"},{"question":"# Problem Statement: Implement a function that encodes a given string using a simple Atbash cipher. The Atbash cipher is a substitution cipher with a specific key where the letters of the alphabet are reversed. That is, all \'A\'s are substituted with \'Z\'s, all \'B\'s with \'Y\'s, and so on. # Constraints: * The input will be a non-empty string consisting of only uppercase letters. * The output should preserve spaces as they are. # Sample Input/Output: ```plaintext atbash_cipher(\\"HELLO WORLD\\") Returns: \\"SVOOL DLIOW\\" atbash_cipher(\\"SECRET MESSAGE\\") Returns: \\"HVXIVG NVHHZTV\\" ``` # Function Signature: ```python def atbash_cipher(message: str) -> str: pass ``` # Requirements: 1. Define the Atbash cipher dictionary where each letter maps to its reverse counterpart. 2. Convert the input string to its Atbash cipher equivalent by replacing each letter according to the cipher dictionary. 3. Preserve spaces in their original positions in the input string. # Explanation: 1. The Atbash cipher dictionary will be created such that for each letter from \'A\' to \'Z\', it maps to \'Z\' to \'A\' respectively. 2. Each letter in the input string is replaced with its reverse counterpart from the Atbash cipher dictionary. 3. Spaces in the input string are preserved and directly copied to the output. # Edge Cases: * Ensure that input strings without spaces or mixed with spaces between words are correctly encoded. * The function should handle larger input strings efficiently while preserving spaces. # Notes: * The encoding process is purely character-based, ignoring spaces but preserving their positions. * This function should be straightforward, requiring only a single pass through the string to replace characters. ```python def atbash_cipher(message: str) -> str: atbash_dict = {chr(i): chr(90 - (i - 65)) for i in range(65, 91)} # A-Z -> Z-A mapping return \'\'.join(atbash_dict[char] if char != \' \' else \' \' for char in message) ```","solution":"def atbash_cipher(message: str) -> str: atbash_dict = {chr(i): chr(90 - (i - 65)) for i in range(65, 91)} # A-Z -> Z-A mapping return \'\'.join(atbash_dict[char] if char != \' \' else \' \' for char in message)"},{"question":"# Problem Statement You have been tasked with developing a scheduling application that requires the capability to find the longest sequence of increasing integers in a provided array. Your function should return the length of the longest such subsequence. Your task is to implement the function `longest_increasing_subsequence(arr: List[int]) -> int` which computes the length of the longest strictly increasing subsequence in the given array. # Function Signature ```python def longest_increasing_subsequence(arr: List[int]) -> int: ``` # Input * `arr` : A list of integers where (0 ≤ len(arr) ≤ 1000) representing the sequence of integers. # Output * An integer representing the length of the longest strictly increasing subsequence in the array. # Constraints * Raise a `TypeError` if the input is not a list. * Raise a `ValueError` if any element in the list is not an integer. # Examples Example 1 Input: ```python longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) ``` Output: ```python 4 ``` Explanation: The longest increasing subsequence is [2, 3, 7, 101]. Example 2 Input: ```python longest_increasing_subsequence([]) ``` Output: ```python 0 ``` Explanation: There is no subsequence in an empty array. Example 3 Input: ```python longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) ``` Output: ```python 4 ``` Explanation: The longest increasing subsequence is [-1, 0, 2, 3]. # Performance Requirements Your solution should efficiently compute the longest increasing subsequence, ideally in O(n log n) time complexity. # Notes 1. The sequence must be strictly increasing (each element must be greater than the preceding element). 2. If there are multiple subsequences with the same maximum length, any one of them is valid to determine the length.","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: if not isinstance(arr, list): raise TypeError(\\"Input must be a list.\\") if any(not isinstance(x, int) for x in arr): raise ValueError(\\"All elements in the list must be integers.\\") if not arr: return 0 # Creating an array to store our sub-problems, initialized to 1 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence will be the maximum value in dp return max(dp)"},{"question":"# Coding Assessment Question Problem Statement You are required to write a function that flattens a nested list of integers. A nested list is a list that may contain integer elements as well as other nested lists of integers. Your task is to flatten this list to a single level, preserving the order of the elements as they appear in the original nested list. You need to implement the function `flatten_list(nested_list: list) -> list` that takes a nested list `nested_list` as input and returns a flattened list containing all the integers in the original nested list, in the same order. Input and Output Format - **Input**: A single nested list `nested_list` containing integers and/or other nested lists. - **Output**: A list of integers, representing the flattened version of the input nested list. Constraints - The input nested list can have a depth of up to 10. - The nested lists can contain up to 10^6 integer elements in total. - All integer values are within the range of -10^9 to 10^9. Examples ```python >>> flatten_list([1, [2, [3, 4]], 5]) [1, 2, 3, 4, 5] >>> flatten_list([[1, 2, [3]], 4]) [1, 2, 3, 4] >>> flatten_list([1, [2, [3, [4, [5]]]]]) [1, 2, 3, 4, 5] >>> flatten_list([]) [] >>> flatten_list([1, [2], [3, [4, [5, [6, [7, 8]]]]], 9]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_list([[], [[], []], [[[]]]]) [] >>> flatten_list([1, 2, [3, [4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list([[[], [1], [], [2, [3, [4]]], []], 5]) [1, 2, 3, 4, 5] ``` Notes - Your implementation should ensure linear time complexity in relation to the total number of elements in all the nested lists. - Handle edge cases, including empty lists and deeply nested structures. - Ensure the function maintains the order of elements as they appear in the original nested list.","solution":"def flatten_list(nested_list): def flatten(nlist): for item in nlist: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(nested_list))"},{"question":"# Sorting Strings By Length and Lexicographical Order You need to implement a function to sort a list of strings based on their lengths. If two strings have the same length, they should be sorted lexicographically (alphabetically). Function Signature ```python def sort_strings(strings: list[str]) -> list[str]: pass ``` Input 1. `strings`: A list of strings. Output The function should return a new list of strings, sorted by their lengths, and if two strings have the same length, they should be sorted lexicographically. Constraints - The list `strings` will contain between 1 and 100 strings. - Each string will contain between 1 and 100 characters. - All strings will consist of lowercase English letters. Example ```python strings = [\\"banana\\", \\"apple\\", \\"pear\\", \\"kiwi\\", \\"fig\\"] sort_strings(strings) # Output: [\\"fig\\", \\"kiwi\\", \\"pear\\", \\"apple\\", \\"banana\\"] strings = [\\"bbb\\", \\"aaa\\", \\"ccc\\", \\"aaaa\\", \\"kk\\"] sort_strings(strings) # Output: [\\"kk\\", \\"aaa\\", \\"bbb\\", \\"ccc\\", \\"aaaa\\"] ``` Doctests The following doctests should also pass: ```python def test_sort_strings(): assert sort_strings( [\\"banana\\", \\"apple\\", \\"pear\\", \\"kiwi\\", \\"fig\\"] ) == [\\"fig\\", \\"kiwi\\", \\"pear\\", \\"apple\\", \\"banana\\"] assert sort_strings( [\\"bbb\\", \\"aaa\\", \\"ccc\\", \\"aaaa\\", \\"kk\\"] ) == [\\"kk\\", \\"aaa\\", \\"bbb\\", \\"ccc\\", \\"aaaa\\"] assert sort_strings( [\\"abc\\", \\"abcd\\", \\"ab\\", \\"a\\", \\"b\\", \\"c\\"] ) == [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"abc\\", \\"abcd\\"] assert sort_strings( [\\"zebra\\", \\"dog\\", \\"cat\\", \\"apple\\", \\"banana\\"] ) == [\\"cat\\", \\"dog\\", \\"apple\\", \\"zebra\\", \\"banana\\"] ``` Notes - Ensure your function handles sorting correctly for both length and lexicographical order. - Test your function on various lists of strings to ensure accuracy.","solution":"def sort_strings(strings: list[str]) -> list[str]: Sort a list of strings based on their length. If two strings have the same length, they should be sorted lexicographically. return sorted(strings, key=lambda x: (len(x), x)) # Example usage # strings = [\\"banana\\", \\"apple\\", \\"pear\\", \\"kiwi\\", \\"fig\\"] # print(sort_strings(strings)) # Output: [\\"fig\\", \\"kiwi\\", \\"pear\\", \\"apple\\", \\"banana\\"] # strings = [\\"bbb\\", \\"aaa\\", \\"ccc\\", \\"aaaa\\", \\"kk\\"] # print(sort_strings(strings)) # Output: [\\"kk\\", \\"aaa\\", \\"bbb\\", \\"ccc\\", \\"aaaa\\"]"},{"question":"Problem Statement: Imagine you are tasked with managing a library system where each book has a unique identifier and the borrowing process involves keeping track of borrowed books. Your goal is to write a set of functions that help in managing the library system efficiently by recording borrowed books, checking the availability of a book, and calculating the number of currently borrowed books. # Specifications: 1. Implement the function `borrow_book`. - **Input**: A dictionary `library` where keys are book identifiers (strings) and values are booleans indicating whether a book is borrowed (`True` if borrowed, `False` otherwise). A string `book_id` representing the identifier of the book to be borrowed. - **Output**: Update the `library` dictionary such that the value for the given `book_id` is set to `True`. If the book is already borrowed, no changes should be made. Return the updated dictionary. 2. Implement the function `return_book`. - **Input**: A dictionary `library` where keys are book identifiers (strings) and values are booleans indicating whether a book is borrowed (`True` if borrowed, `False` otherwise). A string `book_id` representing the identifier of the book to be returned. - **Output**: Update the `library` dictionary such that the value for the given `book_id` is set to `False`. If the book is not borrowed, no changes should be made. Return the updated dictionary. 3. Implement the function `is_borrowed`. - **Input**: A dictionary `library` where keys are book identifiers (strings) and values are booleans indicating whether a book is borrowed (`True` if borrowed, `False` otherwise). A string `book_id` representing the identifier of the book to check. - **Output**: A boolean value indicating whether the given `book_id` is borrowed or not. 4. Implement the function `count_borrowed_books`. - **Input**: A dictionary `library` where keys are book identifiers (strings) and values are booleans indicating whether a book is borrowed (`True` if borrowed, `False` otherwise). - **Output**: An integer representing the number of borrowed books. # Example: ```python >>> library = { ... \\"001\\": False, ... \\"002\\": True, ... \\"003\\": False, ... \\"004\\": True ... } >>> borrow_book(library, \\"001\\") {\'001\': True, \'002\': True, \'003\': False, \'004\': True} >>> return_book(library, \\"002\\") {\'001\': True, \'002\': False, \'003\': False, \'004\': True} >>> is_borrowed(library, \\"001\\") True >>> is_borrowed(library, \\"003\\") False >>> count_borrowed_books(library) 2 ``` # Notes: - It is guaranteed that the `book_id` provided as input exists in the `library` dictionary. - The functions should handle case where the book is already in the desired state (already borrowed or already returned). - You should not use any external libraries.","solution":"def borrow_book(library, book_id): Borrow a book from the library. Parameters: library (dict): Dictionary with book IDs as keys and booleans as values indicating if the book is borrowed. book_id (str): The ID of the book to borrow. Returns: dict: Updated library dictionary. if book_id in library: library[book_id] = True return library def return_book(library, book_id): Return a book to the library. Parameters: library (dict): Dictionary with book IDs as keys and booleans as values indicating if the book is borrowed. book_id (str): The ID of the book to return. Returns: dict: Updated library dictionary. if book_id in library: library[book_id] = False return library def is_borrowed(library, book_id): Check if a book is borrowed. Parameters: library (dict): Dictionary with book IDs as keys and booleans as values indicating if the book is borrowed. book_id (str): The ID of the book to check. Returns: bool: True if the book is borrowed, False otherwise. return library.get(book_id, False) def count_borrowed_books(library): Count the number of borrowed books in the library. Parameters: library (dict): Dictionary with book IDs as keys and booleans as values indicating if the book is borrowed. Returns: int: Number of borrowed books. return sum(borrowed for borrowed in library.values())"},{"question":"# Stock Price Predictor **Objective**: Write a program that predicts the closing stock price of a given company for the next trading day based on historical data. **Task**: 1. Write a function `predict_stock_price` that takes a list of integers representing daily closing prices for the past N days. 2. Implement a simple moving average calculation to predict the next day\'s closing price. 3. The predicted price is the average of the given N days\' closing prices. ```python from typing import List def predict_stock_price(prices: List[int]) -> float: Predicts the closing stock price for the next trading day based on the past N days\' prices. Parameters: prices: List of integers representing historical stock closing prices. Returns: The predicted stock price for the next trading day as a float. # Code implementation here pass if __name__ == \\"__main__\\": prices = [int(x) for x in input(\\"Enter past N days\' closing prices: \\").split()] print(f\\"Predicted stock price for the next trading day: {predict_stock_price(prices)}\\") ``` **Constraints**: - The list `prices` will contain at least one element. - The prices will be positive integers. - The length of the list `prices` will not exceed 1000 elements. **Expected Input/Output**: - **Input**: A list of integers. - **Output**: A float representing the predicted stock price. **Examples**: 1. Input: `[150, 152, 153, 151, 155]` - [Output]: `152.2` 2. Input: `[100, 101, 102, 103, 104, 105, 106]` - [Output]: `103.0` **Performance Requirements**: - The solution should efficiently compute the moving average even for the maximum input size. - The function should gracefully handle abnormal inputs such as an unusually large list size without performance degradation.","solution":"from typing import List def predict_stock_price(prices: List[int]) -> float: Predicts the closing stock price for the next trading day based on the past N days\' prices. Parameters: prices: List of integers representing historical stock closing prices. Returns: The predicted stock price for the next trading day as a float. if not prices: raise ValueError(\\"The prices list should contain at least one element.\\") average = sum(prices) / len(prices) return round(average, 2)"},{"question":"# Coding Assessment Question **Context**: A sequence of positive integers follows the pattern where each term increases by a constant difference (d). In this case, you must determine whether for any given sequence of integers (a_1, a_2, ldots, a_n), it\'s possible to reorder the sequence to form an arithmetic progression. An arithmetic progression is defined as a sequence where the difference between consecutive terms is constant. Write a function to determine whether such a rearrangement is possible. **Function Signature**: ```python def can_form_arithmetic_progression(arr: List[int]) -> bool: This function determines if the given list of integers can be rearranged to form an arithmetic progression. ``` **Input**: * A list of integers `arr` of length `n` (1 ≤ n ≤ 10^5) where ( 1 ≤ arr[i] ≤ 10^9 ). **Output**: * A boolean value indicating whether the given list can be rearranged to form an arithmetic progression. **Example**: ```python >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 2, 4]) False >>> can_form_arithmetic_progression([10, 20, 30, 40, 50]) True >>> can_form_arithmetic_progression([7]) True ``` **Constraints/Notes**: * Any sequence with just one term is trivially an arithmetic progression. * To determine if the sequence can be rearranged, sort the array and check if consecutive differences are equal. * Consider edge cases such as sequences with all identical elements or extremely large ranges within the sequence. This problem tests your ability to manipulate sequences and check for specific patterns using sorting and basic arithmetic operations.","solution":"from typing import List def can_form_arithmetic_progression(arr: List[int]) -> bool: This function determines if the given list of integers can be rearranged to form an arithmetic progression. if len(arr) <= 1: return True arr.sort() difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != difference: return False return True"},{"question":"**Scenario**: You are building an inventory management system for a large warehouse. The system needs to track items, their quantities, and movements in and out of the inventory. You need to ensure that item quantities do not fall below zero and provide quick access to inventory summaries based on item categories. **Task**: Implement a class `InventoryManager` with the following methods: 1. `add_item(item_id: str, category: str, quantity: int) -> None`: Add a new item to the inventory. If the item already exists, increase its quantity. 2. `remove_item(item_id: str, quantity: int) -> None`: Remove a specified quantity of an item from the inventory. Ensure the quantity does not fall below zero. If attempting to remove more than available, remove only the available quantity. 3. `get_summary_by_category(category: str) -> dict`: Return a summary of items in a specified category, with item IDs as keys and quantities as values. 4. `get_total_quantity(item_id: str) -> int`: Return the total quantity of a specified item in the inventory. * Expected input and output formats: * `add_item(\\"item123\\", \\"electronics\\", 50)` -> None * `remove_item(\\"item123\\", 20)` -> None * `get_summary_by_category(\\"electronics\\")` -> `{ \\"item123\\": 30, ... }` * `get_total_quantity(\\"item123\\")` -> 30 * Constraints: * Ensure item quantities are always non-negative. * Optimize for efficient retrieval of inventory summaries by category. * Assume that item addition and removal operations can be frequent and should handle concurrent updates gracefully. Below is the starting code for the class: ```python class InventoryManager: def __init__(self): # Initialize the inventory data structures. self.inventory = {} self.categories = {} def add_item(self, item_id: str, category: str, quantity: int) -> None: # Implement the logic to add an item or update its quantity. pass def remove_item(self, item_id: str, quantity: int) -> None: # Implement the logic to remove a specified quantity of an item. pass def get_summary_by_category(self, category: str) -> dict: # Implement the logic to get an inventory summary by category. pass def get_total_quantity(self, item_id: str) -> int: # Implement the logic to get the total quantity of a specified item. pass ```","solution":"class InventoryManager: def __init__(self): self.inventory = {} self.categories = {} def add_item(self, item_id: str, category: str, quantity: int) -> None: if item_id in self.inventory: self.inventory[item_id][\'quantity\'] += quantity else: self.inventory[item_id] = {\'category\': category, \'quantity\': quantity} if category not in self.categories: self.categories[category] = {} self.categories[category][item_id] = self.inventory[item_id][\'quantity\'] def remove_item(self, item_id: str, quantity: int) -> None: if item_id in self.inventory: self.inventory[item_id][\'quantity\'] = max(0, self.inventory[item_id][\'quantity\'] - quantity) self.categories[self.inventory[item_id][\'category\']][item_id] = self.inventory[item_id][\'quantity\'] def get_summary_by_category(self, category: str) -> dict: if category in self.categories: return self.categories[category] return {} def get_total_quantity(self, item_id: str) -> int: if item_id in self.inventory: return self.inventory[item_id][\'quantity\'] return 0"},{"question":"# Scenario: You are developing a recommendation system for an online bookstore. Each book in the bookstore has been assigned a popularity score based on user interactions. Your task is to implement functionality that accurately recommends a specific number of the most popular books. # Function Specification: You are to implement a function called `get_top_books` that adheres to the following: Input: - `books` (list of tuples): a list where each tuple contains two elements - the book title (str) and its popularity score (float). The list cannot be empty. - `n` (int): the number of top books to return. Must be a positive integer not greater than the length of the `books` list. Output: - Returns a list of strings representing the titles of the `n` most popular books, sorted by their popularity score in descending order. If two books have the same popularity score, retain their relative order from the input list. # Constraints: - If the `books` list is empty, raise a `ValueError` with the message \\"Books list cannot be empty\\". - If `n` is not a positive integer or greater than the length of the `books` list, raise a `ValueError` with the message \\"Invalid number of books requested\\". # Examples: ```python >>> get_top_books([(\'Book A\', 4.5), (\'Book B\', 2.3), (\'Book C\', 5.6)], 2) [\'Book C\', \'Book A\'] >>> get_top_books([(\'Book Z\', 0.3)], 1) [\'Book Z\'] >>> get_top_books([(\'Book D\', 3.3), (\'Book E\', 3.3), (\'Book F\', 4.7), (\'Book G\', 4.7)], 3) [\'Book F\', \'Book G\', \'Book D\'] >>> get_top_books([], 2) Traceback (most recent call last): ... ValueError: Books list cannot be empty >>> get_top_books([(\'Book H\', 5.2)], 2) Traceback (most recent call last): ... ValueError: Invalid number of books requested ``` # Implementation Details: Use sorting algorithms and list manipulations to implement this in an efficient manner. Ensure your function handles edge cases and properly adheres to the specified constraints.","solution":"def get_top_books(books, n): Returns the titles of the \'n\' most popular books sorted by their popularity score in descending order. books: list of tuples - each tuple contains (book title (str), popularity score (float)) n: int - the number of top books to return (must be a positive integer not greater than the length of books list) Raises ValueError if the books list is empty or if n is invalid. if not books: raise ValueError(\\"Books list cannot be empty\\") if not (0 < n <= len(books)): raise ValueError(\\"Invalid number of books requested\\") # Sort the books list by the popularity score in descending order sorted_books = sorted(books, key=lambda book: book[1], reverse=True) # Extract the top \'n\' book titles top_books = [book[0] for book in sorted_books[:n]] return top_books"},{"question":"# Question: Unique Element Finder In real-world applications, we often need to process data and extract unique elements. For instance, given a list of logged timestamps from different events, we might need to identify unique timestamps for certain analyses. **Task:** You are given a list of integers. Write a function called `find_unique_elements` that takes in this list and returns a new list containing only the elements that appear exactly once in the input list. The function signature should be: ```python def find_unique_elements(collection: List[int]) -> List[int]: pass ``` **Input Format:** - A list of integers, `collection`, which may contain duplicates and can have a length of up to 10^5. **Output Format:** - A new list of integers containing only the elements from the input list that appear exactly once, sorted in ascending order. **Constraints:** - The list length is between 0 and 100,000. - Each integer in the list is between -10^6 and 10^6. **Performance Requirement:** - Aim for a solution that runs in O(n log n) time complexity due to sorting the result, but focus on achieving O(n) for identifying unique elements. **Example:** ```python >>> find_unique_elements([4, 3, 2, 3, 1, 2, 4, 5, 6]) [1, 5, 6] >>> find_unique_elements([1, 2, 3, 4, 5, 6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> find_unique_elements([1, 1, 1, 2, 2, 3]) [3] >>> find_unique_elements([]) [] ``` **Context:** Imagine you have a large dataset of transaction IDs and you want to identify transactions that occurred only once for audit purposes. Efficiently identifying these unique transactions is crucial for maintaining the integrity of the audit process. Implement the `find_unique_elements` function to demonstrate your understanding of data processing and algorithm efficiency. Good luck!","solution":"from typing import List def find_unique_elements(collection: List[int]) -> List[int]: Returns a sorted list of elements that appear exactly once in the input list. # Step 1: Use a dictionary to count occurrences of elements element_count = {} for item in collection: if item in element_count: element_count[item] += 1 else: element_count[item] = 1 # Step 2: Collect elements that appear exactly once unique_elements = [item for item, count in element_count.items() if count == 1] # Step 3: Sort the unique elements in ascending order unique_elements.sort() return unique_elements"},{"question":"New Question **Calculate the Intersection of Two Arrays** # Background You are working on a project that requires identifying common elements between two arrays of integers. Specifically, you need to determine which elements are present in both arrays. # Problem Write a function `intersection` that takes two lists of integers and returns a list containing the elements that are present in both lists, without any duplicates. The result can be in any order. # Requirements: - Both lists may contain any integer values, including negative numbers. - The lists might be of different lengths. - Elements in the output list should appear only once, even if they are duplicated in the input lists. # Function Signature ```python def intersection(nums1: list[int], nums2: list[int]) -> list[int]: pass ``` # Input - `nums1` (list of int): A list of integers, which can be of any length from 0 to 10^6. - `nums2` (list of int): Another list of integers, which can also be of any length from 0 to 10^6. # Output - (list of int): A list containing the unique elements that are present in both `nums1` and `nums2`. # Examples 1. `intersection([1, 2, 2, 1], [2, 2])` should return `[2]`. 2. `intersection([4, 9, 5], [9, 4, 9, 8, 4])` should return `[4, 9]` or `[9, 4]`. 3. `intersection([1, 2, 3], [4, 5, 6])` should return `[]`. 4. `intersection([1, 1, 1, 1], [1])` should return `[1]`. 5. `intersection([3, -4, 1, 7], [-4, 2, 7, 10])` should return `[-4, 7]` or `[7, -4]`. # Constraints - The lengths of the lists `nums1` and `nums2` are between 0 and 10^6. - The elements in the lists are unique within each respective list. You are expected to write an efficient solution with optimal performance, considering the potential size of the input lists.","solution":"def intersection(nums1: list[int], nums2: list[int]) -> list[int]: Returns the unique intersection elements of two lists of integers. # Convert both lists to sets to remove duplicates and allow efficient intersection set1 = set(nums1) set2 = set(nums2) # Find the intersection of two sets result_set = set1 & set2 # Convert the result set to a list return list(result_set)"},{"question":"# Coding Assessment Question Design a function that processes a list of transaction records and identifies any fraudulent transactions based on a specified lower limit. A transaction is considered fraudulent if it exceeds this specified lower limit multiple times by the same user within a short time frame. # Task Your function should meet the following requirements: 1. **Function Name**: `find_fraudulent_transactions` 2. **Input**: * `transactions` (List[List[str]]): A list of transaction records where each record is represented as a list of three elements: `[user_id, timestamp, amount]` with `user_id` as a string, `timestamp` as a string in the format \\"YYYY-MM-DD HH:MM:SS\\", and `amount` as a float. * `lower_limit` (float): A specified lower limit value. * `time_frame` (int): An integer representing the maximum number of minutes within which multiple transactions exceeding the lower limit by the same user are considered fraudulent. 3. **Output**: * List of Lists with each sublist containing two elements: the `user_id` and the time `timestamp` of the transaction considered fraudulent. The list should be sorted first by `user_id` and then by `timestamp`. # Example ```python transactions = [ [\\"user1\\", \\"2023-10-01 12:01:45\\", 150.00], [\\"user1\\", \\"2023-10-01 12:06:30\\", 200.00], [\\"user2\\", \\"2023-10-01 12:02:00\\", 80.00], [\\"user2\\", \\"2023-10-01 12:05:00\\", 90.00], [\\"user1\\", \\"2023-10-01 12:16:00\\", 250.00], [\\"user3\\", \\"2023-10-01 12:20:00\\", 50.00] ] lower_limit = 100.00 time_frame = 10 print(find_fraudulent_transactions(transactions, lower_limit, time_frame)) # Output: [[\'user1\', \'2023-10-01 12:06:30\'], [\'user1\', \'2023-10-01 12:16:00\']] ``` # Constraints * The number of transactions will not exceed 10,000. * The `lower_limit` and `amount` are positive floats. * The `time_frame` is a positive integer. * The `timestamp` format will consistently follow the \\"YYYY-MM-DD HH:MM:SS\\" pattern. # Notes * Ensure the function correctly parses timestamps and performs accurate time comparisons. * Prioritize efficient computation to handle large lists of transactions within the given constraints. * Consider edge cases such as transactions occurring exactly at the boundary of the `time_frame`. Good luck!","solution":"from datetime import datetime, timedelta from collections import defaultdict def find_fraudulent_transactions(transactions, lower_limit, time_frame): Processes a list of transaction records and identifies any fraudulent transactions. Args: transactions (List[List[str]]): A list of transaction records. lower_limit (float): A specified lower limit value. time_frame (int): Maximum number of minutes for evaluating fraud. Returns: List[List[str]]: A list of fraudulent transactions. # Helper function to parse timestamp strings to datetime objects def parse_timestamp(timestamp): return datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") # Dictionary to hold transactions by user_id user_transactions = defaultdict(list) # Populate the user_transactions dictionary for user_id, timestamp, amount in transactions: if amount > lower_limit: user_transactions[user_id].append((parse_timestamp(timestamp), amount)) # List to hold the identified fraudulent transactions fraudulent_transactions = [] # Check each user\'s transactions for fraudulent activity for user_id, trans in user_transactions.items(): trans.sort() # Sort transactions by timestamp for the current user for i in range(len(trans)): # Iterate over transactions to find ones that exceed the lower limit in the given time frame count = 1 start_time = trans[i][0] for j in range(i + 1, len(trans)): if (trans[j][0] - start_time) <= timedelta(minutes=time_frame): count += 1 if count > 1: fraudulent_transactions.append([user_id, trans[j][0].strftime(\\"%Y-%m-%d %H:%M:%S\\")]) else: break # Sort fraudulent_transactions by user_id and timestamp fraudulent_transactions.sort(key=lambda x: (x[0], x[1])) return fraudulent_transactions"},{"question":"Problem Statement You are given a list of tuples representing a series of directed edges in a graph. Each tuple contains two integers (u, v), indicating a directed edge from vertex u to vertex v. Your task is to write a function to determine if the graph contains any cycles. # Input - A list of tuples `edges`, where each tuple (u, v) represents a directed edge from node u to node v. # Output - A boolean value: `True` if the graph contains at least one cycle, and `False` otherwise. # Constraints - 1 ≤ number of edges ≤ 1000 - 1 ≤ u, v ≤ 1000 - The graph may have multiple components. - The graph does not necessarily contain all vertices from 1 to 1000. # Example Given the edges: - (1, 2) - (2, 3) - (3, 1) - (4, 5) The function `has_cycle([(1, 2), (2, 3), (3, 1), (4, 5)])` should return `True`, since there is a cycle involving vertices 1, 2, and 3. # Guidance To detect cycles in the graph, you can use Depth-First Search (DFS). Implement the following helper function: 1. `dfs(vertex: int, adjacency_list: dict, visited: set, rec_stack: set) -> bool`: Performs DFS to detect a cycle starting from `vertex`. # Sample Function Definition ```python def has_cycle(edges: list[tuple[int, int]]) -> bool: # Your code here ``` # Note Ensure your solution correctly handles graphs with disconnected components and various edge cases involving vertex connections.","solution":"def has_cycle(edges): from collections import defaultdict def dfs(vertex, adjacency_list, visited, rec_stack): visited.add(vertex) rec_stack.add(vertex) for neighbor in adjacency_list[vertex]: if neighbor not in visited: if dfs(neighbor, adjacency_list, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False adjacency_list = defaultdict(list) vertices = set() for u, v in edges: adjacency_list[u].append(v) vertices.add(u) vertices.add(v) visited = set() rec_stack = set() for vertex in vertices: if vertex not in visited: if dfs(vertex, adjacency_list, visited, rec_stack): return True return False"},{"question":"# File System Path Simplification Given a Unix-style file system path, you need to simplify the path to its canonical form. In a Unix-style file system, a period (`.`) refers to the current directory, and a double period (`..`) refers to the directory up one level. Additionally, any multiple consecutive slashes (`/`) are treated as a single slash. The canonical path must always begin with a single slash `/`, and there must be only a single slash `/` between directory names. The canonical path should not end with a trailing slash `/`, unless it is the root `/`. Task Write a Python function `simplify_path(path: str) -> str` that simplifies the given Unix-style file system path. # Input - A string `path` representing the original Unix-style file system path which might include periods (`.`) and double periods (`..`). # Output - A string representing the simplified, canonical path. # Requirements and Constraints 1. **Input Length**: The input path length will not exceed 3000 characters. 2. **Valid Characters**: The input path will consist of English letters, digits, periods (`.`), and slashes (`/`). 3. **Edge Cases**: Handle cases with multiple consecutive slashes, as well as paths with more periods and double periods than leading directories. Example: Input: ```python path = \\"/home//foo/\\" ``` Output: ```python \\"/home/foo\\" ``` Input: ```python path = \\"/a/./b/../../c/\\" ``` Output: ```python \\"/c\\" ``` Input: ```python path = \\"/../\\" ``` Output: ```python \\"/\\" ``` Input: ```python path = \\"/home//foo/./bar/../\\" ``` Output: ```python \\"/home/foo\\" ``` Implement the function `simplify_path` to meet the described requirements and considerations.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style file system path. Args: path (str): A string representing the original Unix-style file system path. Returns: str: The simplified, canonical path. # Split the path by \\"/\\" parts = path.split(\\"/\\") stack = [] # Process each part of the path for part in parts: if part == \\"..\\": if stack: stack.pop() elif part == \\"\\" or part == \\".\\": continue else: stack.append(part) # Join the stack to form the simplified path simplified_path = \\"/\\" + \\"/\\".join(stack) return simplified_path"},{"question":"# Question: You are given a list of integers where each integer represents the amount of rainfall recorded in a particular day. Implement a function `find_local_peaks(rainfall_data: List[int]) -> List[int]` that identifies the indices of local peaks in the list. A local peak is an element that is strictly greater than both its neighboring elements. The first and last elements of the list are not considered as peaks. Input: * `rainfall_data`: a list of integers representing the rainfall measurements. Output: * A list of integers representing the indices of local peaks in the rainfall data. Constraints: * `1 <= len(rainfall_data) <= 1000` (maximum number of days) * `0 <= rainfall_data[i] <= 10**6` (rainfall measurement for day `i`) Example: ```python rainfall_data = [10, 12, 5, 6, 8, 7, 5, 3, 11, 8] assert find_local_peaks(rainfall_data) == [1, 4, 8] rainfall_data = [5, 5, 5, 5, 5] assert find_local_peaks(rainfall_data) == [] ``` Notes: * The objective is to find elements in the list that have strictly greater values than both the elements immediately before and after them. * Consider edge cases where there are no peaks or multiple consecutive peaks. * Ensure the solution efficiently analyzes the list without unnecessary computations.","solution":"from typing import List def find_local_peaks(rainfall_data: List[int]) -> List[int]: This function returns a list of indices where the rainfall amount represents a local peak. A local peak is defined as an element that is strictly greater than its neighbors, not considering the first and last elements. peaks = [] for i in range(1, len(rainfall_data) - 1): if rainfall_data[i] > rainfall_data[i - 1] and rainfall_data[i] > rainfall_data[i + 1]: peaks.append(i) return peaks"},{"question":"# Problem Statement **Reverse Level Order Traversal** Given a binary tree, undertake the reverse level order traversal of its nodes\' values. Reverse level order traversal is defined as visiting the nodes on the bottom level first, then the next level up, and so on, finishing at the root. Each level should be visited from left to right. # Specific Requirements 1. **Function Signature**: ```python def reverse_level_order_traversal(root: TreeNode) -> list[int]: ``` 2. **Input**: - `root`: Reference to the root node of a binary tree. 3. **Output**: - A list of integers representing the values of nodes in reverse level order traversal. 4. **Constraints**: - The number of nodes in the binary tree will not exceed 1000. - The values of the nodes will be integers within the range -1000 to 1000. - Handle edge cases such as an empty tree (root being `None`). # Example ```python # Example 1: # Input: # 1 # / # 2 3 # / / # 4 5 6 7 # Output: [4, 5, 6, 7, 2, 3, 1] # Example 2: # Input: # 1 # / # 2 3 # # 4 # Output: [4, 2, 3, 1] # Example 3: # Input: # 1 # Output: [1] # Example 4: # Input: # None # Output: [] ``` Implement the function `reverse_level_order_traversal` to return the correct output given the input examples above. # Notes 1. Utilize a queue to manage the order of processing nodes level by level. 2. Consider using a stack to reverse the level order traversal. 3. Ensure your implementation accounts for edge cases such as: - An empty tree. - Trees with only one node. - Trees with varying structures and depths.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def reverse_level_order_traversal(root: TreeNode) -> list[int]: if not root: return [] queue = deque([root]) stack = deque() while queue: current_node = queue.popleft() stack.appendleft(current_node.val) if current_node.right: queue.append(current_node.right) if current_node.left: queue.append(current_node.left) return list(stack)"},{"question":"# Question: Longest Subarray with Unique Elements In this task, you will write a function to identify the length of the longest subarray within a given array. The subarray must consist only of unique elements, i.e., no duplicate elements are allowed within the subarray. Function Signature ```python def longest_unique_subarray(array: list[int]) -> int: ``` # Input - **array** (list of `int`): An input list of integers for which you need to find the length of the longest subarray with all unique elements. # Output - An integer representing the length of the longest subarray with unique elements within the input list. # Constraints - The length of `array` will be between 0 and 10^5. - All elements in the `array` are integers. # Performance - Aim for clean, readable, and efficient code. - Consider edge cases such as empty arrays or arrays with all identical elements. # Example ```python # Example 1 array = [1, 2, 3, 1, 2, 3] print(longest_unique_subarray(array)) # Output: 3 # Explanation: The longest subarray with unique elements is [1, 2, 3] # Example 2 array = [1, 1, 1, 1] print(longest_unique_subarray(array)) # Output: 1 # Explanation: The longest subarray with unique elements is [1] # Example 3 array = [1, 2, 3, 4, 5] print(longest_unique_subarray(array)) # Output: 5 # Explanation: The entire array is comprised of unique elements ``` # Additional Notes - The function should efficiently handle large input sizes, aiming for a linear time complexity algorithm such as using a sliding window technique. - Make sure to thoroughly test your function on various edge cases to ensure accuracy.","solution":"def longest_unique_subarray(array: list[int]) -> int: Returns the length of the longest subarray with all unique elements. n = len(array) if n == 0: return 0 max_length, start = 0, 0 seen = {} for end, value in enumerate(array): if value in seen: start = max(start, seen[value] + 1) seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Prefix Sum Array Application You have been tasked with optimizing the operations on a dataset that frequently requires prefix sums and range updates to the elements. The dataset is stored in an array, and your system must efficiently handle prefix sum calculations and element updates. Implement a class `PrefixSumArray` that supports: 1. **Building the Prefix Sum Array** from an array of integers. 2. **Updating an element** at a specific index. 3. **Querying the prefix sum** up to a specific index. 4. **Querying the sum** of elements in a specific range. Input and Output Formats * **Initialization**: - Input: `arr`, a list of integers. - Example: `arr = [3, 2, -1, 6, 5, 4]` * **Updates**: - Method: `update(index, value)` - Input: `index`, an integer; `value`, an integer. Updates the element at `index` with `value`. - Constraint: `0 <= index < len(arr)` * **Prefix Sum Queries**: - Method: `query_prefix_sum(index)` - Input: `index`, an integer representing the end of the range [0, index]. - Output: Returns the sum of elements from the start of the array to the specified index. - Constraint: `0 <= index < len(arr)` - Example: Given `arr = [3, 2, -1, 6, 5, 4]`, `query_prefix_sum(3)` should return `10`. * **Range Sum Queries**: - Method: `query_range_sum(left, right)` - Input: `left` and `right`, integers representing the range [left, right]. - Output: Returns the sum of elements in the range [left, right]. - Constraint: `0 <= left <= right < len(arr)` - Example: Given `arr = [3, 2, -1, 6, 5, 4]`, `query_range_sum(1, 3)` should return `7`. Implementation Requirements 1. Utilize prefix sum array concept for efficient sum queries. 2. Maintain and update the prefix sums after each update operation to ensure quick queries. 3. Ensure each prefix sum query and update operation runs in O(1) time, and range sum query in O(1) time after preprocessing. 4. Handle invalid index inputs gracefully (e.g., with appropriate error messages). ```python class PrefixSumArray: def __init__(self, arr): # Construct the prefix sum array # Implement the constructor def update(self, index, value): # Update an element at index with new value and adjust prefix sums # Implement the update method def query_prefix_sum(self, index): # Return the sum from start to the given index # Implement the prefix sum query method def query_range_sum(self, left, right): # Return the sum in the range [left, right] # Implement the range sum query method ``` **Note**: Implement the `PrefixSumArray` class methods without using built-in library functions for prefix sums.","solution":"class PrefixSumArray: def __init__(self, arr): self.arr = arr[:] self.prefix_sum = self._build_prefix_sum(arr) def _build_prefix_sum(self, arr): prefix_sum = [0] * len(arr) if arr: prefix_sum[0] = arr[0] for i in range(1, len(arr)): prefix_sum[i] = prefix_sum[i-1] + arr[i] return prefix_sum def update(self, index, value): if index < 0 or index >= len(self.arr): raise IndexError(\\"Index out of bounds\\") # Calculate the difference diff = value - self.arr[index] self.arr[index] = value # Update the prefix sums accordingly for i in range(index, len(self.prefix_sum)): self.prefix_sum[i] += diff def query_prefix_sum(self, index): if index < 0 or index >= len(self.arr): raise IndexError(\\"Index out of bounds\\") return self.prefix_sum[index] def query_range_sum(self, left, right): if left < 0 or right >= len(self.arr) or left > right: raise IndexError(\\"Invalid range\\") if left == 0: return self.prefix_sum[right] return self.prefix_sum[right] - self.prefix_sum[left-1]"},{"question":"# ISBN Validator You are tasked with creating a class to validate International Standard Book Numbers (ISBNs). An ISBN is a ten-digit code used to identify books. The last digit is a checksum, which can be computed as follows: 1. Multiply the first digit by 10, the second by 9, the third by 8, and so on down to the ninth digit multiplied by 2. 2. Sum these products. 3. The checksum is the value required to make this sum a multiple of 11. For example, for an ISBN \\"0471958697\\": - (0 * 10 + 4 * 9 + 7 * 8 + 1 * 7 + 9 * 6 + 5 * 5 + 8 * 4 + 6 * 3 + 9 * 2) = 130 - The checksum value is 7, as adding 7 to 130 makes it 137, a multiple of 11. A valid ISBN has a sum that is a multiple of 11. # Requirements: 1. **Input and Output Formats**: * ISBN must be a 10-character long string. * The checksum digit can be a numeric digit (0-9) or \'X\', which represents the value 10. * Implement the `is_valid` method, which returns a Boolean indicating if the provided ISBN is valid. 2. **Constraints**: * An ISBN is always a 10-character string. * The checksum can be any digit from 0 to 9 or \'X\'. * Valid ISBNs are guaranteed to have correctly formatted characters. 3. **Performance**: * Efficient execution is expected due to the fixed length of the input. # Example ```python isbn = ISBNValidator(\\"0471958697\\") print(isbn.is_valid()) # Output: True isbn = ISBNValidator(\\"123456789X\\") print(isbn.is_valid()) # Output: True isbn = ISBNValidator(\\"1234567890\\") print(isbn.is_valid()) # Output: False ``` # Function Signature ```python class ISBNValidator: def __init__(self, isbn: str) -> None: pass def is_valid(self) -> bool: pass ```","solution":"class ISBNValidator: def __init__(self, isbn: str) -> None: self.isbn = isbn def is_valid(self) -> bool: if len(self.isbn) != 10: return False total = 0 for i in range(9): if not self.isbn[i].isdigit(): return False total += int(self.isbn[i]) * (10 - i) checksum_char = self.isbn[9] if checksum_char == \'X\': checksum = 10 elif checksum_char.isdigit(): checksum = int(checksum_char) else: return False total += checksum return total % 11 == 0"},{"question":"# Scenario You are a software engineer developing features for an event planning application. As part of this project, you need to implement functionality to track the dietary restrictions of attendees. # Problem Statement Create a function `count_dietary_restrictions(attendees: List[str], diets: List[str]) -> Dict[str, int]` that takes a list of attendee names and their dietary restrictions and returns a dictionary where the keys are the dietary restriction categories and the values are the counts of how many attendees fall into those categories. # Function Signature ```python from typing import List, Dict def count_dietary_restrictions(attendees: List[str], diets: List[str]) -> Dict[str, int]: pass ``` # Input * `attendees`: A list of strings where each string represents the name of an attendee. * `diets`: A list of strings where each string corresponds to an attendee in the `attendees` list and indicates that attendee\'s dietary restriction. Possible values in this list are `\'vegan\'`, `\'vegetarian\'`, `\'gluten-free\'`, or `\'none\'`. # Output * A dictionary with the dietary restriction categories `\'vegan\'`, `\'vegetarian\'`, `\'gluten-free\'`, and `\'none\'` as keys, and integers representing the counts of attendees in each category as values. # Constraints * The lengths of `attendees` and `diets` are equal. * Every dietary restriction in `diets` is one of the predefined strings: `\'vegan\'`, `\'vegetarian\'`, `\'gluten-free\'`, or `\'none\'`. # Examples ```python >>> count_dietary_restrictions( [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], [\\"vegetarian\\", \\"vegan\\", \\"gluten-free\\", \\"none\\"] ) {\'vegan\': 1, \'vegetarian\': 1, \'gluten-free\': 1, \'none\': 1} >>> count_dietary_restrictions( [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"], [\\"vegan\\", \\"vegan\\", \\"gluten-free\\", \\"vegetarian\\", \\"none\\"] ) {\'vegan\': 2, \'vegetarian\': 1, \'gluten-free\': 1, \'none\': 1} >>> count_dietary_restrictions( [\\"Alice\\"], [\\"none\\"] ) {\'vegan\': 0, \'vegetarian\': 0, \'gluten-free\': 0, \'none\': 1} ``` # Notes 1. Assume that `attendees` and `diets` will always be provided in pairs such that each attendee has a corresponding dietary restriction. 2. Ensure the output dictionary always contains all four dietary restriction categories, even if some counts are zero.","solution":"from typing import List, Dict def count_dietary_restrictions(attendees: List[str], diets: List[str]) -> Dict[str, int]: # Initialize the dictionary with all dietary restriction categories set to zero counts dietary_counts = { \'vegan\': 0, \'vegetarian\': 0, \'gluten-free\': 0, \'none\': 0 } # Iterate through the list of dietary restrictions and count each category for diet in diets: if diet in dietary_counts: dietary_counts[diet] += 1 return dietary_counts"},{"question":"# Employee Salaries Data Analysis Background Scenario You are given a list of employee records containing their IDs, names, and respective salaries. Your task is to implement a class `EmployeeDB` that will store these records and provide several methods to perform operations like adding new records, updating existing ones, fetching records with the highest and lowest salaries, and getting the average salary of all employees. Class Description Implement a class `EmployeeDB` with the following methods: 1. `add_employee(emp_id: int, name: str, salary: float) -> None`: Adds or updates an employee record. 2. `remove_employee(emp_id: int) -> None`: Removes an employee record by their ID. 3. `get_employee(emp_id: int) -> Tuple[int, str, float]`: Fetches the employee record by their ID. 4. `get_highest_salary_employee() -> Tuple[int, str, float]`: Fetches the employee record with the highest salary. 5. `get_lowest_salary_employee() -> Tuple[int, str, float]`: Fetches the employee record with the lowest salary. 6. `get_average_salary() -> float`: Computes and returns the average salary of all employees. Expected Input and Output: 1. `add_employee(emp_id: int, name: str, salary: float) -> None` * **Input**: An integer `emp_id`, a string `name`, and a float `salary`. * **Output**: None. 2. `remove_employee(emp_id: int) -> None` * **Input**: An integer `emp_id`. * **Output**: None. 3. `get_employee(emp_id: int) -> Tuple[int, str, float]` * **Input**: An integer `emp_id`. * **Output**: A tuple containing the employee ID, name, and salary; or an empty tuple if the employee does not exist. 4. `get_highest_salary_employee() -> Tuple[int, str, float]` * **Output**: A tuple containing the employee ID, name, and salary of the employee with the highest salary. 5. `get_lowest_salary_employee() -> Tuple[int, str, float]` * **Output**: A tuple containing the employee ID, name, and salary of the employee with the lowest salary. 6. `get_average_salary() -> float` * **Output**: A float representing the average salary of all employees. Constraints: 1. Employee IDs are unique integers. 2. Employee names are strings of length `n`, where `1 <= n <= 50`. 3. Salaries are non-negative floats less than `10^6`. 4. Perform the methods with an average time complexity aiming to be O(1) for retrieval operations. Specification: ```python from typing import Tuple, Optional class EmployeeDB: def __init__(self): Initializes the EmployeeDB with an empty dictionary to store employee records. self.employees = {} def add_employee(self, emp_id: int, name: str, salary: float) -> None: Adds or updates an employee record in the database. Parameters: emp_id (int): The employee ID. name (str): The employee\'s name. salary (float): The employee\'s salary. self.employees[emp_id] = (name, salary) def remove_employee(self, emp_id: int) -> None: Removes an employee record based on the employee ID. Parameters: emp_id (int): The employee ID. if emp_id in self.employees: del self.employees[emp_id] def get_employee(self, emp_id: int) -> Tuple[int, str, float]: Retrieves an employee record based on the employee ID. Parameters: emp_id (int): The employee ID. Returns: Tuple[int, str, float]: The employee record including ID, name, and salary. Returns an empty tuple if the employee does not exist. if emp_id in self.employees: name, salary = self.employees[emp_id] return (emp_id, name, salary) return () def get_highest_salary_employee(self) -> Optional[Tuple[int, str, float]]: Retrieves the employee record with the highest salary. Returns: Tuple[int, str, float]: The employee record with the highest salary, or None if no employees exist. if not self.employees: return None max_emp_id = max(self.employees, key=lambda emp_id: self.employees[emp_id][1]) name, salary = self.employees[max_emp_id] return (max_emp_id, name, salary) def get_lowest_salary_employee(self) -> Optional[Tuple[int, str, float]]: Retrieves the employee record with the lowest salary. Returns: Tuple[int, str, float]: The employee record with the lowest salary, or None if no employees exist. if not self.employees: return None min_emp_id = min(self.employees, key=lambda emp_id: self.employees[emp_id][1]) name, salary = self.employees[min_emp_id] return (min_emp_id, name, salary) def get_average_salary(self) -> float: Computes and returns the average salary of all employees. Returns: float: The average salary of all employees. if not self.employees: return 0.0 total_salary = sum(salary for name, salary in self.employees.values()) return total_salary / len(self.employees) # Example Usage db = EmployeeDB() db.add_employee(1, \\"Alice\\", 75000) db.add_employee(2, \\"Bob\\", 50000) db.add_employee(3, \\"Charlie\\", 120000) print(db.get_highest_salary_employee()) # Output: (3, \\"Charlie\\", 120000.0) print(db.get_lowest_salary_employee()) # Output: (2, \\"Bob\\", 50000.0) print(db.get_average_salary()) # Output: 81666.666 ```","solution":"from typing import Tuple, Optional class EmployeeDB: def __init__(self): Initializes the EmployeeDB with an empty dictionary to store employee records. self.employees = {} def add_employee(self, emp_id: int, name: str, salary: float) -> None: Adds or updates an employee record in the database. Parameters: emp_id (int): The employee ID. name (str): The employee\'s name. salary (float): The employee\'s salary. self.employees[emp_id] = (name, salary) def remove_employee(self, emp_id: int) -> None: Removes an employee record based on the employee ID. Parameters: emp_id (int): The employee ID. if emp_id in self.employees: del self.employees[emp_id] def get_employee(self, emp_id: int) -> Tuple[int, str, float]: Retrieves an employee record based on the employee ID. Parameters: emp_id (int): The employee ID. Returns: Tuple[int, str, float]: The employee record including ID, name, and salary. Returns an empty tuple if the employee does not exist. if emp_id in self.employees: name, salary = self.employees[emp_id] return (emp_id, name, salary) return () def get_highest_salary_employee(self) -> Optional[Tuple[int, str, float]]: Retrieves the employee record with the highest salary. Returns: Tuple[int, str, float]: The employee record with the highest salary, or None if no employees exist. if not self.employees: return None max_emp_id = max(self.employees, key=lambda emp_id: self.employees[emp_id][1]) name, salary = self.employees[max_emp_id] return (max_emp_id, name, salary) def get_lowest_salary_employee(self) -> Optional[Tuple[int, str, float]]: Retrieves the employee record with the lowest salary. Returns: Tuple[int, str, float]: The employee record with the lowest salary, or None if no employees exist. if not self.employees: return None min_emp_id = min(self.employees, key=lambda emp_id: self.employees[emp_id][1]) name, salary = self.employees[min_emp_id] return (min_emp_id, name, salary) def get_average_salary(self) -> float: Computes and returns the average salary of all employees. Returns: float: The average salary of all employees. if not self.employees: return 0.0 total_salary = sum(salary for name, salary in self.employees.values()) return total_salary / len(self.employees)"},{"question":"Implement a Function to Calculate the Central Tendency Measures of a List You are tasked with implementing a function that calculates the mean, median, and mode of a given list of integers. Your solution should handle the possibility of multi-modal datasets appropriately. Function Signature ```python def central_tendency_measures(data: list) -> tuple: ``` Input * `data`: A list of integers. Output * A tuple containing three elements: * The mean of the list (a float). * The median of the list (an integer or a float). * A list of the mode(s) (one or more integers). Constraints * The list can have up to 10^4 elements. * The integers in the list can range from -10^6 to 10^6. * The list can be empty, in which case return `(None, None, [])`. Requirements 1. Calculate the mean as the average of the elements. 2. Calculate the median as the middle element if the list length is odd, or the average of the two middle elements if it is even. 3. Calculate the mode(s) as the most frequent element(s) in the list. If there are multiple modes, all of them should be returned in the output list in ascending order. If all elements are unique, the entire list itself is the mode. 4. Ensure the solution handles empty lists gracefully. # Example ```python test_data_1 = [1, 2, 2, 3, 4] test_data_2 = [1, 2, 3] test_data_3 = [1, 1, 2, 2, 3, 3, 4, 4] test_data_4 = [] assert central_tendency_measures(test_data_1) == (2.4, 2, [2]) assert central_tendency_measures(test_data_2) == (2.0, 2, [1, 2, 3]) assert central_tendency_measures(test_data_3) == (2.5, 2.5, [1, 2, 3, 4]) assert central_tendency_measures(test_data_4) == (None, None, []) ``` # Explanation: - For `test_data_1`, the mean is `(1+2+2+3+4)/5 = 2.4`, the median is `2`, and the mode is `[2]`. - For `test_data_2`, the mean is `(1+2+3)/3 = 2.0`, the median is `2`, and there is no unique mode, so we return all elements `[1, 2, 3]`. - For `test_data_3`, the mean is `(1+1+2+2+3+3+4+4)/8 = 2.5`, the median is `(2+3)/2 = 2.5`, and there is no unique mode, so we return all elements `[1, 2, 3, 4]`. - For `test_data_4` (empty list), all measures return as specified.","solution":"import statistics from collections import Counter def central_tendency_measures(data: list) -> tuple: if not data: # Handling empty list return (None, None, []) mean = sum(data) / len(data) data_sorted = sorted(data) n = len(data_sorted) if n % 2 == 1: median = data_sorted[n // 2] else: median = (data_sorted[(n // 2) - 1] + data_sorted[n // 2]) / 2 frequency = Counter(data) max_freq = max(frequency.values()) mode = sorted([num for num, freq in frequency.items() if freq == max_freq]) return (mean, median, mode)"},{"question":"Task Write a Python function that extracts weather data from a provided API for a specified city and returns the temperature and weather conditions. Input * The base URL for the weather API. * A dictionary of parameters that includes the city name, and API key. Output * A tuple containing: * A string with the temperature in Celsius. * A string describing the weather conditions. Constraints * The function should handle network and API errors gracefully and retry a specified number of times before failing. * Maximum allowed retries: 3. * Implement proper exception handling for various potential failures (HTTP errors, parsing errors, etc.) Performance * Aim to minimize network calls when possible, with efficient JSON parsing and error handling. Function Signature ```python def fetch_weather_data(base_url: str, params: dict) -> tuple: ``` Example ```python params = { \\"q\\": \\"Berlin\\", \\"appid\\": \\"your_api_key\\", \\"units\\": \\"metric\\" } result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", params) print(result) # Expected output: (\\"22\\", \\"Clear sky\\") (or similar weather data for Berlin) ``` Hint Use `try-except` blocks to handle exceptions, and consider the usage of a retry strategy with a `for` loop or a helper function. Make sure to convert the temperature from JSON to a string representing degrees Celsius.","solution":"import requests def fetch_weather_data(base_url: str, params: dict) -> tuple: Fetches weather data from a provided API for a specified city and returns the temperature in Celsius and weather conditions. max_retries = 3 for attempt in range(max_retries): try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() # Parsing and processing weather data temperature = str(data[\'main\'][\'temp\']) weather_conditions = data[\'weather\'][0][\'description\'].capitalize() return (temperature, weather_conditions) except requests.exceptions.RequestException as e: if attempt == max_retries - 1: return (\\"Error\\", \\"Failed to fetch data after multiple attempts\\") except (KeyError, ValueError, TypeError) as e: return (\\"Error\\", \\"Error in parsing weather data\\") # Example usage: # params = { # \\"q\\": \\"Berlin\\", # \\"appid\\": \\"your_api_key\\", # \\"units\\": \\"metric\\" # } # result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", params) # print(result)"},{"question":"# Problem Statement You are given a list of unique integers `arr` and a target integer `target`. Write a function `find_pair` that finds and returns a tuple (a, b) such that `a` and `b` are two distinct elements from the list and their sum is equal to `target`. If no such pair exists, return an empty tuple. # Function Signature ```python def find_pair(arr: List[int], target: int) -> Tuple[int, int]: ``` # Input - `arr`: A list of unique integers (2 <= len(arr) <= 10^4). - `target`: An integer. # Output - A tuple of two integers from the list such that their sum equals `target`, or an empty tuple if no such pair exists. # Constraints - There will be at most one valid pair in the input list. # Example ```python arr = [2, 7, 11, 15] target = 9 print(find_pair(arr, target)) # Output should be (2, 7) ``` # Notes - Be mindful of optimizing the solution for efficiency. - Consider edge cases such as the possibility of no valid pair being found. # Additional Context This problem assesses your ability to work with arrays, hashmaps/dictionaries for efficient lookups, and basic algorithmic problem-solving techniques. Focus on how to minimize the time complexity while ensuring the correctness of the solution.","solution":"from typing import List, Tuple def find_pair(arr: List[int], target: int) -> Tuple[int, int]: Finds and returns a tuple (a, b) such that a and b are two distinct elements from the list and their sum is equal to target. If no such pair exists, returns an empty tuple. seen = {} for num in arr: complement = target - num if complement in seen: return (complement, num) seen[num] = True return ()"},{"question":"# Challenge: Analyzing Time Complexity of Custom Sorting Algorithm **Background**: A new sorting algorithm called \\"Odd-Even Merge Sort\\" has been developed, which sorts an array by repeatedly merging two sorted subsequences, one containing elements at odd indices and the other at even indices. # Task Write a function `odd_even_merge_sort(arr: list) -> list` that implements the \\"Odd-Even Merge Sort\\". Additionally, analyze and provide the time complexity of your implementation. Your solution should handle various input sizes efficiently. # Function Signature ```python def odd_even_merge_sort(arr: list) -> list: pass ``` # Input - `arr`: A list of integers that needs to be sorted. The list can be of any size. # Output - Returns a sorted list of integers in non-decreasing order. # Constraints - The length of the array `n` will be such that `1 <= n <= 10^6`. - All elements of the array are integers within the range `-10^9 <= arr[i] <= 10^9`. # Performance Requirements - Ensure your sorting algorithm is efficient for large arrays. - Aim to achieve an average case time complexity of (O(n log n)). - Optimize your implementation for both time and space. # Example 1. **Input**: `arr = [3, 1, 4, 1, 5, 9, 2, 6, 5]` **Output**: `[1, 1, 2, 3, 4, 5, 5, 6, 9]` 2. **Input**: `arr = [10, -10, 0, 5, -5]` **Output**: `[-10, -5, 0, 5, 10]` 3. **Input**: `arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` **Output**: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` # Considerations - Handle edge cases where the array has only one or two elements. - Ensure that the function can handle arrays with repeated elements gracefully. - Comment on any optimizations performed and discuss the theoretical performance of your implementation. **Note**: Standard libraries can be referenced for basic operations, but the primary logic needs to be implemented manually to match the learning objective. # Implementation Tip Consider breaking down the problem into smaller functions, such as: - `merge_odd_even_subarrays(arr)`: Merges two sorted subsequences from odd and even indices. - `sort_and_merge(arr)`: Recursively sorts and merges the odd and even subsequences. Implement the required sorting mechanism in a detailed, step-by-step manner with appropriate comments and documentation.","solution":"def merge(a, b): Merges two sorted lists into one sorted list. result = [] i = j = 0 while i < len(a) and j < len(b): if a[i] < b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 result.extend(a[i:]) result.extend(b[j:]) return result def odd_even_merge(arr, start, end): Recursively merges subarrays defined by odd and even indexed elements. if end - start <= 1: return arr[start:end] mid = (end - start) // 2 even_merge = odd_even_merge(arr, start, start + mid + (end - start) % 2) odd_merge = odd_even_merge(arr, start + mid + (end - start) % 2, end) return merge(even_merge, odd_merge) def odd_even_merge_sort(arr): Odd-Even Merge Sort implementation. if not arr: return [] return odd_even_merge(arr, 0, len(arr))"},{"question":"# Task: Write a JSON API Client for Fetching Data Objective Write a Python class to interact with a mock JSON API. Your client should be able to fetch data, parse the JSON responses, and provide specific information upon request based on certain criteria. Requirements 1. **Function Definition**: Define a class `JSONApiClient` with the following methods: * `__init__(self, base_url: str)`: Initialize the client with a base URL for the API. * `fetch_data(self, endpoint: str) -> dict`: Fetch data from a given endpoint and return the parsed JSON response. * `get_item_by_id(self, endpoint: str, item_id: int) -> dict`: Fetch data from a given endpoint and return the item with the specified ID. * `get_items_by_category(self, endpoint: str, category: str) -> List[dict]`: Fetch data from a given endpoint and return a list of items that belong to a specified category. 2. **Input Format**: * `base_url`: A string representing the base URL of the JSON API. * `endpoint`: A string representing the specific API endpoint to fetch data from. * `item_id`: An integer representing the ID of a specific item. * `category`: A string representing the category name to filter items. 3. **Output Format**: * `fetch_data` method: A dictionary representing the parsed JSON response from the API. * `get_item_by_id` method: A dictionary representing the item with the specified ID. * `get_items_by_category` method: A list of dictionaries, each representing an item belonging to the specified category. 4. **Constraints**: * Assume that the API is well-formed and always returns valid JSON responses. * Implement error handling for network requests and JSON parsing. * The client should handle cases where an item with the specified ID or category does not exist. Performance Requirements The client should effectively handle network requests and JSON parsing without significant delays. Ensure that the methods are efficient and correctly handle large datasets if necessary. Scenario You are developing a data retrieval system that needs to interact with various online services to collect and organize information. An important part of this system is the ability to fetch and filter data from a JSON API based on specific criteria. Implement and test this client to ensure it works correctly and efficiently with the given API structure. ```python import requests class JSONApiClient: def __init__(self, base_url: str): self.base_url = base_url def fetch_data(self, endpoint: str) -> dict: url = f\\"{self.base_url}/{endpoint}\\" response = requests.get(url) response.raise_for_status() return response.json() def get_item_by_id(self, endpoint: str, item_id: int) -> dict: data = self.fetch_data(endpoint) for item in data: if item[\'id\'] == item_id: return item raise ValueError(f\\"Item with ID {item_id} not found\\") def get_items_by_category(self, endpoint: str, category: str) -> List[dict]: data = self.fetch_data(endpoint) return [item for item in data if item.get(\'category\') == category] # Example usage if __name__ == \\"__main__\\": client = JSONApiClient(\\"https://api.example.com\\") products = client.fetch_data(\'products\') product = client.get_item_by_id(\'products\', 123) category_items = client.get_items_by_category(\'products\', \'electronics\') ``` Ensure to test this class with a real or mock API to verify its functionality and performance.","solution":"import requests from typing import List class JSONApiClient: def __init__(self, base_url: str): self.base_url = base_url def fetch_data(self, endpoint: str) -> dict: url = f\\"{self.base_url}/{endpoint}\\" response = requests.get(url) response.raise_for_status() return response.json() def get_item_by_id(self, endpoint: str, item_id: int) -> dict: data = self.fetch_data(endpoint) for item in data: if item[\'id\'] == item_id: return item raise ValueError(f\\"Item with ID {item_id} not found\\") def get_items_by_category(self, endpoint: str, category: str) -> List[dict]: data = self.fetch_data(endpoint) return [item for item in data if item.get(\'category\') == category]"},{"question":"Image Padding and Convolution # Context: You are provided with a basic implementation of image padding and convolution for grayscale images. Your task is to extend and optimize this implementation to handle colored images and include different padding types (zero-padding, reflect-padding, and replicate-padding). # Task: You need to extend and optimize the `conv2d` function so it can efficiently handle colored images (3 channels: R, G, B) and different padding types. # Requirements: 1. **Function Signature**: ```python def conv2d_colored(img: np.ndarray, kernel: np.ndarray, padding_type: str = \'zero\') -> np.ndarray: pass ``` 2. **Input**: - `img` (np.ndarray): A 3D colored image array with shape (height, width, 3) and float values between 0 and 1. - `kernel` (np.ndarray): A 2D array representing the convolution kernel. - `padding_type` (str): Type of padding to use, options are \'zero\', \'reflect\', and \'replicate\'. 3. **Output**: - `output` (np.ndarray): A 3D colored image array with the convolution applied, maintaining original image size and values between 0 and 1. # Constraints: - Ensure the kernel dimensions are valid (odd size). - Implement and verify different padding methods. - Optimize the computation for handling large images in a reasonable time. # Hints: - For each color channel, apply padding and convolution separately. - Use vectorized operations where possible to improve performance. - Properly normalize the output image to maintain values between 0 and 1. # Example: ```python import numpy as np # Sample usage img = np.random.rand(100, 100, 3).astype(\'float32\') kernel = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]], dtype=\'float32\') # Example Sobel kernel out_img_zero = conv2d_colored(img, kernel, padding_type=\'zero\') out_img_reflect = conv2d_colored(img, kernel, padding_type=\'reflect\') out_img_replicate = conv2d_colored(img, kernel, padding_type=\'replicate\') print(out_img_zero.shape, out_img_reflect.shape, out_img_replicate.shape) # Expected output: (100, 100, 3) ``` # Edge Cases: - Handling small and large images with proper padding. - Proper application of the kernel at the image borders depending on padding type. - Ensuring the output image retains the same dimensions and valid pixel value range as the input.","solution":"import numpy as np def pad_image(img, kernel_shape, padding_type): pad_height = kernel_shape[0] // 2 pad_width = kernel_shape[1] // 2 if padding_type == \'zero\': return np.pad(img, pad_width=((pad_height, pad_height), (pad_width, pad_width), (0, 0)), mode=\'constant\') elif padding_type == \'reflect\': return np.pad(img, pad_width=((pad_height, pad_height), (pad_width, pad_width), (0, 0)), mode=\'reflect\') elif padding_type == \'replicate\': return np.pad(img, pad_width=((pad_height, pad_height), (pad_width, pad_width), (0, 0)), mode=\'edge\') else: raise ValueError(\\"Invalid padding type. Use \'zero\', \'reflect\', or \'replicate\'.\\") def conv2d_colored(img: np.ndarray, kernel: np.ndarray, padding_type: str = \'zero\') -> np.ndarray: kernel_height, kernel_width = kernel.shape assert (kernel_height % 2 == 1) and (kernel_width % 2 == 1), \\"Kernel dimensions must be odd\\" padded_img = pad_image(img, (kernel_height, kernel_width), padding_type) height, width, channels = img.shape output = np.zeros((height, width, channels), dtype=np.float32) for c in range(channels): for i in range(height): for j in range(width): region = padded_img[i:i+kernel_height, j:j+kernel_width, c] output[i, j, c] = np.sum(region * kernel) output = np.clip(output, 0, 1) return output"},{"question":"# Problem Statement You are asked to create a function that finds the smallest number `m` such that it contains exactly `k` distinct prime factors. Distinct prime factors are prime numbers that divide the number evenly without any remainder. Your function should aim to be efficient and handle edge cases effectively. # Function Signature ```python def smallest_number_with_k_prime_factors(k: int) -> int: ``` # Input - An integer `k` representing the number of distinct prime factors. - Constraints: `1 <= k <= 10` # Output - An integer representing the smallest number that has exactly `k` distinct prime factors. # Example ```python assert smallest_number_with_k_prime_factors(2) == 6 # 6 = 2 * 3 assert smallest_number_with_k_prime_factors(3) == 30 # 30 = 2 * 3 * 5 assert smallest_number_with_k_prime_factors(1) == 2 # 2 = 2 ``` # Constraints - The function should efficiently compute the smallest number for `k` up to 10. # Notes - Recall that the smallest numbers with distinct prime factors are the product of the first `k` prime numbers. - Primes are numbers greater than 1 not divisible by any number other than 1 and themselves. # Edge Cases - Handle cases where `k = 1` since the smallest prime number is 2. - Optimize for performance to ensure the function can handle the upper constraint of `k`.","solution":"def smallest_number_with_k_prime_factors(k: int) -> int: Returns the smallest number that has exactly k distinct prime factors. def find_primes(n): Helper function to find the first n prime numbers. primes = [] candidate = 2 while len(primes) < n: is_prime = True for p in primes: if candidate % p == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes primes = find_primes(k) result = 1 for prime in primes: result *= prime return result"},{"question":"# Context You are tasked with implementing a set of mathematical operations involving prime numbers. One of the requirements is to perform prime factorization on a given integer and return the result in a structured format. This will assist in various mathematical and cryptographic applications. # Problem Statement Write a class `PrimeFactorizer` with the following static methods: 1. `is_prime(number: int) -> bool` 2. `next_prime(number: int) -> int` 3. `prime_factors(number: int) -> List[int]` 4. `factors(number: int) -> List[int]` Method Descriptions: * **is_prime**: Checks if a given number is prime. * **next_prime**: Finds and returns the smallest prime number larger than the given number. * **prime_factors**: Returns a list of prime factors of the given number. * **factors**: Returns a list of all factors of the given number. Input and Output Formats: * **Input**: - `number`: An integer for which the prime checks and factorizations are to be performed (1 <= number <= 10^6). * **Output**: The result of the operations as described above. Constraints: 1. Each `number` is within the valid range specified. 2. Methods must handle edge cases effectively (e.g., smallest and largest numbers within the range). Example Usage: ```python factorizer = PrimeFactorizer() print(factorizer.is_prime(7)) # Output: True print(factorizer.next_prime(7)) # Output: 11 print(factorizer.prime_factors(28)) # Output: [2, 2, 7] print(factorizer.factors(28)) # Output: [1, 2, 4, 7, 14, 28] ``` # Performance Requirement The methods should be optimized for the input range. Avoid unnecessary computations to ensure efficient execution within the constraints. Good luck, and ensure your implementation handles edge cases and input validation correctly!","solution":"from typing import List class PrimeFactorizer: @staticmethod def is_prime(number: int) -> bool: if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True @staticmethod def next_prime(number: int) -> int: if number <= 1: return 2 prime = number found = False while not found: prime += 1 if PrimeFactorizer.is_prime(prime): found = True return prime @staticmethod def prime_factors(number: int) -> List[int]: n = number factors = [] while n % 2 == 0: factors.append(2) n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i if n > 2: factors.append(n) return factors @staticmethod def factors(number: int) -> List[int]: result = set() for i in range(1, int(number**0.5) + 1): if number % i == 0: result.add(i) result.add(number // i) return sorted(result)"},{"question":"# Unique Prime Factorization You are assigned the task of finding the unique prime factorization of a number. Given a positive integer, you must return its prime factors as a dictionary where keys are the prime factors and values are their respective exponents in the factorization. # Function Requirements You need to implement the function `prime_factorization(n: int) -> dict[int, int]` following these requirements: 1. **Input**: - `n` (int): A positive integer for which the prime factorization is to be determined. 2. **Output**: - A dictionary where keys are prime factors of `n` and values are the exponents of these factors in its prime factorization. # Steps: 1. **Prime Generation**: - Use a prime generation method (e.g., trial division) to identify potential prime factors up to the square root of `n`. 2. **Factorization**: - For each potential prime factor, count how many times it divides `n` and store the factor and its count in a dictionary. - Continue dividing `n` by the prime factor until it is no longer divisible by that factor. 3. **Remaining Prime**: - If after processing all factors up to the square root of `n`, the remaining value of `n` is a prime number greater than 1, it is itself a prime factor. # Constraints: - The function should handle numbers up to `10^9` efficiently. - Avoid unnecessary recomputation by optimizing the factorization process. # Example: ```python >>> prime_factorization(60) {2: 2, 3: 1, 5: 1} >>> prime_factorization(100) {2: 2, 5: 2} >>> prime_factorization(13) {13: 1} ``` # Implementation: Write your solution as a function in Python. ```python def prime_factorization(n: int) -> dict[int, int]: factors = {} # Start with the smallest prime factor d = 2 while d * d <= n: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 if n > 1: factors[n] = 1 return factors ``` Provide accompanying explanations for critical parts and document any assumptions or constraints.","solution":"def prime_factorization(n: int) -> dict[int, int]: factors = {} # Start with the smallest prime factor d = 2 while d * d <= n: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 # If what\'s left is a prime number greater than 1, it is itself a prime factor if n > 1: factors[n] = 1 return factors"},{"question":"# Finding Peak Element in a List Context You are enhancing the functionality of a data analysis tool that requires identifying specific elements in a dataset. One such functionality is to find an element in a list which is greater than or equal to its neighbors, commonly known as a peak element. This element provides significant insight in various analysis scenarios such as identifying turning points in a dataset. Problem Statement Write a function `find_peak_element` that finds a peak element in the given list. A peak element is an element that is greater than or equal to its neighbors. For a list of multiple peak elements, returning any one of them is acceptable. Your function should operate efficiently on large datasets. Function Signature ```python def find_peak_element(nums: list[int]) -> int: pass ``` Input - `nums` (list of int): A list of integers. Output - Returns an integer which is the index of any peak element in the list. Constraints - `1 <= len(nums) <= 10^6` - The list may have multiple peaks, any of which is valid as the return value. - Edge cases like lists with single elements should be handled. - The list can be unsorted. Requirements - The implementation should be optimal in terms of time complexity (O(log n) expected). - Properly handle edge cases, including a single element list and handling unsorted lists. - Avoid excess memory usage. Example ```python assert find_peak_element([1, 2, 3, 1]) == 2 assert find_peak_element([1, 2, 3, 4, 5]) == 4 assert find_peak_element([5, 4, 3, 2, 1]) == 0 assert find_peak_element([2, 1]) == 0 ```","solution":"def find_peak_element(nums: list[int]) -> int: Finds any peak element in the list, where a peak element is greater than or equal to its neighbors. Args: nums (list of int): The list of integers to search for a peak element. Returns: int: The index of any peak element found in the list. def binary_search(left, right): if left == right: return left mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: return binary_search(left, mid) return binary_search(mid + 1, right) return binary_search(0, len(nums) - 1)"},{"question":"# Trie Implementation for Autocomplete You are tasked with implementing a Trie (prefix tree) to support an autocomplete feature. Your implementation will include inserting words into the Trie and searching for words with a given prefix. This question evaluates your understanding of data structures and string manipulation. Function 1: insert_word Implement a function `insert_word` that inserts a given word into the Trie. Each word is a string of lowercase alphabetic characters. # Input: * `word`: A string representing the word to be inserted into the Trie. # Output: * None ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True ``` Function 2: search_prefix Implement a function `search_prefix` that searches the Trie for words starting with a given prefix. It should return a list of words that have the given prefix. # Input: * `prefix`: A string representing the prefix to search for in the Trie. # Output: * A list of strings that are words starting with the given prefix. Example ```python trie = Trie() words = [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"] for word in words: trie.insert_word(word) result = trie.search_prefix(\\"he\\") ``` In the above example, `result` should include words like \\"hello\\", \\"hell\\", \\"heaven\\", and \\"heavy\\" since they all start with the prefix \\"he\\". Constraints * Words will be non-empty strings consisting of lowercase alphabetic characters only. * The number of input words will be between 1 and 1000. * The length of each word will be between 1 and 100. Function Template ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix): def dfs(node, prefix, result): if node.is_end_of_word: result.append(prefix) for char, child in node.children.items(): dfs(child, prefix + char, result) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] result = [] dfs(node, prefix, result) return result ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert_word(self, word): Inserts a given word into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix): Searches for words in the Trie that start with the given prefix. def dfs(node, prefix, result): if node.is_end_of_word: result.append(prefix) for char, child in node.children.items(): dfs(child, prefix + char, result) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] result = [] dfs(node, prefix, result) return result"},{"question":"# Question: Efficient Longest Increasing Subsequence Finder Given an integer array `nums`, implement a function `length_of_LIS(nums)` that finds the length of the longest increasing subsequence in an efficient manner. The implementation should improve upon the standard dynamic programming approach, which has a time complexity of O(n^2), and aim for a solution with better overall complexity, such as O(n log n) using advanced data structures like binary search. Your task is to provide an optimized algorithm that maintains correctness while handling performance constraints effectively. Implement the function: ```python def length_of_LIS(nums): pass ``` # Input/Output Input * `nums`: a list of integers (0 <= nums[i] <= 10^4) representing the array whose LIS length is to be found Output * Returns an integer representing the length of the longest increasing subsequence in `nums`. # Constraints * 1 <= len(nums) <= 10^4 # Example ```python assert length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert length_of_LIS([0, 1, 0, 3, 2, 3]) == 4 assert length_of_LIS([7, 7, 7, 7, 7, 7, 7]) == 1 ``` # Notes 1. Your solution should manage large input sizes efficiently within the given constraints. 2. Utilize appropriate data structures and algorithms to achieve the desired time complexity. 3. Consider edge cases and validate your solution against various test scenarios to ensure robustness.","solution":"from bisect import bisect_left def length_of_LIS(nums): Returns the length of the longest increasing subsequence (LIS) in the given list of numbers. This implementation uses a binary search to achieve O(n log n) time complexity. if not nums: return 0 lis = [] for num in nums: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"**Scenario**: You are developing an efficient storage system for a large company that deals with extremely high volumes of data. One of the critical requirements is to frequently calculate prefix sums for quick data retrieval operations. Your task is to implement a data structure that supports the following operations in constant time after an initial setup: 1. `compute_prefix_sums(array)`: Prepare the data array such that prefix sum queries can be answered in constant time. 2. `query_prefix_sum(i, j)`: Return the sum from index `i` to index `j` in constant time using the pre-processed data. **Question**: Write a class `PrefixSum` that provides the above functionality. Implement the class based on the following information: * **Input Format**: * A list `array` of integers that needs to be pre-processed to allow prefix sum queries. * **Output Format**: * The method `query_prefix_sum(i, j)` should return an integer representing the sum of the array elements from index `i` to index `j` inclusive. **Constraints**: * The length of the input list, n, is such that `1 <= n <= 10^5` * The elements of the array are integers such that `-10^3 <= element <= 10^3` * `0 <= i <= j < n` **Examples**: ```python class PrefixSum: def __init__(self, array): # Implementation goes here def query_prefix_sum(self, i, j): # Implementation goes here # Example Usage array = [1, 2, 3, 4, 5] ps = PrefixSum(array) print(ps.query_prefix_sum(0, 2)) # Output: 6 print(ps.query_prefix_sum(1, 3)) # Output: 9 print(ps.query_prefix_sum(2, 4)) # Output: 12 ``` **Explanation**: In the given example, the input `array` represents the sequence [1, 2, 3, 4, 5]. After pre-processing, the `query_prefix_sum(i, j)` function should be able to return the sum of elements from index `i` to index `j` in constant time. The initialization method should pre-compute the necessary data to ensure the queries are efficient. For each of the example queries: * `query_prefix_sum(0, 2)` returns `1 + 2 + 3 = 6` * `query_prefix_sum(1, 3)` returns `2 + 3 + 4 = 9` * `query_prefix_sum(2, 4)` returns `3 + 4 + 5 = 12` Make sure to handle edge cases such as querying the entire array or querying a single element.","solution":"class PrefixSum: def __init__(self, array): self.prefix_sums = [0] * (len(array) + 1) for i in range(len(array)): self.prefix_sums[i + 1] = self.prefix_sums[i] + array[i] def query_prefix_sum(self, i, j): return self.prefix_sums[j + 1] - self.prefix_sums[i]"},{"question":"# Problem Description You are asked to design a Rank Tracking system for a gaming application where players compete, and their scores are tracked in real-time. The system should be able to provide efficient rank lookups and updates as players\' scores change. Your tasks are: 1. Implement a method to add a new player to the system. 2. Implement a method to update a player\'s score. 3. Implement a method to get the player\'s rank based on their score. # Function Specifications 1. **add_player(player_id: int, score: int)**: Adds a new player to the system with an initial score. - **Input**: An integer `player_id` representing the unique ID of the player and an integer `score` representing the player\'s initial score. - **Output**: None - **Behavior**: Add the player to the system with the given score. Ensure player_id is unique. 2. **update_score(player_id: int, new_score: int)**: Updates the score of an existing player. - **Input**: An integer `player_id` representing the unique ID of the player and an integer `new_score` representing the player\'s updated score. - **Output**: None - **Behavior**: Update the player\'s score in the system. 3. **get_rank(player_id: int) -> int**: Retrieves the current rank of a player based on their score. - **Input**: An integer `player_id` representing the unique ID of the player. - **Output**: An integer representing the player\'s rank. - **Behavior**: Return the rank of the player based on their score, where a lower rank number indicates a higher score. If multiple players have the same score, they should have the same rank, and the next player(s) should have a rank that reflects the tie. # Constraints - All player IDs are unique positive integers. - Scores are non-negative integers. - The system should handle up to 100,000 players efficiently. - The rank should be 1-based, meaning the top player has rank 1. # Example ```python ranking_system = RankTrackingSystem() ranking_system.add_player(1, 1500) ranking_system.add_player(2, 2000) ranking_system.add_player(3, 1800) print(ranking_system.get_rank(1)) # Output: 3 print(ranking_system.get_rank(2)) # Output: 1 print(ranking_system.get_rank(3)) # Output: 2 ranking_system.update_score(1, 2500) print(ranking_system.get_rank(1)) # Output: 1 print(ranking_system.get_rank(2)) # Output: 2 print(ranking_system.get_rank(3)) # Output: 3 ``` # Requirements - Ensure your implementation is efficient, particularly with respect to the constraints. - Carefully handle edge cases such as updating the score for a player that does not exist, or querying a rank for a player not in the system.","solution":"from bisect import insort_left class RankTrackingSystem: def __init__(self): self.players = {} self.scores = [] def add_player(self, player_id: int, score: int): if player_id in self.players: raise ValueError(\\"Player ID already exists.\\") self.players[player_id] = score insort_left(self.scores, (score, player_id)) def update_score(self, player_id: int, new_score: int): if player_id not in self.players: raise ValueError(\\"Player ID does not exist.\\") old_score = self.players[player_id] self.scores.remove((old_score, player_id)) self.players[player_id] = new_score insort_left(self.scores, (new_score, player_id)) def get_rank(self, player_id: int) -> int: if player_id not in self.players: raise ValueError(\\"Player ID does not exist.\\") score = self.players[player_id] rank = len([sc for sc in self.scores if sc[0] > score]) + 1 return rank"},{"question":"# Efficient Path Finding in a Grid with Obstacles You are developing a robot navigation system, and one of the key tasks is to find the shortest path in a grid while avoiding obstacles. The grid is represented as a 2D list, where `0` represents an open cell and `1` represents an obstacle. Task Create a function `find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> int`. # Input - `grid`: A 2D list of integers representing the grid. - `start`: A tuple `(x, y)` representing the starting coordinates. - `goal`: A tuple `(x, y)` representing the goal coordinates. # Output - Return the length of the shortest path from `start` to `goal` as an integer. If no path exists, return `-1`. # Constraints - The grid dimensions are m x n, where `1 <= m, n <= 100`. - `grid[i][j]` is either 0 (open cell) or 1 (obstacle). - The start and goal coordinates are guaranteed to be within the grid bounds. - The start and goal coordinates will not be obstacles. # Examples ```python grid = [ [0, 0, 0, 0, 0], [0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert find_shortest_path(grid, (0, 0), (4, 4)) == 8 grid = [ [0, 1, 0, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0] ] assert find_shortest_path(grid, (0, 0), (4, 4)) == -1 ``` # Notes Ensure your solution: - Handles grids with various configurations of obstacles. - Efficiently finds the shortest path using algorithms suitable for this task, such as Breadth-First Search (BFS) or A*. - Properly manages edge cases, such as when there is no valid path available.","solution":"from collections import deque from typing import List, Tuple def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> int: Uses Breadth-First Search (BFS) to find the shortest path in a grid with obstacles. m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == goal: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # No path found"},{"question":"# Coding Assessment Question: Problem Context In a distributed database system, data is often partitioned across multiple nodes. One common way to select nodes is by using a hash of the key modulo the number of nodes. However, with dynamic additions and removals of nodes, the consistent hashing approach ensures minimal movement of keys between the nodes. Task Implement a function `consistent_hash(key: str, num_nodes: int) -> int` that computes the hash of a given key and then maps it to one of the nodes in the system. Your function should utilize a basic hash function (you can use Python\'s built-in `hash()` function) and ensure the result is always a valid node index. Function Signature ```python def consistent_hash(key: str, num_nodes: int) -> int: ``` Input * A single string `key`, representing the key that needs to be hashed. * An integer `num_nodes`, representing the total number of nodes in the system. Output * The index of the node to which the key should be mapped, ranging from 0 to `num_nodes - 1`. Constraints 1. `1 <= len(key) <= 100` 2. `1 <= num_nodes <= 10^6` Examples * `consistent_hash(\'my_key\', 5)` might return `2`. * `consistent_hash(\'another_key\', 5)` might return `4`. * `consistent_hash(\'my_key\', 1)` will return `0` as there is only one node. Notes 1. Ensure that your hash computation is efficient and scales well with a large number of nodes. 2. The indices of the nodes should be distributed as uniformly as possible based on the hash values. Additional Implementation Details 1. Test your function thoroughly with varying lengths of the key and different numbers of nodes. 2. Ensure that the function handles edge cases, such as having only one node, gracefully. 3. Consider making your function deterministic across different runs of the program for the same inputs to ensure consistency in mapping.","solution":"def consistent_hash(key: str, num_nodes: int) -> int: Computes the hash of a given key and maps it to one of the nodes in the system. Returns the index of the node to which the key should be mapped. hash_value = hash(key) return hash_value % num_nodes"},{"question":"# Task: Game Score Tracker You have been assigned to develop a scorekeeping system for a video game. The system should track the scores of players and allow for the retrieval of top-scoring players. Part 1: Score Update Write a class `ScoreKeeper` that supports the following methods: 1. `add_score(player_id: str, score: int) -> None`: - Takes a string `player_id` and an integer `score`. - Updates the player\'s total score by adding the given `score` to the existing score. Part 2: Top Scorers Retrieval Extend the `ScoreKeeper` class to include a method: 2. `top_scorers(n: int) -> List[str]`: - Takes an integer `n` as input. - Returns a list of player IDs representing the top `n` players based on their scores. - If two players have the same score, they should be ordered alphabetically by their `player_id`. - If `n` is greater than the number of players, return all player IDs sorted by their scores in descending order. Constraints: - Player IDs are unique strings containing only alphanumeric characters. - The `score` will always be a non-negative integer. - The number of players will not exceed 10,000. Example ```python score_keeper = ScoreKeeper() score_keeper.add_score(\'Alice\', 10) score_keeper.add_score(\'Bob\', 15) score_keeper.add_score(\'Alice\', 5) score_keeper.add_score(\'Charlie\', 20) >>> score_keeper.top_scorers(2) [\'Charlie\', \'Alice\'] >>> score_keeper.top_scorers(5) [\'Charlie\', \'Alice\', \'Bob\'] ``` Requirements - Implement the `ScoreKeeper` class with the methods as specified. - Handle edge cases such as adding scores for new players and retrieving top scorers when the number of players is less than `n`. - Ensure that the `top_scorers` method is efficient and performs well with the maximum number of players. Implement the `ScoreKeeper` class and its methods in Python.","solution":"from typing import List from collections import defaultdict class ScoreKeeper: def __init__(self): self.scores = defaultdict(int) def add_score(self, player_id: str, score: int) -> None: Updates a player\'s score by adding the given score to their total. self.scores[player_id] += score def top_scorers(self, n: int) -> List[str]: Returns a list of the top n player IDs based on their scores. Players with the same score are ordered alphabetically by their ID. sorted_players = sorted( self.scores.items(), key=lambda x: (-x[1], x[0]) ) return [player_id for player_id, score in sorted_players[:n]]"},{"question":"# Question: Vowel Substring Finder The task is to determine the longest substring within a given string that contains only vowels. The provided initial brute-force solution performs well for small strings but needs optimization to handle longer inputs efficiently. **Task**: Write a Python function that finds the longest substring of a given string that consists only of vowels (a, e, i, o, u). Your solution must be optimized to handle large strings efficiently. Input: - A string `s` of length `1 <= len(s) <= 10^6`, consisting of lowercase English letters. Output: - A string representing the longest contiguous substring that contains only vowels. - If there are multiple such substrings with the same maximum length, return the one which appears first. Function Signature: ```python def longest_vowel_substring(s: str) -> str: pass ``` Constraints: - Your solution should perform in linear time, O(n), where n is the length of the string. - You should avoid nested loops that result in O(n^2) complexity. - Ensure your solution handles strings with no vowels correctly. Example: ```python >>> longest_vowel_substring(\\"elephant\\") \\"e\\" >>> longest_vowel_substring(\\"beautiful\\") \\"eau\\" >>> longest_vowel_substring(\\"sky\\") \\"\\" ``` **Hint**: Utilize two-pointer or sliding window techniques to keep track of the current substring and update the longest substring found efficiently.","solution":"def longest_vowel_substring(s: str) -> str: Returns the longest contiguous substring that contains only vowels from the input string `s`. vowels = set(\'aeiou\') max_len = 0 max_substr = \\"\\" current_start = 0 current_len = 0 for i, char in enumerate(s): if char in vowels: current_len += 1 if current_len > max_len: max_len = current_len max_substr = s[current_start:i+1] else: current_len = 0 current_start = i + 1 return max_substr"},{"question":"# Problem Statement You are tasked with designing an algorithm to evaluate the performance of a portfolio of stocks. The objective is to calculate the maximum possible profit you could have made by buying and selling a stock exactly once over a specified period. Additionally, you need to extend the functionality to identify the start and end days of that maximum profit period. # Requirements 1. **Input**: - `prices`: A one-dimensional list of integers representing the stock prices over a series of days. Each element corresponds to the stock price on a given day. 2. **Output**: - A tuple containing three elements: - An integer representing the maximum profit possible. - An integer representing the day (index) to buy the stock to achieve this profit. - An integer representing the day (index) to sell the stock to achieve this profit. # Constraints - The length of `prices` will be at least 2 and less than or equal to 1,000,000. - Each element in `prices` will be an integer between 1 and 10,000. # Example ```python # Sample inputs prices = [7, 1, 5, 3, 6, 4] # Evaluating the portfolio max_profit, buy_day, sell_day = evaluate_portfolio(prices) print(f\\"Maximum Profit: {max_profit}, Buy Day: {buy_day}, Sell Day: {sell_day}\\") # Output: Maximum Profit: 5, Buy Day: 1, Sell Day: 4 ``` # Instructions: 1. Implement the function `evaluate_portfolio(prices)` that: - Iterates over the list of prices to find the optimal buy and sell days for maximum profit. - Efficiently identifies and returns the maximum profit alongside the corresponding days (indices) for buying and selling the stock. 2. Ensure the function handles large lists of stock prices within the provided constraints.","solution":"def evaluate_portfolio(prices): Evaluates the maximum possible profit by buying and selling a stock exactly once over a period. Args: prices (list of int): A list of stock prices over a series of days. Returns: tuple: A tuple containing the maximum profit, the buy day, and the sell day. if len(prices) < 2: return (0, -1, -1) # not enough data to buy and sell min_price = prices[0] max_profit = 0 buy_day = 0 sell_day = 0 min_day = 0 for current_day in range(1, len(prices)): current_price = prices[current_day] # Check if we have a new minimum price if current_price < min_price: min_price = current_price min_day = current_day # Calculate the potential profit potential_profit = current_price - min_price # Update the maximum profit and the corresponding days if the potential profit is greater if potential_profit > max_profit: max_profit = potential_profit buy_day = min_day sell_day = current_day return (max_profit, buy_day, sell_day)"},{"question":"# Sum of List When Condition Met You are tasked with the implementation of a function that calculates the sum of all integers in a list that satisfy a given condition. The condition is that the integer must be divisible by a specified divisor. Your Task Implement the function `sum_of_integers(lst: List[int], divisor: int) -> int` that takes a list of integers and a divisor, and returns the sum of all integers in the list that are divisible by the given divisor. # Input - `lst` (List[int]): A list of integers. - `divisor` (int): An integer divisor. # Output - (int): The sum of all integers in the list that are divisible by the divisor. If no divisors are found, return 0. # Constraints - The input list can have between `0` and `10^6` integers. - Each integer in the list will be between `-10^6` and `10^6`. - The divisor will be a non-zero integer between `-10^6` and `10^6`. # Examples ```python >>> sum_of_integers([1, 2, 3, 4, 5, 6], 2) 12 >>> sum_of_integers([10, 15, 20, 25, 30], 5) 100 >>> sum_of_integers([0, 12, 18, 24, 30], 6) 84 >>> sum_of_integers([1, 3, 5, 7], 10) 0 >>> sum_of_integers([10, -20, 30, -40], -10) -20 ``` This question, like the original, focuses on fundamental programming concepts such as list operations, conditional checks, and mathematical operations. The difficulty level, length, and structure are designed to match those of the existing question set.","solution":"def sum_of_integers(lst, divisor): Returns the sum of all integers in the list that are divisible by the divisor. return sum(x for x in lst if x % divisor == 0)"},{"question":"# Distance between Two Points You need to write a function to calculate the distance between two points in a 2D coordinate system. The points are represented as tuples of two floats that correspond to their x and y coordinates. Your task is to implement a function that returns the distance between two given points. # Function Signature ```python def distance_between_points(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: pass ``` # Input - `point1` (Tuple[float, float]): A tuple representing the coordinates (x, y) of the first point. - `point2` (Tuple[float, float]): A tuple representing the coordinates (x, y) of the second point. # Output - A float value representing the distance between `point1` and `point2`. # Constraints - Performance: Efficient computation is required for two points. - Handling of invalid inputs: Raise a `ValueError` if `point1` or `point2` are not tuples with exactly two float elements. # Example ```python >>> distance_between_points((0, 0), (3, 4)) 5.0 >>> distance_between_points((1.2, 3.4), (1.2, 3.4)) 0.0 >>> distance_between_points((-1, -1), (1, 1)) 2.8284271247461903 >>> distance_between_points((2.5, -2.5), (-2.5, 2.5)) 7.0710678118654755 >>> distance_between_points((1, 2), (3, \'4\')) Traceback (most recent call last): ... ValueError: Both points must be tuples with exactly two float elements. ``` # Notes - Use the formula for the Euclidean distance between two points `(x1, y1)` and `(x2, y2)`: [ text{distance} = sqrt{(x2 - x1)^2 + (y2 - y1)^2} ] - Ensure proper validation of inputs and handle any potential errors gracefully.","solution":"import math from typing import Tuple def distance_between_points(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: if not (isinstance(point1, tuple) and isinstance(point2, tuple)): raise ValueError(\\"Both points must be tuples.\\") if not (len(point1) == 2 and len(point2) == 2): raise ValueError(\\"Both points must be tuples with exactly two elements.\\") if not (all(isinstance(coord, (int, float)) for coord in point1) and all(isinstance(coord, (int, float)) for coord in point2)): raise ValueError(\\"Both points must be tuples with exactly two float elements.\\") x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"**Context**: You are working on a simplified version of a filesystem to manage files and directories. You need to create a class that allows you to create, delete, and navigate directories within this filesystem. **Objective**: Implement a `Filesystem` class that supports creating new directories, deleting existing directories, and traversing the filesystem. # Requirements: 1. **Class Structure**: * `Filesystem`: Main class to manage the filesystem. * `Directory`: Helper class to represent each directory. 2. **Methods to Implement**: * `mkdir(path)`: Creates a new directory at the specified `path`. * `ls(path)`: Lists all the directories in the specified `path`. * `cd(path)`: Changes the current working directory to the specified `path`. * `rmdir(path)`: Deletes the directory at the specified `path`. # Define Class Structure ```python class Directory: def __init__(self, name): self.name = name self.subdirectories = {} class Filesystem: def __init__(self): self.root = Directory(\\"\\") self.current_dir = self.root def mkdir(self, path: str): Create a new directory at the specified path. # Implement mkdir functionality def ls(self, path: str) -> list: List all directories in the specified path. # Implement ls functionality def cd(self, path: str): Change the current working directory to the specified path. # Implement cd functionality def rmdir(self, path: str): Delete the directory at the specified path. # Implement rmdir functionality ``` # Instructions 1. **Directory Creation**: Implement `mkdir` to create new directories. If any directory in the path does not exist, it should be created. 2. **Listing Directories**: Implement `ls` to return a list of all subdirectory names at the specified path. If the path does not exist, return an empty list. 3. **Changing Directory**: Implement `cd` to change the working directory. It should support both absolute and relative paths. If the specified directory does not exist, set the current directory to the root. 4. **Deleting Directory**: Implement `rmdir` to delete a directory. If the directory does not exist, do nothing. # Constraints * Only lowercase alphabetic characters and slashes (`/`) will be used in paths. * Paths will not contain trailing slashes. * Paths can be absolute or relative to the current directory. * Initial directory is always the root directory. # Example ```python # Example usage fs = Filesystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") print(fs.ls(\\"/a\\")) # Output: [\'b\'] fs.cd(\\"/a/b\\") fs.mkdir(\\"c\\") print(fs.ls(\\"\\")) # Output: [\'c\'] fs.cd(\\"/\\") fs.rmdir(\\"/a/b/c\\") fs.cd(\\"/a/b\\") print(fs.ls(\\"\\")) # Output: [] ```","solution":"class Directory: def __init__(self, name): self.name = name self.subdirectories = {} class Filesystem: def __init__(self): self.root = Directory(\\"\\") self.current_dir = self.root def mkdir(self, path: str): directories = self._parse_path(path) current = self.current_dir if not path.startswith(\'/\') else self.root for dir_name in directories: if dir_name not in current.subdirectories: current.subdirectories[dir_name] = Directory(dir_name) current = current.subdirectories[dir_name] def ls(self, path: str) -> list: directories = self._parse_path(path) current = self._navigate_to_path(directories) return list(current.subdirectories.keys()) if current else [] def cd(self, path: str): directories = self._parse_path(path) current = self._navigate_to_path(directories) self.current_dir = current if current else self.root def rmdir(self, path: str): directories = self._parse_path(path) parent = self._navigate_to_path(directories[:-1]) if parent and directories[-1] in parent.subdirectories: del parent.subdirectories[directories[-1]] def _parse_path(self, path: str) -> list: if path == \\"\\": return [] if path.startswith(\'/\'): path = path[1:] return path.split(\'/\') def _navigate_to_path(self, directories: list) -> Directory: current = self.current_dir if not directories or directories[0] != \\"\\" else self.root for dir_name in directories: if dir_name == \\"..\\": continue # Ignore for now, as there\'s no parent reference to move up if dir_name not in current.subdirectories: return None current = current.subdirectories[dir_name] return current"},{"question":"# Coding Assessment Question You are a software engineer working on optimizing the performance of a photo sharing application. As part of the application\'s features, users frequently upload and manipulate images. One task you need to handle is verifying whether an image is in landscape orientation. This can be used in various workflows such as automatic photo optimization and alignment. Problem Statement Write a function named `is_landscape` that determines if an image is in landscape orientation. An image is considered landscape if its width is greater than its height. The function should return `True` if the image is in landscape orientation, and `False` otherwise. Function Signature ```python def is_landscape(width: int, height: int) -> bool: pass ``` Input - `width`: An integer representing the width of the image. - `height`: An integer representing the height of the image. Output - Returns a boolean: - `True` if the width is greater than the height (landscape). - `False` otherwise (portrait or square). Example ```python assert is_landscape(1920, 1080) == True assert is_landscape(1080, 1920) == False assert is_landscape(1024, 768) == True assert is_landscape(800, 800) == False assert is_landscape(1200, 1200) == False assert is_landscape(2560, 1600) == True ``` Constraints - The function should run efficiently with minimal overhead. - Assume both `width` and `height` are positive integers within the range of typical image dimensions (up to tens of thousands of pixels). Requirements - Implement the function `is_landscape` as described. - Ensure the function passes basic tests to verify its correctness.","solution":"def is_landscape(width: int, height: int) -> bool: Determines if an image is in landscape orientation. Args: width (int): The width of the image. height (int): The height of the image. Returns: bool: True if the image is in landscape orientation, False otherwise. return width > height"},{"question":"# Temperature Conversion Scenario: You are developing a weather application that displays temperature readings. One feature you need to implement is the ability to convert temperatures from Fahrenheit to Celsius and vice versa. The user should be able to specify the temperature and the target unit, and receive the converted temperature. # Task Write a Python function that converts a given temperature from its current unit to the specified target unit (either Celsius or Fahrenheit). Function Signature ```python def convert_temperature(temp: float, from_unit: str, to_unit: str) -> float: pass ``` Input * `temp` (float): The temperature value to convert. * `from_unit` (str): The current unit of the temperature. Must be either \'C\' for Celsius or \'F\' for Fahrenheit. * `to_unit` (str): The desired unit to convert the temperature to. Must be either \'C\' for Celsius or \'F\' for Fahrenheit. Output * Returns the converted temperature (float). Constraints * `from_unit` and `to_unit` must be either \'C\' or \'F\'. Examples ```python >>> convert_temperature(100, \'C\', \'F\') 212.0 >>> convert_temperature(32, \'F\', \'C\') 0.0 >>> convert_temperature(-40, \'C\', \'F\') -40.0 ``` Validation and Error Handling Your function should raise appropriate exceptions for the following conditions: * If `from_unit` is not \'C\' or \'F\', raise `Exception: Invalid from_unit. Must be either \'C\' or \'F\'` * If `to_unit` is not \'C\' or \'F\', raise `Exception: Invalid to_unit. Must be either \'C\' or \'F\'` * If `from_unit` is the same as `to_unit`, return the `temp` without any conversion","solution":"def convert_temperature(temp: float, from_unit: str, to_unit: str) -> float: Converts temperature from one unit to another. Arguments: temp : float : The temperature value to convert. from_unit : str : The current unit of the temperature (\'C\' for Celsius, \'F\' for Fahrenheit). to_unit : str : The desired unit to convert the temperature to (\'C\' for Celsius, \'F\' for Fahrenheit). Returns: float : The converted temperature value. if from_unit not in [\'C\', \'F\']: raise Exception(\\"Invalid from_unit. Must be either \'C\' or \'F\'\\") if to_unit not in [\'C\', \'F\']: raise Exception(\\"Invalid to_unit. Must be either \'C\' or \'F\'\\") if from_unit == to_unit: return temp if from_unit == \'C\' and to_unit == \'F\': return (temp * 9/5) + 32 elif from_unit == \'F\' and to_unit == \'C\': return (temp - 32) * 5/9"},{"question":"# Matrix Rotation Problem Given a square matrix, your task is to write a program to rotate the matrix by 90 degrees in a clockwise direction. Your solution should perform the rotation in-place, meaning you should not use any extra space other than a few temporary variables. Description Implement the `rotate_matrix` method which takes a 2D square matrix (list of lists) as input and rotates the matrix by 90 degrees clockwise. Specifications * **Input**: * A 2D square matrix `matrix` of integers. The size of the matrix is `n x n`, where `n` is the number of rows (and columns). Each element in the matrix is an integer. * **Output**: * The matrix should be rotated in-place, so no return value is required. Modify the input matrix directly. Example ```python def rotate_matrix(matrix: list[list[int]]) -> None: n = len(matrix) for layer in range(n // 2): first, last = layer, n - layer - 1 for i in range(first, last): # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[-i-1][first] # Move bottom element to left matrix[-i-1][first] = matrix[-first-1][-i-1] # Move right element to bottom matrix[-first-1][-i-1] = matrix[i][-first-1] # Assign top element to right matrix[i][-first-1] = top if __name__ == \\"__main__\\": mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(mat) for row in mat: print(row) ``` Output: ``` [7, 4, 1] [8, 5, 2] [9, 6, 3] ``` Instructions 1. Implement the `rotate_matrix` method to perform the rotation in-place. 2. Ensure you handle the elements of the matrix correctly so that no data is lost during the rotation process. 3. The solution should work efficiently for large matrices without using additional space. Constraints * The matrix size `n x n` can have `n` up to 1000. * The elements of the matrix are integers. * The matrix is always non-empty and square.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. :param matrix: A square 2D list of integers :return: None. The matrix is rotated in place. n = len(matrix) for layer in range(n // 2): first, last = layer, n - layer - 1 for i in range(first, last): # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[-i-1][first] # Move bottom element to left matrix[-i-1][first] = matrix[-first-1][-i-1] # Move right element to bottom matrix[-first-1][-i-1] = matrix[i][-first-1] # Assign top element to right matrix[i][-first-1] = top"},{"question":"# Question: Matrix Diagonal Traversal You are given an `m x n` matrix of integers representing a 2D matrix. Write a function to return all elements of the matrix in diagonal order starting from the top-left corner. A diagonal order starts from the elements of the first row moving top-right and continues moving right-down until all elements are traversed. # Function Signature ```python def find_diagonal_order(matrix: List[List[int]]) -> List[int]: ``` # Input - `matrix` (List[List[int]]): A 2D list of integers representing the matrix. # Output - Returns a list of integers representing the matrix elements in diagonal order. # Constraints 1. The number of elements in the matrix will not exceed 10,000. 2. The matrix dimensions `m` and `n` will be positive integers where `1 <= m, n <= 100`. # Example ```python >>> find_diagonal_order([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` # Explanation - The traversal starts at `matrix[0][0]` (which is `1`). - Move diagonally up-right to `matrix[0][1]` (which is `2`), then to `matrix[1][0]` (which is `4`), and so on. - When moving up-right or down-left, handle the boundaries of the matrix by switching the direction as soon as you hit any boundary. # Hints 1. Use two arrays `[1, -1]` and `[-1, 1]` to handle the direction of diagonal movement efficiently. 2. Keep track of the current position and adjust the direction when hitting the border conditions.","solution":"def find_diagonal_order(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for d in range(m + n - 1): intermediate = [] r = 0 if d < n else d - n + 1 c = d if d < n else n - 1 while r < m and c > -1: intermediate.append(matrix[r][c]) r += 1 c -= 1 if d % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) return result"},{"question":"# Coding Assessment Question Context You are working on implementing a basic stack data structure. One important functionality to include in a stack is checking whether it contains a given element. This operation will help ensure that the stack supports element look-up efficiently. Task Implement a method `contains` within the `Stack` class that checks if a given element is present in the stack. Function Specification ```python def contains(self, value: int) -> bool: Checks whether the stack contains the specified element. Args: value (int): The value to check for in the stack. Examples: >>> stack = Stack() >>> stack.push(3) >>> stack.push(2) >>> stack.push(1) >>> stack.contains(2) True >>> stack.contains(4) False When the stack is empty: >>> stack = Stack() >>> stack.contains(1) False Returns: bool: True if the stack contains the specified element, False otherwise. pass ``` Constraints * Target a time complexity of O(n) for the `contains` method, where n is the number of elements in the stack. * The stack contains integers only. * Assume there are no duplicate elements in the stack. Input Format A method `contains` is added to the `Stack` class with the parameter `value` of type int. Output Format Returns `True` if the stack contains the specified element; otherwise, returns `False`. Examples * Input: `Stack` with elements [1, 2, 3], `contains` is called with `2` * Expected Output: `True` * Input: `Stack` with elements [1, 2, 3], `contains` is called with `4` * Expected Output: `False`","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value: int): self.stack.append(value) def pop(self) -> int: if not self.is_empty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def is_empty(self) -> bool: return len(self.stack) == 0 def contains(self, value: int) -> bool: return value in self.stack"},{"question":"# Context Sorting algorithms are pivotal in computer science. One such algorithm is the Bubble Sort, which repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The process is repeated until the list is sorted. # Problem Statement Write a function `bubble_sort(arr: List[int]) -> List[int]` that takes a list of integers as input and returns a new list with the elements sorted in ascending order using the Bubble Sort algorithm. You should not modify the original list. # Input - `arr`: a list of integers. # Output - A new list of integers sorted in ascending order. # Constraints - The input list `arr` length will not exceed 10^4. - The integers in the list can be both positive and negative, and within the range of -10^6 to 10^6. # Example ```python >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([-1, 5, 3, 2, -2, 0]) [-2, -1, 0, 2, 3, 5] >>> bubble_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] ``` # Notes - Ensure that the function does not modify the input list and that a new list is returned. - Optimize the implementation to minimize the number of passes through the list when possible.","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: Returns a new list with elements sorted in ascending order using the Bubble Sort algorithm. The original list is not modified. sorted_arr = arr[:] n = len(sorted_arr) # Perform Bubble Sort for i in range(n): # Track if a swap was made in this iteration swapped = False for j in range(0, n-i-1): if sorted_arr[j] > sorted_arr[j+1]: # swap the elements sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j] swapped = True # If no elements were swapped, the list is already sorted if not swapped: break return sorted_arr"},{"question":"# Sudoku Solver Given a partially filled 9x9 Sudoku grid, determine if the grid can be solved and return the completed grid. If the grid cannot be solved, return the original grid. Implement the function `def solve_sudoku(grid: List[List[int]]) -> List[List[int]]:` such that: Input * `grid`: A 2D list representing a 9x9 Sudoku grid where `grid[i][j]` is an integer between 0 and 9. A value of 0 represents an empty cell that needs to be filled. Output * A 2D list representing the completed Sudoku grid if solvable. If the grid cannot be solved, return the original grid. Constraints * `grid` is a 9x9 grid. * Initial grid values are valid according to Sudoku rules (no duplicates in rows, columns, or any 3x3 sub-grids). # Example Example 1 ```python grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] expected_solution = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] assert solve_sudoku(grid) == expected_solution ``` Example 2 ```python grid = [ [1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 5, 6, 7, 8, 9, 1, 2, 3], [7, 8, 9, 1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7, 8, 9, 1], [5, 6, 7, 8, 9, 1, 2, 3, 4], [8, 9, 1, 2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8, 9, 1, 2], [6, 7, 8, 9, 1, 2, 3, 4, 5], [9, 1, 2, 3, 4, 5, 6, 7, 0] ] expected_solution = [ [1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 5, 6, 7, 8, 9, 1, 2, 3], [7, 8, 9, 1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7, 8, 9, 1], [5, 6, 7, 8, 9, 1, 2, 3, 4], [8, 9, 1, 2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8, 9, 1, 2], [6, 7, 8, 9, 1, 2, 3, 4, 5], [9, 1, 2, 3, 4, 5, 6, 7, 8] ] assert solve_sudoku(grid) == expected_solution ``` Note * The input grid is guaranteed to have at least one solution. * You can assume there is only one correct solution per valid input grid.","solution":"from typing import List def solve_sudoku(grid: List[List[int]]) -> List[List[int]]: def is_valid(num, pos, grid): # Check row for col in range(9): if grid[pos[0]][col] == num and pos[1] != col: return False # Check column for row in range(9): if grid[row][pos[1]] == num and pos[0] != row: return False # Check box box_x = pos[1] // 3 box_y = pos[0] // 3 for i in range(box_y * 3, box_y * 3 + 3): for j in range(box_x * 3, box_x * 3 + 3): if grid[i][j] == num and (i, j) != pos: return False return True def find_empty(grid): for i in range(9): for j in range(9): if grid[i][j] == 0: return (i, j) # Row, Col return None def solve(): empty_pos = find_empty(grid) if not empty_pos: return True row, col = empty_pos for num in range(1, 10): if is_valid(num, (row, col), grid): grid[row][col] = num if solve(): return True grid[row][col] = 0 return False if solve(): return grid else: return grid"},{"question":"# Problem Statement You are tasked with implementing a simplified version of a social media networking feature. Specifically, you need to detect communities within an undirected graph representing a network of users and connections. Users are represented as nodes, and connections between them are edges. The goal is to implement the Depth-First Search (DFS) algorithm to discover all connected components in the graph, with and without recursion. # Function Signature ```python def dfs_recursive(graph: dict, start: int, visited: set = None) -> list[set]: pass def dfs_iterative(graph: dict, start: int) -> list[set]: pass ``` **Input Format**: - `graph` (dict): A dictionary where keys are user IDs and values are a list of connected user IDs representing the networking graph. - `start` (int): The user ID for the starting vertex of the DFS traversal. **Output Format**: - `dfs_recursive` should return a list of sets, each set representing a connected component in the graph where the algorithm started from the given vertex. - `dfs_iterative` should return a list of sets, each set representing a connected component in the graph where the algorithm started from the given vertex. **Constraints**: - Number of users n in the graph is in the range [1, 500]. - Number of connections m in the graph is in the range [0, 2,500]. # Example Usage ```python # Define the graph as a dictionary graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4], 6: [7], 7: [6] } # Compute communities using recursive DFS starting from vertex 1 communities_rec = dfs_recursive(graph, 1) print(communities_rec) # Output: [{1, 2, 3, 4, 5}] # Compute communities using iterative DFS starting from vertex 1 communities_iter = dfs_iterative(graph, 1) print(communities_iter) # Output: [{1, 2, 3, 4, 5}] ``` **Expected Output**: ``` [{1, 2, 3, 4, 5}] [{1, 2, 3, 4, 5}] ``` # Evaluation Criteria 1. Correctness: The solution should correctly detect all connected components for given graph inputs. 2. Efficiency: The solution should perform within acceptable time limits given the constraints. 3. Edge Handling: Solutions should adequately handle edge cases, including singular users, disconnected users, and dense networks. 4. Code Quality: The implementation should be clean, well-documented, and easy to understand. **Explanation**: In the given example, `dfs_recursive` and `dfs_iterative` functions should both identify the entire connected component starting from vertex 1, which includes vertices {1, 2, 3, 4, 5}, representing one connected community within the graph. The isolated component {6, 7} is not included because the DFS starts at vertex 1. However, extending the problem can include functionality to find all the disconnected components if needed.","solution":"def dfs_recursive(graph: dict, start: int, visited: set = None) -> set: Performs a DFS traversal recursively to find all nodes in the same connected component as start. :param graph: Dictionary representing the graph where keys are nodes and values are lists of connected nodes. :param start: The starting node for the DFS traversal. :param visited: Set of already visited nodes (used internally for recursion). :return: Set of nodes in the same connected component as the start node. if visited is None: visited = set() visited.add(start) for neighbor in graph.get(start, []): if neighbor not in visited: dfs_recursive(graph, neighbor, visited) return visited def dfs_iterative(graph: dict, start: int) -> set: Performs a DFS traversal iteratively to find all nodes in the same connected component as start. :param graph: Dictionary representing the graph where keys are nodes and values are lists of connected nodes. :param start: The starting node for the DFS traversal. :return: Set of nodes in the same connected component as the start node. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbor for neighbor in graph.get(node, []) if neighbor not in visited) return visited"},{"question":"Smallest Window Containing All Characters Given two strings `s` and `t`, find the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such window in `s` that covers all characters in `t`, return an empty string. # Function Specifications Your task is to implement the following function: - `min_window(s: str, t: str) -> str` # Input - `s`: A string representing the source. - `t`: A string representing the target characters you need to include in the window. # Output - Return the smallest substring in `s` that includes all characters in `t`. If no such substring exists, return an empty string. # Constraints * `1 <= len(s), len(t) <= 10^4` * Both `s` and `t` consist of uppercase and lowercase English letters. # Example ```python assert min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" assert min_window(\\"a\\", \\"a\\") == \\"a\\" assert min_window(\\"a\\", \\"aa\\") == \\"\\" assert min_window(\\"bba\\", \\"ab\\") == \\"ba\\" ``` # Note Your implementation should consider edge cases such as: 1. The target string `t` being longer than `s`. 2. The target string `t` containing characters not present in `s`. 3. The smallest possible window appearing at the start, middle or end of string `s`. The function should be optimized for potentially large input sizes up to the constraints provided.","solution":"def min_window(s: str, t: str) -> str: from collections import Counter, defaultdict if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] += 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"You are given a 2D grid representing a map of a battlefield. Each cell in the grid can either be empty (`0`), a wall (`1`), or a soldier (`2`). The soldiers can move horizontally or vertically onto empty cells. The objective is to determine the number of isolated soldier groups on the battlefield. **Task**: Write a function to identify and count the number of isolated groups of soldiers. Soldiers belong to the same group if they can reach each other by moving through empty cells. **Function Signature**: ```python def count_isolated_groups(grid: List[List[int]]) -> int: Args: grid : List[List[int]] : A 2D grid representing the battlefield map Returns: int : The number of isolated groups of soldiers ``` # Input * 2D list `grid` representing the battlefield map, where each element is either `0`, `1`, or `2`. * Constraints: 1 ≤ rows, cols ≤ 500 # Output * An integer representing the number of isolated groups of soldiers. # Example ```python grid = [ [0, 2, 0, 1], [1, 0, 2, 0], [2, 1, 0, 0], [0, 0, 1, 2] ] print(count_isolated_groups(grid)) # Output: 3 ``` # Explanation - There are three groups of soldiers in the grid: - Group 1: Located at (0,1). - Group 2: Connected soldiers at (1,2) and (0,2). - Group 3: Located at (3,3). Thus, there are 3 isolated groups of soldiers on the battlefield map. # Constraints * Optimize the algorithm to avoid excessive time and space complexities, given the constraint on grid size (1 ≤ rows, cols ≤ 500).","solution":"from typing import List def count_isolated_groups(grid: List[List[int]]) -> int: if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def inside_grid(r, c): return 0 <= r < rows and 0 <= c < cols def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if inside_grid(nx, ny) and not visited[nx][ny] and grid[nx][ny] == 2: visited[nx][ny] = True stack.append((nx, ny)) num_isolated_groups = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 2 and not visited[r][c]: num_isolated_groups += 1 visited[r][c] = True dfs(r, c) return num_isolated_groups"},{"question":"# Coding Assessment Question: Efficient Word Ladder Length Calculation Objective Demonstrate knowledge of graph traversal algorithms by implementing a function to determine the shortest transformation sequence from a start word to an end word, using a given set of allowed intermediate words. Task Description Given a `begin_word`, an `end_word`, and a list of `word_list`, implement a function to find the length of the shortest transformation sequence from `begin_word` to `end_word`. Each intermediate word must exist in the `word_list`, and only one letter can be changed at a time. Function Signature ```python def ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int: Compute the length of the shortest transformation sequence from `begin_word` to `end_word` using `word_list`. Input ===== - begin_word: The starting word for the transformation. - end_word: The target word for the transformation. - word_list: A list of allowed words for the transformation. Output ====== - length: The length of the shortest transformation sequence, or 0 if no such sequence exists. ``` Input and Output - **Input**: - `begin_word`: A string representing the start word. - `end_word`: A string representing the target word. - `word_list`: A list of strings where each string is a valid intermediate transformation. - **Output**: - `length`: Integer, the length of the shortest transformation sequence from `begin_word` to `end_word`. If no such sequence exists, return 0. Constraints - All input words (`begin_word`, `end_word`, and `words in word_list`) consist only of lowercase English letters. - The length of each word is the same. - There are no duplicate words in the word_list. - The length of word_list is at most 5000. Performance Requirements - The algorithm should handle the worst-case scenario where the word_list contains up to 5000 entries. Example ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] # Expected output: 5 -> The shortest transformation sequence is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\" length = ladder_length(begin_word, end_word, word_list) print(f\\"Length of shortest transformation sequence: {length}\\") ``` ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] # Expected output: 0 -> Since \\"cog\\" is not in the word_list length = ladder_length(begin_word, end_word, word_list) print(f\\"Length of shortest transformation sequence: {length}\\") ``` In the first example, the shortest transformation sequence leads to `end_word \\"cog\\"` within 5 words. In the second example, the `end_word \\"cog\\"` is not in the word_list, so no transformation sequence is possible.","solution":"from collections import deque def ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int: Compute the length of the shortest transformation sequence from `begin_word` to `end_word` using `word_list`. Args: - begin_word: The starting word for the transformation. - end_word: The target word for the transformation. - word_list: A list of allowed words for the transformation. Returns: - length: The length of the shortest transformation sequence, or 0 if no such sequence exists. if end_word not in word_list: return 0 word_set = set(word_list) queue = deque([(begin_word, 1)]) # each element in the queue is a tuple (current_word, current_length) while queue: current_word, current_length = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end_word: return current_length + 1 if next_word in word_set: word_set.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"# Coding Assessment Question: You are assigned to build a function that will aid a warehouse management system to optimize the storage space by distributing products across different bins. **Function Details**: * Write a function `distribute_products(weights: List[float], max_capacity: float) -> int` that determines the minimum number of bins required to store all products, such that the total weight in each bin does not exceed the specified maximum capacity. **Input**: * `weights` (List[float]): A list of weights of different products. Each weight must be greater than 0. * `max_capacity` (float): The maximum weight capacity of each bin. Must be greater than 0. **Output**: * A single integer representing the minimum number of bins required. **Constraints**: * Real-life constraints apply (e.g., precision errors are tolerated within reasonable limits). * The `weights` list will have at least one product. * The sum of weights will always be less than or equal to 1000 times the `max_capacity`. **Performance Requirements**: * The implementation must complete the computation in O(n log n) time complexity, where n is the number of products. **Scenario**: A warehouse receives products of varying weights daily. Proper bin allocation is crucial to maximize space usage and efficiency in retrieval operations. Automating the distribution of products into bins based on their weights and bin capacity helps streamline the inventory process. **Example Use Cases**: * `distribute_products([10.5, 5.3, 7.2, 15.6], 20.0)` should return `3`. * `distribute_products([9.0, 8.5, 2.4, 5.9, 6.3], 10.0)` should return `4`. **Edge Cases**: * Inputs like `distribute_products([], 10)` should raise an exception: `\\"Products list must not be empty\\"`. * Inputs like `distribute_products([10, -5, 3], 15)` should raise an exception: `\\"Weight of products must be > 0\\"`. * Inputs like `distribute_products([10, 5, 3], 0)` should raise an exception: `\\"Max capacity must be > 0\\"`.","solution":"from typing import List def distribute_products(weights: List[float], max_capacity: float) -> int: if not weights: raise ValueError(\\"Products list must not be empty\\") if max_capacity <= 0: raise ValueError(\\"Max capacity must be > 0\\") if any(weight <= 0 for weight in weights): raise ValueError(\\"Weight of products must be > 0\\") weights.sort(reverse=True) bins = 0 while weights: current_bin = 0 i = 0 while i < len(weights): if current_bin + weights[i] <= max_capacity: current_bin += weights[i] weights.pop(i) else: i += 1 bins += 1 return bins"},{"question":"# Question As a software engineer, you are tasked with analyzing log data to identify potential intrusions. Your goal is to implement a function that reads a list of log entries and identifies IP addresses that have made an unusually high number of requests within a given interval of time. # Requirements 1. **Function Name**: `detect_intrusion` 2. **Inputs**: - A list of strings `logs`, where each string represents a log entry in the format `\\"timestamp ip_address\\"`. The `timestamp` is a string in the format `\\"YYYY-MM-DD HH:MM:SS\\"`, and the `ip_address` is a string representing an IPv4 address. - An integer `threshold` representing the maximum number of allowed requests from a single IP within any given fifteen-minute window. 3. **Output**: - A list of strings representing the IP addresses that exceeded the request limit, sorted in ascending order. # Constraints - You can assume that the timestamps in the log entries are in chronological order. - Each log entry is unique, i.e., there are no duplicate entries in the given list. - The log entries list can be very large, so the solution should be optimized for performance. # Example ```python logs = [ \\"2023-10-01 12:00:00 192.168.1.1\\", \\"2023-10-01 12:05:00 192.168.1.1\\", \\"2023-10-01 12:05:30 192.168.1.1\\", \\"2023-10-01 12:05:45 192.168.1.2\\", \\"2023-10-01 12:10:00 192.168.1.1\\", \\"2023-10-01 12:10:15 192.168.1.1\\", \\"2023-10-01 12:20:00 192.168.1.3\\", \\"2023-10-01 12:25:00 192.168.1.3\\", \\"2023-10-01 12:30:00 192.168.1.3\\", ] threshold = 5 intrusion_ips = detect_intrusion(logs, threshold) print(intrusion_ips) # [\\"192.168.1.1\\"] ``` # Notes - Consider edge cases such as: - Logs with events happening exactly at the boundary of a 15-minute window. - Multiple IPs making requests at the exact same time. - Efficiently managing and searching the time intervals is crucial for performance. - Pay attention to the 15-minute window, which means any contiguous 15-minute period within the logs. # Implementation Hints - Parse the timestamps and convert them into a datetime object for easier manipulation. - Use sliding windows or similar techniques to efficiently count the number of requests within each 15-minute interval. - Utilize dictionaries or other appropriate data structures to tally the requests per IP.","solution":"from datetime import datetime, timedelta from collections import defaultdict def detect_intrusion(logs, threshold): Detects IP addresses that exceed the threshold of requests within any 15-minute window. Parameters: logs (list of str): List of log entries in the format \\"timestamp ip_address\\". threshold (int): The maximum number of allowed requests from a single IP within any 15-minute window. Returns: list of str: List of IP addresses that exceeded the request limit, sorted in ascending order. def parse_log(log): Parses a log entry. Parameters: log (str): Log entry in the format \\"timestamp ip_address\\". Returns: tuple: Parsed timestamp as datetime object and IP address as string. timestamp_str, ip_address = log.rsplit(\\" \\", 1) timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") return timestamp, ip_address ip_request_times = defaultdict(list) intrusion_ips = set() for log in logs: timestamp, ip_address = parse_log(log) ip_request_times[ip_address].append(timestamp) # Remove old requests outside the 15-minute sliding window while ip_request_times[ip_address] and timestamp - ip_request_times[ip_address][0] > timedelta(minutes=15): ip_request_times[ip_address].pop(0) if len(ip_request_times[ip_address]) > threshold: intrusion_ips.add(ip_address) return sorted(intrusion_ips)"},{"question":"Problem Statement You are required to implement a function that evaluates the quality of clustering when k-means clustering is applied to a given dataset. You need to compute the silhouette coefficient for each sample, and then return the average silhouette coefficient for all samples, which gives an idea of how well the clusters are structured. # Function to Implement ```python def calculate_silhouette_score(data, labels): Calculate the average silhouette score for the given clustered data. @param data: A 2D numpy array of shape (n_samples, n_features) containing the dataset. @param labels: A one-dimensional numpy array of length n_samples containing the cluster labels for each sample. @return: A float representing the average silhouette score of the clustered data. # Your code here pass ``` # Input and Output Formats Input - `data`: A two-dimensional numpy array of shape (n_samples, n_features) representing the dataset. - `labels`: A one-dimensional numpy array of length `n_samples` containing the cluster labels for each sample. Output - This function should return a float value representing the average silhouette score of the dataset. # Constraints - The `data` array should be at least 2x2 in dimensions. - The `labels` array should be of the same length as the number of samples in the `data` array. - The cluster labels in the `labels` array should be non-negative integers. # Example ```python # Example Input: data = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]]) labels = np.array([0, 0, 1, 1, 0, 1]) # Example Output: average_silhouette_score = calculate_silhouette_score(data, labels) print(average_silhouette_score) # Expected to print a float value representing the average silhouette score. ``` # Notes - The silhouette coefficient for a sample is a measure of how similar that sample is to its own cluster compared to other clusters. - The silhouette score is calculated for each sample, and the average of these scores gives the final silhouette score. - You can assume that the data has already been clustered using an appropriate algorithm like k-means. - A higher silhouette score indicates better-defined clusters. The score ranges between -1 and 1.","solution":"from sklearn.metrics import silhouette_score import numpy as np def calculate_silhouette_score(data, labels): Calculate the average silhouette score for the given clustered data. @param data: A 2D numpy array of shape (n_samples, n_features) containing the dataset. @param labels: A one-dimensional numpy array of length n_samples containing the cluster labels for each sample. @return: A float representing the average silhouette score of the clustered data. if len(data) < 2 or len(data) != len(labels): raise ValueError(\\"The data array should be at least 2x2 in dimensions and match the length of the labels array.\\") return silhouette_score(data, labels)"},{"question":"Task Question Creation for Coding Assessment New Question [Question #]: Optimize Route Cost between Cities # Context Consider a network of cities connected by bidirectional roads, where each road has an associated cost. You are given the list of connections and their costs. The task is to calculate the minimum cost to travel between two given cities using the available roads. If there is no possible route, return -1. # Task Implement a function `min_cost_route(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int` that computes the minimum cost to travel between two cities. # Input Format - `num_cities`: An integer ( n ) representing the number of cities. - `roads`: A list of tuples `(u, v, cost)` where `u` and `v` are the connected cities and `cost` is the cost of the road between them. - `start`: An integer representing the starting city. - `end`: An integer representing the destination city. # Output Format - Return an integer representing the minimum cost to travel from the `start` city to the `end` city. Return -1 if no route exists. # Function Signature ```python def min_cost_route(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: ``` # Constraints 1. ( 1 leq text{num_cities} leq 1000 ) 2. ( 0 leq text{cost} leq 10^6 ) 3. The roads list contains at most ( 2000 ) connections. 4. ( 0 leq text{u}, text{v} < text{num_cities} ) 5. The roads form a connected network of cities. # Example ```python # Given cities and roads, find the minimum cost from city 0 to city 3 num_cities = 4 roads = [(0, 1, 10), (1, 2, 10), (2, 3, 10), (0, 3, 50)] start = 0 end = 3 min_cost_route(num_cities, roads, start, end) -> 30 # No valid route exists between 0 and 2 num_cities = 3 roads = [(0, 1, 10), (1, 0, 10)] start = 0 end = 2 min_cost_route(num_cities, roads, start, end) -> -1 ``` # Notes - Consider using Dijkstra\'s algorithm or a priority queue to efficiently compute the minimum cost. - Ensure the function handles edge cases, such as no connecting roads between cities or attempting to start and end at the same city.","solution":"import heapq from typing import List, Tuple def min_cost_route(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: # Initialize adjacency list adj_list = [[] for _ in range(num_cities)] for u, v, cost in roads: adj_list[u].append((v, cost)) adj_list[v].append((u, cost)) # Initialize the priority queue and distances array pq = [(0, start)] # (cost, city) distances = [float(\'inf\')] * num_cities distances[start] = 0 while pq: current_cost, current_city = heapq.heappop(pq) if current_city == end: return current_cost for neighbor, weight in adj_list[current_city]: distance = current_cost + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1"},{"question":"# Problem Statement Implement a function to determine if two strings are one edit distance apart. Two strings are considered one edit distance apart if you can: 1. Insert exactly one character into one string to obtain the other string. 2. Delete exactly one character from one string to obtain the other string. 3. Replace exactly one character in one string with another character to obtain the other string. Your task is to write a function that checks whether the given two strings meet this condition. # Function Signature ```python def is_one_edit_distance(s: str, t: str) -> bool: Check if two strings s and t are one edit distance apart. Parameters: s (str): The first string. t (str): The second string. Returns: bool: True if the strings are one edit distance apart, False otherwise. Examples: >>> is_one_edit_distance(\\"abcdef\\", \\"abcdf\\") True >>> is_one_edit_distance(\\"teacher\\", \\"teaches\\") False >>> is_one_edit_distance(\\"intention\\", \\"invention\\") True >>> is_one_edit_distance(\\"pale\\", \\"ple\\") True >>> is_one_edit_distance(\\"pale\\", \\"bake\\") False >>> is_one_edit_distance(\\"\\", \\"a\\") True pass ``` # Constraints * The input strings will have a length of at most 10^4. # Expected Complexity * Ensure your solution runs in linear time O(n), where n is the length of the longer string. * Aim for a space complexity of O(1), i.e., constant space complexity. # Notes * Consider edge cases such as one or both strings being empty. * Test cases will check for correctness and efficiency. * Focus on optimizing the performance for large strings.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: Check if two strings s and t are one edit distance apart. if s == t: return False len_s, len_t = len(s), len(t) # If the length difference is more than 1, they cannot be one edit distance apart if abs(len_s - len_t) > 1: return False # Make sure s is the shorter string or same length as t if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s found_difference = False i, j = 0, 0 while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True if len_s == len_t: i += 1 # If replace we move both pointers else: i += 1 j += 1 # If we finished the loop normally, it means there was at most one edit return True"},{"question":"# Problem Statement Design a function to compute the first `n` terms in the Fibonacci sequence iteratively. The function should be optimized to handle large values of `n` efficiently and ensure constant space complexity. # Guidelines 1. **Function Signature**: ```python def fibonacci(n: int) -> List[int]: ``` 2. **Parameters**: - `n`: The number of terms in the Fibonacci sequence to generate. 3. **Returns**: - A list of the first `n` Fibonacci numbers. 4. **Constraints**: - If `n` is less than or equal to 0, return an empty list. - Handle special cases where `n` is 1 or 2. # Example ```python >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Notes - Optimize the function to use constant space (O(1) space complexity). - Ensure the function efficiently handles large values of `n`, avoiding common pitfalls of recursive implementations.","solution":"def fibonacci(n: int): Returns the first n terms of the Fibonacci sequence. if n <= 0: return [] if n == 1: return [0] if n == 2: return [0, 1] fib_seq = [0, 1] a, b = 0, 1 for _ in range(2, n): a, b = b, a + b fib_seq.append(b) return fib_seq"},{"question":"# Question: Implement a function to flatten a nested JSON object. The properties of the nested object should be concatenated in a dot notation. Function Signature: ```python def flatten_json(nested_json: dict) -> dict: ``` # Requirements: 1. Implement a function that takes a nested JSON object as input and returns a flattened JSON object. 2. Use dot notation to represent nested properties. 3. Ensure the function can handle varied levels of nesting. 4. Validate correctness using the provided test cases and create additional tests if necessary. # Expected input and output formats: - **Input**: A dictionary representing a nested JSON object. - **Output**: A dictionary representing the flattened JSON object. # Sample Test Cases: ```python nested_json_1 = { \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } }, \\"f\\": 4 } expected_output_1 = { \\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3, \\"f\\": 4 } assert flatten_json(nested_json_1) == expected_output_1 nested_json_2 = { \\"name\\": \\"John\\", \\"address\\": { \\"street\\": \\"123 Main St\\", \\"city\\": \\"Springfield\\", \\"coordinates\\": { \\"latitude\\": 40.7128, \\"longitude\\": 74.0060 } } } expected_output_2 = { \\"name\\": \\"John\\", \\"address.street\\": \\"123 Main St\\", \\"address.city\\": \\"Springfield\\", \\"address.coordinates.latitude\\": 40.7128, \\"address.coordinates.longitude\\": 74.0060 } assert flatten_json(nested_json_2) == expected_output_2 ``` # Additional Context: - Consider edge cases such as empty input or properties with non-dictionary values. - Implement a recursive approach to handle varying levels of nesting. - Aim for clarity and efficiency in your solution.","solution":"def flatten_json(nested_json, parent_key=\'\', separator=\'.\'): Flatten a nested JSON object. The nested keys will be concatenated using dot notation. Args: nested_json (dict): The dictionary to be flattened. parent_key (str): The base key for recursion, used to build up the concatenated key names. separator (str): The string used to separate keys. Returns: dict: The flattened dictionary. flattened = {} for key, value in nested_json.items(): new_key = f\\"{parent_key}{separator}{key}\\" if parent_key else key if isinstance(value, dict): flattened.update(flatten_json(value, new_key, separator)) else: flattened[new_key] = value return flattened"},{"question":"# Question: Image Compression using K-Means Clustering You are given an uncompressed RGB image that you need to compress using K-Means Clustering. Your task is to implement the K-Means algorithm to reduce the number of unique colors in the image to K colors. Task 1. Implement the K-Means algorithm to compress the image by reducing the color palette to K colors. 2. Create a class `KMeansImageCompressor` that includes methods for fitting the model and transforming the image. Input and Output * **Input**: A 3D NumPy array representing an RGB image and an integer K for the desired number of unique colors. * **Output**: A 3D NumPy array representing the compressed RGB image with K unique colors. Constraints 1. Ensure your implementation works efficiently for images up to 1024x1024 pixels. 2. Handle edge cases like K being greater than or equal to the number of unique original colors. 3. Validate your implementation with a set of test images to ensure the correctness and quality of compression. Example Scenario Consider an RGB image of size 200x200 with millions of colors. By setting K=16, you will reduce the image to have only 16 unique colors while maintaining the visual quality as much as possible. Implementation Complete the methods `fit`, `predict`, and `transform` in the `KMeansImageCompressor` class. Then provide a few test cases to verify your implementation. ```python import numpy as np from sklearn.cluster import KMeans class KMeansImageCompressor: def __init__(self, K: int): Initialize the KMeansImageCompressor with K colors. self.K = K self.kmeans = None def fit(self, image: np.ndarray) -> None: Fit the K-Means model to the image. # Reshape image to (num_pixels, 3) pixels = image.reshape(-1, 3) # Fit K-Means to the RGB values self.kmeans = KMeans(n_clusters=self.K, random_state=42).fit(pixels) def predict(self, image: np.ndarray) -> np.ndarray: Predict the closest cluster for each pixel. # Reshape image to (num_pixels, 3) pixels = image.reshape(-1, 3) return self.kmeans.predict(pixels) def transform(self, image: np.ndarray) -> np.ndarray: Transform the image to use only K colors. if self.kmeans is None: raise Exception(\\"Model is not fitted yet.\\") labels = self.predict(image) palette = self.kmeans.cluster_centers_ compressed_image = palette[labels].reshape(image.shape) return compressed_image.astype(np.uint8) # Example usage if __name__ == \\"__main__\\": image = np.random.randint(0, 256, size=(200, 200, 3), dtype=np.uint8) compressor = KMeansImageCompressor(K=16) compressor.fit(image) compressed_image = compressor.transform(image) # You can use a library like matplotlib to visualize the result: # import matplotlib.pyplot as plt # plt.imshow(compressed_image) # plt.show() ```","solution":"import numpy as np from sklearn.cluster import KMeans class KMeansImageCompressor: def __init__(self, K: int): Initialize the KMeansImageCompressor with K colors. self.K = K self.kmeans = None def fit(self, image: np.ndarray) -> None: Fit the K-Means model to the image. # Reshape image to (num_pixels, 3) pixels = image.reshape(-1, 3) # Fit K-Means to the RGB values self.kmeans = KMeans(n_clusters=self.K, random_state=42).fit(pixels) def predict(self, image: np.ndarray) -> np.ndarray: Predict the closest cluster for each pixel. # Reshape image to (num_pixels, 3) pixels = image.reshape(-1, 3) return self.kmeans.predict(pixels) def transform(self, image: np.ndarray) -> np.ndarray: Transform the image to use only K colors. if self.kmeans is None: raise Exception(\\"Model is not fitted yet.\\") labels = self.predict(image) palette = self.kmeans.cluster_centers_ compressed_image = palette[labels].reshape(image.shape) return compressed_image.astype(np.uint8)"},{"question":"# Scenario You are developing a software module for a company that processes and analyzes financial data. Your task is to write a function that classifies a list of transactions based on their type and calculates the sum of amounts for each transaction type. # Function Details Implement a function `classify_transactions` that takes one parameter: - `transactions` (list of tuples): Each tuple contains two elements - a string indicating the transaction type and a float representing the transaction amount. The function should return a dictionary where the keys are transaction types and values are the total amounts for those types. # Requirements - The function should handle an empty list by returning an empty dictionary. - If a transaction amount is negative, it should be subtracted from the respective transaction type total. - The transaction types are guaranteed to be strings, and amounts are guaranteed to be floats. - Ensure the sums of the amounts are accurate to two decimal places. # Input and Output - **Input**: - `transactions` (list of tuples): [(transaction_type: str, amount: float), ...] - **Output**: - Return a dictionary with transaction types as keys and the computed total amounts as values, with amounts rounded to two decimal places. # Constraints - Each transaction type (string) will be of length 1 to 50 characters. - Transaction amounts will be within the range of `-1e6` to `1e6`. # Example ```python # Example of a function call transactions = [(\\"deposit\\", 100.0), (\\"withdrawal\\", -50.0), (\\"deposit\\", 200.0), (\\"withdrawal\\", -75.0)] result = classify_transactions(transactions) print(result) # Expected output: {\'deposit\': 300.0, \'withdrawal\': -125.0} transactions = [] result = classify_transactions(transactions) print(result) # Expected output: {} ``` # Notes - Handle edge cases such as an empty list or when all transactions are of the same type. - Ensure the function is efficient and can handle large lists of transactions without significant performance degradation.","solution":"def classify_transactions(transactions): Classifies transactions based on their type and calculates the sum of amounts for each type. :param transactions: List of tuples, with each tuple containing a transaction type and an amount. :return: Dictionary with transaction types as keys and the total amounts as values. result = {} for transaction_type, amount in transactions: if transaction_type in result: result[transaction_type] += amount else: result[transaction_type] = amount # Round amounts to two decimal places result = {k: round(v, 2) for k, v in result.items()} return result"},{"question":"# Scenario You are a software engineer at a logistics company, and your current task is to develop a function that calculates the shortest route between two delivery points using the Manhattan Distance. The Manhattan Distance, sometimes called the \\"Taxicab Distance,\\" is the sum of the absolute differences of their Cartesian coordinates. # Function Details Implement a function `calculate_manhattan_distance` that takes four parameters: - `x1` (int): The x-coordinate of the first point. - `y1` (int): The y-coordinate of the first point. - `x2` (int): The x-coordinate of the second point. - `y2` (int): The y-coordinate of the second point. The function should compute the Manhattan Distance using the formula: [ D = |x2 - x1| + |y2 - y1| ] # Requirements - The function should raise a `ValueError` if any of the coordinates are not integers. - The result should be returned as an integer. # Input and Output - **Input**: - `x1` (int): X-coordinate of the first point. - `y1` (int): Y-coordinate of the first point. - `x2` (int): X-coordinate of the second point. - `y2` (int): Y-coordinate of the second point. - **Output**: - Return the computed Manhattan Distance as an integer. # Constraints - `-1e6 ≤ x1, y1, x2, y2 ≤ 1e6` (Coordinates can be very large or very small) # Example ```python # Example of a function call distance = calculate_manhattan_distance(5, 10, 15, 20) print(distance) # Expected output: 20 distance = calculate_manhattan_distance(-5, -10, 1, 5) print(distance) # Expected output: 21 ``` # Notes Handle edge cases such as when both points are the same or when coordinates have extreme values. Ensure the function is efficient and handles large inputs without unnecessary overhead.","solution":"def calculate_manhattan_distance(x1, y1, x2, y2): Computes the Manhattan Distance between two points (x1, y1) and (x2, y2). :param x1: int, x-coordinate of the first point :param y1: int, y-coordinate of the first point :param x2: int, x-coordinate of the second point :param y2: int, y-coordinate of the second point :return: int, the Manhattan Distance between the two points :raises: ValueError if any of the parameters are not integers if not all(isinstance(coord, int) for coord in [x1, y1, x2, y2]): raise ValueError(\\"All coordinates must be integers.\\") return abs(x2 - x1) + abs(y2 - y1)"},{"question":"# Problem: Validate and Complete a Circular Linked List You are given a partial implementation of a circular singly linked list in Python. Your task is to complete the `__init__` and `insert` methods to ensure the proper functionality of the circular linked list. A circular singly linked list is where the last node points back to the head, forming a circle. # Requirements 1. **Input**: - A list of integers to initialize the circular linked list. - An integer value to insert into the list. 2. **Output**: - The structure should maintain the circular nature of the list after any insertion. - A method to print the list starting from the head node up to the last node, ensuring that it demonstrates the circular nature by terminating appropriately. # Class Definition You need to complete the following class: ```python class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self, elements): # Initialize the circular linked list pass def insert(self, data): # Method to insert a node into the circular linked list pass def print_list(self): # Print the list starting from head to the last node pass ``` # Implementation Instructions 1. The `__init__` method should take a list of integers and create a circular linked list. 2. The `insert` method should accept an integer and insert it at the end of the list while maintaining the circular nature of the list. 3. The `print_list` method should print all elements in the list starting from the head node to the last node, demonstrating the circular nature by stopping once it loops back to the head. # Constraints - Your solution should handle edge cases, such as inserting into an empty circular linked list. - The insertion should be efficient and maintain the properties of the circular linked list. # Example ```python elements = [1, 2, 3, 4] cll = CircularLinkedList(elements) cll.insert(5) cll.print_list() ``` Output: ``` 1 -> 2 -> 3 -> 4 -> 5 -> (back to head) ``` # Notes 1. **Completeness**: Ensure the circular linked list is functional with insertions and initializes correctly from a list of elements. 2. **Circular Nature**: Demonstrate that the list is circular through the implementation of the print function.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self, elements): self.head = None # head points to the first node if elements: for element in elements: self.insert(element) def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node new_node.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head def print_list(self): nodes = [] if self.head: current = self.head while True: nodes.append(str(current.data)) current = current.next if current == self.head: break nodes.append(\\"(back to head)\\") print(\\" -> \\".join(nodes))"},{"question":"# Context You are tasked with developing a feature for a text processing application that needs to identify anagrams within a given list of words. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. # Task Implement a function `find_anagrams(word_list: List[str]) -> Dict[str, List[str]]` that finds and groups anagrams within the provided list of words. # Function Signature ```python def find_anagrams(word_list: List[str]) -> Dict[str, List[str]]: ``` # Input - **word_list**: A list of strings where each string is a word consisting of lowercase alphabetic characters. # Output - **result**: A dictionary where the keys are the \\"signature\\" of the anagram group (sorted character sequence of the words), and the values are lists of words that are anagrams of each other. # Constraints - The words in the input list will be lowercase alphabetic strings with lengths ranging from 1 to 100. - The number of words in the input list will not exceed 10^5. # Requirements - Ensure the function returns a dictionary even if there are no anagrams (an empty dictionary if no anagrams are found). - The words in the dictionary should be presented in the order they appear in the input list. # Performance - The solution should efficiently handle lists with up to 100,000 words. # Sample Input/Output Example 1 ```python word_list = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"abc\\", \\"bca\\", \\"cab\\", \\"hello\\"] output = find_anagrams(word_list) print(output) ``` Expected output: ```python { \\"eilnst\\": [\\"listen\\", \\"silent\\", \\"enlist\\"], \\"abc\\": [\\"abc\\", \\"bca\\", \\"cab\\"] } ``` Example 2 ```python word_list = [\\"abc\\", \\"def\\", \\"ghi\\"] output = find_anagrams(word_list) print(output) ``` Expected output: ```python {} ``` # Explanation For the first example, the words \\"listen\\", \\"silent\\", and \\"enlist\\" are anagrams of each other. Similarly, \\"abc\\", \\"bca\\", and \\"cab\\" are also anagrams. The function groups them accordingly in the output dictionary. The second example has no anagrams, thus the function returns an empty dictionary. # Notes - Sorting each word can help in creating a \\"signature\\" that uniquely identifies anagrams. - The words in each group should be in the same order they appear in the input list.","solution":"from collections import defaultdict from typing import List, Dict def find_anagrams(word_list: List[str]) -> Dict[str, List[str]]: anagrams = defaultdict(list) for word in word_list: # Create a signature by sorting the characters of the word signature = \'\'.join(sorted(word)) # Append the word to the list corresponding to the signature anagrams[signature].append(word) # Filter the dictionary to only include keys with more than one word result = {key: value for key, value in anagrams.items() if len(value) > 1} return result"},{"question":"# **Shortest Path in Weighted Graph** As a software engineer, you are tasked with implementing an algorithm to find the shortest path between two nodes in a directed, weighted graph. The company utilizes this algorithm to optimize various logistical operations, such as routing delivery trucks from their depots to customer locations. You are given a list of `edges` representing the directed, weighted graph. Each edge is defined by its source node, destination node, and weight. Your task is to implement the Dijkstra algorithm to compute the shortest path from a given `start_node` to a given `end_node`. **Function Signature**: ```python def shortest_path(edges: List[Tuple[str, str, int]], start_node: str, end_node: str) -> List[str]: pass ``` **Input**: * `edges`: A list of tuples, where each tuple represents an edge defined as `(source: str, destination: str, weight: int)`. * `start_node`: A string representing the starting node. * `end_node`: A string representing the destination node. **Output**: * A list of strings representing the sequence of nodes forming the shortest path from `start_node` to `end_node`. If no path exists, return an empty list. **Constraints**: * The graph will have at most `10^3` nodes and `10^4` edges. * The weights of the edges are non-negative integers. * You may assume well-formed input data without any cycles that form negative weight cycles. **Example**: ```python edges = [ (\'A\', \'B\', 4), (\'A\', \'C\', 2), (\'B\', \'C\', 5), (\'B\', \'D\', 10), (\'C\', \'E\', 3), (\'E\', \'D\', 4), (\'D\', \'F\', 11) ] start_node = \'A\' end_node = \'D\' result = shortest_path(edges, start_node, end_node) assert result == [\'A\', \'C\', \'E\', \'D\'] edges = [ (\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', 4) ] start_node = \'A\' end_node = \'C\' result = shortest_path(edges, start_node, end_node) assert result == [\'A\', \'B\', \'C\'] ``` **Note**: - Implement the Dijkstra algorithm using a priority queue for efficiency. - Consider edge cases such as disconnected graphs where no path exists between the nodes.","solution":"import heapq from typing import List, Tuple, Dict def shortest_path(edges: List[Tuple[str, str, int]], start_node: str, end_node: str) -> List[str]: graph = {} # Create the graph as an adjacency list for src, dst, weight in edges: if src not in graph: graph[src] = [] if dst not in graph: graph[dst] = [] graph[src].append((dst, weight)) # Priority queue for Dijkstra\'s algorithm queue = [(0, start_node, [])] # (current_distance, current_node, path_taken) visited = set() distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 while queue: current_distance, current_node, path = heapq.heappop(queue) if current_node in visited: continue path = path + [current_node] if current_node == end_node: return path visited.add(current_node) for neighbor, weight in graph[current_node]: if neighbor in visited: continue new_distance = current_distance + weight if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(queue, (new_distance, neighbor, path)) return []"},{"question":"# Context The concept of palindromes is commonly explored in computer science and mathematics. A string is called a palindrome if it reads the same backward as forward (e.g., \\"madam\\", \\"racecar\\"). This problem involves working with such palindromic structures in the context of chemical symbols. # Problem Statement You are required to implement a function `is_chemical_palindrome(symbol: str) -> bool` that determines whether a given chemical element\'s symbol is a palindrome. The input is a string representing the chemical symbol, and the function should return `True` if the symbol is a palindrome, and `False` otherwise. # Function Signature ```python def is_chemical_palindrome(symbol: str) -> bool: pass ``` # Input and Output * **Input**: - `symbol` (str): The chemical symbol to be checked. * **Output**: - `bool`: `True` if the symbol is a palindrome, `False` otherwise. # Constraints * The input string `symbol` will contain only uppercase alphabetic characters (A-Z). * The length of the symbol will be between 1 and 2 characters (since real chemical symbols range between 1 and 2 characters in length). # Performance Requirements The function should operate in constant time, O(1), since it deals with at most two characters. # Example ```python symbol1 = \\"H\\" print(is_chemical_palindrome(symbol1)) # Expected output: True symbol2 = \\"HH\\" print(is_chemical_palindrome(symbol2)) # Expected output: True symbol3 = \\"HE\\" print(is_chemical_palindrome(symbol3)) # Expected output: False symbol4 = \\"O\\" print(is_chemical_palindrome(symbol4)) # Expected output: True ``` # Implementation Notes 1. For one character symbols, the result is trivially True since any single character is a palindrome by definition. 2. For two character symbols, simply compare the first and second characters to determine if they are the same. 3. Consider input edge cases, such as an empty string (though this would violate the constraints). This question tests basic string manipulation and logical reasoning within the constrained context of chemical symbols, similar to how the previous question explored numerical vector operations.","solution":"def is_chemical_palindrome(symbol: str) -> bool: Determines whether a given chemical symbol is a palindrome. Parameters: symbol (str): The chemical symbol to be checked. Returns: bool: True if the symbol is a palindrome, False otherwise. return symbol == symbol[::-1]"},{"question":"# Problem Statement You are tasked with designing an efficient solution to find the shortest path in a weighted, undirected graph using Dijkstra\'s algorithm. This problem tests your understanding of graph traversal and shortest path algorithms. # Function to Implement Implement the function `dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int>` in Python, where: * `graph` is a dictionary where keys are nodes, and values are lists of tuples representing the neighboring nodes and the edge weights. * `start` is the integer representing the starting node for the shortest path search. # Input and Output * **Input**: A dictionary `graph` representing the graph structure and an integer `start` representing the starting node. * **Output**: A dictionary where keys are nodes, and values are the shortest distance from `start` to that node. # Constraints 1. The number of nodes in the graph will be between `1` and `10^4`. 2. The edge weights will be positive integers between `1` and `10^3`. 3. No edge weight will be zero. 4. The `start` node will be a valid node in the graph. # Examples ```python assert dijkstra({0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}, 0) == {0: 0, 1: 3, 2: 1, 3: 4} assert dijkstra({0: [(1, 1)], 1: [(0, 1), (2, 2)], 2: [(1, 2), (3, 1)], 3: [(2, 1)]}, 0) == {0: 0, 1: 1, 2: 3, 3: 4} assert dijkstra({0: [(1, 10), (2, 5)], 1: [(2, 2), (3, 15)], 2: [(1, 3), (3, 4)], 3: []}, 0) == {0: 0, 1: 8, 2: 5, 3: 9} assert dijkstra({0: [(1, 5)], 1: [(2, 5)], 2: [(3, 5)], 3: []}, 0) == {0: 0, 1: 5, 2: 10, 3: 15} assert dijkstra({0: [(1, 2)], 1: [(2, 2)], 2: [(0, 2)]}, 0) == {0: 0, 1: 2, 2: 4} ``` # Performance Requirements * Your solution should operate efficiently for large graphs, ensuring that the time complexity remains O(E log V), where E is the number of edges, and V is the number of vertices. * Ensure that the space complexity is also optimal, considering the size of the graph. # Additional Notes Consider edge cases such as: * Graphs with only one node. * Disconnected graphs where some nodes may not be reachable from `start`. * Handling very large graphs efficiently with priority queues to ensure optimal performance. Implement your function to handle all edge cases effectively.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Implements Dijkstra\'s algorithm to find the shortest path in a weighted, undirected graph. :param graph: Dictionary representing the graph where keys are nodes, and values are lists of tuples (neighbor, weight). :param start: The starting node. :return: Dictionary where keys are nodes and values are the shortest distance from the start node. # Initialize the distances with infinity, and set the distance to the start node to 0 shortest_distances = {node: float(\'inf\') for node in graph} shortest_distances[start] = 0 # Priority queue to process nodes based on their current shortest distance priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If this distance is greater than already found shortest distance, continue if current_distance > shortest_distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s shorter if distance < shortest_distances[neighbor]: shortest_distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_distances"},{"question":"# Fibonacci Subsequence Check You need to determine if a given list is a subsequence of the first `n` Fibonacci numbers. A subsequence means the numbers must appear in the same order but not necessarily consecutively. # Function Requirements You need to implement the function `is_fibonacci_subsequence(lst: list[int], n: int) -> bool` following these requirements: 1. **Input**: - `lst` (list[int]): A list of integers you need to check. - `n` (int): A positive integer defining the number of initial Fibonacci numbers to consider. 2. **Output**: - A boolean value indicating whether the given list is a subsequence of the first `n` Fibonacci numbers. # Steps: 1. **Fibonacci Generation**: - Generate the first `n` Fibonacci numbers, where the Fibonacci sequence starts with `0, 1`. 2. **Subsequence Check**: - Verify if the input list `lst` is a subsequence of the generated Fibonacci sequence. # Constraints: - The function should efficiently handle the input and sequence generation within reasonable execution time. - You should not use third-party libraries for sequence checks. # Example: ```python >>> is_fibonacci_subsequence([1, 2, 8], 12) True >>> is_fibonacci_subsequence([1, 4, 8], 10) False ``` # Explanation: - The first 12 Fibonacci numbers are `[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]`. - The list `[1, 2, 8]` is a subsequence of the above Fibonacci numbers. - The list `[1, 4, 8]` is not a subsequence of the first 10 Fibonacci numbers because `4` is not in the sequence. # Implementation: Write your solution as a function in Python. ```python def is_fibonacci_subsequence(lst: list[int], n: int) -> bool: # Generate the first n Fibonacci numbers def generate_fib_sequence(n): fib_sequence = [0, 1] for _ in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence[:n] fib_sequence = generate_fib_sequence(n) # Check if lst is a subsequence of fib_sequence it = iter(fib_sequence) return all(x in it for x in lst) ``` Provide accompanying explanations for critical parts and document any assumptions or constraints.","solution":"def is_fibonacci_subsequence(lst: list[int], n: int) -> bool: Function to check if `lst` is a subsequence of the first `n` Fibonacci numbers. Parameters: lst (list[int]): The list of integers to check. n (int): The number of initial Fibonacci numbers to consider. Returns: bool: True if `lst` is a subsequence of the first `n` Fibonacci numbers, False otherwise. def generate_fib_sequence(n): Helper function to generate the first `n` Fibonacci numbers. fib_sequence = [0, 1] for _ in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence[:n] fib_sequence = generate_fib_sequence(n) # Check if lst is a subsequence of fib_sequence it = iter(fib_sequence) return all(x in it for x in lst)"},{"question":"# Coding Assessment Question Context You are given an unsorted array of integers where each integer appears twice except for one integer which appears only once. Your objective is to find the integer that appears only once using bitwise operations. Task Write a function `find_single_number(nums) -> int` that returns the integer that appears only once in the array. Input Format * `nums`: A list of integers (e.g., `[4, 1, 2, 1, 2]`). The list contains at least 3 elements and no more than 10,000 elements. Output Format * Return a single integer representing the number that appears only once. Constraints * Each element in the list appears exactly twice except for one element which appears exactly once. * The list will always have one odd occurrence element. Example ```python nums = [4, 1, 2, 1, 2] print(find_single_number(nums)) # Output: 4 ``` Performance Requirements * The solution should run in linear time O(n) and use constant space O(1). Edge Cases to Consider * The list with a single unique element appearing in the middle. * The list where the unique element is the smallest or largest integer. * The list where all elements are large integers. Notes * Use bitwise XOR operation to solve the problem efficiently.","solution":"def find_single_number(nums): Finds the single number that appears only once in the list where all others appear twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Unique Combinations of Dice Rolls Context: In a board game, players often roll multiple dice to determine outcomes of their moves. Sometimes, only the unique combinations of dice results matter rather than the order of the rolls. Task: Write a function `unique_combinations(dice_count: int, sides: int) -> list[tuple]` that returns all unique combinations of outcomes when rolling the specified number of dice, where each die has the same number of sides. Input: * An integer `dice_count`, the number of dice to roll. * An integer `sides`, the number of sides each die has (ranging from 1 to `sides`). Output: * A list of tuples, each containing a unique combination of rolled outcomes. The tuples should be sorted in non-descending order, and the list of tuples should also be sorted lexicographically. Example: ```python def unique_combinations(dice_count: int, sides: int) -> list[tuple]: Example usage: >>> unique_combinations(2, 3) [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)] >>> unique_combinations(3, 2) [(1, 1, 1), (1, 1, 2), (1, 2, 2), (2, 2, 2)] ``` Constraints: * `1 <= dice_count <= 10` * `2 <= sides <= 6` **Edge Cases to consider**: * The minimal case with `dice_count = 1` and any number of sides should return tuples with single elements. * The maximal case with `dice_count = 10` and `sides = 6` should return all relevant unique combinations. Requirements: * Ensure your function correctly computes all unique combinations for all valid inputs. * The tuples should be sorted in non-descending order. * The overall list should be sorted lexicographically for consistency. This question should provide a consistent level of complexity and adhere to the focus of the existing questions on logical and combinatorial problem-solving within the scope of basic programming constructs like loops, conditionals, and data manipulation.","solution":"from itertools import combinations_with_replacement def unique_combinations(dice_count: int, sides: int) -> list[tuple]: Generates unique combinations of dice outcomes. Args: dice_count (int): The number of dice. sides (int): The number of sides on each die. Returns: list[tuple]: A list of tuples representing unique combinations. return list(combinations_with_replacement(range(1, sides + 1), dice_count))"},{"question":"**[Question 2]: Efficient Median Finding in a Data Stream** You are given a stream of integers that are being read sequentially. Your task is to design a data structure that efficiently supports the following two operations: adding a number to the stream and finding the median of all the numbers read so far. A median is the middle value in an ordered list of numbers. If the list is of even length, the median is the mean of the two middle values. # Function Signatures: ```python class MedianFinder: def __init__(self): pass def add_num(self, num: int) -> None: pass def find_median(self) -> float: pass ``` # Methods: - `add_num(num: int) -> None`: Adds the integer `num` to the data structure. - `find_median() -> float`: Returns the median of all integers added so far. # Constraints: - The data structure should support the operations efficiently even for large numbers of integers. - The operations will be called in any arbitrary order, often many times each. - All integers provided are within the range of `-10^5` to `10^5`. - You may assume that the `find_median` method is always called after at least one call to `add_num`. # Example: ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # returns 1.5 mf.add_num(3) print(mf.find_median()) # returns 2.0 ``` # Notes: - Make sure your implementation efficiently supports the two operations in terms of time complexity. - Consider using data structures like heaps to achieve optimal performance. - You might need to handle both the average of the middle values for even numbers of elements and the exact middle for odd numbers of elements.","solution":"import heapq class MedianFinder: def __init__(self): # Two heaps: one max heap for the left half and one min heap for the right half self.left_half = [] # max heap self.right_half = [] # min heap def add_num(self, num: int) -> None: # Adding the number into max heap (invert the number to simulate max heap behavior with min heap) heapq.heappush(self.left_half, -num) # Ensure the largest number in the max heap is less than the smallest number in the min heap if self.left_half and self.right_half and (-self.left_half[0] > self.right_half[0]): to_move = -heapq.heappop(self.left_half) heapq.heappush(self.right_half, to_move) # Balance the sizes of the heaps, ensuring that the max heap (left_half) can have at most one more element if len(self.left_half) > len(self.right_half) + 1: to_move = -heapq.heappop(self.left_half) heapq.heappush(self.right_half, to_move) elif len(self.right_half) > len(self.left_half): to_move = heapq.heappop(self.right_half) heapq.heappush(self.left_half, -to_move) def find_median(self) -> float: # Check the sizes of heaps and calculate median if len(self.left_half) > len(self.right_half): return -self.left_half[0] else: return (-self.left_half[0] + self.right_half[0]) / 2.0"},{"question":"# Problem Statement You need to implement a simple in-memory key-value store with support for basic operations such as setting, getting, and deleting keys, as well as some advanced features like handling expiration of keys and batch operations. # Requirements 1. **Class Definition**: Create a class called `KeyValueStore`. 2. **Methods**: - `__init__(self)`: Initializes the key-value store. - `set(self, key: str, value: T, expiration: int = None)`: Sets the value for a key, with an optional expiration time in seconds. - `get(self, key: str) -> T`: Retrieves the value of the given key. Returns `None` if the key does not exist or has expired. - `delete(self, key: str)`: Deletes the key from the store. - `clear_expired(self)`: Clears all expired keys from the store. - `set_batch(self, data: dict[str, T], expiration: int = None)`: Sets multiple keys and their values at once, with an optional expiration time for all keys. - `get_batch(self, keys: list[str]) -> dict[str, T]`: Retrieves the values for a list of keys. Only include keys that exist and haven\'t expired. 3. **Expiration Handling**: The values should automatically expire and become unavailable after the specified expiration time in seconds. 4. **Performance Requirements**: * Ensure `set`, `get`, and `delete` operations are optimized for performance. * The `clear_expired` method should efficiently remove expired keys. 5. **Error Handling**: Properly handle cases where keys do not exist. # Constraints - The key-value store should hold up to 1000 keys. - The input will always be well-formed and valid. - The expiration time, if given, will be a positive integer. # Input/Output Structure * **Input**: N/A (The input parameters will be method parameters) * **Output**: The methods will not return any values except for `get` and `get_batch`. # Example ```python # Example Usage kv_store = KeyValueStore() kv_store.set(\\"name\\", \\"Alice\\") kv_store.set(\\"age\\", 30) print(kv_store.get(\\"name\\")) # Output: Alice print(kv_store.get(\\"age\\")) # Output: 30 kv_store.delete(\\"age\\") print(kv_store.get(\\"age\\")) # Output: None kv_store.set_batch({\\"city\\": \\"Wonderland\\", \\"country\\": \\"Fiction\\"}, expiration=10) print(kv_store.get_batch([\\"name\\", \\"city\\", \\"country\\"])) # Output: {\'name\': \'Alice\', \'city\': \'Wonderland\', \'country\': \'Fiction\'} ```","solution":"import time class KeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value, expiration: int = None): expiration_time = time.time() + expiration if expiration else None self.store[key] = (value, expiration_time) def get(self, key: str): if key in self.store: value, expiration_time = self.store[key] if not expiration_time or expiration_time > time.time(): return value return None def delete(self, key: str): if key in self.store: del self.store[key] def clear_expired(self): current_time = time.time() self.store = {k: v for k, v in self.store.items() if not v[1] or v[1] > current_time} def set_batch(self, data: dict, expiration: int = None): expiration_time = time.time() + expiration if expiration else None for key, value in data.items(): self.store[key] = (value, expiration_time) def get_batch(self, keys: list): current_time = time.time() result = {} for key in keys: if key in self.store: value, expiration_time = self.store[key] if not expiration_time or expiration_time > current_time: result[key] = value return result"},{"question":"# Coding Assessment Question: **Context**: You are working on a text processing application that needs to identify and categorize unique keywords from a collection of articles. The keywords should be words or phrases that appear multiple times across different articles but only consider their first appearances in each article. **Task**: Write a Python function `unique_keywords` that takes a list of strings (where each string represents an article) and returns a list of keywords that appear in at least two different articles. The keywords should be sorted in alphabetical order. **Specifications**: * Function name: `unique_keywords` * Input: * A list of strings `articles` (1 <= len(articles) <= 100, each string length <= 1000) * Output: * A list of strings containing the unique keywords that appear in at least two different articles, sorted alphabetically. **Constraints**: * The function should ignore punctuation and be case insensitive. * Consider words only made of alphabetic characters as valid keywords. * Ensure efficient processing to handle the upper constraints smoothly. **Example**: ```python def unique_keywords(articles: [str]) -> [str]: Identify and return a list of unique keywords that appear in at least two different articles. Parameters: articles ([str]): A list of article texts. Returns: [str]: A sorted list of keywords appearing in at least two different articles. Examples: >>> unique_keywords([\\"This is a test article\\", \\"This is another test article\\", \\"Completely different text\\"]) [\'article\', \'is\', \'test\', \'this\'] >>> unique_keywords([\\"Hello world\\", \\"World of code\\", \\"Code and world\\"]) [\'code\', \'world\'] >>> unique_keywords([\\"Python programming\\", \\"Python in data science\\", \\"Data science with Python\\"]) [\'data\', \'python\', \'science\'] pass ``` **Notes**: * You may assume that words are separated by spaces. * Pay attention to edge cases such as different casing, punctuation, and varied article lengths. * Provide comprehensive tests to verify that the function works as expected across different scenarios. * Optimize for performance, especially considering the potential length of articles and the number of them.","solution":"import re from collections import defaultdict def unique_keywords(articles): Identify and return a list of unique keywords that appear in at least two different articles. Parameters: articles ([str]): A list of article texts. Returns: [str]: A sorted list of keywords appearing in at least two different articles. # Dictionary to store the appearances of keywords in different articles keyword_articles = defaultdict(set) for i, article in enumerate(articles): # Remove punctuation and make everything lowercase processed_article = re.sub(r\'W+\', \' \', article).lower() words = set(processed_article.split()) for word in words: keyword_articles[word].add(i) # Filter words that appear in at least two different articles unique_keywords_list = [word for word, indices in keyword_articles.items() if len(indices) > 1] # Return the sorted list of keywords return sorted(unique_keywords_list)"},{"question":"# Problem Statement You are given an integer array `nums` sorted in non-decreasing order, and an integer `target`. Write a function `search_range(nums: List[int], target: int) -> List[int]` that finds the starting and ending position of a given `target` in `nums`. If `target` is not found in `nums`, return `[-1, -1]`. # Function Signature ```python def search_range(nums: List[int], target: int) -> List[int]: ``` # Input * `nums`: A list of integers sorted in non-decreasing order. * `target`: An integer value to search for in the list. # Output * A list of two integers representing the starting and ending positions of the `target` in `nums`. If the `target` is not present, return `[-1, -1]`. # Constraints * `0 <= len(nums) <= 10^5` * `-10^9 <= nums[i] <= 10^9` * `-10^9 <= target <= 10^9` # Example * If `nums = [5, 7, 7, 8, 8, 10]` and `target = 8` Running the function should give: ```python print(search_range([5, 7, 7, 8, 8, 10], 8)) # Output: [3, 4] ``` * If `nums = [5, 7, 7, 8, 8, 10]` and `target = 6` Running the function should give: ```python print(search_range([5, 7, 7, 8, 8, 10], 6)) # Output: [-1, -1] ``` **Note**: Your implementation should have a time complexity of O(log n) due to the sorted nature of the array. Use binary search to achieve this. # Requirements * Use binary search to find the first and last occurrences of the `target`. * Efficiently handle edge cases such as an empty array or `target` not present in the array.","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_left(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid return left def find_right(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid return left left_index = find_left(nums, target) right_index = find_right(nums, target) - 1 if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"# Prompt You are tasked with implementing a function that determines if a target string can be constructed using a combination of strings from a given list, where each string from the list can be used only once. You should use a recursive approach to solve this problem. # Function Signature ```python def can_construct(target: str, word_bank: List[str]) -> bool: Given a target string and a list of word strings, determine if the target string can be constructed by concatenating elements of the word bank. Each element of the word bank can be used only once. :param target: The target string to be constructed. :param word_bank: List of available strings that can be used to construct the target string. :return: True if the target string can be constructed using the word bank, otherwise False. Example: >>> can_construct(\\"abcdef\\", [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"]) True >>> can_construct(\\"skateboard\\", [\\"bo\\", \\"rd\\", \\"ate\\", \\"t\\", \\"ska\\", \\"sk\\", \\"boar\\"]) False Constraints: * The target string and all strings in the word bank consist of lowercase English letters. * The length of the target string is at most 50 characters. * The length of each word in the word bank and the total number of words in the word bank are at most 50. * Performance needs to be considered, aim for an efficient solution. ```","solution":"from typing import List def can_construct(target: str, word_bank: List[str]) -> bool: Given a target string and a list of word strings, determine if the target string can be constructed by concatenating elements of the word bank. Each element of the word bank can be used only once. def can_construct_recurse(target, word_bank, memo): if target in memo: return memo[target] if target == \\"\\": return True for word in word_bank: if target.startswith(word): suffix = target[len(word):] if can_construct_recurse(suffix, word_bank, memo): memo[target] = True return True memo[target] = False return False memo = {} return can_construct_recurse(target, word_bank, memo)"},{"question":"# Problem Statement You are tasked with creating a program to simulate the execution of a queue in a ticketing system. Each ticket has a unique identifier (an integer) and the order in which they are processed is in the sequence they come in. You need to implement a queue with the following operations: 1. `enqueue(ticket_id: int)`: Adds a ticket to the back of the queue. 2. `dequeue()`: Removes and returns the ticket from the front of the queue. If the queue is empty, return `None`. 3. `peek()`: Returns the ticket at the front of the queue without removing it. If the queue is empty, return `None`. 4. `size()`: Returns the number of tickets currently in the queue. Implement a class `TicketQueue` that provides these functionalities. # Input/Output * **Methods**: - `enqueue(ticket_id: int) -> None` - `dequeue() -> Optional[int]` - `peek() -> Optional[int]` - `size() -> int` * **Constraints/Mentions**: - The queue should allow operations on an empty queue gracefully. - The queue can handle at most (10^6) operations. # Examples 1. **Example 1**: ```python queue = TicketQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.size()) # Output: 3 print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.size()) # Output: 2 ``` 2. **Example 2**: ```python queue = TicketQueue() print(queue.dequeue()) # Output: None queue.enqueue(4) queue.enqueue(5) print(queue.peek()) # Output: 4 print(queue.size()) # Output: 2 print(queue.dequeue()) # Output: 4 print(queue.dequeue()) # Output: 5 print(queue.dequeue()) # Output: None ``` Make sure to handle edge cases and write clean, efficient code. Validate your solution with the provided functional tests in your environment.","solution":"from typing import Optional from collections import deque class TicketQueue: def __init__(self): self.queue = deque() def enqueue(self, ticket_id: int) -> None: Adds a ticket to the back of the queue. self.queue.append(ticket_id) def dequeue(self) -> Optional[int]: Removes and returns the ticket from the front of the queue. If the queue is empty, return None. if len(self.queue) == 0: return None return self.queue.popleft() def peek(self) -> Optional[int]: Returns the ticket at the front of the queue without removing it. If the queue is empty, return None. if len(self.queue) == 0: return None return self.queue[0] def size(self) -> int: Returns the number of tickets currently in the queue. return len(self.queue)"},{"question":"# Problem Description: Frequent Words Counter You are required to implement a function that reads a very large text file and counts the frequency of each unique word. Given the memory constraints, you must use an efficient approach to gather and count the words, ensuring that the memory usage does not exceed a specified limit. # Requirements 1. **Function Implementation**: Write a function `count_frequent_words(input_file, output_file, mem_limit)` that computes the word frequencies in the given text file. 2. The function should: * Split the input file into manageable chunks based on the memory limit. * Count the frequency of each unique word in each chunk. * Aggregate the counts from all chunks and write the result to the output file. 3. Ensure your solution can handle the following: * Very large files that cannot fit into memory. * Different line terminators. * Edge cases where files may be empty or contain only one word. 4. **Input/Output**: * `input_file`: Path to the input text file. * `output_file`: Path where the word frequency results should be saved in the format `word: frequency`. * `mem_limit`: The maximum amount of memory (in bytes) the program is allowed to use. # Constraints * Memory limit, `mem_limit <= 1GB`. * Line lengths in the input file will not exceed 1MB. * Text files will contain only ASCII characters. * Words are defined as alphanumeric sequences separated by non-alphanumeric characters. # Example ```python def count_frequent_words(input_file, output_file, mem_limit): # Your code goes here pass # Example usage count_frequent_words(\\"input.txt\\", \\"output.txt\\", 104857600) # 100 MB memory limit ``` Implement the function while considering performance and memory constraints. You may use helper classes or functions as necessary.","solution":"import os import re from collections import defaultdict def count_frequent_words(input_file, output_file, mem_limit): # Helper function to process chunks of file def process_chunk(chunk): word_count = defaultdict(int) words = re.findall(r\'bw+b\', chunk) for word in words: word_count[word.lower()] += 1 return word_count # Step 1: Initialize counts dictionary and setup chunk reading word_counts = defaultdict(int) chunk_size = min(mem_limit // 10, 2**20) # Read chunks in units up to 1 MB, adjusted for memory limit with open(input_file, \'r\', encoding=\'utf-8\') as file: while True: chunk = file.read(chunk_size) if not chunk: break word_counts_chunk = process_chunk(chunk) for word, count in word_counts_chunk.items(): word_counts[word] += count # Step 2: Write the aggregated word counts to output file with open(output_file, \'w\', encoding=\'utf-8\') as file: for word, count in sorted(word_counts.items()): file.write(f\'{word}: {count}n\')"},{"question":"# Parsing and Evaluating Mathematical Expressions Scenario You are required to write a program that can parse and evaluate simple mathematical expressions containing addition, subtraction, multiplication, and division. The expressions will be provided as strings and may include positive or negative decimal numbers, parentheses, and whitespace characters. Requirements Implement the `ExpressionEvaluator` class with the following methods: 1. **`__init__(self)`**: Initialize the evaluator. 2. **`parse_expression(self, expression)`**: Parse the given mathematical expression from the string format and convert it into a format that can be easily evaluated (e.g., an abstract syntax tree or another suitable structure). 3. **`evaluate_expression(self, parsed_expression)`**: Evaluate the parsed mathematical expression and return the result. Input and Output Format - **Input**: A string representing a mathematical expression. The input may contain parentheses for grouping and whitespace which should be ignored. - **Output**: A decimal number representing the evaluation result of the expression. Constraints - The input string is guaranteed to be a valid mathematical expression. - Handles addition `+`, subtraction `-`, multiplication `*`, and division `/`. - Supports nested parentheses without limitation on the depth. - Handles whitespaces appropriately (ignore them). Function Signature ```python class ExpressionEvaluator: def __init__(self): pass def parse_expression(self, expression: str): pass def evaluate_expression(self, parsed_expression) -> float: pass def evaluate_math_expression(expression: str) -> float: pass ``` Example ```python evaluator = ExpressionEvaluator() parsed_expr = evaluator.parse_expression(\\"3 + (2 - 5) * 6 / 3\\") result = evaluator.evaluate_expression(parsed_expr) print(result) # Output: -1.0 parsed_expr = evaluator.parse_expression(\\"10 + 2 * (6 / 3) - 5\\") result = evaluator.evaluate_expression(parsed_expr) print(result) # Output: 9.0 parsed_expr = evaluator.parse_expression(\\"(1 + 2) * (3 - 4) / 2\\") result = evaluator.evaluate_expression(parsed_expr) print(result) # Output: -1.5 ``` Implement the `ExpressionEvaluator` class and ensure it handles all edge cases and adheres to the constraints given in the analysis.","solution":"import ast import operator class ExpressionEvaluator: def __init__(self): self.operators = { ast.Add: operator.add, ast.Sub: operator.sub, ast.Mult: operator.mul, ast.Div: operator.truediv } def parse_expression(self, expression: str): Parses the mathematical expression into an AST (Abstract Syntax Tree). # Remove whitespaces expression = expression.replace(\\" \\", \\"\\") return ast.parse(expression, mode=\'eval\').body def evaluate_expression(self, node): Evaluates the given AST node recursively. if isinstance(node, ast.Num): # <number> return node.n elif isinstance(node, ast.BinOp): # <left> <operator> <right> left = self.evaluate_expression(node.left) right = self.evaluate_expression(node.right) op = self.operators[type(node.op)] return op(left, right) elif isinstance(node, ast.UnaryOp): # - <operand> operand = self.evaluate_expression(node.operand) if isinstance(node.op, ast.UAdd): return +operand elif isinstance(node.op, ast.USub): return -operand else: raise TypeError(node) def evaluate_math_expression(expression: str) -> float: evaluator = ExpressionEvaluator() parsed_expr = evaluator.parse_expression(expression) return evaluator.evaluate_expression(parsed_expr)"},{"question":"# Coding Question: Fibonacci Sequence Up to N Write a Python function to generate a list of Fibonacci numbers up to a given integer `n`. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. Your Task Implement the function `generate_fibonacci_up_to_n(n: int) -> list[int]` that follows these rules: 1. The function accepts one parameter: * `n` (int): The inclusive upper limit for the numbers in the Fibonacci sequence. 2. Returns a list containing the Fibonacci sequence up to and including the value `n`. 3. If `n` is less than 0, return an empty list. Example Usage ```python assert generate_fibonacci_up_to_n(10) == [0, 1, 1, 2, 3, 5, 8] assert generate_fibonacci_up_to_n(89) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] assert generate_fibonacci_up_to_n(0) == [0] assert generate_fibonacci_up_to_n(-5) == [] assert generate_fibonacci_up_to_n(1) == [0, 1, 1] ``` Constraints * `-10^3 <= n <= 10^3` Performance Requirements * Aim for an efficient solution with O(k) time complexity, where `k` is the number of Fibonacci numbers less than or equal to `n`. * Ensure correctness and handle edge cases properly. # Notes * The function should account for negative values of `n` by returning an empty list. * Handle edge cases such as `n` being zero or in the Fibonacci sequence to ensure correct output.","solution":"def generate_fibonacci_up_to_n(n: int) -> list[int]: Generates a list of Fibonacci numbers up to and including the given integer n. Parameters: n (int): The inclusive upper limit for the numbers in the Fibonacci sequence. Returns: list[int]: A list containing the Fibonacci sequence up to and including n. if n < 0: return [] fibonacci_sequence = [0, 1] while True: next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] if next_fib > n: break fibonacci_sequence.append(next_fib) # Special case when n is 0, include only [0] if n == 0: return [0] return fibonacci_sequence"},{"question":"# Scenario: You are creating a library management system that includes a functionality to parse and analyze book catalog data. Each book entry contains its title, author, publication year, and genre. The system needs to analyze this information and generate a summary report of the book collection. # Task: Implement a function `generate_report(catalog: List[Dict[str, str]]) -> Dict[str, Any]` that processes a list of book entries and returns a summary report. The report should include: - Total number of books - A dictionary with the number of books per genre - The oldest and newest publication years # Input: - `catalog` (List[Dict[str, str]]): A list of dictionary entries where each dictionary represents a book with the following keys - \'title\', \'author\', \'publication_year\', and \'genre\'. # Output: - `Dict[str, Any]`: A dictionary containing the summary report with keys - \'total_books\', \'books_per_genre\', \'oldest_publication_year\', and \'newest_publication_year\'. # Constraints: - Each dictionary entry must contain all four keys. - Values for \'publication_year\' are valid integers. # Example: ```plaintext Input: [ {\'title\': \'Book One\', \'author\': \'Author A\', \'publication_year\': \'2001\', \'genre\': \'Fiction\'}, {\'title\': \'Book Two\', \'author\': \'Author B\', \'publication_year\': \'1995\', \'genre\': \'Science\'}, {\'title\': \'Book Three\', \'author\': \'Author A\', \'publication_year\': \'2010\', \'genre\': \'Fiction\'}, {\'title\': \'Book Four\', \'author\': \'Author C\', \'publication_year\': \'1980\', \'genre\': \'History\'}, {\'title\': \'Book Five\', \'author\': \'Author D\', \'publication_year\': \'2015\', \'genre\': \'Science\'} ] Output: { \'total_books\': 5, \'books_per_genre\': {\'Fiction\': 2, \'Science\': 2, \'History\': 1}, \'oldest_publication_year\': 1980, \'newest_publication_year\': 2015 } ```","solution":"from typing import List, Dict, Any def generate_report(catalog: List[Dict[str, str]]) -> Dict[str, Any]: Generates a summary report from the book catalog. Parameters: catalog (List[Dict[str, str]]): A list of dictionary entries where each dictionary represents a book with keys \'title\', \'author\', \'publication_year\', and \'genre\'. Returns: Dict[str, Any]: A dictionary containing the summary report with keys - \'total_books\', \'books_per_genre\', \'oldest_publication_year\', and \'newest_publication_year\'. total_books = len(catalog) books_per_genre = {} oldest_publication_year = float(\'inf\') newest_publication_year = float(\'-inf\') for book in catalog: genre = book[\'genre\'] publication_year = int(book[\'publication_year\']) if genre in books_per_genre: books_per_genre[genre] += 1 else: books_per_genre[genre] = 1 if publication_year < oldest_publication_year: oldest_publication_year = publication_year if publication_year > newest_publication_year: newest_publication_year = publication_year return { \'total_books\': total_books, \'books_per_genre\': books_per_genre, \'oldest_publication_year\': oldest_publication_year, \'newest_publication_year\': newest_publication_year }"},{"question":"# Coding Assessment Question Scenario: Assume you are designing an algorithm to manage a warehouse inventory system. Each item in the warehouse has a unique identifier and a fixed number of units. You need to implement a system to handle inventory updates and queries efficiently. Task: Write a class `InventorySystem` that provides the following functionalities: 1. `__init__(self)`: Initializes an empty inventory. 2. `add_item(self, item_id: str, count: int)`: Adds the specified number of units of the item to the inventory. If the item does not exist, it adds a new entry. 3. `remove_item(self, item_id: str, count: int) -> bool`: Removes the specified number of units of the item from the inventory. If the item does not exist or there are not enough units, it returns `False`; otherwise, it returns `True`. 4. `get_inventory(self) -> Dict[str, int]`: Returns the current inventory as a dictionary where keys are item identifiers and values are the number of units. Example: ```python inventory = InventorySystem() inventory.add_item(\\"item1\\", 10) inventory.add_item(\\"item2\\", 5) print(inventory.get_inventory()) # Output: {\'item1\': 10, \'item2\': 5} result = inventory.remove_item(\\"item1\\", 3) print(result) # Output: True print(inventory.get_inventory()) # Output: {\'item1\': 7, \'item2\': 5} result = inventory.remove_item(\\"item2\\", 10) print(result) # Output: False print(inventory.get_inventory()) # Output: {\'item1\': 7, \'item2\': 5} ``` Constraints: - The item identifiers are unique strings. - The number of units is a non-negative integer. - There can be up to 50,000 operations (add, remove, get inventory) in total. # Performance Requirements: - The algorithm should handle all operations efficiently within a combined time complexity of O(1) per add and remove operation. Note: - Ensure to handle edge cases, such as removing from an empty inventory or querying an inventory with no items. - The class should be capable of managing high volumes of transactions and provide accurate inventory status at all times.","solution":"class InventorySystem: def __init__(self): self.inventory = {} def add_item(self, item_id: str, count: int): if item_id in self.inventory: self.inventory[item_id] += count else: self.inventory[item_id] = count def remove_item(self, item_id: str, count: int) -> bool: if item_id not in self.inventory or self.inventory[item_id] < count: return False self.inventory[item_id] -= count if self.inventory[item_id] == 0: del self.inventory[item_id] return True def get_inventory(self) -> dict: return self.inventory.copy()"},{"question":"**Problem Statement**: Implement a basic text editor with the following capabilities: adding and deleting text, selecting text, and copying and pasting text to and from the clipboard. # Features to Implement: 1. **Add Text**: - Method: `add_text(new_text: str) -> None` - Description: Adds the specified `new_text` to the end of the document. 2. **Delete Text**: - Method: `delete_text(count: int) -> str` - Description: Deletes the last `count` characters from the document and returns the deleted text. If `count` is greater than the current document length, delete all text. 3. **Select Text**: - Method: `select_text(start: int, end: int) -> str` - Description: Selects text from `start` index to `end` index (inclusive of start, exclusive of end) and returns the selected text. If the specified range is invalid or out of bounds, raise a `ValueError`. 4. **Copy Selected Text**: - Method: `copy_selected_text() -> None` - Description: Copies the currently selected text to a clipboard variable. If no text is selected, raise a `ValueError`. 5. **Paste Text**: - Method: `paste_text() -> None` - Description: Pastes the text currently in the clipboard to the end of the document. If the clipboard is empty, do nothing. 6. **Clear Document**: - Method: `clear_document() -> None` - Description: Clears all content from the document. # Constraints: - You can assume that any string provided to the methods will be non-empty and valid. - Ensure operations are efficient, especially when handling large text inputs. # Example: ```python # Example Usage editor = TextEditor() editor.add_text(\\"Hello\\") editor.add_text(\\" World!\\") assert editor.delete_text(1) == \\"!\\" assert editor.select_text(0, 5) == \\"Hello\\" editor.copy_selected_text() editor.paste_text() assert editor.delete_text(6) == \\"Hello \\" editor.clear_document() assert editor.select_text(0, 1) == \\"\\" # This should raise a ValueError ``` Implement the `TextEditor` class following the above description and ensuring your implementation passes all necessary edge cases.","solution":"class TextEditor: def __init__(self): self.document = \\"\\" self.clipboard = \\"\\" self.selected_text = \\"\\" def add_text(self, new_text: str) -> None: self.document += new_text def delete_text(self, count: int) -> str: if count > len(self.document): count = len(self.document) deleted_text = self.document[-count:] self.document = self.document[:-count] return deleted_text def select_text(self, start: int, end: int) -> str: if start < 0 or end > len(self.document) or start >= end: raise ValueError(\\"Invalid selection range\\") self.selected_text = self.document[start:end] return self.selected_text def copy_selected_text(self) -> None: if not self.selected_text: raise ValueError(\\"No text selected to copy\\") self.clipboard = self.selected_text def paste_text(self) -> None: if self.clipboard: self.document += self.clipboard def clear_document(self) -> None: self.document = \\"\\" self.clipboard = \\"\\" self.selected_text = \\"\\""},{"question":"# Question: Path Count in Grid with Obstacles You are given a 2D grid where some cells contain obstacles. Write a function `count_paths` that calculates the number of unique paths from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. An obstacle means breaking the path, and no movement is allowed through a cell with an obstacle. Input: - A list of lists `grid` representing the 2D grid where each element is either a 0 (empty cell) or 1 (obstacle). Constraints: - The grid will have at least one and at most 100 rows (`1 <= rows <= 100`). - The grid will have at least one and at most 100 columns (`1 <= cols <= 100`). - The top-left and bottom-right cells will always be empty (0). Output: - An integer representing the number of unique paths from the top-left to the bottom-right corner. Example: ```python def count_paths(grid: list[list[int]]) -> int: pass # Example Usage # There is only one path in this grid: right, right, down, down print(count_paths([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ])) # should return 2 # There are no paths in this grid because the obstacle blocks the way print(count_paths([ [0, 1], [1, 0] ])) # should return 0 ``` You are required to utilize dynamic programming to solve this problem efficiently. Verify your solution using sufficient test cases to affirm correctness, considering edge cases and performance.","solution":"def count_paths(grid): if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = 1 # Fill the first row and first column for r in range(1, rows): if grid[r][0] == 0: dp[r][0] = dp[r-1][0] else: # obstacle dp[r][0] = 0 for c in range(1, cols): if grid[0][c] == 0: dp[0][c] = dp[0][c-1] else: # obstacle dp[0][c] = 0 for r in range(1, rows): for c in range(1, cols): if grid[r][c] == 0: dp[r][c] = dp[r-1][c] + dp[r][c-1] else: # obstacle dp[r][c] = 0 return dp[-1][-1]"},{"question":"# Coding Assessment Question You are tasked with creating an efficient algorithm to determine the k-th smallest element in a sorted matrix. The matrix is sorted in non-decreasing order both row-wise and column-wise. **Scenario**: Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, create a function to find the k-th smallest element. **Function Signature**: ```python def kthSmallest(matrix: List[List[int]], k: int) -> int: pass ``` **Input**: - `matrix`: a list of lists of integers, representing the n x n matrix that is sorted both row-wise and column-wise. - `k` (1 <= k <= n^2): an integer representing the position of the desired element if the entire matrix was flattened and sorted. **Output**: - Returns a single integer which is the k-th smallest element in the matrix. **Constraints**: - Ensure your algorithm is optimized for performance, particularly for matrices up to `300 x 300`. - Aim for an approach that has a logarithmic or polynomial time complexity rather than a brute force solution. **Examples**: ```python assert kthSmallest([ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], 8) == 13 assert kthSmallest([ [1, 2], [1, 3] ], 2) == 1 assert kthSmallest([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 5) == 5 ``` **Notes**: - Take into consideration edge cases such as duplicate numbers and small values of k and n. - Make use of binary search or a min-heap to maintain efficiency. - Document your code thoroughly to ensure clarity and maintainability. Happy Coding!","solution":"import heapq from typing import List def kthSmallest(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a sorted matrix. The matrix is sorted in non-decreasing order both row-wise and column-wise. Parameters: matrix (List[List[int]]): The n x n matrix containing sorted integers. k (int): The k-th position in the sorted order to retrieve. Returns: int: The k-th smallest element in the matrix. n = len(matrix) min_heap = [] # Insert the first element of each row in the heap for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times while k > 0: element, r, c = heapq.heappop(min_heap) if c < n - 1: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"# Sorting by Custom Criteria Challenge Background In many applications, there is a need to sort data based on custom criteria rather than natural order. For example, sorting items based on multiple attributes in a specific order. This task will explore sorting a collection of strings that incorporate numeric and alphabetical segments. Problem Statement Write a function `custom_sort` that sorts a list of strings based on a custom criteria: it should primarily sort by the numeric value embedded in each string and secondarily by the alphabetic value. Each string in the list is guaranteed to contain exactly one numeric substring followed by exactly one alphabetical substring. ```python def custom_sort(strings: list) -> list: Sorts a list of strings based on embedded numeric and alphabetical segments. Examples: >>> custom_sort([\\"10apple\\", \\"2banana\\", \\"1cherry\\", \\"22date\\", \\"2apricot\\"]) [\'1cherry\', \'2apricot\', \'2banana\', \'10apple\', \'22date\'] >>> custom_sort([\\"30cat\\", \\"2dog\\", \\"10bird\\", \\"2antelope\\"]) [\'2antelope\', \'2dog\', \'10bird\', \'30cat\'] >>> custom_sort([]) [] >>> custom_sort([\\"1alpha\\", \\"2beta\\"]) [\'1alpha\', \'2beta\'] pass ``` # Input - `strings` (list): A list of alphanumeric strings. Each string is structured such that it contains exactly one numeric segment followed by exactly one alphabetical segment. # Output - `list`: A list of strings sorted based on the criteria defined above. # Constraints - The list may contain between 0 and 10^5 strings. - Each string is non-empty and contains exactly one numeric segment followed by exactly one alphabetical segment. - The numeric segment will be at the start and will be positive with no leading zeros. - The alphabetical segment is non-empty and will consist of lowercase alphabets only. # Requirements - Implement efficient sorting capable of handling up to the upper input limit. - Follow Pythonic principles and avoid reinventing the wheel where the language\'s built-in capabilities suffice. - Thoroughly test edge cases, such as strings with the same numeric values but different alphabetical segments. # Testing Assume a standard testing framework like `doctest`, and create comprehensive tests to validate your implementation. Good luck, and happy coding!","solution":"def custom_sort(strings: list) -> list: Sorts a list of strings based on embedded numeric and alphabetical segments. Examples: >>> custom_sort([\\"10apple\\", \\"2banana\\", \\"1cherry\\", \\"22date\\", \\"2apricot\\"]) [\'1cherry\', \'2apricot\', \'2banana\', \'10apple\', \'22date\'] >>> custom_sort([\\"30cat\\", \\"2dog\\", \\"10bird\\", \\"2antelope\\"]) [\'2antelope\', \'2dog\', \'10bird\', \'30cat\'] >>> custom_sort([]) [] >>> custom_sort([\\"1alpha\\", \\"2beta\\"]) [\'1alpha\', \'2beta\'] def extract_parts(s): # Find the position where the numeric part ends and the alphabetic part starts for i, char in enumerate(s): if char.isalpha(): break numeric_part = int(s[:i]) # Convert the numeric part to an integer alphabetic_part = s[i:] # Remainder is the alphabetic part return numeric_part, alphabetic_part return sorted(strings, key=extract_parts)"},{"question":"# Coding Question: Implement a Real-Time Rate Limiter Using a Sliding Window **Scenario**: You are required to implement a rate limiter that can track and limit the number of events (e.g., API requests) that occur within a specified time frame. This is essential for preventing abuse and ensuring fair usage of resources. **Given**: A sliding window mechanism should be used to count the number of events in the last `T` seconds. The system should efficiently handle a large number of events and quickly determine if a new event should be allowed or rejected based on the maximum allowed events within the time window. **Instructions**: 1. Implement the `RateLimiter` class with the following methods: - `__init__(self, T: int, max_events: int)`: Initialize the rate limiter with the time window `T` (in seconds) and the maximum number of allowed events `max_events` within that window. - `shouldAllowEvent(self, timestamp: int) -> bool`: Takes a timestamp (in seconds) and returns `True` if the event should be allowed, or `False` if it should be rejected based on the rate limiting rules. 2. Use a queue or deque as part of your sliding window implementation to efficiently manage the timestamps of the events. **Constraints**: - You can assume that timestamps are non-negative integers. - The `shouldAllowEvent` method is called with strictly increasing timestamps. - The maximum number of events and the time window will fit in memory. - Your solution should handle a high volume of `shouldAllowEvent` calls efficiently. **Example**: ```python rl = RateLimiter(60, 5) # Allow up to 5 events per 60 seconds print(rl.shouldAllowEvent(1)) # Output: True print(rl.shouldAllowEvent(10)) # Output: True print(rl.shouldAllowEvent(20)) # Output: True print(rl.shouldAllowEvent(30)) # Output: True print(rl.shouldAllowEvent(40)) # Output: True print(rl.shouldAllowEvent(50)) # Output: False (6th event within 60 seconds) print(rl.shouldAllowEvent(70)) # Output: True (1st event falls out of the 60s window) ``` **Required Classes and Methods** (Interface): ```python from collections import deque class RateLimiter: def __init__(self, T: int, max_events: int): # Initialize necessary data structures with time window T and max events allowed. self.T = T self.max_events = max_events self.events = deque() def shouldAllowEvent(self, timestamp: int) -> bool: # Check if the event at the given timestamp should be allowed or rejected. # Maintain the sliding window of event timestamps within self.T seconds. ``` Please ensure your implementation manages the sliding window efficiently for optimal performance.","solution":"from collections import deque class RateLimiter: def __init__(self, T: int, max_events: int): Initialize the rate limiter with the time window T (in seconds) and the maximum number of allowed events max_events within that window. self.T = T self.max_events = max_events self.events = deque() def shouldAllowEvent(self, timestamp: int) -> bool: Takes a timestamp (in seconds) and returns True if the event should be allowed, or False if it should be rejected based on the rate limiting rules. # Remove events that are outside the window of T seconds while self.events and self.events[0] <= timestamp - self.T: self.events.popleft() if len(self.events) < self.max_events: self.events.append(timestamp) return True return False"},{"question":"Binary Tree Traversal Binary trees are a fundamental data structure used in various computer science applications. One common task is traversing the tree in a specific order to retrieve or operate on the nodes\' values. In this task, we will focus on implementing different types of binary tree traversals: pre-order, in-order, and post-order. # Task Write a class `BinaryTree` that represents a binary tree and includes methods for pre-order, in-order, and post-order traversal. Each traversal method should return a list of the node values in the order they were visited. # Class Signature ```python class BinaryTree: def __init__(self, value: int): self.value = value self.left = None self.right = None def insert_left(self, value: int) -> \'BinaryTree\': pass def insert_right(self, value: int) -> \'BinaryTree\': pass def pre_order(self) -> list: pass def in_order(self) -> list: pass def post_order(self) -> list: pass ``` # Input * `value`: Integer value for the binary tree node. * For `insert_left` and `insert_right` methods, an integer value that should become the left or right child of the node, respectively. # Output * `pre_order`: Returns a list of integers representing the tree values in pre-order (Root, Left, Right). * `in_order`: Returns a list of integers representing the tree values in in-order (Left, Root, Right). * `post_order`: Returns a list of integers representing the tree values in post-order (Left, Right, Root). # Example ```python # Example 1 t = BinaryTree(1) t.insert_left(2) t.insert_right(3) t.left.insert_left(4) t.left.insert_right(5) t.right.insert_left(6) t.right.insert_right(7) print(t.pre_order()) # Expected output: [1, 2, 4, 5, 3, 6, 7] print(t.in_order()) # Expected output: [4, 2, 5, 1, 6, 3, 7] print(t.post_order()) # Expected output: [4, 5, 2, 6, 7, 3, 1] # Example 2 t2 = BinaryTree(10) t2.insert_left(5) t2.insert_right(15) t2.left.insert_right(7) print(t2.pre_order()) # Expected output: [10, 5, 7, 15] print(t2.in_order()) # Expected output: [5, 7, 10, 15] print(t2.post_order()) # Expected output: [7, 5, 15, 10] ``` # Constraints * The values given will be integers. * The tree structure will be a valid binary tree according to the insertions performed. # Notes * Ensure each traversal method (pre-order, in-order, post-order) is implemented recursively. * The root value of the tree is set at initialization, and child nodes are added using `insert_left` and `insert_right` methods. * You may add additional helper methods within the class to facilitate the traversals. # Testing Your Class Test the `BinaryTree` class with various tree configurations to ensure accurate traversal outputs. Some test cases are provided in the `doctest` format. ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() t = BinaryTree(1) t.insert_left(2) t.insert_right(3) t.left.insert_left(4) t.left.insert_right(5) t.right.insert_left(6) t.right.insert_right(7) print(t.pre_order()) # Expected: [1, 2, 4, 5, 3, 6, 7] print(t.in_order()) # Expected: [4, 2, 5, 1, 6, 3, 7] print(t.post_order()) # Expected: [4, 5, 2, 6, 7, 3, 1] ```","solution":"class BinaryTree: def __init__(self, value: int): self.value = value self.left = None self.right = None def insert_left(self, value: int) -> \'BinaryTree\': self.left = BinaryTree(value) return self.left def insert_right(self, value: int) -> \'BinaryTree\': self.right = BinaryTree(value) return self.right def pre_order(self) -> list: result = [] self._pre_order_traversal(self, result) return result def _pre_order_traversal(self, node, result): if node: result.append(node.value) self._pre_order_traversal(node.left, result) self._pre_order_traversal(node.right, result) def in_order(self) -> list: result = [] self._in_order_traversal(self, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result) def post_order(self) -> list: result = [] self._post_order_traversal(self, result) return result def _post_order_traversal(self, node, result): if node: self._post_order_traversal(node.left, result) self._post_order_traversal(node.right, result) result.append(node.value)"},{"question":"# Task You are given a class to represent a directed, weighted graph. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given source node to all other nodes in the graph. # Function Signature ```python class Graph: def __init__(self, vertices: int): Initialize the graph with a specified number of vertices. Parameters: vertices (int): Number of vertices in the graph. self.V = vertices self.graph = defaultdict(list) # adjacency list representation def add_edge(self, u: int, v: int, w: int) -> None: Add an edge to the graph. Parameters: u (int): Starting vertex of the edge. v (int): Ending vertex of the edge. w (int): Weight of the edge. Example Usage: >>> g.add_edge(0, 1, 2) def dijkstra(self, src: int) -> List[int]: Implement Dijkstra\'s algorithm to find the shortest paths from a given source to all vertices. Parameters: src (int): The source vertex. Returns: A list of distances where the value at index i represents the shortest distance from the source to vertex i. Example Usage: >>> g = Graph(5) >>> g.add_edge(0, 1, 9) >>> g.add_edge(0, 2, 6) >>> g.add_edge(0, 3, 5) >>> g.add_edge(0, 4, 3) >>> g.add_edge(2, 1, 2) >>> g.add_edge(2, 3, 4) >>> g.dijkstra(0) [0, 8, 6, 5, 3] pass ``` # Specifications 1. Implement the `dijkstra` method to compute the shortest paths from the source vertex to all other vertices using Dijkstra\'s algorithm. 2. The method should return a list of distances. 3. The graph uses adjacency list representation. # Input - **src**: An integer representing the starting vertex. # Output - A list of integers where each element represents the shortest distance from the source vertex to the corresponding vertex in the graph. # Example 1. Create a graph with 5 vertices: ```python g = Graph(5) ``` 2. Add edges to the graph: ```python g.add_edge(0, 1, 9) g.add_edge(0, 2, 6) g.add_edge(0, 3, 5) g.add_edge(0, 4, 3) g.add_edge(2, 1, 2) g.add_edge(2, 3, 4) ``` 3. Find shortest paths from vertex 0: ```python assert g.dijkstra(0) == [0, 8, 6, 5, 3] ``` # Constraints - The graph does not contain negative weight edges. - Vertices and weights are non-negative integers. - The number of vertices, `V`, in the graph can be up to 1000. - The weight `w` of an edge can be up to 10^5.","solution":"import heapq from collections import defaultdict from typing import List class Graph: def __init__(self, vertices: int): Initialize the graph with a specified number of vertices. self.V = vertices self.graph = defaultdict(list) # adjacency list representation def add_edge(self, u: int, v: int, w: int) -> None: Add an edge to the graph. self.graph[u].append((v, w)) def dijkstra(self, src: int) -> List[int]: Implement Dijkstra\'s algorithm to find the shortest paths from a given source to all vertices. distances = [float(\'inf\')] * self.V distances[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Problem Statement # Context You are developing a module for processing 2D matrices, which is frequently used for numerical computations and image processing tasks. One fundamental operation is rotating a matrix by 90 degrees clockwise. This operation is crucial in various applications, such as graphical transformations and data organization. # Task Write a function `rotate_matrix` to rotate a given n x n matrix by 90 degrees clockwise. The function should modify the matrix in place. # Requirements 1. The function should be named `rotate_matrix`. 2. The function should take one parameter: - `matrix` (list[list[int]]): A square matrix (n x n) of integers. 3. The function should modify the matrix in place and should not return any value. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` # Constraints * The size of the matrix `n` will be between 1 and 100, inclusive. * Each element in the matrix will be an integer in the range -10^4 to 10^4. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Notes Your implementation should be efficient and capable of handling large matrices within the given constraints.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Problem Statement **Insufficient Power Supply** In power engineering, often you may come across scenarios where you have to calculate whether the available power supply is enough for a given load over a period. Given certain parameters, calculate the missing one using the power formula. # Functions and Formulas The power required **( P )** in kilowatts (kW) to maintain a certain energy consumption over a period can be expressed as: [ P = frac{E}{t} ] Where: - **( E )** is the energy consumption in kilowatt-hours (kWh). - **( t )** is the time period in hours (h). # Input Your function should take three arguments: 1. **power** (`float`): Power in kilowatts (kW) (set to zero if unknown). 2. **energy** (`float`): Energy consumption in kilowatt-hours (kWh) (set to zero if unknown). 3. **time** (`float`): Time period in hours (h) (set to zero if unknown). # Output A dictionary containing the missing parameter with key: value pair. # Constraints * Exactly one of the power, energy, or time must be set to zero to compute its value based on the others. * The provided values must be greater than or equal to zero, except for the parameter to be calculated, which must be zero. * If more than one or none of the parameter values are zero, raise a ValueError with the message \\"One and only one argument must be 0\\". * If any provided value is negative, raise a ValueError with an appropriate message indicating the invalid parameter. # Examples ```python # Example 1: print(insufficient_power_supply(power=0, energy=50, time=10)) # Output: {\'power\': 5.0} # Example 2: print(insufficient_power_supply(power=2, energy=0, time=4)) # Output: {\'energy\': 8.0} # Example 3: print(insufficient_power_supply(power=2.5, energy=7.5, time=0)) # Output: {\'time\': 3.0} # Error cases: # More than one zero argument print(insufficient_power_supply(power=0, energy=0, time=5)) # Output: ValueError: One and only one argument must be 0 # Negative energy print(insufficient_power_supply(power=3, energy=-7, time=2)) # Output: ValueError: Energy consumption can not be negative # Negative time print(insufficient_power_supply(power=3, energy=7, time=-2)) # Output: ValueError: Time period can not be negative ``` # Submission Implement your solution in the function `insufficient_power_supply`. Ensure it handles the given constraints and edge cases effectively.","solution":"def insufficient_power_supply(power, energy, time): This function computes the missing value among power, energy, and time using the formula P = E / t, where: - power (P) is in kilowatts (kW) - energy (E) is in kilowatt-hours (kWh) - time (t) is in hours (h) Exactly one of the arguments must be zero, since that will be the value to compute. If more than one, or none, of the arguments are zero, the function raises a ValueError. Args: power (float): Power in kilowatts (kW) (set to zero if unknown). energy (float): Energy consumption in kilowatt-hours (kWh) (set to zero if unknown). time (float): Time period in hours (h) (set to zero if unknown). Returns: dict: A dictionary containing the name of the computed value and its result. Raises: ValueError: If more than one or none of the arguments are zero, or if any non-zero argument is negative. # Check if all values are valid if any([val < 0 for val in [power, energy, time]]): if power < 0: raise ValueError(\\"Power can not be negative\\") if energy < 0: raise ValueError(\\"Energy consumption can not be negative\\") if time < 0: raise ValueError(\\"Time period can not be negative\\") # Check the number of zeros zero_count = sum([1 for val in [power, energy, time] if val == 0]) if zero_count != 1: raise ValueError(\\"One and only one argument must be 0\\") # Calculate the missing value if power == 0: power = energy / time return {\'power\': power} elif energy == 0: energy = power * time return {\'energy\': energy} elif time == 0: time = energy / power return {\'time\': time}"},{"question":"# Problem Statement Implement the following operations of an AVL Tree using the provided `AVLTree` class template. An AVL Tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. 1. **Insert**: The method, `insert`, should add a new key to the AVL Tree while maintaining its balancing property. 2. **Delete**: The method, `delete`, should remove a key from the AVL Tree while maintaining its balancing property. 3. **Find**: The method, `find`, should return a boolean indicating whether a key exists in the AVL Tree. 4. **In-Order Traversal**: The method, `in_order_traversal`, should return the keys of the AVL Tree in ascending order. Input Format - For initialization, you will not be provided any input explicitly. Instead, the `insert` method will be called with keys to build the initial tree. Output Format - A list of keys after each traversal or a boolean for the find operation. Constraints - Each key will be a unique integer. - Each key integer will be in the range of -10^9 to 10^9. Functions to Implement ```python class AVLTree: def __init__(self): pass def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def find(self, key: int) -> bool: pass def in_order_traversal(self) -> List[int]: pass ``` Example ```python tree = AVLTree() tree.insert(20) tree.insert(40) tree.insert(50) tree.insert(10) tree.insert(30) print(tree.in_order_traversal()) # Output: [10, 20, 30, 40, 50] print(tree.find(30)) # Output: True print(tree.find(5)) # Output: False tree.delete(20) tree.delete(50) print(tree.in_order_traversal()) # Output: [10, 30, 40] ``` Note: The actual sequence of keys may vary depending on intermediate balancing operations performed by the AVL Tree.","solution":"class AVLTree: class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None def __init__(self): self.root = None def insert(self, key: int) -> None: if not self.root: self.root = self.TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return self.TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key: int) -> None: if self.root: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def find(self, key: int) -> bool: return self._find(self.root, key) def _find(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) return self._find(node.right, key) def in_order_traversal(self): result = [] self._in_order(self.root, result) return result def _in_order(self, node, result): if node: self._in_order(node.left, result) result.append(node.key) self._in_order(node.right, result) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) elif balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_min_value_node(self, node): while node.left: node = node.left return node"},{"question":"# Employee Age Validator You are given a partially implemented class named `Employee` that includes a method to set the employee\'s age. Your task is to complete this method to ensure that the age is within a valid range. Class Definition ```python class Employee: def __init__(self, name: str, age: int): self.name = name self.set_age(age) def set_age(self, age: int): # Your implementation here ``` Method: `set_age` * Parameters: * **age** (int): The age of the employee. * Returns: * No return value. # Constraints 1. Age must be a positive integer. 2. Age should be in the range 18 to 65 inclusive. 3. If the age is outside the valid range, the function should raise a `ValueError` with an appropriate message. Examples ```python >>> emp = Employee(\\"Alice\\", 30) >>> emp.name \'Alice\' >>> emp.age 30 >>> emp.set_age(40) >>> emp.age 40 >>> emp.set_age(16) Traceback (most recent call last): ... ValueError: Age must be between 18 and 65. >>> emp.set_age(68) Traceback (most recent call last): ... ValueError: Age must be between 18 and 65. ``` Additional Notes * Ensure the `ValueError` raised contains the message \\"Age must be between 18 and 65.\\" * The age attribute should be accessible as `emp.age`. Complete the `set_age` method in the `Employee` class according to the provided specifications.","solution":"class Employee: def __init__(self, name: str, age: int): self.name = name self.set_age(age) def set_age(self, age: int): if not (18 <= age <= 65): raise ValueError(\\"Age must be between 18 and 65.\\") self.age = age"},{"question":"# Question: Anagram Grouping and Counting Objective Implement a solution to group a list of words by their anagram groups and return the count of unique anagram groups in the list. Task 1. **Implement a function, `group_anagrams(words: List[str]) -> List[List[str]]`,** that groups a list of words into anagram groups. 2. **Implement a function, `count_unique_anagram_groups(words: List[str]) -> int`,** that returns the count of unique anagram groups from the provided list of words using the `group_anagrams` function. Function Signatures ```python def group_anagrams(words: List[str]) -> List[List[str]]: # Group words into anagram groups pass def count_unique_anagram_groups(words: List[str]) -> int: # Return the count of unique anagram groups pass ``` Expected Input and Output - **Input**: A list of strings `words` (list of words where each word consists of lowercase English letters). - **Output**: A list of anagram groups and the count of unique anagram groups. Constraints - 1 ≤ len(words) ≤ 10000 - 1 ≤ len(words[i]) ≤ 100 Example ```python >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> count_unique_anagram_groups([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) 3 ``` Explanation - For the words `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, the anagram groups are `[\'eat\', \'tea\', \'ate\']`, `[\'tan\', \'nat\']`, and `[\'bat\']`. - The count of unique anagram groups is `3`.","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups a list of words into anagram groups. :param words: List of words :return: List of anagram groups anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values()) def count_unique_anagram_groups(words: List[str]) -> int: Counts the number of unique anagram groups from the provided list of words. :param words: List of words :return: Count of unique anagram groups anagram_groups = group_anagrams(words) return len(anagram_groups)"},{"question":"# Question: Customizable Dataframe Filter Objective: As part of a data analysis tool, you are tasked with implementing a customizable dataframe filtering functionality. The implementation should allow for dynamic filtering based on various criteria specified by the user. Part 1: Implementing the Filters 1. **Function: `filter_based_on_column_value`** * Filter a dataframe based on a specific column and a value condition. ```python import pandas as pd def filter_based_on_column_value(df: pd.DataFrame, column: str, value) -> pd.DataFrame: Filter dataframe based on a specific column and a value condition. Parameters: df (pd.DataFrame): The dataframe to filter. column (str): The column name to apply the filter on. value: The value to filter the column by. Returns: pd.DataFrame: Filtered dataframe. pass # Your implementation ``` 2. **Function: `filter_based_on_value_range`** * Filter a dataframe based on a range of values for a specific column. ```python import pandas as pd def filter_based_on_value_range(df: pd.DataFrame, column: str, min_value, max_value) -> pd.DataFrame: Filter dataframe based on a range of values for a specific column. Parameters: df (pd.DataFrame): The dataframe to filter. column (str): The column name to apply the filter on. min_value: The minimum value of the range. max_value: The maximum value of the range. Returns: pd.DataFrame: Filtered dataframe. pass # Your implementation ``` Part 2: Aggregating Filters 3. **Function: `apply_multiple_filters`** * Apply multiple filtration criteria to the dataframe. ```python import pandas as pd def apply_multiple_filters(df: pd.DataFrame, filters: dict) -> pd.DataFrame: Apply multiple filtration criteria to the dataframe. Parameters: df (pd.DataFrame): The dataframe to filter. filters (dict): Dictionary containing columns and their respective filter functions and values. Example: {\'column1\': (\'value_match\', \'some_value\'), \'column2\': (\'range\', (min_val, max_val))} Returns: pd.DataFrame: Filtered dataframe. pass # Your implementation ``` Constraints & Requirements: * Filtration should be efficient even for large datasets. * Ensure appropriate error handling for invalid column names or filter conditions. * Filters should support numerical, categorical, and date types. * Make use of pandas library for dataframe operations. Example: ```python import pandas as pd # Example Dataframe data = { \'Name\': [\'Alice\', \'Bob\', \'Charlie\', \'David\'], \'Age\': [24, 30, 22, 27], \'Salary\': [50000, 60000, 45000, 70000] } df = pd.DataFrame(data) # Applying filters filtered_df_1 = filter_based_on_column_value(df, \'Name\', \'Alice\') filtered_df_2 = filter_based_on_value_range(df, \'Age\', 25, 35) combined_filters = apply_multiple_filters(df, {\'Name\': (\'value_match\', \'Alice\'), \'Age\': (\'range\', (20, 25))}) print(filtered_df_1) # Example Output: # Name Age Salary # 0 Alice 24 50000 print(filtered_df_2) # Example Output: # Name Age Salary # 1 Bob 30 60000 # 3 David 27 70000 print(combined_filters) # Example Output: # Name Age Salary # 0 Alice 24 50000 ``` Ensure your implementation covers edge cases, performs efficiently, and meets all specified criteria for customizable dataframe filtering.","solution":"import pandas as pd def filter_based_on_column_value(df: pd.DataFrame, column: str, value) -> pd.DataFrame: Filter dataframe based on a specific column and a value condition. Parameters: df (pd.DataFrame): The dataframe to filter. column (str): The column name to apply the filter on. value: The value to filter the column by. Returns: pd.DataFrame: Filtered dataframe. if column not in df.columns: raise ValueError(f\\"Column {column} does not exist in the dataframe.\\") return df[df[column] == value] def filter_based_on_value_range(df: pd.DataFrame, column: str, min_value, max_value) -> pd.DataFrame: Filter dataframe based on a range of values for a specific column. Parameters: df (pd.DataFrame): The dataframe to filter. column (str): The column name to apply the filter on. min_value: The minimum value of the range. max_value: The maximum value of the range. Returns: pd.DataFrame: Filtered dataframe. if column not in df.columns: raise ValueError(f\\"Column {column} does not exist in the dataframe.\\") return df[(df[column] >= min_value) & (df[column] <= max_value)] def apply_multiple_filters(df: pd.DataFrame, filters: dict) -> pd.DataFrame: Apply multiple filtration criteria to the dataframe. Parameters: df (pd.DataFrame): The dataframe to filter. filters (dict): Dictionary containing columns and their respective filter functions and values. Example: {\'column1\': (\'value_match\', \'some_value\'), \'column2\': (\'range\', (min_val, max_val))} Returns: pd.DataFrame: Filtered dataframe. filtered_df = df.copy() for column, (filter_type, filter_value) in filters.items(): if filter_type == \'value_match\': filtered_df = filter_based_on_column_value(filtered_df, column, filter_value) elif filter_type == \'range\': min_value, max_value = filter_value filtered_df = filter_based_on_value_range(filtered_df, column, min_value, max_value) else: raise ValueError(f\\"Unsupported filter type: {filter_type}\\") return filtered_df"},{"question":"# Problem Statement Create a function named `sequence_statistics` that processes a sequence of numbers and provides statistical insights about the sequence. # Requirements 1. **Compute Mean**: - Compute the arithmetic mean of the sequence. 2. **Compute Median**: - Compute the median of the sequence. If the sequence has an odd length, the median is the middle element. If the sequence has an even length, the median is the average of the two middle elements. 3. **Compute Mode**: - Compute the mode of the sequence. The mode is the element that appears most frequently. If multiple elements have the same highest frequency, return a list of these elements. 4. **Compute Standard Deviation**: - Compute the population standard deviation of the sequence. # Input Format - A list of integers representing the sequence. # Output Format - A dictionary with four key-value pairs: - `\\"mean\\"`: the arithmetic mean of the sequence. - `\\"median\\"`: the median of the sequence. - `\\"mode\\"`: a list of the most frequent elements. - `\\"std_dev\\"`: the population standard deviation. # Constraints - The length of the sequence is at least 1. - The elements of the sequence are integers. # Example ```python sequence = [1, 2, 2, 3, 4] result = sequence_statistics(sequence) print(result) # Output: # { # \\"mean\\": 2.4, # \\"median\\": 2, # \\"mode\\": [2], # \\"std_dev\\": 1.019803902718557 # } ``` # Boilerplate Code ```python from typing import List, Dict, Union import math from statistics import mean, median def sequence_statistics(sequence: List[int]) -> Dict[str, Union[float, List[int]]]: def calculate_mean(seq: List[int]) -> float: return mean(seq) def calculate_median(seq: List[int]) -> Union[float, int]: return median(seq) def calculate_mode(seq: List[int]) -> List[int]: frequency = {} for num in seq: frequency[num] = frequency.get(num, 0) + 1 max_frequency = max(frequency.values()) mode = [key for key, value in frequency.entries() if value == max_frequency] return mode def calculate_standard_deviation(seq: List[int]) -> float: mu = mean(seq) variance = mean([(x - mu) ** 2 for x in seq]) return math.sqrt(variance) return { \\"mean\\": calculate_mean(sequence), \\"median\\": calculate_median(sequence), \\"mode\\": calculate_mode(sequence), \\"std_dev\\": calculate_standard_deviation(sequence) } ```","solution":"from typing import List, Dict, Union import math from statistics import mean, median, mode def sequence_statistics(sequence: List[int]) -> Dict[str, Union[float, List[int]]]: def calculate_mean(seq: List[int]) -> float: return mean(seq) def calculate_median(seq: List[int]) -> Union[float, int]: return median(seq) def calculate_mode(seq: List[int]) -> List[int]: frequency = {} for num in seq: frequency[num] = frequency.get(num, 0) + 1 max_frequency = max(frequency.values()) mode_values = [key for key, value in frequency.items() if value == max_frequency] return mode_values def calculate_standard_deviation(seq: List[int]) -> float: mu = calculate_mean(seq) variance = sum((x - mu) ** 2 for x in seq) / len(seq) return math.sqrt(variance) return { \\"mean\\": calculate_mean(sequence), \\"median\\": calculate_median(sequence), \\"mode\\": calculate_mode(sequence), \\"std_dev\\": calculate_standard_deviation(sequence) }"},{"question":"# Scenario You are developing a logging system for a web server that records user activities. To capture and analyze user behavior effectively, it\'s essential to track the duration of user sessions. Each session starts with a login event and ends with a logout event. To provide accurate insights, the system must handle multiple sessions per user and ensure the recorded session times do not overlap. # Task Implement the function `calculate_session_times`, which calculates the total time each user spent active on the platform based on their login and logout timestamps. # Requirements 1. **Function Signature**: ```python def calculate_session_times(logs: List[Tuple[int, str, str]]) -> Dict[int, int]: pass ``` 2. **Parameters**: - `logs` (List[Tuple[int, str, str]]): A list of log entries where each entry is a tuple containing: - `user_id` (int): The unique identifier for the user. - `timestamp` (str): The timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". - `event` (str): The event type, either \\"login\\" or \\"logout\\". 3. **Returns**: - (Dict[int, int]): A dictionary where the keys are user IDs and the values are the total session times in seconds. 4. **Constraints**: - Each user alternates between \\"login\\" and \\"logout\\" events. - Assume the logs are sequential but not necessarily sorted. - Only complete sessions (a login followed by a logout) should be counted. # Examples ```python >>> logs = [ ... (1, \\"2023-10-01 08:00:00\\", \\"login\\"), ... (2, \\"2023-10-01 08:05:00\\", \\"login\\"), ... (1, \\"2023-10-01 09:00:00\\", \\"logout\\"), ... (2, \\"2023-10-01 09:05:00\\", \\"logout\\"), ... (1, \\"2023-10-01 10:00:00\\", \\"login\\"), ... (1, \\"2023-10-01 12:00:00\\", \\"logout\\"), ... ] >>> calculate_session_times(logs) {1: 10800, 2: 3600} ``` # Additional Notes Consider edge cases such as: - Logs with incomplete sessions (e.g., missing a corresponding \\"logout\\" event). - Users with multiple non-overlapping sessions. - Validate the timestamp formats and ensure they are correctly parsed.","solution":"from typing import List, Tuple, Dict from datetime import datetime def calculate_session_times(logs: List[Tuple[int, str, str]]) -> Dict[int, int]: Calculate total active session time for each user based on login and logout events. session_times = {} user_sessions = {} for user_id, timestamp, event in logs: if user_id not in user_sessions: user_sessions[user_id] = {\\"login\\": None, \\"total\\": 0} if event == \\"login\\": user_sessions[user_id][\\"login\\"] = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') elif event == \\"logout\\" and user_sessions[user_id][\\"login\\"] is not None: login_time = user_sessions[user_id][\\"login\\"] logout_time = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') session_duration = (logout_time - login_time).total_seconds() user_sessions[user_id][\\"total\\"] += session_duration user_sessions[user_id][\\"login\\"] = None # Reset the login time for the next possible session for user_id, data in user_sessions.items(): session_times[user_id] = int(data[\\"total\\"]) # Convert to int for exact seconds return session_times"},{"question":"# Scenario You have been tasked with developing a utility to manage the file timestamps in your project repository. Specifically, the requirement is to ensure all file timestamps are updated to match the creation date of the repository. # Problem Statement Write a function `update_file_timestamps` that accepts a `repo_path` and a `timestamp` (a string in the format `YYYY-MM-DD HH:MM:SS`), and updates the \\"last modified\\" and \\"last accessed\\" timestamps of all files within the repository to match the given timestamp. The function should: 1. Traverse the repository starting from `repo_path`. 2. Apply the new timestamp to all files, excluding directories. 3. Handle different operating systems (Windows, Mac, Linux) appropriately. 4. Gracefully skip any files that cannot be updated, logging an appropriate message. # Function Signature ```python def update_file_timestamps(repo_path: str, timestamp: str) -> None: pass ``` # Input - `repo_path`: a string representing the path to the repository. - `timestamp`: a string representing the new timestamp in the format `YYYY-MM-DD HH:MM:SS`. # Output - No return value. The function modifies the timestamps of the files in place. # Constraints - The function should not modify the timestamps of directories. - The function should handle potential permission issues gracefully and log errors. - Ensure compatibility with at least Python 3.7 and later. # Example Given a directory structure as follows: ``` ./ |-- folder_1/ | |-- file_1.py | |-- file_2.ipynb |-- folder_2/ | |-- file_3.py ``` Calling `update_file_timestamps(\\".\\", \\"2023-01-01 12:00:00\\")` would update the timestamps for `file_1.py`, `file_2.ipynb`, and `file_3.py` to `2023-01-01 12:00:00`. **Note**: Pay attention to cross-platform compatibility for setting file timestamps and handle any potential errors appropriately by logging messages instead of raising exceptions.","solution":"import os import time import logging from datetime import datetime def update_file_timestamps(repo_path: str, timestamp: str) -> None: Update the last modified and last accessed timestamps of all files within the given repository to match the provided timestamp. Args: repo_path (str): The path to the repository. timestamp (str): The new timestamp in the format YYYY-MM-DD HH:MM:SS. # Configure logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') # Parse the timestamp new_time_seconds = time.mktime(datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\').timetuple()) # Traverse the repository starting from repo_path for root, dirs, files in os.walk(repo_path): for file in files: file_path = os.path.join(root, file) try: # Update the last modified and last accessed times os.utime(file_path, (new_time_seconds, new_time_seconds)) except Exception as e: logging.error(f\\"Failed to update timestamp for {file_path}: {e}\\")"},{"question":"# Problem: Count Words in a Sentence You are required to write a function `count_words` that receives a string containing a sentence and returns a dictionary with the count of each word in the sentence. Words are defined as any sequences of characters separated by whitespace. The function should be case-insensitive, so \'Apple\' and \'apple\' are considered the same word. Input: * A string `sentence` (1 <= len(sentence) <= 10^5) Output: * A dictionary where the keys are words and the values are their respective counts. Requirements: * Ignore punctuation and convert all characters to lowercase for the count. * Your solution should be efficient in terms of time complexity. Example: ```python >>> count_words(\\"Hello world! hello!\\") {\'hello\': 2, \'world\': 1} >>> count_words(\\"This is a test. This test is only a test.\\") {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} >>> count_words(\\"Python is amazing. Python, indeed, is amazing.\\") {\'python\': 2, \'is\': 2, \'amazing\': 2, \'indeed\': 1} ``` Constraints: * The input string will contain at least one word. * Punctuation should be ignored, and words should be treated in a case-insensitive manner.","solution":"import re from collections import defaultdict def count_words(sentence): Returns a dictionary with the count of each word in the sentence. Words are considered case-insensitive and punctuation is ignored. # Convert the sentence to lowercase sentence = sentence.lower() # Remove punctuation using regex sentence = re.sub(r\'[^ws]\', \'\', sentence) # Split the sentence into words words = sentence.split() # Use defaultdict to keep count of each word word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Coding Assessment Question: Command Line Argument Parser Context You are tasked with implementing a simplified command-line argument parser for a hypothetical application. This parser should be able to interpret both optional and required arguments passed to a program from the command line. Task 1. **Parsing Arguments**: Implement a method `parse_args` which can take an array of strings (arguments from the command line) and parse them as per given specifications: - Required arguments are indicated by their position and do not have any prefix. - Optional arguments start with a `--` prefix and are provided in a key-value format. 2. **Retrieving Argument Values**: Implement methods `get_required` and `get_optional` to retrieve the values of required and optional arguments respectively. 3. **Error Handling**: Ensure your parser correctly handles the following scenarios: - Missing required arguments should raise a `ValueError`. - Optional arguments provided without values should raise a `ValueError`. Implementation ```python class ArgumentParser: def __init__(self): self.required_args = [] self.optional_args = {} def parse_args(self, args, required_num): # Clear previous state self.required_args = [] self.optional_args = {} if len(args) < required_num: raise ValueError(\'Missing required arguments\') # Fetch required args for i in range(required_num): self.required_args.append(args[i]) # Parse optional args i = required_num while i < len(args): if args[i].startswith(\'--\'): if i + 1 < len(args) and not args[i + 1].startswith(\'--\'): self.optional_args[args[i][2:]] = args[i + 1] i += 2 else: raise ValueError(f\'Missing value for optional argument {args[i]}\') else: raise ValueError(f\'Unexpected argument {args[i]}\') def get_required(self): return self.required_args def get_optional(self): return self.optional_args # Example usage if __name__ == \\"__main__\\": parser = ArgumentParser() parser.parse_args([\'input.txt\', \'--verbose\', \'true\', \'output.txt\'], 2) required_args = parser.get_required() optional_args = parser.get_optional() print(\\"Required Arguments:\\", required_args) print(\\"Optional Arguments:\\", optional_args) ``` Input Format - A list of strings representing command line arguments. - An integer indicating the number of required arguments. Output Format - Method `get_required` returns a list of required arguments. - Method `get_optional` returns a dictionary with key-value pairs of optional arguments. - Method `parse_args` raises `ValueError` in case of errors as specified. Constraints - Required arguments are consecutive at the beginning of the list of arguments. - Optional arguments must start with `--` and be followed by their corresponding value. - The number of required arguments will be explicitly stated. This problem requires the implementation within the given `ArgumentParser` class template.","solution":"class ArgumentParser: def __init__(self): self.required_args = [] self.optional_args = {} def parse_args(self, args, required_num): # Clear previous state self.required_args = [] self.optional_args = {} if len(args) < required_num: raise ValueError(\'Missing required arguments\') # Fetch required args for i in range(required_num): self.required_args.append(args[i]) # Parse optional args i = required_num while i < len(args): if args[i].startswith(\'--\'): if i + 1 < len(args) and not args[i + 1].startswith(\'--\'): self.optional_args[args[i][2:]] = args[i + 1] i += 2 else: raise ValueError(f\'Missing value for optional argument {args[i]}\') else: raise ValueError(f\'Unexpected argument {args[i]}\') def get_required(self): return self.required_args def get_optional(self): return self.optional_args # Example usage # if __name__ == \\"__main__\\": # parser = ArgumentParser() # parser.parse_args([\'input.txt\', \'--verbose\', \'true\', \'output.txt\'], 2) # required_args = parser.get_required() # optional_args = parser.get_optional() # print(\\"Required Arguments:\\", required_args) # print(\\"Optional Arguments:\\", optional_args)"},{"question":"# Context You are given an unordered list of integers and tasked with finding the first element that appears more than once, as well as the index at which the repetition occurs. In case there are no repetitions, return `None`. # Task Write a function `find_first_repetition(arr)` that takes a list of integers as input and returns a tuple containing the first repeated integer and its corresponding index. If there are no duplicates in the list, return `None`. # Requirements 1. The function should iterate through the list and track the instances and their indices of each element efficiently. 2. The function should have a time complexity of O(n), where n is the number of elements in the list. # Input/Output - The input is a list of integers `arr`. - The output should be a tuple (element, index) where `element` is the first integer with a repetition and `index` is the position in the list where this repetition is found. - If no repetitions are found, return `None`. # Example ```python # Example 1 arr = [4, 5, 6, 3, 7, 8, 4, 9, 6] print(find_first_repetition(arr)) # Output: (4, 6) # Example 2 arr = [1, 2, 3, 4, 5, 6] print(find_first_repetition(arr)) # Output: None # Example 3 arr = [10, 20, 30, 10, 50, 60, 10] print(find_first_repetition(arr)) # Output: (10, 3) ``` # Notes * Aim to solve this problem using a single pass through the list. * Use an appropriate data structure to keep track of the elements and their indices. * Consider edge cases, such as an empty list or a list with a single element where no repetitions are possible.","solution":"def find_first_repetition(arr): Returns the first repeated integer in the list and the index where this repetition is found. If there are no repetitions, return None. seen = {} for index, value in enumerate(arr): if value in seen: return value, index seen[value] = index return None"},{"question":"# Problem Statement You are tasked with implementing measures for managing a simple bank account system. The system should support basic operations such as deposit, withdrawal, and balance enquiry while ensuring data integrity through the use of a simple checksum. # Your Task 1. **Deposit Operation**: Implement a function that handles the deposit operation. The function should increase the account balance by a given amount. 2. **Withdrawal Operation**: Implement a function that handles the withdrawal operation. The function should decrease the account balance by a given amount but ensures the balance does not go below zero. 3. **Checksum Calculation**: Implement a function that calculates a simple checksum for the account balance. The checksum is defined as the sum of the digits of the account balance. # Instructions 1. **deposit**: * **Input**: `balance` (float), and `amount` (float) - the current balance and the amount to be deposited. * **Output**: `float` - the new balance after the deposit operation. * **Constraints**: Both balance and amount will be non-negative. 2. **withdraw**: * **Input**: `balance` (float), and `amount` (float) - the current balance and the amount to be withdrawn. * **Output**: `float` - the new balance after the withdrawal operation. If the withdrawal amount is greater than the current balance, return the current balance. * **Constraints**: Both balance and amount will be non-negative. 3. **calculate_checksum**: * **Input**: `balance` (float) - the account balance. * **Output**: `int` - the checksum which is the sum of the digits of the balance. * **Constraints**: The balance will be a non-negative float but can be very large (up to millions). # Example ```python >>> deposit(100, 50) 150.0 >>> withdraw(100, 50) 50.0 >>> withdraw(100, 150) 100.0 >>> calculate_checksum(12345.67) 28 >>> calculate_checksum(10000) 1 ``` # Requirements - The solutions should handle edge cases involving invalid inputs. - Performance should be O(n) for the checksum function where n is the number of digits in the balance, and O(1) for the deposit and withdrawal functions. - Adhere to the provided constraints for correctness.","solution":"def deposit(balance, amount): Increases the account balance by the given amount. Args: balance (float): The current balance. amount (float): The amount to deposit. Returns: float: The new balance after the deposit. return balance + amount def withdraw(balance, amount): Decreases the account balance by the given amount, ensuring the balance does not go below zero. Args: balance (float): The current balance. amount (float): The amount to withdraw. Returns: float: The new balance after the withdrawal. If the amount is greater than the current balance, returns the current balance. return balance - amount if amount <= balance else balance def calculate_checksum(balance): Calculates a simple checksum for the account balance. Args: balance (float): The account balance. Returns: int: The checksum, which is the sum of the digits of the balance. checksum = sum(int(digit) for digit in str(balance) if digit.isdigit()) return checksum"},{"question":"# Sorting the Meeting Times Scheduling and efficiently managing meeting times is a common task in software development. Your objective is to write a function that will take a list of meeting times and return them in sorted order, ensuring that chronological order is maintained. Task Objective: Write a function `sort_meetings(meetings: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that takes a list of meeting times represented by tuples, each containing a start time and an end time, and returns the list sorted by start times. If two meetings have the same start time, sort by their end times. Function Specifications: * **Input**: * `meetings` (List[Tuple[int, int]]): a list of tuples where each tuple contains two integers representing the start and end times of a meeting. * **Output**: * (List[Tuple[int, int]]): a list of tuples representing the sorted meeting times. Constraints: * The start time of each meeting will be less than its end time within a valid 24-hour range (0 ≤ start, end < 24). * Meetings within the list can overlap. * The list can be empty. What You Should Implement: Implement a function named `sort_meetings` that returns the list of meetings sorted by start and end times. Example usages: ```python >>> sort_meetings([(13, 15), (9, 10), (12, 14), (9, 11)]) [(9, 10), (9, 11), (12, 14), (13, 15)] >>> sort_meetings([(10, 12), (14, 16), (11, 13), (9, 11)]) [(9, 11), (10, 12), (11, 13), (14, 16)] >>> sort_meetings([(14, 15), (12, 14)]) [(12, 14), (14, 15)] >>> sort_meetings([]) [] ``` You are encouraged to consider all edge cases and ensure your solution is both efficient and accurate. This problem tests your understanding of list and tuple manipulation, sorting algorithms, and attention to detail. Submit your implementation complete with appropriate validation and testing using the examples provided.","solution":"from typing import List, Tuple def sort_meetings(meetings: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Takes a list of meeting times represented by tuples (start, end) and returns the sorted list by start times, and by end times if start times are the same. return sorted(meetings, key=lambda x: (x[0], x[1]))"},{"question":"# Morse Code Decoder Implementation Morse code is a method used in telecommunication to encode text characters as standardized sequences of two different signal durations, called dots and dashes. Your task is to implement a Morse code decoder that translates Morse code into readable English text. Specifications: 1. **Dictionary Mapping**: * Use a predefined dictionary to map Morse code sequences to their corresponding English alphabet. 2. **Text Preparation**: * Morse code will use the characters `.` for dots and `-` for dashes. * Each letter in a word will be separated by a single space, and words will be separated by three spaces. * Convert Morse code to English text using the dictionary mapping. 3. **Decoding**: * Split the input Morse code string using three spaces (\\" \\") to separate individual words. * Within each word, split individual Morse code sequences using a single space. * Translate each Morse code sequence to its corresponding letter using the dictionary. * Join the translated letters to form the decoded English message. Input and Output Formats: * **Function Signatures**: ```python def morse_to_text(morse_code: str) -> str: pass ``` * **Inputs**: * `morse_code`: A string representing the Morse code to be decoded. * **Outputs**: * Returns the decoded English string. Examples: * **Decoding**: ```python assert morse_to_text(\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\") == \\"HELLO WORLD\\" assert morse_to_text(\\".-- .. -.. . .-- .- -.-. .... .--. .-..\\") == \\"WIDE WATCHPL\\" assert morse_to_text(\\"....- .---- ...-- ----.\\") == \\"4139\\" assert morse_to_text(\\"-.-. .--. .- -.-. .\\") == \\"CPACE\\" ``` Implement this function, write the appropriate assertions to validate your results, and provide a brief analysis of any encountered edge cases or issues.","solution":"def morse_to_text(morse_code: str) -> str: morse_dict = { \'.-\': \'A\', \'-...\': \'B\', \'-.-.\': \'C\', \'-..\': \'D\', \'.\': \'E\', \'..-.\': \'F\', \'--.\': \'G\', \'....\': \'H\', \'..\': \'I\', \'.---\': \'J\', \'-.-\': \'K\', \'.-..\': \'L\', \'--\': \'M\', \'-.\': \'N\', \'---\': \'O\', \'.--.\': \'P\', \'--.-\': \'Q\', \'.-.\': \'R\', \'...\': \'S\', \'-\': \'T\', \'..-\': \'U\', \'...-\': \'V\', \'.--\': \'W\', \'-..-\': \'X\', \'-.--\': \'Y\', \'--..\': \'Z\', \'-----\': \'0\', \'.----\': \'1\', \'..---\': \'2\', \'...--\': \'3\', \'....-\': \'4\', \'.....\': \'5\', \'-....\': \'6\', \'--...\': \'7\', \'---..\': \'8\', \'----.\': \'9\' } words = morse_code.split(\\" \\") decoded_message = [] for word in words: letters = word.split(\\" \\") decoded_word = \'\'.join(morse_dict[letter] for letter in letters if letter in morse_dict) decoded_message.append(decoded_word) return \' \'.join(decoded_message)"},{"question":"# Interval Tree - Implementation and Overlapping Intervals Search Background: An Interval Tree is a data structure to store intervals efficiently and allows for fast retrieving of all intervals that overlap with a given interval. It is particularly useful in applications such as computational geometry and DNA sequence alignment. Task: 1. **Construct the Interval Tree**: Implement code to construct an Interval Tree from a given list of intervals. 2. **Implement Overlapping Intervals Search**: Write a function to find and return all intervals in the tree that overlap with a given query interval. Function Signatures: 1. `build_interval_tree(intervals: list[tuple[int, int]]) -> IntervalTreeNode` * **Input**: * `intervals` - A list of intervals represented as tuples of two integers. Each tuple represents the start and end of an interval. * **Output**: * The root node of the constructed Interval Tree. 2. `find_overlapping_intervals(root: IntervalTreeNode, query_interval: tuple[int, int]) -> list[tuple[int, int]]` * **Input**: * `root` - The root node of the Interval Tree. * `query_interval` - The query interval for which we need to find overlapping intervals. * **Output**: * A list of intervals from the tree that overlap with the query interval. Constraints: * All intervals are non-empty, i.e., start < end. * The number of intervals `n` is large (e.g., n < 10^6). Example: ```python # Define the IntervalTreeNode class as needed. # Example intervals and query intervals = [ (1, 5), (3, 7), (4, 6), (6, 8), (10, 15) ] query_interval = (4, 10) interval_tree_root = build_interval_tree(intervals) overlapping_intervals = find_overlapping_intervals(interval_tree_root, query_interval) print(overlapping_intervals) # Output should be the list of intervals that overlap with \'query_interval\' ``` Notes: * You are required to implement the `build_interval_tree` and `find_overlapping_intervals` functions. * Ensure consideration of edge cases such as intervals starting or ending at the same point. * Handle ties by including all intervals that overlap with the query interval.","solution":"class IntervalTreeNode: def __init__(self, interval, max_end, left=None, right=None): Initializes an Interval Tree node. :param interval: The interval represented by this node. :param max_end: The maximum end value of all intervals in the subtree rooted at this node. :param left: Left child of the node. :param right: Right child of the node. self.interval = interval self.max_end = max_end self.left = left self.right = right def build_interval_tree(intervals): Builds an interval tree from a list of intervals. :param intervals: List of intervals to construct the tree. :return: The root node of the interval tree. if not intervals: return None # Sort intervals by starting times intervals.sort(key=lambda x: x[0]) # Find the median interval and use it as the root median_index = len(intervals) // 2 median_interval = intervals[median_index] # Build the node (interval, max_end) root = IntervalTreeNode(median_interval, max(x[1] for x in intervals)) # Recursively build the left and right subtrees root.left = build_interval_tree(intervals[:median_index]) root.right = build_interval_tree(intervals[median_index + 1:]) return root def do_intervals_overlap(interval1, interval2): Checks whether two intervals overlap. :param interval1: The first interval. :param interval2: The second interval. :return: True if the intervals overlap, False otherwise. return interval1[0] < interval2[1] and interval2[0] < interval1[1] def find_overlapping_intervals(root, query_interval): Finds all intervals in the tree that overlap with the query interval. :param root: The root node of the interval tree. :param query_interval: The query interval. :return: A list of intervals that overlap with the query interval. if not root: return [] result = [] if do_intervals_overlap(root.interval, query_interval): result.append(root.interval) if root.left and root.left.max_end >= query_interval[0]: result.extend(find_overlapping_intervals(root.left, query_interval)) result.extend(find_overlapping_intervals(root.right, query_interval)) return result"},{"question":"# Convert String to Integer (atoi) Function Background The `atoi` (ASCII to integer) function is a common utility in various programming languages that converts a string representation of a number into its integer form. This function needs to handle optional leading/trailing spaces and an optional sign character (`+` or `-`). Objective Write a function that implements the `atoi` functionality to convert a string to an integer. Function Signature ```python def string_to_int(s: str) -> int: ``` Input * `s` (str): A string representing a numerical value. The string can include leading/trailing whitespace, an optional sign character, and contain only digits. There will not be any other non-digit characters in the input string. Output * Return an integer that corresponds to the numerical value represented by the input string. The function should handle negative numbers correctly if the string indicates a negative value. Constraints * The input string, after trimming leading/trailing whitespace, will be a valid representation of a number within the range of a 32-bit signed integer (`-2^31` to `2^31 - 1`). Error Handling * If the input string is empty or contains only whitespace, raise a `ValueError` with the message \\"No value passed to the function\\". * If the conversion results in a number outside the 32-bit signed integer range, clamp the value to the nearest bound of this range. Examples ```python >>> string_to_int(\\"42\\") 42 >>> string_to_int(\\" -42\\") -42 >>> string_to_int(\\"4193 with words\\") Traceback (most recent call last): ... ValueError: Invalid input format >>> string_to_int(\\"words and 987\\") Traceback (most recent call last): ... ValueError: Invalid input format >>> string_to_int(\\"-91283472332\\") -2147483648 # Clamped to -2^31 >>> string_to_int(\\" +100 \\") 100 >>> string_to_int(\\"\\") Traceback (most recent call last): ... ValueError: No value passed to the function ```","solution":"def string_to_int(s: str) -> int: Converts a string representation of a number into its integer form. Handles optional leading/trailing spaces and an optional sign character. If the conversion results in a number outside the 32-bit signed integer range, clamps the value to the nearest bound. INT_MAX = 2**31 - 1 INT_MIN = -2**31 s = s.strip() if not s: raise ValueError(\\"No value passed to the function\\") negative = False start_index = 0 if s[0] in (\'-\', \'+\'): if s[0] == \'-\': negative = True start_index += 1 num = 0 for i in range(start_index, len(s)): if not s[i].isdigit(): raise ValueError(\\"Invalid input format\\") num = num * 10 + int(s[i]) if not negative and num > INT_MAX: return INT_MAX if negative and -num < INT_MIN: return INT_MIN return -num if negative else num"},{"question":"# Problem Description You are given an implementation of a singly linked list in Python. Your task is to enhance the existing code to support an additional feature: **Detect Cycle**. The cycle detection should determine if a cycle exists in the linked list. A linked list contains a cycle if some node in the list can be reached again by continuously following the `next` pointer. # Objective Implement a method in the `LinkedList` class called `has_cycle` that returns `True` if the linked list contains a cycle, and `False` otherwise. # Input * A `LinkedList` instance representing the head of the singly linked list. # Output * A boolean value indicating whether the linked list has a cycle. # Constraints * The linked list can contain up to 10,000 nodes. * Each node contains an integer value. # Example Given the linked list as follows: ``` 1 -> 2 -> 3 -> 4 -> 5 ^ | |_________| ``` Calling `linked_list.has_cycle()` should return: ``` True ``` If the linked list is: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` Calling `linked_list.has_cycle()` should return: ``` False ``` # Implementation Notes 1. Use Floyd\'s Cycle-Finding Algorithm (Tortoise and Hare) to detect the cycle efficiently. 2. Traverse the linked list with two pointers, a slow pointer moving one step at a time and a fast pointer moving two steps at a time. 3. If the fast pointer meets the slow pointer, a cycle exists. # Code Template ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedList: def __init__(self): self.head = None def has_cycle(self) -> bool: Detects if the linked list has a cycle. Returns: bool: True if there is a cycle, False otherwise. slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False # Example usage linked_list = LinkedList() # Create nodes node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) # Connect nodes linked_list.head = node1 node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 # Comment the next line to not create a cycle node5.next = node3 print(linked_list.has_cycle()) # Output should be True or False ``` # Requirements * Ensure the function uses O(1) additional space. * Handle edge cases appropriately, such as empty linked list or single node without cycle.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedList: def __init__(self): self.head = None def has_cycle(self) -> bool: Detects if the linked list has a cycle. Returns: bool: True if there is a cycle, False otherwise. if not self.head: return False slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False # Example usage # linked_list = LinkedList() # # Create nodes # node1 = ListNode(1) # node2 = ListNode(2) # node3 = ListNode(3) # node4 = ListNode(4) # node5 = ListNode(5) # # Connect nodes # linked_list.head = node1 # node1.next = node2 # node2.next = node3 # node3.next = node4 # node4.next = node5 # # Comment the next line to not create a cycle # node5.next = node3 # # print(linked_list.has_cycle()) # Output should be True or False"},{"question":"# In-Place Array Rotation **Scenario**: As a software engineer, you\'re working on a system that requires frequent manipulation of arrays. One common operation you need to perform is rotating the elements of the array by a specified number of positions. **Task**: Implement an algorithm that rotates the elements of an array in place to the right by a given number of positions. This means that the rotated array should overwrite the original array. **Function Signature**: ```python def rotate_array(arr: list, k: int) -> None: ``` # Requirements: 1. **Input**: * A list, `arr`, containing integers or floating-point numbers. * An integer, `k`, representing the number of positions to rotate the array to the right. * The list can have up to 10^5 elements, and `k` will be a non-negative integer. 2. **Output**: * The function should modify the list `arr` in place and does not need to return anything. 3. **Constraints**: * The array rotation should be performed in place without using extra space for another array. * Handle cases where `k` is greater than the length of the array. * An empty list should remain unchanged. * The algorithm should be efficient in terms of time complexity. # Example: ```python >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 2) >>> print(arr) [4, 5, 1, 2, 3] >>> arr = [0, 1, 2, 3, 4, 5] >>> rotate_array(arr, 3) >>> print(arr) [3, 4, 5, 0, 1, 2] >>> arr = [1.1, 2.2, 3.3] >>> rotate_array(arr, 1) >>> print(arr) [3.3, 1.1, 2.2] >>> arr = [4, 5, 6] >>> rotate_array(arr, 4) >>> print(arr) [6, 4, 5] ``` # Notes: * **Edge Cases**: Pay attention to edge cases such as empty lists, single-element lists, and large values of `k` where `k` can be much larger than the length of the array. * **Performance**: Ensure your solution adheres to optimal performance constraints considering the provided input size limits. Implement your function below: ```python def rotate_array(arr: list, k: int) -> None: # Your implementation here ```","solution":"def rotate_array(arr: list, k: int) -> None: Rotates the elements of arr to the right by k positions in place. n = len(arr) if n == 0: return k = k % n # Normalize k to be within the range of array length if k == 0: return # Reverse the entire array arr.reverse() # Reverse first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"# Problem Statement You have been tasked with writing an algorithm to determine the longest palindrome that can be formed by reordering characters from a given string `s`. The palindrome should utilize as many characters from the string as possible. A palindrome is a string that reads the same backward as forward. For example, \\"racecar\\" and \\"level\\" are palindromes. # Function Signature ```python def longest_palindrome(s: str) -> str: ``` # Input * `s` (str): A string composed of lowercase and/or uppercase English letters where `1 ≤ len(s) ≤ 10^5`. # Output * A string which is the longest possible palindrome that can be formed by reordering the characters of the input string `s`. # Constraints - The output must be a palindrome using as many characters from `s` as possible. - The returned palindrome can have characters in any order that qualifies as a palindrome. # Example ```python assert longest_palindrome(\\"abccccdd\\") in [\\"dccaccd\\", \\"dccbccd\\", \\"dccbccd\\", \\"dccbccd\\"] assert longest_palindrome(\\"aabb\\") in [\\"abba\\", \\"baab\\"] assert longest_palindrome(\\"abc\\") == \\"a\\" # either \\"a\\", \\"b\\", or \\"c\\" is acceptable ``` # Hints 1. Count the frequency of each character in the string. 2. Use characters with even frequencies to ensure that pairs are used for symmetrical parts of the palindrome. 3. Handle one character with an odd frequency (if any) to place in the middle of the palindrome.","solution":"def longest_palindrome(s: str) -> str: from collections import Counter char_count = Counter(s) half_palindrome = [] middle_char = \'\' for char, count in char_count.items(): # Add pairs to the half_palindrome half_palindrome.append(char * (count // 2)) # Choose the single middle character if necessary if count % 2 == 1 and (middle_char == \'\' or count > char_count[middle_char]): middle_char = char # Construct the palindrome half_palindrome_str = \'\'.join(half_palindrome) half_palindrome_reverse = half_palindrome_str[::-1] return half_palindrome_str + middle_char + half_palindrome_reverse"},{"question":"# Problem Description: You are given a class `CircularQueue` which implements a circular queue data structure. Extend its functionality by implementing the following additional method: **Task**: Implement a method `increase_capacity` which doubles the capacity of the queue while maintaining the order of the elements. ```python def increase_capacity(self) -> None: Doubles the capacity of the circular queue and preserves the order of elements. Time complexity: O(n) @returns: None Example: >>> c_queue = CircularQueue(3) >>> c_queue.enqueue(1) >>> c_queue.enqueue(2) >>> c_queue.enqueue(3) >>> c_queue.is_full() True >>> c_queue.increase_capacity() >>> c_queue.capacity 6 >>> c_queue.is_full() False >>> c_queue.dequeue() 1 >>> c_queue.enqueue(4) >>> c_queue.enqueue(5) >>> list(c_queue) [2, 3, 4, 5] ``` **Input**: - No input parameters **Output**: - No output returned, but the capacity of the circular queue is doubled # Constraints: - All basic operations (enqueue, dequeue, etc.) must work properly. - The `increase_capacity` method must allocate a new queue with doubled capacity and transfer existing elements while maintaining their order. - Proper handling of edge cases (e.g., queue may be empty). # Example Consider the example usage below: ```python # Circular Queue initialization with capacity 3 c_queue = CircularQueue(3) # Enqueue elements to the queue c_queue.enqueue(1) c_queue.enqueue(2) c_queue.enqueue(3) # Check if the queue is full print(c_queue.is_full()) # Output: True # Double the capacity of the queue c_queue.increase_capacity() # Check the new capacity print(c_queue.capacity) # Output: 6 # Check if the queue is still full print(c_queue.is_full()) # Output: False # Dequeue an element and add new elements print(c_queue.dequeue()) # Output: 1 c_queue.enqueue(4) c_queue.enqueue(5) # To visualize the queue, we can print the elements in it print(list(c_queue)) # Output: [2, 3, 4, 5] ``` **Notes**: - Ensure that the order of the elements in the queue is preserved after increasing the capacity. - Handle the wrap-around nature of the circular queue properly. - Make sure the queue functions correctly with the new capacity in subsequent operations.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.size = 0 self.front = 0 self.rear = 0 def enqueue(self, value: int) -> None: if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0 def increase_capacity(self) -> None: new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.size def __iter__(self): for i in range(self.size): yield self.queue[(self.front + i) % self.capacity] # Example usage: # c_queue = CircularQueue(3) # c_queue.enqueue(1) # c_queue.enqueue(2) # c_queue.enqueue(3) # print(c_queue.is_full()) # True # c_queue.increase_capacity() # print(c_queue.capacity) # 6 # print(c_queue.is_full()) # False # print(c_queue.dequeue()) # 1 # c_queue.enqueue(4) # c_queue.enqueue(5) # print(list(c_queue)) # [2, 3, 4, 5]"},{"question":"# Elevator System Simulator In a building with multiple floors, an elevator system needs to be designed that efficiently handles requests from passengers to move between floors. The elevator can respond to requests from within the elevator (internal requests) as well as from the floors (external requests). Here are the specifications of the elevator system: 1. **Initial Setup:** The elevator starts on the ground floor (floor 0). 2. **Floor Requests:** Requests can be made for any floor from 0 up to `max_floor - 1`. **Key Terms:** - **Internal Request:** A request made by a passenger inside the elevator to go to a specific floor. - **External Request:** A request made from a floor by passengers waiting to be picked up. # Task Write a class `ElevatorSystem` that simulates the elevator’s behavior. This class should include methods to handle requests and to move the elevator. Methods 1. **`__init__(self, max_floor: int) -> None:`** - Initialize the elevator with the highest floor defined by `max_floor`. 2. **`external_request(self, floor: int) -> None:`** - Receive an external request from one of the floors. - Raise a `ValueError` if the requested floor is out of the valid range (0 to `max_floor - 1`). 3. **`internal_request(self, floor: int) -> None:`** - Receive an internal request from within the elevator. - Raise a `ValueError` if the requested floor is out of the valid range (0 to `max_floor - 1`). 4. **`step(self) -> None:`** - Move the elevator one step towards the nearest requested floor in the current direction (up or down). - Open the doors when the elevator reaches a requested floor, and remove that floor from the requests. - The elevator should subsequently move towards the next requested floor or stop if there are no more requests. 5. **`status(self) -> dict:`** - Return the current status of the elevator including: - Current floor - Direction of movement (\'up\', \'down\', \'idle\') - List of pending internal requests - List of pending external requests Example ```python elevator = ElevatorSystem(max_floor=10) elevator.external_request(3) elevator.internal_request(7) elevator.internal_request(5) print(elevator.status()) # Output: {\\"current_floor\\": 0, \\"direction\\": \\"up\\", \\"internal_requests\\": [7, 5], \\"external_requests\\": [3]} elevator.step() elevator.step() elevator.step() print(elevator.status()) # Output: {\\"current_floor\\": 3, \\"direction\\": \\"up\\", \\"internal_requests\\": [7, 5], \\"external_requests\\": []} elevator.step() print(elevator.status()) # Output: {\\"current_floor\\": 5, \\"direction\\": \\"up\\", \\"internal_requests\\": [7], \\"external_requests\\": []} ``` **Constraints:** - The elevator can only move one floor at a time during each step. - The requests should be processed in a first-come, first-served manner. - The elevator can only handle one request per step. **Considerations:** - Ensure proper handling of input validation. - Test the system with multiple sequences of requests and movements to ensure efficiency and correctness.","solution":"class ElevatorSystem: def __init__(self, max_floor: int) -> None: self.max_floor = max_floor self.current_floor = 0 self.internal_requests = [] self.external_requests = [] self.direction = \'idle\' def external_request(self, floor: int) -> None: if 0 <= floor < self.max_floor: if floor not in self.external_requests: self.external_requests.append(floor) else: raise ValueError(\\"Requested floor is out of the valid range.\\") def internal_request(self, floor: int) -> None: if 0 <= floor < self.max_floor: if floor not in self.internal_requests: self.internal_requests.append(floor) else: raise ValueError(\\"Requested floor is out of the valid range.\\") def step(self) -> None: if not self.external_requests and not self.internal_requests: self.direction = \'idle\' return # Determine the next floor to move to all_requests = sorted(self.external_requests + self.internal_requests) next_floor = all_requests[0] if self.current_floor < next_floor: self.current_floor += 1 self.direction = \'up\' elif self.current_floor > next_floor: self.current_floor -= 1 self.direction = \'down\' else: self.direction = \'idle\' # Open doors and remove the floor from requests if self.current_floor in self.external_requests: self.external_requests.remove(self.current_floor) if self.current_floor in self.internal_requests: self.internal_requests.remove(self.current_floor) if not self.external_requests and not self.internal_requests: self.direction = \'idle\' def status(self) -> dict: return { \\"current_floor\\": self.current_floor, \\"direction\\": self.direction, \\"internal_requests\\": self.internal_requests, \\"external_requests\\": self.external_requests }"},{"question":"# Problem Statement: You are given a collection of numbers, each represented as a list of digits. Your task is to write a function `find_largest_number(arr: list) -> str` that arranges the numbers in such a way that they form the largest possible concatenated number. # Function Signature: ```python def find_largest_number(arr: list) -> str: ``` # Input: - A list of integers where each integer is greater than or equal to 0. # Output: - Return a string representing the largest concatenated number possible. # Constraints: - The input list will always contain at least one number. - Each integer in the list should be considered as a sequence of digits, not as a single integer. # Example: ```python assert find_largest_number([10, 2]) == \\"210\\" assert find_largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" assert find_largest_number([1, 10, 100, 1000]) == \\"1101001000\\" assert find_largest_number([0, 0, 0]) == \\"0\\" ``` # Notes: - Ensure your solution handles lists with zeros correctly, avoiding leading zeros in the result. - Pay attention to the order of concatenation to maximize the number\'s value. - Consider how to handle the comparison between digit sequences to determine the optimal ordering. # Additional Challenge: - Optimize your implementation to handle large lists efficiently.","solution":"def custom_compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def find_largest_number(arr: list) -> str: Rearranges the numbers to form the largest possible concatenated number. from functools import cmp_to_key # Convert the array to a list of strings str_arr = list(map(str, arr)) # Sort the array with the custom comparator str_arr.sort(key=cmp_to_key(custom_compare)) # Join the array to form the result string largest_number = \'\'.join(str_arr) # Handle the case with multiple leading zeros (e.g., [0, 0]) if largest_number[0] == \'0\': return \'0\' return largest_number"},{"question":"# Problem Statement You are tasked with finding the largest difference between any two elements in an array such that the larger element comes after the smaller in the original array. Write a function `max_difference` that receives an array of integers and returns the maximum difference (Larger element - Smaller element) where the larger element comes after the smaller element. # Function Signature ```python def max_difference(array: list[int]) -> int: ``` # Input - `array` (List[int]): A list of integers. # Output - Returns an integer representing the maximum difference. If no such difference is possible, return -1. # Constraints - The input list may contain up to (10^6) integers. - Each integer in the list is within the range (-10^9) to (10^9). - The solution should have O(n) time complexity and O(1) space complexity. # Examples ```python >>> array = [2, 3, 10, 6, 4, 8, 1] >>> max_difference(array) 8 >>> array = [7, 9, 5, 6, 3, 2] >>> max_difference(array) 2 >>> array = [1, 2] >>> max_difference(array) 1 >>> array = [4, 3, 2, 1] >>> max_difference(array) -1 >>> array = [10, 2, 5, 1, 8, 7, 6] >>> max_difference(array) 7 ``` # Requirements - Implement the function `max_difference` to find the maximum difference with linear time complexity. - Ensure that the implementation works efficiently for large input sizes. - Manage edge cases effectively including: - When the array is empty. - When the array contains only a single element. - When the elements are in strictly decreasing order. # Hints - Keep track of the minimum element encountered so far as you iterate through the array. - Update the maximum difference by comparing the current element with the tracked minimum element. - Consider returning -1 if all comparisons suggest non-positive differences indicating larger elements never appear after smaller ones. The function `max_difference` must be implemented efficiently to handle large datasets within the provided constraints.","solution":"def max_difference(array: list[int]) -> int: if not array or len(array) < 2: return -1 min_element = array[0] max_diff = -1 for i in range(1, len(array)): if array[i] > min_element: max_diff = max(max_diff, array[i] - min_element) min_element = min(min_element, array[i]) return max_diff"},{"question":"# Problem Statement You are a network administrator and need to analyze the consistency of timestamps within log entries generated by several systems. Each log entry contains a system identifier and a timestamp. Your task is to implement a function to find and return all systems that have non-sequential timestamps (i.e., a log entry with a later timestamp appears before an entry with an earlier timestamp for the same system). If a system has all its timestamps in sequential order, it should not be included in the result. # Function Signature ```python def find_non_sequential_logs(logs: list[tuple[str, int]]) -> list[str]: pass ``` # Input * `logs`: A list of tuples, where each tuple consists of: * A string `system_id` indicating the system identifier. * An integer `timestamp` representing the timestamp of the log entry. Each `system_id` is a non-empty string of at most 50 characters, and each `timestamp` is a non-negative integer. # Output * Returns a sorted list of unique system identifiers (strings) which have non-sequential timestamps in their log entries. # Constraints * The length of `logs` will not exceed (10^5). * Each `system_id` will be a contiguous string without spaces, and each `timestamp` is a non-negative integer. # Example ```python >>> find_non_sequential_logs([(\\"system1\\", 101), (\\"system2\\", 200), (\\"system1\\", 100), (\\"system3\\", 300), (\\"system2\\", 199)]) [\'system1\', \'system2\'] ``` # Explanation In this example: * \\"system1\\" has timestamps 101 and 100, which are non-sequential because 100 appears after 101. * \\"system2\\" has timestamps 200 and 199, which are non-sequential because 199 appears after 200. * \\"system3\\" has timestamps 300 only, which are naturally sequential as there\'s only one timestamp. # Notes 1. Ensure your function handles large inputs efficiently. 2. Consider edge cases such as systems with a single log entry or with already sequential timestamps. 3. Return the system identifiers sorted in ascending order. 4. The function should output unique system identifiers even if there are multiple non-sequential instances for the same system.","solution":"def find_non_sequential_logs(logs): from collections import defaultdict system_logs = defaultdict(list) # Group logs by system_id for system_id, timestamp in logs: system_logs[system_id].append(timestamp) non_sequential_systems = set() # Check each system\'s logs for non-sequential timestamps for system_id, timestamps in system_logs.items(): for i in range(1, len(timestamps)): if timestamps[i] < timestamps[i-1]: non_sequential_systems.add(system_id) break return sorted(non_sequential_systems)"},{"question":"# Problem Statement Implement a function that simulates a basic vending machine. The function will receive as input a list of items available in the vending machine, along with their prices, and a list of coins that the user inserts into the machine. The function should return the total amount of money inserted and the list of items the user can afford to purchase. # Function Signature ```python def vending_machine(items: List[Tuple[str, int]], coins: List[int]) -> Tuple[int, List[str]]: Args: items: A list of tuples where each tuple consists of a string representing the item name and an integer representing the item\'s price (in cents). coins: A list of integers representing the coins inserted into the machine (in cents). Possible coin values are [1, 5, 10, 25, 50, 100]. Returns: A tuple containing: - An integer representing the total amount of money inserted into the machine (in cents). - A list of strings representing the names of the items the user can afford to purchase based on the total amount inserted. ``` # Input and Output - **Input**: - `items`: List of available items and their prices (in cents). Each item is represented as a tuple (`item_name`, `item_price`). - `coins`: List of integers representing the coins inserted in the machine. Possible coins are [1, 5, 10, 25, 50, 100] (each value represents cents). - **Output**: A tuple containing: - An integer representing the total amount inserted into the machine (in cents). - A list of item names that can be purchased with the total amount inserted. # Constraints - All item prices and the total amount of coins inserted are between 1 and 10000 cents. - The items list will contain at most 100 items. - The coins list will contain at most 100 coins. # Example ```python items = [(\\"Soda\\", 125), (\\"Chips\\", 75), (\\"Candy\\", 50)] coins = [25, 25, 25, 50] print(vending_machine(items, coins)) # Output: (125, [\\"Soda\\", \\"Chips\\", \\"Candy\\"]) items = [(\\"Gum\\", 5), (\\"Chocolate\\", 60), (\\"Juice\\", 150)] coins = [25, 10, 10, 5, 1] print(vending_machine(items, coins)) # Output: (51, [\\"Gum\\", \\"Chocolate\\"]) ``` # Notes - The provided `vending_machine` function should: - Calculate the total amount of money inserted by summing up the values in the `coins` list. - Identify which items the user can afford to buy by comparing the total amount inserted with the prices of the items. - Return a tuple with the total amount and a list of items that can be bought with that amount.","solution":"from typing import List, Tuple def vending_machine(items: List[Tuple[str, int]], coins: List[int]) -> Tuple[int, List[str]]: Calculate the total amount of coins inserted and return the list of items that can be purchased. Args: items: A list of tuples where each tuple consists of a string representing the item name and an integer representing the item\'s price (in cents). coins: A list of integers representing the coins inserted into the machine (in cents). Possible coin values are [1, 5, 10, 25, 50, 100]. Returns: A tuple containing: - An integer representing the total amount of money inserted into the machine (in cents). - A list of strings representing the names of the items the user can afford to purchase based on the total amount inserted. total_amount = sum(coins) affordable_items = [item for item, price in items if total_amount >= price] return total_amount, affordable_items"},{"question":"# Coding Assessment Question Scenario: You are developing a program to monitor and analyze the performance of a distributed system. One critical aspect is to detect anomalies in the system\'s CPU usage, which is recorded as a time series of percentage values. Your task is to implement a function to identify time intervals where the CPU usage exceeds a given threshold for a specified minimum duration. Task: Write a function named `detect_cpu_anomalies` that processes the time series data and identifies intervals of continuous high CPU usage. Function Signature: ```python def detect_cpu_anomalies(cpu_usage: List[float], threshold: float, min_duration: int) -> List[Tuple[int, int]]: Detect intervals of high CPU usage. Parameters: cpu_usage (List[float]): A list of CPU usage percentages recorded at regular intervals. threshold (float): The CPU usage percentage threshold to detect anomalies. min_duration (int): The minimum number of consecutive intervals for an anomaly to be considered. Returns: List[Tuple[int, int]]: A list of tuples representing the start and end indices of intervals where CPU usage exceeded the threshold. ``` Constraints: * `0 <= threshold <= 100` * `min_duration > 0` * `len(cpu_usage) >= min_duration` Example Usage: 1. Provide a sample CPU usage time series: ```python cpu_usage_data = [10.5, 12.0, 55.2, 67.3, 70.5, 80.1, 75.0, 11.2, 90.0, 95.5, 60.3] threshold = 50.0 min_duration = 3 ``` 2. Detect high CPU usage intervals: ```python anomalies = detect_cpu_anomalies(cpu_usage_data, threshold, min_duration) print(anomalies) ``` This should return intervals where the CPU usage continuously exceeds 50.0% for at least 3 consecutive intervals, such as `[(2, 6), (8, 10)]`. Testing: - Ensure that the function correctly identifies intervals of high usage. - Validate handling of cases with no intervals meeting the criteria. - Test with different threshold and duration values to ensure robustness. By following these guidelines, the new question integrates seamlessly with the existing set in terms of style, complexity, and scope, challenging the candidate\'s ability to process time series data and implement anomaly detection logic effectively.","solution":"from typing import List, Tuple def detect_cpu_anomalies(cpu_usage: List[float], threshold: float, min_duration: int) -> List[Tuple[int, int]]: Detect intervals of high CPU usage. Parameters: cpu_usage (List[float]): A list of CPU usage percentages recorded at regular intervals. threshold (float): The CPU usage percentage threshold to detect anomalies. min_duration (int): The minimum number of consecutive intervals for an anomaly to be considered. Returns: List[Tuple[int, int]]: A list of tuples representing the start and end indices of intervals where CPU usage exceeded the threshold. anomalies = [] n = len(cpu_usage) i = 0 while i < n: if cpu_usage[i] > threshold: start = i while i < n and cpu_usage[i] > threshold: i += 1 if i - start >= min_duration: anomalies.append((start, i - 1)) else: i += 1 return anomalies"},{"question":"# Coding Assessment Question **Problem Description**: You are required to write a Python function to help a hotel manage its room bookings. The function `book_rooms` should take a list of bookings and determine the maximum number of rooms booked at the same time. Each booking is represented by a tuple of two integers `(start_time, end_time)`, where `start_time` and `end_time` are the hours in a 24-hour format (0-23). # Function Signature ```python def book_rooms(bookings: List[Tuple[int, int]]) -> int: pass ``` # Input - **bookings** (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end times of a booking. # Output - **int**: The maximum number of rooms booked at the same time. # Constraints - Bookings can have overlapping times. - The start and end times are inclusive. - The length of the bookings list will not exceed `10^4`. - Each room can be booked multiple times, but each booking is independent of the others. # Example Given the following list of bookings: ```python bookings = [ (1, 4), (2, 5), (6, 7), (3, 8) ] ``` Calling `book_rooms(bookings)` should return `3` because, at time intervals `[2, 3, 4]`, there are 3 concurrent bookings. # Specific Requirements 1. **Function Implementation**: Only the function definition and logic should be implemented. 2. **Performance**: The function should be efficient in terms of time and space, given the constraints. 3. **Edge Case Handling**: Ensure to handle cases such as no bookings, bookings with the same start and end time, etc., without errors. # Hints You may use a sweep line algorithm or other efficient event-based strategy to maximize performance.","solution":"from typing import List, Tuple def book_rooms(bookings: List[Tuple[int, int]]) -> int: events = [] for start, end in bookings: events.append((start, \'start\')) events.append((end+1, \'end\')) # To count the room as still booked at end time events.sort() # Sort events first by time, then by type (\'start\' before \'end\') max_rooms = 0 current_rooms = 0 for time, event_type in events: if event_type == \'start\': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 return max_rooms"},{"question":"# Background Dynamic programming (DP) is a method for solving complex problems by breaking them down into simpler subproblems. Fibonacci sequence is one of the most classic problems that can be solved using dynamic programming. The sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. # Task You are provided with a number `n`. Your task is to calculate the `n`th Fibonacci number using dynamic programming. # Function Signature ```python def fibonacci(n: int) -> int: ``` # Input * `n`: An integer (0 leq n leq 10^4). # Output * Returns an integer representing the `n`th Fibonacci number. # Constraints * `0 leq n leq 10^4` # Example ```python print(fibonacci(10)) # Output: 55 print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(50)) # Output: 12586269025 ``` # Notes * Optimize the solution to avoid recalculating subproblems multiple times. * You may use iteration or memoization to achieve a time complexity of O(n).","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"# Coding Question: Reorder Array for Maximum Sum You are given an array of integers `arr`. Your task is to write a function `reorder_for_max_sum` that reorders the elements of `arr` to maximize the sum of adjacent differences. The sum of adjacent differences is defined as the sum of `|arr[i] - arr[i+1]|` for all `i` from `0` to `len(arr)-2`. # Input - The input array `arr` which is a list of integers. # Output - A reordered list of integers that maximizes the sum of adjacent differences. # Constraints - The length of `arr` will be in the range `[3, 10^4]`. - Each element of `arr` will be in the range `[-10^4, 10^4]`. # Example: ```python >>> reorder_for_max_sum([1, 3, 2, 4]) [1, 4, 2, 3] >>> reorder_for_max_sum([10, 12, 15, 20, 35]) [10, 35, 12, 20, 15] >>> reorder_for_max_sum([3, 5, 2, 1]) [1, 5, 2, 3] >>> reorder_for_max_sum([100, 300, 200, 400]) [100, 400, 200, 300] >>> reorder_for_max_sum([1, 2, 3, 4, 5]) [1, 5, 2, 4, 3] ``` # Note: For the given input `arr = [1, 3, 2, 4]`, one possible reordered list that maximizes the sum of adjacent differences is `[1, 4, 2, 3]`. The sum of adjacent differences for this solution is `|1 - 4| + |4 - 2| + |2 - 3| = 3 + 2 + 1 = 6`, which is the maximum possible sum for this array. Develop a solution that efficiently determines the reorder of the array to achieve the maximum possible sum of adjacent differences.","solution":"def reorder_for_max_sum(arr): Reorders the elements of the array `arr` to maximize the sum of adjacent differences. arr.sort() left, right = 0, len(arr) - 1 result = [] while left <= right: if left == right: result.append(arr[left]) else: result.append(arr[left]) result.append(arr[right]) left += 1 right -= 1 return result"},{"question":"# Context In a data processing application, you need to manage and perform operations on large datasets effectively. One of the tasks involves managing metadata for different datasets and ensuring this metadata is kept consistent throughout various operations. # Problem Statement Write a Python class `Dataset` that supports the following functionalities: 1. **Initialization**: Should initialize a dataset with a given name and a list of columns. 2. **Add Record**: Implement a method to add a new record (row) to the dataset. 3. **Delete Record**: Implement a method to delete a record by index. 4. **Update Record**: Implement a method to update a record at a specific index. 5. **Filter Records**: Implement a method to filter records based on a provided criterion. 6. **String Representation**: A method to return a string representation of the dataset in a tabular format. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases, error handling, and data consistency when performing operations. # Implementation Details 1. **Initialization**: ```python class Dataset: def __init__(self, name: str, columns: List[str]) -> None: ... ``` 2. **Add Record**: ```python def add_record(self, record: List[Any]) -> None: ... ``` 3. **Delete Record**: ```python def delete_record(self, index: int) -> None: ... ``` 4. **Update Record**: ```python def update_record(self, index: int, new_record: List[Any]) -> None: ... ``` 5. **Filter Records**: ```python def filter_records(self, criterion: Callable[[List[Any]], bool]) -> List[List[Any]]: ... ``` 6. **String Representation**: ```python def __str__(self) -> str: ... ``` # Constraints - Ensure records added or updated have the same number of elements as the number of columns. - The input dataset name and columns are guaranteed to be non-empty strings and non-empty lists respectively. - Handle cases where invalid indices are provided for delete or update operations. # Unit Tests Create a test class `TestDataset` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and error scenarios like trying to add inconsistent records or operations on invalid indices. # Example ```python ds = Dataset(\\"StudentData\\", [\\"Name\\", \\"Age\\", \\"Grade\\"]) # Test Add Record ds.add_record([\\"Alice\\", 21, \\"A\\"]) ds.add_record([\\"Bob\\", 22, \\"B\\"]) print(str(ds)) # Should print records in a tabular format. # Test Delete Record ds.delete_record(1) print(str(ds)) # Should no longer contain the record for \\"Bob\\". # Test Update Record ds.update_record(0, [\\"Alice\\", 21, \\"A+\\"]) print(str(ds)) # Should update Alice\'s grade. # Test Filter Records filtered = ds.filter_records(lambda record: record[2] == \\"A+\\") print(filtered) # Should return records where the grade is \\"A+\\". ``` By following this example, add proper validations and handle different scenarios in your implementation to ensure robust functionality.","solution":"from typing import List, Any, Callable class Dataset: def __init__(self, name: str, columns: List[str]) -> None: self.name = name self.columns = columns self.records = [] def add_record(self, record: List[Any]) -> None: if len(record) != len(self.columns): raise ValueError(\\"Record length does not match number of columns\\") self.records.append(record) def delete_record(self, index: int) -> None: if index < 0 or index >= len(self.records): raise IndexError(\\"Record index out of range\\") del self.records[index] def update_record(self, index: int, new_record: List[Any]) -> None: if len(new_record) != len(self.columns): raise ValueError(\\"New record length does not match number of columns\\") if index < 0 or index >= len(self.records): raise IndexError(\\"Record index out of range\\") self.records[index] = new_record def filter_records(self, criterion: Callable[[List[Any]], bool]) -> List[List[Any]]: return [record for record in self.records if criterion(record)] def __str__(self) -> str: output = \' | \'.join(self.columns) + \'n\' output += \'-\' * (len(output) - 1) + \'n\' for record in self.records: output += \' | \'.join(map(str, record)) + \'n\' return output.strip()"},{"question":"New Question [Question 2]: **Graph Shortest Path Problem** # Problem Statement You are required to implement Dijkstra\'s algorithm to find the shortest path between two nodes in a graph. Given an adjacency matrix that represents the graph, your task is to return the shortest path distance from the start node to the end node. # Function Signature ```python def dijkstra(adjacency_matrix: List[List[int]], start: int, end: int) -> int: ``` # Input * `adjacency_matrix`: A `List[List[int]]` representing the `n x n` adjacency matrix of the graph. Each value `adjacency_matrix[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge, the value is `float(\'inf\')` except `adjacency_matrix[i][i]` which is `0`. * `start`: An integer representing the starting node. * `end`: An integer representing the target node. # Output * Returns an `int` representing the shortest path distance from the start node to the end node. If the end node is not reachable, return `-1`. # Constraints * The adjacency matrix is guaranteed to be of size `n x n` where `1 <= n <= 100`. * Each edge weight will be a non-negative integer, or `float(\'inf\')` where there is no edge. # Performance Requirements * The implementation should run efficiently for `n` up to 100 (time complexity of O(n^2) using the adjacency matrix representation is acceptable). # Example ```python # Example 1 adjacency_matrix = [ [0, 1, 4, float(\'inf\')], [1, 0, 2, 5], [4, 2, 0, 1], [float(\'inf\'), 5, 1, 0] ] start = 0 end = 3 assert dijkstra(adjacency_matrix, start, end) == 4 # Path: 0 -> 1 -> 2 -> 3 # Example 2 adjacency_matrix = [ [0, float(\'inf\'), float(\'inf\')], [float(\'inf\'), 0, 1], [float(\'inf\'), 1, 0] ] start = 0 end = 2 assert dijkstra(adjacency_matrix, start, end) == -1 # No path exists from 0 to 2 ``` # Notes * Consider edge cases such as a graph with only one node or a scenario where the start and end node are the same. * Handle potential disconnected nodes using appropriate techniques. * You may use a priority queue to optimize the algorithm, but it\'s not mandatory. By following these guidelines, you will be able to implement an efficient and reliable version of Dijkstra\'s algorithm to find the shortest path in a graph.","solution":"from typing import List import heapq import sys def dijkstra(adjacency_matrix: List[List[int]], start: int, end: int) -> int: n = len(adjacency_matrix) dist = [sys.maxsize] * n dist[start] = 0 visited = [False] * n min_heap = [(0, start)] while min_heap: current_dist, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True for v in range(n): if adjacency_matrix[u][v] != float(\'inf\') and not visited[v]: if current_dist + adjacency_matrix[u][v] < dist[v]: dist[v] = current_dist + adjacency_matrix[u][v] heapq.heappush(min_heap, (dist[v], v)) return dist[end] if dist[end] != sys.maxsize else -1"},{"question":"# Question Design a class `WeatherData` that fetches and presents weather information for a given location. The class should utilize the OpenWeatherMap API to get weather details and presents it in a user-friendly manner. # Requirements 1. **API URL**: Use the OpenWeatherMap API endpoint \\"http://api.openweathermap.org/data/2.5/weather\\" with appropriate parameters for location and API key. 2. **HTTP Request**: Utilize `requests` library to send a GET request to the API. 3. **Data Extraction**: Extract and structure the following information from the API response: * Temperature (in Celsius) * Weather description * Wind speed * Humidity * City name * Country 4. **Error Handling**: Handle common errors such as invalid location, API request issues, or data extraction failures gracefully. # Class Structure Implement the following structure for `WeatherData`: ```python class WeatherData: def __init__(self, api_key: str, location: str): # Constructor with initialization code def fetch_weather(self): # Fetch weather data from the API def get_json(self) -> dict: # Return a dictionary of weather information def __repr__(self) -> str: # Return a string representation of the object def __str__(self) -> str: # Return a user-friendly string representation of the weather information @property def temperature(self) -> float: # Return the temperature in Celsius @property def weather_description(self) -> str: # Return the weather description @property def wind_speed(self) -> float: # Return the wind speed in m/s @property def humidity(self) -> int: # Return the humidity percentage @property def city_name(self) -> str: # Return the city name @property def country(self) -> str: # Return the country ``` # Constraints: 1. **Location Length**: The `location` parameter should be a non-empty string of at most 50 characters. 2. **Timeout**: Set a reasonable timeout for HTTP requests (e.g., 10 seconds). 3. **Performance**: Ensure the implemented class can handle API calls within a reasonable time frame. # Bonus: Enhance the class with a caching mechanism to store and retrieve previously fetched weather data, avoiding redundant network calls.","solution":"import requests class WeatherData: def __init__(self, api_key: str, location: str): self.api_key = api_key self.location = location self.base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" self._data = None self.fetch_weather() def fetch_weather(self): if not self.location or len(self.location) > 50: raise ValueError(\\"Location must be a non-empty string of at most 50 characters\\") try: params = { \'q\': self.location, \'appid\': self.api_key, \'units\': \'metric\' } response = requests.get(self.base_url, params=params, timeout=10) response.raise_for_status() self._data = response.json() except requests.RequestException as e: raise SystemError(f\\"Failed to fetch weather data: {e}\\") def get_json(self) -> dict: return self._data def __repr__(self) -> str: return f\\"WeatherData(api_key=\'{self.api_key}\', location=\'{self.location}\')\\" def __str__(self) -> str: return f\\"Weather in {self.city_name}, {self.country}: {self.weather_description}, {self.temperature}°C, Wind Speed: {self.wind_speed} m/s, Humidity: {self.humidity}%\\" @property def temperature(self) -> float: return self._data[\'main\'][\'temp\'] @property def weather_description(self) -> str: return self._data[\'weather\'][0][\'description\'] @property def wind_speed(self) -> float: return self._data[\'wind\'][\'speed\'] @property def humidity(self) -> int: return self._data[\'main\'][\'humidity\'] @property def city_name(self) -> str: return self._data[\'name\'] @property def country(self) -> str: return self._data[\'sys\'][\'country\']"},{"question":"# Context You are tasked with implementing a function to simulate a simple chatbot based on pattern matching. The chatbot should be able to recognize certain keywords in user inputs and respond accordingly. If the input does not contain any recognizable keyword, it should return a default response. # Requirements Implement a function `chatbot_response` that takes a user input as a string and returns an appropriate response based on predefined patterns. # Function Specification ```python def chatbot_response(user_input: str) -> str: Generate a response from a chatbot based on user input. :param user_input: str, the input string from the user. :return: str, the chatbot\'s response. pass ``` # Input - `user_input` - A string representing the input from the user. # Output - Returns a string containing the chatbot\'s response. # Example ```python # Example inputs and expected outputs print(chatbot_response(\\"hello\\")) # Expected Output: \\"Hi there! How can I assist you today?\\" print(chatbot_response(\\"price\\")) # Expected Output: \\"Are you asking about our product prices? Please specify the product.\\" print(chatbot_response(\\"bye\\")) # Expected Output: \\"Goodbye! Have a great day!\\" print(chatbot_response(\\"How do I reset my password?\\")) # Expected Output: \\"I can help you with that. Please visit our password reset page.\\" print(chatbot_response(\\"random input\\")) # Expected Output: \\"I\'m not sure I understand. Can you please rephrase?\\" ``` # Constraints - The function should identify at least the following keywords: \\"hello\\", \\"bye\\", \\"price\\", \\"password\\". - The function should be case-insensitive. - If the input does not contain any of the predefined keywords, return: \\"I\'m not sure I understand. Can you please rephrase?\\" # Notes - Use simple string matching techniques or regular expressions to identify keywords. - Ensure the function handles variations in input such as different cases and extra spaces efficiently.","solution":"def chatbot_response(user_input: str) -> str: Generate a response from a chatbot based on user input. :param user_input: str, the input string from the user. :return: str, the chatbot\'s response. user_input = user_input.lower().strip() if \\"hello\\" in user_input: return \\"Hi there! How can I assist you today?\\" elif \\"bye\\" in user_input: return \\"Goodbye! Have a great day!\\" elif \\"price\\" in user_input: return \\"Are you asking about our product prices? Please specify the product.\\" elif \\"password\\" in user_input: return \\"I can help you with that. Please visit our password reset page.\\" else: return \\"I\'m not sure I understand. Can you please rephrase?\\""},{"question":"# Coding Assessment Question Context: You are creating a financial application that tracks users\' investment portfolios. Users frequently make changes to their portfolios by buying and selling stock shares. To keep accurate records, the application must maintain a concise transaction history and accurately compute the current holdings of each stock after every transaction. Task: Write a function `calculate_portfolio(transactions: list[str]) -> dict[str, int]` that accepts a list of transaction strings and returns a dictionary representing the final holdings of each stock. Each transaction string will be in the format `\\"{action} {quantity} {ticker_symbol}\\"`, where `action` is either \\"BUY\\" or \\"SELL\\", `quantity` is a positive integer, and `ticker_symbol` is the stock\'s ticker symbol (a string of uppercase letters). Function Signature: ```python def calculate_portfolio(transactions: list[str]) -> dict[str, int]: ``` Input: * A list of strings `transactions` where each string represents a transaction. * Example: `[\\"BUY 50 AAPL\\", \\"SELL 20 AAPL\\", \\"BUY 100 TSLA\\", \\"SELL 10 TSLA\\"]` Output: * A dictionary where the keys are the stock ticker symbols and the values are the net number of shares owned. * Example: `{\\"AAPL\\": 30, \\"TSLA\\": 90}` Constraints: * The input list will contain between 1 and 10^4 transactions. * It is guaranteed that the net number of shares for each stock will be non-negative after applying all transactions. Example: ```python transactions = [\\"BUY 50 MSFT\\", \\"SELL 20 MSFT\\", \\"BUY 30 GOOGL\\", \\"BUY 10 MSFT\\", \\"SELL 5 GOOGL\\"] assert calculate_portfolio(transactions) == {\\"MSFT\\": 40, \\"GOOGL\\": 25} ``` Performance Requirements: * The solution should operate efficiently, handling up to 10^4 transactions in a reasonable time frame. Summary: Implement the `calculate_portfolio` function to correctly track the net holdings for each stock based on a series of buy and sell transactions. Ensure that the function can handle multiple transactions for the same stock and maintain accurate final holdings.","solution":"def calculate_portfolio(transactions): Calculates the final holdings of each stock based on a list of transactions. Args: transactions (list of str): List of transaction strings in the format \\"{action} {quantity} {ticker_symbol}\\". Returns: dict: Dictionary where keys are ticker symbols and values are the net number of shares owned. portfolio = {} for transaction in transactions: action, quantity, ticker_symbol = transaction.split() quantity = int(quantity) if ticker_symbol not in portfolio: portfolio[ticker_symbol] = 0 if action == \\"BUY\\": portfolio[ticker_symbol] += quantity elif action == \\"SELL\\": portfolio[ticker_symbol] -= quantity return portfolio"},{"question":"# Question: Implementing K-Means Clustering for Image Compression Image compression is an essential technique in image processing, reducing the storage requirements for images while maintaining quality. One effective method utilizes the K-Means clustering algorithm to reduce the number of unique colors in an image. Given an input color image, implement the function `kmeans_image_compression(image, K, max_iter=100)` that compresses the image using K-Means clustering. **Input**: - `image` (3D numpy array): A color image with dimensions (height, width, 3). - `K` (int): The number of clusters (colors) to reduce the image to. - `max_iter` (int): The maximum number of iterations for the K-Means algorithm. Default is 100. **Output**: - `compressed_image` (3D numpy array): The compressed image with the same dimensions as the input, but containing only K unique colors. **Constraints**: - The input `image` should be of type numpy array with pixel values in the range [0, 255]. - The image dimensions are at most 1024x1024 pixels to ensure feasible run-time within typical computational limits. - K should be a positive integer less than 256. **Performance Requirements**: - Optimize the clustering process to run efficiently within a few seconds for maximum dimension images. - Ensure low memory overhead, maintaining an O(hwd) space complexity where h is height, w is width, and d is the depth of the image (3). **Implementation Details**: - Utilize common techniques such as initialization of centroids, assignment of points to the nearest centroid, updating centroids, and convergence criteria. - Mechanisms like random initialization of centroids and vectorized operations to improve performance are encouraged. Example: ```python import numpy as np from sklearn.cluster import KMeans def kmeans_image_compression(image, K, max_iter=100): # Reshape the image to a 2D array of pixels pixels = image.reshape(-1, 3) # Perform KMeans clustering kmeans = KMeans(n_clusters=K, max_iter=max_iter) kmeans.fit(pixels) # Replace each pixel value with its respective centroid value compressed_pixels = kmeans.cluster_centers_[kmeans.labels_] # Reshape the compressed pixels array back to the original image shape compressed_image = compressed_pixels.reshape(image.shape).astype(np.uint8) return compressed_image # Example Usage: if __name__ == \\"__main__\\": from skimage import data, io import matplotlib.pyplot as plt # Use example image image = data.astronaut() compressed_image = kmeans_image_compression(image, K=16) fig, ax = plt.subplots(1, 2, figsize=(10, 5)) ax[0].set_title(\'Original Image\') ax[0].imshow(image) ax[1].set_title(\'Compressed Image\') ax[1].imshow(compressed_image) plt.show() ``` **Hints**: - Start by reshaping the image into a list of pixels. - Use an appropriate library or implement your K-Means to cluster the pixels based on their color values. - Once clustered, replace each pixel in the image with its corresponding cluster centroid.","solution":"import numpy as np from sklearn.cluster import KMeans def kmeans_image_compression(image, K, max_iter=100): Compress an image using K-Means clustering to reduce the number of unique colors. Parameters: - image (3D numpy array): A color image with dimensions (height, width, 3). - K (int): The number of clusters (colors) to reduce the image to. - max_iter (int): The maximum number of iterations for the K-Means algorithm. Default is 100. Returns: - compressed_image (3D numpy array): Compressed image with the same dimensions as the input but only K unique colors. # Reshape the image to a 2D array of pixels pixels = image.reshape(-1, 3) # Perform KMeans clustering kmeans = KMeans(n_clusters=K, max_iter=max_iter) kmeans.fit(pixels) # Replace each pixel value with its respective centroid value compressed_pixels = kmeans.cluster_centers_[kmeans.labels_] # Reshape the compressed pixels array back to the original image shape compressed_image = compressed_pixels.reshape(image.shape).astype(np.uint8) return compressed_image"},{"question":"**Scenario**: You are developing an application that processes natural language texts for various analytical purposes. One feature of your application involves automatically identifying and summarizing unique words and their frequency of occurrence. **Task**: Implement the core functionality to calculate word frequency from a given text. # Word Frequency Counter Function 1. **Function Name**: `calculate_word_frequency` 2. **Input**: - `text`: A string representing the input text. 3. **Output**: A dictionary with unique words as keys and their frequencies as values. # Detailed Requirements: 1. **Input validation**: - Ensure the input text is not empty. 2. **Output**: - Return a dictionary where all words are in lowercase and are stripped of punctuation. - Words should be split based on whitespace. - Ignore common punctuation marks like \'.\', \',\', \'!\', \'?\', etc. # Constraints & Performance: - The function should handle text containing up to 1,000,000 characters efficiently. - Consider edge cases such as texts with no alphabetic characters and texts with large amounts of whitespace. # Example Function Signature: ```python def calculate_word_frequency(text: str) -> dict: pass ``` # Example Usage: ```python text = \\"Hello world! Hello, programming world.\\" result = calculate_word_frequency(text) print(result) # Expected output: {\'hello\': 2, \'world\': 2, \'programming\': 1} ``` # Additional Notes: - Ensure to use a robust method to strip punctuation and normalize the case of words. - The function should be performant even with large texts and mixed characters. --- This question maintains the style, complexity, and scope of the original questions, challenging the candidate to process large datasets and manipulate strings, which are common tasks in software development.","solution":"import re from collections import defaultdict def calculate_word_frequency(text: str) -> dict: Calculate the frequency of each unique word in the input text. Parameters: text (str): A string representing the input text. Returns: dict: A dictionary with unique words as keys and their frequencies as values. if not text: return {} # Using regex to replace punctuations with space and converting text to lower case cleaned_text = re.sub(r\'[^ws]\', \' \', text).lower() words = cleaned_text.split() frequency_dict = defaultdict(int) for word in words: frequency_dict[word] += 1 return dict(frequency_dict)"},{"question":"# Problem Scenario You are working on a computational graphics project that involves generating and manipulating geometric shapes. One common requirement is to efficiently check for intersections between different shapes. Specifically, you need to implement functionality to check whether two rectangles intersect in a 2D plane. # Task: Implement a function `do_rectangles_intersect` that determines whether two rectangles in 2D space intersect. Each rectangle is represented by its lower-left and upper-right corners. # Key Requirements: 1. Define a function to determine if two given rectangles overlap. 2. The rectangles should be specified by their lower-left and upper-right corners. # Specifications: 1. **Function**: `do_rectangles_intersect` 2. **Parameters**: * `rect1`: A tuple of four integers `(x1, y1, x2, y2)` specifying the lower-left `(x1, y1)` and upper-right `(x2, y2)` corners of the first rectangle. * `rect2`: A tuple of four integers `(a1, b1, a2, b2)` specifying the lower-left `(a1, b1)` and upper-right `(a2, b2)` corners of the second rectangle. 3. **Return**: * `True` if the rectangles intersect, `False` otherwise. # Constraints: * The coordinates `x1, y1, x2, y2, a1, b1, a2, b2` are all integers. * Assume that the coordinates of the lower-left corner are strictly less than the coordinates of the upper-right corner for each rectangle, i.e., `x1 < x2` and `y1 < y2` for rect1, and similarly for rect2. # Example: ```python # Example Usage rect1 = (0, 0, 2, 2) rect2 = (1, 1, 3, 3) print(do_rectangles_intersect(rect1, rect2)) # returns True rect3 = (0, 0, 1, 1) rect4 = (2, 2, 3, 3) print(do_rectangles_intersect(rect3, rect4)) # returns False ``` # Notes: * Two rectangles intersect if their projection on the x-axis and the y-axis both overlap. * To determine if the rectangles overlap, you need to ensure that one rectangle is not completely to the right, left, above, or below the other rectangle.","solution":"def do_rectangles_intersect(rect1, rect2): Determines if two rectangles, defined by their lower-left and upper-right corners, intersect. Parameters: rect1 (tuple): (x1, y1, x2, y2) lower-left and upper-right corners of the first rectangle. rect2 (tuple): (a1, b1, a2, b2) lower-left and upper-right corners of the second rectangle. Returns: bool: True if the rectangles intersect, False otherwise. x1, y1, x2, y2 = rect1 a1, b1, a2, b2 = rect2 # Check if one rectangle is to the left of the other if x2 <= a1 or a2 <= x1: return False # Check if one rectangle is above the other if y2 <= b1 or b2 <= y1: return False return True"},{"question":"# Coding Challenge: File System Navigator As a software developer, you need to implement a simple navigational system for a file directory structure. The goal is to allow users to traverse the directory structure, navigate to subdirectories, and get the list of items in the current directory. **Objective**: Design a class that models a file system navigator with methods to change directories, list items in the current directory, and navigate up to the previous directory. # Task **Class Definition**: ```python class FileSystemNavigator: def __init__(self, directory_structure: dict): # Directory structure is initially provided as a nested dictionary pass def change_directory(self, path: str) -> bool: pass def list_directory(self) -> list[str]: pass def navigate_up(self) -> bool: pass ``` **Inputs**: - `directory_structure (dict)`: The initial nested dictionary that represents the directory structure. Each key is a directory name, and its value is either a nested dictionary (subdirectory) or an empty dictionary (an empty directory). **Methods**: 1. `change_directory(path: str) -> bool`: Changes the current working directory to the given path. The path can be either absolute (starting from root) or relative (from the current directory). Returns `True` if the directory change was successful, `False` otherwise. 2. `list_directory() -> list[str]`: Lists all items in the current working directory. Returns a list of strings representing directory names. 3. `navigate_up() -> bool`: Navigates to the parent directory of the current working directory. Returns `True` if the operation was successful, `False` if already at the root directory. # Example Given the following directory structure: ```python directory_structure = { \\"home\\": { \\"user\\": { \\"documents\\": {}, \\"photos\\": { \\"vacation\\": {} }, }, }, \\"var\\": { \\"log\\": {}, \\"tmp\\": {}, }, } ``` **Example Usage**: ```python navigator = FileSystemNavigator(directory_structure) assert navigator.change_directory(\\"/home/user/photos\\") == True assert navigator.list_directory() == [\\"vacation\\"] assert navigator.navigate_up() == True assert navigator.list_directory() == [\\"documents\\", \\"photos\\"] assert navigator.change_directory(\\"/var/\\") == True assert navigator.list_directory() == [\\"log\\", \\"tmp\\"] assert navigator.navigate_up() == True assert navigator.list_directory() == [\\"home\\", \\"var\\"] assert navigator.change_directory(\\"/\\") == True assert navigator.list_directory() == [\\"home\\", \\"var\\"] assert navigator.navigate_up() == False # Already at root ``` # Constraints - Assume all directory names are unique. - Only valid paths should be passed into the `change_directory` method. Format paths using `/` as the path separator. - Initial current working directory is the root directory (`/`). # Implementation Requirements - Implement the `FileSystemNavigator` class with all the methods specified. - Validate path changes and edge cases (e.g., navigating above the root directory). - Ensure efficiency in directory traversal and state management.","solution":"class FileSystemNavigator: def __init__(self, directory_structure: dict): self.root = directory_structure self.current_directory = self.root self.current_path = [] def change_directory(self, path: str) -> bool: parts = path.strip(\'/\').split(\'/\') if path.startswith(\'/\'): target_directory = self.root path_parts = parts else: target_directory = self.current_directory path_parts = self.current_path + parts temp_dir = self.root temp_path = [] for part in path_parts: if part == \\"\\": continue if part not in temp_dir: return False temp_dir = temp_dir[part] temp_path.append(part) self.current_directory = temp_dir self.current_path = temp_path return True def list_directory(self) -> list: return list(self.current_directory.keys()) def navigate_up(self) -> bool: if not self.current_path: return False self.current_path.pop() temp_dir = self.root for part in self.current_path: temp_dir = temp_dir[part] self.current_directory = temp_dir return True"},{"question":"# Problem Statement You are given a matrix filled with non-negative integers where each cell represents the number of units of water that cell can trap. The water can only escape from the cells on the border. Your task is to compute the total amount of water trapped in the matrix after considering the cells\' elevation. # Function Signature ```python def trap_water(matrix: list[list[int]]) -> int: pass ``` # Input * `matrix`: A 2D list of non-negative integers where each integer represents the elevation at that cell. The matrix is of size `m x n` where `1 ≤ m, n ≤ 200`. # Output * Returns an integer representing the total amount of water trapped in the matrix. # Constraints * Water can be trapped in cells that are not at the border. * The input matrix will have at least one row and one column (i.e., `m ≥ 1` and `n ≥ 1`). # Example ```python >>> trap_water([ [1, 3, 2, 4, 1], [3, 1, 0, 2, 3], [2, 1, 3, 2, 1], [4, 2, 2, 3, 2] ]) 4 ``` # Explanation In this example, the trapped water is calculated by examining the lowest elevation cells surrounded by higher elevation cells: - The cell at position (1, 2) with elevation 0 can trap 1 unit of water, since the lowest surrounding height is 1. - The cell at position (2, 1) with elevation 1 can trap 2 units of water, surrounded by heights of 2 and 3 respectively. - The cell at position (2, 3) with elevation 2 can trap 1 unit of water, surrounded by heights of 3, 3, and 2. Thus, the total trapped water is 1 + 2 + 1 = 4 units. # Notes 1. Ensure that your function efficiently handles the given constraints. 2. Carefully consider edge cases such as very small matrices. 3. The water trapping should consider all cells, not just those directly adjacent.","solution":"import heapq def trap_water(matrix: list[list[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] pq = [] # initialize the priority queue with all the border cells for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(pq, (matrix[i][j], i, j)) visited[i][j] = True water_trapped = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while pq: height, x, y = heapq.heappop(pq) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - matrix[nx][ny]) heapq.heappush(pq, (max(height, matrix[nx][ny]), nx, ny)) return water_trapped"},{"question":"# Problem Statement You are to implement a function to process and analyze a list of student grades. The function should determine the highest grade, the lowest grade, the average grade, and the median grade. # Task Implement the following function: 1. `analyze_grades(grades: list[int]) -> dict[str, float | int]`: Takes a list of grades as input and returns a dictionary with the highest grade, the lowest grade, the average grade, and the median grade. Raises `ValueError` if the list is empty and `TypeError` if any item in the list is not an integer. # Input and Output Formats - **Input**: - `grades`: A non-empty list of integers where each integer represents a student\'s grade. - **Output**: - Returns a dictionary with the following keys: - `\'highest\'`: the highest grade as an integer. - `\'lowest\'`: the lowest grade as an integer. - `\'average\'`: the average grade as a float rounded to two decimal places. - `\'median\'`: the median grade as a float or integer (use float if the number of grades is even and average the middle elements). # Constraints - The grades list will always contain at least one integer. - Each grade will be an integer between 0 and 100 inclusive. # Examples ```python analyze_grades([87, 95, 76, 88, 100]) # Output: {\'highest\': 100, \'lowest\': 76, \'average\': 89.2, \'median\': 88} analyze_grades([55, 72, 91, 85, 60, 99]) # Output: {\'highest\': 99, \'lowest\': 55, \'average\': 77.0, \'median\': 78.5} ``` # Notes Consider edge cases like: - A list with all grades being the same. - Lists with an even number of grades, requiring calculation of the median as the average of the two middle elements. - An empty list, which should raise an exception.","solution":"def analyze_grades(grades): Takes a list of grades and returns a dictionary with the highest, lowest, average, and median grades. Parameters: grades (list): A list of integers representing student grades. Returns: dict: A dictionary with highest, lowest, average, and median grades. Raises: ValueError: If the list is empty. TypeError: If any item in the list is not an integer. if not grades: raise ValueError(\\"The grades list cannot be empty\\") if not all(isinstance(grade, int) for grade in grades): raise TypeError(\\"All items in the grades list must be integers\\") highest = max(grades) lowest = min(grades) average = round(sum(grades) / len(grades), 2) sorted_grades = sorted(grades) n = len(sorted_grades) if n % 2 == 0: median = (sorted_grades[n // 2 - 1] + sorted_grades[n // 2]) / 2 else: median = sorted_grades[n // 2] return { \'highest\': highest, \'lowest\': lowest, \'average\': average, \'median\': median }"},{"question":"# Transforming a Sentence to Title Case Scenario You are tasked with creating a function to transform a given sentence into title case. In title case, the first letter of each word is capitalized, and all other letters are in lowercase. Articles, conjunctions, and prepositions have special rules that they remain in lowercase unless they are the first or last word in the sentence. Task Implement the function `title_case(sentence: str) -> str`: 1. **title_case(sentence: str) -> str**: This function transforms the given sentence into title case following the rules described above. Input and Output Formats * The `sentence` parameter is a string containing lowercase English letters and spaces. * The returned value should be the transformed title case string. Rules 1. The first and last words in the sentence should always be capitalized. 2. Articles (a, an, the), conjunctions (and, but, or, nor, for, so, yet), and prepositions (in, on, at, to, from, by, with, about, among, between, during, regarding, until) should remain in lowercase unless they are the first or last word of the sentence. Constraints * The `sentence` consists of lowercase letters and spaces only. * The length of `sentence` is between 1 and 1000 characters. Example ```python def title_case(sentence: str) -> str: # TODO: Implement this function pass >>> title_case(\\"a quick brown fox jumps over the lazy dog\\") \'A Quick Brown Fox Jumps Over the Lazy Dog\' >>> title_case(\\"the quick brown fox\\") \'The Quick Brown Fox\' >>> title_case(\\"in a galaxy far far away\\") \'In a Galaxy Far Far Away\' ``` Notes * Consider splitting the sentence into words and then applying the capitalization rules accordingly. * Use a list of articles, conjunctions, and prepositions for reference to ensure accurate title casing. * Ensure to handle edge cases such as sentences with single-letter words and varying lengths properly.","solution":"def title_case(sentence: str) -> str: Transforms the given sentence into title case. exceptions = {\'a\', \'an\', \'the\', \'and\', \'but\', \'or\', \'nor\', \'for\', \'so\', \'yet\', \'in\', \'on\', \'at\', \'to\', \'from\', \'by\', \'with\', \'about\', \'among\', \'between\', \'during\', \'regarding\', \'until\'} words = sentence.split() if not words: return sentence title_cased_words = [] # Always capitalize the first word title_cased_words.append(words[0].capitalize()) # Capitalize middle words only if they are not in the exceptions list for word in words[1:-1]: if word in exceptions: title_cased_words.append(word) else: title_cased_words.append(word.capitalize()) # Always capitalize the last word if len(words) > 1: title_cased_words.append(words[-1].capitalize()) return \' \'.join(title_cased_words)"},{"question":"# Coding Assessment Question: Food Recipe Preparation Time Estimator Context: You are part of a meal planning application team, and one of the features of the app is to estimate the total preparation time for a set of recipes. Each recipe has a preparation time and a cooking time. The total time for a single recipe is the sum of both preparation and cooking times. Task: Write a Python function `total_preparation_time` that takes a list of tuples as its input. Each tuple contains two integers: `prep_time` and `cook_time` representing the preparation time and cooking time for a recipe respectively. The function should return the total time required to prepare all the recipes in the list. Input: * A list of tuples `recipes` where each tuple consists of two integers (`prep_time`, `cook_time`). Output: * An integer representing the total preparation time for all recipes combined. Constraints: * Both `prep_time` and `cook_time` must be non-negative integers. Raise a `ValueError` if any of the times are negative. * The list `recipes` can contain up to ( 10^6 ) recipes. Example: ```python >>> total_preparation_time([(10, 20), (15, 30), (5, 10)]) 90 >>> total_preparation_time([(2, 3), (4, 5), (6, 7)]) 27 >>> total_preparation_time([(0, 0)]) 0 >>> total_preparation_time([(5, -1), (3, 9)]) Traceback (most recent call last): ... ValueError: Preparation and cooking times must be non-negative >>> total_preparation_time([]) 0 ``` Requirements: 1. Ensure your function validates that all preparation and cooking times are non-negative. 2. Include error handling to raise a `ValueError` on invalid input. 3. Optimize your code for readability and efficiency considering the constraints. Performance: * The function should run in linear time ( O(n) ) where ( n ) is the number of recipes. * Memory usage must be efficient and within acceptable limits for large input sizes.","solution":"def total_preparation_time(recipes): Calculate the total preparation time for a set of recipes. Args: - recipes: A list of tuples (prep_time, cook_time) representing the preparation and cooking times for each recipe respectively. Returns: - An integer representing the total preparation time for all recipes combined. Raises: - ValueError: If any of the preparation or cooking times are negative. total_time = 0 for prep_time, cook_time in recipes: if prep_time < 0 or cook_time < 0: raise ValueError(\\"Preparation and cooking times must be non-negative\\") total_time += prep_time + cook_time return total_time"},{"question":"# Course Enrollment Application Context: You are building a simple course enrollment system for a university. Students can enroll in courses, and you should be able to query the system to know which students are enrolled in a particular course and what courses a particular student is enrolled in. Task: Implement a class `CourseEnrollment` that supports enrolling students in courses and querying course and enrollment information. Requirements: 1. **Class Definition** - Implement the class `CourseEnrollment` that represents the enrollment system. - The constructor initializes the enrollment system with no students enrolled. 2. **Enrollment Method** - Implement the method `enroll_student(self, student: str, course: str)` which enrolls a student in a course. Avoid duplicate enrollments. 3. **Query Methods** - Implement the method `courses_for_student(self, student: str) -> List[str]` which returns a list of courses the given student is enrolled in, sorted in alphabetical order. If the student is not enrolled in any course, return an empty list. - Implement the method `students_in_course(self, course: str) -> List[str]` which returns a list of students enrolled in the given course, sorted in alphabetical order. If no students are enrolled in the course, return an empty list. Input/Output: - **Input**: ```python enrollment.enroll_student(\\"Alice\\", \\"Math\\") enrollment.enroll_student(\\"Bob\\", \\"Math\\") enrollment.enroll_student(\\"Alice\\", \\"History\\") ``` - **Output**: ```python enrollment.courses_for_student(\\"Alice\\") -> [\\"History\\", \\"Math\\"] enrollment.students_in_course(\\"Math\\") -> [\\"Alice\\", \\"Bob\\"] ``` Constraints: - A student and course name are non-empty strings consisting of alphanumeric characters and are case-sensitive. - Assume the course and student names are unique identifiers. Example Usage: ```python >>> enrollment = CourseEnrollment() >>> enrollment.enroll_student(\\"Alice\\", \\"Math\\") >>> enrollment.enroll_student(\\"Bob\\", \\"Math\\") >>> enrollment.enroll_student(\\"Alice\\", \\"History\\") >>> enrollment.courses_for_student(\\"Alice\\") [\'History\', \'Math\'] >>> enrollment.students_in_course(\\"Math\\") [\'Alice\', \'Bob\'] >>> enrollment.students_in_course(\\"History\\") [\'Alice\'] >>> enrollment.courses_for_student(\\"Bob\\") [\'Math\'] ```","solution":"from typing import List class CourseEnrollment: def __init__(self): self.student_courses = {} self.course_students = {} def enroll_student(self, student: str, course: str): if student not in self.student_courses: self.student_courses[student] = set() if course not in self.course_students: self.course_students[course] = set() self.student_courses[student].add(course) self.course_students[course].add(student) def courses_for_student(self, student: str) -> List[str]: if student not in self.student_courses: return [] return sorted(self.student_courses[student]) def students_in_course(self, course: str) -> List[str]: if course not in self.course_students: return [] return sorted(self.course_students[course])"},{"question":"# Scenario You are working for a tech company that provides location-based services, and your current project involves calculating distances between geographic points. Your application needs to support functionality that determines the shortest travel distance between two locations on Earth, considering the curvature of the planet. # Problem Statement You need to implement a feature that calculates the great-circle distance between two points on the Earth\'s surface, given their latitude and longitude in decimal degrees. The great-circle distance is the shortest path between two points on the surface of a sphere. # Requirements You need to implement the `great_circle_distance` function that takes four parameters: 1. `lat1` (float): Latitude of the first point in decimal degrees. 2. `lon1` (float): Longitude of the first point in decimal degrees. 3. `lat2` (float): Latitude of the second point in decimal degrees. 4. `lon2` (float): Longitude of the second point in decimal degrees. Your function should calculate the distance using the Haversine formula. Assume the Earth\'s radius is 6371 kilometers. # Input - `lat1`: a float representing the latitude of the first point in decimal degrees. - `lon1`: a float representing the longitude of the first point in decimal degrees. - `lat2`: a float representing the latitude of the second point in decimal degrees. - `lon2`: a float representing the longitude of the second point in decimal degrees. # Output - Returns a float representing the distance between the two points in kilometers. # Constraints - All latitude values must be between -90 and 90 degrees. - All longitude values must be between -180 and 180 degrees. - Latitude and longitude will be valid floats within the specified ranges. # Example ```python import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points on Earth in kilometers. Parameters: lat1 (float): Latitude of the first point. lon1 (float): Longitude of the first point. lat2 (float): Latitude of the second point. lon2 (float): Longitude of the second point. Returns: float: Great-circle distance in kilometers. # Convert decimal degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) distance = 6371 * c # Earth\'s radius in kilometers return distance # Example usage: print(great_circle_distance(51.5074, -0.1278, 40.7128, -74.0060)) # Distance between London and New York print(great_circle_distance(34.0522, -118.2437, 35.6895, 139.6917)) # Distance between Los Angeles and Tokyo # The function should handle negative values correctly as they represent valid latitude and longitude values. # For example, crossing the equator or prime meridian. ```","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points on Earth in kilometers. Parameters: lat1 (float): Latitude of the first point. lon1 (float): Longitude of the first point. lat2 (float): Latitude of the second point. lon2 (float): Longitude of the second point. Returns: float: Great-circle distance in kilometers. # Earth\'s radius in kilometers R = 6371 # Convert decimal degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) distance = R * c # Distance in kilometers return distance"},{"question":"# String Pattern Matching You are given a pattern and a string, and you need to determine if the string follows the given pattern. Implement a function that returns `True` if the string matches the pattern and `False` otherwise. Each character in the pattern corresponds to a unique substring in the string. Function Signature ```python def match_pattern(pattern: str, s: str) -> bool: pass ``` # Input - `pattern` (str): A string where each character represents a different pattern. The pattern string\'s length is between 1 and 100. - `s` (str): A string made up of lowercase letters, with length between 1 and 1000. # Output - `bool`: A boolean value `True` if the string matches the pattern, `False` otherwise. # Example ```python pattern = \\"abba\\" s = \\"dog cat cat dog\\" match_pattern(pattern, s) # Output: True pattern = \\"abba\\" s = \\"dog cat cat fish\\" match_pattern(pattern, s) # Output: False ``` # Constraints - The pattern string and the input string must be non-empty. - Each character in the pattern corresponds to a unique mapping: multiple characters cannot map to the same substring. Performance Requirements - The algorithm should efficiently handle the length of the string and pattern. - You should aim for a linear time complexity relative to the length of the string and pattern. # Notes - Use a dictionary to keep track of the mappings between pattern characters and substrings. - Consider edge cases where the number of spaces in the string does not match the length constraints implied by the pattern. **Hint:** Try to split the string by spaces and compare it to the pattern length. Ensure to check for consistent mappings in both directions (pattern to substring and substring to pattern).","solution":"def match_pattern(pattern: str, s: str) -> bool: words = s.split() # Check if the number of components match if len(pattern) != len(words): return False # Dictionaries to keep track of mappings from pattern to word and word to pattern pattern_to_word = {} word_to_pattern = {} for p_char, word in zip(pattern, words): if p_char not in pattern_to_word: pattern_to_word[p_char] = word if word not in word_to_pattern: word_to_pattern[word] = p_char if pattern_to_word[p_char] != word or word_to_pattern[word] != p_char: return False return True"},{"question":"# Question: Implement a Cache System for Fibonacci Sequence Calculation You are tasked with extending a `Cache` class used to optimize the calculation of the Fibonacci sequence. The class should store previously computed values of the Fibonacci sequence to avoid redundant calculations, thereby improving performance. **Definition**: - The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 The task is broken down as follows: 1. Implement a method `fibonacci` in the `Cache` class that computes the nth Fibonacci number using memoization (caching). 2. Ensure that the `fibonacci` method stores intermediate results to optimize performance for subsequent calls. **Expected Input and Output**: - Input: An integer `n` (0 ≤ n ≤ 10^5). - Output: An integer representing the nth Fibonacci number. **Constraints**: - Ensure that the function handles large values of `n` efficiently by utilizing the cache. - Avoid recomputing Fibonacci numbers for values already present in the cache. # Example ```python # Example of usage: cache = Cache() print(cache.fibonacci(10)) # Expected output: 55 print(cache.fibonacci(50)) # Expected output: 12586269025 print(cache.fibonacci(10)) # Expected output: 55 (retrieved from cache) ``` # Performance Requirements Your method should run in O(n) time complexity for the first call with a particular `n`, and O(1) for subsequent calls with the same `n` due to caching. The space complexity should be O(n) to store the computed values. Your task: 1. Implement the `Cache` class with a `fibonacci` method that uses memoization. 2. Write appropriate test cases to validate the implementation. Good luck!","solution":"class Cache: def __init__(self): # Cache for storing previously calculated Fibonacci numbers self.memo = {} def fibonacci(self, n): Returns the nth Fibonacci number using memoization. if n in self.memo: return self.memo[n] if n == 0: self.memo[0] = 0 elif n == 1: self.memo[1] = 1 else: self.memo[n] = self.fibonacci(n-1) + self.fibonacci(n-2) return self.memo[n]"},{"question":"# Coding Question: Detect Cycles in a Linked List **Objective**: Implement a function to detect if a `LinkedList` contains a cycle. Your function should return `True` if there is a cycle, and `False` otherwise. # Problem Statement: You are provided with a `LinkedList` class that supports appending new integers and iterating over existing elements. Your task is to implement the method `has_cycle()` to determine if the linked list contains any cycles. # Function Signature: ```python def has_cycle(self) -> bool: # Your code goes here ``` # Constraints: - **Input**: The linked list class as provided, containing any ordering or duplicate integers. - **Output**: Returns a boolean indicating if the linked list has a cycle. - **Performance Requirement**: Aim for O(n) time complexity and O(1) space complexity. - **Edge Cases**: - An empty linked list should return `False`. - A linked list with one element should return `False`. - Test on linked lists of various lengths and configurations. # Example: ```python # Example Usage linked_list = LinkedList() linked_list.extend([3, 1, 4, 1, 5]) print(linked_list.has_cycle()) # Expected Output: False # Creating a cycle for test cycle_node = linked_list.head.next.next # Node with value 4 linked_list.tail.next = cycle_node print(linked_list.has_cycle()) # Expected Output: True ``` # Scenario: You\'re tasked with developing a reliable system for a transaction ledger that requires detecting potential cycles in transaction chains to prevent infinite loops during processing. Implementing a cycle detection function in the linked list will help safeguard the integrity of your transaction system and ensure robust data handling. # Additional Notes: You are only allowed to modify the `LinkedList` class to add the `has_cycle` method. Consider using Floyd’s Cycle-Finding Algorithm (also known as the Tortoise and Hare algorithm) for an efficient solution that consumes constant space and runs in linear time.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None self.tail = None def append(self, data): new_node = Node(data) if self.head is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node self.tail = new_node def extend(self, data_list): for data in data_list: self.append(data) def has_cycle(self) -> bool: slow = self.head fast = self.head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Coding Assessment Question In software development, it\'s essential to understand how to manipulate data structures efficiently. In this task, you will be working with a classic data structure—linked lists. Your task is to implement a function that reverses a linked list in pairs. # Scenario Given a singly linked list, write a function that reverses the nodes of the list in pairs. For example, if the linked list is `1 -> 2 -> 3 -> 4`, it should be transformed to `2 -> 1 -> 4 -> 3`. # Function Definition Implement the function `reverse_in_pairs` that takes a singly linked list as input and returns it with nodes reversed in pairs. # Class Definitions ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_in_pairs(head: ListNode) -> ListNode: pass ``` # Input * `head` (ListNode): The head of the singly linked list. # Output * Returns (ListNode): The head of the modified list with nodes reversed in pairs. # Constraints * The number of nodes in the linked list will be in the range `[0, 100]`. * `-100 <= Node.val <= 100` # Performance Requirements Your implementation should perform the operation in O(N) time complexity, where N is the number of nodes in the linked list. The space complexity should be O(1) (not including space used for the input and output). # Examples ```python # Example 1 # Input: head = [1 -> 2 -> 3 -> 4] # Output: [2 -> 1 -> 4 -> 3] head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) new_head = reverse_in_pairs(head) # new_head should be [2 -> 1 -> 4 -> 3] # Example 2 # Input: head = [1 -> 2 -> 3] # Output: [2 -> 1 -> 3] head = ListNode(1, ListNode(2, ListNode(3))) new_head = reverse_in_pairs(head) # new_head should be [2 -> 1 -> 3] ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_in_pairs(head: ListNode) -> ListNode: if not head or not head.next: return head prev = None curr = head new_head = head.next while curr and curr.next: next_pair = curr.next.next second = curr.next curr.next.next = curr curr.next = next_pair if prev: prev.next = second prev = curr curr = next_pair return new_head"},{"question":"# Problem Description You are given a singly linked list implemented as a Python class. Your task is to implement a method named `remove_nth_from_end(self, n: int) -> None` in the `LinkedList` class that removes the nth node from the end of the list and returns the modified list. If `n` is larger than the length of the list, the function should leave the list unchanged. # Requirements - The function only modifies the linked list; it does not return a new list. - Your solution should traverse the linked list efficiently. - Handle edge cases such as `n` being larger than the length of the linked list or the list being empty. # Input - `n (int)`: A positive integer indicating the position from the end of the list of the node to be removed. # Output - The linked list should be modified in place, removing the nth node from the end. # Constraints - `1 <= n <= 10^5` - The number of nodes in the linked list is between 0 and 10^5. # Examples Example 1: ```python linked_list = LinkedList() for i in range(1, 6): linked_list.push(i) print(list(linked_list)) # Output before remove_nth_from_end: [5, 4, 3, 2, 1] linked_list.remove_nth_from_end(2) print(list(linked_list)) # Output after remove_nth_from_end: [5, 4, 3, 1] ``` Example 2: ```python linked_list = LinkedList() for i in range(1, 6): linked_list.push(i) print(list(linked_list)) # Output before remove_nth_from_end: [5, 4, 3, 2, 1] linked_list.remove_nth_from_end(5) print(list(linked_list)) # Output after remove_nth_from_end: [4, 3, 2, 1] ``` # Notes - Consider using two pointers to find the nth node from the end in a single pass. - Ensure your implementation handles all edge cases gracefully.","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def remove_nth_from_end(self, n: int) -> None: dummy = Node(0) dummy.next = self.head first = second = dummy # Advance first n+1 steps for _ in range(n + 1): if first: first = first.next else: return # n is larger than the length of the list # Move first to the end, maintaining the gap of n while first: first = first.next second = second.next # Remove the nth node if second and second.next: second.next = second.next.next # Handle the case when the head is removed self.head = dummy.next def __iter__(self): node = self.head while node: yield node.data node = node.next"},{"question":"# Problem Statement: You are tasked with developing a feature for a text processing application aiming to identify and count the unique words in a sentence. The purpose of this feature is to help in text analysis by providing a clear frequency distribution of words. Your task is to implement a function that performs this operation efficiently. # Function Definition: ```python def count_unique_words(sentence: str) -> dict[str, int]: Count the frequency of unique words in the given sentence. Parameters: - sentence: A string containing the sentence to process. Returns: - A dictionary with words as keys and their frequency count as values. ``` # Input and Output: - **Input**: - `sentence`: A string containing words separated by spaces. The string may include letters, spaces, and punctuation. Its length will not exceed 10^4 characters. - **Output**: A dictionary where keys are unique words (in lowercase) from the sentence, and values are the frequency of each word. # Constraints: - Words are case-insensitive, so \'Hello\' and \'hello\' should be considered the same word. - Normalize words by converting them to lowercase and removing punctuation marks at the beginning or end of the words. - The input `sentence` can include alphabets, spaces, and punctuation marks. - Handle edge cases gracefully, such as empty strings or strings with only punctuation. # Example: ```python count_unique_words(\\"Hello world! Hello, everyone. It\'s a beautiful world.\\") # Output: {\'hello\': 2, \'world\': 2, \'everyone\': 1, \'its\': 1, \'a\': 1, \'beautiful\': 1} count_unique_words(\\"Testing, testing, 1, 2, 3!\\") # Output: {\'testing\': 2, \'1\': 1, \'2\': 1, \'3\': 1} count_unique_words(\\"\\") # Output: {} count_unique_words(\\"Special characters #%^&*() remain, but filtered at word boundaries.\\") # Output: {\'special\': 1, \'characters\': 1, \'remain\': 1, \'but\': 1, \'filtered\': 1, \'at\': 1, \'word\': 1, \'boundaries\': 1} ``` # Notes: - The function should make use of efficient string manipulation and dictionary operations. - Punctuation includes common symbols and should be treated appropriately such that words are stripped of leading and trailing punctuation. - You may assume that punctuation marks do not occur mid-word (i.e., \\"word.word\\" or \\"word,word\\" will not appear, but \\"word, word\\" is valid). Good luck, and happy coding!","solution":"import re from collections import defaultdict def count_unique_words(sentence: str) -> dict: Count the frequency of unique words in the given sentence. Parameters: - sentence: A string containing the sentence to process. Returns: - A dictionary with words as keys and their frequency count as values. # Use regular expressions to split the sentence into words words = re.findall(r\'bw+b\', sentence.lower()) word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Question: Implement a Simplified Version of the Unix `ls -l` Command Problem Statement Your task is to implement a simplified version of the Unix `ls -l` command that lists files in a directory along with their sizes. Your program should traverse a given directory and output the name and size of each file in bytes, sorted in descending order by size. It should also handle nested directories, printing the paths correctly. Input and Output * **Input**: A string `start_path` representing the directory path from which to start listing files. * **Output**: A list of tuples, where each tuple contains: * The path to the file relative to `start_path` (as a string), * The size of the file in bytes (as an integer). Files should be listed in descending order by file size. If two files have the same size, they should be sorted alphabetically by path. Constraints 1. The `start_path` is a valid directory path. 2. The directory may contain subdirectories and files. 3. Assume all file sizes fit in a 32-bit integer. Example ```python # Assuming the directory structure: # /test_dir # |-- a.txt (2 bytes) # |-- b.txt (10 bytes) # |-- sub_dir # |-- c.txt (5 bytes) assert list_files(\\"/test_dir\\") == [ (\\"b.txt\\", 10), (\\"sub_dir/c.txt\\", 5), (\\"a.txt\\", 2) ] ``` Important Notes - You should traverse all subdirectories recursively. - Ensure the output paths are relative to `start_path`, using `/` as the path separator. Implementation ```python import os def list_files(start_path: str): file_list = [] for root, _, files in os.walk(start_path): for file in files: file_path = os.path.join(root, file) file_size = os.path.getsize(file_path) relative_path = os.path.relpath(file_path, start_path) file_list.append((relative_path, file_size)) # Sort files by size in descending order, then by path alphabetically for ties file_list.sort(key=lambda x: (-x[1], x[0])) return file_list # Example usage if __name__ == \\"__main__\\": directory_path = \\"/test_dir\\" print(list_files(directory_path)) ```","solution":"import os def list_files(start_path: str): List all files in a directory and its subdirectories, with their sizes in bytes. Args: start_path (str): The starting directory path. Returns: List[Tuple[str, int]]: List of tuples containing file paths (relative to start_path) and their sizes in bytes, sorted by size in descending order, and alphabetically by path for ties. file_list = [] for root, _, files in os.walk(start_path): for file in files: file_path = os.path.join(root, file) file_size = os.path.getsize(file_path) relative_path = os.path.relpath(file_path, start_path) file_list.append((relative_path, file_size)) # Sort files by size in descending order, then by path alphabetically for ties file_list.sort(key=lambda x: (-x[1], x[0])) return file_list"},{"question":"# Question: Implement Matrix Rank Calculation with Integer Check Given a square matrix of integers, your task is to write a function that computes the rank of the matrix. To ensure the correctness of input, your function should first verify that all entries of the matrix are integers. # Function Signature ```python def compute_matrix_rank(matrix: np.ndarray) -> int: pass ``` # Input - `matrix` (numpy.ndarray): A square matrix with integer entries. # Output - Returns the rank of the matrix as an integer. # Constraints - Matrix dimensions: `matrix` is of size `n x n` where `1 ≤ n ≤ 1000`. # Requirements - Your function should first verify that all entries of the matrix are integers. If the matrix contains non-integer entries, raise a `ValueError` with a message: `\\"The given matrix contains non-integer entries.\\"` - Compute the rank of the matrix using appropriate matrix operations. - No external libraries other than numpy are allowed. # Performance - Aim for an efficient implementation with respect to time and space complexity, considering the given constraints. # Example ```python import numpy as np matrix = np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) print(compute_matrix_rank(matrix)) # Output: 2 ``` # Note - Ensure you thoroughly test your function with various edge cases and input sizes.","solution":"import numpy as np def compute_matrix_rank(matrix: np.ndarray) -> int: Computes the rank of the given square matrix of integers. Parameters: matrix (np.ndarray): A square matrix containing integer entries. Returns: int: The rank of the matrix. Raises: ValueError: If the matrix contains non-integer entries. # Check if all entries are integers if not np.issubdtype(matrix.dtype, np.integer): raise ValueError(\\"The given matrix contains non-integer entries.\\") # Compute and return the rank of the matrix return np.linalg.matrix_rank(matrix)"},{"question":"**Problem Statement**: Implement a function that computes the Collatz sequence for a given positive integer, and returns the number of steps required to reach 1. The Collatz sequence is defined as follows: - Start with a positive integer `n`. - If `n` is 1, the sequence ends. - If `n` is even, divide `n` by 2. - If `n` is odd, multiply `n` by 3 and add 1. **Function Signature**: ```python def collatz_steps(n: int) -> int: pass ``` **Input**: - `n` (int): A positive integer to start the Collatz sequence. **Output**: - Returns an integer representing the number of steps to reach 1. **Constraints**: - `n` must be a positive integer. **Requirements**: - The function should raise a `ValueError` with the message \\"Input must be a positive integer\\" for invalid inputs. **Performance**: - The function should be efficient and handle moderately large values of `n` within practical execution time limits. **Examples**: ```python >>> collatz_steps(1) 0 >>> collatz_steps(12) 9 >>> collatz_steps(19) 20 >>> collatz_steps(-5) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> collatz_steps(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer ``` **Additional Context**: The Collatz sequence, also known as the 3n + 1 problem, is a well-known mathematical sequence. This problem tests your ability to implement sequence generation algorithms, handle recursion or iteration efficiently, and manage input validation tasks robustly.","solution":"def collatz_steps(n: int) -> int: Computes the number of steps required to reach 1 in the Collatz sequence for a given number n. Parameters: n (int): A positive integer to start the Collatz sequence. Returns: int: The number of steps to reach 1. Raises: ValueError: If the input is not a positive integer. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer\\") steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"# Question: Power Set Generation **Objective**: Write a function to generate the power set of a given set of integers, and return the power set as a list of lists. **Function Signature**: ```python def generate_power_set(nums: List[int]) -> List[List[int]]: Given a list of integers, return the power set (all possible subsets). ``` # Input - `nums` (List[int]): List of integers (0 <= len(nums) <= 10, -10 <= nums[i] <= 10). # Output - List of lists, where each list is a subset of `nums`. # Constraints - Focus on time efficiency in generating the power set. - Subsets in the power set can be listed in any order. - Avoid duplicates in the resulting power set. # Example ```python assert generate_power_set([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert generate_power_set([4, 4]) == [[], [4], [4, 4]] # Deduplication not required in subsets assert generate_power_set([]) == [[]] ``` **Notes**: - The power set of a set S is the set of all subsets of S, including the empty set and S itself. - The order of subsets in the power set does not matter.","solution":"from typing import List def generate_power_set(nums: List[int]) -> List[List[int]]: Given a list of integers, return the power set (all possible subsets). power_set = [[]] for num in nums: power_set += [curr + [num] for curr in power_set] return power_set"},{"question":"Task Write a function to simulate a simple banking system\'s deposit and withdrawal operations, ensuring thread safety. Input * A starting balance as an integer. * A list of operations, where each operation is a dictionary with two keys: \\"type\\" (either \\"deposit\\" or \\"withdrawal\\") and \\"amount\\" (a positive integer). Output * The final balance after all operations have been executed. Constraints * You must ensure thread safety, as operations may come from multiple threads. * Validate input to ensure only positive integers for amounts and valid operation types. * Assume the initial balance is always non-negative. * The function should avoid any overdrafts and retain the balance if a withdrawal cannot be fully completed due to insufficient funds. Performance * Aim for efficient handling of concurrent operations with minimal locks. Function Signature ```python from threading import Lock def simulate_banking(balance: int, operations: list) -> int: ``` Example ```python initial_balance = 100 operations = [ {\\"type\\": \\"deposit\\", \\"amount\\": 50}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 70}, {\\"type\\": \\"deposit\\", \\"amount\\": 30}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 90}, ] final_balance = simulate_banking(initial_balance, operations) print(final_balance) # Expected output: 110 ``` Hint Use a Lock object to ensure that deposits and withdrawals are processed safely when accessed from multiple threads. Make sure to handle the lock correctly to avoid deadlocks or race conditions.","solution":"from threading import Lock from threading import Thread def simulate_banking(balance: int, operations: list) -> int: lock = Lock() def process_operation(operation): nonlocal balance operation_type = operation.get(\\"type\\") amount = operation.get(\\"amount\\") if not isinstance(amount, int) or amount <= 0: return if operation_type not in [\\"deposit\\", \\"withdrawal\\"]: return with lock: if operation_type == \\"deposit\\": balance += amount elif operation_type == \\"withdrawal\\" and balance >= amount: balance -= amount threads = [] for operation in operations: thread = Thread(target=process_operation, args=(operation,)) thread.start() threads.append(thread) for thread in threads: thread.join() return balance"},{"question":"# Context: You are developing a system to manage a library of books. Each book is categorized by genres, and each genre has a certain popularity rating. Your task is to implement a recommendation system that suggests the top 3 most popular genres based on the books in the library. # Task: Implement the function `top_genres(book_data: List[Dict[str, Any]]) -> List[str]`. The function takes a list of dictionaries as input, where each dictionary represents a book with `title`, `author`, and `genres` as keys. The genres are given as a list of strings within each book dictionary. The function should then: 1. Calculate the total count of each genre across all books. 2. Sort the genres based on their popularity in descending order. 3. Return the top 3 genres as a list of strings. If there are less than 3 genres, return all of them. # Input: * `book_data`: A list of dictionaries, where each dictionary contains the following keys: - `title`: A string representing the book title. - `author`: A string representing the book\'s author. - `genres`: A list of strings representing the genres of the book. # Output: * Returns a list of strings representing the top 3 most popular genres in descending order of popularity. # Example: ```python def top_genres(book_data: List[Dict[str, Any]]) -> List[str]: # Your implementation here # Usage books = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"genres\\": [\\"Fantasy\\", \\"Adventure\\"]}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"genres\\": [\\"Fantasy\\", \\"Drama\\"]}, {\\"title\\": \\"Book Three\\", \\"author\\": \\"Author C\\", \\"genres\\": [\\"Sci-Fi\\", \\"Adventure\\"]}, ] result = top_genres(books) print(result) # Expected output: [\\"Fantasy\\", \\"Adventure\\", \\"Drama\\"] ``` # Constraints: * The keys `title`, `author`, and `genres` will always be present in each dictionary. * Each genre string will contain only alphabetical characters and spaces. * The solution should efficiently handle input lists with up to 10,000 book entries. # Performance Requirements: * Your implementation should efficiently process the input data within acceptable runtime limits for the given constraints. # Note: * In case of a tie (genres with the same count), the order of those genres in the output does not matter.","solution":"from typing import List, Dict, Any def top_genres(book_data: List[Dict[str, Any]]) -> List[str]: # Dictionary to keep count of genres genre_count = {} # Calculate the total count of each genre for book in book_data: for genre in book[\'genres\']: if genre in genre_count: genre_count[genre] += 1 else: genre_count[genre] = 1 # Sort genres based on their popularity in descending order sorted_genres = sorted(genre_count.items(), key=lambda x: x[1], reverse=True) # Extract the top 3 genres top_3_genres = [genre for genre, count in sorted_genres[:3]] return top_3_genres"},{"question":"# Question: Hash Map Implementation Coding Challenge # Background: Hash maps, also known as hash tables, are fundamental data structures that offer efficient key-value pair storage and retrieval. They achieve this by utilizing a hashing function to compute an index into an array of buckets or slots, from which the desired value can be found. # Your Task: Implement a basic `HashMap` class in Python, supporting fundamental operations including insertion (`put`), retrieval (`get`), and deletion (`delete`) of key-value pairs. # Class Definition: ```python class HashMap: def __init__(self, initial_capacity = 16): # initialize the hash map with the given initial capacity pass def _hash(self, key): # internal function to compute the hash value of a key pass def put(self, key, value): # add a key-value pair to the hash map pass def get(self, key): # retrieve the value associated with the key pass def delete(self, key): # remove the key-value pair from the hash map pass ``` # Input Methods: 1. **`__init__(self, initial_capacity=16)`**: - `initial_capacity` (int, optional): The initial size of the hash map. Default is 16. 2. **`_hash(self, key)`**: - `key`: the key to be hashed. 3. **`put(self, key, value)`**: - `key`: The key of the element to be inserted. - `value`: The value of the element to be inserted. 4. **`get(self, key)`**: - `key`: The key of the element to be retrieved. 5. **`delete(self, key)`**: - `key`: The key of the element to be deleted. # Output: Methods: 1. **`__init__(self, initial_capacity=16)`**: Initializes the hash map. 2. **`_hash(self, key)`**: Returns the index for the key. 3. **`put(self, key, value)`**: Stores the key-value pair in the hash map. 4. **`get(self, key)`**: Retrieves the value associated with the key. 5. **`delete(self, key)`**: Removes the key-value pair from the hash map. # Constraints: - The keys and values can be of any data type. - Handle collisions using separate chaining (linked lists). - No need to resize the underlying array for simplicity. - Ensure basic operations (insert, get, delete) have average O(1) time complexity. - The hash function should handle multiple data types as keys efficiently. # Example: ```python # Instantiate a new HashMap hash_map = HashMap() # Insert key-value pairs hash_map.put(\'apple\', 3) hash_map.put(\'banana\', 5) hash_map.put(\'cherry\', 10) # Retrieve values print(hash_map.get(\'apple\')) # Output: 3 print(hash_map.get(\'banana\')) # Output: 5 # Delete a key hash_map.delete(\'banana\') # Try to retrieve the deleted key print(hash_map.get(\'banana\')) # Output: None ``` # Additional Task: Write unit tests to validate your `HashMap` implementation for various cases including: - Basic insert, get, and delete operations. - Handling key collisions. - Working with different data types as keys and values. - Testing the hash map with a large number of entries to ensure efficiency.","solution":"class HashMap: def __init__(self, initial_capacity=16): self.capacity = initial_capacity self.table = [[] for _ in range(self.capacity)] def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): hash_index = self._hash(key) for i, (k, v) in enumerate(self.table[hash_index]): if k == key: self.table[hash_index][i] = (key, value) return self.table[hash_index].append((key, value)) def get(self, key): hash_index = self._hash(key) for k, v in self.table[hash_index]: if k == key: return v return None def delete(self, key): hash_index = self._hash(key) for i, (k, v) in enumerate(self.table[hash_index]): if k == key: del self.table[hash_index][i] return"},{"question":"# Problem Statement You work in a robotics company that designs algorithms to control the movement of autonomous robots. One of the tasks is to determine the shortest path for a robot to navigate from its starting position to a target position on a grid while avoiding obstacles. The grid is represented as a matrix where 0s indicate free space and 1s indicate obstacles. Implement the A* search algorithm to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1) of an n x n grid. # Function Signature ```python def find_shortest_path(grid): Finds the shortest path in a grid using the A* search algorithm. Arguments: grid -- a list of lists of integers where 0 represents free space and 1 represents an obstacle. Returns: An integer representing the length of the shortest path from the top-left corner to the bottom-right corner. If no path is found, return -1. pass ``` # Input * `grid` (list of lists of integers): An n x n grid representing the map where 0s are free space and 1s are obstacles. # Output * Integer representing the length of the shortest path from (0, 0) to (n-1, n-1). * Return -1 if no path exists. # Constraints * ( 1 leq n leq 100 ) * Each grid element is either 0 or 1. * The top-left corner grid[0][0] and bottom-right corner grid[n-1][n-1] are always 0. # Performance Requirements * Your solution should be optimized to handle the maximal constraints efficiently. # Example ```python # Define the grid grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0] ] # Call the function path_length = find_shortest_path(grid) # Example output # 5 ``` # Explanation The function calculates the shortest path length from the top-left corner to the bottom-right corner using the A* search algorithm. In the example, the path found is [(0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2) -> (3,2) -> (3,3)] with a length of 5. The function should return 5 for this example.","solution":"import heapq def find_shortest_path(grid): Finds the shortest path in a grid using the A* search algorithm. Arguments: grid -- a list of lists of integers where 0 represents free space and 1 represents an obstacle. Returns: An integer representing the length of the shortest path from the top-left corner to the bottom-right corner. If no path is found, return -1. def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) n = len(grid) start = (0, 0) goal = (n-1, n-1) open_list = [] heapq.heappush(open_list, (0 + heuristic(start, goal), 0, start)) came_from = {} g_score = {start: 0} while open_list: current_f, current_g, current = heapq.heappop(open_list) if current == goal: return current_g for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (current[0] + dx, current[1] + dy) if 0 <= neighbor[0] < n and 0 <= neighbor[1] < n and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = current_g + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_list, (f_score, tentative_g_score, neighbor)) return -1"},{"question":"# Problem Statement You are working as a software developer for a navigation company. Your task is to write a program that calculates the shortest path between two points in a city grid. The city grid is represented by an M x N matrix, where some cells may be blocked and cannot be traversed. You need to find the shortest path from the start cell to the destination cell using only valid moves: up, down, left, and right. Diagonal movement is not allowed. # Requirements 1. Implement a function `shortest_path` to return the length of the shortest path given the city grid matrix, the start cell coordinates, and the destination cell coordinates. 2. If there is no valid path from the start to the destination, the function should return -1. # Function Signature ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: # Your code here ``` # Inputs * `grid` (List[List[int]]): A 2D list representing the city grid, where 0s are traversable cells and 1s are blocked cells. * `start` (Tuple[int, int]): A tuple representing the starting cell coordinates (row, column). * `destination` (Tuple[int, int]): A tuple representing the destination cell coordinates (row, column). # Output * `path_length` (int): The length of the shortest path from the start to the destination. Return -1 if no path exists. # Constraints * 2 <= M, N <= 1000 (dimensions of the grid) * `grid[i][j]` is either 0 (traversable) or 1 (blocked) * 0 <= start[0], start[1], destination[0], destination[1] < M, N * The start and destination cells are always 0 (traversable). # Example ```python # Example 1: grid = [ [0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] start = (0, 0) destination = (4, 4) assert shortest_path(grid, start, destination) == 7 # Example 2: grid = [ [0, 1], [1, 0] ] start = (0, 0) destination = (1, 1) assert shortest_path(grid, start, destination) == -1 ``` # Explanation 1. The `shortest_path` function calculates the shortest path length considering the constraints of untraversable cells. 2. Use a breadth-first search (BFS) algorithm to find the shortest path in an unweighted grid. 3. Proper error handling and edge case consideration ensure realistic outputs in all scenarios. Complete the implementation of this function, ensuring correctness and efficiency.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: if not grid or not grid[0] or grid[start[0]][start[1]] == 1 or grid[destination[0]][destination[1]] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: row, col, dist = queue.popleft() if (row, col) == destination: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"# Problem Statement You need to implement a function named `longest_common_subsequence` which takes two strings and returns their longest common subsequence (LCS). A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. The LCS of two strings is the longest sequence that can be derived from both strings. # Function Specification * **Function Name**: `longest_common_subsequence` * **Input**: * Two strings `s1` and `s2` (1 ≤ |s1|, |s2| ≤ 1000). * **Output**: * A string representing the longest common subsequence of `s1` and `s2`. # Constraints: * If there are multiple LCS of the same maximum length, return any one of them. * The function must handle the maximum input size efficiently. * The solution should utilize Dynamic Programming to achieve the desired efficiency. # Example ```python assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\") == \\"BCAB\\" or longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\") == \\"BCBA\\" assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == \\"GTAB\\" assert longest_common_subsequence(\\"ABCDGH\\", \\"AEDFHR\\") == \\"ADH\\" assert longest_common_subsequence(\\"AAB\\", \\"AZB\\") == \\"AB\\" ``` # Implementation Hints Use a two-dimensional table to keep track of the LCS lengths between prefixes of the two strings. Iterate over the table to build the longest common subsequence from the computed lengths.","solution":"def longest_common_subsequence(s1, s2): Returns the longest common subsequence (LCS) of two input strings. m, n = len(s1), len(s2) # Create a 2D list to store the lengths of LCS for substrings. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m): for j in range(n): if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # Recover the LCS from the dp array lcs = [] x, y = m, n while x > 0 and y > 0: if dp[x][y] == dp[x - 1][y]: x -= 1 elif dp[x][y] == dp[x][y - 1]: y -= 1 else: lcs.append(s1[x - 1]) x -= 1 y -= 1 return \'\'.join(reversed(lcs))"},{"question":"# Question: Implement a Multi-Mode Sorting Algorithm You need to implement a flexible sorting function that can sort a list of integers based on different modes (ascending, descending, even-odd, odd-even). The function should be efficient and able to handle various edge cases. Function Signature ```python def multi_mode_sort(arr: list, mode: str = \'ascending\') -> list: ``` Input * `arr`: A list of integers to be sorted. * `mode`: A string indicating the sorting mode. It can be one of the following values: - `\'ascending\'`: Sort the list in ascending order. - `\'descending\'`: Sort the list in descending order. - `\'even-odd\'`: Sort all even numbers first (in ascending order), followed by all odd numbers (in ascending order). - `\'odd-even\'`: Sort all odd numbers first (in ascending order), followed by all even numbers (in ascending order). Defaults to `\'ascending\'`. Output * A new list of integers sorted according to the specified mode. Constraints * The list will have at most 10^4 integers. * Each integer is between -10^6 and 10^6 inclusive. * Assume the input list can be empty. Requirements 1. Implement sorting for the specified modes accurately. 2. Ensure the solution can handle edge cases such as lists with all even or all odd numbers, and empty lists. 3. Optimize for performance using efficient sorting algorithms. # Example ```python test_list_1 = [3, 1, 4, 1, 5, 9, 2, 6, 5] test_list_2 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] test_list_3 = [0, 1, 2, 3, 4, 5] assert multi_mode_sort(test_list_1) == [1, 1, 2, 3, 4, 5, 5, 6, 9] assert multi_mode_sort(test_list_2, mode=\'descending\') == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] assert multi_mode_sort(test_list_3, mode=\'even-odd\') == [0, 2, 4, 1, 3, 5] assert multi_mode_sort(test_list_3, mode=\'odd-even\') == [1, 3, 5, 0, 2, 4] ```","solution":"def multi_mode_sort(arr: list, mode: str = \'ascending\') -> list: Sorts a list of integers according to the specified mode. Parameters: arr (list): The list of integers to be sorted. mode (str): The sorting mode, which can be one of: \'ascending\' (default): Sort in ascending order. \'descending\': Sort in descending order. \'even-odd\': Sort all even numbers first (ascending), then all odd numbers (ascending). \'odd-even\': Sort all odd numbers first (ascending), then all even numbers (ascending). Returns: list: A new list of sorted integers according to the specified mode. if mode == \'ascending\': return sorted(arr) elif mode == \'descending\': return sorted(arr, reverse=True) elif mode == \'even-odd\': evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0]) return evens + odds elif mode == \'odd-even\': odds = sorted([x for x in arr if x % 2 != 0]) evens = sorted([x for x in arr if x % 2 == 0]) return odds + evens else: raise ValueError(\\"Invalid mode specified\\")"},{"question":"# Palindrome Checker Implementation Challenge Objective You are tasked to implement a function to check if a given string is a palindrome using both iterative and recursive approaches. Scenario Consider a program that needs to check whether a string is a palindrome as part of its string manipulation tasks. The function should be efficient and handle edge cases appropriately. Function Specifications: * **Function Name**: `is_palindrome_iterative` * **Input**: A string `s` * **Output**: Returns `True` if the string `s` is a palindrome, and `False` otherwise. * **Constraints**: - The function should ignore case and non-alphanumeric characters. * **Performance Requirements**: Use an iterative approach with fewer than O(n) auxiliary space. * **Function Name**: `is_palindrome_recursive` * **Input**: A string `s` * **Output**: Returns `True` if the string `s` is a palindrome, and `False` otherwise. * **Constraints**: - Same as above with respect to ignoring case and non-alphanumeric characters. * **Performance Requirements**: Use a recursive approach. Example Usage ```python # Iterative implementation examples assert is_palindrome_iterative(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome_iterative(\\"Racecar\\") == True assert is_palindrome_iterative(\\"Hello, world!\\") == False assert is_palindrome_iterative(\\"\\") == True # Recursive implementation examples assert is_palindrome_recursive(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome_recursive(\\"Racecar\\") == True assert is_palindrome_recursive(\\"Hello, world!\\") == False assert is_palindrome_recursive(\\"\\") == True ```","solution":"import re def preprocess_string(s): Preprocess the string by converting to lowercase, and removing non-alphanumeric characters. return re.sub(r\'[^a-z0-9]\', \'\', s.lower()) def is_palindrome_iterative(s): Check if a given string is a palindrome using an iterative approach. s = preprocess_string(s) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True def is_palindrome_recursive(s): Check if a given string is a palindrome using a recursive approach. s = preprocess_string(s) def helper(left, right): if left >= right: return True if s[left] != s[right]: return False return helper(left + 1, right - 1) return helper(0, len(s) - 1)"},{"question":"# Question: Directed Acyclic Graph (DAG) Shortest Path In this exercise, you will find the shortest paths from a given source node to all other nodes in a Directed Acyclic Graph (DAG) with weighted edges. You need to implement an algorithm that correctly handles the structure and properties of a DAG efficiently. Function Signature ```python def shortest_path_dag(graph: dict[int, list[tuple[int, int]]], start: int) -> dict[int, int]: Finds the shortest paths from the start node to all other nodes in a weighted DAG. :param graph: The graph represented as an adjacency list. The keys are node identifiers and the values are lists of tuples, where each tuple consists of a neighboring node and the weight of the edge to that neighbor. :param start: The starting node identifier from which to calculate shortest paths. :return: A dictionary where the keys are node identifiers and the values are the shortest path distances from the starting node to that node. If a node is not reachable from the start node, it should not appear in the dictionary. pass ``` Input * `graph` (dict): A dictionary representing the DAG where the keys are nodes, and the values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge to that neighbor. * `start` (int): The starting node identifier. Output * `dict` (dict): A dictionary where each key is a node identifier, and the corresponding value is the shortest distance from the start node to that node. Constraints * The graph has no cycles and is directed. * Weights are non-negative integers. * The number of nodes `N` and the number of edges `E` satisfy: 1 ≤ N, E ≤ 10^5. * The function should have a time complexity of O(N + E) due to the constraints. Example ```python graph = { 0: [(1, 2), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(3, 3)], 3: [] } start = 0 output = shortest_path_dag(graph, start) print(output) # Output should be: {0: 0, 1: 2, 2: 3, 3: 6} graph2 = { 0: [(1, 1)], 1: [(2, 1)], 2: [(3, 1)], 3: [] } start2 = 0 output2 = shortest_path_dag(graph2, start2) print(output2) # Output should be: {0: 0, 1: 1, 2: 2, 3: 3} ``` Implement the `shortest_path_dag` function based on the above specifications, efficiently finding the shortest paths from the start node to all other nodes in the DAG.","solution":"def shortest_path_dag(graph, start): Finds the shortest paths from the start node to all other nodes in a weighted DAG. def topological_sort(vertex, visited, stack): visited[vertex] = True if vertex in graph: for neighbor, _ in graph[vertex]: if not visited[neighbor]: topological_sort(neighbor, visited, stack) stack.insert(0, vertex) # Step 1: Perform a topological sort of the vertices visited = {key: False for key in graph} stack = [] for vertex in graph: if not visited[vertex]: topological_sort(vertex, visited, stack) # Step 2: Initialize distances to all vertices as infinite and distance to the source as 0 distances = {key: float(\\"inf\\") for key in graph} distances[start] = 0 # Step 3: Process vertices in topological order while stack: vertex = stack.pop(0) # Update distances of all adjacent vertices if distances[vertex] != float(\\"inf\\"): if vertex in graph: for neighbor, weight in graph[vertex]: if distances[vertex] + weight < distances[neighbor]: distances[neighbor] = distances[vertex] + weight # Remove distances to nodes that are not reachable from start return {node: distance for node, distance in distances.items() if distance != float(\\"inf\\")}"},{"question":"Task Question Creation for Coding Assessment Objective Analyze the provided sample question and create an additional question that aligns with the existing set in terms of style, complexity, and scope. Guidelines # Question Style - Carefully examine the format and presentation of the given questions. - Maintain a consistent tone and language used in the original set. # Question Length - Ensure your new question is of comparable length to the existing ones. - If the original questions vary in length, aim for the average length among them. # Difficulty Level - Assess the cognitive and technical challenges presented in the sample questions. - Match the complexity of concepts, algorithms, or programming techniques required. # Topic Alignment - Identify the core programming concepts or domains covered in the existing questions. - Create a question that explores a related or complementary area within the same general topic. # Question Uniqueness - While maintaining similarity, ensure your new question is not a mere rephrasing of an existing one. - Introduce a novel problem or scenario that tests the same skills in a different context. Output Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality. Output one new question only. Given an `n x m` grid filled with non-negative integers, find a path from the top-left corner to the bottom-right corner which minimizes the sum of the values along the path. You can only move either down or right at any point in time. Your function should return the minimum sum of the path from the top-left corner to the bottom-right corner of the grid. # Constraints: - The grid is a non-empty 2D list of non-negative integers. - The size of the grid is at most 100 x 100. # Example: ```python def min_path_sum(grid: List[List[int]]) -> int: pass # Example 1 print(min_path_sum([[1,3,1],[1,5,1],[4,2,1]])) # Output: 7 # Explanation: Course of path - 1→3→1→1→1→2→1 = 7 # Example 2 print(min_path_sum([[1,2,3],[4,5,6]])) # Output: 12 # Explanation: Course of path - 1→2→3→6 = 12 # Example 3 print(min_path_sum([[1,2],[5,6],[1,1]])) # Output: 8 # Explanation: Course of path - 1→2→6→1 = 10 ``` # Notes: - You are expected to implement the `min_path_sum` function. - Aim for clarity, efficiency, and correctness in your solution. - Consider edge cases and optimize where necessary.","solution":"def min_path_sum(grid): Finds the path with the minimum sum from top-left to bottom-right. You can only move right or down. Args: grid (List[List[int]]): 2D grid of non-negative integers. Returns: int: The sum of the minimal path. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Create a 2D dp array to store the minimum paths dp = [[0] * m for _ in range(n)] # Initializing the top-left corner dp[0][0] = grid[0][0] # Initialize first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"# Evaluate Arithmetic Expression Coding Assessment Question Context You are part of a development team responsible for implementing a mathematical engine used by a scientific calculator. As part of this engine, you need to evaluate arithmetic expressions provided by users accurately. Your task is to write a function that can evaluate an arithmetic expression given as a string. Description Write a function `evaluate_expression(expression: str) -> int` that calculates the result of a given arithmetic expression. The expression will only contain non-negative integers, `+`, `-`, `*`, and `/` operators, as well as parentheses `()` to specify operation precedence. # Input - A string representing a valid arithmetic expression. # Output - An integer representing the result of the arithmetic expression. # Constraints - The input string does not contain any invalid characters or malformed expressions. - The length of the input string is within the range `[1, 10^4]`. - Division is integer division which truncates towards zero. # Example ```python assert evaluate_expression(\\"3 + 5 * 2\\") == 13 assert evaluate_expression(\\"10 + 2 * 6\\") == 22 assert evaluate_expression(\\"100 * 2 + 12\\") == 212 assert evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 assert evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 ``` # Notes - Ensure your function handles operator precedence correctly, including parentheses. - Ensure your function can evaluate expressions efficiently within the given constraints. - You may assume that there are no spaces between characters unless they are part of the representation of parentheses. Implement the `evaluate_expression` function to achieve the above requirements.","solution":"import re def evaluate_expression(expression: str) -> int: Evaluates the arithmetic expression provided as a string and returns the result as an integer. Parameters: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the arithmetic expression. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Use int() for integer division truncating towards zero def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 # To handle spaces in the expression expression = expression.replace(\\" \\", \\"\\") i = 0 operators = [] values = [] while i < len(expression): if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"Coding Assessment Question # Objective Design and implement a function to manage a simple task scheduling system that avoids conflicts and ensures tasks are efficiently organized over a given timeframe. # Scenario You are working in a team managing a task scheduling system for multiple users. The system needs to assign tasks to users while avoiding any scheduling conflicts. Each task has a duration, and the system must make sure that no tasks overlap for any user. # Task Implement the function `schedule_tasks` with the following requirements: 1. **Input**: * A list of dictionaries, each representing a task with `user_id`, `task_id`, `start_time` (HH:MM), and `end_time` (HH:MM). 2. **Output**: * A list of dictionaries, each representing a scheduled task with `user_id`, `task_id`, and a list of time slots `[ (start_time, end_time) ]` that are conflict-free. 3. **Constraints**: * Tasks must not overlap for the same `user_id`. * If any task cannot be scheduled due to conflicts, it should be excluded from the output. * Ensure the function handles at least 1000 tasks efficiently. 4. **Performance Requirements**: * Optimize for both time and space complexity while ensuring accurate scheduling without conflicts. * Handle edge cases like same start and end times, invalid time formats, and overlapping multiple tasks robustly. # Constraints: * Time slots are provided in a 24-hour format. * Functions should handle time range between `00:00` and `23:59`. * Should use Python\'s datetime module for time parsing and comparisons. # Function Signature ```python from typing import List, Dict def schedule_tasks(tasks: List[Dict[str, str]]) -> List[Dict[str, object]]: ``` # Example ```python tasks = [ {\'user_id\': 1, \'task_id\': 101, \'start_time\': \'09:00\', \'end_time\': \'10:00\'}, {\'user_id\': 1, \'task_id\': 102, \'start_time\': \'10:00\', \'end_time\': \'11:00\'}, {\'user_id\': 2, \'task_id\': 201, \'start_time\': \'09:30\', \'end_time\': \'10:30\'}, {\'user_id\': 1, \'task_id\': 103, \'start_time\': \'09:30\', \'end_time\': \'10:30\'} ] scheduled_tasks = schedule_tasks(tasks) print(scheduled_tasks) ``` # Additional Task * Write test cases that verify your function\'s performance and correctness for various scenarios including overlapping tasks, edge cases of simultaneous tasks, and invalid input times. Ensure the tests include at least five different sets of input tasks.","solution":"from typing import List, Dict from datetime import datetime def schedule_tasks(tasks: List[Dict[str, str]]) -> List[Dict[str, object]]: def parse_time(time_str): return datetime.strptime(time_str, \\"%H:%M\\") def time_in_minutes(time_str): time = parse_time(time_str) return time.hour * 60 + time.minute # Dictionary to hold the sorted scheduled tasks per user user_schedules = {} for task in tasks: user_id = task[\'user_id\'] start_time = time_in_minutes(task[\'start_time\']) end_time = time_in_minutes(task[\'end_time\']) if end_time <= start_time: continue # Skip invalid tasks with incorrect time ranges if user_id not in user_schedules: user_schedules[user_id] = [] # Check for conflicts with existing tasks conflict_exists = any(s <= start_time < e or s < end_time <= e for s, e in user_schedules[user_id]) if not conflict_exists: user_schedules[user_id].append((start_time, end_time)) user_schedules[user_id].sort() result = [] for user_id, intervals in user_schedules.items(): user_tasks = { \'user_id\': user_id, \'tasks\': [{\'task_id\': task[\'task_id\'], \'time_slot\': (task[\'start_time\'], task[\'end_time\'])} for task in tasks if task[\'user_id\'] == user_id and (time_in_minutes(task[\'start_time\']), time_in_minutes(task[\'end_time\'])) in intervals] } result.append(user_tasks) return result"},{"question":"# Coding Problem: Valid Anagram Pairs You are given a list of strings and your task is to find all pairs of strings where both strings in each pair are anagrams of each other. Two strings are considered anagrams if and only if they contain the same characters in the same frequency. **Function Signature**: ```python def find_anagram_pairs(strings: list) -> list: ``` **Input**: * `strings` (list of str): A list containing n strings. **Output**: * (list of tuples): A list containing tuples, where each tuple has two strings that are anagrams of each other. **Constraints**: * The list can contain up to 1000 strings. * Each string contains only lowercase alphabetic characters (a-z). * Pair every anagram pair only once. For example, if you have (\'abc\', \'bca\') and (\'bca\', \'abc\'), only one of them should appear in the output. **Examples**: ```python assert find_anagram_pairs([]) == [] assert find_anagram_pairs([\'abc\']) == [] assert find_anagram_pairs([\'abc\', \'bca\']) == [(\'abc\', \'bca\')] assert find_anagram_pairs([\'abc\', \'bca\', \'xyz\', \'yxz\', \'zxy\']) == [(\'abc\', \'bca\'), (\'xyz\', \'yxz\'), (\'xyz\', \'zxy\'), (\'yxz\', \'zxy\')] assert find_anagram_pairs([\'abc\', \'def\', \'ghi\']) == [] ``` **Note**: Ensure you check all possible pairs and avoid duplicate anagram pairs in the result. **Hints**: * You may create a helper function to check if two strings are anagrams by comparing their sorted versions or by comparing character frequencies.","solution":"def find_anagram_pairs(strings): Given a list of strings, find all pairs of strings that are anagrams of each other. Args: strings (list of str): A list containing n strings. Returns: list of tuples: A list containing tuples, where each tuple has two strings that are anagrams of each other. # Helper function to check if two strings are anagrams def are_anagrams(s1, s2): return sorted(s1) == sorted(s2) anagram_pairs = [] length = len(strings) for i in range(length): for j in range(i + 1, length): if are_anagrams(strings[i], strings[j]): anagram_pairs.append((strings[i], strings[j])) return anagram_pairs"},{"question":"# Binary Search with Functional Enhancements Scenario: You are required to enhance the standard binary search algorithm with the following features: 1. **Flexibility with Custom Comparators**: Allow an optional custom comparator to compare elements. 2. **First and Last Occurrence**: Add parameters to find the first or last occurrence of the target element when duplicates are present. 3. **Inexact Match Handling**: Add a parameter to determine behavior when the exact target is not found (e.g., return nearest value). Task: Implement the function `enhanced_binary_search` with the following signature: ```python from typing import Callable, List, Optional, Union def enhanced_binary_search(collection: List[int], target: int, comparator: Optional[Callable[[int, int], bool]] = None, find_first: bool = False, find_last: bool = False, return_nearest: bool = False) -> Union[int, None] ``` * **Parameters**: - `collection`: A list of integers to be searched, assumed to be sorted. - `target`: The integer value to search for. - `comparator`: An optional custom comparator function that takes two integers and returns a boolean indicating their order. Default is standard comparison. - `find_first`: A boolean flag. If True, find the first occurrence of the target when duplicates are present. Default is False. - `find_last`: A boolean flag. If True, find the last occurrence of the target when duplicates are present. Default is False. - `return_nearest`: A boolean flag. If True, return the nearest value if the exact target is not found. Default is False. * **Returns**: - The index of the target element based on the given parameters, or the index of the nearest element if `return_nearest` is True and the target is not found. If `return_nearest` is False and the target is not found, return None. * **Constraints**: - The provided list can be empty or contain up to (10^5) integers. * **Example**: ```python # Example usage: enhanced_binary_search([1, 2, 3, 4, 5, 6], 4) # Returns: 3 enhanced_binary_search([1, 2, 3, 4, 5, 5, 6], 5, find_first=True) # Returns: 4 enhanced_binary_search([1, 2, 3, 4, 5, 5, 6], 5, find_last=True) # Returns: 5 enhanced_binary_search([1, 2, 3, 4, 6], 5, return_nearest=True) # Returns: 3 (index of 4, since 4 is the nearest value to 5) enhanced_binary_search([1, 2, 3, 4, 6], 5, comparator=lambda x, y: x % 10 < y % 10) # Returns: None (custom comparator may require specific conditions) ``` Note: - The implementation should maintain the efficiency of binary search while incorporating the requested features. - Consider edge cases and validate your implementation with various test cases, including empty lists, single-element lists, and lists with multiple identical elements.","solution":"from typing import Callable, List, Optional, Union def enhanced_binary_search(collection: List[int], target: int, comparator: Optional[Callable[[int, int], bool]] = None, find_first: bool = False, find_last: bool = False, return_nearest: bool = False) -> Union[int, None]: if not collection: return None def default_comparator(a, b): return a < b if comparator is None: comparator = default_comparator lo, hi = 0, len(collection) - 1 result = None nearest_index = None while lo <= hi: mid = (lo + hi) // 2 if collection[mid] == target: result = mid if find_first: hi = mid - 1 elif find_last: lo = mid + 1 else: return mid elif comparator(collection[mid], target): lo = mid + 1 nearest_index = mid else: hi = mid - 1 if nearest_index is None or (abs(collection[mid] - target) < abs(collection[nearest_index] - target)): nearest_index = mid if result is not None: return result if return_nearest and nearest_index is not None: return nearest_index return None"},{"question":"# Question: Second Largest Element in Array Given an array of integers, determine the second largest unique element in the array. If there is no such element (i.e., there is only one distinct element in the array or the array is empty), return `None`. **Function Signature**: ```python def find_second_largest(nums: List[int]) -> Optional[int]: pass ``` # Objectives: 1. Implement the `find_second_largest` function to find the second largest unique element in an array. 2. Handle potential edge cases, such as arrays with all identical elements or empty arrays. # Constraints: * The input array (`nums`) will contain at most 10^6 elements. * Each element in the array will be an integer within the range [-10^9, 10^9]. * The function should run within O(n) time complexity, where n is the length of the input array. # Example: ```python >>> find_second_largest([10, 5, 20, 8, 20]) 10 >>> find_second_largest([2, 1]) 1 >>> find_second_largest([5, 5, 5]) None >>> find_second_largest([7]) None >>> find_second_largest([]) None ``` # Guidelines: 1. Your solution should handle both large and small arrays efficiently. 2. Special cases such as arrays with all identical elements or arrays with less than two elements should be correctly managed by returning `None`. 3. Write clean and readable code with appropriate comments to explain your logic where necessary.","solution":"from typing import List, Optional def find_second_largest(nums: List[int]) -> Optional[int]: Find the second largest unique element in the array. If there is no such element, return None. if len(nums) < 2: return None first_largest, second_largest = None, None for num in nums: if first_largest is None or num > first_largest: second_largest = first_largest first_largest = num elif num != first_largest and (second_largest is None or num > second_largest): second_largest = num return second_largest"},{"question":"# Sorting an Array of Dates Scenario You are developing a scheduling tool that requires sorting a list of dates in ascending order. The dates are provided as strings in the format `YYYY-MM-DD` and you need to implement a function that sorts them accurately. Input and Output Requirements You need to implement the following function: 1. **`sort_dates(dates: list[str]) -> list[str]`**: * **Input**: A list of dates as strings in `YYYY-MM-DD` format. * **Output**: A list of dates sorted in ascending order. The function should validate that each date string is in proper format. If any date string is not in the correct format, an appropriate exception should be thrown. Example Usage and Expected Results ```python assert sort_dates([\\"2021-05-13\\", \\"2020-03-25\\", \\"2021-09-10\\"]) == [\\"2020-03-25\\", \\"2021-05-13\\", \\"2021-09-10\\"] assert sort_dates([\\"2022-12-01\\", \\"2021-12-01\\", \\"2022-01-20\\"]) == [\\"2021-12-01\\", \\"2022-01-20\\", \\"2022-12-01\\"] assert sort_dates([\\"2021-01-01\\", \\"2021-01-01\\"]) == [\\"2021-01-01\\", \\"2021-01-01\\"] # Test cases for invalid input try: sort_dates([\\"2020-13-25\\", \\"2021-09-10\\"]) except ValueError as e: assert str(e) == \\"Invalid date format in input\\" try: sort_dates([\\"2021-02-29\\"]) except ValueError as e: assert str(e) == \\"Invalid date in input\\" ``` Constraints * Each date string must follow the format `YYYY-MM-DD`. * The year part (YYYY) should be a four-digit number. * The month part (MM) should be between `01` and `12`. * The day part (DD) should be between `01` and `31` and must be valid for the given month and year. * If any date string is not formatted correctly, your function should raise a `ValueError` with an appropriate message (`\\"Invalid date format in input\\"` for format errors, `\\"Invalid date in input\\"` for invalid dates). This question assesses your ability to manipulate and validate strings, handle errors appropriately, and use common algorithms to sort data.","solution":"from datetime import datetime def sort_dates(dates): Returns a list of dates sorted in ascending order. Args: dates (list of str): List of dates in YYYY-MM-DD format. Returns: list of str: Sorted list of dates. Raises: ValueError: If any date string is not in proper format or is invalid. # Validate each date for date_str in dates: try: datetime.strptime(date_str, \'%Y-%m-%d\') except ValueError as e: if \\"does not match format\\" in str(e): raise ValueError(\\"Invalid date format in input\\") else: raise ValueError(\\"Invalid date in input\\") # Use sorted with a sorting key to sort the dates sorted_dates = sorted(dates, key=lambda date: datetime.strptime(date, \'%Y-%m-%d\')) return sorted_dates"},{"question":"# Problem Statement You are provided with a list of integers and tasked with performing two types of operations: reversing a segment of the list between two specified indices and sorting the entire list in non-decreasing order. Implement the segment reversing function `reverse_segment` and the sorting function `sort_list`, adhering to the specifications and constraints provided below. Function 1: `reverse_segment` Implement the function `reverse_segment` that takes a list of integers and two position indices, then reverses the segment of the list between those indices (inclusive). ```python def reverse_segment(arr: list[int], start: int, end: int) -> list[int]: ``` **Parameters**: - `arr` (list of int): The list of integers. - `start` (int): The starting index of the segment to reverse. - `end` (int): The ending index of the segment to reverse. **Returns**: - `list of int`: The list with the specified segment reversed. **Example**: ```python arr = [1, 2, 3, 4, 5, 6] arr = reverse_segment(arr, 1, 4) print(arr) # Output: [1, 5, 4, 3, 2, 6] ``` Function 2: `sort_list` Implement the function `sort_list` that takes a list of integers and sorts it in non-decreasing order. ```python def sort_list(arr: list[int]) -> list[int]: ``` **Parameters**: - `arr` (list of int): The list of integers. **Returns**: - `list of int`: The list sorted in non-decreasing order. **Example**: ```python arr = [5, 3, 2, 6, 4, 1] sorted_arr = sort_list(arr) print(sorted_arr) # Output: [1, 2, 3, 4, 5, 6] ``` Constraints * The list length will not exceed 10^4. * The `start` and `end` indices for `reverse_segment` will always be valid (0 ≤ start ≤ end < len(arr)). * Handle edge cases appropriately, such as empty lists or lists with a single element. Additional Requirements 1. Ensure your code handles large inputs efficiently. 2. Include appropriate error handling to manage the constraints effectively.","solution":"def reverse_segment(arr, start, end): Reverses the segment of the list arr between indices start and end (inclusive). Parameters: - arr: list of integers - start: starting index of the segment to reverse - end: ending index of the segment to reverse Returns: - list of integers with the specified segment reversed if not arr or start < 0 or end >= len(arr) or start > end: return arr # Reverse the segment between start and end arr[start:end + 1] = arr[start:end + 1][::-1] return arr def sort_list(arr): Sorts the list arr in non-decreasing order. Parameters: - arr: list of integers Returns: - list of integers sorted in non-decreasing order return sorted(arr)"},{"question":"# Scenario You are managing a logistics company and need to develop a software solution to optimize the delivery routes. The goal is to ensure that each delivery vehicle starts from the warehouse, visits a set of designated delivery points, and returns to the warehouse. The route should be optimized for the shortest possible distance traveled. # Problem Statement Implement a function `optimize_route(warehouse: Tuple[int, int], deliveries: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that takes the coordinates of the warehouse and a list of delivery points, and returns the optimal route that minimizes the total distance traveled. The optimal route should start and end at the warehouse. # Specifications * **Input**: * `warehouse`: A tuple of two integers representing the coordinates (x, y) of the warehouse. * `deliveries`: A list of tuples, each containing two integers representing the coordinates (x, y) of each delivery point. * **Output**: A list of tuples representing the coordinates of the warehouse and delivery points in the order they should be visited for the shortest route. * **Constraints**: * There will be at most 15 delivery points. * The coordinates will be integers within the range [-1000, 1000]. * **Performance**: Aim to achieve an optimized route using techniques such as dynamic programming (e.g., the traveling salesman problem) for enhanced performance. # Example ```python warehouse = (0, 0) deliveries = [(2, 3), (6, 1), (3, 4)] route = optimize_route(warehouse, deliveries) print(route) # Expected output: [(0, 0), (2, 3), (3, 4), (6, 1), (0, 0)] or other optimal variants warehouse = (5, 5) deliveries = [(1, 2), (7, 8), (3, 4), (9, 6)] route = optimize_route(warehouse, deliveries) print(route) # Expected output: [(5, 5), (3, 4), (1, 2), (9, 6), (7, 8), (5, 5)] or other optimal variants ``` # Bonus Implement additional features to handle constraints such as time windows for delivery points or different vehicle capacities, optimizing the route accordingly.","solution":"from itertools import permutations from typing import List, Tuple def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points. return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5 def total_distance(route: List[Tuple[int, int]]) -> float: Calculate the total distance of the given route. distance = 0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) return distance def optimize_route(warehouse: Tuple[int, int], deliveries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Optimizes the delivery route to minimize the total distance traveled. all_points = [warehouse] + deliveries min_distance = float(\'inf\') best_route = [] for perm in permutations(deliveries): current_route = [warehouse] + list(perm) + [warehouse] current_distance = total_distance(current_route) if current_distance < min_distance: min_distance = current_distance best_route = current_route return best_route"},{"question":"# Question: Implement K-Means Clustering and Silhouette Score You are given a dataset with multiple features. Write code to implement the K-Means clustering algorithm and compute the silhouette score to evaluate the clustering performance. The silhouette score should be calculated for a range of cluster numbers to determine the optimal number of clusters. Requirements: 1. Implement the `k_means_clustering()` function to perform K-Means clustering. 2. Implement the `compute_silhouette_score()` function to calculate the silhouette score for each data point. 3. Implement the `optimal_clusters()` function to find the range of cluster numbers and determine the one with the highest average silhouette score. Function Signature: ```python def k_means_clustering(features: np.ndarray, num_clusters: int, max_iters: int=300) -> Tuple[np.ndarray, np.ndarray]: def compute_silhouette_score(features: np.ndarray, labels: np.ndarray) -> float: def optimal_clusters(features: np.ndarray, cluster_range: List[int]) -> int: ``` Input: - `features`: 2D NumPy array of shape `(n_samples, n_features)` - `num_clusters`: Integer, number of clusters to form (only for `k_means_clustering`) - `max_iters`: Integer, maximum number of iterations for the K-Means algorithm (only for `k_means_clustering`, default is 300) - `labels`: 1D NumPy array of integers of shape `(n_samples,)` representing cluster labels (only for `compute_silhouette_score`) - `cluster_range`: List of integers specifying different numbers of clusters to evaluate (only for `optimal_clusters`) Output: - `k_means_clustering`: Tuple containing: - `centroids`: 2D NumPy array of shape `(num_clusters, n_features)` - `cluster_labels`: 1D NumPy array of shape `(n_samples,)` representing the index of the cluster each sample belongs to - `compute_silhouette_score`: Float representing the average silhouette score. - `optimal_clusters`: Integer representing the optimal number of clusters. Constraints: 1. `num_clusters` should be greater than 1 and less than or equal to the number of `features`. 2. The `cluster_range` should only contain values greater than 1. 3. Ensure the functions handle edge cases and optimize for performance. Example: ```python import numpy as np from typing import List, Tuple # Sample features features = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0]]) def k_means_clustering(features: np.ndarray, num_clusters: int, max_iters: int = 300) -> Tuple[np.ndarray, np.ndarray]: # Your implementation here pass def compute_silhouette_score(features: np.ndarray, labels: np.ndarray) -> float: # Your implementation here pass def optimal_clusters(features: np.ndarray, cluster_range: List[int]) -> int: # Your implementation here pass # Get the K-Means clustering result centroids, cluster_labels = k_means_clustering(features, 3) print(\'Centroids:\', centroids) print(\'Cluster Labels:\', cluster_labels) # Calculate the silhouette score silhouette_score = compute_silhouette_score(features, cluster_labels) print(\'Silhouette Score:\', silhouette_score) # Determine the optimal number of clusters optimal_num = optimal_clusters(features, [2, 3, 4, 5]) print(\'Optimal Number of Clusters:\', optimal_num) ``` Note: Implement the details of `k_means_clustering()`, `compute_silhouette_score()`, and `optimal_clusters()` functions to achieve the required behavior. Ensure proper handling of edge cases and optimize the code for performance.","solution":"import numpy as np from typing import List, Tuple from scipy.spatial.distance import cdist from sklearn.metrics import silhouette_score def k_means_clustering(features: np.ndarray, num_clusters: int, max_iters: int = 300) -> Tuple[np.ndarray, np.ndarray]: Perform K-Means clustering Args: features: 2D NumPy array of shape (n_samples, n_features) num_clusters: Integer, number of clusters to form max_iters: Integer, maximum number of iterations Returns: centroids: 2D NumPy array of shape (num_clusters, n_features) cluster_labels: 1D NumPy array of shape (n_samples,) n_samples, n_features = features.shape centroids = features[np.random.choice(n_samples, num_clusters, replace=False), :] for _ in range(max_iters): distances = cdist(features, centroids, \'euclidean\') cluster_labels = np.argmin(distances, axis=1) new_centroids = np.array([features[cluster_labels == j].mean(axis=0) for j in range(num_clusters)]) if np.all(new_centroids == centroids): break centroids = new_centroids return centroids, cluster_labels def compute_silhouette_score(features: np.ndarray, labels: np.ndarray) -> float: Calculate the silhouette score for clustering Args: features: 2D NumPy array of shape (n_samples, n_features) labels: 1D NumPy array of shape (n_samples,) Returns: float: Average silhouette score return silhouette_score(features, labels) def optimal_clusters(features: np.ndarray, cluster_range: List[int]) -> int: Find the optimal number of clusters by calculating the silhouette scores for a range of clusters Args: features: 2D NumPy array of shape (n_samples, n_features) cluster_range: List of integers specifying different numbers of clusters to evaluate Returns: int: Optimal number of clusters best_score = -1 best_k = cluster_range[0] for k in cluster_range: _, labels = k_means_clustering(features, k) score = compute_silhouette_score(features, labels) if score > best_score: best_score = score best_k = k return best_k"},{"question":"# Question: Implement a Smoothing Function for Time Series Data Context In data analysis, especially when dealing with time series data, smoothing techniques are used to reduce noise and better identify trends. One common method is the exponential moving average (EMA), which applies more weight to recent observations. Your task is to implement a custom smoothing function using EMA and validate its correctness. Task Implement a function `exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray` that computes the exponential moving average of a given time series data. Requirements 1. **Function Signature**: ```python def exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray: ``` 2. **Inputs**: - `data`: A numpy array of floating-point numbers representing the time series data. - `alpha`: A float between 0 and 1 (exclusive), representing the smoothing factor. 3. **Output**: - A numpy array of the same length as the input data, representing the smoothed time series. 4. **Constraints**: - The input array `data` must not be empty. - The smoothing factor `alpha` must be strictly between 0 and 1. 5. **Edge Cases**: - If `data` has only one element, the function should return the same array. - Ensure appropriate handling of boundary values for `alpha`. Examples ```python >>> data = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> alpha = 0.5 >>> exponential_moving_average(data, alpha) array([1.0, 1.5, 2.25, 3.125, 4.0625]) >>> data = np.array([1.0]) >>> alpha = 0.5 >>> exponential_moving_average(data, alpha) array([1.0]) >>> data = np.array([]) >>> alpha = 0.5 >>> exponential_moving_average(data, alpha) Traceback (most recent call last): ... ValueError: Input array \'data\' cannot be empty. ``` Note: Implementing the smoothing function correctly involves using the exponential moving average formula, which you are expected to research and apply properly.","solution":"import numpy as np def exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray: Computes the exponential moving average of a given time series data. Parameters: - data (np.ndarray): A numpy array of floating-point numbers representing the time series data. - alpha (float): A float between 0 and 1 (exclusive), representing the smoothing factor. Returns: - np.ndarray: A numpy array of the same length as the input data, representing the smoothed time series. if not (0 < alpha < 1): raise ValueError(\\"Alpha must be strictly between 0 and 1.\\") if data.size == 0: raise ValueError(\\"Input array \'data\' cannot be empty.\\") ema = np.empty_like(data) ema[0] = data[0] for i in range(1, len(data)): ema[i] = alpha * data[i] + (1 - alpha) * ema[i - 1] return ema"},{"question":"# Graph Question: Analyzing Communication Nodes You are given a directed graph representing a communication network, where nodes are devices and edges represent one-way communication channels between them. One important aspect of this network is determining whether every device can eventually communicate with all other devices, either directly or through other devices. Given the adjacency list representation of the graph, determine if the graph is \\"strongly connected\\" (i.e., every device can reach every other device). **Function Signature**: `def is_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool:` # Input: - An integer `n` denoting the number of nodes where (1 leq n leq 10^5). - A list of tuples `edges` where each tuple `(a, b)` represents a directed edge from node `a` to node `b` in the graph. Each node is zero-indexed. # Output: - A boolean: `True` if the graph is strongly connected, `False` otherwise. # Example: ```python >>> is_strongly_connected(4, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 1)]) True >>> is_strongly_connected(4, [(0, 1), (1, 2), (2, 3)]) False ``` # Constraints: - Each node index `a` and `b` will satisfy (0 leq a, b < n). - Use graph traversal algorithms such as DFS or BFS to determine reachability. - Ensure the implementation is efficient for the upper limits of the input size. # Performance Requirements: - The solution should be able to handle the time and space complexity associated with graphs containing up to (10^5) nodes efficiently.","solution":"from typing import List, Tuple def is_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool: from collections import defaultdict, deque def build_graph(n, edges): graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) return graph, reverse_graph def bfs(start, graph): visited = [False] * n queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited # Build original and reverse graphs graph, reverse_graph = build_graph(n, edges) # Check reachability from node 0 in the original graph if not all(bfs(0, graph)): return False # Check reachability from node 0 in the reversed graph if not all(bfs(0, reverse_graph)): return False return True"},{"question":"# Coding Problem: Optimal Delivery Path for Parcels Context: Logistics companies often face the challenge of optimizing delivery routes to ensure timely and cost-efficient parcel deliveries. They must determine the shortest path through a series of stops while considering various constraints such as road conditions and delivery deadlines. Task: Write a function `find_optimal_delivery_path(start, delivery_locations, road_conditions)` that: 1. Determines the optimal path for delivering parcels starting from the `start` location and covering all `delivery_locations`. 2. Evaluates the road conditions and computes the minimum total cost and time required for completing the delivery. 3. Returns the minimum total cost and the sequence of locations to be visited. **Functions to Implement**: 1. **calculate_delivery_costs**: This function builds and returns the `cost` and `time` tables based on road conditions and distances. 2. **derive_optimal_path**: This function uses the `cost` and `time` tables to reconstruct the sequence of locations that minimizes either the cost or time. 3. **find_optimal_delivery_path**: This function integrates the computation and reconstruction steps to return the desired results. # Example: ```python def find_optimal_delivery_path( start: str, delivery_locations: list[str], road_conditions: dict[tuple[str, str], tuple[int, int]] ) -> tuple[int, list[str]]: # Write your implementation here. pass ``` Given: ```python road_conditions = { (\\"A\\", \\"B\\"): (3, 15), # (cost, time) (\\"A\\", \\"C\\"): (5, 10), (\\"B\\", \\"C\\"): (2, 5), (\\"B\\", \\"D\\"): (6, 20), (\\"C\\", \\"D\\"): (4, 10) } ``` For the input: ```python find_optimal_delivery_path(\\"A\\", [\\"B\\", \\"C\\", \\"D\\"], road_conditions) ``` Expected Output: ```python (9, [\'A\', \'B\', \'C\', \'D\']) ``` Constraints: * Number of delivery locations (1 ≤ n ≤ 100). * Values of cost and time (1 ≤ value ≤ 1000). * Roads between locations ensure at least one valid path exists connecting all delivery points. Performance Requirements: - Ensure the solution is efficient and can handle the upper limit of delivery locations and road conditions. - Handle edge cases, including potential loops or large graphs. Implementation Notes: - Use graph traversal algorithms such as Dijkstra\'s or A* for finding the shortest path. - Accurately derive the path that minimizes the total cost and returns the exact visiting sequence. - The function must efficiently handle the given constraints to provide optimal results.","solution":"import heapq def calculate_delivery_costs(start, road_conditions): # Initialize cost and time tables cost = {start: 0} time = {start: 0} pq = [(0, 0, start)] # priority queue: (current_cost, current_time, current_node) while pq: current_cost, current_time, current_node = heapq.heappop(pq) for (u, v), (c, t) in road_conditions.items(): if u == current_node: if v not in cost or current_cost + c < cost[v]: cost[v] = current_cost + c time[v] = current_time + t heapq.heappush(pq, (cost[v], time[v], v)) elif v == current_node: if u not in cost or current_cost + c < cost[u]: cost[u] = current_cost + c time[u] = current_time + t heapq.heappush(pq, (cost[u], time[u], u)) return cost, time def derive_optimal_path(start, delivery_locations, road_conditions, cost): path = [start] current_node = start while delivery_locations: next_node = min(delivery_locations, key=lambda x: cost[x]) path.append(next_node) delivery_locations.remove(next_node) current_node = next_node return path def find_optimal_delivery_path(start, delivery_locations, road_conditions): delivery_set = set(delivery_locations) cost, time = calculate_delivery_costs(start, road_conditions) path = derive_optimal_path(start, delivery_locations, road_conditions, cost) total_cost = sum(road_conditions[(u, v)][0] for u, v in zip(path, path[1:])) return total_cost, path"},{"question":"# Coding Challenge: You are given an array of integers representing the heights of buildings aligned in a row. Each building\'s width is 1 unit. Your task is to write a function that calculates the maximum amount of water that could be trapped between these buildings after it rains. The water is trapped between the buildings and is determined by the shorter of the two heights on either side of the trapped water. **Function Signature**: ```python def max_trapped_water(heights: List[int]) -> int: # Your code here ``` **Input**: - `heights`: A list containing integers, representing the height of buildings. The length of `heights` is `N` where `1 <= N <= 10^4` and `0 <= heights[i] <= 10^5`. **Output**: - Returns the maximum amount of water that can be trapped. **Constraints**: - The array may contain negative numbers, but heights[i] will always be non-negative. **Example Input and Output**: ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(max_trapped_water(heights)) # Expected output -> 6 ``` **Explanation**: The array represents the following elevation map: ``` | _ | _ | |_ | _ | | | | |_ | | | | _ _ | |_| | |_|_ |_|_|_|_|_|_|_| ``` - Buildings with heights `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` - The maximum amount of water can be trapped between the heights at indices [1, 11] and it equals 6 units. **Requirements**: - Implement the function efficiently with consideration for time complexity. - Avoid using additional libraries or built-in complex functions.","solution":"from typing import List def max_trapped_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"# Problem Statement Objective Write a program in any language of your choice that generates the nth number in the Fibonacci sequence. Implement the solution using both an iterative and a recursive approach within the same program. Motivation This task assesses your understanding of the Fibonacci sequence, recursion, and iteration concepts, and demonstrates your ability to implement them in a chosen programming language. # Requirements 1. **Input**: An integer ( n ) where ( 1 leq n leq 40 ). 2. **Output**: The nth Fibonacci number calculated using both iterative and recursive methods. # Constraints - You must implement both approaches in the same program. - The program should handle ( n ) values efficiently within the constraints. - The result should be identical for both methods. # Performance - Ensure the recursive method handles up to ( n = 40 ) within a reasonable time frame. - Ensure the iterative method performs efficiently for all valid ( n ) values. # Specification Example If you were to solve this in Python, a valid program might resemble: ```python def fib_iterative(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b return a def fib_recursive(n): if n == 0: return 0 elif n == 1: return 1 else: return fib_recursive(n-1) + fib_recursive(n-2) n = 10 print(\\"Iterative:\\", fib_iterative(n)) print(\\"Recursive:\\", fib_recursive(n)) ``` In this example, if ( n = 10 ), the output should be `Iterative: 55` and `Recursive: 55`. Notes - Consider edge cases such as the smallest and largest values within the input range to ensure robustness. - The language you choose may have different syntax and methods for handling recursion and iteration efficiently. - You are encouraged to explore and test your solution to ensure both methods produce the same result accurately.","solution":"def fib_iterative(n): Returns the nth Fibonacci number using an iterative approach. a, b = 0, 1 for _ in range(n): a, b = b, a + b return a def fib_recursive(n): Returns the nth Fibonacci number using a recursive approach. if n == 0: return 0 elif n == 1: return 1 else: return fib_recursive(n - 1) + fib_recursive(n - 2) def get_fibonacci_number(n): Returns the nth Fibonacci number using both iterative and recursive methods. return fib_iterative(n), fib_recursive(n)"},{"question":"# Question **Problem Statement**: You are provided with a List of integers that represent grades of students. The task is to group these grades into categories and compute the count of grades in each category. The categories are defined as follows: - A: Grades >= 90 - B: 80 <= Grades < 90 - C: 70 <= Grades < 80 - D: 60 <= Grades < 70 - F: Grades < 60 **Objective**: 1. Write a function called `categorize_grades(grades: list[int]) -> dict` that takes a list of integers (grades) and returns a dictionary where the keys are the grade categories (\'A\', \'B\', \'C\', \'D\', \'F\') and the values are the counts of grades in each category. **Constraints**: - Each grade in the input list will be an integer between 0 and 100, inclusive. - The input list can be empty. - The function should return an empty dictionary if no grades are provided. **Input**: - A list of integers (grades) for the `categorize_grades` function. **Output**: - A dictionary where keys are grade categories and values are the count of grades in each category. **Examples**: 1. `categorize_grades([92, 85, 77, 65, 58, 90, 81, 72, 60, 89])` should return ```python { \'A\': 2, \'B\': 3, \'C\': 2, \'D\': 2, \'F\': 1 } ``` 2. `categorize_grades([88, 59, 100, 45, 78, 90, 82, 67, 92, 88])` should return ```python { \'A\': 3, \'B\': 3, \'C\': 1, \'D\': 1, \'F\': 2 } ``` 3. `categorize_grades([50, 55, 60, 65, 70])` should return ```python { \'A\': 0, \'B\': 0, \'C\': 1, \'D\': 2, \'F\': 2 } ``` 4. `categorize_grades([])` should return ```python { } ``` This will test your ability to handle lists, conditions, and dictionary operations in Python. Your solution should handle edge cases and input validation appropriately.","solution":"def categorize_grades(grades): Categorize a list of grades into predefined categories and return the count of grades in each category. - A: Grades >= 90 - B: 80 <= Grades < 90 - C: 70 <= Grades < 80 - D: 60 <= Grades < 70 - F: Grades < 60 Args: grades (list of int): A list of integer grades. Returns: dict: A dictionary with grade categories as keys and counts as values. # Define the categories categories = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0} # Iterate through the grades and categorize them for grade in grades: if grade >= 90: categories[\'A\'] += 1 elif grade >= 80: categories[\'B\'] += 1 elif grade >= 70: categories[\'C\'] += 1 elif grade >= 60: categories[\'D\'] += 1 else: categories[\'F\'] += 1 # Filter out categories with zero counts (if such behavior is desired) categories = {k: v for k, v in categories.items() if v > 0} return categories"},{"question":"# Problem Statement You are tasked with writing a function `longest_consecutive_subarray` that finds the length of the longest subarray consisting of the same element from a given list of integers. # Function Signature ```python def longest_consecutive_subarray(arr: List[int]) -> int: ``` # Input * A list of integers `arr` where the length of the list is (0 leq text{len}(arr) leq 10^5). # Output * An integer representing the length of the longest subarray consisting of the same element. # Constraints * The function should handle cases where the array is empty. * The function should handle the largest subarray length efficiently. * The function should raise appropriate errors for non-list inputs. # Performance Requirements * Time complexity: O(n) * Space complexity: O(1) # Edge Cases & Error Handling * If the input is not a list, raise a `TypeError`. * If any element of the list is not an integer, raise a `ValueError`. # Example 1. Example 1: ```python longest_consecutive_subarray([1, 1, 2, 2, 2, 3, 1]) ``` Expected Output: ```python 3 ``` 2. Example 2: ```python longest_consecutive_subarray([1, 1, 1, 1, 1]) ``` Expected Output: ```python 5 ``` 3. Edge Case 1: ```python longest_consecutive_subarray([]) ``` Expected Output: ```python 0 ``` 4. Edge Case 2: ```python longest_consecutive_subarray(\\"12345\\") ``` Expected Output: ```python TypeError: \'str\' object is not iterable ``` 5. Edge Case 3: ```python longest_consecutive_subarray([1, 1, \'2\', 2, 2, 3, 1]) ``` Expected Output: ```python ValueError: All elements must be integers ``` Write the `longest_consecutive_subarray` function to solve the above problem statement.","solution":"from typing import List def longest_consecutive_subarray(arr: List[int]) -> int: if not isinstance(arr, list): raise TypeError(\\"Input should be a list\\") for element in arr: if not isinstance(element, int): raise ValueError(\\"All elements must be integers\\") if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"# Linked List Intersection Detection In this exercise, you are required to write a function to determine if two linked lists intersect. The intersection is defined based on the reference, not the value of the nodes. That is, if two linked lists have some nodes in common by reference, they intersect. Consider the following linked lists as an example: ``` List A: 1 -> 2 → 6 -> 7 -> 8 List B: 3 / ``` The two linked lists intersect at node with value 6. # Requirements: * **Function Name**: `get_intersection_node` * **Input**: Two `ListNode` objects representing the heads of the two linked lists. * **Output**: A `ListNode` object representing the intersection node or `None` if the lists do not intersect. * **Constraints**: * The total number of nodes across both lists is in the range [0, 10^4]. * `ListNode` data values will be of integer type. * **Performance**: * The function should have a time complexity of (O(n + m)), where (n) and (m) are the lengths of the two linked lists. * The space complexity should be (O(1)). You should handle the edge case where either or both input lists are `None` (no intersection). **Function Signature**: ```python def get_intersection_node(headA: ListNode | None, headB: ListNode | None) -> ListNode | None: pass ``` # Example ```python # Example input lists # List A: 1 -> 2 -> 6 -> 7 -> 8 # List B: 3 -> 6 -> 7 -> 8 # Example usage headA = ListNode(1) headA.next = ListNode(2) common = ListNode(6) common.next = ListNode(7) common.next.next = ListNode(8) headA.next.next = common headB = ListNode(3) headB.next = common print(get_intersection_node(headA, headB).val) # Output: 6 ``` **Tip**: You can use two pointers for an efficient solution. Iterate over both lists, and once you reach the end of one list, continue from the start of the other list. This way, both pointers will meet at the intersection node after at most `n + m` operations if an intersection exists. # Notes * You may assume the given `ListNode` class and list creation functions are available to you. * Your solution will be tested for performance efficiency and correctness. * Write your solution with clarity and ensure to comment your code where necessary.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode | None, headB: ListNode | None) -> ListNode | None: if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA is not pointerB: # Move to the next nodes or switch lists pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"# Coding Question Context You\'re working on an event scheduling system where a set of events need to be managed. Each event is represented by a start time and an end time. The system should be able to find the maximum number of non-overlapping events that can be attended. Problem Statement Implement a function `max_non_overlapping_events` that takes a list of events (tuples), where each tuple contains the start and end time of an event, and returns the maximum number of non-overlapping events that can be attended. ```python def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list of events where each event is represented as a tuple (start_time, end_time). Returns: int: The maximum number of non-overlapping events that can be attended. pass ``` # Constraints 1. Each event is represented as a tuple `(start_time, end_time)` with `0 <= start_time < end_time <= 10^9`. 2. The list of events can have up to `10^5` events. 3. Two events `(s1, e1)` and `(s2, e2)` are non-overlapping if and only if `(e1 <= s2)` or `(e2 <= s1)`. Example ```python events = [(1, 3), (2, 4), (3, 5), (7, 8)] # The maximum number of non-overlapping events is 3 # The selected events could be [(1, 3), (3, 5), (7, 8)], so the output should be 3. assert max_non_overlapping_events(events) == 3 events = [(1, 2), (2, 3), (3, 4), (4, 5)] # All events are non-overlapping assert max_non_overlapping_events(events) == 4 ``` # Performance Requirements The function should aim for an optimal solution with a time complexity of O(n log n) where `n` is the number of events.","solution":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list of events where each event is represented as a tuple (start_time, end_time). Returns: int: The maximum number of non-overlapping events that can be attended. # Sort the events by their end time events.sort(key=lambda x: x[1]) count = 0 last_end = float(\'-inf\') # Iterate through the sorted events for start, end in events: # If the event does not overlap with the previous one, attend it if start >= last_end: count += 1 last_end = end return count"},{"question":"# Question You are asked to develop a feature for a bookstore\'s inventory management system. This feature will compute and return the total value of all books in the inventory based on their stock and price. Additionally, the feature must provide the ability to restock books, adjust their prices, and retrieve summary information about the inventory. Implement a class `Bookstore` with the following methods: Method 1: `__init__` * **Input**: None * **Initialization**: Initializes an empty dictionary to store book details, where each key is a string representing the book\'s title and the value is another dictionary containing keys: \\"stock\\" and \\"price\\". Method 2: `add_book` * **Input**: A string `title`, an integer `stock`, and a float `price`. * **Output**: None * **Behavior**: Adds a new book to the inventory with the given title, stock, and price. If the book already exists, it updates the stock and price. Method 3: `update_stock` * **Input**: A string `title` and an integer `stock_change`. * **Output**: None * **Behavior**: Adjusts the stock of the specified book by the given `stock_change`. If the book doesn\'t exist, it should raise a `ValueError`. Method 4: `update_price` * **Input**: A string `title` and a float `new_price`. * **Output**: None * **Behavior**: Updates the price of the specified book. If the book doesn\'t exist, it should raise a `ValueError`. Method 5: `get_total_value` * **Input**: None * **Output**: A float representing the total value of all books in the inventory. * **Behavior**: Computes and returns the total value of all books, which is the sum of `price * stock` for each book. Method 6: `get_inventory_summary` * **Input**: None * **Output**: A list of dictionaries, where each dictionary contains the \\"title\\", \\"stock\\", and \\"price\\" of a book. * **Behavior**: Returns a summary of all books in the inventory. **Example Usage**: ```python store = Bookstore() store.add_book(\\"The Great Gatsby\\", 5, 9.99) store.add_book(\\"1984\\", 3, 14.99) store.update_stock(\\"The Great Gatsby\\", 2) store.update_price(\\"1984\\", 12.99) assert store.get_total_value() == (7 * 9.99 + 3 * 12.99) assert store.get_inventory_summary() == [ {\\"title\\": \\"The Great Gatsby\\", \\"stock\\": 7, \\"price\\": 9.99}, {\\"title\\": \\"1984\\", \\"stock\\": 3, \\"price\\": 12.99} ] ``` Create this class and demonstrate its functionality by implementing all methods and a `main` function to show its usage.","solution":"class Bookstore: def __init__(self): self.inventory = {} def add_book(self, title, stock, price): self.inventory[title] = { \\"stock\\": stock, \\"price\\": price } def update_stock(self, title, stock_change): if title in self.inventory: self.inventory[title][\\"stock\\"] += stock_change else: raise ValueError(f\\"Book titled \'{title}\' not found in inventory.\\") def update_price(self, title, new_price): if title in self.inventory: self.inventory[title][\\"price\\"] = new_price else: raise ValueError(f\\"Book titled \'{title}\' not found in inventory.\\") def get_total_value(self): total_value = 0 for book in self.inventory.values(): total_value += book[\\"price\\"] * book[\\"stock\\"] return total_value def get_inventory_summary(self): summary = [] for title, details in self.inventory.items(): summary.append({ \\"title\\": title, \\"stock\\": details[\\"stock\\"], \\"price\\": details[\\"price\\"] }) return summary"},{"question":"# Coding Assessment Question Scenario A company is developing a tool to help users check the validity of their passwords according to specific security rules. The tool will help ensure that users\' passwords are strong and difficult to guess. Task Implement the `is_valid_password` function that checks the strength of a given password based on the following criteria: 1. The password must be at least 8 characters long. 2. The password must contain at least one uppercase letter, one lowercase letter, one number, and one special character from the set `!@#%^&*()-+`. Requirements - The function should take one input, a string `password`. - Return `True` if the password meets all criteria, otherwise return `False`. Input Format: - A single string `password` that may include any printable ASCII characters. Output Format: - A boolean value `True` if the password is valid, `False` otherwise. Constraints: - Assume the length of the string is at most ( 100 ) characters. - The input string may contain any printable ASCII characters. Example: ``` Input: \\"Aa1!bcdef\\" Output: True Input: \\"password\\" Output: False Input: \\"Aa1!bc\\" Output: False Input: \\"Aa1BcDeFg\\" Output: False ``` Function Signature: ```python def is_valid_password(password: str) -> bool: pass ``` **Hint**: Consider using regular expressions or a combination of checking each character in a loop. Good luck!","solution":"def is_valid_password(password: str) -> bool: if len(password) < 8: return False has_upper = False has_lower = False has_digit = False has_special = False special_chars = \\"!@#%^&*()-+\\" for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_chars: has_special = True return has_upper and has_lower and has_digit and has_special"},{"question":"# Coding Assessment Question You are given a function `optimize_route` that determines the shortest path between two points in a weighted directed graph representing a city\'s transportation network. This function adheres to Dijkstra\'s algorithm for shortest path calculation and includes validation to ensure no negative cycle exists. The `optimize_route` function returns the shortest path distance and the actual path taken in list form. Write a function named `enhanced_optimize_route` that extends the `optimize_route` function to handle multiple routes between various points within the city. The new function should take a list of route requests, each containing a start point and an endpoint, and then compute the shortest path for each route request using the underlying graph. The results should be returned in a dictionary mapping route indices to their respective distances and paths. Function Signature: ```python def enhanced_optimize_route(graph: dict[str, dict[str, int]], route_requests: list[tuple[str, str]]) -> dict[int, dict[str, object]]: pass ``` # Requirements - **Parameters**: - `graph`: A dictionary representing the weighted directed graph, where keys are node identifiers, and values are dictionaries of neighboring nodes and edge weights. - `route_requests`: A list of tuples, where each tuple contains two strings representing the start and end points of the requested routes. - **Returns**: - A dictionary where keys are route request indices (starting from 0) and values are dictionaries containing the shortest path distance (`distance`: int) and the actual path (`path`: list of strings). - **Constraints**: - The graph contains at least two nodes. - Each route request specifies different valid nodes within the graph. - There must be a valid path from each start point to each end point in the route requests. - All node identifiers and edge weights are non-negative integers. # Examples 1. ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } route_requests = [(\'A\', \'D\'), (\'B\', \'C\')] enhanced_optimize_route(graph, route_requests) ``` Should return: ``` { 0: {\'distance\': 4, \'path\': [\'A\', \'B\', \'C\', \'D\']}, 1: {\'distance\': 2, \'path\': [\'B\', \'C\']} } ``` 2. ```python graph = { \'X\': {\'Y\': 7, \'Z\': 1}, \'Y\': {\'Z\': 2, \'W\': 3}, \'Z\': {\'W\': 5}, \'W\': {} } route_requests = [(\'X\', \'W\'), (\'Y\', \'Z\')] enhanced_optimize_route(graph, route_requests) ``` Should return: ``` { 0: {\'distance\': 6, \'path\': [\'X\', \'Z\', \'W\']}, 1: {\'distance\': 2, \'path\': [\'Y\', \'Z\']} } ```","solution":"import heapq def dijkstra(graph, start, end): # Initialize distances and priority queue distances = {node: float(\'inf\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] paths = {node: [] for node in graph} paths[start].append(start) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip nodes with outdated distances if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance paths[neighbor] = paths[current_node] + [neighbor] heapq.heappush(priority_queue, (distance, neighbor)) return distances[end], paths[end] def enhanced_optimize_route(graph, route_requests): results = {} for idx, (start, end) in enumerate(route_requests): distance, path = dijkstra(graph, start, end) results[idx] = {\'distance\': distance, \'path\': path} return results"},{"question":"# Coding Assessment Question You are requested to implement a class structure for a simple library system that manages books and tracks the availability of each book. The system should allow the addition of new books to the library, borrowing books, and returning books. Your Task Define a `Library` class with the following methods: 1. **add_book(title)**: This method adds a book to the library with the given title. If the book already exists, it increments the count of the available copies. 2. **borrow_book(title)**: This method allows a user to borrow a book if it is available. If the book is not available or does not exist, it raises an appropriate exception. 3. **return_book(title)**: This method allows a user to return a book. If the book was not borrowed or does not exist in the library\'s catalog, it raises an appropriate exception. 4. **available_books()**: This method returns a dictionary of all the books in the library with the number of available copies for each book. # Function Specifications `add_book` - **Input**: `title` (string) - **Output**: None - **Exceptions**: - Raise `ValueError` if the title is an empty string. `borrow_book` - **Input**: `title` (string) - **Output**: None - **Exceptions**: - Raise `ValueError` if the title is an empty string. - Raise `Exception` if the book does not exist or no copies are available. `return_book` - **Input**: `title` (string) - **Output**: None - **Exceptions**: - Raise `ValueError` if the title is an empty string. - Raise `Exception` if the book does not exist in the catalog. `available_books` - **Output**: `Dict[str, int]` (dictionary where keys are book titles and values are the count of available copies) - **Exceptions**: None # Example Usage ```python library = Library() try: library.add_book(\\"Python Programming\\") library.add_book(\\"Data Structures and Algorithms\\") library.add_book(\\"Python Programming\\") # Adding another copy book_list = library.available_books() print(book_list) # Expected Output: {\'Python Programming\': 2, \'Data Structures and Algorithms\': 1} library.borrow_book(\\"Python Programming\\") book_list = library.available_books() print(book_list) # Expected Output: {\'Python Programming\': 1, \'Data Structures and Algorithms\': 1} library.return_book(\\"Python Programming\\") book_list = library.available_books() print(book_list) # Expected Output: {\'Python Programming\': 2, \'Data Structures and Algorithms\': 1} except ValueError as ve: print(ve) except Exception as e: print(e) ``` # Constraints - Book titles are case-sensitive strings. - The initial set of books and their quantity are managed solely through the `add_book` method. - All operations adhere to standard library management practices ensuring correctness of the library\'s state.","solution":"class Library: def __init__(self): self.catalog = {} def add_book(self, title): if not title: raise ValueError(\\"The book title cannot be empty.\\") if title in self.catalog: self.catalog[title] += 1 else: self.catalog[title] = 1 def borrow_book(self, title): if not title: raise ValueError(\\"The book title cannot be empty.\\") if title not in self.catalog or self.catalog[title] == 0: raise Exception(\\"The book is not available.\\") self.catalog[title] -= 1 def return_book(self, title): if not title: raise ValueError(\\"The book title cannot be empty.\\") if title not in self.catalog: raise Exception(\\"The book does not exist in the library\'s catalog.\\") self.catalog[title] += 1 def available_books(self): return self.catalog"},{"question":"# Rainfall Data Processing Objective Create a class to handle and process monthly rainfall data. This task evaluates your ability to work with data structures, mathematical operations, and basic data analysis techniques. Scenario You are developing a system to analyze monthly rainfall data for a given year. You need to implement a class that allows for storing monthly rainfall amounts and performing simple statistical analyses. Instructions 1. Implement a class named `RainfallData` with the following methods: * `__init__(self)` * Description: Initializes an empty list to store monthly rainfall data. * `add_monthly_data(self, month, rainfall)` * Input: * `month` (str): Name of the month (e.g., \\"January\\", \\"February\\", etc.). * `rainfall` (float): Amount of rainfall in millimeters. * Output: None * Description: Adds a month\'s rainfall data to the internal list. The method should raise an exception if the input month already has data. * `get_total_rainfall(self)` * Input: None * Output: * `total` (float): Total rainfall for the year. * Description: Returns the sum of all monthly rainfall amounts. * `get_average_rainfall(self)` * Input: None * Output: * `average` (float): Average monthly rainfall. * Description: Returns the average monthly rainfall. * `get_max_rainfall(self)` * Input: None * Output: * `month` (str), `rainfall` (float): Month with maximum rainfall and the rainfall amount. * Description: Returns the month and amount of maximum monthly rainfall. * `get_min_rainfall(self)` * Input: None * Output: * `month` (str), `rainfall` (float): Month with minimum rainfall and the rainfall amount. * Description: Returns the month and amount of minimum monthly rainfall. Constraints * You must use a list to store the monthly data, where each element is a tuple of the form `(month, rainfall)`. * The monthly names are case-insensitive, so \\"January\\" and \\"january\\" should be treated as the same month. * The input rainfall values are non-negative floats. * Raise an exception if a method is called before any data has been added. Example ```python rainfall_data = RainfallData() rainfall_data.add_monthly_data(\\"January\\", 78.0) rainfall_data.add_monthly_data(\\"February\\", 65.2) rainfall_data.add_monthly_data(\\"March\\", 89.4) total_rainfall = rainfall_data.get_total_rainfall() print(f\\"Total rainfall: {total_rainfall} mm\\") average_rainfall = rainfall_data.get_average_rainfall() print(f\\"Average monthly rainfall: {average_rainfall} mm\\") max_rainfall = rainfall_data.get_max_rainfall() print(f\\"Maximum rainfall: {max_rainfall[0]} - {max_rainfall[1]} mm\\") min_rainfall = rainfall_data.get_min_rainfall() print(f\\"Minimum rainfall: {min_rainfall[0]} - {min_rainfall[1]} mm\\") ```","solution":"class RainfallData: def __init__(self): self.data = [] def add_monthly_data(self, month, rainfall): month = month.lower() if any(m == month for m, _ in self.data): raise ValueError(f\\"Data for the month \'{month}\' already exists.\\") self.data.append((month, rainfall)) def get_total_rainfall(self): if not self.data: raise ValueError(\\"No rainfall data available.\\") return sum(rainfall for _, rainfall in self.data) def get_average_rainfall(self): if not self.data: raise ValueError(\\"No rainfall data available.\\") return self.get_total_rainfall() / len(self.data) def get_max_rainfall(self): if not self.data: raise ValueError(\\"No rainfall data available.\\") return max(self.data, key=lambda x: x[1]) def get_min_rainfall(self): if not self.data: raise ValueError(\\"No rainfall data available.\\") return min(self.data, key=lambda x: x[1])"},{"question":"# Context You are tasked with developing a system to manage a library\'s inventory. The library keeps records of books, including their titles, authors, and publication years. Along with managing the inventory, there is a routine task to find all unique authors and list books published by each author in descending order of their publication years. # Task Write a Python function that takes as input a list of dictionaries representing books and outputs a dictionary where each key is an author\'s name and the value is a list of book titles sorted in descending order of their publication years. # Function Signature ```python def organize_library_inventory(books: list[dict[str, str | int]]) -> dict[str, list[str]]: pass ``` # Input - `books` (list of dict): Each dictionary represents a book and has three keys: - `\\"title\\"` (str): The title of the book. - `\\"author\\"` (str): The author\'s name. - `\\"year\\"` (int): The publication year. # Output A dictionary where: - Each key is a unique author\'s name. - Each value is a list of book titles written by that author, sorted in descending order of their publication years. # Constraints - The list `books` will contain at least 1 and at most 1000 books. - Each book\'s title will be a non-empty string. - Each author\'s name will be a non-empty string. - Each publication year will be an integer. # Example ```python books = [ {\\"title\\": \\"Book A1\\", \\"author\\": \\"Author A\\", \\"year\\": 2001}, {\\"title\\": \\"Book B1\\", \\"author\\": \\"Author B\\", \\"year\\": 1999}, {\\"title\\": \\"Book A2\\", \\"author\\": \\"Author A\\", \\"year\\": 2003}, {\\"title\\": \\"Book C1\\", \\"author\\": \\"Author C\\", \\"year\\": 2000}, ] expected_output = { \\"Author A\\": [\\"Book A2\\", \\"Book A1\\"], \\"Author B\\": [\\"Book B1\\"], \\"Author C\\": [\\"Book C1\\"], } assert organize_library_inventory(books) == expected_output ```","solution":"from collections import defaultdict def organize_library_inventory(books): Organizes the library inventory by authors and sorts their books in descending order of publication years. :param books: List of dictionaries with keys \\"title\\", \\"author\\", and \\"year\\" :return: Dictionary with authors as keys and lists of book titles as values authors_books = defaultdict(list) for book in books: author = book[\'author\'] authors_books[author].append(book) sorted_authors_books = {} for author, books in authors_books.items(): sorted_books = sorted(books, key=lambda x: x[\'year\'], reverse=True) sorted_titles = [book[\'title\'] for book in sorted_books] sorted_authors_books[author] = sorted_titles return sorted_authors_books"},{"question":"# Problem Statement You have been provided with a number of packages, each with a weight as an integer. These packages need to be delivered using a drone that has a weight limit. Your task is to determine the minimum number of trips the drone needs to make to deliver all the packages without exceeding its weight limit on any trip. # Function Signature ```python def minimum_trips(weights: List[int], limit: int) -> int: pass ``` # Detailed Requirements 1. **Input**: - `weights` (List[int]): An array of integers representing the weights of the packages (1 ≤ len(weights) ≤ 1000, 1 ≤ weights[i] ≤ 10000). - `limit` (int): An integer representing the weight limit of the drone (1 ≤ limit ≤ 10000). 2. **Output**: - Returns an integer representing the minimum number of trips required. 3. **Examples**: ```python >>> minimum_trips([1, 2, 3, 4, 5], 5) 3 >>> minimum_trips([9, 8, 7, 6, 2, 1], 10) 4 >>> minimum_trips([2, 2, 3, 3, 4, 4], 5) 4 ``` # Notes - You may assume that the drone can carry multiple packages as long as their combined weight does not exceed the weight limit. - The goal is to minimize the total number of trips. - Packages can be combined in any way to maximize the number of packages in each trip without exceeding the weight limit. - A greedy approach can be helpful, but ensure to test your solution against various edge cases such as all lightweight packages or a single very heavy package. # Constraints 1. Ensure the solution runs efficiently within the provided input limits. 2. Handle cases where a package weight equals or exceeds the drone\'s weight limit by ensuring such packages can either be delivered alone or excluded appropriately.","solution":"from typing import List def minimum_trips(weights: List[int], limit: int) -> int: weights.sort(reverse=True) i, j = 0, len(weights) - 1 trips = 0 while i <= j: if i == j: # Only one package left trips += 1 break if weights[i] + weights[j] <= limit: j -= 1 i += 1 trips += 1 return trips"},{"question":"# Context You are developing a basic e-commerce platform to manage product pricing. Each product has a base price, to which taxes and discounts can be applied. Taxes are always added before any discount is applied. # Task Write a function `calculate_final_price(base_price: float, tax_rate: float, discount_rate: float) -> float` that takes the base price of a product in dollars, the tax rate as a percentage, and the discount rate as a percentage, and returns the final price of the product in dollars after applying the tax and discount sequentially. The function should handle edge cases and invalid inputs appropriately. # Input - A float value `base_price` representing the base price in dollars (must be non-negative). - A float value `tax_rate` representing the tax rate as a percentage (must be non-negative). - A float value `discount_rate` representing the discount rate as a percentage (must be non-negative and not greater than 100). # Output - A float value representing the final price in dollars. # Constraints - If the base price is negative, raise a `ValueError` with the message \\"Base price cannot be negative\\". - If the tax rate is negative, raise a `ValueError` with the message \\"Tax rate cannot be negative\\". - If the discount rate is negative or greater than 100, raise a `ValueError` with the message \\"Discount rate must be between 0 and 100\\". # Examples ```python calculate_final_price(100.0, 10.0, 20.0) # Expected Output: 88.0 calculate_final_price(50.0, 5.0, 10.0) # Expected Output: 47.25 calculate_final_price(200.0, 15.0, 10.0) # Expected Output: 207.0 calculate_final_price(75.0, 0.0, 25.0) # Expected Output: 56.25 calculate_final_price(120.0, 8.0, 30.0) # Expected Output: 92.4 ``` # Additional Note - To ensure precision, round your output to two decimal places.","solution":"def calculate_final_price(base_price: float, tax_rate: float, discount_rate: float) -> float: Calculate the final price of a product after applying tax and discount sequentially. :param base_price: The base price of the product in dollars (must be non-negative). :param tax_rate: The tax rate as a percentage (must be non-negative). :param discount_rate: The discount rate as a percentage (must be between 0 and 100). :return: The final price of the product in dollars, rounded to two decimal places. :raises ValueError: If base_price is negative, tax_rate is negative, or discount_rate is out of valid range. if base_price < 0: raise ValueError(\\"Base price cannot be negative\\") if tax_rate < 0: raise ValueError(\\"Tax rate cannot be negative\\") if discount_rate < 0 or discount_rate > 100: raise ValueError(\\"Discount rate must be between 0 and 100\\") # Apply tax price_with_tax = base_price * (1 + tax_rate / 100) # Apply discount final_price = price_with_tax * (1 - discount_rate / 100) # Return the final price rounded to two decimal places return round(final_price, 2)"},{"question":"# Problem Statement: Write a function that takes a list of integers and returns a new list with duplicates removed while maintaining the original order of elements. Additionally, implement a unit test to verify the correctness of your solution. # Function Signature: ```python def remove_duplicates(input_list: list) -> list: Remove duplicates from the list while maintaining the order. :param input_list: List of integers which may contain duplicates. :return: List of integers without duplicates, maintaining original order. # Unit test function def test_remove_duplicates(): Test the remove_duplicates function with various inputs. ``` # Requirements: 1. **Input**: A list of integers. 2. **Output**: A list of integers without duplicates, maintaining the original order. 3. **Constraints**: The list may have up to 10^5 elements, and each element will be in the range [1, 10^9]. 4. **Performance**: Your solution should efficiently handle large lists within reasonable time limits. # Examples: ```python assert remove_duplicates([4, 5, 6, 7, 4, 5, 5, 6]) == [4, 5, 6, 7] assert remove_duplicates([1, 2, 3, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert remove_duplicates([99, 10, 22, 10, 99, 17]) == [99, 10, 22, 17] ``` # Guidelines: 1. Use a set or other data structure to track the elements that have already appeared in the list. 2. Ensure the new list maintains the original order of the first occurrences of each element. 3. Implement the test function to cover various test cases, including edge cases with empty lists and lists with unique elements only.","solution":"def remove_duplicates(input_list): Remove duplicates from the list while maintaining the order. :param input_list: List of integers which may contain duplicates. :return: List of integers without duplicates, maintaining original order. seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Task You need to write a function `is_anagram_palindrome` that determines whether any permutation of the given string can be rearranged to form a palindrome. # Function Signature ```python def is_anagram_palindrome(s: str) -> bool: ``` # Input * A single string `s` (1 <= len(s) <= 1000), which contains only lowercase English letters. # Output * Return `True` if any permutation of `s` can form a palindrome, otherwise return `False`. # Constraints * Ensure the function efficiently handles the upper limit of the input size. * The function should not use excessive memory or computational time for large strings. # Requirements: - Make sure your function passes the provided example cases. - Create additional edge case tests to validate your function against strings with varying character distributions. # Examples: ```python assert is_anagram_palindrome(\\"civic\\") == True # \\"civic\\" itself is a palindrome assert is_anagram_palindrome(\\"ivicc\\") == True # \\"civic\\" is a permutation that forms a palindrome assert is_anagram_palindrome(\\"hello\\") == False # No permutation of \\"hello\\" forms a palindrome assert is_anagram_palindrome(\\"aabb\\") == True # \\"abba\\" is a permutation that forms a palindrome assert is_anagram_palindrome(\\"abcabc\\") == True # \\"abccba\\" is a permutation that forms a palindrome assert is_anagram_palindrome(\\"carerac\\") == True # \\"racecar\\" is a permutation that forms a palindrome ```","solution":"def is_anagram_palindrome(s: str) -> bool: Determines whether any permutation of the given string can be rearranged to form a palindrome. Args: s (str): Input string composed of lowercase English letters. Returns: bool: True if any permutation of the string can form a palindrome, otherwise False. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be able to form a palindrome, it can have at most one character with an odd count return odd_count <= 1"},{"question":"# Coding Assessment Question **Unique Pathways in a Grid** You are given a grid with `m` rows and `n` columns where you need to find the total number of unique pathways from the top-left corner (0,0) to the bottom-right corner (m-1, n-1). You can only move to the right or down from any cell. Write the function `unique_paths(m: int, n: int) -> int` that calculates the number of such unique paths. Input * Two integers, `m` and `n`, representing the number of rows and columns in the grid, respectively `(1 <= m, n <= 15)`. Output * An integer representing the total number of unique pathways from the top-left corner to the bottom-right corner. Examples 1. **Input**: `unique_paths(3, 2)` **Output**: `3` 2. **Input**: `unique_paths(7, 3)` **Output**: `28` Your implementation should handle the given constraints efficiently and return the correct count of unique pathways for varying grid sizes. Make sure to test your function with edge cases, such as the smallest possible grid (1x1) and larger grids up to the maximum size (15x15).","solution":"def unique_paths(m, n): Function to calculate the number of unique paths in an m x n grid from the top-left to the bottom-right corner. You can only move either down or right at any point in time. :param m: number of rows :param n: number of columns :return: number of unique paths # Create a 2D list to store the number of paths to each cell dp = [[0] * n for _ in range(m)] # Fill the first row and first column with 1s as there\'s only one way to reach any cell in the first row or column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Calculate the number of paths for each cell (i, j) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner cell will have the total number of unique paths return dp[m-1][n-1]"},{"question":"# Problem: Distance Calculation System Your task is to design a distance calculation system that integrates various geometric distance calculation functions into a unified module. The goal is to develop functions for each of these distances, ensuring proper input validation, and efficient computation while adhering to geometric formulas. Task Requirements: 1. **Function Signature**: - Implement functions corresponding to each of the following distances: * Euclidean Distance (2D) * Euclidean Distance (3D) * Manhattan Distance * Chebyshev Distance * Minkowski Distance - The function names should be prefixed with `dist_` followed by the distance name (e.g., `dist_euclidean_2d`). 2. **Input and Output**: - The distance functions should accept numerical values (either `float` or `int`) and return the distance as a `float`. - If invalid values are provided (e.g., non-numeric inputs), the function should raise a `ValueError` with an appropriate message. 3. **Constraints**: - All inputs must be numerical and the dimensions must match the required distance calculation. 4. **Performance Requirements**: - Ensure that the functions run efficiently and use a reasonable amount of space. Example Functions: 1. **Euclidean Distance (2D)** ```python def dist_euclidean_2d(x1: float, y1: float, x2: float, y2: float) -> float: if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_euclidean_2d() only accepts numerical values\\") from math import sqrt return sqrt((x2 - x1)**2 + (y2 - y1)**2) ``` 2. **Manhattan Distance** ```python def dist_manhattan(x1: float, y1: float, x2: float, y2: float) -> float: if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_manhattan() only accepts numerical values\\") return abs(x2 - x1) + abs(y2 - y1) ``` 3. **Chebyshev Distance** ```python def dist_chebyshev(x1: float, y1: float, x2: float, y2: float) -> float: if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_chebyshev() only accepts numerical values\\") return max(abs(x2 - x1), abs(y2 - y1)) ``` 4. **Minkowski Distance** ```python def dist_minkowski(x1: float, y1: float, x2: float, y2: float, p: float) -> float: if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2, p]): raise ValueError(\\"dist_minkowski() only accepts numerical values\\") if p <= 0: raise ValueError(\\"The order p must be a positive number\\") from math import pow return pow(pow(abs(x2 - x1), p) + pow(abs(y2 - y1), p), 1/p) ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct distance calculations. - Boundary inputs involving zero distances. - Invalid inputs like non-numeric values raising appropriate errors. Provide at least one test example for each distance calculation function in the form of `assert` statements to validate their behavior. Example tests: ```python # Euclidean Distance (2D) assert abs(dist_euclidean_2d(0, 0, 3, 4) - 5) < 1e-6 assert abs(dist_euclidean_2d(1, 2, 1, 2) - 0) < 1e-6 # Manhattan Distance assert abs(dist_manhattan(1, 2, 4, 6) - 7) < 1e-6 assert abs(dist_manhattan(0, 0, 0, 0) - 0) < 1e-6 # Chebyshev Distance assert abs(dist_chebyshev(1, 2, 4, 6) - 4) < 1e-6 assert abs(dist_chebyshev(0, 0, 7, -7) - 7) < 1e-6 # Minkowski Distance assert abs(dist_minkowski(1, 2, 4, 6, 3) - 4.497941445275415) < 1e-6 assert abs(dist_minkowski(0, 0, 8, 6, 2) - 10) < 1e-6 ```","solution":"from math import sqrt, pow def dist_euclidean_2d(x1, y1, x2, y2): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_euclidean_2d() only accepts numerical values\\") return sqrt((x2 - x1)**2 + (y2 - y1)**2) def dist_euclidean_3d(x1, y1, z1, x2, y2, z2): if not all(isinstance(i, (int, float)) for i in [x1, y1, z1, x2, y2, z2]): raise ValueError(\\"dist_euclidean_3d() only accepts numerical values\\") return sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) def dist_manhattan(x1, y1, x2, y2): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_manhattan() only accepts numerical values\\") return abs(x2 - x1) + abs(y2 - y1) def dist_chebyshev(x1, y1, x2, y2): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_chebyshev() only accepts numerical values\\") return max(abs(x2 - x1), abs(y2 - y1)) def dist_minkowski(x1, y1, x2, y2, p): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2, p]): raise ValueError(\\"dist_minkowski() only accepts numerical values\\") if p <= 0: raise ValueError(\\"The order p must be a positive number\\") return pow(pow(abs(x2 - x1), p) + pow(abs(y2 - y1), p), 1/p)"},{"question":"# Question: String Shift Cipher You are assigned to implement an encoding and decoding method for messages using a simple shift cipher. This cipher shifts each letter in the message by a specified number of positions in the alphabet, wrapping around if necessary. It is a straightforward but effective way to encode textual data. Function Signature ```python def shift_cipher(message: str, shift: int) -> str: def unshift_cipher(message: str, shift: int) -> str: ``` Inputs 1. `message`: A string consisting of lowercase alphabetic characters representing the message to be encoded or decoded. 2. `shift`: An integer indicating the number of positions each character in the message should be shifted. It can be positive (right shift) or negative (left shift). Outputs - `shift_cipher` should return an encoded message as a string. - `unshift_cipher` should return the original message given an encoded message and the shift value. Examples ```python message = \\"hello\\" shift = 3 encoded_message = shift_cipher(message, shift) print(encoded_message) # Output: \\"khoor\\" decoded_message = unshift_cipher(encoded_message, shift) print(decoded_message) # Output: \\"hello\\" ``` Constraints - The `message` will only contain lowercase alphabetic characters (a-z). - You will need to handle shifts that wrap around the end of the alphabet (e.g., a shift of 1 on \'z\' should result in \'a\'). # Context You are working on a basic encryption system for secure communication between two parties. By implementing a simple shift cipher, you can ensure that messages are not immediately readable by someone intercepting the transmission. This basic form of encryption is foundational and helps in understanding more complex cryptographic algorithms. Example ```python message = \\"xyz\\" shift = 5 encoded_message = shift_cipher(message, shift) print(encoded_message) # Output: \\"cde\\" decoded_message = unshift_cipher(encoded_message, shift) print(decoded_message) # Output: \\"xyz\\" ``` In this example, the string \\"xyz\\" is encoded to \\"cde\\" when shifted by 5 positions. Decoding \\"cde\\" with the same shift value of 5 correctly returns the original message \\"xyz\\". This illustrates the cipher\'s capability to handle wrapping around the end of the alphabet and properly reversing the encoding process.","solution":"def shift_cipher(message: str, shift: int) -> str: Encodes the message using a shift cipher. Shifts each letter in the message by the specified number of positions in the alphabet. encoded_message = [] for char in message: new_char = chr(((ord(char) - ord(\'a\') + shift) % 26) + ord(\'a\')) encoded_message.append(new_char) return \'\'.join(encoded_message) def unshift_cipher(message: str, shift: int) -> str: Decodes the message encoded with a shift cipher. Shifts each letter in the message back by the specified number of positions in the alphabet. decoded_message = [] for char in message: new_char = chr(((ord(char) - ord(\'a\') - shift) % 26) + ord(\'a\')) decoded_message.append(new_char) return \'\'.join(decoded_message)"},{"question":"You are given a list of strings where each string can be a valid integer (positive, negative, zero) or a float (positive, negative, zero, with at most one decimal point). Your task is to implement a function that sorts this list of strings first by their numeric value, and if two numbers are equal, sort them by their original string representation lexicographically. # Function Signature ```python def sort_numeric_strings(strings: list) -> list: ``` # Input * A list of strings `strings` where each string represents a valid integer or float. # Output * A list of strings sorted by their numeric value and lexicographically for equal numeric values. # Example ```python # Example 1 assert sort_numeric_strings([\\"1\\", \\"10\\", \\"-1\\", \\"3.14\\", \\"2.7\\", \\"3.140\\", \\"-2.5\\"]) == [\\"-2.5\\", \\"-1\\", \\"1\\", \\"2.7\\", \\"3.14\\", \\"3.140\\", \\"10\\"] # Example 2 assert sort_numeric_strings([\\"0\\", \\"-3.2\\", \\"4\\", \\"5\\", \\"-0.5\\", \\"3.00\\", \\"-3.20\\"]) == [\\"-3.2\\", \\"-3.20\\", \\"-0.5\\", \\"0\\", \\"3.00\\", \\"4\\", \\"5\\"] # Example 3 assert sort_numeric_strings([\\"-0.1\\", \\"2\\", \\"-2\\", \\"0.1\\", \\"1.0\\", \\"2.00\\", \\"-1.00\\"]) == [\\"-2\\", \\"-1.00\\", \\"-0.1\\", \\"0.1\\", \\"1.0\\", \\"2\\", \\"2.00\\"] # Example 4 assert sort_numeric_strings([]) == [] # Example 5 (Edge Case with Duplicates) assert sort_numeric_strings([\\"3\\", \\"3\\", \\"-3\\", \\"3.0\\", \\"3.00\\", \\"-3.00\\"]) == [\\"-3\\", \\"-3.00\\", \\"3\\", \\"3\\", \\"3.0\\", \\"3.00\\"] ``` # Constraints * Your solution should handle both large and small numbers efficiently. * Edge cases like empty lists, negative values, and multiple equivalent string representations of the same numeric value should be addressed correctly. * Ensure your implementation is properly commented to explain how the combined numeric and lexicographic sorting is achieved. # Description The task explores your ability to handle mixed numeric data types and sorting algorithms. This problem tests your ability to convert strings to numbers for accurate comparison while preserving original string formats for lexicographic ordering when necessary. # Additional Notes * Assume the input list contains valid integers and floats only. * Handle negative signs and different string representations of the same number (e.g., \\"3.0\\" and \\"3.00\\" should be considered equal in numeric value).","solution":"def sort_numeric_strings(strings: list) -> list: Sorts a list of numeric strings first by their numeric value, and if equal, lexicographically by their original string representation. # Define a key function that converts the string to a float for numeric comparison, # and also returns the original string for lexicographic comparison if numeric values are equal def sort_key(s): return (float(s), s) # Sort the list using the defined key function return sorted(strings, key=sort_key)"},{"question":"# Binary Search Tree Manipulation and Queries Context You are given a task to enhance and utilize a `BinarySearchTree` class to handle specific data structure manipulations and queries. This question evaluates your ability to work with trees and implement efficient algorithms. Problem Statement 1. **Height Calculation**: Implement a method `height(self) -> int` that computes the height of the tree. The height of a tree is the number of edges in the longest path from the root to a leaf node. * **Input**: None. * **Output**: Return the height of the tree as an integer. 2. **Lowest Common Ancestor (LCA)**: Implement a method `find_lca(self, n1: int, n2: int) -> Node` to find the lowest common ancestor (LCA) of two given nodes `n1` and `n2`. * **Input**: `n1` and `n2` are integers representing values of the two nodes. * **Output**: Return the `Node` that is the lowest common ancestor of the nodes with values `n1` and `n2`. If either `n1` or `n2` is not present in the tree, return `None`. # Implementation Details * Implement the following two methods inside the `BinarySearchTree` class provided: ```python class BinarySearchTree: # Existing methods of the class... def height(self) -> int: # Your implementation here def find_lca(self, n1: int, n2: int) -> Node: # Your implementation here ``` # Example Usage ```python bst = BinarySearchTree() for value in [20, 8, 22, 4, 12, 10, 14]: bst.insert(value) print(bst.height()) # Should print: 3 (Levels: 20 -> 8 -> 4) lca_node = bst.find_lca(10, 14) print(lca_node.data) # Should print the data of LCA which is: 12 ``` * **Constraints**: - Nodes\' values in the tree are unique integers. - The tree may support a variable number of nodes with different heights and structures. * **Submission Requirements**: - The `height` method should compute the height of the tree using recursion or iteration. - The `find_lca` method should efficiently find the LCA without unnecessary traversals and should return a Node object. Explain your approach briefly after implementing the above methods.","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.data: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def height(self): def _height(node): if node is None: return -1 # Base case: empty tree has height -1 left_height = _height(node.left) right_height = _height(node.right) return 1 + max(left_height, right_height) return _height(self.root) def find_lca(self, n1, n2): def _find_lca(node, n1, n2): if node is None: return None # If either n1 or n2 matches with root\'s key, report the presence by returning root if node.data == n1 or node.data == n2: return node # Look for keys in left and right subtrees left_lca = _find_lca(node.left, n1, n2) right_lca = _find_lca(node.right, n1, n2) # If both of the above calls return non-null, then n1 and n2 are in different subtrees # so this node is their LCA if left_lca and right_lca: return node # Otherwise check if left subtree or right subtree is LCA return left_lca if left_lca is not None else right_lca # Wrapper method for LCA lca = _find_lca(self.root, n1, n2) def find(node, k): if node is None: return False if node.data == k or find(node.left, k) or find(node.right, k): return True return False if find(self.root, n1) and find(self.root, n2): return lca return None"},{"question":"# Question Write a function that calculates the sum of the digits of a given non-negative integer until the sum is a single digit. This process is known as \\"repeated digital sum\\" or \\"digital root.\\" 1. **Function Name**: `digital_root(n: int) -> int` - **Input**: A single non-negative integer (n). - **Output**: The single-digit result of repeatedly summing the digits of the input number. - **Constraints**: The function should handle large values of (n) efficiently. - **Error Handling**: Raise an appropriate error if the input is not a non-negative integer. # Example ```python >>> digital_root(0) 0 >>> digital_root(9) 9 >>> digital_root(38) 2 >>> digital_root(1259) 8 >>> digital_root(98765) 8 >>> digital_root(\\"123\\") Traceback (most recent call last): ... TypeError: The input must be a non-negative integer. >>> digital_root(-1) Traceback (most recent call last): ... ValueError: The input must be a non-negative integer. ``` # Requirements * The function should use an efficient approach to handle very large integers. * Ensure the solution is robust and handles improper inputs gracefully.","solution":"def digital_root(n): Calculate the digital root of a given non-negative integer. Parameters: n (int): A non-negative integer. Returns: int: The single-digit digital root of the input number. Raises: TypeError: If the input is not an integer. ValueError: If the input is a negative integer. if not isinstance(n, int): raise TypeError(\\"The input must be a non-negative integer.\\") if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"# Problem Statement You are tasked with implementing a text processing utility function for a Natural Language Processing (NLP) application. This function needs to detect and extract all unique words from a given sentence, ignoring case and excluding punctuation. # Description For this problem, a word is defined as any sequence of characters bounded by whitespace or the start/end of the string. The unique words should be extracted case-insensitively and be returned in a sorted order (sorted lexicographically). # Objective Write a function `extract_unique_words` that takes a single sentence as input and returns a list of unique words found in that sentence, sorted lexicographically. # Function Signature ```python def extract_unique_words(sentence: str) -> List[str]: pass ``` # Input - **sentence** (str): a string containing the sentence from which to extract unique words. # Output - A list of unique words, sorted lexicographically. # Constraints - The input sentence will not be empty. - The sentence can contain upper and lower case letters, punctuation marks, and whitespace. - Words are case insensitive, i.e., \\"Word\\" and \\"word\\" should be considered the same. - Ignore punctuation marks in the sentence. # Examples **Example 1:** ```python sentence = \\"Hello, World! Say hello to the new world.\\" print(extract_unique_words(sentence)) # Expected output: [\'hello\', \'new\', \'say\', \'the\', \'to\', \'world\'] ``` **Example 2:** ```python sentence = \\"The quick brown fox jumps, over the lazy dog! The dog didn\'t move.\\" print(extract_unique_words(sentence)) # Expected output: [\'brown\', \'didnt\', \'dog\', \'fox\', \'jumps\', \'lazy\', \'move\', \'over\', \'quick\', \'the\'] ``` # Constraints 1. The input string will have a maximum length of 1000 characters. 2. The function should handle all types of common punctuation marks (.,!?;:). # Hints 1. Use regular expressions to help with the punctuation removal. 2. Convert the entire sentence to lower case to handle case insensitivity. 3. Use a set to store unique words and then convert it back to a sorted list.","solution":"import re from typing import List def extract_unique_words(sentence: str) -> List[str]: Extracts unique words from a given sentence, ignoring case and excluding punctuation. Returns a sorted list of unique words. # Remove punctuation using regex and convert to lower case sentence = re.sub(r\'[^ws]\', \'\', sentence).lower() # Split the sentence into words words = sentence.split() # Use a set to store unique words unique_words = set(words) # Return the sorted list of unique words return sorted(unique_words)"},{"question":"Implementing a Simple Neural Network for XOR Function Background The XOR (exclusive OR) function outputs true or 1 only when the two input Boolean values differ. It is a classic problem that demonstrates the learning capabilities of neural networks since a single-layer perceptron cannot solve it due to its non-linearity, while a multi-layer neural network can. Problem Statement You are required to implement a simple neural network with one hidden layer to compute the XOR function. The neural network should have: - 2 input neurons - 2 neurons in the hidden layer - 1 output neuron You are required to use the sigmoid activation function for the neurons. Function Signature ```python def xor_nn(X: List[List[int]], W1: List[List[float]], W2: List[float], b1: List[float], b2: float) -> List[float]: ``` Input - `X`: A 2D list where each sublist contains two integers (0 or 1) representing the input to the XOR function. Dimensions `k x 2` where `1 ≤ k ≤ 100`. - `W1`: A list of lists containing weights for the input to hidden layer connections. Dimensions `2 x 2`. - `W2`: A list containing the weights for the hidden layer to output layer connections. Dimensions `1 x 2`. - `b1`: A list containing the biases for the hidden layer neurons. Dimensions `2`. - `b2`: A float representing the bias for the output neuron. Output - A list of floats representing the output of the neural network for each set of inputs, rounded to 2 decimal places. Example ```python # Example input X = [ [0, 0], [0, 1], [1, 0], [1, 1] ] W1 = [ [20.0, 20.0], [-20.0, -20.0] ] W2 = [20.0, 20.0] b1 = [-10.0, 30.0] b2 = -30.0 # Example output result = [0.00, 1.00, 1.00, 0.00] ``` Constraints - Ensure the implementation correctly handles multiple inputs in `X`. - Compute the forward pass using matrix operations efficiently. - Round the output to 2 decimal places for each input set. Hints - Use the sigmoid function: `sigmoid(x) = 1 / (1 + exp(-x))`. - Perform matrix multiplication and bias addition step-by-step to compute the activations. - Use a loop (or vectorization if Python allows) to process each input set individually through the network. This question assesses understanding of basic neural network structures, forward pass computation, and matrix operations, aligning well with image processing and algorithm-focused assessments.","solution":"import math from typing import List def sigmoid(x: float) -> float: Compute the sigmoid function return 1 / (1 + math.exp(-x)) def xor_nn(X: List[List[int]], W1: List[List[float]], W2: List[float], b1: List[float], b2: float) -> List[float]: Neural Network implementation for XOR function. results = [] for x in X: # Calculate input to hidden layer hidden_inputs = [ x[0] * W1[0][0] + x[1] * W1[0][1] + b1[0], x[0] * W1[1][0] + x[1] * W1[1][1] + b1[1] ] # Apply sigmoid activation function to hidden layer inputs hidden_outputs = [ sigmoid(hidden_inputs[0]), sigmoid(hidden_inputs[1]) ] # Calculate input to output layer output_input = hidden_outputs[0] * W2[0] + hidden_outputs[1] * W2[1] + b2 # Apply sigmoid activation function to output layer input output = sigmoid(output_input) # Append output and round to 2 decimal places results.append(round(output, 2)) return results"},{"question":"# Coding Assessment Question: Problem Context You are working on a text processing engine tailored for generating structured summaries from various input documents. A key feature of this engine is the ability to detect and extract specific patterns within the text. Task Implement a function `extract_dates(text: str) -> list` that extracts all date-like patterns in the format `YYYY-MM-DD` from a given input string. These date patterns must adhere strictly to the specified format and be separated by non-alphanumeric characters within the text. Function Signature ```python def extract_dates(text: str) -> list: ``` Input * A single string `text` containing the input document. Output * A list of strings, each representing a detected date in the `YYYY-MM-DD` format. The dates should be returned in the order they appear in the input string. Constraints 1. The year `YYYY` must be between `1000` and `2999`. 2. The month `MM` should be between `01` and `12`. 3. The day `DD` should be valid for the given month and year. Examples * `extract_dates(\\"2023-03-15 was a good day. However, 2022-02-30 is invalid.\\")` should return `[\'2023-03-15\']`. * `extract_dates(\\"Check these dates: 2100-06-20, 1999-12-31, and 3000-01-01.\\")` should return `[\'2100-06-20\', \'1999-12-31\']`. * `extract_dates(\\"Meeting on 2022-11-31 and trip on 2022-14-01.\\")` should return `[]`. * `extract_dates(\\"Dates like 2020-02-29 and 2021-02-28 should be recognized.\\")` should return `[\'2020-02-29\', \'2021-02-28\']`. Notes 1. Ensure that the function handles leap years correctly for the date validation. 2. Your implementation should traverse the text once and utilize efficient string and list operations. 3. Do not use any third-party libraries for date detection or validation; only use the Python standard library. 4. If no valid dates are found, the function should return an empty list. Additional Implementation Details 1. Use regular expressions to detect potential date patterns and validate each candidate. 2. Carefully manage edge cases such as different delimiters or mixed invalid and valid dates in the text. 3. Include thorough testing to cover various input scenarios and edge cases.","solution":"import re from datetime import datetime def extract_dates(text): Extract dates in the format YYYY-MM-DD from the given text. date_pattern = re.compile(r\\"b(1[0-9]{3}|2[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])b\\") matches = date_pattern.findall(text) valid_dates = [] for match in matches: date_str = f\\"{match[0]}-{match[1]}-{match[2]}\\" try: # Validate date by trying to create a datetime object datetime.strptime(date_str, \\"%Y-%m-%d\\") valid_dates.append(date_str) except ValueError: # If date is not valid, skip it continue return valid_dates"},{"question":"# Traffic Light Controller Simulation Design a function to simulate the behavior of a traffic light controller at a crossroad. There are four main actions that the traffic light can take, which should be represented in cycles: 1. **Green for the North-South direction and Red for East-West direction** 2. **Yellow for the North-South direction and Red for East-West direction** 3. **Red for the North-South direction and Green for East-West direction** 4. **Red for the North-South direction and Yellow for East-West direction** The traffic light controller needs to cycle through these actions in the specified order. **Function Signature:** ```python def traffic_light(current_state: str) -> str: Simulates the next state of a traffic light based on the current state. :param current_state: A string representing the current state. One of {\\"Green_NS\\", \\"Yellow_NS\\", \\"Green_EW\\", \\"Yellow_EW\\"}. :return: A string representing the next state of the traffic light. ``` **Requirements:** 1. The input `current_state` will always be a valid string representing one of the four possible states. 2. The function should return the next state as per the cycling order defined above. 3. The state transitions should be as follows: - \\"Green_NS\\" -> \\"Yellow_NS\\" - \\"Yellow_NS\\" -> \\"Green_EW\\" - \\"Green_EW\\" -> \\"Yellow_EW\\" - \\"Yellow_EW\\" -> \\"Green_NS\\" **Examples:** ```python >>> traffic_light(\\"Green_NS\\") \'Yellow_NS\' >>> traffic_light(\\"Yellow_NS\\") \'Green_EW\' >>> traffic_light(\\"Green_EW\\") \'Yellow_EW\' >>> traffic_light(\\"Yellow_EW\\") \'Green_NS\' ``` Ensure that your implementation accurately reflects the cyclic behavior as described and transitions smoothly between the states.","solution":"def traffic_light(current_state: str) -> str: Simulates the next state of a traffic light based on the current state. :param current_state: A string representing the current state. One of {\\"Green_NS\\", \\"Yellow_NS\\", \\"Green_EW\\", \\"Yellow_EW\\"}. :return: A string representing the next state of the traffic light. state_transition = { \\"Green_NS\\": \\"Yellow_NS\\", \\"Yellow_NS\\": \\"Green_EW\\", \\"Green_EW\\": \\"Yellow_EW\\", \\"Yellow_EW\\": \\"Green_NS\\" } return state_transition.get(current_state)"},{"question":"# Problem You are given a sequence of daily stock prices of a given company for the past `n` days. Your task is to identify the days on which buying and selling the stock would have resulted in the maximum profit. If there are multiple such buy-sell pairs that yield the same maximum profit, return any one of them. # Requirements 1. Write a function `max_profit_days` that takes in a list of integers representing daily stock prices. 2. The function should return a tuple `(buy_day, sell_day)`, where `buy_day` and `sell_day` are the respective days (0-indexed) on which the stock should be bought and sold for maximum profit. 3. If no profit can be made, return `(-1, -1)`. # Constraints * The list of stock prices will have at least two and no more than 10^5 elements. * All stock prices are positive integers. * You may only buy and sell the stock once. # Input and Output Format - `max_profit_days(prices: List[int]) -> Tuple[int, int]` Here\'s an example of how this function should work: Example ```python prices = [7, 1, 5, 3, 6, 4] result = max_profit_days(prices) assert result == (1, 4) # Buy on day 1 (price 1), sell on day 4 (price 6) prices = [7, 6, 4, 3, 1] result = max_profit_days(prices) assert result == (-1, -1) # No profitable buy-sell pair ``` # Additional Information - Use an efficient algorithm to ensure the solution runs in linear time, O(n). - Consider edge cases such as prices that are strictly decreasing or all elements being the same. # Solution Template ```python from typing import List, Tuple def max_profit_days(prices: List[int]) -> Tuple[int, int]: Determine the best days to buy and sell stock for maximum profit. if len(prices) < 2: return (-1, -1) min_price_day = 0 max_profit = 0 buy_day = sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_day]: min_price_day = current_day current_profit = prices[current_day] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = current_day return (buy_day, sell_day) if max_profit > 0 else (-1, -1) ```","solution":"from typing import List, Tuple def max_profit_days(prices: List[int]) -> Tuple[int, int]: Determine the best days to buy and sell stock for maximum profit. if len(prices) < 2: return (-1, -1) min_price_day = 0 max_profit = 0 buy_day = sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_day]: min_price_day = current_day current_profit = prices[current_day] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = current_day return (buy_day, sell_day) if max_profit > 0 else (-1, -1)"},{"question":"# Coding Assessment Question Question: You are tasked with implementing a feature for tracking the popularity of a series of hashtags. Specifically, you need to keep track of the top `k` most frequently occurring hashtags within a given list. Each hashtag is represented as a string. Write a function `top_k_hashtags(hashtags: List[str], k: int) -> List[str]` that returns the `k` most frequently occurring hashtags from the input list, in descending order of frequency. If two hashtags have the same frequency, they should be returned in lexicographical order. Function Signature: ```python from typing import List def top_k_hashtags(hashtags: List[str], k: int) -> List[str]: pass ``` Input: - `hashtags` (List[str]): A list of strings representing the hashtags. - `k` (int): A non-negative integer specifying the number of top most frequent hashtags to return. If `k` is negative or greater than the number of unique hashtags, your function should raise a `ValueError` with the message \\"Invalid input\\". Output: - `List[str]`: A list of the `k` most frequently occurring hashtags, sorted by frequency and then lexicographically if frequencies are equal. Constraints: - The length of the list `hashtags` can be up to 10^6. - The length of each hashtag can be up to 100 characters. - The value of `k` will be between 0 and the number of unique hashtags inclusive. Performance Requirements: - Time Complexity should be O(n log k) where n is the number of hashtags. - Space Complexity should be O(n). Example: ```python >>> top_k_hashtags([\\"#fun\\", \\"#love\\", \\"#travel\\", \\"#fun\\", \\"#food\\", \\"#love\\", \\"#fun\\"], 2) [\'#fun\', \'#love\'] >>> top_k_hashtags([\\"#apple\\", \\"#banana\\", \\"#apple\\", \\"#apple\\", \\"#banana\\", \\"#cherry\\"], 1) [\'#apple\'] >>> top_k_hashtags([\\"#sun\\", \\"#moon\\", \\"#stars\\"], 0) [] >>> top_k_hashtags([\\"#coding\\", \\"#data\\", \\"#code\\", \\"#data\\", \\"#happy\\", \\"#coding\\", \\"#happy\\"], 2) [\'#coding\', \'#data\'] >>> top_k_hashtags([\\"#hello\\", \\"#world\\"], -1) Traceback (most recent call last): ... ValueError: Invalid input >>> top_k_hashtags([\\"#trend\\", \\"#fashion\\", \\"#style\\"], 5) Traceback (most recent call last): ... ValueError: Invalid input ``` # Additional Information: 1. You might find it useful to utilize data structures such as dictionaries for counting frequency and heaps for efficiently tracking the top `k` elements. 2. Ensure to perform input validation as per the given constraints.","solution":"from typing import List from collections import Counter import heapq def top_k_hashtags(hashtags: List[str], k: int) -> List[str]: if k < 0 or k > len(set(hashtags)): raise ValueError(\\"Invalid input\\") # Count the frequency of each hashtag count = Counter(hashtags) # Use a heap to get the top k elements heap = [(-freq, tag) for tag, freq in count.items()] heapq.heapify(heap) # Extract the top k hashtags top_k = heapq.nsmallest(k, heap) # Sort by frequency first (in descending order) and then by lexicographical order result = [tag for freq, tag in sorted(top_k)] return result"},{"question":"# Palindrome Permutation Problem Context: A permutation of a string is a rearrangement of its characters. A string is a palindrome if it reads the same forward and backward. To determine if a string can be rearranged to form a palindrome, each character must appear an even number of times, with at most one character appearing an odd number of times. Objective: Write a function that checks if any permutation of a given string can be rearranged to form a palindrome. Function Signature: ```python def can_form_palindrome(s: str) -> bool: ``` Input: * `s` (str): a non-empty string containing only lowercase English letters, where 1 ≤ len(s) ≤ 10^5. Output: * `True` if any permutation of the string can be rearranged to form a palindrome. * `False` otherwise. Constraints: * The function should handle string inputs up to length 10^5 efficiently. * Consider optimizing the solution to have an O(n) time complexity. Example: ```python assert can_form_palindrome(\\"carrace\\") == True # \\"racecar\\" is a permutation that forms a palindrome assert can_form_palindrome(\\"hello\\") == False # No permutation of \\"hello\\" can form a palindrome ``` Notes: * Use a data structure that efficiently counts character frequencies (e.g., a dictionary or collections.Counter). * Think about how many characters with an odd count are permissible to form a palindrome and base your logic on this insight.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if any permutation of the given string can be rearranged to form a palindrome. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd count is allowed for the string to be rearranged to a palindrome return odd_count <= 1"},{"question":"# Context: As part of a text processing application, you often need to restructure and format text data. One frequent task is converting a string of words into a sentence where the first word starts with a capital letter, and each subsequent word is lowercase, unless it is a proper noun. # Problem Statement: Write a function `format_sentence(words: list) -> str` that takes a list of words and returns a formatted sentence. Your implementation should: 1. Combine the words into a sentence separated by spaces. 2. Capitalize the first word and make sure all other words that are not proper nouns are in lowercase. 3. Consider a proper noun as any word that is fully capitalized in the input list. 4. Ensure the resulting sentence ends with a period. # Input: * A list `words` (length <= 100), where each element is a string representing a word. Each word\'s length is between 1 and 50 characters. # Output: * A string representing the formatted sentence. # Constraints: * You may assume the list will contain only valid words without spaces or special characters. # Examples: ```python >>> format_sentence([\\"hello\\", \\"WORLD\\", \\"this\\", \\"IS\\", \\"a\\", \\"TEST\\"]) \\"Hello WORLD this IS a TEST.\\" >>> format_sentence([\\"PYTHON\\", \\"is\\", \\"FUN\\"]) \\"Python is fun.\\" >>> format_sentence([\\"DATA\\", \\"Science\\", \\"Is\\", \\"INTERESTING\\"]) \\"Data science is INTERESTING.\\" >>> format_sentence([\\"GREAT\\"]) \\"Great.\\" ``` # Detailed Requirements: 1. Combine the words in the provided list into a single string separated by spaces. 2. Ensure the first word is capitalized. 3. Ensure all words except fully capitalized words (proper nouns) are in lowercase. 4. End the sentence with a period.","solution":"def format_sentence(words): Takes a list of words and returns a formatted sentence. Parameters: - words (list): A list of words where each element is a string. Returns: - str: A formatted sentence. if not words: return \\"\\" # Capitalize the first word formatted_words = [words[0].capitalize()] # Format the rest of the words for word in words[1:]: if word.isupper(): formatted_words.append(word) else: formatted_words.append(word.lower()) # Join the words into a sentence and end with a period sentence = \\" \\".join(formatted_words) + \\".\\" return sentence"},{"question":"# Problem Statement Create a function that generates the necessary information to sort a list of dictionaries based on various conditions. This will test your ability to manipulate and handle complex data structures effectively. # Requirements 1. Implement a function `get_sorted_info` that accepts a list of dictionaries and a list of keys for sorting order. 2. The function returns a sorted list of dictionaries based on the specified keys\' order of priority. 3. Each dictionary contains keys such as \'name\', \'age\', \'salary\', etc. (you can assume predetermined keys). # Function Signature ```python def get_sorted_info(data: List[Dict[str, Any]], sort_order: List[str]) -> List[Dict[str, Any]]: pass ``` # Input and Output Formats * **get_sorted_info**: - **Input**: A list of dictionaries (`data`) and a list of keys (`sort_order`) specifying the sorting priorities. - **Output**: A new sorted list of dictionaries. # Constraints 1. Every dictionary in the list will contain the keys present in the `sort_order`. 2. Assume all values corresponding to the same keys in different dictionaries are comparable. 3. Handle edge cases such as an empty list or one dictionary in the list. # Scenario Emma works as a data analyst and needs to organize data sets of employee records. She often needs to sort these records by multiple criteria like age, salary, and name in varying orders. Implement the `get_sorted_info` function to aid Emma in efficiently sorting her data. # Usage Example ```python # Data to be sorted data = [ {\'name\': \'John Doe\', \'age\': 28, \'salary\': 50000}, {\'name\': \'Jane Smith\', \'age\': 34, \'salary\': 75000}, {\'name\': \'Alice Johnson\', \'age\': 28, \'salary\': 55000}, {\'name\': \'Bob Brown\', \'age\': 45, \'salary\': 70000} ] # Sorting based on age, then salary sort_order = [\'age\', \'salary\'] sorted_data = get_sorted_info(data, sort_order) print(sorted_data) # Output: # [ # {\'name\': \'John Doe\', \'age\': 28, \'salary\': 50000}, # {\'name\': \'Alice Johnson\', \'age\': 28, \'salary\': 55000}, # {\'name\': \'Jane Smith\', \'age\': 34, \'salary\': 75000}, # {\'name\': \'Bob Brown\', \'age\': 45, \'salary\': 70000} # ] ``` To implement and test the `get_sorted_info` method, create various test cases to validate sorting using the provided example as a basis.","solution":"from typing import List, Dict, Any def get_sorted_info(data: List[Dict[str, Any]], sort_order: List[str]) -> List[Dict[str, Any]]: Sorts a list of dictionaries based on the given list of keys in the specified order. Parameters: data (List[Dict[str, Any]]): The list of dictionaries to be sorted. sort_order (List[str]): The list of keys to sort by in the order of priority. Returns: List[Dict[str, Any]]): The sorted list of dictionaries. return sorted(data, key=lambda x: tuple(x[key] for key in sort_order))"},{"question":"# Tree Depth Challenge **Problem Statement:** You have a binary tree, and you are required to write a function `deepest_left_leaf` to find the value of the deepest left leaf node in the tree. A left leaf is a leaf node that is the left child of its parent. **Function Signature:** ```python def deepest_left_leaf(root: Optional[TreeNode]) -> int: ``` **Input:** * `root`: A TreeNode - The root of the binary tree. Each `TreeNode` has attributes `val`, `left`, and `right`. **Output:** * Return the value of the deepest left leaf node. **Constraints:** 1. The number of nodes in the tree will be between `1` and `10^4`. 2. Node values are unique integers. 3. You may assume all node values are valid and the input will always be a non-empty tree. **Example Usage:** ```python # Example Tree # 1 # / # 2 3 # / / # 4 5 6 # # 7 deepest_left_leaf(root) -> 7 ``` **Note:** * Implement proper tree traversal techniques to explore all nodes and identify the deepest left leaf node. * Ensure the solution handles large trees efficiently and avoids excessive memory use. * Consider edge cases such as when the tree contains only one node or has an unbalanced structure. **TreeNode Definition:** ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_left_leaf(root): if not root: return None from collections import deque queue = deque([(root, False, 0)]) # (node, is_left, depth) deepest_node = None max_depth = -1 while queue: node, is_left, depth = queue.popleft() if node.left is None and node.right is None and is_left: if depth > max_depth: max_depth = depth deepest_node = node.val if node.left: queue.append((node.left, True, depth + 1)) if node.right: queue.append((node.right, False, depth + 1)) return deepest_node"},{"question":"# Problem Statement You are given an array of integers `a` and an integer `k`. Your task is to write a function `int_division(a: List[int], k: int) -> List[int]` that takes this array and the integer divider and returns a new array where each element is the result of the integer division of the corresponding element in the original array by `k`. # Function Signature ```python def int_division(a: List[int], k: int) -> List[int]: pass ``` # Input - `a`: A list of integers. The length of `a` will be between 1 and 1000 (inclusive). - `k`: An integer which is the divisor. Value of `k` will be between 1 and 1000 (inclusive). # Output - A list of integers where each element is the result of the integer division of the corresponding element in `a` by `k`. # Constraints - Ensure you perform integer division, which truncates towards zero. - The length of the output list must match the length of the input list `a`. # Example ```python assert int_division([5, 10, 15, 20], 5) == [1, 2, 3, 4] assert int_division([4, 3, 2, 1], 2) == [2, 1, 1, 0] assert int_division([-5, -10, 15, 21], 5) == [-1, -2, 3, 4] ``` # Additional Information - Ensure your code handles both positive and negative integers properly. - The function should be optimized to handle large input sizes efficiently. - Do not modify the function signature provided. # **Note**: Make sure your solution passes the provided test cases and you handle any potential edge cases.","solution":"from typing import List def int_division(a: List[int], k: int) -> List[int]: Performs integer division of each element in the list `a` by the integer `k`. return [x // k for x in a]"},{"question":"# Problem Context You are developing an application for a real-time strategy game. One of the requirements is to efficiently manage the health status of multiple units in the game. Each unit has a health level, and the game needs to frequently update and retrieve units based on their health. # Task Implement a `GameUnitManager` class with methods to add units, remove units, update health, and retrieve units with health above a certain threshold. # Function Signature ```python class GameUnitManager: def __init__(self): ... def add_unit(self, unit_id: str, health: int): ... def remove_unit(self, unit_id: str): ... def update_health(self, unit_id: str, health: int): ... def get_units_with_health_above(self, threshold: int) -> list[str]: ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Initializes an empty structure to store units and their health. 2. **Add Unit (`add_unit` method)**: - Accepts a `unit_id` (string) and `health` (integer). - Adds the unit with the given health to the collection. 3. **Remove Unit (`remove_unit` method)**: - Accepts a `unit_id`. - Removes the unit with the specified `unit_id` from the collection. 4. **Update Health (`update_health` method)**: - Accepts a `unit_id` and a new `health` value. - Updates the health value of the specified unit. 5. **Get Units with Health Above Threshold (`get_units_with_health_above` method)**: - Accepts a `threshold` value. - Returns a list of unit IDs whose health is strictly greater than the given threshold. # Input and Output Format * **Input**: - Series of method calls to add, remove, update health, and retrieve units. * **Output**: - Correctly maintain the health status of each unit. - Return list of unit IDs for units with health above the specified threshold. # Constraints 1. Each `unit_id` is unique. 2. `health` values are non-negative integers. 3. `threshold` is a non-negative integer. # Example Usage ```python if __name__ == \\"__main__\\": manager = GameUnitManager() manager.add_unit(\\"unit1\\", 100) manager.add_unit(\\"unit2\\", 50) manager.update_health(\\"unit2\\", 200) manager.remove_unit(\\"unit1\\") print(manager.get_units_with_health_above(100)) # Output: [\\"unit2\\"] ``` # Additional Guidelines 1. **Edge Cases**: - Ensure proper handling when adding a unit that already exists. - Handle updating non-existent units gracefully. - Attempting to remove non-existent units should be managed. 2. **Performance**: - Efficiently manage the units to handle frequent updates and queries. - Consider the use of appropriate data structures for optimal performance. Ensure your implementation of the `GameUnitManager` class correctly maintains the health states of units and effectively handles the given operations.","solution":"class GameUnitManager: def __init__(self): self.units = {} def add_unit(self, unit_id: str, health: int): if unit_id in self.units: raise ValueError(f\\"Unit with id {unit_id} already exists.\\") self.units[unit_id] = health def remove_unit(self, unit_id: str): if unit_id in self.units: del self.units[unit_id] def update_health(self, unit_id: str, health: int): if unit_id in self.units: self.units[unit_id] = health else: raise KeyError(f\\"Unit with id {unit_id} does not exist.\\") def get_units_with_health_above(self, threshold: int) -> list[str]: return [unit_id for unit_id, health in self.units.items() if health > threshold]"},{"question":"# Coding Assessment Question You need to implement a function `is_subtree` that determines whether one binary tree is a subtree of another binary tree. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: pass ``` # Input * `s` (TreeNode): The root node of the main binary tree. * `t` (TreeNode): The root node of the subtree to check for. # Output * Returns `True` if `t` is a subtree of `s`, otherwise returns `False`. # Constraints * Binary trees can contain up to 1000 nodes. * Tree node values are integers and can be positive, negative, or zero. # Performance Requirements * Ensure the function efficiently handles checking the subtree structure. * Aim to minimize redundant calculations and check subtree matching comprehensively. # Example ```python s = TreeNode(3) s.left = TreeNode(4) s.right = TreeNode(5) s.left.left = TreeNode(1) s.left.right = TreeNode(2) t = TreeNode(4) t.left = TreeNode(1) t.right = TreeNode(2) result = is_subtree(s, t) print(result) ``` Expected output: ```python True ``` # Note * You need to define the `TreeNode` class as provided in the signature. * The function should correctly identify subtrees even if the main tree is significantly larger or unbalanced. * Implement necessary checks to handle edge cases like `t` being `None` (`None` subtree is a valid subtree) or `s` being `None`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False return s.val == t.val and is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) if not s: return not t if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"# Problem Statement Write a function that computes the difference between the sum of the squares of the first `N` natural numbers and the square of their sum. This problem is known as the \\"difference of squares.\\" # Input - An integer `N` (1 <= N <= 10^4), which represents the number upper bound of the natural numbers sequence. # Output - An integer representing the difference between the sum of the squares of the first `N` natural numbers and the square of their sum. # Constraints - Your solution should efficiently handle the upper bound constraint of N. # Function Signature ```python def difference_of_squares(N: int) -> int: pass ``` # Example Your implementation should produce the following outputs: ```python print(difference_of_squares(10)) ``` Expected Output: ```python 2640 ``` ```python print(difference_of_squares(100)) ``` Expected Output: ```python 25164150 ``` # Explanation For the example `N = 10`: - Sum of squares: (1^2 + 2^2 + 3^2 + ldots + 10^2 = 385) - Square of the sum: ((1 + 2 + 3 + ldots + 10)^2 = 3025) - The difference is (3025 - 385 = 2640) For the example `N = 100`: - Sum of squares: Sum of squares from 1 to 100 - Square of the sum: Square of the sum from 1 to 100 - The difference is ( text{computed difference} ) Your function should efficiently compute these values using appropriate mathematical formulas or iterations, ensuring performance within the constraints.","solution":"def difference_of_squares(N: int) -> int: Returns the difference between the sum of the squares of the first N natural numbers and the square of their sum. sum_of_squares = sum(i ** 2 for i in range(1, N + 1)) square_of_sum = sum(range(1, N + 1)) ** 2 return square_of_sum - sum_of_squares"},{"question":"# Binary Tree to Double-Linked List Conversion with In-Order Traversal Background: You are provided with a binary tree data structure where each node contains a `value`, a `left` child, and a `right` child. The task is to convert this binary tree into a double-linked list using an in-order traversal. Task: Convert the given binary tree to a double-linked list such that each node in the list follows the in-order sequence of the original binary tree. The left pointer of each node should point to the previous node in the list, and the right pointer should point to the next node in the list. Requirements: 1. Implement an in-order traversal of the binary tree to link each node appropriately. 2. Ensure the double-linked list maintains the order of nodes as per in-order traversal of the binary tree. 3. Handle edge cases such as an empty tree or a tree with a single node. Function Implementation: You need to implement the following method: ```python class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: Convert the binary tree rooted at \'root\' to a double-linked list in-place. Return the head of the double-linked list. # Your implementation goes here ``` Input and Output **Example**: ```python # Example tree: # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) head = binary_tree_to_doubly_linked_list(root) # The resulting doubly linked list should be: 1 <-> 2 <-> 3 <-> 4 <-> 5 current = head while current: print(current.value, end=\\" <-> \\" if current.right else \\"n\\") current = current.right # Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` **Constraints**: - The tree can contain up to 1000 nodes. - Node values are unique integers within the range [-10^5, 10^5]. **Performance Requirements**: - The conversion process should have a linear time complexity O(n), where n is the number of nodes in the tree. # Additional Notes: - You may utilize a helper function to manage the in-order traversal and node linking.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: Convert the binary tree rooted at \'root\' to a double-linked list in-place. Return the head of the double-linked list. if not root: return None # Helper function to perform in-order traversal and link nodes def convert(node): nonlocal prev, head if not node: return # Left convert(node.left) # Node if prev: prev.right = node node.left = prev else: head = node prev = node # Right convert(node.right) prev, head = None, None convert(root) return head"},{"question":"# Question: Implement a Concurrency-Safe In-Memory Cache You are required to implement a class, `ConcurrentCache`, that serves as a thread-safe in-memory cache. The cache should support thread-safe get and put operations and should be optimized to handle concurrent access by multiple threads. Class Definition ```python class ConcurrentCache: def __init__(self): pass def put(self, key: str, value: any) -> None: pass def get(self, key: str) -> any: pass ``` Methods 1. `__init__`: Initialize an empty cache. 2. `put(key, value)`: Add the given key-value pair to the cache. If the key already exists, update the value. 3. `get(key)`: Retrieve the value associated with the given key. If the key does not exist in the cache, return `None`. Constraints * Ensure the cache supports concurrent access. Multiple threads should be able to invoke `put` and `get` methods safely. * Optimize for performance to handle high throughput in a concurrent environment. * Use Python\'s threading library to manage synchronization. Example Usage ```python cache = ConcurrentCache() def worker_put(cache, key, value): cache.put(key, value) def worker_get(cache, key): print(cache.get(key)) # Example scenario with threaded access import threading threads = [] threads.append(threading.Thread(target=worker_put, args=(cache, \'key1\', \'value1\'))) threads.append(threading.Thread(target=worker_put, args=(cache, \'key2\', \'value2\'))) threads.append(threading.Thread(target=worker_get, args=(cache, \'key1\'))) threads.append(threading.Thread(target=worker_get, args=(cache, \'key3\'))) for t in threads: t.start() for t in threads: t.join() ``` In this example, multiple threads are used to put and get entries from the `ConcurrentCache`. The operations should execute safely without interfering with each other, and the cache should return the correct results. **Note**: Implement the appropriate thread-safe locking mechanisms to manage concurrent access effectively.","solution":"import threading class ConcurrentCache: def __init__(self): self.cache = {} self.lock = threading.Lock() def put(self, key: str, value: any) -> None: with self.lock: self.cache[key] = value def get(self, key: str) -> any: with self.lock: return self.cache.get(key)"},{"question":"# Coding Assessment Question: Subarray Sum to Target Problem Statement: You are tasked with creating a function that finds the smallest contiguous subarray whose sum is equal to a given target value. The function should return the length of this subarray. If no such subarray exists, return 0. Function Signature: ```python def smallest_subarray_sum(nums: list, target: int) -> int: pass ``` Example: ```python assert smallest_subarray_sum([2, 3, 1, 2, 4, 3], 7) == 2 # [4, 3] is the smallest subarray assert smallest_subarray_sum([1, 4, 4], 4) == 1 # [4] is the smallest subarray assert smallest_subarray_sum([1, 1, 1, 1, 1, 1, 1], 7) == 7 # [1, 1, 1, 1, 1, 1, 1] assert smallest_subarray_sum([1, 2, 3, 4, 5], 11) == 0 # No subarray sums up to 11 ``` Constraints: 1. The length of the `nums` list will be between 1 and (10^5). 2. Each element in the `nums` list will be a non-negative integer less than or equal to (10^4). 3. The `target` value will be a positive integer less than or equal to (10^5). Expected Input and Output: * **Input**: A list of non-negative integers `nums` and a positive integer `target`. * **Output**: An integer representing the length of the smallest subarray with sum equal to `target`. Implementation Guidance: To solve this problem: 1. Use the sliding window technique to keep track of the current subarray sum. 2. Expand the window by adding elements until the sum is at least `target`. 3. Once the sum is `target` or more, record the length and move the window from the left to reduce the subarray size while maintaining the sum condition. 4. Repeat until you reach the end of the list. Notes: * Be mindful of performance; the solution should ideally work in linear time complexity.","solution":"def smallest_subarray_sum(nums, target): Finds the smallest contiguous subarray sum that equals the target value. :param nums: List of non-negative integers. :param target: Positive integer target value. :return: Length of the smallest subarray with sum equal to target, or 0 if no such subarray exists. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Problem Statement **Context**: You are developing a text processing tool that needs to analyze large text documents for keyword identification and ranking. To achieve this, you will implement the TF-IDF (Term Frequency-Inverse Document Frequency) algorithm which is commonly used for extracting important words from documents. **Task**: Given a list of documents (each document is a string of words) and a list of keywords, implement a function to compute the TF-IDF score for each keyword in each document. Return a dictionary where each key is a keyword and the value is another dictionary that maps document indices to their TF-IDF score. # Function Signature: ```python def compute_tfidf(documents: List[str], keywords: List[str]) -> Dict[str, Dict[int, float]]: Compute the TF-IDF score for each keyword in each document. Parameters: - documents (List[str]): A list of strings where each string represents a document. - keywords (List[str]): A list of keywords for which to compute the TF-IDF scores. Returns: - Dict[str, Dict[int, float]]: A dictionary where each key is a keyword and the value is another dictionary that maps document indices to their TF-IDF score for that keyword. ``` # Input: - `documents`: A list of strings, each string being a document. - `keywords`: A list of keywords (strings) to analyze. # Output: - A dictionary where each key is a keyword, and the value is another dictionary that maps document indices to their TF-IDF score for that keyword. # Constraints: - The number of documents will be less than 1000. - Each document can have up to 10,000 words. - The number of keywords will be less than 100. # Example: ```python documents = [ \\"this is a sample document\\", \\"this document is another sample document\\", \\"yet another example of a sample document\\" ] keywords = [\\"sample\\", \\"document\\"] output_dict = compute_tfidf(documents, keywords) # Expected output: # { # \\"sample\\": {0: tfidf0_0, 1: tfidf0_1, 2: tfidf0_2}, # \\"document\\": {0: tfidf1_0, 1: tfidf1_1, 2: tfidf1_2} # } # where tfidf0_0, tfidf0_1, tfidf0_2, tfidf1_0, tfidf1_1, tfidf1_2 are the TF-IDF scores for \'sample\' and \'document\' # in the three documents respectively. ``` **Note**: Ensure your function efficiently handles the computation by considering both Term Frequency (TF) and Inverse Document Frequency (IDF) components, and can scale with the given constraints.","solution":"import math from typing import List, Dict, Union def compute_tfidf(documents: List[str], keywords: List[str]) -> Dict[str, Dict[int, float]]: def term_frequency(term, document): words = document.split() term_count = words.count(term) total_words = len(words) return term_count / total_words def inverse_document_frequency(term, documents): num_docs_with_term = sum(1 for doc in documents if term in doc.split()) if num_docs_with_term == 0: return 0 return math.log(len(documents) / num_docs_with_term) + 1 tfidf_scores = {keyword: {} for keyword in keywords} for doc_index, document in enumerate(documents): for keyword in keywords: tf = term_frequency(keyword, document) idf = inverse_document_frequency(keyword, documents) tfidf_scores[keyword][doc_index] = tf * idf return tfidf_scores"},{"question":"# Even-Digit Sum **Objective**: Write a function to determine if the sum of all even digits in a given number is greater than a specified threshold. Function Signature ```python def is_even_digit_sum_greater(number: int, threshold: int) -> bool: Returns True if the sum of all even digits in the number is greater than the threshold, False otherwise. pass ``` # Input * Two integers: * `number` - A non-negative integer, to check for the sum of its even digits. * `threshold` - A non-negative integer, the threshold value to compare the sum against. # Output * A boolean value `True` if the sum of all even digits in `number` is greater than `threshold`, otherwise `False`. # Constraints * The function should handle inputs where `number` is up to 10^18 efficiently. * Raise a `TypeError` if the inputs are not integers. # Example Cases Example 1: **Input**: ```python number = 2468 threshold = 10 ``` **Output**: ```python True ``` **Explanation**: The even digits are 2, 4, 6, and 8. Their sum is 20, which is greater than 10. Example 2: **Input**: ```python number = 1357 threshold = 5 ``` **Output**: ```python False ``` **Explanation**: There are no even digits, so their sum is 0, which is not greater than 5. Example 3: **Input**: ```python number = 4802 threshold = 10 ``` **Output**: ```python True ``` **Explanation**: The even digits are 4, 8, and 2. Their sum is 14, which is greater than 10. # Implementation Hints 1. Iterate through each digit of the number. 2. Check if the digit is even and accumulate the sum. 3. Compare the sum with the threshold and return the result.","solution":"def is_even_digit_sum_greater(number: int, threshold: int) -> bool: Returns True if the sum of all even digits in the number is greater than the threshold, False otherwise. if not isinstance(number, int) or not isinstance(threshold, int): raise TypeError(\\"Both inputs must be integers\\") even_sum = 0 for digit in str(number): if int(digit) % 2 == 0: even_sum += int(digit) return even_sum > threshold"},{"question":"# String Compression using Run-Length Encoding **Context**: You are building a utility that compresses strings using run-length encoding (RLE). Run-length encoding is a simple form of data compression where consecutive data elements are replaced by a single data value and a count. For example, the string \\"aaabbc\\" would be compressed to \\"a3b2c1\\". **Function Specification**: Write a function `run_length_encode(s: str) -> str` that takes a string and returns its run-length encoded version. **Input**: - A string `s` consisting only of lowercase English letters (1 <= len(s) <= 10^6). **Output**: - A string representing the run-length encoded version of `s`. **Constraints**: - Use efficient string manipulation techniques to handle large inputs. - Ensure the encoded string length should be minimized appropriately using the run-length encoding scheme. **Performance**: - Your solution should process large strings efficiently in both time and space. **Sample Input and Output**: ```python assert run_length_encode(\\"aaaabbbcc\\") == \\"a4b3c2\\" assert run_length_encode(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encode(\\"aabbccddeeff\\") == \\"a2b2c2d2e2f2\\" assert run_length_encode(\\"zzzzzzzzzz\\") == \\"z10\\" ```","solution":"def run_length_encode(s: str) -> str: Compresses the input string `s` using run-length encoding. :param s: A string consisting only of lowercase English letters :return: A run-length encoded string if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string.append(s[i - 1]) encoded_string.append(str(count)) count = 1 # Append the last character and its count encoded_string.append(s[-1]) encoded_string.append(str(count)) return \'\'.join(encoded_string)"},{"question":"# Question: Implement a Thread-safe Counter in Python You are required to implement a Python class `ThreadSafeCounter` that manages a counter in a thread-safe manner. Your implementation should allow multiple threads to increment the counter without introducing race conditions. Class Signature ```python class ThreadSafeCounter: def __init__(self): pass def increment(self) -> None: pass def get_value(self) -> int: pass ``` Methods * `__init__(self)`: Initializes the counter to `0`. * `increment(self)`: Atomically increments the counter by `1`. * `get_value(self)`: Returns the current value of the counter. Constraints * You must ensure that `increment` operations are thread-safe. * Use appropriate synchronization mechanisms to avoid race conditions. Example Usage ```python from threading import Thread counter = ThreadSafeCounter() def worker(): for _ in range(1000): counter.increment() threads = [Thread(target=worker) for _ in range(10)] for thread in threads: thread.start() for thread in threads: thread.join() print(counter.get_value()) # Expected output: 10000 ``` In this example, ten threads increment the counter 1000 times each. The final value of the counter should be `10000` if the implementation correctly ensures thread-safety. **Note**: Focus on achieving synchronization and ensuring the correctness of the counter value when accessed by multiple threads.","solution":"import threading class ThreadSafeCounter: def __init__(self): self._counter = 0 self._lock = threading.Lock() def increment(self) -> None: with self._lock: self._counter += 1 def get_value(self) -> int: with self._lock: return self._counter"},{"question":"# Problem Statement Implement the following operations for a singly linked list using the provided `LinkedList` class template: 1. **Insert At Beginning**: The method `insert_at_beginning` should add a new node with a specified value to the start of the list. 2. **Insert At End**: The method `insert_at_end` should append a new node with a specified value to the end of the list. 3. **Delete Node**: The method `delete_node` should remove the first node that has the specified value. 4. **Reverse List**: The method `reverse` should reverse the linked list. 5. **Search Value**: The method `search` should return True if a node with the specified value exists in the list, otherwise False. Input Format - You will be provided with multiple operations and their respective values in a sequence. Output Format - After each operation, output the current state of the linked list. For the `search` operation, output `True` or `False`. Constraints - The input sequence will contain at most 10^5 operations. - Each value for node insertion or deletion will be in the range of -10^9 to 10^9. Functions to Implement ```python def insert_at_beginning(self, value: int) -> None: pass def insert_at_end(self, value: int) -> None: pass def delete_node(self, value: int) -> None: pass def reverse(self) -> None: pass def search(self, value: int) -> bool: pass ``` Example ```python # Initialize the linked list linked_list = LinkedList() # Insert at beginning operation linked_list.insert_at_beginning(10) print(linked_list) # Output: 10 # Insert at end operation linked_list.insert_at_end(20) print(linked_list) # Output: 10 -> 20 # Insert at beginning operation linked_list.insert_at_beginning(5) print(linked_list) # Output: 5 -> 10 -> 20 # Delete node operation linked_list.delete_node(10) print(linked_list) # Output: 5 -> 20 # Search operation found = linked_list.search(20) print(found) # Output: True # Reverse list operation linked_list.reverse() print(linked_list) # Output: 20 -> 5 # Search operation found = linked_list.search(15) print(found) # Output: False ``` Note: Ensure that the string representation of the linked list in the output is as shown in the example, using the \'->\' separator between nodes.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def __str__(self): if not self.head: return \\"\\" result = [] current = self.head while current: result.append(str(current.value)) current = current.next return \\" -> \\".join(result) def insert_at_beginning(self, value: int) -> None: new_node = Node(value) new_node.next = self.head self.head = new_node def insert_at_end(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def delete_node(self, value: int) -> None: if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def reverse(self) -> None: prev, current = None, self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def search(self, value: int) -> bool: current = self.head while current: if current.value == value: return True current = current.next return False"},{"question":"# Maze Pathfinding with A* **Scenario**: You are assigned to implement a pathfinding algorithm for a maze-solving robot. The robot needs to navigate through a grid-based maze from a start point to an end point using the A* search algorithm. **Objective**: Write a function `astar_maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]` that returns the path from start to end as a list of grid coordinates. If no path is found, return an empty list. **Input**: - `maze` (List[List[int]]): A grid representation of the maze where `0` represents a walkable path and `1` represents an obstacle. - `start` (Tuple[int, int]): A tuple representing the starting coordinates (row, column). - `end` (Tuple[int, int]): A tuple representing the ending coordinates (row, column). **Output**: - A list of tuples (List[Tuple[int, int]]) representing the path from start to end. Each tuple contains the row and column indices of the path. If no path is found, return an empty list. **Constraints**: - 1 <= len(maze), len(maze[i]) <= 100 - The start and end points will always be on walkable paths (0) - The maze boundaries are impassable (1) - Paths are restricted to cardinal directions (up, down, left, right). **Performance Requirements**: - Your implementation should efficiently handle the upper constraint limits and avoid redundant calculations. **Example**: ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) result = astar_maze_solver(maze, start, end) # Expected output path from start to end # [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` Implement the function `astar_maze_solver` following the specified guidelines and ensure to handle performance and edge cases effectively.","solution":"from heapq import heappop, heappush from typing import List, Tuple def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def astar_maze_solver(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows = len(maze) cols = len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] open_set = [] heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} while open_set: _, current = heappop(open_set) if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and maze[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"Problem Statement Write a function `subarray_sum(arr: list[int], k: int) -> int` to find the number of subarrays whose sum equals a given integer `k`. A subarray is a contiguous part of an array. # Function Signature ```python def subarray_sum(arr: list[int], k: int) -> int: # Your code here ``` # Input * `arr` (list of int): The list of integers to examine. * `k` (int): The target sum for the subarrays. # Output * `int`: The number of subarrays whose sum equals `k`. # Constraints * The length of `arr` will not exceed 10^4. * The elements of `arr` will be in the range of `[-10^5, 10^5]`. * The integer `k` will be in the range of `[-10^5, 10^5]`. # Examples ```python assert subarray_sum([1, 1, 1], 2) == 2 assert subarray_sum([1, 2, 3], 3) == 2 assert subarray_sum([-1, -1, 1], 0) == 1 assert subarray_sum([1], 1) == 1 assert subarray_sum([1, -1, 0], 0) == 3 assert subarray_sum([3, 4, 7, 2, -3, 1, 4, 2], 7) == 4 ``` # Notes - Consider using a hash map to keep track of cumulative sums and their frequencies to achieve an efficient solution. - Be mindful of edge cases, such as an empty array or when `k` is not attainable by any subarray.","solution":"def subarray_sum(arr, k): Finds the number of subarrays whose sum equals k. Args: arr (list of int): The list of integers to examine. k (int): The target sum for the subarrays. Returns: int: The number of subarrays whose sum equals k. current_sum = 0 count = 0 prefix_sums = {0: 1} # initialize with 0 sum having one count for num in arr: current_sum += num # Check how many times the (current_sum - k) has occurred in the map if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] # Update the count of current_sum in the map prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"# Problem Statement Create a function called `word_break_with_cache` that determines if a given string `s` can be segmented into one or more words found in a dictionary (`word_dict`). This function should utilize a caching mechanism to improve the performance of the checking process. # Function Signature ```python def word_break_with_cache( s: str, word_dict: set[str], cache: dict[str, bool] | None = None ) -> bool: ``` # Input 1. `s` (str): The input string to be segmented. 2. `word_dict` (set): A set of strings representing the dictionary of words. 3. `cache` (dict, optional): A dictionary used to cache results of previously computed substrings. Default is an empty dictionary if not provided. # Output - `result` (bool): True if the string can be segmented into words from the dictionary, False otherwise. # Constraints - The input string `s` consists of only lowercase English letters. - The dictionary `word_dict` contains non-empty strings of lowercase English letters. - The length of the input string `s` can be up to 300. - The total number of words in the `word_dict` doesn\'t exceed 1000. # Example ```python assert word_break_with_cache(\'leetcode\', {\'leet\', \'code\'}) == True assert word_break_with_cache(\'applepenapple\', {\'apple\', \'pen\'}) == True assert word_break_with_cache(\'catsandog\', {\'cats\', \'dog\', \'sand\', \'and\', \'cat\'}) == False assert word_break_with_cache(\'helloleetcode\', {\'hello\', \'leetcode\'}, {}) == True assert word_break_with_cache(\'aaaab\', {\'a\', \'aa\', \'aaa\'}, {}) == False ``` # Implementation Note 1. Use recursion and memoization to efficiently break down and verify each substring. 2. Cache the results of previously checked substrings to avoid redundant computations. 3. The function should handle both provision and absence of the `cache` parameter seamlessly.","solution":"def word_break_with_cache(s: str, word_dict: set[str], cache: dict[str, bool] | None = None) -> bool: if cache is None: cache = {} if s in cache: return cache[s] if s in word_dict: cache[s] = True return True for i in range(1, len(s)): prefix = s[:i] suffix = s[i:] if prefix in word_dict and word_break_with_cache(suffix, word_dict, cache): cache[s] = True return True cache[s] = False return False"},{"question":"# Longest Common Subsequence Problem Context You are developing a feature for a text comparison tool that highlights the similarities between two documents. One crucial aspect of this feature is the ability to identify the longest common subsequence (LCS) within the text, which can help determine the extent of similarity. Task Implement a function `longest_common_subsequence` that takes in two strings and returns the length of their longest common subsequence. A subsequence is a sequence that appears in the same relative order but not necessarily contiguously. Function Signature ```python def longest_common_subsequence(str1: str, str2: str) -> int: ``` Input - `str1` (str): A string representing the first document. - `str2` (str): A string representing the second document. Output - The function should return an integer which is the length of the longest common subsequence of the two strings. Constraints - Both input strings can have up to 10^3 characters. - The characters in the strings are ASCII characters. Examples 1. `longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\")` - Returns: `4`, the longest common subsequence is \\"BDAB\\" or \\"BCAB\\". 2. `longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\")` - Returns: `4`, the longest common subsequence is \\"GTAB\\". 3. `longest_common_subsequence(\\"12345\\", \\"54321\\")` - Returns: `1`, the longest common subsequence is any one character \\"1\\", \\"2\\", \\"3\\", \\"4\\", or \\"5\\". 4. `longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\")` - Returns: `4`, the longest common subsequence is \\"MJAU\\". 5. `longest_common_subsequence(\\"abcdef\\", \\"abc\\")` - Returns: `3`, the longest common subsequence is \\"abc\\". Performance Requirement The implementation should use dynamic programming to ensure that it efficiently handles the input constraints, with an expected time complexity of `O(n * m)`, where `n` and `m` are the lengths of the input strings.","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. n, m = len(str1), len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[n][m]"},{"question":"# Fibonacci Sequence Calculation The Fibonacci sequence is defined as follows: - ( F(0) = 0 ) - ( F(1) = 1 ) - For ( n > 1 ), ( F(n) = F(n-1) + F(n-2) ) Write a Python function `fibonacci(n: int) -> int` that: 1. Accepts an integer ( n ) as an input parameter. 2. Computes and returns the ( n )-th number in the Fibonacci sequence using an iterative approach. 3. Handles the following constraints: - The input ( n ) should be non-negative. If ( n ) is negative, an appropriate exception with a meaningful message should be raised. # Input * A single integer ( n ), representing the position in the Fibonacci sequence. # Output * An integer representing the ( n )-th number in the Fibonacci sequence. # Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(7) 13 >>> fibonacci(10) 55 ``` # Constraints * ( 0 leq n leq 30 ) Create the function `fibonacci` to meet the specifications above, ensuring input validation and error handling are appropriately implemented.","solution":"def fibonacci(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. Parameters: n (int): The position in the Fibonacci sequence (must be non-negative). Returns: int: The n-th Fibonacci number. Raises: ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement: You are tasked with creating a function that finds the length of the shortest transformation sequence from a start word to an end word, given a dictionary of allowed intermediate words. Each transformed word must be in the dictionary, and only one letter can be changed at a time. The solution should follow a Breadth-First Search (BFS) approach for optimal performance. # Function Signature ```python def shortest_transformation_sequence(beginWord: str, endWord: str, wordList: List[str]) -> int: pass ``` # Input * `beginWord` (str): The starting word for the transformation. The length of `beginWord` is (1 leq |beginWord| leq 100). * `endWord` (str): The target word for the transformation. * `wordList` (List[str]): A list of strings representing the dictionary of words. Each word is of the same length as `beginWord`. # Output * An integer representing the length of the shortest transformation sequence from `beginWord` to `endWord`, including both the begin and end words. If no such transformation sequence exists, return 0. # Constraints * The `beginWord`, `endWord`, and all words in `wordList` are of the same length. * All input strings consist of lowercase English letters only. * There are no duplicate words in `wordList`. # Example ```python >>> shortest_transformation_sequence(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> shortest_transformation_sequence(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 ``` # Explanation For the first example, the shortest transformation sequence (\\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\") has 5 steps. For the second example, since \\"cog\\" is not in the word list, no transformation sequence can be found, thus it returns 0. Implement the `shortest_transformation_sequence` function using a BFS approach to ensure efficient traversal.","solution":"from collections import deque from typing import List def shortest_transformation_sequence(beginWord: str, endWord: str, wordList: List[str]) -> int: if endWord not in wordList: return 0 wordList = set(wordList) queue = deque([(beginWord, 1)]) # Store current word and transformation count while queue: current_word, level = queue.popleft() if current_word == endWord: return level # Try changing each character of the current_word to every letter from \'a\' to \'z\' for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': if c == current_word[i]: continue # Skip same letter next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append((next_word, level + 1)) return 0 # If no transformation sequence is found"},{"question":"# Question: Implement Efficient Data Manipulation with a Custom Linked List Context You are working on a memory-efficient data structure to perform various operations on a list of numerical data. Given the requirement to implement a custom linked list that supports specific operations efficiently, you need to define and manipulate nodes in this custom linked list. Objective Write a Python class `CustomLinkedList` that allows addition, deletion, and retrieval of data nodes. Each node contains a numeric value and supports efficient access and modification. # Requirements 1. **Class Definitions**: a. Define a `Node` class to represent a single node in the linked list with attributes `data` (float) and `next` (Node). b. Define a `CustomLinkedList` class with methods to manipulate the list: 2. **Method Definitions**: - `__init__(self)`: Initialize an empty linked list. - `add_node(self, value: float)`: Add a new node with the given value at the end of the list. - `delete_node(self, value: float)`: Delete the first node with the given value from the list. - `find_node(self, value: float) -> bool`: Return True if a node with the given value exists, otherwise False. - `to_list(self) -> List[float]`: Convert the linked list to a Python list of floats. Input Format - For `add_node`, `delete_node`, and `find_node`: - `value`: A float representing the value to add, delete, or find. Output Format - For `find_node`: A boolean indicating whether the value was found. - For `to_list`: A list of floats representing the values in the linked list. Constraints - Nodes in the linked list must maintain the order of insertion. - The linked list may contain duplicate values. - Handle edge cases such as deleting from an empty list or finding a value that does not exist. Example Usage ```python class Node: def __init__(self, data: float): self.data = data self.next = None class CustomLinkedList: def __init__(self): self.head = None def add_node(self, value: float): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_node(self, value: float): current = self.head if not current: return if current.data == value: self.head = current.next return while current.next and current.next.data != value: current = current.next if current.next: current.next = current.next.next def find_node(self, value: float) -> bool: current = self.head while current: if current.data == value: return True current = current.next return False def to_list(self) -> List[float]: result = [] current = self.head while current: result.append(current.data) current = current.next return result # Example Operations linked_list = CustomLinkedList() linked_list.add_node(1.1) linked_list.add_node(2.2) linked_list.add_node(3.3) print(linked_list.to_list()) # Expected output: [1.1, 2.2, 3.3] linked_list.delete_node(2.2) print(linked_list.find_node(2.2)) # Expected output: False print(linked_list.find_node(3.3)) # Expected output: True print(linked_list.to_list()) # Expected output: [1.1, 3.3] ``` # Guidelines: - Ensure proper handling of edge cases like deleting from an empty list. - Appropriately manage memory and references within the linked list. - Validate and document the solution adequately.","solution":"class Node: def __init__(self, data: float): self.data = data self.next = None class CustomLinkedList: def __init__(self): self.head = None def add_node(self, value: float): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_node(self, value: float): current = self.head if not current: return if current.data == value: self.head = current.next return while current.next and current.next.data != value: current = current.next if current.next: current.next = current.next.next def find_node(self, value: float) -> bool: current = self.head while current: if current.data == value: return True current = current.next return False def to_list(self) -> list: result = [] current = self.head while current: result.append(current.data) current = current.next return result"},{"question":"# Problem Statement You are tasked with optimizing an operation within a sorted, rotated array. The goal is to find the minimum element in such an array. This problem aims to test your understanding of binary search and handling edge cases in rotated arrays. # Function to Implement Implement the function `find_minimum(nums: List[int]) -> int` in Python, where: * `nums` is a list of integers sorted in ascending order and then rotated at an unknown pivot. # Input and Output * **Input**: A list `nums` of integers. * **Output**: The minimum element in the list. # Constraints 1. The list length will be between `1` and `10^6`. 2. Elements in the list are between `-10^9` and `10^9`. 3. You must implement an O(log n) solution using a modified binary search. # Examples ```python assert find_minimum([3, 4, 5, 1, 2]) == 1 assert find_minimum([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_minimum([11, 13, 15, 17]) == 11 assert find_minimum([2, 1]) == 1 assert find_minimum([2]) == 2 ``` # Performance Requirements * Your solution should operate efficiently for large lists, ensuring that the time complexity is O(log n). # Additional Notes Consider edge cases such as: * Single-element arrays. * Arrays that are not rotated. * Rotated arrays with duplicates if any. * Handling very large and very small numbers properly within the constraints. Implement your function to handle all edge cases effectively.","solution":"def find_minimum(nums): Finds the minimum element in a sorted, rotated array. Args: nums (List[int]): The input list of integers. Returns: int: The minimum element in the list. if not nums: raise ValueError(\\"nums must contain at least one element\\") left, right = 0, len(nums) - 1 # If the array is not rotated (the smallest element is at the front) if nums[left] < nums[right]: return nums[left] while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"Prefix String Matcher # Scenario You are tasked with creating a utility to categorize words based on their common prefixes. A prefix in this context defined as the string formed by the initial characters of the word up to a specified length, N. If the length of the word is less than N, use the entire word as the prefix. # Function to Implement You need to write a function, `get_prefix_groups`, that will accept a list of words and an integer N, and return a dictionary where the keys are prefixes and the values are lists of words that share that prefix. # Function Signature ```python def get_prefix_groups(words: list, N: int) -> dict: pass ``` # Input - A list of strings representing words. (1 ≤ len(words) ≤ 1000, 1 ≤ len(word) ≤ 100) - An integer N representing the length of the prefix. (1 ≤ N ≤ 100) # Output - A dictionary where the keys are prefix strings and the values are lists of words that share that prefix. # Constraints - Assume all words are case-insensitive and should be converted to lowercase. - Words may contain spaces or punctuation. - You need to handle non-alphabetic input gracefully. # Example ```python get_prefix_groups([\\"apple\\", \\"application\\", \\"ape\\", \\"app\\", \\"banana\\", \\"band\\", \\"bandit\\"], 3) ``` Output: ```python { \'app\': [\'apple\', \'application\', \'app\'], \'ape\': [\'ape\'], \'ban\': [\'banana\', \'band\', \'bandit\'] } ``` # Notes - Ensure the function handles cases where words may not have enough characters to form a full-length prefix by using the entire word as the prefix. - Make sure the function does not fail on receiving empty or non-string inputs, where appropriate return an empty dictionary. - Ensure that your code handles performance efficiently for larger lists of words.","solution":"def get_prefix_groups(words: list, N: int) -> dict: Groups words by their prefixes of length N. Args: words (list): A list of words to be grouped. N (int): The length of the prefix to consider. Returns: dict: A dictionary with keys as prefixes and values as lists of words sharing that prefix. prefix_groups = {} for word in words: word_lower = word.lower() prefix = word_lower[:N] if prefix not in prefix_groups: prefix_groups[prefix] = [] prefix_groups[prefix].append(word) return prefix_groups"},{"question":"# Context Binary Tree Traversal is fundamental in understanding and utilizing binary data structures. In particular, In-order Traversal is used frequently for various applications, including sorting and searching. # Task Write a function that performs an In-order Traversal on a given binary tree and returns the list of values in in-order sequence. Your implementation should traverse the binary tree without using recursion (iteratively). # Input and Output * **Input**: A reference to the `root` node of the binary tree. * **Output**: A list of integers representing the tree\'s nodes in in-order sequence. # Constraints * You cannot use recursion. * The binary tree nodes may have integer values within the range -1000 to 1000. * The number of nodes in the binary tree will be in the range of 0 to 10^4. # Examples ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right >>> root = TreeNode(1, None, TreeNode(2, TreeNode(3))) >>> in_order_traversal(root) [1, 3, 2] >>> root = TreeNode(1) >>> in_order_traversal(root) [1] >>> root = None >>> in_order_traversal(root) [] ``` # Implementation Requirements * Do not use recursion; instead, use an iterative method with a stack. * Ensure the solution is efficient in terms of time and space complexity. * Validate edge cases such as an empty tree or a tree with a single node. # Hints * Utilize a stack to keep track of the nodes. * Adhere to the Left-Root-Right sequence for in-order traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_traversal(root): Performs in-order traversal of a binary tree iteratively. Args: root (TreeNode): The root node of the binary tree. Returns: list: The list of node values in in-order sequence. result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Problem: Find the First Unique Character You are given a string, and you need to find the first non-repeating character in that string. Implement a function `first_unique_character` that takes a string as input and returns the first character that does not repeat. If there is no such character, return an empty string. Input: * A string `s` (1 <= len(s) <= 10^5) consisting of lowercase Latin letters. Output: * A single character, or an empty string if no unique character is found. Requirements: * Your solution should efficiently process the input string. * Aim to minimize auxiliary space utilization. Example: ```python >>> first_unique_character(\\"leetcode\\") \'l\' >>> first_unique_character(\\"loveleetcode\\") \'v\' >>> first_unique_character(\\"aabb\\") \'\' ``` Constraints: * The input string will contain at least one character. * Your implementation should be able to handle a large number of characters efficiently.","solution":"def first_unique_character(s): Returns the first non-repeating character in the string s. If no unique character is found, returns an empty string. # Step 1: Calculate the frequency of each character in the string char_frequency = {} for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Step 2: Find and return the first character with a frequency of 1 for char in s: if char_frequency[char] == 1: return char return \\"\\""},{"question":"# Order Book System Your task is to implement a basic order book system for a stock trading platform. The system should handle buy and sell orders and match them efficiently based on the price and timestamp. Class Definition ```python class OrderBook: def __init__(self) -> None: Initialize the OrderBook with two empty lists for buy and sell orders. self.buy_orders = [] self.sell_orders = [] def add_order(self, order_type: str, price: int, quantity: int, timestamp: int) -> None: Adds an order to the order book. Parameters: - order_type (str): Either \\"buy\\" or \\"sell\\". - price (int): The price of the order. - quantity (int): The quantity of the stock. - timestamp (int): The timestamp of the order. pass def match_orders(self) -> list[tuple[int, int, int]]: Matches buy and sell orders. Returns: - List of tuples (price, quantity, timestamp) representing matched orders. pass def get_order_book(self) -> dict: Returns the current state of the order book. Returns: - A dictionary with two keys \\"buy\\" and \\"sell\\" containing lists of current orders. pass ``` # Requirements 1. **Initialization**: The `__init__` method should initialize the order book with empty lists for buy and sell orders. 2. **add_order**: Add an order to the order book with the given type, price, quantity, and timestamp. Buy orders should be sorted in descending order of price, and within the same price, by ascending timestamp. Sell orders should be sorted in ascending order of price, and within the same price, by ascending timestamp. 3. **match_orders**: Implement order matching logic. Buy orders should be matched with sell orders if the buy price is greater than or equal to the sell price. Orders should be matched based on price and timestamp priority. Return a list of matched orders as tuples of (price, quantity, timestamp). 4. **get_order_book**: Return the current state of the order book with two keys \\"buy\\" and \\"sell\\", each containing the respective lists of current orders. # Constraints * Price, quantity, and timestamp values will be integer types. * The order book should be able to handle up to 100,000 orders efficiently. Example Usage: ```python order_book = OrderBook() order_book.add_order(\\"buy\\", 100, 10, 1) order_book.add_order(\\"sell\\", 95, 5, 2) print(order_book.match_orders()) # Output: [(95, 5, 2)] order_book.add_order(\\"buy\\", 95, 10, 3) print(order_book.get_order_book()[\'buy\']) # Output: [(100, 10, 1), (95, 10, 3)] print(order_book.get_order_book()[\'sell\']) # Output: [] ``` # Notes * Ensure that the matching logic is efficient and handles edge cases, such as orders with the same price but different timestamps. * The `add_order` method should insert orders maintaining the sorted order required for efficient matching. * `get_order_book` should return the current state without altering the internal order book. * Include sufficient documentation and method-level comments to explain your logic and decisions.","solution":"class OrderBook: def __init__(self) -> None: Initialize the OrderBook with two empty lists for buy and sell orders. self.buy_orders = [] self.sell_orders = [] def add_order(self, order_type: str, price: int, quantity: int, timestamp: int) -> None: Adds an order to the order book. Parameters: - order_type (str): Either \\"buy\\" or \\"sell\\". - price (int): The price of the order. - quantity (int): The quantity of the stock. - timestamp (int): The timestamp of the order. order = (price, quantity, timestamp) if order_type == \\"buy\\": # Insert the order keeping the list sorted by price descending, then by timestamp ascending index = 0 while index < len(self.buy_orders) and (self.buy_orders[index][0] > price or (self.buy_orders[index][0] == price and self.buy_orders[index][2] < timestamp)): index += 1 self.buy_orders.insert(index, order) elif order_type == \\"sell\\": # Insert the order keeping the list sorted by price ascending, then by timestamp ascending index = 0 while index < len(self.sell_orders) and (self.sell_orders[index][0] < price or (self.sell_orders[index][0] == price and self.sell_orders[index][2] < timestamp)): index += 1 self.sell_orders.insert(index, order) def match_orders(self) -> list[tuple[int, int, int]]: Matches buy and sell orders. Returns: - List of tuples (price, quantity, timestamp) representing matched orders. matches = [] while self.buy_orders and self.sell_orders: buy_order = self.buy_orders[0] sell_order = self.sell_orders[0] buy_price, buy_quantity, buy_timestamp = buy_order sell_price, sell_quantity, sell_timestamp = sell_order if buy_price >= sell_price: matched_quantity = min(buy_quantity, sell_quantity) matches.append((sell_price, matched_quantity, sell_timestamp)) if buy_quantity > matched_quantity: self.buy_orders[0] = (buy_price, buy_quantity - matched_quantity, buy_timestamp) else: self.buy_orders.pop(0) if sell_quantity > matched_quantity: self.sell_orders[0] = (sell_price, sell_quantity - matched_quantity, sell_timestamp) else: self.sell_orders.pop(0) else: break return matches def get_order_book(self) -> dict: Returns the current state of the order book. Returns: - A dictionary with two keys \\"buy\\" and \\"sell\\" containing lists of current orders. return { \\"buy\\": self.buy_orders, \\"sell\\": self.sell_orders }"},{"question":"# Coding Question: Path Sum in a 2D Grid You are given a 2D grid of integers where each cell contains a certain value. You start from the top-left cell of the grid and can only move right or down to reach the bottom-right cell. You need to find the maximum sum of values along a path from the top-left to the bottom-right cell. **Scenario**: Imagine you are developing a game where a character moves from the top-left corner to the bottom-right corner of a grid. Each cell contains points, and the character collects points as they move. The character can only move right or down at each step. Your goal is to determine the maximum points the character can collect by the time they reach the bottom-right corner. Function Signature ```python def max_path_sum(grid: List[List[int]]) -> int: pass ``` Input * `grid` (List[List[int]]): A 2D list of integers representing the grid. Output * Returns an integer, the maximum sum of values along a path from the top-left to the bottom-right cell. Constraints * The grid will have at least 1 row and 1 column. * The values within the grid can be positive, zero, or negative. * The size of the grid will not exceed 100x100. Example ```python assert max_path_sum([[5, 3, 2], [1, 7, 1], [4, 2, 8]]) == 23 # Path: 5 -> 3 -> 7 -> 2 -> 8. Sum = 25. assert max_path_sum([[1, 2, 5], [3, 2, 1]]) == 9 # Path: 1 -> 3 -> 2 -> 1. Sum = 7. ``` Notes * Ensure your function handles different grid sizes and values efficiently. * Consider optimizing your solution to avoid excessive computation time for larger grids. * Implement robust error checking where relevant.","solution":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, cols): dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Problem Statement You are given a list of integers and an integer `k`. Your task is to implement a function that rotates the list to the right by `k` positions. This means that the last `k` elements of the list will move to the front in the same order, and the rest of the elements will shift right. If `k` is greater than the length of the list, the rotation should continue cyclically. # Function Signature ```python def rotate_list(array: list[int], k: int) -> list[int]: :param array: List of integers to rotate. :param k: Number of positions to rotate the list to the right. :return: The list after rotating it to the right by k positions. ``` # Input - `array`: A list of integers of length `n` where `0 <= n <= 10^5`. - `k`: An integer such that `0 <= k <= 10^5`. # Output - A list representing the input list rotated to the right by `k` positions. # Examples ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([10, 20, 30, 40], 1) [40, 10, 20, 30] >>> rotate_list([7, 7, 7, 7], 3) [7, 7, 7, 7] >>> rotate_list([1, 2, 3], 3) [1, 2, 3] >>> rotate_list([], 2) [] ``` # Constraints - The list may be empty, in which case the output should also be an empty list. - If `k` is zero, the list should remain unchanged. - Time complexity should be O(n). - Use of in-built libraries for rotating the list is not allowed (e.g., `collections.deque.rotate`). # Additional Notes - Consider the edge cases such as when `k` is zero, list is empty, or `k` is greater than the length of the list. - The function should handle large values of `k` efficiently.","solution":"def rotate_list(array: list[int], k: int) -> list[int]: Rotates the list to the right by k positions. if not array: return [] k = k % len(array) # Handle cases where k is larger than len(array) return array[-k:] + array[:-k] if k != 0 else array"},{"question":"# Question: Implement a Min-Heap Data Structure Implement a Min-Heap, a complete binary tree where the root is the minimum element and each parent node is less than or equal to its child nodes. The task is to implement the core functionalities of a Min-Heap: `insert`, `extract_min`, and `heapify`. Requirements: * Implement a class `MinHeap` to encapsulate the heap operations. * Implement the following methods: * `__init__(self)`: Initialize an empty heap. * `insert(self, element)`: Insert an element into the heap while maintaining the heap property. * `extract_min(self)`: Remove and return the minimum element from the heap, while maintaining the heap property. * `heapify(self, arr)`: Given an array, build a Min-Heap from it in O(n) time complexity. # Class Signature: ```python class MinHeap: def __init__(self): Initialize an empty Min-Heap. def insert(self, element): Insert an element into the heap. :param element: The element to be inserted. def extract_min(self): Remove and return the minimum element from the heap. :return: The minimum element in the heap. def heapify(self, arr): Build a heap from an array. :param arr: List of elements to be converted into a heap. ``` # Example: ```python >>> heap = MinHeap() >>> heap.insert(3) >>> heap.insert(1) >>> heap.insert(6) >>> heap.insert(5) >>> heap.insert(2) >>> heap.insert(4) >>> heap.extract_min() 1 >>> heap.extract_min() 2 >>> heap.extract_min() 3 >>> heap = MinHeap() >>> heap.heapify([9, 3, 5, 7, 2, 6, 4, 8]) >>> heap.extract_min() 2 >>> heap.extract_min() 3 ``` # Instructions: 1. Implement a list-based Min-Heap data structure. 2. Implement the core methods to manipulate and maintain the properties of a Min-Heap. 3. Ensure that `insert` and `extract_min` operations maintain O(log n) time complexity. 4. Ensure that `heapify` is implemented in O(n) time complexity.","solution":"class MinHeap: def __init__(self): Initialize an empty Min-Heap. self.heap = [] def insert(self, element): Insert an element into the heap. :param element: The element to be inserted. self.heap.append(element) self._bubble_up(len(self.heap) - 1) def extract_min(self): Remove and return the minimum element from the heap. :return: The minimum element in the heap. if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return root def heapify(self, arr): Build a heap from an array. :param arr: List of elements to be converted into a heap. self.heap = arr[:] for i in range(len(arr) // 2 - 1, -1, -1): self._bubble_down(i) def _bubble_up(self, index): parent = (index - 1) >> 1 while index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent parent = (index - 1) >> 1 def _bubble_down(self, index): min_index = index left_child = (index << 1) + 1 right_child = (index << 1) + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[min_index]: min_index = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[min_index]: min_index = right_child if min_index != index: self.heap[index], self.heap[min_index] = self.heap[min_index], self.heap[index] self._bubble_down(min_index)"},{"question":"Variant Subsequence Problem Context: In a given string, a subsequence is a sequence derived by deleting some or none of the characters without changing the order of the remaining characters. A subsequence is considered \\"variant\\" if it skips over at least one character of the original string. Task: Write a function that finds the length of the longest \\"variant\\" subsequence which contains all unique characters, skipping over at least one character of the original string. Requirements: 1. **Input**: A single string `s`. 2. **Output**: An integer representing the length of the longest variant subsequence that contains all unique characters. Input and Output Constraints: * `s` will be a non-empty string consisting of lowercase English letters. Implementation: Your solution should: 1. Identify the longest unique character subsequence. 2. Ensure that the subsequence skips over at least one character. 3. Return the length of this subsequence. Function Signature: ```python def longest_variant_subsequence(s: str) -> int: pass ``` Example: ```python >>> longest_variant_subsequence(\\"abracadabra\\") 4 >>> longest_variant_subsequence(\\"abcd\\") 3 >>> longest_variant_subsequence(\\"banana\\") 3 >>> longest_variant_subsequence(\\"abcabcabc\\") 3 ```","solution":"def longest_variant_subsequence(s: str) -> int: # Unique characters in the string unique_chars = set(s) # If the length of unique characters set is less than or equal to 1, # we can\'t have a \\"variant\\" subsequence which skips at least one character. if len(unique_chars) <= 1: return 0 # As we need to skip at least one character # Length of unique characters unique_length = len(unique_chars) # For the longest \\"variant\\" subsequence that skips at least one character, # we need to remove at least one character from the longest subsequence. return unique_length - 1"},{"question":"# Question You are tasked to implement a function related to the linked list data structure described below. Problem Statement Given a singly linked list where each node contains an integer value, implement a function `reverse_sublist` that reverses a specific portion of the linked list. The portion to be reversed begins at position `m` and ends at position `n` (1-indexed positions), both inclusive. You need to return the head of the modified linked list. If `m` is equal to `n`, the linked list should remain unchanged. Function Signature ```python def reverse_sublist(head: ListNode | None, m: int, n: int) -> ListNode | None: ``` Input - `head` (ListNode | None): The head node of the singly linked list. It can be `None` if the list is empty. - `m` (int): The starting position of the sublist to be reversed (1-indexed). - `n` (int): The ending position of the sublist to be reversed (1-indexed). Output - `ListNode | None`: Return the head of the linked list after the sublist has been reversed. Constraints 1. The number of nodes in the list is in the range [0, 10^4]. 2. Each node\'s value is in the range [-1000, 1000]. 3. 1 ≤ m ≤ n ≤ number of nodes in the list. Example ```python # List structure: 1 -> 2 -> 3 -> 4 -> 5 # Range: m = 2, n = 4 # After reversing the sublist from position 2 to 4: # List structure: 1 -> 4 -> 3 -> 2 -> 5 class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next # Constructing the list: head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) result = reverse_sublist(head, 2, 4) # Output list after function -> 1 -> 4 -> 3 -> 2 -> 5 # Helper function to print the linked list def print_list(node): while node: print(node.value, end=\' -> \' if node.next else \'\') node = node.next print_list(result) # Expected output should be the sequence: 1 -> 4 -> 3 -> 2 -> 5 ``` Requirements - Implement the `reverse_sublist` function ensuring it handles edge cases like an empty list, a single-node list, and contiguous ranges from head to tail. - Consider performance: the function should efficiently handle the upper limit of the constraints.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_sublist(head: ListNode | None, m: int, n: int) -> ListNode | None: if not head or m == n: return head dummy = ListNode(0) dummy.next = head pre = dummy # Move pre to the node right before the start of the sublist for _ in range(m - 1): pre = pre.next # Reverse the sublist from m to n current = pre.next then = current.next for _ in range(n - m): current.next = then.next then.next = pre.next pre.next = then then = current.next return dummy.next"},{"question":"# Coding Question: Converting Infix to Postfix Expression using Stack Context: In computer science, expressions are often written in infix notation where operators are placed between operands (e.g., `A + B`). To evaluate these expressions in programs, it is often useful to convert infix expressions to postfix notation (also known as Reverse Polish Notation - RPN) where operators follow their operands (e.g., `A B +`). Task: Create a function that converts an infix expression (given as a string) to a postfix expression. Requirements: * **Function Signature**: `def infix_to_postfix(expression: str) -> str` * **Input**: * `expression`: A string representing the infix expression. The expression will contain single-letter operands (A-Z), binary operators (+, -, *, /), and parentheses for grouping. * **Output**: * A string representing the postfix expression corresponding to the given infix expression. * **Constraints**: * The input expression will be a valid infix expression. * The length of the expression will not exceed 1000 characters. Here is an example for your reference: ```python assert infix_to_postfix(\\"A+B*C\\") == \\"ABC*+\\" assert infix_to_postfix(\\"(A+B)*C\\") == \\"AB+C*\\" assert infix_to_postfix(\\"A*(B+C*D)+E\\") == \\"ABCD*+*E+\\" ``` Challenge: Implement the function using a stack to manage the operators and parentheses. Ensure that the operators follow the proper precedence and associativity rules. Use Python\'s list data structure as the stack for your implementation.","solution":"def infix_to_postfix(expression: str) -> str: Converts the given infix expression to its equivalent postfix expression. precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2, \'(\': 0} stack = [] postfix = [] for char in expression: if char.isalpha(): # Operand postfix.append(char) elif char == \'(\': # Left parenthesis stack.append(char) elif char == \')\': # Right parenthesis while stack and stack[-1] != \'(\': postfix.append(stack.pop()) stack.pop() # Pop the left parenthesis else: # Operator while stack and precedence[stack[-1]] >= precedence[char]: postfix.append(stack.pop()) stack.append(char) while stack: postfix.append(stack.pop()) return \'\'.join(postfix)"},{"question":"# Word Frequency Counter Problem Description: Write a function that takes a string of text and returns a dictionary representing the frequency of each unique word in the text. Function Signature: ```python def word_frequencies(text: str) -> dict: pass ``` Input: * A single string `text` representing the input text. The text will consist of only lowercase English letters and spaces. The length of the text will be between 1 and 10,000 characters. Output: * A dictionary where keys are unique words from the input text, and values are the count of each word\'s occurrence. Examples: * **Example 1**: ```python word_frequencies(\\"hello world\\") ``` **Output**: ```python {\'hello\': 1, \'world\': 1} ``` * **Example 2**: ```python word_frequencies(\\"this is a test this is only a test\\") ``` **Output**: ```python { \'this\': 2, \'is\': 2, \'a\': 2, \'test\': 2, \'only\': 1 } ``` * **Example 3**: ```python word_frequencies(\\"the quick brown fox jumps over the lazy dog the dog barks\\") ``` **Output**: ```python { \'the\': 3, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 2, \'barks\': 1 } ``` Notes: * Words are defined as any sequences of characters separated by spaces. * The function should be case-insensitive, and it should handle multiple spaces between words gracefully.","solution":"def word_frequencies(text: str) -> dict: Returns a dictionary representing the frequency of each unique word in the text. words = text.split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"# Coding Question Context As part of your role in a software development firm, you are tasked with optimizing sorting operations for a large dataset. This dataset often requires sorting by multiple criteria, and performance improvements can make significant differences in the overall system efficiency. Problem Write a Python function `custom_sort` that sorts a list of dictionaries based on multiple keys in descending and ascending order as specified. The list can be large, and your implementation should aim to be efficient. Requirements 1. Your function should handle various data types and sort criteria. 2. The function should maintain efficiency even with large datasets. Input and Output Formats * **Input**: A list of dictionaries and a list of tuples specifying the sort order. Each tuple contains a key and a boolean indicating ascending (True) or descending (False) order. ```python def custom_sort(data: list, sort_order: list) -> list: pass ``` * **Output**: A sorted list of dictionaries. Constraints * Each dictionary will have the same keys. * The sort order list will contain valid keys present in the dictionaries. Example ```python data = [ {\'name\': \'Alice\', \'age\': 30, \'score\': 85}, {\'name\': \'Bob\', \'age\': 25, \'score\': 90}, {\'name\': \'Charlie\', \'age\': 35, \'score\': 82}, {\'name\': \'David\', \'age\': 30, \'score\': 88} ] # Sort by score descending, then by age ascending sort_order = [(\'score\', False), (\'age\', True)] assert custom_sort(data, sort_order) == [ {\'name\': \'Bob\', \'age\': 25, \'score\': 90}, {\'name\': \'David\', \'age\': 30, \'score\': 88}, {\'name\': \'Alice\', \'age\': 30, \'score\': 85}, {\'name\': \'Charlie\', \'age\': 35, \'score\': 82} ] data2 = [ {\'name\': \'Alice\', \'age\': 30, \'score\': 85}, {\'name\': \'Bob\', \'age\': 25, \'score\': 85}, {\'name\': \'Alice\', \'age\': 25, \'score\': 85} ] # Sort by name ascending, then by age descending sort_order2 = [(\'name\', True), (\'age\', False)] assert custom_sort(data2, sort_order2) == [ {\'name\': \'Alice\', \'age\': 30, \'score\': 85}, {\'name\': \'Alice\', \'age\': 25, \'score\': 85}, {\'name\': \'Bob\', \'age\': 25, \'score\': 85} ] ```","solution":"def custom_sort(data, sort_order): Sorts a list of dictionaries based on multiple keys in specified order (ascending/descending). Parameters: - data (list): A list of dictionaries to sort. - sort_order (list): A list of tuples, where each tuple contains a key and a boolean indicating ascending (True) or descending (False). Returns: - list: A sorted list of dictionaries. for key, reverse in reversed(sort_order): data.sort(key=lambda x: x[key], reverse=not reverse) return data"},{"question":"# Product of Array Except Self Context You are given an array of integers `nums`. Write a function that returns an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. Function Signature ```python def product_except_self(nums: list[int]) -> list[int]: ``` Inputs - `nums`: A list of integers. Outputs - A list of integers where each element is the product of all other elements in `nums` except the element at the same index. Constraints - The length of `nums` is at least 1 and does not exceed (10^4). - The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer. - You cannot use division to solve the problem. - The algorithm should run in O(n) time complexity. Example ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([0, 0, 0, 5]) [0, 0, 0, 0] >>> product_except_self([5]) [1] ``` Instructions 1. Use two arrays to store products of elements to the left and right of each element. 2. Traverse the input array twice to fill these arrays. 3. Produce the final result by multiplying the corresponding elements of these two arrays. Edge Cases to Consider - The input list is empty or contains only one element. - There are zero or multiple zeros in the input list. Note Ensure you utilize O(n) time complexity and do not use division to solve the problem. The function should handle large lists efficiently.","solution":"def product_except_self(nums): length = len(nums) # Initialize arrays to store prefix and suffix products prefix_products = [1] * length suffix_products = [1] * length # Calculate prefix products for i in range(1, length): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Calculate suffix products in reverse order for i in range(length - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * nums[i + 1] # Multiply prefix and suffix products to get the final result result = [prefix_products[i] * suffix_products[i] for i in range(length)] return result"},{"question":"# Problem Statement You are given a list of non-negative integers representing the amount of time each task will take. Each task can be performed during a single unit of time. However, you can only work on one task at a time, and you want to minimize the total time required to complete all tasks, given that certain tasks might have dependencies and cannot start until the dependent task is finished. Write a function that determines the minimum total time required to complete all tasks. If it is impossible to complete all tasks due to circular dependencies, return -1. # Function to Implement Implement the function `min_time_required(tasks: List[int], dependencies: List[Tuple[int, int]]) -> int`: * `tasks`: a list of integers where `tasks[i]` represents the time required to complete the i-th task. ** `dependencies`: a list of tuples (a, b) where task b depends on task a, meaning task b cannot start until task a is complete. # Expected Input/Output Formats * **Input**: The function takes two parameters: `tasks` and `dependencies`. * `tasks` - a list of integers. * `dependencies` - a list of tuples of integers. * **Output**: The function returns an integer indicating the minimum total time required to complete all tasks or -1 if it is impossible due to circular dependencies. # Constraints 1. The length of the `tasks` list is at least 1 and no more than 1000. 2. All elements in `tasks` are non-negative integers. 3. The `dependencies` list may contain up to 1000 tuples. 4. Circular dependencies make it impossible to complete all tasks. # Example ```python def test_min_time_required(): assert min_time_required([4, 2, 3], [(0, 1), (1, 2)]) == 9 assert min_time_required([3, 2, 5], [(0, 1), (1, 0)]) == -1 assert min_time_required([2, 3, 1], [(0, 1), (1, 2), (2, 0)]) == -1 test_min_time_required() ``` # Explanation 1. In the first example, Task 0 takes 4 units, Task 1 takes 2 units (after Task 0), and Task 2 takes 3 units (after Task 1), for a total of 4 + 2 + 3 = 9 units of time. 2. In the second example, there\'s a circular dependency between Task 0 and Task 1, making it impossible to complete the tasks, so the function returns -1. 3. In the third example, there\'s a circular dependency involving all tasks, thus the function also returns -1.","solution":"from typing import List, Tuple from collections import deque def min_time_required(tasks: List[int], dependencies: List[Tuple[int, int]]) -> int: n = len(tasks) indegree = [0] * n graph = [[] for _ in range(n)] # Build graph and calculate indegree of each task for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Queue for tasks with no prerequisites queue = deque() for i in range(n): if indegree[i] == 0: queue.append(i) total_time = 0 time_taken = [0] * n # Process tasks in topological order while queue: task = queue.popleft() # Update total time taken for current task time_taken[task] += tasks[task] total_time = max(total_time, time_taken[task]) for neighbor in graph[task]: indegree[neighbor] -= 1 # Update the time taken for the dependent task time_taken[neighbor] = max(time_taken[neighbor], time_taken[task]) if indegree[neighbor] == 0: queue.append(neighbor) # Check if there\'s a task with non-zero indegree (indicating a cycle) if any(indegree): return -1 return total_time"},{"question":"# Question: Scheduling Tasks with Priority and Time Constraints **Context**: A company has a set of tasks that need to be completed by certain deadlines. Each task has a start time, an end time (deadline), and a priority level. The goal is to maximize the total priority of completed tasks within the given time constraints. You decide to use a greedy algorithm to select the tasks that will give the highest total priority without overlapping schedules. **Task**: 1. Write a class `Task` that represents an individual task. It should have properties for `name`, `start_time`, `end_time`, and `priority`. 2. Write the method `schedule_tasks` that selects and schedules tasks using a greedy approach to maximize total priority without any task\'s time range overlapping another\'s time range. **Implementation**: 1. Define the `Task` class: - `__init__(self, name: str, start_time: int, end_time: int, priority: int)`. - Properties: `name`, `start_time`, `end_time`, and `priority`. 2. Define the function `schedule_tasks`: - `schedule_tasks(tasks: List[Task]) -> List[Task]` - Use a greedy algorithm to select tasks, maximizing the total priority while ensuring that no two selected tasks overlap. **Constraints**: - Tasks cannot overlap; a task can only be scheduled if its start time is greater than or equal to the end time of the previously scheduled task. - The priority of a task is a positive integer. - Assume all times are given as integers representing hours of the day, with `0 <= start_time < end_time <= 24`. **Expected Input/Output**: - **Input**: - A list of `Task` objects, each with properties `name`, `start_time`, `end_time`, and `priority`. - **Output**: - A list of `Task` objects that were selected to be scheduled, maximizing total priority without overlapping times. ```python from typing import List class Task: def __init__(self, name: str, start_time: int, end_time: int, priority: int): self.name = name self.start_time = start_time self.end_time = end_time self.priority = priority def schedule_tasks(tasks: List[Task]) -> List[Task]: # Sort tasks by their end time tasks.sort(key=lambda x: x.end_time) scheduled_tasks = [] last_end_time = 0 for task in tasks: if task.start_time >= last_end_time: scheduled_tasks.append(task) last_end_time = task.end_time return scheduled_tasks # Example tasks tasks = [ Task(\\"Task A\\", 1, 3, 50), Task(\\"Task B\\", 2, 5, 20), Task(\\"Task C\\", 3, 8, 30), Task(\\"Task D\\", 4, 7, 40), Task(\\"Task E\\", 6, 10, 10) ] scheduled = schedule_tasks(tasks) for task in scheduled: print(f\\"Task: {task.name}, Start: {task.start_time}, End: {task.end_time}, Priority: {task.priority}\\") ``` This question assesses the ability to implement a greedy algorithm, handle scheduling and priority management, and apply constraints to achieve optimal task selection. It involves concepts like sorting, greedy strategy, and basic time management.","solution":"from typing import List class Task: def __init__(self, name: str, start_time: int, end_time: int, priority: int): self.name = name self.start_time = start_time self.end_time = end_time self.priority = priority def schedule_tasks(tasks: List[Task]) -> List[Task]: # Sort tasks by their end time tasks.sort(key=lambda x: x.end_time) scheduled_tasks = [] last_end_time = 0 for task in tasks: if task.start_time >= last_end_time: scheduled_tasks.append(task) last_end_time = task.end_time return scheduled_tasks"},{"question":"# Problem Statement You are given a list of integers and a target sum. Your task is to write a function `find_pair_with_sum` that finds the first pair of integers from the list that add up to the given target sum. If no such pair exists, the function should return `None`. # Input and Output Formats Input: * `nums` (list): A list of integers. * `target` (int): The target sum. Output: * A tuple containing the first pair of integers that add up to the target sum, or `None` if no such pair exists. # Constraints: * The list `nums` will contain only integers (positive, negative, and zero). * The maximum size of the list is (10^4). * The target sum will be an integer. # Performance Requirements: * Your implementation should be optimized for performance given the constraints. # Examples: ```python >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None ``` # Additional Test Case: ```python >>> find_pair_with_sum([-1, 0, 1, 2, -1, -4], -1) (-1, 0) ``` # Edge Cases: 1. Empty list: ```python >>> find_pair_with_sum([], 5) None ``` 2. Single element list: ```python >>> find_pair_with_sum([5], 5) None ``` # Implementation Requirements: * Ensure that the input list is not empty; if it is, return `None`. * Once the first valid pair is found, return it immediately.","solution":"def find_pair_with_sum(nums, target): Finds the first pair of integers in the list `nums` that add up to `target`. Returns the pair as a tuple. If no such pair exists, returns None. :param nums: List[int] - A list of integers. :param target: int - The target sum. :return: tuple or None seen = set() for num in nums: complement = target - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"Question Sorting algorithms are fundamental in computer science, playing a crucial role in data organization and retrieval. Implement the QuickSort algorithm to sort a list of integers in ascending order. The function should modify the input list in-place and not return any value. # Function Signature ```python def quicksort(arr: List[int], low: int, high: int) -> None: pass ``` # Input * A list of integers `arr` (0 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). * Two integers `low` and `high` representing the starting and ending indices for the sort (0 ≤ low ≤ high < len(arr)). # Output * The function modifies the input list in-place and does not return any value. # Examples ```python >>> arr = [10, 7, 8, 9, 1, 5] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1, 5, 7, 8, 9, 10] >>> arr = [3, -1, 2, 1, 0, 3, 2] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [-1, 0, 1, 2, 2, 3, 3] >>> arr = [] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [] ``` # Scenario QuickSort is a highly efficient sorting algorithm often applied in systems requiring fast data processing, such as e-commerce platforms where product listings must be dynamically ordered based on user preferences. The purpose of this function is to provide a robust and efficient sorting mechanism capable of handling large datasets under real-time constraints. # Notes Implement QuickSort as described, ensuring efficient partitioning and recursive sorting. Handle edge cases such as empty lists and lists with large numbers efficiently. The function will be tested for various input arrays, validating that the algorithm performs well within the constraints provided. # Constraints * The function must sort the array in-place. * The algorithm\'s average time complexity should be O(n log n), where n is the length of the list. * The implementation should handle the worst-case scenario gracefully, ensuring performance does not degrade excessively.","solution":"from typing import List def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] # choosing the last element as pivot i = low - 1 # index of smaller element for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] # swap elements arr[i + 1], arr[high] = arr[high], arr[i + 1] # swap pivot element to the correct position return i + 1 def quicksort(arr: List[int], low: int, high: int) -> None: if low < high: pi = partition(arr, low, high) quicksort(arr, low, pi - 1) # recursively sort elements before partition quicksort(arr, pi + 1, high) # recursively sort elements after partition"},{"question":"# Problem Statement Write a function `polynomial_derivative` that computes the derivative of a polynomial represented by a list of its coefficients. The polynomial is represented in the form: [ P(x) = a_0 x^0 + a_1 x^1 + a_2 x^2 + ldots + a_n x^n ] The derivative of this polynomial is: [ P\'(x) = a_1 x^0 + 2a_2 x^1 + 3a_3 x^2 + ldots + n a_n x^{n-1} ] # Function Signature ```python def polynomial_derivative(coefficients: list) -> list: pass ``` # Input 1. `coefficients`: A list of integers or floats representing the coefficients of the polynomial. The (i-th) element of the list corresponds to the coefficient (a_i). # Output A list of integers or floats representing the coefficients of the derivative of the polynomial. # Constraints 1. The `coefficients` list must contain at least one element. 2. The elements of the `coefficients` list must be either integers or floats. # Examples 1. `polynomial_derivative([3, 2, 1])` should return `[2, 2]`. This corresponds to the derivative of ( P(x) = 3 + 2x + x^2 ), which is ( P\'(x) = 2 + 2x ). 2. `polynomial_derivative([1, 0, -3, 2])` should return `[0, -6, 6]`. This corresponds to the derivative of ( P(x) = 1 - 3x^2 + 2x^3 ), which is ( P\'(x) = -6x + 6x^2 ). 3. `polynomial_derivative([5])` should return `[]`. This corresponds to the derivative of the constant polynomial ( P(x) = 5 ), which is zero. # Notes 1. If the polynomial is a constant (i.e., the list has only one element), the derivative is zero, thus the output should be an empty list. 2. Ensure to handle edge cases gracefully, such as polynomials with all zero coefficients. 3. Optimize your code for performance.","solution":"def polynomial_derivative(coefficients): Computes the derivative of a polynomial represented by a list of its coefficients. :param coefficients: List of coefficients where the i-th element is the coefficient of x^i. :return: List of coefficients for the derivative of the polynomial. if len(coefficients) <= 1: return [] derivative = [] for i in range(1, len(coefficients)): derivative.append(i * coefficients[i]) return derivative"},{"question":"# Question: Find the Missing Number in a Sequence Context: You are tasked with developing a function to find a single missing number from an arithmetic sequence. An arithmetic sequence or arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant. The input array is a sequence of `n` integers where one of the terms is missing. Your task is to determine the missing term. Task: Write a function, `find_missing`, that takes a single list `sequence` of `n` integers where one term is missing and returns the missing integer. Function Signature: ```python def find_missing(sequence: list) -> int: pass ``` Input: * `sequence` (1 ≤ len(sequence) ≤ 10^4): A list of integers representing the sequence with one term missing. Output: * Return the missing integer from the sequence. Examples: ```python >>> find_missing([1, 2, 4, 5, 6]) 3 >>> find_missing([10, 20, 30, 50]) 40 >>> find_missing([5, 10, 20]) 15 >>> find_missing([-3, 0, 3, 6, 12]) 9 >>> find_missing([100, 200, 400, 500]) 300 ``` # Constraints: * Your solution should have a time complexity of O(n) and space complexity of O(1). # Additional Notes: * Consider arithmetic sequences with both positive and negative differences. * Ensure your solution finds the missing term even in sequences with various step sizes.","solution":"def find_missing(sequence): Returns the missing number in an arithmetic sequence. :param sequence: A list of integers representing the arithmetic sequence with one missing term. :return: The missing integer in the sequence. n = len(sequence) + 1 total_sum = (n * (sequence[0] + sequence[-1])) // 2 actual_sum = sum(sequence) return total_sum - actual_sum"},{"question":"# Problem Statement Create a function `all_unique_characters(s: str) -> bool` that will determine if all characters in the input string are unique. The function should return `True` if all characters are unique, and `False` otherwise. The input string may contain letters, digits, spaces, and punctuation. # Input * A single string `s` (0 ≤ len(s) ≤ 10^6). # Output * The function should return a boolean value: `True` if all characters in the string are unique, `False` otherwise. # Constraints * Use only standard library functions. * Consider edge cases such as: * An empty string. * Strings with different types of characters (letters, digits, spaces, and punctuation). # Example ```python >>> all_unique_characters(\\"hello\\") False >>> all_unique_characters(\\"world\\") True >>> all_unique_characters(\\"1234567890\\") True >>> all_unique_characters(\\"12345 67890\\") False >>> all_unique_characters(\\"!@#%^&*()\\") True >>> all_unique_characters(\\"\\") True ``` # Additional Information The goal of this exercise is to assess your ability to implement efficient algorithms for determining character uniqueness, especially under potential constraints of large input sizes. Consider both time and space complexity in your solution.","solution":"def all_unique_characters(s: str) -> bool: Determine if all characters in the input string are unique. Args: s (str): Input string to check for unique characters. Returns: bool: True if all characters are unique, False otherwise. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"# Coding Assessment Question Scenario: You are a backend engineer designing a function for a large-scale social networking platform. In this platform, friendships form between users, and each user can be part of multiple communities. Some communities are complete cliques (each member of the community is friends with every other member) while others are partially connected. Your task is to create a function to identify the largest clique within a given set of friendships. Goals: Using a backtracking approach, write a Python function `find_largest_clique` that takes the number of users and their friendships, and returns the largest clique of users in the form of user indices. Function Signature: ```python def find_largest_clique(n: int, friendships: list[tuple[int, int]]) -> list[int]: pass ``` Input: - `n (int)`: The number of users, represented as nodes in the graph. - `friendships (list[tuple[int, int]])`: A list of tuples where each tuple (u, v) signifies that user u is friends with user v. Output: - `list[int]`: A list representing the largest clique of users, with each user represented by their index. Example: ```python n = 5 friendships = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] print(find_largest_clique(n, friendships)) # Output: [0, 1, 2] ``` Constraints: - The number of users will not exceed 100. - Each user may have multiple friends but the total number of friendships will not exceed 1000. Performance Requirements: - The solution must efficiently handle the constraints on the number of users (vertices) and friendships (edges) as specified.","solution":"def find_largest_clique(n, friendships): def is_clique(clique): for i in range(len(clique)): for j in range(i+1, len(clique)): if (clique[i], clique[j]) not in edges and (clique[j], clique[i]) not in edges: return False return True def backtrack(start, current_clique): nonlocal largest_clique if len(current_clique) > len(largest_clique): largest_clique = current_clique[:] for i in range(start, n): current_clique.append(i) if is_clique(current_clique): backtrack(i + 1, current_clique) current_clique.pop() edges = set(friendships) largest_clique = [] backtrack(0, []) return largest_clique"},{"question":"# Employee Salary Increment Scenario: A company evaluates its employees’ performance annually and decides on salary increments based on predefined performance grades. As a software engineer in the company\'s HR department, you need to implement a feature in your HR management system to compute the new salary of an employee after the increment is applied based on their performance grade. # Task Write a Python function that computes the new salary after the increment based on the employee’s current salary and their performance grade. Function Signature ```python def calculate_new_salary(current_salary: float, grade: str) -> float: pass ``` Input * `current_salary` (float): The current salary of the employee. * `grade` (str): The performance grade of the employee. It can be \\"A\\", \\"B\\", \\"C\\", or \\"D\\". Output * Returns the new salary (float). Constraints * `current_salary > 0` * `grade` is one of {\\"A\\", \\"B\\", \\"C\\", \\"D\\"} Grade Increments * Grade \\"A\\": 20% increment * Grade \\"B\\": 15% increment * Grade \\"C\\": 10% increment * Grade \\"D\\": 5% increment Examples ```python >>> calculate_new_salary(50000, \\"A\\") 60000.0 >>> calculate_new_salary(70000, \\"B\\") 80500.0 >>> calculate_new_salary(40000, \\"C\\") 44000.0 >>> calculate_new_salary(35000, \\"D\\") 36750.0 ``` Validation and Error Handling Your function should raise appropriate exceptions for the following conditions: * If `current_salary` is less than or equal to 0, raise `Exception: Current salary must be > 0` * If `grade` is not one of \\"A\\", \\"B\\", \\"C\\", or \\"D\\", raise `Exception: Invalid performance grade. Must be one of \\"A\\", \\"B\\", \\"C\\", or \\"D\\"`","solution":"def calculate_new_salary(current_salary: float, grade: str) -> float: Computes the new salary after the increment based on the employee’s current salary and their performance grade. Args: current_salary (float): The current salary of the employee. grade (str): The performance grade of the employee (\\"A\\", \\"B\\", \\"C\\", or \\"D\\"). Returns: float: The new salary after the increment. Raises: Exception: If current_salary is less than or equal to 0. Exception: If grade is not one of \\"A\\", \\"B\\", \\"C\\", or \\"D\\". if current_salary <= 0: raise Exception(\\"Current salary must be > 0\\") if grade not in {\\"A\\", \\"B\\", \\"C\\", \\"D\\"}: raise Exception(\'Invalid performance grade. Must be one of \\"A\\", \\"B\\", \\"C\\", or \\"D\\"\') increments = { \\"A\\": 0.20, \\"B\\": 0.15, \\"C\\": 0.10, \\"D\\": 0.05 } increment = increments[grade] new_salary = current_salary * (1 + increment) return new_salary"},{"question":"# Analyzing Web Traffic Data You need to create a function that analyzes web traffic data logs and extracts key statistics. These web logs contain information such as IP address, datetime, request type, requested URL, HTTP status code, and response size. Your task is to write a function that reads a given filepath to a log file, processes the file, and returns the most frequent IP address and the most requested URL. Function Signature: ```python def analyze_web_logs(filepath: str) -> LogAnalysis: pass ``` Requirements: 1. **File Reading**: Read the content of the log file located at the provided filepath. 2. **Data Parsing**: Parse each log entry in the file to extract IP addresses and requested URLs. 3. **Statistics Calculation**: Determine the most frequent IP address and the most requested URL. 4. **Return Data**: Return the extracted data as an instance of the `LogAnalysis` named tuple. Constraints: - The function should handle potential errors such as: - File not found or unreadable. - Incorrect log format. - Large file size with efficient parsing. Input and Output Format: - **Input**: A string representing the filepath to the log file. - **Output**: A `LogAnalysis` named tuple containing two strings (most frequent IP address and most requested URL). Log Format Example ``` 127.0.0.1 - - [10/Oct/2023:13:55:36 -0400] \\"GET /index.html HTTP/1.1\\" 200 128 10.0.0.1 - - [10/Oct/2023:13:55:40 -0400] \\"GET /about.html HTTP/1.1\\" 200 512 127.0.0.1 - - [10/Oct/2023:13:55:42 -0400] \\"POST /submit-form HTTP/1.1\\" 200 64 ``` Example ```python filepath = \\"/path/to/web/logs.txt\\" result = analyze_web_logs(filepath) print(result) # Possible output if the logs contain the following data: # LogAnalysis(most_frequent_ip=\'127.0.0.1\', most_requested_url=\'/index.html\') ``` Additional Notes: - Ensure robust error handling to deal with file access and parsing issues. - Optimize for minimal latency with consideration for very large log files. - Use Python libraries as necessary to assist with file reading and data processing.","solution":"from collections import namedtuple, Counter LogAnalysis = namedtuple(\'LogAnalysis\', [\'most_frequent_ip\', \'most_requested_url\']) def analyze_web_logs(filepath: str) -> LogAnalysis: try: with open(filepath, \'r\') as log_file: ip_counter = Counter() url_counter = Counter() for line in log_file: try: ip, rest = line.split(\' - - \', 1) url = rest.split(\'\\"\')[1].split(\' \')[1] ip_counter[ip] += 1 url_counter[url] += 1 except (IndexError, ValueError): continue if not ip_counter or not url_counter: raise ValueError(\\"Log file is empty or does not contain recognized log entries.\\") most_frequent_ip = ip_counter.most_common(1)[0][0] most_requested_url = url_counter.most_common(1)[0][0] return LogAnalysis(most_frequent_ip, most_requested_url) except FileNotFoundError: raise FileNotFoundError(\\"The file could not be found.\\") except IOError: raise IOError(\\"An error occurred while reading the file.\\")"},{"question":"# Coding Assessment Question: You are part of a development team creating a software simulation of a parking lot management system. Each parking spot has a unique identifier, and the system needs to track the availability of parking spots using a custom data structure. For this task, you need to implement a class `ParkingLot` which uses a min-heap to track the next available parking spot in an efficient manner. Every time a parking spot is taken or freed, the class should update the list of available spots accordingly. Class Definition: ```python class ParkingLot: def __init__(self, n: int): Initialize the parking lot with n parking spots identified by numbers 1 to n. Args: n (int): The number of parking spots. def park(self) -> int: Park a car in the next available spot. Returns: int: The spot number of the parked car. def leave(self, spot: int): Free a parking spot. Args: spot (int): The spot number to be freed. ``` Input: - Upon initializing, `n` (an integer) represents the total number of parking spots, where ( 1 leq n leq 10^5 ). - The `park` method does not take any inputs. - The `leave` method takes an integer `spot` where ( 1 leq text{spot} leq n ). Output: - The `park` method returns the parking spot number where the car was parked. - The `leave` method does not return a value. Example: ```python >>> parking_lot = ParkingLot(5) >>> parking_lot.park() 1 >>> parking_lot.park() 2 >>> parking_lot.leave(1) >>> parking_lot.park() 1 >>> parking_lot.park() 3 >>> parking_lot.park() 4 >>> parking_lot.park() 5 >>> parking_lot.park() # This returns an exception/error indicating no spots available. ``` Constraints: 1. The `park` method should always park cars in the smallest-numbered available spot. 2. Both `park` and `leave` methods should run in logarithmic time complexity, ( O(log n) ). 3. You may use Python\'s heapq library for efficient min-heap operations. Additional Notes: - Ensure to handle edge cases, such as attempting to park when no spots are available or leaving a spot that wasn\'t parked in. - The final implementation should be efficient and scalable for large values of `n`. Your task is to implement the `ParkingLot` class based on the given description and constraints.","solution":"import heapq class ParkingLot: def __init__(self, n: int): Initialize the parking lot with n parking spots identified by numbers 1 to n. Args: n (int): The number of parking spots. self.available_spots = list(range(1, n + 1)) heapq.heapify(self.available_spots) def park(self) -> int: Park a car in the next available spot. Returns: int: The spot number of the parked car. if self.available_spots: return heapq.heappop(self.available_spots) raise Exception(\\"No parking spots available\\") def leave(self, spot: int): Free a parking spot. Args: spot (int): The spot number to be freed. heapq.heappush(self.available_spots, spot)"},{"question":"# Problem Statement You are tasked with creating a program that calculates the factorial of a given positive integer. Factorials are a common mathematical operation, typically represented as `n!`, which means the product of all positive integers less than or equal to `n`. Write a function `calculate_factorial(n: int) -> int` that takes a single parameter: - `n`: A positive integer. The function should return the factorial of the given integer `n`. If `n` is zero or negative, the function should raise a `ValueError` with an appropriate message. # Input/Output * **Input**: - `n` (1 <= n <= 20) * **Output**: - A single integer representing the factorial of `n`. * **Constraints/Mentions**: - The output should be an integer. - Handling error inputs properly. - Factorial for `n = 0` is defined as `1` in mathematics, but for this problem, inputs will always be strictly positive. # Examples 1. **Example 1**: ```python n = 5 calculate_factorial(n) -> 120 ``` 2. **Example 2**: ```python n = 1 calculate_factorial(n) -> 1 ``` 3. **Example 3**: ```python n = 0 calculate_factorial(n) -> Raises a ValueError \\"Input must be a positive integer\\" ``` 4. **Example 4**: ```python n = -5 calculate_factorial(n) -> Raises a ValueError \\"Input must be a positive integer\\" ``` Ensure your function handles edge cases and is efficient. Validate your solution with the provided functional tests in your environment.","solution":"def calculate_factorial(n: int) -> int: Returns the factorial of a positive integer n. Raises ValueError if n is not a positive integer. if n <= 0: raise ValueError(\\"Input must be a positive integer\\") factorial = 1 for i in range(1, n + 1): factorial *= i return factorial"},{"question":"# Problem Statement You are tasked with implementing a function that determines whether a given undirected graph is bipartite. A graph is bipartite if its vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. If the graph is bipartite, the function should return `True` and the partition sets. Otherwise, it should return `False`. # Function Signature ```python def is_bipartite(graph: dict) -> tuple[bool, list[int], list[int]]: Determines if the undirected graph is bipartite and returns the partition sets if true. Args: graph (dict): A dictionary representing an undirected graph, where keys are node names (integers) and values are sets of connected nodes. Returns: tuple[bool, list[int], list[int]]: A tuple containing: - A boolean indicating if the graph is bipartite. - A list of nodes in set U. - A list of nodes in set V. If the graph is not bipartite, the boolean is False and the lists are empty. pass ``` # Example Usage ```python # Example of a bipartite graph graph_bipartite = { 1: {2, 3}, 2: {1, 4}, 3: {1, 4}, 4: {2, 3} } is_bipartite_result = is_bipartite(graph_bipartite) assert is_bipartite_result == (True, [1, 4], [2, 3]) # Correct partition of the bipartite graph # Example of a non-bipartite graph (contains an odd cycle) graph_non_bipartite = { 1: {2, 3}, 2: {1, 3}, 3: {1, 2} } non_bipartite_result = is_bipartite(graph_non_bipartite) assert non_bipartite_result == (False, [], []) # Not a bipartite graph # Example of a disconnected bipartite graph graph_disconnected_bipartite = { 1: {2}, 2: {1}, 3: {4}, 4: {3} } disconnected_bipartite_result = is_bipartite(graph_disconnected_bipartite) assert disconnected_bipartite_result == (True, [1, 3], [2, 4]) # Correct partition of the bipartite graph ``` # Constraints * The graph is undirected. * The nodes are represented by unique integers. * The dictionary values are sets of connected nodes, ensuring no duplicate connections. * The graph can be disconnected. * Nodes do not have weights, and the graph only considers the presence of edges. # Additional Information Consider edge cases, such as when: * The graph has only one node. * The graph is disconnected. * Some nodes or edges form odd-length cycles, meaning the graph isn\'t bipartite. * The graph is already evenly partitioned into two disjoint sets.","solution":"def is_bipartite(graph: dict) -> tuple[bool, list[int], list[int]]: Determines if the undirected graph is bipartite and returns the partition sets if true. Args: graph (dict): A dictionary representing an undirected graph, where keys are node names (integers) and values are sets of connected nodes. Returns: tuple[bool, list[int], list[int]]: A tuple containing: - A boolean indicating if the graph is bipartite. - A list of nodes in set U. - A list of nodes in set V. If the graph is not bipartite, the boolean is False and the lists are empty. color = {} def bfs(start): queue = [start] color[start] = 0 # Color the starting node with 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if neighbor not in color: queue.append(neighbor) color[neighbor] = 1 - color[node] # Assign alternate color elif color[neighbor] == color[node]: return False return True for node in graph: if node not in color: if not bfs(node): return (False, [], []) U = [node for node in color if color[node] == 0] V = [node for node in color if color[node] == 1] return (True, U, V)"},{"question":"# Problem Statement You are assigned the task of counting the number of ways to climb a staircase of `n` steps, where you can climb either 1, 2, or 3 steps at a time. Write a function `count_ways(n: int) -> int` that calculates and returns the total number of distinct ways to reach the top of the staircase. Input * `n` — an integer (0 ≤ n ≤ 10^5) Output * The function should return an integer representing the number of distinct ways to reach the top of the staircase. Constraints - If `n` is 0, return 1 because there is one way to stay at the ground (doing nothing). - Consider performance as `n` can be quite large (up to 10^5). Example ```python >>> count_ways(3) 4 >>> count_ways(4) 7 >>> count_ways(10) 274 ``` Explanation: 1. For `n = 3`, there are 4 ways to climb the stairs: - 1 step + 1 step + 1 step - 1 step + 2 steps - 2 steps + 1 step - 3 steps 2. For `n = 4`, there are 7 ways to climb the stairs: - 1 step + 1 step + 1 step + 1 step - 1 step + 1 step + 2 steps - 1 step + 2 steps + 1 step - 2 steps + 1 step + 1 step - 2 steps + 2 steps - 1 step + 3 steps - 3 steps + 1 step 3. For `n = 10`, the number of ways follows the dynamic programming approach leveraging previously computed results to calculate the new one efficiently. The problem has overlapping subproblems and can be efficiently solved with dynamic programming. Implement the function with optimal efficiency to handle large inputs.","solution":"def count_ways(n: int) -> int: Computes the number of ways to climb a staircase with n steps, where you can climb 1, 2, or 3 steps at a time. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 ways = [0] * (n + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 ways[3] = 4 for i in range(4, n + 1): ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3] return ways[n]"},{"question":"Problem Description You are given an integer array `nums` and an integer `target`. Your task is to write a function `two_sum` that finds two distinct indices in the array whose values add up to the target sum. # Input * An integer array `nums` of length n. * An integer `target`. # Output * A list of two integers representing the indices of the two numbers that add up to the target. If no such indices exist, return an empty list. # Constraints * The array `nums` can contain both negative and positive integers. * Each input has exactly one solution, and you may not use the same element twice. * The order of the output does not matter. # Example Input/Output ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 2, 3, 4], 8) [] ``` # Function Signature ```python def two_sum(nums: list[int], target: int) -> list[int]: pass ``` # Implementation Requirements 1. Ensure that the solution is efficient with an average time complexity of O(n). 2. Handle all valid input arrays as per the constraints. 3. Aim for a solution using hashing to achieve the desired time complexity.","solution":"def two_sum(nums, target): Finds two distinct indices in the nums array such that their values add up to the target. Args: nums : list of integers target : integer Returns: list of two integers representing the indices of the two numbers lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i return []"},{"question":"# Evaluating Infix Expression with Two Stacks Scenario You are required to create a function that evaluates mathematical expressions provided in infix notation. The infix notation is a common arithmetic notation where operators are written between operands (e.g., 3 + 5). To evaluate the expression correctly, you will use two stacks: one for operands (numbers) and one for operators. Task Implement a function named `evaluate_infix_expression` with the following requirements: Function: `evaluate_infix_expression` 1. **Input**: * `expression` (str): A string representing a mathematical expression in infix notation. 2. **Output**: * `result` (float): The evaluated result of the expression. Constraints and Limitations * The expression can contain non-negative integers and the operators `+`, `-`, `*`, `/`, and parentheses `()`. * The input expression will be valid with balanced parentheses. * The division operator `/` should perform floating-point division. * Use the precedence rules for operators: `*` and `/` have higher precedence than `+` and `-`. * Support at least basic integer operands and floating-point results. Example ```python # Evaluate the expression result = evaluate_infix_expression(\\"3 + 2 * (1 + 2) / 3\\") print(result) # Output: 5.0 (Explanation: 3 + (2 * 3 / 3) -> 3 + 2 -> 5) result = evaluate_infix_expression(\\"(8 + 2) * 5 - 10 / 2\\") print(result) # Output: 45.0 (Explanation: (10) * 5 - 5 -> 50 - 5 -> 45) result = evaluate_infix_expression(\\"100 / (5 * (2 + 3))\\") print(result) # Output: 4.0 (Explanation: 100 / (5 * 5) -> 100 / 25 -> 4.0) ``` Ensure your implementation handles operator precedence and parentheses correctly to provide accurate results for the infix expression. ```python def evaluate_infix_expression(expression): def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression) ```","solution":"def evaluate_infix_expression(expression): def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression)"},{"question":"# Question: Sum of Unique Elements in the List You are asked to implement a function that returns the sum of unique elements in a given list of integers. If there are no unique elements, the function should return 0. Function Signature ```python def sum_of_unique_elements(lst: list) -> int: pass ``` # Input * `lst` (list): A list of integers. It is not necessarily sorted, and could include duplicates. * ( (1 leq len(lst) leq 10^5) ) * ( (-10^6 leq lst[i] leq 10^6) ) # Output * An integer representing the sum of unique elements in the list. # Constraints 1. The input list can contain negative and positive integers as well as zeros. 2. Elements are considered unique if they appear exactly once in the list. # Performance Requirements 1. The function should run in linear time, O(n). # Example ```python assert sum_of_unique_elements([1, 2, 3, 2, 1, 4]) == 7 # unique elements: 3, 4 assert sum_of_unique_elements([5, 5, 5, 5]) == 0 # no unique elements assert sum_of_unique_elements([10, -2, 3, 4, -2, 4, 3]) == 10 # unique elements: 10 assert sum_of_unique_elements([0, -1, 0, 1]) == 0 # unique elements: -1, 1; sum is 0 assert sum_of_unique_elements([7]) == 7 # unique element: 7 ``` # Scenario You are a data analyst tasked with cleaning and analyzing data from a survey. One of your tasks is to identify the sum of unique responses for certain questions. Implement the `sum_of_unique_elements()` function to efficiently calculate this sum, aiding in data analysis tasks.","solution":"def sum_of_unique_elements(lst: list) -> int: Returns the sum of unique elements in the list. If there are no unique elements, returns 0. from collections import Counter # Count occurrences of each element in the list element_count = Counter(lst) # Calculate the sum of elements that appear exactly once unique_sum = sum(element for element, count in element_count.items() if count == 1) return unique_sum"},{"question":"Introduction: Dijkstra\'s algorithm is a classic algorithm used to find the shortest paths between nodes in a graph, which may represent, for example, road networks. Problem: You are required to enhance the `Graph` and `DijkstraExecutor` classes to not only find the shortest path from the source to all other vertices but also to identify the vertices that are part of one of the shortest paths to another vertex. # Task: 1. Implement the Dijkstra\'s algorithm in the `DijkstraExecutor` class to find the shortest path from a given source vertex to all other vertices. 2. Extend the implementation to identify and return the list of vertices that are part of any shortest path between the source and another vertex. # Input/Output Format: * **Input**: - `graph`: A 2D list of integers representing the edge weights in the graph. `graph[u][v]` represents the weight of the edge from vertex `u` to vertex `v`. A value of `0` means there is no direct edge between vertices `u` and `v`. - `source`: An integer representing the index of the source vertex. * **Output**: - A tuple where the first element is a list of integers representing the shortest distances from the source to each vertex, and the second element is a list representing the vertices that are part of any shortest path between the source and any other vertex. # Constraints: 1. The graph will be a square matrix where the number of rows equals the number of columns, representing `V` vertices. 2. The graph will have non-negative edge weights. 3. `1 <= V <= 500` 4. There will always be a path from the source to all other vertices. # Example: ```python graph = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] source = 0 network = Graph(graph) network.set_shortest_path_algorithm(DijkstraExecutor) shortest_distances, path_vertices = network.find_shortest_paths(source) print(shortest_distances) # Output should be [0, 10, 50, 30, 60] print(path_vertices) # Output should be [0, 1, 3, 2, 4] ``` # Evaluation Criteria: 1. Correctness: The implemented algorithms must compute the shortest paths and identify the path vertices correctly. 2. Efficiency: The code should be optimized to handle the upper constraints efficiently. 3. Code Quality: Solutions should adhere to good coding practices including readability, modularity, and proper documentation.","solution":"from heapq import heappop, heappush import sys class Graph: def __init__(self, graph): self.graph = graph self.V = len(graph) def set_shortest_path_algorithm(self, algorithm): self.shortest_path_algorithm = algorithm def find_shortest_paths(self, source): executor = self.shortest_path_algorithm(self.graph) return executor.find_shortest_paths(source) class DijkstraExecutor: def __init__(self, graph): self.graph = graph self.V = len(graph) def find_shortest_paths(self, src): distances = [sys.maxsize] * self.V distances[src] = 0 min_heap = [(0, src)] shortest_path_tree_set = set() visited = [False] * self.V paths = [[] for _ in range(self.V)] paths[src].append(src) while min_heap: current_distance, u = heappop(min_heap) if visited[u]: continue visited[u] = True shortest_path_tree_set.add(u) for v in range(self.V): weight = self.graph[u][v] if weight > 0 and not visited[v] and distances[v] > current_distance + weight: distances[v] = current_distance + weight heappush(min_heap, (distances[v], v)) paths[v] = paths[u] + [v] unique_path_vertices = set(vertex for path in paths for vertex in path) return distances, list(unique_path_vertices)"},{"question":"# Recommend the Most Suitable Data Structure for a Given Problem **Context**: You are developing an application where various operations are required on a sequence of integers. Depending on different use cases, you may involve operations such as inserting elements, deleting elements, and accessing elements at both ends of the sequence. Your task is to assess the performance of different data structures by implementing a series of operations and determining which data structure would be the most suitable for such a scenario. # Task: 1. **Data Structure Implementation**: Implement operations for deque (double-ended queue), list, and queue data structures. 2. **Performance Measurement**: Measure the performance of these implementations on a set of operations. 3. **Recommendation**: Based on your performance measurements, recommend the most suitable data structure for the given problem scenario. # Inputs: - **operations**: A list of operations to perform on the data structures. Each operation is a tuple where the first element is the operation type (`\'insert_front\'`, `\'insert_back\'`, `\'delete_front\'`, `\'delete_back\'`, `\'access_front\'`, `\'access_back\'`) and the second element can be the value (in case of insert operations) or `None`. # Expected Output: - **Performance Metrics**: Print the time taken for each data structure to complete all operations. - **Recommendation**: Based on the results, recommend the most suitable data structure. # Code Constraints: - Use the `time` module for performance measurement. - Ensure your code accurately simulates and measures the given operations. - Include meaningful comments and print statements for analysis and debugging purposes. Here is the skeleton of the program you need to implement: ```python import time from collections import deque from queue import Queue def measure_performance(operations, data_structure_instance, ds_type): start_time = time.time() for operation in operations: op_name, value = operation if ds_type == \'list\': if op_name == \'insert_front\': data_structure_instance.insert(0, value) elif op_name == \'insert_back\': data_structure_instance.append(value) elif op_name == \'delete_front\': if data_structure_instance: data_structure_instance.pop(0) elif op_name == \'delete_back\': if data_structure_instance: data_structure_instance.pop() elif op_name == \'access_front\': if data_structure_instance: _ = data_structure_instance[0] elif op_name == \'access_back\': if data_structure_instance: _ = data_structure_instance[-1] elif ds_type == \'deque\': if op_name == \'insert_front\': data_structure_instance.appendleft(value) elif op_name == \'insert_back\': data_structure_instance.append(value) elif op_name == \'delete_front\': if data_structure_instance: data_structure_instance.popleft() elif op_name == \'delete_back\': if data_structure_instance: data_structure_instance.pop() elif op_name == \'access_front\': if data_structure_instance: _ = data_structure_instance[0] elif op_name == \'access_back\': if data_structure_instance: _ = data_structure_instance[-1] elif ds_type == \'queue\': if op_name == \'insert_back\': data_structure_instance.put(value) elif op_name == \'delete_front\': if not data_structure_instance.empty(): data_structure_instance.get() # Queues do not support access from front and back directly like lists or deques end_time = time.time() return end_time - start_time def main(): operations = [ (\'insert_back\', 10), (\'insert_front\', 20), (\'insert_back\', 30), (\'delete_front\', None), (\'access_front\', None), (\'delete_back\', None), (\'access_back\', None) ] list_instance = [] deque_instance = deque() queue_instance = Queue() list_time = measure_performance(operations, list_instance, \'list\') print(f\\"List Performance Time: {list_time:.6f} seconds\\") deque_time = measure_performance(operations, deque_instance, \'deque\') print(f\\"Deque Performance Time: {deque_time:.6f} seconds\\") queue_time = measure_performance(operations, queue_instance, \'queue\') print(f\\"Queue Performance Time (insert and delete operations only): {queue_time:.6f} seconds\\") # Recommendations based on measured performance if list_time < deque_time and list_time < queue_time: recommended_ds = \'List\' elif deque_time < list_time and deque_time < queue_time: recommended_ds = \'Deque\' else: recommended_ds = \'Queue\' print(f\\"Recommended Data Structure: {recommended_ds}\\") if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on implementing the operations correctly on different data structures. - Accurately measuring the performance of these data structures. - Providing a reasoned recommendation based on your performance measurements. - Ensure code clarity with proper documentation and comments.","solution":"import time from collections import deque from queue import Queue def measure_performance(operations, data_structure_instance, ds_type): start_time = time.time() for operation in operations: op_name, value = operation if ds_type == \'list\': if op_name == \'insert_front\': data_structure_instance.insert(0, value) elif op_name == \'insert_back\': data_structure_instance.append(value) elif op_name == \'delete_front\': if data_structure_instance: data_structure_instance.pop(0) elif op_name == \'delete_back\': if data_structure_instance: data_structure_instance.pop() elif op_name == \'access_front\': if data_structure_instance: _ = data_structure_instance[0] elif op_name == \'access_back\': if data_structure_instance: _ = data_structure_instance[-1] elif ds_type == \'deque\': if op_name == \'insert_front\': data_structure_instance.appendleft(value) elif op_name == \'insert_back\': data_structure_instance.append(value) elif op_name == \'delete_front\': if data_structure_instance: data_structure_instance.popleft() elif op_name == \'delete_back\': if data_structure_instance: data_structure_instance.pop() elif op_name == \'access_front\': if data_structure_instance: _ = data_structure_instance[0] elif op_name == \'access_back\': if data_structure_instance: _ = data_structure_instance[-1] elif ds_type == \'queue\': if op_name == \'insert_back\': data_structure_instance.put(value) elif op_name == \'delete_front\': if not data_structure_instance.empty(): data_structure_instance.get() # Queues do not support access from front and back directly like lists or deques end_time = time.time() return end_time - start_time def main(): operations = [ (\'insert_back\', 10), (\'insert_front\', 20), (\'insert_back\', 30), (\'delete_front\', None), (\'access_front\', None), (\'delete_back\', None), (\'access_back\', None) ] list_instance = [] deque_instance = deque() queue_instance = Queue() list_time = measure_performance(operations, list_instance, \'list\') print(f\\"List Performance Time: {list_time:.6f} seconds\\") deque_time = measure_performance(operations, deque_instance, \'deque\') print(f\\"Deque Performance Time: {deque_time:.6f} seconds\\") queue_time = measure_performance(operations, queue_instance, \'queue\') print(f\\"Queue Performance Time (insert and delete operations only): {queue_time:.6f} seconds\\") # Recommendations based on measured performance if list_time < deque_time and list_time < queue_time: recommended_ds = \'List\' elif deque_time < list_time and deque_time < queue_time: recommended_ds = \'Deque\' else: recommended_ds = \'Queue\' print(f\\"Recommended Data Structure: {recommended_ds}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement You need to ascertain whether the given input string can be segmentized into multiple segments, each of which is a valid word found in a provided dictionary. Write a function that checks if this segmentation is feasible. # Function Signature ```python def can_segment_string(s: str, dictionary: [str]) -> bool: ``` # Input and Output * **Input**: * A string `s` representing the sentence or phrase to be segmented. * A list of strings `dictionary` representing the set of valid words. * **Output**: A boolean `True` if the string can be segmented into valid words, `False` otherwise. # Example ```python assert can_segment_string(\\"applepie\\", [\\"apple\\", \\"pie\\"]) == True # \\"applepie\\" can be segmented as \\"apple\\" + \\"pie\\" assert can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True # \\"applepenapple\\" can be segmented as \\"apple\\" + \\"pen\\" + \\"apple\\" assert can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False # \\"catsandog\\" cannot be segmented assert can_segment_string(\\"aaaaaaa\\", [\\"aaaa\\", \\"aaa\\"]) == True # \\"aaaaaaa\\" can be segmented as \\"aaa\\" + \\"aaaa\\" or \\"aaaa\\" + \\"aaa\\" ``` # Constraints * The input string `s` will have at most length 300. * No word in the dictionary will be longer than 50 characters. * The dictionary will contain at most 1000 words, but may contain duplicate entries. * Each word in the dictionary and the input string will consist of lowercase English letters only. # Hint Consider using dynamic programming to address this problem, iterating through substrings and checking against the dictionary. You can also utilize memoization to optimize the context lookups in the dictionary.","solution":"def can_segment_string(s: str, dictionary: [str]) -> bool: word_set = set(dictionary) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"# Coding Question Objective Write a function `nearest_fibonacci` that finds the nearest Fibonacci number to a given input number `n`. If the input number is equidistant between two Fibonacci numbers, return the smaller one. Function Signature ```python def nearest_fibonacci(n: int) -> int: pass ``` Input * `n`: An integer representing the input number. Output * An integer representing the nearest Fibonacci number. Constraints * The input number `n` will be a non-negative integer (0 ≤ n ≤ 10^9). Examples ```python >>> nearest_fibonacci(15) 13 >>> nearest_fibonacci(20) 21 >>> nearest_fibonacci(0) 0 >>> nearest_fibonacci(8) 8 >>> nearest_fibonacci(100) 89 ``` Additional Requirements * The function should be optimized to handle large values of `n` efficiently. * The solution should take the closest Fibonacci number to `n`, preferring the lower Fibonacci number in case of a tie. * The function should deal with edge cases, including when `n` is 0. # Hints * Fibonacci sequence starts from 0, 1, 1, 2, 3, 5, 8, 13, ... * Consider not calculating Fibonacci numbers beyond the necessary point for efficiency.","solution":"def nearest_fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 # Initial Fibonacci numbers fib1, fib2 = 0, 1 # Loop until we find the closest Fibonacci number while fib2 <= n: fib1, fib2 = fib2, fib1 + fib2 # now fib1 is the largest Fibonacci number less than or equal to n # and fib2 is the smallest Fibonacci number greater than n if (n - fib1) <= (fib2 - n): return fib1 else: return fib2"},{"question":"Here\'s an additional question that aligns with the guidelines provided: You are given a `LinkedList` class implementation that supports basic operations (insertion, deletion, traversal). Your task is to enhance this class to add the following features: 1. Reverse the linked list. 2. Find the middle element. # Requirements Reverse Linked List - Create a method to reverse the linked list such that the last node becomes the head and the head becomes the last node. Find Middle Element - Create a method to find the middle element of the linked list. If the list has an even number of elements, return the first of the two middle elements. # Function Signatures You will need to add the following methods to the `LinkedList` class: 1. `reverse(self) -> None`: - Reverses the linked list in place. 2. `find_middle(self) -> T`: - Returns the middle element of the linked list. Ensure the class maintains its integrity and functions correctly after these operations. # Constraints - The linked list can have both integer and string elements. - Assume the linked list will have at least one element when either of the methods is called. # Example Usage ```python linked_list = LinkedList() linked_list.insert(1) linked_list.insert(2) linked_list.insert(3) linked_list.insert(4) linked_list.insert(5) assert linked_list.find_middle() == 3 linked_list.reverse() # After reversing, the new list should start with 5 assert linked_list.head.value == 5 # Your additional implementation should integrate smoothly # with the existing functionality such as the test cases provided. if __name__ == \\"__main__\\": unittest.main() ``` # Notes - Ensure your new methods adhere to and extend the existing class design. - Your changes should not break the existing linked list functionality. - Write new tests to cover the added features and ensure comprehensive testing.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def delete(self, key): temp = self.head if temp is not None: if temp.data == key: self.head = temp.next temp = None return while temp is not None: if temp.data == key: break prev = temp temp = temp.next if temp == None: return prev.next = temp.next temp = None def traverse(self): values = [] temp = self.head while temp: values.append(temp.data) temp = temp.next return values def reverse(self): prev = None current = self.head while current is not None: next = current.next current.next = prev prev = current current = next self.head = prev def find_middle(self): slow_ptr = self.head fast_ptr = self.head if self.head is not None: while fast_ptr is not None and fast_ptr.next is not None: fast_ptr = fast_ptr.next.next slow_ptr = slow_ptr.next return slow_ptr.data return None"},{"question":"# Problem Statement You are tasked with implementing a function that checks if the characters in a given integer sequence can be rearranged to form a palindrome. # Function Signature ```python def can_form_palindrome(num: int) -> bool: pass ``` # Input * `num` (int): A non-negative integer. # Output * A boolean that returns True if the sequence of digits can be rearranged to form a palindrome, otherwise False. # Constraints * `0 <= num <= 10^12` * If `num` is negative, your function should raise a ValueError with the message \\"the value must be non-negative\\". * If `num` is not an integer, your function should raise a TypeError. # Example ```python >>> can_form_palindrome(12321) True >>> can_form_palindrome(53235) True >>> can_form_palindrome(123456) False >>> can_form_palindrome(0) True >>> can_form_palindrome(987789) True ``` # Notes 1. You should ensure inputs are validated for type and value restrictions as mentioned in the constraints. 2. A number can form a palindrome if at most one digit has an odd frequency.","solution":"def can_form_palindrome(num: int) -> bool: Checks if the characters in a given integer sequence can be rearranged to form a palindrome. Args: - num (int): A non-negative integer. Returns: - bool: True if the sequence of digits can be rearranged to form a palindrome, otherwise False. Raises: - ValueError: If the input num is negative. - TypeError: If the input num is not an integer. if not isinstance(num, int): raise TypeError(\\"num must be an integer\\") if num < 0: raise ValueError(\\"the value must be non-negative\\") # Convert number to string to count digits digits = str(num) # Count frequency of each digit digit_count = {} for digit in digits: if digit in digit_count: digit_count[digit] += 1 else: digit_count[digit] = 1 # Check the number of odd frequency digits odd_count = 0 for count in digit_count.values(): if count % 2 != 0: odd_count += 1 # A number can form a palindrome if at most one digit has an odd frequency return odd_count <= 1"},{"question":"# Coding Challenge: Compressed Trie Implementation Context You are tasked with implementing a Compressed Trie (Radix Tree) to optimize search operations for prefixes in a set of strings. A Compressed Trie is a space-optimized version of a standard Trie where nodes with only one child are merged with their parents. Task Create a `CompressedTrie` class with the following essential operations: 1. **Insert**: Add a string to the compressed trie. 2. **Search**: Check if a given string exists in the compressed trie. 3. **Starts With**: Check if there is any string in the trie that starts with a given prefix. Specifications **Operation 1: Insert** - **Function Signature**: `def insert(self, word):` - **Input**: `word` - A string to be inserted into the trie. - **Output**: It does not return anything but updates the trie to include the new string. **Operation 2: Search** - **Function Signature**: `def search(self, word):` - **Input**: `word` - The string to be searched in the trie. - **Output**: Returns `True` if the word exists in the trie, `False` otherwise. **Operation 3: Starts With** - **Function Signature**: `def starts_with(self, prefix):` - **Input**: `prefix` - The prefix to be checked. - **Output**: Returns `True` if there is any string in the trie that starts with the given prefix, `False` otherwise. # Constraints - Characters in the strings are restricted to lowercase English letters. - The trie should maintain efficient space usage by compressing nodes with single children. Example Usage ```python # Initialize a compressed trie trie = CompressedTrie() # Insert elements trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apply\\") trie.insert(\\"apt\\") trie.insert(\\"apex\\") # Search for elements print(trie.search(\\"apple\\")) # Should print True print(trie.search(\\"app\\")) # Should print True print(trie.search(\\"apl\\")) # Should print False # Check prefix existence print(trie.starts_with(\\"ap\\")) # Should print True print(trie.starts_with(\\"ape\\")) # Should print True print(trie.starts_with(\\"b\\")) # Should print False ``` # Additional Requirements - Ensure that the trie is compressed and optimized for space. - Implement appropriate checks and modifications to maintain the trie structure during insertion. - Tries must efficiently handle large datasets and support fast search operations. # Note Modify the `CompressedTrie` and `TrieNode` classes as necessary to implement the required functionalities. Ensure comprehensive testing with various cases to validate the correctness and efficiency of your implementation.","solution":"class TrieNode: def __init__(self, children=None, is_word=False): self.children = children if children is not None else {} self.is_word = is_word class CompressedTrie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root while word: found = False for key in node.children.keys(): if word.startswith(key): node = node.children[key] word = word[len(key):] found = True break if key.startswith(word): new_node = TrieNode(children={key[len(word):]: node.children[key]}, is_word=True) del node.children[key] node.children[word] = new_node return if not found: node.children[word] = TrieNode(is_word=True) return def search(self, word): node = self.root while word: found = False for key in node.children.keys(): if word.startswith(key): node = node.children[key] if len(word) == len(key): return node.is_word word = word[len(key):] found = True break if not found: return False return False def starts_with(self, prefix): node = self.root while prefix: found = False for key in node.children.keys(): if prefix.startswith(key): node = node.children[key] if len(prefix) == len(key): return True prefix = prefix[len(key):] found = True break if key.startswith(prefix): return True if not found: return False return False"},{"question":"# Question Write a function `double_square_sum(n: int) -> int` that computes the sum of the squares of all even numbers from 2 to `n`, inclusive. Input - An integer `n` where (2 leq n leq 10^6). Output - An integer representing the sum of the squares of all even numbers from 2 to `n`, inclusive. Examples ```python assert double_square_sum(10) == 220 # 2^2 + 4^2 + 6^2 + 8^2 + 10^2 = 4 + 16 + 36 + 64 + 100 = 220 assert double_square_sum(6) == 56 # 2^2 + 4^2 + 6^2 = 4 + 16 + 36 = 56 assert double_square_sum(2) == 4 # 2^2 = 4 ``` Constraints - The function should handle cases where `n` is very close to the upper limit efficiently. - Only even integers within the range should be considered. - Ensure the solution avoids unnecessary computations and handles large inputs optimally.","solution":"def double_square_sum(n: int) -> int: Computes the sum of the squares of all even numbers from 2 to n, inclusive. Parameters: n (int): The upper limit (inclusive) for the range of numbers to be considered. Returns: int: The sum of the squares of all even numbers from 2 to n. return sum(i**2 for i in range(2, n + 1, 2))"},{"question":"# Coding Assessment Question Context You are designing a text processing application that requires efficient searching of substrings within a larger string. Classical substring searching algorithms are either too slow or consume too much memory for very large texts. You choose to implement the Knuth-Morris-Pratt (KMP) algorithm for this purpose. Task Write a function `kmp_search` that searches for all occurrences of a given pattern string within a large text string. Your function should: 1. Return a list of starting indices where the pattern is found in the text. 2. Handle cases where the pattern or text is empty by returning an empty list. 3. Be optimized to handle large texts efficiently. Constraints - The lengths of the pattern and text will both be between 0 and (10^6). - The text and pattern will consist of ASCII characters. Function Signature ```python def kmp_search(text: str, pattern: str) -> list[int]: pass ``` Expected Input and Output ```python >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"aaaaaa\\", \\"aa\\") [0, 1, 2, 3, 4] >>> kmp_search(\\"hello world\\", \\"world\\") [6] >>> kmp_search(\\"abcdabcdabcd\\", \\"abcd\\") [0, 4, 8] >>> kmp_search(\\"\\", \\"pattern\\") [] >>> kmp_search(\\"text\\", \\"\\") [] ``` Performance Requirements - Your implementation should handle large input sizes efficiently. - Aim for O(n + m) time complexity, where n is the length of the text and m is the length of the pattern. - Ensure to handle edge cases effectively, including empty strings.","solution":"def kmp_search(text: str, pattern: str) -> list[int]: Returns a list of starting indices where the pattern is found in the text using the Knuth-Morris-Pratt (KMP) algorithm. if not text or not pattern: return [] def compute_lps(pattern: str) -> list[int]: Computes the longest prefix-suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"**Dynamic Programming: Longest Increasing Subsequence** You\'ve been assigned a project to analyze stock prices for generating investment insights. One of the tasks involves determining the longest increasing subsequence of daily stock prices over a given period. # Problem Statement You are given a list `prices` where: - `prices[i]` represents the stock price on the `i-th` day. Your task is to find the length of the longest increasing subsequence of stock prices. # Task Implement the function `longest_increasing_subsequence(prices)` that returns the length of the longest increasing subsequence of stock prices. # Expected Input and Output Formats ```python def longest_increasing_subsequence(prices: List[int]) -> int: pass ``` - `prices`: A list of integers where each integer represents the price of a stock on a particular day. **Output**: An integer representing the length of the longest increasing subsequence of stock prices. # Constraints 1. `1 <= len(prices) <= 1000` 2. `0 <= prices[i] <= 10^6` # Performance Requirements Your solution should use dynamic programming efficiently to compute the result within reasonable time constraints. # Scenario Imagine you are given daily closing stock prices of a company over a period of time, and you need to analyze the investment pattern by finding the longest period during which the price consecutively increased. # Example ```python prices = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(longest_increasing_subsequence(prices)) # Output: 6 ``` In this example, the longest increasing subsequence is `[10, 22, 33, 50, 60, 80]`, giving a length of 6.","solution":"def longest_increasing_subsequence(prices): Returns the length of the longest increasing subsequence of the input list prices. if not prices: return 0 n = len(prices) dp = [1] * n for i in range(1, n): for j in range(i): if prices[i] > prices[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Scenario You are developing a library management system for a local school. One of the features required is to automatically suggest new book arrivals to students based on their reading history. The system needs to rank new books based on the reading habits and preferences of the students. # Task Description Implement a Python function `rank_new_books` that ranks new book arrivals for a student based on their previous reading history and stated preferences. The function should take in a list of new book titles, a dictionary of book title ratings from the student\'s history, and a dictionary of genre preferences. # Function Signature ```python def rank_new_books( new_books: list[str], history: dict[str, float], preferences: dict[str, int] ) -> list[str]: ``` # Input - `new_books`: A list of new book titles, where each title is a string. - `history`: A dictionary where the keys are book titles (strings) the student has read, and the values are ratings (floats) the student gave to those books. - `preferences`: A dictionary where the keys are genres (strings) and the values are preference scores (integers) assigned by the student for those genres. # Output - A list of new book titles, ranked from most to least likely to be liked by the student. # Constraints - Each book title must be unique within `new_books`. - `history` and `preferences` may have overlapping or mismatched keys, and your implementation must handle such cases gracefully. - Assume you have access to a dictionary `book_genres` that maps each book title to its genre. # Performance Requirements - Your solution should manage the unit of work linearly relative to the length of `new_books`. # Example ```python new_books = [\\"Mystery Tales\\", \\"Adventures of Science\\", \\"Modern Cooking\\"] history = {\\"Mystery at the Abbey\\": 4.5, \\"Science Wonders\\": 3.0, \\"Gourmet Recipes\\": 5.0} preferences = {\\"Mystery\\": 5, \\"Science\\": 3, \\"Cooking\\": 4} book_genres = { \\"Mystery Tales\\": \\"Mystery\\", \\"Adventures of Science\\": \\"Science\\", \\"Modern Cooking\\": \\"Cooking\\", \\"Mystery at the Abbey\\": \\"Mystery\\", \\"Science Wonders\\": \\"Science\\", \\"Gourmet Recipes\\": \\"Cooking\\" } # Expected: [\'Mystery Tales\', \'Modern Cooking\', \'Adventures of Science\'] print(rank_new_books(new_books, history, preferences)) ``` # Notes - Utilize the student\'s historical ratings and genre preferences to determine the ranking. - The exact formula for ranking books can be designed at your discretion, provided it is logical and leverages both the rating history and genre preferences effectively. - Ensure the function correctly handles cases where a book in history or preferences does not exist in `book_genres`. The task is to parse and analyze the given data effectively, making educated suggestions that improve user engagement based on their past interactions.","solution":"def rank_new_books(new_books, history, preferences): Ranks new book arrivals based on student\'s reading history and preferences. Parameters: new_books (list[str]): List of new book titles. history (dict[str, float]): Dictionary of book title ratings from the student\'s history. preferences (dict[str, int]): Dictionary of genre preferences with preference scores. Returns: list[str]: List of new book titles ranked from most to least likely to be liked by the student. # This dictionary maps each book title to its genre. book_genres = { \\"Mystery Tales\\": \\"Mystery\\", \\"Adventures of Science\\": \\"Science\\", \\"Modern Cooking\\": \\"Cooking\\", \\"Mystery at the Abbey\\": \\"Mystery\\", \\"Science Wonders\\": \\"Science\\", \\"Gourmet Recipes\\": \\"Cooking\\" } def book_rating(title): genre = book_genres.get(title) if not genre: return 0 # Default rating if genre is unknown genre_pref = preferences.get(genre, 0) # Calculate average rating for this genre from history genre_history_ratings = [ rating for book, rating in history.items() if book_genres.get(book) == genre ] if genre_history_ratings: avg_history_rating = sum(genre_history_ratings) / len(genre_history_ratings) else: avg_history_rating = 0 # Default if no history ratings for this genre # Rating is a combination of genre preference and history rating return avg_history_rating + genre_pref # Rank new books based on calculated rating ranked_books = sorted(new_books, key=book_rating, reverse=True) return ranked_books"},{"question":"# Question: String Reversal in Different Bases Objective Implement a solution to reverse strings representing numbers in different bases (binary, octal, decimal, and hexadecimal) and convert them back to their original form in the original base. Task 1. **Implement a function, `reverse_string_base(n: str, base: int) -> str`,** that takes a string `n` representing a number in a given base and an integer `base` representing the base (2, 8, 10, or 16). The function should reverse the string and then decode it back to an integer, before encoding it again as a string in the original base. Function Signature ```python def reverse_string_base(n: str, base: int) -> str: # Reverse the string n, convert it to an integer given the base, # and then convert it back to a string representing the same base. pass ``` Expected Input and Output - **Input**: A string `n` and an integer `base` where `base` is one of [2, 8, 10, 16]. - **Output**: A string representing the number in the original base after reversing its string representation. Constraints - `2 ≤ base ≤ 16` - The string `n` is a valid representation in the given base. Example ```python >>> reverse_string_base(\'1010\', 2) \'0101\' >>> reverse_string_base(\'1234\', 10) \'4321\' >>> reverse_string_base(\'17\', 8) \'71\' >>> reverse_string_base(\'1A3\', 16) \'3A1\' ``` Explanation - For `n = \'1010\'` in base `2`, reversing yields `\'0101\'` which is the same because 1\'s and 0\'s determine the value directly in binary. - For `n = \'1234\'` in base `10`, reversing yields `4321`. - For `n = \'17\'` in base `8`, reversing yields `71`. - For `n = \'1A3\'` in base `16`, reversing yields `3A1`.","solution":"def reverse_string_base(n: str, base: int) -> str: # Reverse the string n reversed_n = n[::-1] # Convert the reversed string to an integer given the base integer_value = int(reversed_n, base) # Convert the integer back to a string in the original base if base == 2: return bin(integer_value)[2:] # Remove \'0b\' prefix elif base == 8: return oct(integer_value)[2:] # Remove \'0o\' prefix elif base == 10: return str(integer_value) # No prefix for decimal elif base == 16: return hex(integer_value)[2:].upper() # Remove \'0x\' prefix and use uppercase letters raise ValueError(\\"Base must be one of [2, 8, 10, 16]\\")"},{"question":"# Scenario You are a software developer at a company that manages an online book store. Your task is to implement a function that, given a list of book titles, identifies and returns duplicate titles along with the number of occurrences of each duplicate. # Task Write a function `find_duplicates(titles: List[str]) -> Dict[str, int]` that takes a list of book titles (strings) and returns a dictionary where the keys are the duplicated titles and the values are their respective frequencies. # Input Format * `titles`: A list of book titles (strings). The list may contain up to (10^5) titles. # Output Format * Return a dictionary where each key is a duplicated book title and each value is the count of how many times that title appears in the list. * Only include titles that appear more than once in the list. # Constraints * All titles are non-empty strings and their lengths do not exceed 100 characters. * The book titles are case-sensitive (i.e., \\"Book\\" and \\"book\\" are considered different). # Example ```python titles = [ \\"Harry Potter and the Sorcerer\'s Stone\\", \\"The Hobbit\\", \\"Harry Potter and the Chamber of Secrets\\", \\"The Hobbit\\", \\"Harry Potter and the Sorcerer\'s Stone\\", \\"1984\\" ] print(find_duplicates(titles)) # Output: {\\"Harry Potter and the Sorcerer\'s Stone\\": 2, \\"The Hobbit\\": 2} ```","solution":"from typing import List, Dict from collections import Counter def find_duplicates(titles: List[str]) -> Dict[str, int]: Identifies and returns duplicate titles along with their occurrence counts. title_counts = Counter(titles) duplicates = {title: count for title, count in title_counts.items() if count > 1} return duplicates"},{"question":"# Coding Assessment Question Context You are developing a function to find the first non-repeated character in a string. This task will help you understand string manipulation and the use of data structures for counting occurrences in languages like Python. Task Implement a function `first_non_repeated` that finds the first character in a string that does not repeat. If all characters in the string repeat, the function should return `None`. Function Specification ```python def first_non_repeated(s: str) -> str: Finds the first non-repeated character in the string. Examples: >>> first_non_repeated(\\"swiss\\") \'w\' >>> first_non_repeated(\\"repetition\\") \'r\' >>> first_non_repeated(\\"aabbcc\\") None When the input string is empty: >>> first_non_repeated(\\"\\") None When the input string has one character: >>> first_non_repeated(\\"x\\") \'x\' Returns: str | None: The first character that does not repeat, or None if all characters repeat. pass ``` Constraints * The function should have optimal time complexity. * Assume the input string only contains lowercase alphabetical characters. * The input string can have a length of up to 10^5 characters. Input Format A single string `s`. Output Format Returns the first non-repeated character as a string. If all characters are repeated, returns `None`. Examples * Input: `\\"swiss\\"` * Expected Output: `\'w\'` * Input: `\\"repetition\\"` * Expected Output: `\'r\'` * Input: `\\"aabbcc\\"` * Expected Output: `None`","solution":"def first_non_repeated(s: str) -> str: Finds the first non-repeated character in the string. Examples: >>> first_non_repeated(\\"swiss\\") \'w\' >>> first_non_repeated(\\"repetition\\") \'r\' >>> first_non_repeated(\\"aabbcc\\") None When the input string is empty: >>> first_non_repeated(\\"\\") None When the input string has one character: >>> first_non_repeated(\\"x\\") \'x\' Returns: str | None: The first character that does not repeat, or None if all characters repeat. # Dictionary to count occurrences of each character char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char return None"},{"question":"# Problem Statement You are helping a logistics company optimize their delivery scheduling. The company wants to determine the maximum number of packages that can be delivered without exceeding the vehicle\'s weight capacity. # Task Implement a function `max_packages` that returns the maximum number of packages that can be delivered given the weights of the packages and the vehicle\'s weight capacity. Function Signature ```python def max_packages(package_weights: List[float], vehicle_capacity: float) -> int: ``` Input * `package_weights` (List[float]): A list containing the weight of each package. Each weight is a positive float. * `vehicle_capacity` (float): The maximum weight capacity of the vehicle. Output * (int): The maximum number of packages that can be delivered without exceeding the weight capacity. Constraints * `1 ≤ len(package_weights) ≤ 100` * `0.1 ≤ each weight in package_weights ≤ vehicle_capacity` * `0.1 ≤ vehicle_capacity ≤ 10000.0` # Example ```python max_num = max_packages([2.5, 3.0, 1.5, 4.0, 2.0], 7.5) print(max_num) # Output: 3 (Packages with weights 1.5, 2.0, and 2.5 can be delivered without exceeding the vehicle capacity) ``` # Notes 1. Ensure to validate the input values. 2. Consider using a greedy algorithm to maximize the number of packages by prioritizing lighter packages first. 3. Document any assumptions or additional considerations in your solution. This question requires careful analysis and a methodical approach to ensure the constraints are adhered to while checking different combinations of package weights to maximize deliveries without exceeding capacity limits.","solution":"from typing import List def max_packages(package_weights: List[float], vehicle_capacity: float) -> int: Returns the maximum number of packages that can be delivered without exceeding the vehicle\'s weight capacity. Args: package_weights (List[float]): A list containing the weight of each package. vehicle_capacity (float): The maximum weight capacity of the vehicle. Returns: int: The maximum number of packages that can be delivered. # Sort the package weights to use a greedy approach package_weights.sort() total_weight = 0 count = 0 for weight in package_weights: if total_weight + weight <= vehicle_capacity: total_weight += weight count += 1 else: break return count"},{"question":"# Coding Question Context: You have been hired to develop a function that sorts a list of dictionary items based on a given key. Each dictionary in the list represents a student with their respective attributes such as name, age, and grade. Objective: Implement a function that sorts a list of dictionaries based on a specified key and order. Function Signature: ```python def sort_students(students: list, key:str, ascending: bool = True) -> list: :param students: list : a list of dictionaries, where each dictionary contains student attributes. :param key: str : the key by which to sort the dictionaries. :param ascending: bool : a boolean indicating whether to sort in ascending order (default True). :return: list : a sorted list of student dictionaries. Example: >>> students = [ ... {\'name\': \'Alice\', \'age\': 24, \'grade\': 88}, ... {\'name\': \'Bob\', \'age\': 22, \'grade\': 95}, ... {\'name\': \'Charlie\', \'age\': 23, \'grade\': 78} ... ] >>> sort_students(students, \'age\') [ ... {\'name\': \'Bob\', \'age\': 22, \'grade\': 95}, ... {\'name\': \'Charlie\', \'age\': 23, \'grade\': 78}, ... {\'name\': \'Alice\', \'age\': 24, \'grade\': 88} ... ] >>> sort_students(students, \'grade\', False) [ ... {\'name\': \'Bob\', \'age\': 22, \'grade\': 95}, ... {\'name\': \'Alice\', \'age\': 24, \'grade\': 88}, ... {\'name\': \'Charlie\', \'age\': 23, \'grade\': 78} ... ] ``` Requirements: * **Input**: * `students` - a list of dictionaries, where each dictionary contains attributes like \'name\', \'age\', and \'grade\'. * `key` - a string indicating the dictionary key to sort by. * `ascending` - a boolean indicating the sort order; `True` for ascending and `False` for descending (default is `True`). * **Output**: * Return a list of dictionaries sorted based on the given key and order. Constraints: * Each dictionary will always have the specified key. * The `students` list and the dictionaries are well-formed and non-empty. * Keys can be of different types (i.e., integer for \'age\', float for \'grade\', string for \'name\') and should be handled appropriately. * Ensure stable sorting, i.e., students with the same key value maintain their relative order. Edge Cases: * Sorting by a key that has the same value for multiple students. * Different types of data as the value of the key (string, integer, float). Your function should maintain efficiency and stability with varying data sizes and types.","solution":"def sort_students(students: list, key: str, ascending: bool = True) -> list: Sorts a list of dictionaries based on a specified key and order. :param students: list : a list of dictionaries, where each dictionary contains student attributes. :param key: str : the key by which to sort the dictionaries. :param ascending: bool : a boolean indicating whether to sort in ascending order (default True). :return: list : a sorted list of student dictionaries. return sorted(students, key=lambda x: x[key], reverse=not ascending)"},{"question":"# Problem Statement You are given an array of integers `nums` and an integer `target`. Your task is to determine whether there is a pair of integers in the array whose sum is equal to the given `target`. If such a pair exists, return the indices of the two integers in the form of a list `[index1, index2]`. The indices in the list should be in ascending order. If no such pair exists, return an empty list. Implement the following function: ```python def find_pair_with_sum(nums: list[int], target: int) -> list[int]: pass ``` # Constraints: * The input array `nums` will have at most `10^5` elements. * `-10^9 <= nums[i] <= 10^9` * The `target` will be within the range `-10^9 <= target <= 10^9`. * Each input would have exactly one solution, and you may not use the same element twice. # Examples 1. `find_pair_with_sum([2, 7, 11, 15], 9)` should return `[0, 1]` because `nums[0] + nums[1] = 2 + 7 = 9`. 2. `find_pair_with_sum([1, 2, 3, 4], 7)` should return `[2, 3]` because `nums[2] + nums[3] = 3 + 4 = 7`. 3. `find_pair_with_sum([3, 2, 4], 6)` should return `[1, 2]` because `nums[1] + nums[2] = 2 + 4 = 6`. 4. `find_pair_with_sum([3, 3], 6)` should return `[0, 1]` because `nums[0] + nums[1] = 3 + 3 = 6`. # Directions: * Implement the function `find_pair_with_sum` as described. * Aim for optimal time and space complexity. * Consider edge cases like the presence of negative numbers, large array sizes, and the possibility of multiple pairs summing to the target (though the problem guarantees exactly one solution here).","solution":"def find_pair_with_sum(nums: list[int], target: int) -> list[int]: Returns a list of two indices whose values in the input array sum up to the target. If no such pair exists, returns an empty list. # Dictionary to store the complement and its index complement_map = {} for index, num in enumerate(nums): # The complement is what we need to add to num to get the target complement = target - num # If complement is in the dictionary then we found our pair if complement in complement_map: return [complement_map[complement], index] # Store the index of the current number in the dictionary complement_map[num] = index # If we reach here, no pair found which should not happen as per problem constraints return []"},{"question":"# Coding Challenge: Implement a Custom Dijkstra\'s Algorithm with Path Reconstruction **Context**: You have been provided with a graph represented as an adjacency list and your task is to implement Dijkstra\'s algorithm to find the shortest path from a starting node to an ending node, and also return the actual path taken. **Your Task**: Write a Python function `dijkstra_shortest_path(graph, start_node, end_node)` that performs Dijkstra\'s algorithm to find the shortest path from `start_node` to `end_node`. The function should return both the length of the shortest path and the sequence of nodes that form this path. **Input**: - `graph`: A dictionary where the keys are node identifiers (integers or strings) and the values are dictionaries representing the neighboring nodes and the corresponding edge weights. - `start_node`: The node identifier where the path starts. - `end_node`: The node identifier where the path ends. **Output**: - Tuple `(shortest_path_length, path)`: - `shortest_path_length`: A float representing the length of the shortest path from `start_node` to `end_node`. - `path`: A list of nodes representing the shortest path from `start_node` to `end_node`. **Constraints**: - All edge weights are non-negative. - Graph is connected and contains at least two nodes. - `start_node` and `end_node` are distinct and exist in the graph. **Example**: Given the graph: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } ``` and the nodes \'A\' and \'D\', the function call `dijkstra_shortest_path(graph, \'A\', \'D\')` should output `(4, [\'A\', \'B\', \'C\', \'D\'])`. ```python import heapq def dijkstra_shortest_path(graph, start_node, end_node): Dijkstra\'s algorithm to find the shortest path in a graph with path reconstruction. Args: graph (dict): Adjacency list representation of the graph. start_node (str/int): The starting node. end_node (str/int): The ending node. Returns: tuple: (shortest_path_length, path) shortest_path_length (float): The length of the shortest path from start_node to end_node. path (list): The nodes in the shortest path from start_node to end_node. # Priority queue to store the nodes to explore: (distance, node) pq = [(0, start_node)] # Dictionary to store the minimum distance to each node distances = {node: float(\'infinity\') for node in graph} distances[start_node] = 0 # Dictionary to store the path taken to reach each node previous_nodes = {} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end_node: break for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) previous_nodes[neighbor] = current_node # Reconstruct the path path = [] node = end_node while node != start_node: path.insert(0, node) node = previous_nodes[node] if node is None: # In case there is no valid path return float(\'infinity\'), [] path.insert(0, start_node) return distances[end_node], path # Example usage: graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start_node = \'A\' end_node = \'D\' shortest_path_length, path = dijkstra_shortest_path(graph, start_node, end_node) print(\\"Shortest path length:\\", shortest_path_length) print(\\"Shortest path:\\", path) ``` **Note**: Make sure your function handles cases where there is no path from `start_node` to `end_node` appropriately. If no path exists, return `float(\'infinity\')` for the distance and an empty list for the path.","solution":"import heapq def dijkstra_shortest_path(graph, start_node, end_node): Dijkstra\'s algorithm to find the shortest path in a graph with path reconstruction. Args: graph (dict): Adjacency list representation of the graph. start_node (str/int): The starting node. end_node (str/int): The ending node. Returns: tuple: (shortest_path_length, path) shortest_path_length (float): The length of the shortest path from start_node to end_node. path (list): The nodes in the shortest path from start_node to end_node. # Priority queue to store the nodes to explore: (distance, node) pq = [(0, start_node)] # Dictionary to store the minimum distance to each node distances = {node: float(\'infinity\') for node in graph} distances[start_node] = 0 # Dictionary to store the path taken to reach each node previous_nodes = {} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end_node: break for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) previous_nodes[neighbor] = current_node # Reconstruct the path path = [] node = end_node while node != start_node: path.insert(0, node) node = previous_nodes.get(node) if node is None: # In case there is no valid path return float(\'infinity\'), [] path.insert(0, start_node) return distances[end_node], path"},{"question":"# Palindrome Number Checker Scenario: You are developing a feature for a software application that needs to check if a given number is a palindrome. A palindrome is a number that reads the same forwards and backwards. For instance, 121 is a palindrome while 123 is not. Task: Implement a Python function `is_palindrome(number: int) -> bool` that determines if the provided number is a palindrome. If the provided value is not an integer, the function should raise an appropriate exception. Function Requirements: * **Input**: * `number` (int): The number to check for palindromic properties. * **Output**: * Returns `True` if the `number` is a palindrome, otherwise `False`. * **Constraints**: * Accepts only integer inputs. * Raise a `TypeError` if the input is not an integer. * **Performance Requirements**: * The function should have a time complexity of O(n), where n is the number of digits in the input number. Example Usage: ```python assert is_palindrome(121) == True assert is_palindrome(-121) == False assert is_palindrome(10) == False assert is_palindrome(12321) == True ``` Additional Scenarios & Edge Cases to Consider: * Non-integer input: ```python is_palindrome(\\"121\\") # Raises TypeError is_palindrome(12.1) # Raises TypeError ``` Implement the function `is_palindrome` to fulfill these requirements.","solution":"def is_palindrome(number: int) -> bool: Determines if the provided number is a palindrome. Parameters: number (int): The number to check. Returns: bool: True if the number is a palindrome, otherwise False. Raises: TypeError: If the input is not an integer. if not isinstance(number, int): raise TypeError(\\"Input must be an integer\\") str_number = str(number) return str_number == str_number[::-1]"},{"question":"# Coding Assessment Question The company WaterFlow Inc. tracks the water usage in residential buildings. They store the data in a list where each index represents a specific day, and the value at that index represents the water usage in liters. To analyze trends, they want to determine the highest volume of water used in any contiguous subrange of days within a given period. Objective: Write a function `max_water_usage(water_usage: List[int], days: int) -> int` that takes a list of integers representing daily water usage and an integer representing the number of days, and returns the maximum water usage observed in any contiguous subrange of the given period. Input: - `water_usage` (List[int]): A list of integers where each integer represents the water usage for a specific day. - `days` (1 <= len(water_usage) <= 10^5): An integer representing the number of days. Output: - Returns an integer indicating the maximum water usage observed in any contiguous subrange of the given period. Example: ```python assert max_water_usage([2, 1, 5, 3, 6, 4], 3) == 14 assert max_water_usage([1, -3, 2, 1, -1], 2) == 3 assert max_water_usage([4, -1, 2, 1], 4) == 6 ``` Constraints: - The solution should handle both positive and negative numbers in the list effectively. - Ensure the implementation is efficient, possible with a time complexity of O(n). Performance Requirements: - Use algorithms like Kadane\'s algorithm for finding the maximum subarray sum to ensure optimal performance. - Taking care of different edge cases where given periods might only include negative numbers as well.","solution":"from typing import List def max_water_usage(water_usage: List[int], days: int) -> int: Returns the maximum water usage observed in any contiguous subrange of the given period. if days <= 0 or days > len(water_usage): raise ValueError(\\"Number of days must be in the valid range.\\") max_sum = current_sum = sum(water_usage[:days]) for i in range(days, len(water_usage)): current_sum += water_usage[i] - water_usage[i - days] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Merge Sort - Recursive Sorting Algorithm You are a software engineer at a company focused on developing efficient sorting algorithms. Your latest task involves implementing the \\"Merge Sort\\" algorithm, which is a classic divide-and-conquer algorithm. Merge Sort Merge Sort works by recursively dividing the unsorted array into two halves until each half contains only one element, then merges the halves together in a sorted manner. # Task You need to implement a function `merge_sort(arr: list[int]) -> list[int]` that sorts an array of integers using the merge sort algorithm. # Input and Output Formats * **Input**: - `arr`: a list of integers that needs to be sorted. * **Output**: - Returns a new list of integers, which is the sorted version of the input list. # Example: ```python merge_sort([38, 27, 43, 3, 9, 82, 10]) => [3, 9, 10, 27, 38, 43, 82] merge_sort([1, 5, 3, 2, 8, 7, 6, 4]) => [1, 2, 3, 4, 5, 6, 7, 8] ``` # Constraints: * Ensure the function handles an empty list properly by returning an empty list. * The input list can have up to 10,000 elements. * Optimize the merging process to minimize the number of operations. # Performance: * The algorithm\'s time complexity should be O(n log n), typical for merge sort. * Utilize recursion efficiently to avoid stack overflow errors. **Note**: You can define additional helper functions if needed for merging two sorted sublists. # Hints: 1. To divide the array, you can find the middle point using integer division. 2. To merge two sorted arrays, ensure to handle duplicates and maintain their order as well. ```python def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result ```","solution":"def merge_sort(arr: list[int]) -> list[int]: Sorts an array of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: Merges two sorted lists into one sorted list. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Iterating over Linked List in Reverse In this programming task, you will work with a custom `LinkedList` class that supports various linked list operations. Your goal is to implement a specific method and verify its correctness. Problem Statement You are given the `LinkedList` class with its current functionalities as defined in the code snippet provided. Implement the following additional feature: # Method: `reverse_iter()` Create an iterator that allows iterating over the linked list elements in reverse order. # Expected Input and Output Formats * **Input**: The method will be called on a `LinkedList` instance, which can contain any number of elements. * **Output**: An iterator that yields the elements of the linked list in reverse order. # Constraints and Limitations: 1. You must implement the method such that it efficiently handles lists of varying lengths, including very large lists. 2. The linked list can contain any data type in its nodes. 3. Minimize the space complexity of the solution as much as possible. Example Scenario ```python >>> lst = LinkedList() >>> lst.append(1) >>> lst.append(2) >>> lst.append(3) >>> rev_iter = lst.reverse_iter() >>> [item for item in rev_iter] [3, 2, 1] ``` Use this function implementation to ensure your logic allows proper reverse iteration of the list. # Implementation Complete the following method within the `LinkedList` class: ```python def reverse_iter(self): # Your code here pass ``` Ensure your tested implementation handles edge cases such as an empty linked list. Evaluation Criteria * **Correctness**: The iterator should correctly yield elements in reverse order. * **Efficiency**: The solution should handle the given constraints. * **Readability**: The code should be clean, and well-documented.","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def reverse_iter(self): # Generate the elements in reverse order def generate_reverse(node): if node: yield from generate_reverse(node.next) yield node.data return generate_reverse(self.head)"},{"question":"# Problem Statement You are given a string `time` representing the time in the format \\"HH:MM\\", where HH is a two-digit hour that ranges from \\"00\\" to \\"23\\", and MM is a two-digit minute that ranges from \\"00\\" to \\"59\\". Your task is to determine the minimum number of replacements needed in the given time string so that it represents a valid time. A replacement can change any digit in the string to any other digit (\'0\' - \'9\'). # Function Signature ```python def min_replacements_to_valid_time(time: str) -> int: pass ``` # Input - `time`: A string of length 5 representing the time in the format \\"HH:MM\\". # Output - Return the minimum number of digit replacements needed to make the given time string a valid time. # Constraints - The provided time string will always be of the format \\"HH:MM\\". # Example ```python time = \\"2?:3?\\" output = min_replacements_to_valid_time(time) # Expected output: 2 Explanation: The two \'?\' can be replaced with \'0\' and \'0\' to form \\"20:30\\". time = \\"12:?5\\" output = min_replacements_to_valid_time(time) # Expected output: 1 Explanation: The \'?\' can be replaced with \'0\' to form \\"12:05\\". time = \\"?4:5?\\" output = min_replacements_to_valid_time(time) # Expected output: 1 Explanation: The \'?\' can be replaced with \'1\' to form \\"14:50\\" or \\"04:51\\". ``` # Implementation Details - Implement the `min_replacements_to_valid_time` function. - Ensure to handle edge cases like having multiple \'?\' in the input string. Ensure that the replacements result in a valid time considering both hours and minutes separately.","solution":"def min_replacements_to_valid_time(time: str) -> int: Returns the minimum number of digit replacements needed to make the given time string a valid time. count = 0 hours, minutes = time.split(\\":\\") # Check hours if hours[0] == \'?\': if hours[1] == \'?\' or \'0\' <= hours[1] <= \'3\': count += 1 # Can replace with 2 else: count += 1 # Must replace with 0,1 if hours[1] == \'?\': if hours[0] == \'2\': count += 1 # Can replace with 0,1,2,3 else: count += 1 # Can replace with 0,1,2,3,4,5,6,7,8,9 # Check minutes if minutes[0] == \'?\': count += 1 # Can replace with any digit 0-5 if minutes[1] == \'?\': count += 1 # Can replace with any digit 0-9 return count"},{"question":"# Balanced Parentheses with Counts Background: Balanced parentheses are sequences of opening \'(\' and closing \')\' parentheses where every opening parenthesis has a corresponding closing parenthesis, and the pairs are properly nested. For example, the sequences \\"()\\", \\"(())\\", and \\"(()(()))\\" are balanced, while \\"(\\", \\")\\", \\"(()\\", and \\"())(\\" are not. Task: You need to extend the `BalancedParentheses` class with two functionalities: 1. Check if a given string of parentheses is balanced. 2. Count the maximum depth of nested parentheses if the string is balanced, otherwise return -1. Requirements: - Write a method `is_balanced(self, s: str) -> bool` that checks if the input string `s` is balanced. - Write a method `max_depth(self, s: str) -> int` that returns the maximum depth of nested parentheses in a balanced string `s`. If the string is not balanced, return -1. Function Signature: ```python def is_balanced(self, s: str) -> bool: # Your code here def max_depth(self, s: str) -> int: # Your code here ``` Input: - The input string `s` contains only the characters \'(\' and \')\'. Output: - `is_balanced(s: str) -> bool` returns `True` if the parentheses in the string are balanced; `False` otherwise. - `max_depth(s: str) -> int` returns the maximum depth of nested parentheses for a balanced string, or -1 if the string is not balanced. Constraints / Assumptions: - The string length can be up to 10^5. - You need to ensure efficient traversal and calculation to handle large inputs. # Function Examples: ```python # Example 1 bp = BalancedParentheses() s = \\"((()))\\" print(bp.is_balanced(s)) # Returns True print(bp.max_depth(s)) # Returns 3 # Example 2 s = \\"((()(())))\\" print(bp.is_balanced(s)) # Returns True print(bp.max_depth(s)) # Returns 4 # Example 3 s = \\"(()(()\\" print(bp.is_balanced(s)) # Returns False print(bp.max_depth(s)) # Returns -1 # Example 4 s = \\"())(\\" print(bp.is_balanced(s)) # Returns False print(bp.max_depth(s)) # Returns -1 ```","solution":"class BalancedParentheses: def is_balanced(self, s: str) -> bool: balance = 0 for char in s: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: return False return balance == 0 def max_depth(self, s: str) -> int: if not self.is_balanced(s): return -1 current_depth = 0 max_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"# Task Implement a function that parses a mathematical expression containing only the four basic arithmetic operations (+, -, *, /) and parentheses, and evaluates it to return the result. The input expression is given as a string and may contain whitespace that should be ignored. You must handle operator precedence and parentheses correctly. # Function Signature ```python def evaluate_expression(expression: str) -> float: Evaluate the given mathematical expression and return the result. Parameters: expression (str): A string representing a mathematical expression which may include +, -, *, / operators, parentheses, and whitespace. Returns: float: The result of evaluating the expression. Example Usage: >>> evaluate_expression(\\"3 + 5\\") 8.0 >>> evaluate_expression(\\"10 + 2 * 6\\") 22.0 >>> evaluate_expression(\\"100 * 2 + 12\\") 212.0 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400.0 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.0 pass ``` # Specifications 1. Implement the `evaluate_expression` function to parse and evaluate the mathematical expression provided as a string. 2. Ensure that the function correctly handles whitespace, operator precedence, and parentheses. 3. The function should return the result as a `float`. # Input - **expression**: A string representing a mathematical expression containing digits, whitespace, operators (+, -, *, /), and parentheses. # Output - The function should return a `float` representing the evaluated result of the expression. # Example 1. Evaluate a simple addition expression: ```python evaluate_expression(\\"3 + 5\\") ``` - Expected output: `8.0` 2. Evaluate an expression with mixed operators: ```python evaluate_expression(\\"10 + 2 * 6\\") ``` - Expected output: `22.0` 3. Evaluate an expression with parentheses: ```python evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") ``` - Expected output: `100.0` # Constraints - The input expression is guaranteed to be a valid mathematical expression. - The operands and intermediate results are within the range of a 32-bit float. - Division is floating point division, not integer division.","solution":"import re def evaluate_expression(expression: str) -> float: Evaluate the given mathematical expression and return the result. Parameters: expression (str): A string representing a mathematical expression which may include +, -, *, / operators, parentheses, and whitespace. Returns: float: The result of evaluating the expression. def eval_inner(expr): tokens = re.findall(r\'d+.?d*|+|-|*|/|(|)\', expr) def evaluate(tokens): def get_next_token(): return tokens.pop(0) if tokens else None def parse_expression(): token = get_next_token() if token == \'(\': value = parse_add_sub() get_next_token() # should be \')\' return value return float(token) def parse_term(): value = parse_expression() while tokens: token = get_next_token() if token == \'*\': value *= parse_expression() elif token == \'/\': value /= parse_expression() else: tokens.insert(0, token) break return value def parse_add_sub(): value = parse_term() while tokens: token = get_next_token() if token == \'+\': value += parse_term() elif token == \'-\': value -= parse_term() else: tokens.insert(0, token) break return value return parse_add_sub() return evaluate(tokens) expr = expression.replace(\' \', \'\') return eval_inner(expr)"},{"question":"# Coding Assessment Question **Scenario**: Develop a pathfinding algorithm that helps a robot navigate a grid filled with obstacles from a given start point to an end point. The robot can only move up, down, left, or right, avoiding obstacles and staying within the grid boundaries. # Problem Statement: Implement a function `find_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int])` that finds the shortest path for the robot to travel from the start position to the end position. You should return the path as a list of coordinate tuples representing the grid cells the robot passed through, including the start and end points. If there is no valid path, return an empty list. # Requirements: 1. **Input**: - `grid`: A 2D list of integers where `0` represents an open cell and `1` represents an obstacle. - `start`: A tuple representing the robot\'s starting position (row, column). - `end`: A tuple representing the robot\'s ending position (row, column). 2. **Output**: - A list of tuples, each representing the grid cells in the path from start to end, inclusive. - If no path exists, return an empty list. 3. **Constraints**: - The grid dimensions will be between 1x1 and 100x100. - The start and end points will always be within the grid bounds. - The start point will never be an obstacle, but the end point can be. # Examples: ```python >>> find_path([[0, 0, 0], [1, 0, 1], [0, 0, 0]], (0, 0), (2, 2)) [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)] >>> find_path([[0, 1], [0, 0]], (0, 0), (1, 1)) [(0, 0), (1, 0), (1, 1)] >>> find_path([[0, 1], [1, 0]], (0, 0), (1, 1)) [] # No valid path >>> find_path([[0]], (0, 0), (0, 0)) # Start and end are the same [(0, 0)] >>> find_path([[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0]], (0, 0), (2, 3)) [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3)] ``` # Guidelines: * Ensure your function correctly handles cases such as obstacles completely blocking a path or having multiple paths to choose from. * Implement an efficient algorithm such as Breadth-First Search (BFS) to find the shortest path. * Avoid excessive memory usage with proper handling of the grid cells and visited states. * Consider performance implications for larger grids up to the maximum constraints.","solution":"from collections import deque from typing import List, Tuple def find_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) if start == end: return [start] if grid[end[0]][end[1]] == 1: return [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start, [start])]) # queue stores (current_position, path_to_current) visited = set() visited.add(start) while queue: current, path = queue.popleft() for direction in directions: nr, nc = current[0] + direction[0], current[1] + direction[1] if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: if (nr, nc) == end: return path + [(nr, nc)] queue.append(((nr, nc), path + [(nr, nc)])) visited.add((nr, nc)) return []"},{"question":"# Coding Assessment: Polynomial Operations in Mathematics Given a polynomial represented by its coefficients in decreasing order of powers, write a program to perform various operations on polynomials. You need to implement three core functions to complete the task: 1. **add_polynomials** 2. **subtract_polynomials** 3. **multiply_polynomials** Requirements 1. **add_polynomials(p1, p2):** - **Input**: - `p1`: list of floats, coefficients of the first polynomial in decreasing order of powers. - `p2`: list of floats, coefficients of the second polynomial in decreasing order of powers. - **Output**: - Returns a list of floats representing the coefficients of the resulting polynomial after adding `p1` and `p2`. - **Constraints**: - If the input lists are empty, raise `ValueError`. 2. **subtract_polynomials(p1, p2):** - **Input**: - `p1`: list of floats, coefficients of the first polynomial in decreasing order of powers. - `p2`: list of floats, coefficients of the second polynomial in decreasing order of powers. - **Output**: - Returns a list of floats representing the coefficients of the resulting polynomial after subtracting `p2` from `p1`. - **Constraints**: - If the input lists are empty, raise `ValueError`. 3. **multiply_polynomials(p1, p2):** - **Input**: - `p1`: list of floats, coefficients of the first polynomial in decreasing order of powers. - `p2`: list of floats, coefficients of the second polynomial in decreasing order of powers. - **Output**: - Returns a list of floats representing the coefficients of the resulting polynomial after multiplying `p1` and `p2`. - **Constraints**: - If the input lists are empty, raise `ValueError`. Ensure your solution includes appropriate error handling as specified and follows the given format. Examples ```python # Given two polynomials, add them result = add_polynomials([1, 2, 3], [3, 2, 1]) # Expected: [4, 4, 4] # Given two polynomials, subtract the second from the first result = subtract_polynomials([5, 0, -2], [3, 2, 1]) # Expected: [2, -2, -3] # Given two polynomials, multiply them result = multiply_polynomials([1, 2], [1, 2, 3]) # Expected: [1, 4, 7, 6] ``` Use the above-mentioned function definitions to implement the required functionality.","solution":"def add_polynomials(p1, p2): Adds two polynomials represented by their coefficients. if not p1 or not p2: raise ValueError(\\"Input polynomials cannot be empty.\\") length = max(len(p1), len(p2)) result = [0] * length for i in range(1, len(p1) + 1): result[-i] += p1[-i] for i in range(1, len(p2) + 1): result[-i] += p2[-i] return result def subtract_polynomials(p1, p2): Subtracts the second polynomial from the first, represented by their coefficients. if not p1 or not p2: raise ValueError(\\"Input polynomials cannot be empty.\\") length = max(len(p1), len(p2)) result = [0] * length for i in range(1, len(p1) + 1): result[-i] += p1[-i] for i in range(1, len(p2) + 1): result[-i] -= p2[-i] return result def multiply_polynomials(p1, p2): Multiplies two polynomials represented by their coefficients. if not p1 or not p2: raise ValueError(\\"Input polynomials cannot be empty.\\") result = [0] * (len(p1) + len(p2) - 1) for i in range(len(p1)): for j in range(len(p2)): result[i + j] += p1[i] * p2[j] return result"},{"question":"# Problem Statement: You are given a class `BinarySearchTree` that implements a basic binary search tree (BST). You need to extend the class with the following functionalities: 1. **find_kth_smallest(k)**: Implement a method to find and return the `k`-th smallest element in the BST. If `k` is greater than the number of nodes in the tree, return `-1`. 2. **is_valid_bst()**: Implement a method to validate whether the tree is a valid BST. The method should return `True` if the tree is a valid BST and `False` otherwise. # Expected Input and Output Formats: * For `find_kth_smallest(k)`: * **Input**: * `k` (int): The `k`-th position (1-based index) to find the smallest element. * **Output**: * Returns the `k`-th smallest element in the BST. If `k` is invalid, return `-1`. * For `is_valid_bst()`: * **Output**: * Returns either `True` or `False`. # Constraints: 1. The number of nodes in the BST can be up to `N = 10^4`. 2. The value of each node is a unique integer within the range `[-10^5, 10^5]`. # Example: ```python bst = BinarySearchTree() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(3) bst.insert(15) bst.insert(25) print(bst.find_kth_smallest(3)) # Expected: 10 print(bst.find_kth_smallest(1)) # Expected: 3 print(bst.is_valid_bst()) # Expected: True # Manipulate tree structure for validation bst.root.left.left.right = TreeNode(12) print(bst.is_valid_bst()) # Expected: False ``` # Solution Template: You may start with the provided code snippet and extend the class as described in the task. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): def _insert(root, val): if not root: return TreeNode(val) if val < root.val: root.left = _insert(root.left, val) else: root.right = _insert(root.right, val) return root if not self.root: self.root = TreeNode(val) else: _insert(self.root, val) def inorder(self): def _inorder(root): return _inorder(root.left) + [root.val] + _inorder(root.right) if root else [] return _inorder(self.root) def find_kth_smallest(self, k): # Implement the method to find the k-th smallest element. pass def is_valid_bst(self): # Implement the method to validate if the BST is valid. pass ``` ```python # You can run your tests here bst = BinarySearchTree() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(3) bst.insert(15) bst.insert(25) print(bst.find_kth_smallest(3)) # Expected: 10 print(bst.find_kth_smallest(1)) # Expected: 3 print(bst.is_valid_bst()) # Expected: True bst.root.left.left.right = TreeNode(12) print(bst.is_valid_bst()) # Expected: False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): def _insert(root, val): if not root: return TreeNode(val) if val < root.val: root.left = _insert(root.left, val) else: root.right = _insert(root.right, val) return root if not self.root: self.root = TreeNode(val) else: _insert(self.root, val) def inorder_traversal(self, node): if not node: return [] return self.inorder_traversal(node.left) + [node.val] + self.inorder_traversal(node.right) def find_kth_smallest(self, k): inorder_list = self.inorder_traversal(self.root) if 0 < k <= len(inorder_list): return inorder_list[k - 1] return -1 def is_valid_bst_helper(self, node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return (self.is_valid_bst_helper(node.left, low, node.val) and self.is_valid_bst_helper(node.right, node.val, high)) def is_valid_bst(self): return self.is_valid_bst_helper(self.root)"},{"question":"# Friend Circle Detection using BFS You are provided with a two-dimensional matrix representing a social network, where each cell i, j contains a value of either 1 or 0. A value of 1 indicates that person i is friends with person j, and a value of 0 indicates no friendship. A friend circle is defined as a group of people who are directly or indirectly friends. Your task is to implement a function `find_friend_circles` that determines the number of friend circles in the matrix using Breadth-First Search (BFS). Requirements: 1. **Input**: A two-dimensional list `matrix` of size n x n, where n is the number of people. 2. **Output**: An integer representing the number of friend circles. 3. **Performance Constraints**: The function should run with a time complexity of O(n^2) and space complexity of O(n). Function Signature: ```python def find_friend_circles(matrix: List[List[int]]) -> int ``` Example: ```python # Example 1 matrix = [ [1, 1, 0], [1, 1, 0], [0, 0, 1] ] assert find_friend_circles(matrix) == 2 # There are 2 friend circles # Example 2 matrix = [ [1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1] ] assert find_friend_circles(matrix) == 1 # There is 1 friend circle ``` Note: - Ensure proper handling of cases where the matrix could be empty or contain only one person. - Implement the BFS traversal in a way that accurately detects all friends directly or indirectly connected to form friend circles.","solution":"from collections import deque from typing import List def find_friend_circles(matrix: List[List[int]]) -> int: def bfs(node: int): queue = deque([node]) visited.add(node) while queue: current = queue.popleft() for neighbor, is_friend in enumerate(matrix[current]): if is_friend == 1 and neighbor not in visited: visited.add(neighbor) queue.append(neighbor) n = len(matrix) if n == 0: return 0 visited = set() friend_circles = 0 for person in range(n): if person not in visited: friend_circles += 1 bfs(person) return friend_circles"},{"question":"# Question: Implementing a Balanced Binary Search Tree (AVL Tree) Context: You are tasked with implementing a balanced binary search tree, specifically an AVL (Adelson-Velsky and Landis) tree, to manage a dynamic dataset efficiently. Maintaining balance in the tree allows for consistent O(log n) time complexity for insertions, deletions, and lookups. Problem Statement: Write a Python class `AVLTree` that supports insertion, deletion, and search operations while maintaining balance. The tree should automatically rebalance itself after mutations to ensure all operations are efficient. Your class should implement the following methods: - `insert(self, key: int) -> None`: Inserts a key into the AVL Tree. - `delete(self, key: int) -> None`: Deletes a key from the AVL Tree. - `search(self, key: int) -> bool`: Searches for a key in the AVL Tree and returns `True` if found, otherwise `False`. - `is_balanced(self) -> bool`: Returns `True` if the tree is balanced, otherwise `False`. Input: * Insertion and deletion take a single integer key as input. * Search takes a single integer key as input. * All class methods should be executable without external inputs. Output: * `insert` and `delete` should not return any value. * `search` should return `True` if the key is found, `False` otherwise. * `is_balanced` should return `True` if the AVL tree properties are maintained, else `False`. Constraints: - Ensuring that the tree balances itself after each insertion and deletion. - Handle edge cases such as inserting duplicate keys gracefully. - All keys are unique integers. Example Usage: ```python # Define the AVL Tree class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: # Implement the insertion logic and balancing here def delete(self, key: int) -> None: # Implement the deletion logic and balancing here def search(self, key: int) -> bool: # Implement the search logic here def is_balanced(self) -> bool: # Implement the check for balance here # Example Usage avl_tree = AVLTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) print(avl_tree.search(20)) # Output: True print(avl_tree.is_balanced()) # Output: True avl_tree.delete(20) print(avl_tree.search(20)) # Output: False print(avl_tree.is_balanced()) # Output: True ``` Implement the complete class `AVLTree` with the specified methods and ensure it maintains the AVL Tree properties.","solution":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def __init__(self): self.root = None def _height(self, node): if not node: return 0 return node.height def _balance_factor(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._height(y.left), self._height(y.right)) x.height = 1 + max(self._height(x.left), self._height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._height(x.left), self._height(x.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self._height(node.left), self._height(node.right)) balance = self._balance_factor(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def insert(self, key): self.root = self._insert(self.root, key) def _min_value_node(self, node): if node is None or node.left is None: return node return self._min_value_node(node.left) def _delete(self, root, key): if not root: return root elif key < root.key: root.left = self._delete(root.left, key) elif key > root.key: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._min_value_node(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) root.height = 1 + max(self._height(root.left), self._height(root.right)) balance = self._balance_factor(root) if balance > 1 and self._balance_factor(root.left) >= 0: return self._right_rotate(root) if balance > 1 and self._balance_factor(root.left) < 0: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and self._balance_factor(root.right) <= 0: return self._left_rotate(root) if balance < -1 and self._balance_factor(root.right) > 0: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def delete(self, key): self.root = self._delete(self.root, key) def _search(self, node, key): if not node or node.key == key: return node if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def search(self, key): return self._search(self.root, key) is not None def _is_balanced(self, node): if not node: return True lh = self._height(node.left) rh = self._height(node.right) if abs(lh - rh) <= 1 and self._is_balanced(node.left) and self._is_balanced(node.right): return True return False def is_balanced(self): return self._is_balanced(self.root)"},{"question":"# Question: Design a Parking Lot System You are required to design a parking lot system with the following capabilities: 1. **Park a Vehicle:** Allow a vehicle to park in a specific slot if available. 2. **Free a Slot:** Free up a slot when a vehicle leaves. 3. **Check Available Slots:** Return a list of available slots. **Constraints**: - The parking lot has a fixed number of slots. - Each slot can accommodate exactly one vehicle. - The vehicles are identified by their license plate numbers. - The slots are numbered sequentially from 1 to N. Implement the ParkingLot class with the following methods: 1. **__init__(self, num_slots: int):** Initializes the parking lot with the given number of slots. 2. **park_vehicle(self, license_plate: str) -> bool:** Parks a vehicle with the given license plate in the first available slot and returns True. If no slots are available, returns False. 3. **free_slot(self, slot_number: int) -> bool:** Frees the slot with the given slot number and returns True. If the slot is already free or invalid, returns False. 4. **available_slots(self) -> list:** Returns a list of all available slots. **Example**: ```python parking_lot = ParkingLot(3) print(parking_lot.park_vehicle(\\"ABC123\\")) # Output: True print(parking_lot.park_vehicle(\\"XYZ789\\")) # Output: True print(parking_lot.available_slots()) # Output: [3] print(parking_lot.free_slot(2)) # Output: True print(parking_lot.available_slots()) # Output: [2, 3] print(parking_lot.park_vehicle(\\"LMN456\\")) # Output: True print(parking_lot.available_slots()) # Output: [3] print(parking_lot.free_slot(5)) # Output: False ``` **Note**: You are expected to handle the parking and slot freeing in an efficient manner. The list of available slots should always return in numerical order.","solution":"class ParkingLot: def __init__(self, num_slots: int): Initializes the parking lot with the given number of slots. self.num_slots = num_slots self.slots = [None] * num_slots def park_vehicle(self, license_plate: str) -> bool: Parks a vehicle with the given license plate in the first available slot and returns True. If no slots are available, returns False. for i in range(self.num_slots): if self.slots[i] is None: self.slots[i] = license_plate return True return False def free_slot(self, slot_number: int) -> bool: Frees the slot with the given slot number and returns True. If the slot is already free or invalid, returns False. if 1 <= slot_number <= self.num_slots and self.slots[slot_number - 1] is not None: self.slots[slot_number - 1] = None return True return False def available_slots(self) -> list: Returns a list of all available slots. return [i + 1 for i in range(self.num_slots) if self.slots[i] is None]"},{"question":"# Problem Description You are given the task of implementing a function to determine the longest contiguous subsequence in an array where the difference between the maximum and minimum elements is no greater than `k`. The function should return the length of this subsequence. # Function Signature ```python def longest_subsequence_within_range(arr: List[int], k: int) -> int: Find the length of the longest contiguous subsequence where the difference between the maximum and minimum elements is no greater than k. Args: arr (List[int]): A list of integers. k (int): The maximum allowed difference between the maximum and minimum elements in the subsequence. Returns: int: The length of the longest contiguous subsequence meeting the criteria. Examples: >>> longest_subsequence_within_range([1, 3, 6, 7, 2, 8, 9], 5) 4 >>> longest_subsequence_within_range([10, 1, 2, 10, 8, 7, 1, 3], 1) 2 ``` # Input * An integer array `arr` (1 ≤ len(arr) ≤ 10^5). * An integer `k` (0 ≤ `k` ≤ 10^9). # Output * Returns an integer representing the length of the longest contiguous subsequence within the specified range. # Constraints * The function should process efficiently, ideally with a linear time complexity of (O(n)) in relation to the input array\'s size. # Example ```python assert longest_subsequence_within_range([1, 3, 6, 7, 2, 8, 9], 5) == 4 assert longest_subsequence_within_range([10, 1, 2, 10, 8, 7, 1, 3], 1) == 2 assert longest_subsequence_within_range([1, 2, 3, 4, 5], 2) == 3 assert longest_subsequence_within_range([4, 4, 4, 4], 0) == 4 ``` # Performance Requirements * Implement the function in a way that handles large arrays efficiently, ensuring that it performs within the time constraints even for the upper limits of the input size.","solution":"from typing import List from collections import deque def longest_subsequence_within_range(arr: List[int], k: int) -> int: Find the length of the longest contiguous subsequence where the difference between the maximum and minimum elements is no greater than k. if not arr: return 0 min_deque = deque() max_deque = deque() start = 0 max_len = 0 for end in range(len(arr)): while min_deque and arr[min_deque[-1]] >= arr[end]: min_deque.pop() while max_deque and arr[max_deque[-1]] <= arr[end]: max_deque.pop() min_deque.append(end) max_deque.append(end) while arr[max_deque[0]] - arr[min_deque[0]] > k: if min_deque[0] == start: min_deque.popleft() if max_deque[0] == start: max_deque.popleft() start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"Task Question Creation for Coding Assessment Objective Analyze the provided sample question and create an additional question that aligns with the existing set in terms of style, complexity, and scope. Guidelines # Question Style - Carefully examine the format and presentation of the given question. - Maintain a consistent tone and language used in the original set. # Question Length - Ensure your new question is of comparable length to the existing one. - Aim for the average length if there is variation. # Difficulty Level - Assess the cognitive and technical challenges presented in the sample question. - Match the complexity of concepts, algorithms, or programming techniques required. # Topic Alignment - Identify the core programming concepts or domains covered in the existing question. - Create a question that explores a related or complementary area within the same general topic. # Question Uniqueness - While maintaining similarity, ensure your new question is not a mere rephrasing of the existing one. - Introduce a novel problem or scenario that tests the same skills in a different context. Output Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality. Hexagonal numbers form a sequence of numbers that represent hexagonally arranged dots. The nth hexagonal number `hₙ` is calculated using the formula: [ hₙ = n(2n - 1) ] Given a positive integer `length`, write a Python function `hexagonal_numbers(length: int) -> list[int]` that returns a list of the first `length` hexagonal numbers. **Function Signature**: ```python def hexagonal_numbers(length: int) -> list[int]: ``` # Input * A positive integer `length` which specifies the number of hexagonal numbers to generate. # Output * A list of integers containing the first `length` hexagonal numbers. # Constraints * `length` should be a positive integer (greater than zero). # Examples ```python >>> hexagonal_numbers(10) [0, 1, 6, 15, 28, 45, 66, 91, 120, 153] >>> hexagonal_numbers(5) [0, 1, 6, 15, 28] >>> hexagonal_numbers(1) [0] ``` # Notes * Ensure the function raises a `ValueError` if the input is not a positive integer. * Optimize for performance to handle reasonably large values of `length`. --- Triangular numbers form a sequence of numbers that represent objects arranged in the shape of an equilateral triangle. The nth triangular number `tₙ` is calculated using the formula: [ tₙ = frac{n(n + 1)}{2} ] Given a positive integer `length`, write a Python function `triangular_numbers(length: int) -> list[int]` that returns a list of the first `length` triangular numbers. **Function Signature**: ```python def triangular_numbers(length: int) -> list[int]: ``` # Input * A positive integer `length` which specifies the number of triangular numbers to generate. # Output * A list of integers containing the first `length` triangular numbers. # Constraints * `length` should be a positive integer (greater than zero). # Examples ```python >>> triangular_numbers(10) [0, 1, 3, 6, 10, 15, 21, 28, 36, 45] >>> triangular_numbers(5) [0, 1, 3, 6, 10] >>> triangular_numbers(1) [0] ``` # Notes * Ensure the function raises a `ValueError` if the input is not a positive integer. * Optimize for performance to handle reasonably large values of `length`.","solution":"def triangular_numbers(length: int) -> list[int]: Returns a list of the first \'length\' triangular numbers. Parameters: length (int): The number of triangular numbers to generate. Returns: list[int]: A list containing the first \'length\' triangular numbers. Raises: ValueError: If \'length\' is not a positive integer. if not isinstance(length, int) or length <= 0: raise ValueError(\\"Input should be a positive integer\\") result = [] for n in range(length): t_n = n * (n + 1) // 2 result.append(t_n) return result"},{"question":"# Problem Statement Implement a function `run_length_encoding` that takes a string as input and returns its run-length encoded version. The run-length encoding involves replacing consecutive identical characters with the character followed by the count of consecutive occurrences. # Function Signature ```python def run_length_encoding(s: str) -> str: pass ``` # Input: - `s` (str): A string containing only alphanumeric characters (both uppercase and lowercase) without any spaces. # Output: - A string representing the run-length encoded version of the input string. # Constraints: - The input string\'s length will not exceed 10^4. - Runs of identical characters are case-sensitive (e.g., \\"aaA\\" is different from \\"AAA\\"). # Examples: ```python >>> run_length_encoding(\\"aaabbc\\") \'a3b2c1\' >>> run_length_encoding(\\"abcd\\") \'a1b1c1d1\' >>> run_length_encoding(\\"aAaaBBBb\\") \'a1A1a2B3b1\' >>> run_length_encoding(\\"\\") \'\' >>> run_length_encoding(\\"zzzzz\\") \'z5\' ``` # Notes: - If a character appears only once consecutively, it should still be followed by \\"1\\" (e.g., \\"a1\\"). - You may assume the input string is always valid and contains only alphanumeric characters without spaces.","solution":"def run_length_encoding(s: str) -> str: if not s: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str.append(s[i - 1] + str(count)) count = 1 encoded_str.append(s[-1] + str(count)) # Add the last run return \\"\\".join(encoded_str)"},{"question":"# Problem Description You are given a sorted linked list consisting of distinct integers. Write a function to create a balanced binary search tree (BST) from this sorted linked list. # Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def sortedListToBST(head: ListNode) -> TreeNode: ``` # Input * `head` (`ListNode`): A ListNode object representing the head of the singly-linked list sorted in ascending order containing distinct integers. # Output * `TreeNode`: The root of the balanced binary search tree. # Constraints * The length of the linked list, `n`, will be in the range [0, 10^5]. * The value of each node will be in the range [-10^4, 10^4]. # Performance Requirements * The solution must handle up to 100,000 nodes efficiently. * Aim to achieve a time complexity of O(n), where n is the number of nodes in the linked list. # Example Cases Example 1: ```python # Sorted linked list: 1 -> 2 -> 3 -> 4 -> 5 input_head = ListNode(1) input_head.next = ListNode(2) input_head.next.next = ListNode(3) input_head.next.next.next = ListNode(4) input_head.next.next.next.next = ListNode(5) output = sortedListToBST(input_head) # The balanced BST: # 3 # / # 2 5 # / / # 1 4 ``` Example 2: ```python # Sorted linked list: -10 -> -3 -> 0 -> 5 -> 9 input_head = ListNode(-10) input_head.next = ListNode(-3) input_head.next.next = ListNode(0) input_head.next.next.next = ListNode(5) input_head.next.next.next.next = ListNode(9) output = sortedListToBST(input_head) # The balanced BST: # 0 # / # -10 5 # # -3 9 ``` Example 3: ```python # Sorted linked list: input_head = None output = sortedListToBST(input_head) # The balanced BST: # None ``` # Additional Information 1. Your code should ensure that the tree height is as balanced as possible (minimized). 2. Consider converting the linked list to an array first, or use a two-pointer technique to determine the middle node efficiently.","solution":"class ListNode: def __init__(self, x: int): self.val = x self.next = None class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def sortedListToBST(head: ListNode) -> TreeNode: def find_size(head: ListNode) -> int: ptr, c = head, 0 while ptr: ptr = ptr.next c += 1 return c def convert_list_to_bst(left: int, right: int) -> TreeNode: nonlocal head if left > right: return None mid = (left + right) // 2 left_child = convert_list_to_bst(left, mid - 1) node = TreeNode(head.val) node.left = left_child head = head.next node.right = convert_list_to_bst(mid + 1, right) return node size = find_size(head) return convert_list_to_bst(0, size - 1)"},{"question":"# Question: Implementing a Custom Priority Queue In this task, you are required to implement a custom priority queue (min-heap) class. This class must provide the usual functionalities of a priority queue, including insertion, extraction of the minimum element, and updating the priority of elements already present in the queue. You will need to pay close attention to maintaining the heap property during these operations. Requirements: 1. **Class Definition**: Implement a class `PriorityQueue`, providing the following methods: - `__init__(self)`: Initializes an empty priority queue. - `insert(self, item: Any, priority: int)`: Inserts a new item with a given priority. - `extract_min(self) -> tuple`: Removes and returns the item with the lowest priority. - `decrease_priority(self, item: Any, new_priority: int)`: Decreases the priority of a given item. 2. **Input and Output Formats**: - **Methods**: * `insert(item: Any, priority: int)`: - Input: - `item` could be any data type. - `priority` should be an integer. * `extract_min() -> tuple`: - Output: - A tuple `(item, priority)`, where `item` is the item with the minimum priority. * `decrease_priority(item: Any, new_priority: int)`: - Input: - `item` could be any data type. - `new_priority` should be an integer less than or equal to the current priority of the item. 3. **Constraints**: - Maintain the heap property after every operation. - The implementation should handle cases where operations like `decrease_priority` are performed on items not present in the queue gracefully. 4. **Performance**: - Ensure heap operations (`insert`, `extract_min`, and `decrease_priority`) are efficient. ```python from typing import Any, List, Tuple class PriorityQueue: def __init__(self) -> None: Initializes an empty priority queue. self.heap: List[Tuple[int, Any]] = [] def insert(self, item: Any, priority: int) -> None: Inserts an item with a given priority into the priority queue. # Your code here pass def extract_min(self) -> Tuple[Any, int]: Removes and returns the item with the minimum priority. # Your code here pass def decrease_priority(self, item: Any, new_priority: int) -> None: Decreases the priority of a given item. # Your code here pass # Example usage: pq = PriorityQueue() pq.insert(\\"task1\\", 5) pq.insert(\\"task2\\", 3) pq.decrease_priority(\\"task1\\", 2) item = pq.extract_min() print(item) # Output should be (\\"task1\\", 2) since its priority was decreased before extraction ``` **Scenarios to Consider**: * Attempting to `decrease_priority` of an item not present in the queue. * Ensuring the heap property is maintained after each insertion and extraction. * Handling ties when two elements have the same priority. Write your solution and test the implementation with various edge cases to ensure correctness and efficiency.","solution":"from typing import Any, List, Tuple import heapq class PriorityQueue: def __init__(self) -> None: Initializes an empty priority queue. self.heap: List[Tuple[int, int, Any]] = [] self.entry_finder = {} self.counter = 0 def insert(self, item: Any, priority: int) -> None: Inserts an item with a given priority into the priority queue. if item in self.entry_finder: self.decrease_priority(item, priority) return count = self.counter entry = [priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def extract_min(self) -> Tuple[Any, int]: Removes and returns the item with the minimum priority. while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not None: del self.entry_finder[item] return (item, priority) raise KeyError(\\"pop from an empty priority queue\\") def decrease_priority(self, item: Any, new_priority: int) -> None: Decreases the priority of a given item. if item not in self.entry_finder: return entry = self.entry_finder.pop(item) entry[-1] = None # Mark the existing entry as removed self.insert(item, new_priority)"},{"question":"# Coding Assessment Question: **Objective**: Create a customized implementation of a Caesar Cipher that includes functionality for both encryption and decryption with an additional challenge of randomly shifting individual characters by different values. **Instructions**: Implement a `AdvancedCaesarCipher` class with the following methods: 1. `__init__(self, seed: int)`: Initialize the class with a seed for the random number generator to ensure reproducibility. 2. `encrypt(self, plaintext: str) -> str`: Encrypt a given plaintext where each character is shifted by a random value. Non-alpha characters should remain unchanged. 3. `decrypt(self, ciphertext: str) -> str`: Decrypt the given ciphertext back to the original plaintext by reversing the random shifts applied during encryption. **Constraints**: * The message length can be from 0 up to 1000 characters. * Both lowercase and uppercase alphabetic characters should be shifted within their respective ranges (i.e., \'a\'-\'z\' and \'A\'-\'Z\'), non-alpha characters should remain unchanged. * Use the provided seed to generate a reproducible sequence of random shifts. * Preserve the input message\'s case. **Example**: ```python cipher = AdvancedCaesarCipher(seed=42) encrypted_message = cipher.encrypt(\\"Hello World!\\") print(encrypted_message) # Example output: \\"Ifmmp Xpsme!\\" decrypted_message = cipher.decrypt(encrypted_message) print(decrypted_message) # Expected output: \\"Hello World!\\" ``` **Detailed Requirements**: * Random character shifts should be within the range [1, 25]. * The random shifts should be stored and reused for decryption to ensure the original message can be correctly restored. * Ensure the encryption process handles each individual character with its unique shift. Good luck!","solution":"import random import string class AdvancedCaesarCipher: def __init__(self, seed: int): self.seed = seed random.seed(self.seed) def _shift_char(self, char, shift, encrypt=True): if char in string.ascii_lowercase: start = ord(\'a\') offset = 26 elif char in string.ascii_uppercase: start = ord(\'A\') offset = 26 else: return char shift = shift if encrypt else -shift return chr((ord(char) - start + shift) % offset + start) def encrypt(self, plaintext: str) -> str: self.shifts = [random.randint(1, 25) for _ in plaintext] ciphertext = [] for char, shift in zip(plaintext, self.shifts): ciphertext.append(self._shift_char(char, shift)) return \'\'.join(ciphertext) def decrypt(self, ciphertext: str) -> str: assert len(ciphertext) == len(self.shifts), \\"Ciphertext length doesn\'t match the shift length\\" plaintext = [] for char, shift in zip(ciphertext, self.shifts): plaintext.append(self._shift_char(char, shift, encrypt=False)) return \'\'.join(plaintext)"},{"question":"# Coding Challenge: Circular String Shift Background: A common string manipulation task in programming is shifting the characters of a string circularly either to the left or right. For instance, shifting the string \\"abcd\\" to the right by 1 results in \\"dabc\\", while shifting it to the left by 1 results in \\"bcda\\". Task: Implement a function `circular_shift` that takes a string and shifts its characters circularly to the left or right by a given number of positions. Function Signature: ```python def circular_shift(s: str, shifts: int, direction: str) -> str: pass ``` Input: * A string `s` (1 <= len(s) <= 100) representing the original string. * An integer `shifts` (0 <= shifts <= 1000) representing the number of positions to shift. * A string `direction` which shall be either `\'left\'` or `\'right\'`, indicating the direction of the shift. Output: * A string representing the modified string after applying the circular shift. Constraints: * It is guaranteed that `s` contains only lowercase English letters. Example: ```python assert circular_shift(\\"abcdef\\", 2, \\"left\\") == \\"cdefab\\" assert circular_shift(\\"abcdef\\", 3, \\"right\\") == \\"defabc\\" assert circular_shift(\\"crazy\\", 7, \\"right\\") == \\"azycr\\" assert circular_shift(\\"hello\\", 15, \\"left\\") == \\"lohel\\" ``` **Note**: The number of shifts will wrap around the length of the string because of the circular nature. For instance, shifting \\"abcdef\\" 8 times to the left is the same as shifting it 2 times to the left.","solution":"def circular_shift(s: str, shifts: int, direction: str) -> str: Shifts the characters of the string `s` circularly to the left or right by the given number of positions. :param s: The original string :param shifts: Number of positions to shift :param direction: Direction to shift (\'left\' or \'right\') :return: The shifted string n = len(s) # Normalize shifts value to be within 0 and n-1 shifts = shifts % n if direction == \'left\': return s[shifts:] + s[:shifts] elif direction == \'right\': return s[-shifts:] + s[:-shifts] else: raise ValueError(\\"Direction must be either \'left\' or \'right\'\\")"},{"question":"# Implement a Thread-safe Bounded Queue Problem Description: You are tasked with implementing a thread-safe bounded queue that supports basic operations with an upper limit on the number of items it can contain. The queue should allow multiple producer threads to add items and multiple consumer threads to remove items concurrently. You need to ensure that the queue operates correctly under concurrent access, with appropriate blocking and waiting when the queue is full or empty. Function Signatures: ```python class BoundedQueue: def __init__(self, capacity: int): Initialize the bounded queue with a given capacity. Args: - capacity (int): The maximum number of items the queue can hold. pass def enqueue(self, item: Any) -> None: Add an item to the end of the queue. Block if the queue is full. Args: - item (Any): The item to be added to the queue. pass def dequeue(self) -> Any: Remove and return an item from the front of the queue. Block if the queue is empty. Returns: - Any: The item removed from the front of the queue. pass ``` Input: - For `BoundedQueue.__init__`: - `capacity`: An integer representing the maximum number of items the queue can hold. - For `BoundedQueue.enqueue`: - `item`: The item to be added to the queue. - For `BoundedQueue.dequeue`: - This method does not take any arguments. Output: - For `BoundedQueue.__init__`: This method initializes the queue and does not return a value. - For `BoundedQueue.enqueue`: This method does not return a value but blocks if the queue is full until space becomes available. - For `BoundedQueue.dequeue`: This method returns the item removed from the front of the queue and blocks if the queue is empty until an item becomes available. Constraints: - The queue capacity must be a positive integer. - The queue must be implemented using appropriate synchronization mechanisms to ensure thread safety. - The enqueue operation must block if the queue is full. - The dequeue operation must block if the queue is empty. Performance Requirements: - The operations should be efficient and minimize the use of locks to avoid performance bottlenecks. - The implementation should handle high-concurrency scenarios gracefully. Example: ```python from threading import Thread import time import random def producer(queue, id): for i in range(10): item = f\'item{id}-{i}\' print(f\\"Producer {id} enqueueing: {item}\\") queue.enqueue(item) time.sleep(random.uniform(0.1, 0.5)) def consumer(queue, id): for i in range(10): item = queue.dequeue() print(f\\"Consumer {id} dequeueing: {item}\\") time.sleep(random.uniform(0.1, 0.5)) queue = BoundedQueue(capacity=5) producers = [Thread(target=producer, args=(queue, i)) for i in range(3)] consumers = [Thread(target=consumer, args=(queue, i)) for i in range(3)] for p in producers: p.start() for c in consumers: c.start() for p in producers: p.join() for c in consumers: c.join() ``` --- The question above aligns with the original set in terms of style, complexity, and scope by addressing thread safety in a concurrent programming scenario, which is a common and significant concept in computer science.","solution":"from threading import Lock, Condition from typing import Any class BoundedQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [] self.lock = Lock() self.not_full = Condition(self.lock) self.not_empty = Condition(self.lock) def enqueue(self, item: Any) -> None: with self.not_full: while len(self.queue) >= self.capacity: self.not_full.wait() self.queue.append(item) self.not_empty.notify() def dequeue(self) -> Any: with self.not_empty: while len(self.queue) == 0: self.not_empty.wait() item = self.queue.pop(0) self.not_full.notify() return item"},{"question":"# Question: Efficiently Manipulate Large Matrices for Data Analysis As part of a data analysis exercise, you have to perform operations on large matrices. You must implement two functions to handle specific matrix operations efficiently. Steps to Follow: 1. Write a function `find_max_in_submatrix(matrix: List[List[int]], top_row: int, left_col: int, bottom_row: int, right_col: int) -> int` that finds the maximum element in the submatrix defined by the given top-left and bottom-right corners. * The `matrix` parameter represents a 2D list of integers. * The `(top_row, left_col)` and `(bottom_row, right_col)` parameters specify the boundaries of the submatrix, inclusive. 2. Write a function `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` that rotates the entire matrix 90 degrees clockwise. * The `matrix` parameter represents a 2D list of integers. * The function should return a new 2D list representing the rotated matrix. Input & Output: * **Input**: * `find_max_in_submatrix` takes a 2D list of integers and four integers representing the top-left and bottom-right corners of the submatrix. * `rotate_clockwise` takes a 2D list of integers. * **Output**: * `find_max_in_submatrix` returns a single integer, the maximum value within the specified submatrix. * `rotate_clockwise` returns a new 2D list, the rotated matrix. Constraints: * The input matrix for both functions will be non-empty and rectangular. * Submatrix boundaries will always define a valid submatrix within the dimensions of `matrix`. Examples: ```python >>> matrix = [ [5, 3, 8, 6], [7, 2, 1, 0], [4, 9, 3, 8], [6, 1, 5, 2] ] >>> find_max_in_submatrix(matrix, 1, 1, 3, 3) 9 # submatrix is [[2, 1, 0], [9, 3, 8], [1, 5, 2]] >>> find_max_in_submatrix(matrix, 0, 2, 2, 3) 8 # submatrix is [[8, 6], [1, 0], [3, 8]] >>> rotate_clockwise(matrix) [ [6, 4, 7, 5], [1, 9, 2, 3], [5, 3, 1, 8], [2, 8, 0, 6] ] >>> rotate_clockwise([[1, 2], [3, 4]]) [ [3, 1], [4, 2] ] ``` Implement the functions meeting the above specifications.","solution":"from typing import List def find_max_in_submatrix(matrix: List[List[int]], top_row: int, left_col: int, bottom_row: int, right_col: int) -> int: Finds the maximum element in the submatrix defined by the given top-left and bottom-right corners. max_value = float(\'-inf\') for r in range(top_row, bottom_row + 1): for c in range(left_col, right_col + 1): if matrix[r][c] > max_value: max_value = matrix[r][c] return max_value def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the entire matrix 90 degrees clockwise and returns the new matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[c][rows - 1 - r] = matrix[r][c] return rotated"},{"question":"**Context**: You are working on a networking module for a distributed system, which needs to ensure that data packets are transmitted in the correct order over multiple nodes. One key requirement is to verify that the intermediate nodes are correctly relaying packets in sequential order without any mismatches or duplicates. **Task**: Write a function `is_valid_sequence` that takes a list of packets (represented as positive integers) received by a node and determines if the packets are in a valid consecutive sequence without any duplicates or missing numbers. # Function Signature ```python def is_valid_sequence(packets: List[int]) -> bool: pass ``` # Input * `packets`: A list of positive integers representing received data packets. # Output * Returns `True` if the packets form a valid consecutive sequence without duplicates, otherwise `False`. # Constraints * 0 ≤ len(packets) ≤ 10^6 * 1 ≤ packets[i] ≤ 10^9 # Performance Requirement * The implementation should have a time complexity of (O(n)) and space complexity of (O(n)). # Example ```python assert is_valid_sequence([1, 2, 3, 4, 5]) == True assert is_valid_sequence([3, 1, 2, 5, 4]) == True assert is_valid_sequence([1, 2, 2, 4, 5]) == False assert is_valid_sequence([1, 2, 4, 5]) == False assert is_valid_sequence([]) == True assert is_valid_sequence([7]) == True ``` Implement the `is_valid_sequence` function such that it efficiently checks if the packets received form a valid consecutive sequence without any duplicates.","solution":"from typing import List def is_valid_sequence(packets: List[int]) -> bool: if not packets: return True min_packet = min(packets) max_packet = max(packets) if len(packets) != (max_packet - min_packet + 1): return False packet_set = set(packets) return len(packet_set) == len(packets)"},{"question":"# Problem Statement You are given an integer array `arr` and an integer `k`. Write a function `find_closest_elements(arr: List[int], k: int, x: int) -> List[int]` that returns the `k` closest integers to `x` in the array. The result should be sorted in ascending order. # Function Signature ```python def find_closest_elements(arr: List[int], k: int, x: int) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers sorted in non-decreasing order. * `k` (int): The number of closest integers to find. * `x` (int): The target integer. # Output * (List[int]): A list of the `k` closest integers to `x` in sorted order. # Constraints * The length of the array `arr` will be between 1 and 10^4. * `k` will be a positive integer such that `1 <= k <= arr.length`. * `x` will be a valid integer. # Examples ```python >>> find_closest_elements([1,2,3,4,5], 4, 3) [1, 2, 3, 4] >>> find_closest_elements([1,2,3,4,5], 4, -1) [1, 2, 3, 4] >>> find_closest_elements([1,2,3,4,5], 2, 6) [4, 5] ``` # Implementation Requirements * Design the solution to be efficient with a time complexity not worse than O(n log n). * Use binary search to find the starting point of the closest elements. * Ensure that the final output list is sorted in ascending order.","solution":"from typing import List def find_closest_elements(arr: List[int], k: int, x: int) -> List[int]: def binary_search(arr, x): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] < x: left = mid + 1 else: right = mid - 1 return left index = binary_search(arr, x) left, right = index - 1, index while k > 0: if left < 0: right += 1 elif right >= len(arr) or (left >= 0 and abs(arr[left] - x) <= abs(arr[right] - x)): left -= 1 else: right += 1 k -= 1 return sorted(arr[left + 1:right])"},{"question":"# Problem Statement You are given a binary search tree (BST) represented by a nested dictionary, where each node contains a value and possibly a left and/or right subtree. Your task is to write a function `find_kth_smallest` that finds the k-th smallest element in the BST. # Input * `bst`: a nested dictionary representing the binary search tree. Each node is represented as `{ \\"value\\": int, \\"left\\": Optional[dict], \\"right\\": Optional[dict] }`. * `k`: an integer representing the order of the smallest element to find (1-based index). # Output The function should return an integer representing the k-th smallest element in the BST. # Constraints * The BST will have at least 1 and at most 1000 nodes. * All node values are unique integers between -10^6 and 10^6. * 1 <= k <= number of nodes in the BST. # Example ```python def find_kth_smallest(bst, k): # Your implementation here test_bst = { \\"value\\": 5, \\"left\\": { \\"value\\": 3, \\"left\\": { \\"value\\": 2, \\"left\\": { \\"value\\": 1, \\"left\\": None, \\"right\\": None }, \\"right\\": None }, \\"right\\": { \\"value\\": 4, \\"left\\": None, \\"right\\": None } }, \\"right\\": { \\"value\\": 7, \\"left\\": { \\"value\\": 6, \\"left\\": None, \\"right\\": None }, \\"right\\": { \\"value\\": 8, \\"left\\": None, \\"right\\": None } } } k = 3 print(find_kth_smallest(test_bst, k)) # Expected output: 3 ``` # Scenario Imagine a database system that maintains an index in the form of a binary search tree to optimize queries. You are required to retrieve the k-th smallest entry (e.g., timestamp, user ID) efficiently.","solution":"def find_kth_smallest(bst, k): Finds the k-th smallest element in a BST. def in_order_traversal(node): if not node: return [] return in_order_traversal(node[\\"left\\"]) + [node[\\"value\\"]] + in_order_traversal(node[\\"right\\"]) in_order = in_order_traversal(bst) return in_order[k - 1]"},{"question":"# Coding Assessment Question Write a Python program that simulates a basic shopping cart system. Your task is to implement a class `ShoppingCart` that encapsulates the following functionalities: 1. Adding items to the cart. 2. Removing items from the cart. 3. Viewing all items in the cart. 4. Calculating the total cost of the cart. 5. Applying a discount to the total cost. Each item added to the shopping cart is represented as a dictionary with keys `name` (str), `price` (float), and `quantity` (int). Class Signature ```python class ShoppingCart: def __init__(self): pass def add_item(self, name: str, price: float, quantity: int): pass def remove_item(self, name: str): pass def view_cart(self) -> list: pass def calculate_total(self) -> float: pass def apply_discount(self, discount: float): pass ``` Method Specifications: - **add_item(name, price, quantity)**: Adds an item to the cart. If the item already exists, increase its quantity. - **remove_item(name)**: Removes an item from the cart by name. If the item does not exist, raise an exception. - **view_cart()**: Returns a list of items in the cart, where each item is represented as the dictionary described above. - **calculate_total()**: Returns the total cost of the cart as a float. - **apply_discount(discount)**: Applies a discount to the total cost. The discount is a percentage represented as a float (e.g., for 10%, discount = 0.10). Example Usage: ```python cart = ShoppingCart() cart.add_item(\\"apple\\", 0.99, 3) cart.add_item(\\"banana\\", 1.29, 2) cart.add_item(\\"orange\\", 1.50, 1) print(cart.view_cart()) # [{\'name\': \'apple\', \'price\': 0.99, \'quantity\': 3}, {\'name\': \'banana\', \'price\': 1.29, \'quantity\': 2}, {\'name\': \'orange\', \'price\': 1.5, \'quantity\': 1}] print(cart.calculate_total()) # 6.05 cart.apply_discount(0.10) print(cart.calculate_total()) # 5.445 cart.remove_item(\\"banana\\") print(cart.view_cart()) # [{\'name\': \'apple\', \'price\': 0.99, \'quantity\': 3}, {\'name\': \'orange\', \'price\': 1.5, \'quantity\': 1}] ``` Constraints: - Price and quantity of items should always be positive numbers. - When applying a discount, ensure that it does not result in a negative total. - Handle possible erroneous removals by raising appropriate exceptions. By completing this implementation, you should demonstrate an understanding of object-oriented programming principles, collection manipulations, and basic error handling in Python.","solution":"class ShoppingCart: def __init__(self): self.items = [] self.total = 0.0 def add_item(self, name: str, price: float, quantity: int): if price < 0 or quantity < 0: raise ValueError(\\"Price and quantity must be positive numbers.\\") for item in self.items: if item[\'name\'] == name: item[\'price\'] = price # update the price in case it has changed item[\'quantity\'] += quantity return self.items.append({\'name\': name, \'price\': price, \'quantity\': quantity}) def remove_item(self, name: str): for item in self.items: if item[\'name\'] == name: self.items.remove(item) return raise ValueError(\\"Item not found in the cart.\\") def view_cart(self) -> list: return self.items def calculate_total(self) -> float: self.total = sum(item[\'price\'] * item[\'quantity\'] for item in self.items) return self.total def apply_discount(self, discount: float): if discount < 0 or discount > 1: raise ValueError(\\"Discount must be between 0 and 1.\\") self.total *= (1 - discount) return self.total"},{"question":"# Coding Assessment Question Balanced Parentheses Checker with Dynamic Programming You are a software engineer working on a code editor and need to implement a feature that checks whether the parentheses in a given string are balanced. Parentheses are considered balanced when each opening parenthesis has a corresponding closing parenthesis in the correct order. # Problem Statement Implement a function `is_balanced_parens` in Python to determine whether a given string containing parentheses is balanced using a dynamic programming approach. The function should return `True` if the parentheses are balanced and `False` otherwise. # Input Your function will take a single string as an input which consists only of the characters `\'(\'` and `\')\'`. For example: ``` (()()) )()( ((()) ``` # Function Signature ```python def is_balanced_parens(s: str) -> bool: pass ``` # Output * Returns a boolean value: * `True` if the input string has balanced parentheses. * `False` otherwise. # Constraints * The length of the input string does not exceed 10^5. * Avoid using stack-based approaches. Instead, solve the problem using dynamic programming. # Performance Requirements * The solution should efficiently handle strings up to the maximum length constraint. * The time complexity should be O(n) for an input string of length n. # Example For input string `\\"(()())\\"`, the function `is_balanced_parens(\\"(()())\\")` should return `True`. For input string `\\")()(\\"`, the function `is_balanced_parens(\\")()(\\")` should return `False`. For input string `\\"((())\\"`, the function `is_balanced_parens(\\"((())\\")` should return `False`. # Additional Instructions * Do not use any collections-based implementations such as stacks or queues. * Document your code with comments explaining the key parts. * You are encouraged to write helper functions to break down different parts of the algorithm (e.g., tracking open and close parentheses count).","solution":"def is_balanced_parens(s: str) -> bool: Function to determine if parentheses in a string are balanced using dynamic programming approach. # Counters for open and close parentheses open_count = 0 for char in s: if char == \'(\': open_count += 1 else: # char == \')\' open_count -= 1 # If open_count drops below zero, we have a closing parenthesis without a matching opener if open_count < 0: return False # If all open parentheses have been closed, open_count should be zero return open_count == 0"},{"question":"# Problem Statement You are required to implement a class called `StackWithMax` that extends a basic stack by adding an operation to retrieve the maximum element in constant time. This task will help you practice designing algorithms that utilize auxiliary data structures to achieve efficient results. Implement methods in the `StackWithMax` class to handle: 1. Pushing an element onto the stack. 2. Popping an element from the stack. 3. Retrieving the maximum element in the stack. 4. Checking if the stack is empty. # Function Specifications 1. **Push Function** ```python def push(self, value: int) -> None: ``` - **Input**: An integer value to be added to the stack. - **Output**: None. 2. **Pop Function** ```python def pop(self) -> int: ``` - **Input**: None. - **Output**: The integer value removed from the stack. - **Constraints**: Raises IndexError if the stack is empty. 3. **Get Max Function** ```python def get_max(self) -> int: ``` - **Input**: None. - **Output**: The maximum integer value in the stack. - **Constraints**: Raises IndexError if the stack is empty. 4. **Is Empty Function** ```python def is_empty(self) -> bool: ``` - **Input**: None. - **Output**: True if the stack is empty, False otherwise. # Examples ```python s = StackWithMax() s.push(3) s.push(5) assert s.get_max() == 5 s.push(7) s.push(2) assert s.get_max() == 7 assert s.pop() == 2 assert s.get_max() == 7 assert s.pop() == 7 assert s.get_max() == 5 assert s.pop() == 5 assert s.get_max() == 3 assert s.pop() == 3 assert s.is_empty() ``` # Notes - You should use an additional stack to keep track of maximums. - Consider how you will maintain the maximum values when pushing and popping elements. - Ensure proper error handling for edge cases.","solution":"class StackWithMax: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from an empty stack\\") value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def get_max(self) -> int: if not self.max_stack: raise IndexError(\\"max from an empty stack\\") return self.max_stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0"},{"question":"# Question Prompt Create a small library management system that includes basic functionalities for book borrowing and returning, tracking overdue books, and issuing fines for overdue returns. 1. **Book Borrowing and Returning**: Implement methods to borrow and return books. 2. **Overdue Tracking and Fines**: Track overdue books and calculate fines based on a daily fine rate if a book is returned late. Expected Input and Output - **Methods**: - `borrow_book(member_id: int, book_id: int, borrow_date: str)` — Borrow a book on a specified date. - `return_book(member_id: int, book_id: int, return_date: str)` — Return a borrowed book on a specified date. - `calculate_fines(member_id: int, current_date: str)` — Calculate the total fines for a member based on the current date. - **Output**: - Borrow and return methods should update the internal state of the system. - Fines should be returned as a dictionary in the format `{\\"overdue_books\\": int, \\"total_fines\\": float}`. Constraints and Limitations - Assume dates are given in the format \\"YYYY-MM-DD\\". - Fines are calculated with a daily rate of 1 per day overdue. - The system should handle up to 1000 members and 5000 books. - Performance should be sufficient to allow quick updates and calculations even when close to maximum capacity. ```python from datetime import datetime, timedelta class Library: def __init__(self, daily_fine_rate: float = 1.0): self.daily_fine_rate = daily_fine_rate self.books = {} # Mapping of book_id to (member_id, borrow_date) self.members = {} # Mapping of member_id to list of borrowed book_ids def borrow_book(self, member_id: int, book_id: int, borrow_date: str): Borrow a book by a member on a specified date. # Implement borrowing logic def return_book(self, member_id: int, book_id: int, return_date: str): Return a borrowed book by a member on a specified date. # Implement returning logic def calculate_fines(self, member_id: int, current_date: str): Calculate total fines for a member based on the current date. # Implement fine calculation logic def book_is_borrowed(self, book_id: int): Check if a book is currently borrowed. # Implement book checking logic return book_id in self.books ``` Objectives: 1. Implement the `borrow_book` method to record the borrowing of a book. 2. Implement the `return_book` method to update records when a book is returned. 3. Implement the `calculate_fines` method to determine the number of overdue books and total fines for a member. 4. Ensure proper state management within the library system to track book borrowings and returns. **Hint**: Use Python\'s `datetime` module to handle dates and calculate overdue days. (Note: The instructor should add specific test cases, examples, and edge conditions to guide students during the assessment.)","solution":"from datetime import datetime class Library: def __init__(self, daily_fine_rate: float = 1.0): self.daily_fine_rate = daily_fine_rate self.books = {} # Mapping of book_id to (member_id, borrow_date) self.members = {} # Mapping of member_id to list of borrowed book_ids def borrow_book(self, member_id: int, book_id: int, borrow_date: str): Borrow a book by a member on a specified date. if book_id in self.books: raise ValueError(f\\"Book {book_id} is already borrowed.\\") self.books[book_id] = (member_id, borrow_date) if member_id not in self.members: self.members[member_id] = [] self.members[member_id].append(book_id) def return_book(self, member_id: int, book_id: int, return_date: str): Return a borrowed book by a member on a specified date. if book_id not in self.books: raise ValueError(f\\"Book {book_id} was not borrowed.\\") record = self.books.pop(book_id) if record[0] != member_id: raise ValueError(f\\"Book {book_id} was not borrowed by member {member_id}.\\") if member_id in self.members: self.members[member_id].remove(book_id) def calculate_fines(self, member_id: int, current_date: str): Calculate total fines for a member based on the current date. if member_id not in self.members: return {\\"overdue_books\\": 0, \\"total_fines\\": 0.0} current_datetime = datetime.strptime(current_date, \\"%Y-%m-%d\\") total_fines = 0 overdue_books = 0 for book_id in self.members[member_id]: borrow_date = datetime.strptime(self.books[book_id][1], \\"%Y-%m-%d\\") overdue_days = (current_datetime - borrow_date).days - 14 # Assuming 14 days borrow period if overdue_days > 0: overdue_books += 1 total_fines += overdue_days * self.daily_fine_rate return {\\"overdue_books\\": overdue_books, \\"total_fines\\": total_fines} def book_is_borrowed(self, book_id: int): Check if a book is currently borrowed. return book_id in self.books"},{"question":"# Coding Assessment: Implement a Simple Inventory Management System Context You are developing a basic inventory management system that tracks a store\'s products, their quantities, and prices. The system should be able to handle adding new products, updating existing ones, removing products, and displaying the inventory in a formatted table. Requirements Implement the following functions: 1. **add_product(inventory: dict, product_id: int, product_name: str, quantity: int, price: float)**: * Adds a new product to the inventory. If the product already exists, it should update the quantity and price. 2. **remove_product(inventory: dict, product_id: int)**: * Removes a product from the inventory based on its product ID. 3. **update_product(inventory: dict, product_id: int, quantity: int = None, price: float = None)**: * Updates the quantity and/or price of an existing product. 4. **display_inventory(inventory: dict)**: * Displays the current inventory in a formatted table, including Product ID, Name, Quantity, and Price. Input * You will be provided with an inventory dictionary and a series of function calls to manage the inventory. * Example: ```python inventory = {} add_product(inventory, 1, \\"Apple\\", 50, 0.5) add_product(inventory, 2, \\"Banana\\", 100, 0.3) ``` Output * The functions should print the inventory in a formatted table, including: * Product ID, Name, Quantity, and Price for each product. * Example output for the display function: ```python Product ID Product Name Quantity Price 1 Apple 50 0.5 2 Banana 100 0.3 ``` Example ```python # Example provided inputs: inventory = {} add_product(inventory, 1, \\"Apple\\", 50, 0.5) add_product(inventory, 2, \\"Banana\\", 100, 0.3) update_product(inventory, 1, price=0.55) remove_product(inventory, 2) display_inventory(inventory) # Expected Output: Product ID Product Name Quantity Price 1 Apple 50 0.55 ``` Ensure your implementation handles possible edge cases, such as removing a non-existing product or updating with invalid data.","solution":"def add_product(inventory, product_id, product_name, quantity, price): Adds a new product to the inventory. If the product already exists, it updates the existing product\'s quantity and price. if product_id in inventory: # Update the existing product\'s quantity and price inventory[product_id][\'quantity\'] = quantity inventory[product_id][\'price\'] = price else: # Add new product inventory[product_id] = { \'name\': product_name, \'quantity\': quantity, \'price\': price } def remove_product(inventory, product_id): Removes a product from the inventory based on its product ID. If the product does not exist, it does nothing. if product_id in inventory: del inventory[product_id] def update_product(inventory, product_id, quantity=None, price=None): Updates the quantity and/or price of an existing product. if product_id in inventory: if quantity is not None: inventory[product_id][\'quantity\'] = quantity if price is not None: inventory[product_id][\'price\'] = price def display_inventory(inventory): Displays the current inventory in a formatted table. print(f\\"{\'Product ID\':<12} {\'Product Name\':<15} {\'Quantity\':<10} {\'Price\':<6}\\") for product_id, details in inventory.items(): name = details[\'name\'] quantity = details[\'quantity\'] price = details[\'price\'] print(f\\"{product_id:<12} {name:<15} {quantity:<10} {price:<6}\\")"},{"question":"# Coding Assessment Question Context: Sorting algorithms are fundamental tools in computer science and are crucial for optimizing the performance of various applications. Among them, quicksort is widely appreciated for its efficiency and simplicity. Problem Statement: Implement the quicksort algorithm to sort an array of integers in ascending order. Your implementation should be in-place and utilize the last element of the array as the pivot. Guidelines: 1. Write a function `quicksort` that sorts an array using the quicksort algorithm. 2. The partition function should place the pivot element in its correct position in the sorted array and place all elements smaller than the pivot to the left and all greater elements to the right. 3. The implementation must be in-place, meaning you should not use additional arrays or data structures. Input Format: - A single list of integers `arr` which can have both positive and negative numbers. Output Format: - The original list `arr` sorted in ascending order. Example: Input: ```python arr = [10, 7, 8, 9, 1, 5] ``` Output: ```python [1, 5, 7, 8, 9, 10] ``` Constraints: - The list `arr` can have up to (10^5) elements. - Elements in `arr` are within the range of (-10^6) to (10^6). Function Signature: ```python def quicksort(arr: List[int]) -> None: pass ``` Performance Requirements: - The solution should efficiently sort the array, considering both average and worst-case runtime complexities of the quicksort algorithm.","solution":"from typing import List def quicksort(arr: List[int]) -> None: Sorts the input list using the quicksort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: None: The list is sorted in place. def partition(low, high): # Use the last element as the pivot pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] # Place the pivot in the correct position arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_helper(low, high): if low < high: pi = partition(low, high) quicksort_helper(low, pi - 1) quicksort_helper(pi + 1, high) quicksort_helper(0, len(arr) - 1)"},{"question":"# Coding Question **Context**: You are developing a web application that requires an in-memory key-value store with time-to-live (TTL) functionality for caching purposes. The store should automatically remove expired entries to free up memory. **Task**: Implement an `InMemoryCache` class that supports storing key-value pairs with optional TTL. The class should provide methods to set, get, and delete entries, and automatically remove expired entries. **Class Specification**: ```python from typing import Any, Optional import time import threading class InMemoryCache: def __init__(self): Initialize the in-memory cache. self.cache = {} self.lock = threading.Lock() def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None: Store a key-value pair in the cache. If ttl is provided, the entry will expire after ttl seconds. Parameters: - key (str): The key under which the value will be stored. - value (Any): The value to be stored. - ttl (Optional[int]): Time-to-live in seconds (default is None, which means no expiry). Returns: - None pass def get(self, key: str) -> Optional[Any]: Retrieve the value associated with the given key if it exists and has not expired. Parameters: - key (str): The key to lookup. Returns: - The value associated with the key, or None if the key does not exist or has expired. pass def delete(self, key: str) -> None: Delete the entry associated with the given key. Parameters: - key (str): The key to delete. Returns: - None pass def _remove_expired_entries(self): Internal method to remove expired entries from the cache. Returns: - None pass ``` **Constraints**: * Ensure thread safety when accessing or modifying the cache. * Use Python\'s `threading` module to handle the locking mechanism. * Automatically remove expired entries using a background cleanup task. * TTL is optional, and the default behavior should be to keep entries indefinitely if TTL is not specified. **Example Usage**: ```python cache = InMemoryCache() # Set a key \\"foo\\" with value \\"bar\\" and TTL of 5 seconds cache.set(\\"foo\\", \\"bar\\", ttl=5) # Retrieve the value immediately print(cache.get(\\"foo\\")) # Expected output: \\"bar\\" # Wait for 6 seconds and try to retrieve the value again time.sleep(6) print(cache.get(\\"foo\\")) # Expected output: None # Set a key \\"hello\\" with value \\"world\\" without TTL cache.set(\\"hello\\", \\"world\\") print(cache.get(\\"hello\\")) # Expected output: \\"world\\" # Manually delete the key cache.delete(\\"hello\\") print(cache.get(\\"hello\\")) # Expected output: None ``` **Expected Output**: There is no direct output. Ensure that: * The value is stored and retrieved correctly. * The TTL mechanism expires entries as expected. * The delete functionality removes entries.","solution":"from typing import Any, Optional import time import threading class InMemoryCache: def __init__(self): Initialize the in-memory cache. self.cache = {} self.lock = threading.Lock() self.cleanup_thread = threading.Thread(target=self._cleanup, daemon=True) self.cleanup_thread.start() def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None: Store a key-value pair in the cache. If ttl is provided, the entry will expire after ttl seconds. with self.lock: expiry = None if ttl is not None: expiry = time.time() + ttl self.cache[key] = (value, expiry) def get(self, key: str) -> Optional[Any]: Retrieve the value associated with the given key if it exists and has not expired. with self.lock: if key not in self.cache: return None value, expiry = self.cache[key] if expiry is not None and time.time() > expiry: del self.cache[key] return None return value def delete(self, key: str) -> None: Delete the entry associated with the given key. with self.lock: if key in self.cache: del self.cache[key] def _cleanup(self): Internal method to remove expired entries from the cache. while True: with self.lock: now = time.time() keys_to_delete = [] for key, (_, expiry) in self.cache.items(): if expiry is not None and now > expiry: keys_to_delete.append(key) for key in keys_to_delete: del self.cache[key] time.sleep(1)"},{"question":"# URL Shortener Implementation In this task, you will create a URL shortener system that generates unique shortened URLs for given input URLs and can retrieve the original URLs from the shortened versions. The implementation should handle edge cases such as invalid inputs and duplicate URLs effectively. **Function Signatures**: - Implement the class `class URLShortener:` - `def __init__(self):` - `def encode(self, long_url: str) -> str:` - `def decode(self, short_url: str) -> str:` # Requirements: 1. **URLShortener Class**: - Implement a class with methods to encode and decode URLs while maintaining a relationship between the long URLs and their short representations. 2. **encode(self, long_url: str) -> str**: - Accepts a full URL as a string and returns a unique shortened URL as a string. - Generates a short URL which is significantly shorter than the input long URL. - Ensures no two different long URLs end up with the same short URL. - Manages a mapping from long URLs to short URLs to prevent duplication. - Handles edge cases such as invalid URLs or very long URLs gracefully. 3. **decode(self, short_url: str) -> str**: - Accepts a shortened URL and returns the original long URL as a string. - Ensures the short URL provided is valid and can be decoded. - Handles edge cases such as non-existent short URLs or malformed input. # Constraints: - The input string for encoding will be a valid URL. - Both methods need to be designed to handle large numbers of URLs efficiently. # Example: ```python # Example URLShortener usage shortener = URLShortener() # Encoding a URL long_url = \\"https://www.example.com/some/long/path/to/resource\\" short_url = shortener.encode(long_url) assert short_url != long_url # Decoding a URL decoded_url = shortener.decode(short_url) assert decoded_url == long_url ``` # Tests: Your implementation will be tested on various cases, including but not limited to: - Encoding and decoding typical URLs. - Handling edge cases such as empty strings, invalid URLs, and URLs with various special characters. - Performance aspects with a large number of URL encodings/decodings. Make sure to cover these tests comprehensively to validate the robustness of your functions.","solution":"class URLShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base = \\"http://short.url/\\" self.counter = 0 def _generate_code(self): return str(self.counter) def encode(self, long_url: str) -> str: if long_url in self.url_to_code: return self.base + self.url_to_code[long_url] self.counter += 1 code = self._generate_code() self.url_to_code[long_url] = code self.code_to_url[code] = long_url return self.base + code def decode(self, short_url: str) -> str: code = short_url.replace(self.base, \\"\\") if code in self.code_to_url: return self.code_to_url[code] return \\"\\""},{"question":"# Problem Description You are required to implement a function `reverse_even_only` that takes a singly linked list and reverses only the even-indexed elements (0-based index) in the list while keeping the odd-indexed elements in their original positions. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_even_only(head: ListNode) -> ListNode: ``` # Input * `head`: The head of a singly linked list, where each node is an instance of `ListNode` containing non-negative integers. # Output * Return the head of the modified linked list. # Constraints 1. The linked list can contain between 0 and 1000 nodes. 2. Each node value is a non-negative integer. # Example ```python # Given the list: 1 -> 2 -> 3 -> 4 -> 5 -> NULL # Even-indexed elements are: 1, 3, 5 # Odd-indexed elements are: 2, 4 # After reversing even-indexed elements, the list becomes: 5 -> 2 -> 3 -> 4 -> 1 -> NULL head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) new_head = reverse_even_only(head) # The resulting linked list should be: 5 -> 2 -> 3 -> 4 -> 1 assert new_head.val == 5 assert new_head.next.val == 2 assert new_head.next.next.val == 3 assert new_head.next.next.next.val == 4 assert new_head.next.next.next.next.val == 1 # Given the list: 1 -> 2 -> 3 -> NULL # Even-indexed elements are: 1, 3 # Odd-indexed elements are: 2 # After reversing even-indexed elements, the list becomes: 3 -> 2 -> 1 -> NULL head = ListNode(1, ListNode(2, ListNode(3))) new_head = reverse_even_only(head) # The resulting linked list should be: 3 -> 2 -> 1 assert new_head.val == 3 assert new_head.next.val == 2 assert new_head.next.next.val == 1 ``` # Notes * Your solution should efficiently handle the specified constraints without excessive use of memory or time. * Ensure the function gracefully handles edge cases, such as an empty list or a list with only one node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_even_only(head: ListNode) -> ListNode: if not head or not head.next: return head even_values = [] current = head index = 0 # Collect even indexed values while current: if index % 2 == 0: even_values.append(current.val) index += 1 current = current.next # Reverse the collected even indexed values even_values.reverse() current = head index = 0 even_index = 0 # Reassign the reversed even indexed values back into the list while current: if index % 2 == 0: current.val = even_values[even_index] even_index += 1 index += 1 current = current.next return head"},{"question":"# Coding Assessment Question Prerequisites: Understanding of string manipulation, hashing algorithms, and data structures (specifically dictionaries). Problem Statement: Implement a function `longest_unique_substring(s: str) -> str` that returns the longest substring without repeating characters. Function Signature: ```python def longest_unique_substring(s: str) -> str: pass ``` Input: - `s`: A non-empty string of length up to 10^6 consisting of only ASCII characters. Output: - A string representing the longest substring without repeating characters. In case of multiple substrings of the same length, return the one which appears first. Requirements: 1. **Efficiency**: Your implementation should have time complexity close to O(n). 2. **Space Optimization**: Utilize optimal additional space where possible. Constraints: - Handle invalid inputs by raising appropriate Python exceptions: - If `s` is not a string, raise a `TypeError`. - If the length of `s` is 0, raise a `ValueError`. Examples: ```python assert longest_unique_substring(\'abcabcbb\') == \'abc\' # \'abc\' is the longest substring without repeating characters assert longest_unique_substring(\'bbbbb\') == \'b\' # \'b\' is the longest substring without repeating characters assert longest_unique_substring(\'pwwkew\') == \'wke\' # \'wke\' is the longest substring without repeating characters assert longest_unique_substring(\'\') == ValueError # Raise ValueError for empty string ``` Note: - Ensure to include edge-case testing. - Optimize both for readability and performance. - Unit tests are highly recommended.","solution":"def longest_unique_substring(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if len(s) == 0: raise ValueError(\\"Input string must not be empty\\") char_map = {} start = 0 max_length = 0 start_max = 0 for i, ch in enumerate(s): if ch in char_map and char_map[ch] >= start: start = char_map[ch] + 1 char_map[ch] = i if i - start + 1 > max_length: max_length = i - start + 1 start_max = start return s[start_max:start_max + max_length]"},{"question":"# Question: Minimum Path Sum in a Grid **Context**: You are given a 2D grid where each cell represents the cost of entering that cell. The task is to find the minimum cost to reach the bottom-right corner of the grid from the top-left corner. This problem is useful in finding optimal paths and cost-efficient strategies in grid-based scenarios. **Problem Statement**: Write a function named `min_path_sum` that uses dynamic programming to compute the minimum cost to reach the bottom-right corner of the grid starting from the top-left corner. **Function Signature**: ```python def min_path_sum(grid: list[list[int]]) -> int: ``` **Input**: * `grid` (list of list of int): A 2D list where each sub-list represents a row and each integer represents the cost of entering that cell. **Output**: * Returns an integer representing the minimum cost to reach the bottom-right corner of the grid. **Constraints**: * `1 <= len(grid), len(grid[0]) <= 200` * `0 <= grid[i][j] <= 100` for all valid `i, j` **Example**: ```python print(min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) # Output: 7 print(min_path_sum([[1, 2], [1, 1]])) # Output: 3 ``` **Verification**: 1. Ensure the algorithm handles edge cases, like grids with only one row or one column. 2. Verify the function manages maximum grid size within acceptable time limits. 3. Confirm the correctness by comparing multiple paths in the grid to identify the minimum path sum.","solution":"def min_path_sum(grid): Computes the minimum cost to reach the bottom-right corner of the grid from the top-left corner using dynamic programming. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize the 2D dp array with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] # Base case dp[0][0] = grid[0][0] # Fill the first row for c in range(1, cols): dp[0][c] = dp[0][c-1] + grid[0][c] # Fill the first column for r in range(1, rows): dp[r][0] = dp[r-1][0] + grid[r][0] # Fill the rest of the dp array for r in range(1, rows): for c in range(1, cols): dp[r][c] = min(dp[r-1][c], dp[r][c-1]) + grid[r][c] return dp[rows-1][cols-1]"},{"question":"# Clone Graph With Depth-First Search You are working as a software developer for a company that specializes in data structure utilities. Your task is to implement a function that clones an undirected graph using depth-first search (DFS). The graph is represented using adjacency lists. Function Signature ```python class Node: def __init__(self, val: int, neighbors: List[\'Node\'] = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] def clone_graph(node: Node) -> Node: This function creates a deep copy of an undirected graph using DFS. :param node: The root node of the graph to be cloned. :return: The root node of the cloned graph. ``` Input 1. **node**: A `Node` object that represents the root of the graph. Each `Node` has a `val` which is an integer, and `neighbors` which is a list of adjacent nodes. Output * A `Node` object that is the root of a deep-copied clone of the graph. Constraints * The number of nodes in the graph is in the range `[0, 100]`. * Node values are unique integers. * Each node may have 0 or more neighbors. Example ```python # Example node creation and cloning # Nodes of the graph node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) # Setting up neighbors (adjacency list) node1.neighbors = [node2, node4] node2.neighbors = [node1, node3] node3.neighbors = [node2, node4] node4.neighbors = [node1, node3] # Cloning the graph cloned_node1 = clone_graph(node1) # Verifying by value and structure assert cloned_node1.val == node1.val assert len(cloned_node1.neighbors) == 2 assert all(nei.val in [2, 4] for nei in cloned_node1.neighbors) ``` Notes * Use a dictionary to keep track of already copied nodes to avoid infinite loops. * Ensure that the function handles edge cases such as an empty graph (i.e., when `node` is `None`). * Aim for a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. * Ensure the deep copy maintains the complete structure and connectivity of the original graph.","solution":"class Node: def __init__(self, val: int, neighbors: list = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] def clone_graph(node: Node) -> Node: This function creates a deep copy of an undirected graph using DFS. :param node: The root node of the graph to be cloned. :return: The root node of the cloned graph. if not node: return None # Dictionary to keep track of cloned nodes cloned_nodes = {} def dfs(node): if node in cloned_nodes: return cloned_nodes[node] clone = Node(node.val) cloned_nodes[node] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone return dfs(node)"},{"question":"# Coding Challenge: Simulated Stock Trading # Question: You are given a simplified stock trading simulation for a single stock. The stock price varies over time and you are allowed to buy and sell this stock according to certain rules, aiming to maximize your profit. **Objective:** Write a function that takes a list of stock prices and determines the maximum profit that can be achieved with the following constraints: 1. You may complete at most one transaction (i.e., buy one and sell one share of the stock). 2. You cannot sell a stock before you buy it. **Function Signature:** ```python def max_profit(prices: List[int]) -> int: pass ``` **Parameters:** - `prices` (List[int]): A list of integers where each integer represents the price of the stock on a particular day. **Returns:** - `int`: The maximum profit that can be achieved from one transaction. If no profit is possible, return 0. **Constraints:** - The length of `prices` will be between `1` and `10**5`. - Each price in `prices` will be between `0` and `10**4`. **Example**: ```python # Example 1 prices = [7, 1, 5, 3, 6, 4] # Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. # Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. print(max_profit(prices)) # Output: 5 # Example 2 prices = [7, 6, 4, 3, 1] # Explanation: In this case, no transactions are done, and the max profit = 0. print(max_profit(prices)) # Output: 0 ``` **Hint**: Iterate through the list while keeping track of the minimum price seen so far and the maximum profit possible.","solution":"from typing import List def max_profit(prices: List[int]) -> int: This function calculates the maximum profit that can be achieved from buying and selling a single stock given the prices on different days. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Coding Challenge: Efficient Stock Price Analyzer Context In financial analysis, it\'s crucial to determine the optimal moments to buy and sell stocks to maximize profit. This involves identifying the maximum profit that can be achieved from a list of daily stock prices, which can fluctuate significantly. A naive approach would require examining all possible pairs of days, resulting in an O(n^2) time complexity. However, a more efficient solution is needed for applications where quick analysis is critical. Task Write a function `max_profit(prices: list[int]) -> int` that calculates the maximum achievable profit from a list of historical daily stock prices. Your solution should have a time complexity of O(n) and use O(1) extra space. Input * A list `prices` where `prices[i]` is the stock price on the ith day. Output * An integer representing the maximum profit. Constraints * The length of `prices` will be at least one. * Prices will always be non-negative integers. Performance Requirement Your solution should efficiently handle large datasets, potentially on the order of 10^6 elements. Example ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([2, 4, 1]) 2 >>> max_profit([2, 1, 2, 0, 1]) 1 ``` Problem Solving Strategy 1. Traverse the list while tracking the minimum price observed so far. 2. For each price, calculate the potential profit and update the maximum profit accordingly. Good luck and aim for an optimized solution!","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a list of daily stock prices. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Coding Assessment Question You are tasked with implementing a feature to identify and mark connected components (regions) in a binary matrix using Depth-First Search (DFS). Each region is to be marked with a unique identifier to distinguish it from other regions. Requirements: 1. Implement a function `mark_regions` that iterates over the matrix and marks all regions distinctly. 2. A region is defined as a group of connected 1s (cells whose value is 1) in the North, South, East, or West direction. 3. Each region should be marked with a unique identifier starting from 2. # Function Signature ```python def mark_regions(matrix: List[List[int]]) -> None: Mark regions in a binary matrix. :param matrix: 2D binary matrix (list of lists) :type matrix: List[List[int]] pass ``` # Input - A binary matrix represented as a list of lists of integers, where `matrix[i][j]` is either 0 or 1. # Output - The function shall modify the matrix in place, marking each distinct region with a unique identifier starting from 2. # Constraints - The matrix will have at most 1000 rows and 1000 columns. - The function should handle edge boundaries of the matrix gracefully. - Optimize the solution for performance. # Example ```python # Input matrix matrix = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 1, 1, 1, 0] ] # Mark regions mark_regions(matrix) # Output matrix # [ # [2, 2, 0, 0, 0], # [2, 0, 0, 3, 3], # [0, 0, 4, 0, 0], # [0, 4, 4, 4, 0] # ] ``` # Additional Information The function shall use Depth-First Search (DFS) to traverse and mark each region. Document any assumptions made. This question will assess: - Proficiency in Depth-First Search (DFS) algorithms, - Ability to manipulate and modify 2D matrices, - Understanding of connected component labeling in binary matrices.","solution":"from typing import List def mark_regions(matrix: List[List[int]]) -> None: Mark regions in a binary matrix using Depth-First Search (DFS). :param matrix: 2D binary matrix (list of lists) :type matrix: List[List[int]] def dfs(matrix, i, j, region_id): # directions: N, E, S, W directions = [(-1, 0), (0, 1), (1, 0), (0, -1)] stack = [(i, j)] while stack: x, y = stack.pop() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] == 1: matrix[nx][ny] = region_id stack.append((nx, ny)) region_id = 2 # Start labeling regions from 2 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: matrix[i][j] = region_id dfs(matrix, i, j, region_id) region_id += 1"},{"question":"# Problem Statement Design and implement a class that simulates the behavior of a basic file system with a hierarchical structure. Your class should support creating directories, creating files, and retrieving file content by path on demand. The system should maintain the structure and implement essential path-related functionality. You are to implement a class `FileSystem` with specific methods to handle the actions described. # Function Signature ```python class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: pass def add_content_to_file(self, file_path: str, content: str) -> None: pass def read_content_from_file(self, file_path: str) -> str: pass def _get_node(self, path: str, create: bool=False): pass def ls(self, path: str) -> list: pass def __repr__(self): pass ``` # Implementation Details Class Initialization * **Constructor**: - Initializes the root directory as an empty dictionary. Methods to Implement * **mkdir**: Create a directory at the specified path. - Input: `path` as a string representing the directory path. - Output: None. * **add_content_to_file**: Add content to a file at the specified path. - Input: `file_path` as a string and `content` as a string. - Output: None. - Note: If the file already exists, append the content to it. * **read_content_from_file**: Read the content from a file at the specified path. - Input: `file_path` as a string. - Output: The content of the file as a string. * **_get_node**: Helper method to facilitate node navigation and creation. - Input: `path` as a string, and `create` as a boolean. - Output: The dictionary node at the specified path. * **ls**: List the content at the specified directory path. - Input: `path` as a string. - Output: List of directory or file names in alphabetical order. * **__repr__**: For debugging purposes, provides a string representation of the current file system state. - Input: None. - Output: A string representation of the file system. # Constraints 1. `path` and `file_path` will be non-empty strings that start with `/` and do not end with `/`. 2. The operations will be valid, ensuring no undefined paths are accessed. # Example Usage ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.add_content_to_file(\\"/a/b/c/d\\", \\"hello\\") print(fs.ls(\\"/\\")) # Output: [\\"a\\"] print(fs.ls(\\"/a/b/c\\")) # Output: [\\"d\\"] print(fs.read_content_from_file(\\"/a/b/c/d\\")) # Output: \\"hello\\" fs.add_content_to_file(\\"/a/b/c/d\\", \\" world\\") print(fs.read_content_from_file(\\"/a/b/c/d\\")) # Output: \\"hello world\\" ``` # Expected Output ```plaintext [\\"a\\"] [\\"d\\"] \\"hello\\" \\"hello world\\" ``` Submit your implementation of the `FileSystem` class.","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: self._get_node(path, create=True) def add_content_to_file(self, file_path: str, content: str) -> None: directories = file_path.split(\'/\') node = self._get_node(\'/\'.join(directories[:-1]), create=True) file_name = directories[-1] if file_name not in node: node[file_name] = \\"\\" node[file_name] += content def read_content_from_file(self, file_path: str) -> str: directories = file_path.split(\'/\') node = self._get_node(\'/\'.join(directories[:-1]), create=False) file_name = directories[-1] return node[file_name] def _get_node(self, path: str, create: bool=False): node = self.root if path == \\"/\\": return node directories = path.split(\'/\') for directory in directories: if directory: if create and directory not in node: node[directory] = {} node = node[directory] return node def ls(self, path: str) -> list: node = self._get_node(path) if isinstance(node, str): return [path.split(\'/\')[-1]] return sorted(node.keys()) def __repr__(self): return str(self.root)"},{"question":"# Longest Uncommon Subsequence You are given two strings. Your task is to implement a function that returns the length of the longest uncommon subsequence. An uncommon subsequence between the two strings is defined as a string that exists in only one of the two strings and not as a subsequence in the other string. **Function Signature**: ```python def longest_uncommon_subsequence(str1: str, str2: str) -> int: pass ``` # Example ```python # Example usage str1 = \\"abc\\" str2 = \\"cab\\" # Test longest_uncommon_subsequence assert longest_uncommon_subsequence(str1, str2) == 3 str1 = \\"aaa\\" str2 = \\"bbb\\" assert longest_uncommon_subsequence(str1, str2) == 3 str1 = \\"abcd\\" str2 = \\"abcd\\" assert longest_uncommon_subsequence(str1, str2) == -1 ``` **Constraints**: - Both `str1` and `str2` will consist of lowercase letters. - The length of `str1` and `str2` will not exceed 100. **Note**: - If str1 and str2 are exactly the same, return -1 because there is no uncommon subsequence. - In any other case, the longest uncommon subsequence will be the longest string itself. If the strings are of different lengths, return the length of the longer string. If they are of the same length but different, return the length of either of the strings.","solution":"def longest_uncommon_subsequence(str1: str, str2: str) -> int: Returns the length of the longest uncommon subsequence between two strings. An uncommon subsequence is defined as a string that is present in only one of the two strings and not as a subsequence in the other string. If the two strings are exactly the same, the function returns -1. Otherwise, it returns the length of the longer string. If both have the same length but are different, the length of either string is returned. if str1 == str2: return -1 return max(len(str1), len(str2))"},{"question":"# Balanced Parentheses with Stars Coding Challenge **Objective**: Implement a function that checks if a string containing parentheses (`(` and `)`) and asterisk (`*`) is balanced. Problem Description Given a string `s` containing only the characters `(`, `)`, and `*`, your goal is to determine if the string can be considered valid. The asterisks (`*`) can be treated as either a left parenthesis `(`, a right parenthesis `)`, or an empty string. Function Signature ```python def checkValidString(s: str) -> bool: pass ``` Input * A single string `s` (1 ≤ len(s) ≤ 100) consisting of the characters `(`, `)`, and `*`. Output * Returns `True` if the string `s` is balanced. * Returns `False` otherwise. Constraints * The input string `s` must only contain `(`, `)`, and `*`. * If the input contains invalid characters, raise a `ValueError` with the message `\\"Invalid character found in the input string\\"`. Example ```python >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"((*)\\") True >>> checkValidString(\\"((*)(*\\") False ``` Edge Cases * Handling empty input: * `checkValidString(\\"\\")` should return `True`. * Handling input with invalid characters: * `checkValidString(\\"abc\\")` should raise a `ValueError`. Additional Requirements * Implement the solution in an efficient manner. * Consider all possible placements of the asterisk as a parenthesis or an empty string to verify the balance of the input.","solution":"def checkValidString(s: str) -> bool: This function checks whether a string with characters \'(\', \')\', and \'*\' is balanced. The \'*\' can be treated as \'(\', \')\' or an empty string. # Error handling for invalid characters if not all(c in {\'(\', \')\', \'*\'} for c in s): raise ValueError(\\"Invalid character found in the input string\\") left_balance = right_balance = 0 # First pass: check for valid left-to-right balance for char in s: if char == \'(\' or char == \'*\': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False # Second pass: check for valid right-to-left balance for char in reversed(s): if char == \')\' or char == \'*\': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"# Problem Context Data structures such as Stacks and Queues are fundamental to various algorithms and applications in computer science. Sometimes, it is required to process sequences where these structures need to be used interchangeably based on specific conditions. Implementing such scenario-based processing teaches efficient use of these data structures in more dynamic and realistic applications. # Task You are tasked with implementing a custom data structure `MultiStackQueue` that supports both stack and queue operations. Depending on the mode, it should act either as a stack or as a queue. The users of this data structure should also be able to switch modes dynamically. # Requirements 1. Implement the `MultiStackQueue` class with the following operations: - `push(value)`: * Adds an element to the data structure. - `pop() -> value`: * Removes and returns an element based on the current mode. - `switch_mode(mode)`: * Changes the current mode to either \'stack\' or \'queue\'. - `current_mode() -> mode`: * Returns the current mode of the data structure. # Input and Output Format - `push` method: * **Input**: `value` (any data type) * **Output**: None - `pop` method: * **Output**: Returns the last added element if in \'stack\' mode, or the first added element if in \'queue\' mode. - `switch_mode` method: * **Input**: `mode` (string, either \'stack\' or \'queue\') * **Output**: None - `current_mode` method: * **Output**: Returns the current mode as a string. # Constraints - Ensure efficient switch between modes. - Implement proper error handling for underflow conditions and invalid mode switching. # Edge Cases - Switching modes on an empty data structure. - Attempting invalid operations based on the current mode. - Handling mixed pushing and popping operations correctly. # Performance Expectations - Aim for (O(1)) time complexity for stack and queue operations. - Efficiently manage memory usage during mode switches. # Example ```python class MultiStackQueue: def __init__(self): # Your implementation here pass def push(self, value): # Your implementation here pass def pop(self): # Your implementation here pass def switch_mode(self, mode): # Your implementation here pass def current_mode(self): # Your implementation here pass # Example Usage msq = MultiStackQueue() msq.push(1) msq.push(2) msq.push(3) assert msq.pop() == 3 msq.switch_mode(\'queue\') assert msq.pop() == 1 msq.push(4) assert msq.pop() == 2 assert msq.current_mode() == \'queue\' print(\\"All tests passed!\\") ``` Implement the `MultiStackQueue` class with the specified methods and ensure to handle all edge cases and performance constraints effectively.","solution":"from collections import deque class MultiStackQueue: def __init__(self): Initialize data structure to maintain stack and queue modes. self.data = deque() self.mode = \'stack\' # default mode is \'stack\' def push(self, value): Adds value to data structure. self.data.append(value) def pop(self): Removes and returns element based on current mode. if not self.data: raise IndexError(\\"pop from an empty MultiStackQueue\\") if self.mode == \'stack\': return self.data.pop() else: # mode is \'queue\' return self.data.popleft() def switch_mode(self, mode): Switches the current mode to either \'stack\' or \'queue\'. if mode not in {\'stack\', \'queue\'}: raise ValueError(\\"mode must be either \'stack\' or \'queue\'\\") self.mode = mode def current_mode(self): Returns the current mode. return self.mode"},{"question":"# Coding Assessment Question You are given a list of integers representing the heights of bars in a histogram. Each bar has a width of 1. Write a function that computes the largest rectangular area in the histogram. # Requirements Implement the function `largest_histogram_area(heights)` which takes: 1. `heights`: A list of integers representing the heights of the bars in the histogram. # Expected Function Signature ```python def largest_histogram_area(heights: List[int]) -> int: ``` # Constraints - The `heights` list can be empty. - Each height in the `heights` list will be a non-negative integer. # Example ```python >>> largest_histogram_area([2, 1, 5, 6, 2, 3]) 10 ``` # Performance Expectations - The function should run in O(n) time complexity, where n is the length of `heights`. - Use O(n) additional space for any auxiliary data structures. If `heights` is empty, return 0.","solution":"from typing import List def largest_histogram_area(heights: List[int]) -> int: Computes the largest rectangular area possible in a histogram given by heights. :param heights: List[int] - A list of integers representing the heights of bars. :return: int - The maximum rectangular area. max_area = 0 stack = [] for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"# Coding Assessment Question Problem Statement You are given a sentinel-doubly linked list implemented as a class, with methods to insert values at the front and end of the list as well as to perform traversal from both directions. Your task is to extend this class to support additional functionality. Objective 1. Write a function `find_middle` that finds and returns the middle element of the doubly linked list. If the list has an even number of elements, return the element closer to the end (the second middle element). 2. Handle edge cases effectively (e.g., an empty list should return `None`). Implementation Details Extend the provided class with the following function: ```python def find_middle(self) -> int: ``` - **Output**: - Returns the middle element (type `int`). - If the list is empty, return `None`. Constraints - Assume the linked list stores integer values. - Handle an empty doubly linked list correctly (should return `None`). Performance Requirements - The solution should run in O(n) time complexity, where n is the number of nodes in the doubly linked list. - Optimize for space as much as possible. Example ```python # Example usage: dll = DoublyLinkedList() dll.append(10) dll.append(20) dll.append(30) # This should return 20 (list: 10 <-> 20 <-> 30, middle is 20) middle_element = dll.find_middle() print(middle_element) # Output: 20 dll.append(40) # This should return 30 (list: 10 <-> 20 <-> 30 <-> 40, even number, second middle is 30) middle_element = dll.find_middle() print(middle_element) # Output: 30 # For an empty list, this should return None dll_empty = DoublyLinkedList() middle_element = dll_empty.find_middle() print(middle_element) # Output: None ``` Notes - You may use a helper function if needed to maintain clear and efficient code. - Remember to handle the input constraints and verify edge cases effectively.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def append(self, value: int): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node self.size += 1 def prepend(self, value: int): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.head.prev = new_node new_node.next = self.head self.head = new_node self.size += 1 def find_middle(self) -> int: if not self.head: return None middle_index = self.size // 2 current = self.head for _ in range(middle_index): current = current.next return current.value"},{"question":"# Task Scheduler with Dependencies You are given a list of tasks, each specified by an ID, a duration, a reward, and a list of dependencies. Each task can start only after all its dependencies are completed. Tasks are specified in a list of dictionaries, where each dictionary represents a task with ID, duration, reward, and dependencies keys. Your goal is to write a function `schedule_tasks(tasks_info)` that schedules the tasks in a way that maximizes the total reward while respecting all dependencies. The function should return a list of task IDs corresponding to the tasks that can be completed to yield the maximum reward. # Input * `tasks_info`: A list of dictionaries, where each dictionary contains: * `id`: An integer representing the task ID. * `duration`: An integer representing the duration of the task in units of time. * `reward`: An integer representing the reward for completing the task. * `dependencies`: A list of integers representing the IDs of tasks that must be completed before the current task. # Output * A list of integers representing the task IDs that can be completed to yield the maximum reward. # Constraints * Each task can only start once all its dependencies are completed. * The tasks should be scheduled in a way that maximizes the total reward. * There should be no cycles in the dependency graph (which would make the tasks impossible to complete). # Performance Requirements * Time Complexity: O(n^2) * Space Complexity: O(n) # Examples ```python assert schedule_tasks([ {\'id\': 1, \'duration\': 3, \'reward\': 20, \'dependencies\': [2]}, {\'id\': 2, \'duration\': 2, \'reward\': 10, \'dependencies\': []} ]) == [2, 1] assert schedule_tasks([ {\'id\': 1, \'duration\': 2, \'reward\': 30, \'dependencies\': [2, 3]}, {\'id\': 2, \'duration\': 1, \'reward\': 10, \'dependencies\': []}, {\'id\': 3, \'duration\': 3, \'reward\': 20, \'dependencies\': [2]} ]) == [2, 3, 1] assert schedule_tasks([ {\'id\': 1, \'duration\': 2, \'reward\': 15, \'dependencies\': []} ]) == [1] assert schedule_tasks([]) == [] ``` # Additional Considerations Ensure that your solution handles: * Edge cases such as empty input. * Tasks with no dependencies. * The order of tasks to handle maximum reward calculation correctly. # Function Signature ```python def schedule_tasks(tasks_info: list[dict]) -> list[int]: # Your code here ```","solution":"def schedule_tasks(tasks_info): from collections import defaultdict, deque # Create graph and in-degree dictionary graph = defaultdict(list) in_degree = {} reward = {} duration = {} for task in tasks_info: id = task[\'id\'] duration[id] = task[\'duration\'] reward[id] = task[\'reward\'] in_degree[id] = len(task[\'dependencies\']) for dep in task[\'dependencies\']: graph[dep].append(id) # Initialize queue with tasks having no dependencies queue = deque([task[\'id\'] for task in tasks_info if in_degree[task[\'id\']] == 0]) completed_tasks = [] total_reward = 0 while queue: current = queue.popleft() completed_tasks.append(current) total_reward += reward[current] for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return completed_tasks"},{"question":"# Problem Statement You have been tasked with writing a function that simulates a basic Message Queue (MQ), which allows messages to be added to the queue, retrieved in the order they were added (First-In-First-Out, FIFO), and provides functionality to get the current size of the queue. # Input - The function will not take any input from the user but will interact with predefined methods for the operations. # Output - Your implementation should support three actions: `enqueue`, `dequeue`, and `size`. # Constraints - The queue should handle an arbitrary number of string messages. - Attempting to dequeue from an empty queue should return `None` without causing an error. # Function Signatures Implement the following methods within a `MessageQueue` class: ```python class MessageQueue: def __init__(self): # Initialize your data structure here def enqueue(self, message: str) -> None: # Add a message to the queue def dequeue(self) -> str: # Remove and return the first message in the queue or None if the queue is empty def size(self) -> int: # Return the number of messages currently in the queue ``` # Examples ```python mq = MessageQueue() mq.enqueue(\\"message1\\") mq.enqueue(\\"message2\\") print(mq.size()) # Output: 2 print(mq.dequeue()) # Output: \\"message1\\" print(mq.size()) # Output: 1 print(mq.dequeue()) # Output: \\"message2\\" print(mq.size()) # Output: 0 print(mq.dequeue()) # Output: None ``` # Explanation - The `MessageQueue` class should maintain an internal structure to track the messages. - The `enqueue` method should add a new message to the back of the queue. - The `dequeue` method should remove and return the message from the front of the queue. If the queue is empty, it should return `None`. - The `size` method should return the number of messages currently in the queue. **Note**: This question evaluates the candidate\'s understanding of data structures, specifically queues, and their ability to implement classes and methods following defined constraints.","solution":"class MessageQueue: def __init__(self): self.queue = [] def enqueue(self, message: str) -> None: self.queue.append(message) def dequeue(self) -> str: if not self.queue: return None return self.queue.pop(0) def size(self) -> int: return len(self.queue)"},{"question":"**Knapsack Problem** Your task is to solve the Knapsack problem using a dynamic programming algorithm. The objective is to determine the maximum total value of items that can be placed into a knapsack of a given capacity. # Requirements - Implement a function `knapsack(capacity: int, weights: List[int], values: List[int]) -> int` that returns the maximum value that can be carried in the knapsack. - Each item has a weight and a corresponding value. You can either include an item in the knapsack or exclude it. You cannot include an item more than once (0/1 knapsack). # Inputs - Integer `capacity`: the maximum weight capacity of the knapsack. - List `weights`: a list of integers where each integer represents the weight of an item. - List `values`: a list of integers where each integer represents the value of an item. - It is guaranteed that the length of `weights` and `values` lists will be the same, and they will not exceed 100 (1 ≤ len(weights) = len(values) ≤ 100). # Outputs - An integer representing the maximum value that can be obtained within the given capacity of the knapsack. # Constraints - Handle edge cases where the capacity is 0 or there are no items to choose from. - Provide a brief explanation and documentation of your solution. # Example ```python def knapsack(capacity: int, weights: List[int], values: List[int]) -> int: # Your code here # Example usage: max_value = knapsack(50, [10, 20, 30], [60, 100, 120]) print(max_value) # Output: # 220 ``` # Prompt Using the described algorithm and principles above: 1. Implement the `knapsack` function. 2. Ensure the function showcases efficient dynamic programming practices. 3. Provide meaningful comments and documentation within the code.","solution":"from typing import List def knapsack(capacity: int, weights: List[int], values: List[int]) -> int: Returns the maximum value that can be carried in the knapsack of given capacity using dynamic programming. :param capacity: Maximum weight capacity of the knapsack :param weights: List of item weights :param values: List of item values :return: Maximum value that can be obtained within the given capacity n = len(weights) # Create a 2D list to store the maximum value at each n weight from 0 to capacity dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] # Fill the dp table in bottom-up manner for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: # Item can be included dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: # Item cannot be included dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"# Context Understanding and working with binary trees is fundamental in computer science and software development. Binary trees serve as the foundation for various data structures and algorithms, including binary search trees and heaps. You are required to implement a function to determine whether two binary trees are identical in structure and node values. # Objective Write a Python function `are_trees_identical(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool` that checks if the two binary trees are identical. # Requirements 1. **Input Format**: * `tree1`: The root node of the first binary tree. * `tree2`: The root node of the second binary tree. 2. **Output Format**: * A boolean value (`True` or `False`) indicating whether the two binary trees are identical. 3. **Constraints**: * The binary trees can have at most 1000 nodes. * Each node in the binary tree has an integer value. # Performance Ensure your implementation is efficient, considering the recursive nature of tree traversal. # Function Signature ```python def are_trees_identical(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool: ``` # Example ```python # Define TreeNode class for binary tree nodes class TreeNode: def __init__(self, val: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right # Example usage: tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) are_trees_identical(tree1, tree2) # Should return: True tree3 = TreeNode(1, TreeNode(2)) tree4 = TreeNode(1, None, TreeNode(2)) are_trees_identical(tree3, tree4) # Should return: False ``` # Notes * Define the `TreeNode` class as shown in the example. * Consider edge cases such as empty trees and trees with different structures. * Ensure the function works correctly for trees with various node values and configurations.","solution":"class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def are_trees_identical(tree1: TreeNode, tree2: TreeNode) -> bool: # Both trees are empty if tree1 is None and tree2 is None: return True # One of the trees is empty, but not the other if tree1 is None or tree2 is None: return False # Both trees are non-empty, compare the values and the subtrees if tree1.val != tree2.val: return False return are_trees_identical(tree1.left, tree2.left) and are_trees_identical(tree1.right, tree2.right)"},{"question":"# MD5 Hash Generator You are tasked with implementing a function to generate MD5 hash digests. MD5 (Message Digest Algorithm 5) generates a 128-bit hash value from an input string. Note that MD5 hashing is widely used for data integrity checks though it\'s not considered secure for cryptographic purposes. Problem Statement Implement a function `generate_md5_hash` that takes a string input and returns the MD5 hash of the input string. 1. **generate_md5_hash(input_str: str) -> str**: - **Input**: - `input_str`: A string containing the message whose MD5 hash you need to compute. - **Output**: Returns the MD5 hash as a 32-character hexadecimal string. Constraints * The input string can contain any ASCII characters, including spaces and punctuation. * The hash digest should be represented as a lowercase hexadecimal string. Example ```python assert generate_md5_hash(\'The quick brown fox jumps over the lazy dog\') == \'9e107d9d372bb6826bd81d3542a419d6\' assert generate_md5_hash(\'\') == \'d41d8cd98f00b204e9800998ecf8427e\' ``` Function Definition ```python import hashlib def generate_md5_hash(input_str: str) -> str: # Create an md5 hash object hash_object = hashlib.md5(input_str.encode()) # Return the hexadecimal representation of the hash return hash_object.hexdigest() ```","solution":"import hashlib def generate_md5_hash(input_str: str) -> str: Generates an MD5 hash for the given input string. Args: input_str (str): The input string to hash. Returns: str: The MD5 hash of the input string as a 32-character hexadecimal string. # Create an md5 hash object hash_object = hashlib.md5(input_str.encode()) # Return the hexadecimal representation of the hash return hash_object.hexdigest()"},{"question":"Scenario You are given a list of tasks, each with a specific deadline and a profit if the task is completed before the deadline. Your goal is to maximize the total profit by scheduling the tasks in such a way that no two tasks overlap. Task Implement a function to determine the maximum profit achievable by scheduling the tasks, and print the sequence of tasks that generate this maximum profit. Function Signature ```python def schedule_tasks(tasks: List[Task]) -> None: ``` Input - `tasks`: A list of `Task` objects, where each task has the following attributes: - `deadline`: Integer, the deadline by which the task must be finished. - `profit`: Integer, the profit earned for completing the task by its deadline. Output - The function should print the maximum profit achievable and the sequence of tasks that lead to this profit. Constraints - The `deadline` for each task is a positive integer. - The `profit` for each task is a non-negative integer. - The number of tasks `n` is between `1` and `100` (inclusive). Example ```python tasks = [ Task(deadline=2, profit=100), Task(deadline=1, profit=19), Task(deadline=2, profit=27), Task(deadline=1, profit=25), Task(deadline=3, profit=15) ] schedule_tasks(tasks) ``` # Expected Output ``` Maximum profit is 142. The sequence of tasks is: Task(deadline=2, profit=100) Task(deadline=2, profit=27) Task(deadline=3, profit=15) ``` **Note**: To achieve the optimal solution, focus on utilizing a greedy algorithm, sorting tasks by their profit and placing them in the latest possible available timeslots within their respective deadlines.","solution":"from typing import List class Task: def __init__(self, deadline: int, profit: int): self.deadline = deadline self.profit = profit def __repr__(self): return f\\"Task(deadline={self.deadline}, profit={self.profit})\\" def schedule_tasks(tasks: List[Task]) -> None: Schedules tasks to maximize profit with no overlapping deadlines. Prints the maximum profit and the sequence of tasks leading to it. # Sort tasks based on profit in descending order tasks.sort(key=lambda x: x.profit, reverse=True) # Find the maximum deadline to determine the time slots max_deadline = max(task.deadline for task in tasks) # Time slots, initialized to None time_slots = [None] * max_deadline total_profit = 0 for task in tasks: # Try to schedule task in the latest possible slot before its deadline for slot in range(min(max_deadline, task.deadline) - 1, -1, -1): if time_slots[slot] is None: time_slots[slot] = task total_profit += task.profit break # Filter out None slots and keep only scheduled tasks scheduled_tasks = [task for task in time_slots if task is not None] # Output the results print(f\\"Maximum profit is {total_profit}.\\") print(\\"The sequence of tasks is:\\") for task in scheduled_tasks: print(task) # Example usage: # tasks = [ # Task(deadline=2, profit=100), # Task(deadline=1, profit=19), # Task(deadline=2, profit=27), # Task(deadline=1, profit=25), # Task(deadline=3, profit=15) # ] # schedule_tasks(tasks)"},{"question":"# Problem Statement You are required to compute the Fibonacci sequence up to the nth term, respecting the following constraints and input formats. # Task: Write a function `fibonacci_sequence(n: Union[int, str]) -> Union[List[int], str]:` that takes an integer or a string representing an integer, which designates the number of terms (n) in the Fibonacci sequence, and returns a list containing the Fibonacci sequence up to the nth term. If the input is invalid, return an error message. # Input * `n`: a positive integer (n >= 1) or a string that can be converted to a positive integer. # Output * A list of integers representing the Fibonacci sequence up to the nth term. * If the input is invalid (non-convertible string, negative number, zero, or non-integer), return the string \\"Invalid input\\". # Constraints * The function should handle conversion of string input to an integer if it\'s a valid representation of a positive integer. * The function should ignore None, empty string, or any invalid inputs and return an appropriate error message. # Example Input `n = 5` Output `[0, 1, 1, 2, 3]` Input `n = \\"7\\"` Output `[0, 1, 1, 2, 3, 5, 8]` Input `n = \\"-3\\"` Output `Invalid input` Input `n = \\"abc\\"` Output `Invalid input` # Implementation Notes - Writing concise and well-documented code is expected. - Consider using type hints and ensuring code readability. - The solution should be tested for various edge cases. # Function Signature ```python from typing import List, Union def fibonacci_sequence(n: Union[int, str]) -> Union[List[int], str]: pass ``` # Additional Requirements 1. Implement comprehensive validation of inputs. 2. Include error handling for invalid input types and values. 3. Efficient processing for larger values of n.","solution":"from typing import List, Union def fibonacci_sequence(n: Union[int, str]) -> Union[List[int], str]: try: # Attempt to convert to integer n = int(n) except (ValueError, TypeError): return \\"Invalid input\\" # Ensure n is a positive integer if n <= 0: return \\"Invalid input\\" # Generate Fibonacci sequence up to nth term sequence = [] a, b = 0, 1 while len(sequence) < n: sequence.append(a) a, b = b, a + b return sequence"},{"question":"# Problem Statement You are developing a simple text analyzer that will count the frequency of each word in a given string. Your task is to implement a function that takes a string as input and returns a dictionary where the keys are the unique words, and the values are the number of times each word appears in the string. # Function Signature ```python def word_count(s: str) -> dict[str, int]: pass ``` # Input * `s`: A string containing several words separated by spaces and possibly punctuated. - Constraints: (0 leq text{len}(s) leq 10^6) # Output * Returns a dictionary where: - Keys are unique words from the input string. - Values are the frequency counts of the corresponding words. # Requirements * The function should be case-insensitive meaning \'Word\' and \'word\' should be considered the same word. * Words are defined as continuous sequences of alphabetical characters (`a-z`, `A-Z`). Ignore any punctuation marks. * The solution should have a linear time complexity O(n), where n is the length of the string. # Examples 1. `word_count(\\"Hello world! Hello.\\")` should return `{\'hello\': 2, \'world\': 1}`. 2. `word_count(\\"This is a simple test. A test for word count.\\")` should return `{\'this\': 1, \'is\': 1, \'a\': 2, \'simple\': 1, \'test\': 2, \'for\': 1, \'word\': 1, \'count\': 1}`. 3. `word_count(\\"To be, or not to be, that is the question!\\")` should return `{\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1, \'that\': 1, \'is\': 1, \'the\': 1, \'question\': 1}`. 4. `word_count(\\"\\")` should return `{}`. 5. `word_count(\\"Hello.\\")` should return `{\'hello\': 1}`. # Edge Cases Consider the following edge cases: 1. An empty string should return an empty dictionary. 2. Ensure capitalization is handled such that \'Word\' and \'word\' count as the same word. 3. Ignore all punctuation marks within the string. 4. Strings with different kinds of punctuation marks separating words. # Constraint - Built-in functions to handle string manipulations (like `str.lower()`, `str.split()`) are allowed, but external libraries for text processing are not.","solution":"import re def word_count(s: str) -> dict[str, int]: Returns the frequency of each word in the given string. The function is case insensitive and ignores punctuation. # Convert the string to lowercase and use regex to find all words s = s.lower() words = re.findall(r\'b[a-z]+b\', s) # Use a dictionary to count the frequencies word_freq = {} for word in words: if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 return word_freq"},{"question":"# Question: Warehouse Inventory Optimization A company needs to manage its warehouse inventory efficiently. You are tasked with developing a function that optimizes the restocking of items based on current stock levels and restocking thresholds. Your Task Enhance the provided function to: 1. Validate input values to ensure that quantities and thresholds are non-negative integers. 2. Ensure the function handles cases where restocking thresholds are met or exceeded and provides clear messages for the following scenarios: - Any input value is negative. - Restocking threshold is zero or missing. 3. Implement detailed unit tests to cover these scenarios. Function Signature ```python def restock_inventory( current_stock: dict[str, int], restock_threshold: dict[str, int] ) -> dict[str, int]: ``` Input - `current_stock`: Dictionary with item names as keys and current stock levels as values (non-negative integers). - `restock_threshold`: Dictionary with item names as keys and restocking thresholds as values (non-negative integers). Output - A dictionary with item names as keys and the quantities to be restocked as values. Constraints - **Non-negativity**: All quantities and thresholds must be non-negative integers. - **Threshold**: Each item in the `current_stock` must have a corresponding restocking threshold. The function should return a dictionary with the restocking quantities required for each item if the current stock level is below the restocking threshold. Otherwise, it should return zero for those items. Examples ```python assert restock_inventory({\'itemA\': 5, \'itemB\': 2}, {\'itemA\': 10, \'itemB\': 3}) == {\'itemA\': 5, \'itemB\': 1} assert restock_inventory({\'itemA\': 10, \'itemB\': 5}, {\'itemA\': 10, \'itemB\': 3}) == {\'itemA\': 0, \'itemB\': 0} # Error Scenarios try: restock_inventory({\'itemA\': -1, \'itemB\': 5}, {\'itemA\': 10, \'itemB\': 3}) except ValueError as e: assert str(e) == \\"Quantities and thresholds must be non-negative integers\\" try: restock_inventory({\'itemA\': 5, \'itemB\': 5}, {\'itemA\': 0, \'itemB\': 3}) except ValueError as e: assert str(e) == \\"Restocking threshold must be non-zero\\" try: restock_inventory({\'itemA\': 5, \'itemB\': 5}, {\'itemA\': 10}) except ValueError as e: assert str(e) == \\"Each item in current stock must have a corresponding restocking threshold\\" ``` Enhance the function\'s reliability and robustness to manage warehouse inventory effectively and handle all edge cases.","solution":"def restock_inventory( current_stock: dict[str, int], restock_threshold: dict[str, int] ) -> dict[str, int]: Returns a dictionary with the items and their respective quantities to restock based on the current stock and restock thresholds. for item, quantity in current_stock.items(): if quantity < 0: raise ValueError(\\"Quantities and thresholds must be non-negative integers\\") for item, threshold in restock_threshold.items(): if threshold <= 0: raise ValueError(\\"Restocking threshold must be non-zero\\") for item in current_stock: if item not in restock_threshold: raise ValueError(\\"Each item in current stock must have a corresponding restocking threshold\\") restock_quantities = {} for item, current_quantity in current_stock.items(): threshold = restock_threshold[item] restock_quantity = threshold - current_quantity if current_quantity < threshold else 0 restock_quantities[item] = max(restock_quantity, 0) return restock_quantities"},{"question":"Problem Description You are given a list of integers representing the heights of buildings in a skyline. Your goal is to determine the volume of water that can be trapped after raining. Implement the \\"Trapping Rain Water\\" problem using dynamic programming to find this volume. Function Signature ```python def trap_rain_water(heights: List[int]) -> int: Given a list of integers representing the height of buildings in a skyline, determine the volume of water that can be trapped after raining. Parameters: ---------- heights: List[int] - List of non-negative integers representing the heights of the buildings. Returns: ------- int - The total volume of water that can be trapped. Constraints: ----------- - 0 <= len(heights) <= 1000 - 0 <= heights[i] <= 1000 ``` Example ```python assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 assert trap_rain_water([]) == 0 ``` # Constraints * Ensure the heights list contains non-negative integers. * Handle cases where the heights list is empty (should return 0). # Performance Requirement * The solution should have a time complexity of O(n) and a space complexity of O(n). # Edge Cases to Handle * If the heights list is empty (should return 0). * If all the heights are zero (should return 0). * If the list has only one element (should return 0).","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) # Initialize arrays to store the maximum heights to the left and right of each position left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"# Problem: Rotate Matrix You are given an n x n 2D matrix `matrix` representing an image. Rotate the image by 90 degrees (clockwise). # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` # Input * `matrix`: A 2D list of integers representing the image. It is guaranteed that the matrix is an n x n grid and n is between 1 and 1000. # Output * The function should modify the matrix in place, meaning no new matrix should be created. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Constraints - The function should work efficiently even for large values of n (up to 1000). - The matrix must be modified in place. - The input matrix is guaranteed to be square (n x n). # Notes - Consider using a two-step process: first transpose (flip over its main diagonal), then reverse each row. - Think about how the indices of elements will change during the rotation process. - You should handle any edge cases, such as a single element matrix or an extremely large matrix efficiently.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Implement Matrix Multiplication with Memory Optimization You are tasked with performing matrix multiplication in a memory-constrained environment. To optimize memory usage, you need to implement a function that performs matrix multiplication without storing intermediate large matrices. Task Implement the function `optimized_matrix_multiplication(A, B)` in Python that multiplies two matrices `A` and `B` efficiently and returns the resulting matrix. Function Details - **Input**: - `A` (np.ndarray): A 2-dimensional array of shape `(m, n)`. - `B` (np.ndarray): A 2-dimensional array of shape `(n, p)`. - **Output**: - `C` (np.ndarray): The resulting matrix after multiplication with shape `(m, p)`. Constraints - Only use NumPy for numerical operations. - Do not use built-in methods like `np.dot` or `np.matmul`. - Optimize to minimize additional memory usage beyond the input and output matrices. - Ensure the solution handles large matrices efficiently. Example ```python import numpy as np A = np.array([[1, 2], [3, 4], [5, 6]]) B = np.array([[7, 8, 9], [10, 11, 12]]) C = optimized_matrix_multiplication(A, B) print(C) # Output: array([[27, 30, 33], # [61, 68, 75], # [95, 106, 117]]) ``` Edge Cases - If `A` or `B` is an empty matrix, or the inner dimensions do not match, return an appropriate error message or handle the error gracefully. To ensure memory efficiency, only allocate memory for the result matrix and avoid any unnecessary copies of the data.","solution":"import numpy as np def optimized_matrix_multiplication(A, B): Perform matrix multiplication in a memory-efficient way. Args: A (np.ndarray): 2D array of shape (m, n). B (np.ndarray): 2D array of shape (n, p). Returns: np.ndarray: 2D array of shape (m, p) after multiplying A with B. # Get dimensions m, n = A.shape n_B, p = B.shape # Check if the inner dimensions match if n != n_B: raise ValueError(\\"Inner matrix dimensions do not match\\") # Initialize the result matrix with zeros C = np.zeros((m, p)) # Perform matrix multiplication for i in range(m): for j in range(p): C[i, j] = sum(A[i, k] * B[k, j] for k in range(n)) return C"},{"question":"# Problem Statement Design a Python class to manage a scheduling system for a collection of meetings. Your class should support adding, removing, and querying meetings based on their start and end times. Additionally, ensure the class efficiently handles overlaps and can provide a list of non-overlapping meetings. # Requirements - Create a `MeetingScheduler` class to manage meetings. - Implement methods to: - Add a meeting. - Remove a meeting. - Retrieve all non-overlapping meetings. - Find if a specific time slot is available for a new meeting. # Function Implementation Method Header 1. **MeetingScheduler class**: ```python class MeetingScheduler: def __init__(self) -> None: pass ``` 2. **Adding a meeting**: ```python def add_meeting(self, start_time: int, end_time: int) -> bool: ``` - **start_time**: Integer representing the starting time of the meeting. - **end_time**: Integer representing the ending time of the meeting. - **returns**: Boolean indicating whether the meeting was successfully added (False if it overlaps with an existing meeting). 3. **Removing a meeting**: ```python def remove_meeting(self, start_time: int, end_time: int) -> bool: ``` - **start_time**: Integer representing the starting time of the meeting to be removed. - **end_time**: Integer representing the ending time of the meeting to be removed. - **returns**: Boolean indicating whether the meeting was successfully removed (False if the meeting was not found). 4. **Retrieving all non-overlapping meetings**: ```python def get_non_overlapping_meetings(self) -> List[Tuple[int, int]]: ``` - **returns**: A list of tuples, each containing the start and end times of non-overlapping meetings. 5. **Checking if a time slot is available**: ```python def is_time_slot_available(self, start_time: int, end_time: int) -> bool: ``` - **start_time**: Integer representing the starting time of the desired slot. - **end_time**: Integer representing the ending time of the desired slot. - **returns**: Boolean indicating whether the time slot is available (True if no meetings overlap). # Input and Output Formats - Meeting times are specified as integers representing hours in a 24-hour format. - Meetings are closed intervals [start_time, end_time]. # Constraints - Meetings cannot span midnight (i.e., end_time > start_time). - No two meetings can have any overlap in time. - All times are in the range [0, 23]. # Examples 1. **Adding and Removing Meetings**: ```python scheduler = MeetingScheduler() print(scheduler.add_meeting(9, 10)) # Expected Output: True print(scheduler.add_meeting(10, 11)) # Expected Output: True print(scheduler.add_meeting(10, 11)) # Expected Output: False (overlapping) print(scheduler.remove_meeting(9, 10)) # Expected Output: True print(scheduler.remove_meeting(9, 10)) # Expected Output: False (already removed) ``` 2. **Non-overlapping Meetings**: ```python scheduler = MeetingScheduler() scheduler.add_meeting(9, 10) scheduler.add_meeting(11, 12) scheduler.add_meeting(13, 14) print(scheduler.get_non_overlapping_meetings()) # Expected Output: [(9, 10), (11, 12), (13, 14)] ``` 3. **Checking Time Slot Availability**: ```python scheduler = MeetingScheduler() scheduler.add_meeting(9, 10) scheduler.add_meeting(11, 12) print(scheduler.is_time_slot_available(10, 11)) # Expected Output: True print(scheduler.is_time_slot_available(10, 12)) # Expected Output: False ``` # Notes - Ensure efficient management of meetings, particularly when adding and removing to minimize disruption to the schedule. - Handle edge cases such as invalid time intervals gracefully by returning appropriate error indicators (e.g., False).","solution":"from typing import List, Tuple class MeetingScheduler: def __init__(self) -> None: self.meetings = [] def add_meeting(self, start_time: int, end_time: int) -> bool: if start_time >= end_time: return False if self.is_time_slot_available(start_time, end_time): self.meetings.append((start_time, end_time)) self.meetings.sort() # Keeping meetings sorted for simpler operations return True else: return False def remove_meeting(self, start_time: int, end_time: int) -> bool: if (start_time, end_time) in self.meetings: self.meetings.remove((start_time, end_time)) return True else: return False def get_non_overlapping_meetings(self) -> List[Tuple[int, int]]: return self.meetings def is_time_slot_available(self, start_time: int, end_time: int) -> bool: for meeting in self.meetings: if not (end_time <= meeting[0] or start_time >= meeting[1]): return False return True"},{"question":"# Coding Assessment Question: Implementing LRU Cache with Dynamic Capacity **Scenario**: You are tasked with designing an efficient in-memory key-value store for an application. To optimize memory usage, the cache will evict the least recently used (LRU) items when capacity is exceeded. Additionally, the cache\'s capacity should be dynamic, meaning it can be adjusted throughout the application\'s lifecycle without losing existing data. **Objective**: You need to implement a class `LRUCache` which supports the following operations: - `get(key: int) -> int`: Retrieve the value of the key if it exists in the cache, otherwise return -1. - `put(key: int, value: int) -> None`: Insert or update the value of the key, and if the cache exceeds its capacity, it should evict the least recently used item. - `set_capacity(new_capacity: int) -> None`: Adjust the cache\'s capacity to the specified new capacity and perform any necessary evictions to remain within the new capacity. Input: - `operations`: A list of operations to be performed on the cache. - `arguments`: A list of lists, where each sublist contains arguments for the corresponding operation. For example, `operations` might be `[\\"LRUCache\\", \\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"set_capacity\\", \\"put\\", \\"get\\"]` and `arguments` might be `[[2], [1, 1], [2, 2], [1], [3, 3], [2], [1], [4, 4], [1]]`. Output: - A list of results for all `get` operations performed, in the order they were called. ```python class LRUCache: def __init__(self, capacity: int) -> None: Initialize the LRU cache with positive size capacity. self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. if key in self.cache: # refresh the LRU order because the key was accessed self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. if key in self.cache: self.cache[key] = value # refresh the LRU order because the key was accessed self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: # remove the least recently used key lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def set_capacity(self, new_capacity: int) -> None: Adjust the capacity of the cache. Evict the least recently used items if necessary to fit within new capacity. self.capacity = new_capacity while len(self.cache) > self.capacity: lru_key = self.order.pop(0) del self.cache[lru_key] def process_operations(operations: list[str], arguments: list[list[int]]) -> list[int]: result = [] lru_cache = None for op, args in zip(operations, arguments): if op == \\"LRUCache\\": lru_cache = LRUCache(*args) elif op == \\"put\\": lru_cache.put(*args) elif op == \\"get\\": result.append(lru_cache.get(*args)) elif op == \\"set_capacity\\": lru_cache.set_capacity(*args) return result # Example usage: if __name__ == \\"__main__\\": operations = [\\"LRUCache\\", \\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"set_capacity\\", \\"put\\", \\"get\\"] arguments = [[2], [1, 1], [2, 2], [1], [3, 3], [2], [1], [4, 4], [1]] print(process_operations(operations, arguments)) # Expected Output: [1, -1, -1] ``` Constraints: 1. The cache\'s initial capacity and the `new_capacity` will always be positive integers. 2. Keys and values in `put` operations will always be positive integers. 3. The operations list may contain up to 10^4 operations. Requirements: - Correctly implement the `LRUCache` class with methods `get`, `put`, and `set_capacity`. - Ensure your solution handles edge cases where capacity adjustments lead to multiple evictions. - Simulate the process of handling a series of operations on the cache efficiently. **Note**: This question assesses your ability to implement cache mechanisms, handle dynamic structures, and perform efficient evictions based on usage patterns.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int) -> None: Initialize the LRU cache with positive size capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. if key not in self.cache: return -1 self.cache.move_to_end(key) # move the accessed key to the end to show that it was recently used return self.cache[key] def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # pop the first item in the dictionary (least recently used) def set_capacity(self, new_capacity: int) -> None: Adjust the capacity of the cache. Evict the least recently used items if necessary to fit within new capacity. self.capacity = new_capacity while len(self.cache) > self.capacity: self.cache.popitem(last=False) # pop the first item in the dictionary (least recently used) def process_operations(operations: list[str], arguments: list[list[int]]) -> list[int]: result = [] lru_cache = None for op, args in zip(operations, arguments): if op == \\"LRUCache\\": lru_cache = LRUCache(*args) elif op == \\"put\\": lru_cache.put(*args) elif op == \\"get\\": result.append(lru_cache.get(*args)) elif op == \\"set_capacity\\": lru_cache.set_capacity(*args) return result # Example usage: if __name__ == \\"__main__\\": operations = [\\"LRUCache\\", \\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"set_capacity\\", \\"put\\", \\"get\\"] arguments = [[2], [1, 1], [2, 2], [1], [3, 3], [2], [1], [4, 4], [1]] print(process_operations(operations, arguments)) # Expected Output: [1, -1, -1]"},{"question":"# Scenario: You are tasked with designing a simple file system that supports basic file and directory operations. Each directory can contain files and other directories, and each file has a unique name within its directory. The file system should offer methods to create files, create directories, list contents, and read file contents. # Task: Implement a file system that supports the following operations. # Requirements: 1. **Initialization**: Initialize the file system with a root directory. 2. **Methods**: * `mkdir(path)`: Create a new directory at the specified path. * `add_file(path, content)`: Create a new file with specified content at the given path. * `ls(path)`: List the names of files and directories at the specified path. * `read_file(path)`: Retrieve the content of the file at the given path. 3. **Constraints**: * Directory paths and file paths use `/` as the separator. * The root directory is denoted by `/`. * File contents are strings. * Assume the length of paths and contents is reasonable for testing. # Input Format: - For `mkdir` method: * `path`: A string representing the full directory path. - For `add_file` method: * `path`: A string representing the full file path. * `content`: A string representing the content of the file. - For `ls` method: * `path`: A string representing the directory path to list. - For `read_file` method: * `path`: A string representing the full file path. # Output Format: - `ls`: A list of strings representing the names of files and directories at the specified path. - `read_file`: The string content of the specified file. - `mkdir` and `add_file`: No return value. # Example: ```python # Initializing the file system file_system = FileSystem() # Creating directories file_system.mkdir(\'/dir1\') file_system.mkdir(\'/dir1/dir2\') # Adding files file_system.add_file(\'/dir1/file1.txt\', \'Hello, world!\') file_system.add_file(\'/dir1/dir2/file2.txt\', \'This is a test.\') # Listing contents print(file_system.ls(\'/dir1\')) # Expected output: [\'dir2\', \'file1.txt\'] print(file_system.ls(\'/dir1/dir2\')) # Expected output: [\'file2.txt\'] # Reading file contents print(file_system.read_file(\'/dir1/file1.txt\')) # Expected output: \'Hello, world!\' print(file_system.read_file(\'/dir1/dir2/file2.txt\')) # Expected output: \'This is a test.\' ``` Implement the `FileSystem` class in Python with the above specifications.","solution":"class FileSystem: def __init__(self): self.root = {\'type\': \'dir\', \'content\': {}} def _find_node(self, path): parts = path.strip(\'/\').split(\'/\') node = self.root for part in parts: if part: if part in node[\'content\']: node = node[\'content\'][part] else: return None return node def mkdir(self, path): parts = path.strip(\'/\').split(\'/\') node = self.root for part in parts: if part not in node[\'content\']: node[\'content\'][part] = {\'type\': \'dir\', \'content\': {}} node = node[\'content\'][part] def add_file(self, path, content): parts = path.strip(\'/\').split(\'/\') filename = parts.pop() node = self.root for part in parts: if part not in node[\'content\']: node[\'content\'][part] = {\'type\': \'dir\', \'content\': {}} node = node[\'content\'][part] node[\'content\'][filename] = {\'type\': \'file\', \'content\': content} def ls(self, path): node = self._find_node(path) if node is None: raise FileNotFoundError(f\\"The path {path} does not exist.\\") if node[\'type\'] == \'file\': return [path.split(\'/\')[-1]] return sorted(node[\'content\'].keys()) def read_file(self, path): node = self._find_node(path) if node is None or node[\'type\'] != \'file\': raise FileNotFoundError(f\\"The file {path} does not exist.\\") return node[\'content\']"},{"question":"# Counting Connected Components in an Undirected Graph Context You are given an undirected graph represented as an adjacency list, and you need to find the number of connected components in the graph. A connected component is a subset of vertices such that there is a path between any pair of vertices in the subset, and no vertex in the subset is connected to any vertex outside it. Task Implement a function `count_connected_components(graph: Dict[int, List[int]]) -> int`. The function should take a dictionary representing the adjacency list of the graph as input and return the number of connected components. Input and Output Formats * **Input**: A dictionary `graph`, where keys are integers representing the nodes and values are lists of integers representing the nodes that are directly connected to the key node. * **Output**: An integer representing the number of connected components in the graph. Constraints * The number of nodes can be at most 1000. * The graph may have disconnected vertices. Example ```python assert count_connected_components({ 0: [1], 1: [0, 2], 2: [1], 3: [] }) == 2 assert count_connected_components({ 0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3] }) == 2 assert count_connected_components({ 0: [], 1: [], 2: [] }) == 3 ``` # Performance Requirements * The solution should be efficient enough to handle the upper limit of the input sizes within a reasonable time frame, ideally in O(n + e) time complexity, where `n` is the number of nodes and `e` is the number of edges. Notes * Consider using Depth First Search (DFS) or Breadth First Search (BFS) to traverse the graph. * Ensure that every node, even if it has no connections, is considered in the count.","solution":"def count_connected_components(graph): def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: stack.append(neighbor) visited = set() components = 0 for node in graph: if node not in visited: dfs(node) components += 1 return components"},{"question":"# Problem Statement In a database system, we often need to keep track of data insertion events and the timestamps associated with them. One efficient way to manage this is by using a binary search tree (BST) where each node contains a timestamp and an associated value. For this problem, you will implement a function to insert elements into a BST and another function to find the value associated with the nth largest timestamp. # Requirements 1. **Function Signatures**: ```python def insert_bst(root: \'Node\', timestamp: int, value: int) -> \'Node\': def find_nth_largest(root: \'Node\', n: int) -> int: ``` - **Input** for `insert_bst`: * `root`: The root node of the BST (initially `None` for the first insertion). * `timestamp`: An integer representing the timestamp of the event. * `value`: An integer representing the value associated with the timestamp. - **Output** for `insert_bst`: * Return the root node after the insertion. - **Input** for `find_nth_largest`: * `root`: The root node of the BST. * `n`: An integer representing the position (1-based) of the largest timestamp to find. - **Output** for `find_nth_largest`: * Return the value associated with the nth largest timestamp. # Details 1. For the BST: * If the timestamp is less than the current node\'s timestamp, it goes to the left child. * If the timestamp is greater than the current node\'s timestamp, it goes to the right child. * Assume all timestamps are unique for simplicity. * Each node also stores the size of its subtree to facilitate efficient nth largest retrieval. 2. You need to implement an efficient way to find the nth largest timestamp by using the subtree sizes. # Example ```python class Node: def __init__(self, timestamp: int, value: int): self.timestamp = timestamp self.value = value self.left = None self.right = None self.size = 1 # Size of the subtree including this node def test_bst_functions(): root = None root = insert_bst(root, 50, 1) root = insert_bst(root, 30, 2) root = insert_bst(root, 70, 3) root = insert_bst(root, 20, 4) root = insert_bst(root, 40, 5) root = insert_bst(root, 60, 6) root = insert_bst(root, 80, 7) assert find_nth_largest(root, 1) == 7 assert find_nth_largest(root, 2) == 3 assert find_nth_largest(root, 3) == 6 assert find_nth_largest(root, 7) == 4 if __name__ == \\"__main__\\": test_bst_functions() ``` # Constraints and Performance Requirements 1. Assume 1 <= len(nodes in BST) <= 10^5. 2. Timestamps and values are guaranteed to be integers within the range [1, 10^6]. 3. Your implementation should support efficient insertions and nth largest retrieval with logarithmic complexity. Ensure your implementation handles edge cases and maintains the efficiency of tree operations.","solution":"class Node: def __init__(self, timestamp: int, value: int): self.timestamp = timestamp self.value = value self.left = None self.right = None self.size = 1 # Size of the subtree including this node def insert_bst(root: Node, timestamp: int, value: int) -> Node: if root is None: return Node(timestamp, value) if timestamp < root.timestamp: root.left = insert_bst(root.left, timestamp, value) else: root.right = insert_bst(root.right, timestamp, value) root.size = 1 + (root.left.size if root.left else 0) + (root.right.size if root.right else 0) return root def find_nth_largest(root: Node, n: int) -> int: # Convert nth largest to nth smallest in zero-indexed k = root.size - n + 1 return find_kth_smallest(root, k) def find_kth_smallest(root: Node, k: int) -> int: left_size = root.left.size if root.left else 0 if k == left_size + 1: return root.value elif k <= left_size: return find_kth_smallest(root.left, k) else: return find_kth_smallest(root.right, k - left_size - 1)"},{"question":"# Problem Statement You are tasked with implementing a queue data structure for managing a line of customers at a service center. The queue must support typical operations and handle error conditions gracefully. **Specifications**: Implement a `Queue` class with the following methods: 1. `enqueue(data: T)`: Add an element `data` to the back of the queue. 2. `dequeue() -> T`: Remove and return the front element of the queue. 3. `front() -> T`: Return (but do not remove) the front element of the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty, `False` otherwise. 5. `is_full() -> bool`: Return `True` if the queue is full, `False` otherwise. 6. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueOverflowError*: Raised when attempting to enqueue on a full queue. - *QueueUnderflowError*: Raised when attempting to dequeue from or access the front of an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The queue should be limited by a maximum size constraint upon initialization. # Inputs: - Integer `limit`: Defines the maximum number of elements the queue can hold. - Sequence of operations requests including `enqueue`, `dequeue`, `front`, `is_empty`, `is_full`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `front`: The respective element. - For `is_empty`, `is_full`: Boolean value indicating state of queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python Q = Queue(3) Q.enqueue(10) Q.enqueue(20) print(Q.dequeue()) # Output: 10 print(Q.front()) # Output: 20 print(Q.is_empty()) # Output: False Q.enqueue(30) print(Q.is_full()) # Output: False Q.enqueue(40) Q.enqueue(50) # Raises QueueOverflowError: Too many elements ``` # Constraints: - Queue size `limit` ranges from 1 to 10^4. - Operations on the queue should be optimized for efficiency. # Task: Implement the `Queue` class described above, ensuring proper function and error handling compliance.","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit: int): self.limit = limit self.queue = [] def enqueue(self, data): if len(self.queue) >= self.limit: raise QueueOverflowError(\\"Too many elements\\") self.queue.append(data) def dequeue(self): if len(self.queue) == 0: raise QueueUnderflowError(\\"No elements to dequeue\\") return self.queue.pop(0) def front(self): if len(self.queue) == 0: raise QueueUnderflowError(\\"No elements in the queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) >= self.limit def size(self): return len(self.queue)"},{"question":"# Problem Statement You are tasked with writing a function `game_scores` that processes the results of a series of games played between various teams, and determines the final score for each team based on the provided scoring rules. Each game result is provided as a string in a specific format, and your function should correctly interpret these results to compute the total score for each team. Scoring Rules - Each team starts with a score of 0. - For each game: - If a team wins (indicated by a higher score), it gains 3 points. - If a game ends in a draw (indicated by an equal score), each team gains 1 point. - If a team loses (indicated by a lower score), it gains 0 points. Input - A list of strings, where each string represents the result of a game in the format: \\"TeamA ScoreA - ScoreB TeamB\\" - `TeamA` and `TeamB` are the names of the two teams. - `ScoreA` and `ScoreB` are the scores of `TeamA` and `TeamB` respectively. Output - A dictionary where keys are team names and values are the final scores. Constraints - The list contains up to 1000 games. - Team names consist of uppercase and lowercase letters only, with no spaces. - Scores are non-negative integers. Function Signature ```python def game_scores(game_results: list) -> dict: ``` Example Suppose the input list contains the following games: ```python [ \\"Lions 3 - 1 Snakes\\", \\"Tigers 2 - 2 Bears\\", \\"Lions 1 - 1 Bears\\", \\"Snakes 0 - 2 Tigers\\", \\"Bears 3 - 3 Snakes\\" ] ``` The final scores calculation would be: - \\"Lions 3 - 1 Snakes\\": Lions win → Lions +3, Snakes +0 - \\"Tigers 2 - 2 Bears\\": Draw → Tigers +1, Bears +1 - \\"Lions 1 - 1 Bears\\": Draw → Lions +1, Bears +1 - \\"Snakes 0 - 2 Tigers\\": Tigers win → Tigers +3, Snakes +0 - \\"Bears 3 - 3 Snakes\\": Draw → Bears +1, Snakes +1 Resulting dictionary: ```python { \\"Lions\\": 4, \\"Snakes\\": 1, \\"Tigers\\": 4, \\"Bears\\": 3 } ``` Requirements - Implement the function in Python. - Ensure the function handles tie conditions and different winning/losing scenarios. - Your function should efficiently process the list and correctly compute the scores for all teams.","solution":"def game_scores(game_results): Calculate the scores of each team based on the results of the games. Parameters: game_results (list): A list of strings where each string represents the result of a game in the format: \\"TeamA ScoreA - ScoreB TeamB\\". Returns: dict: A dictionary where the keys are team names and values are the final scores. scores = {} for game in game_results: parts = game.split() team_a = parts[0] score_a = int(parts[1]) score_b = int(parts[3]) # parts[2] is \\"-\\" team_b = parts[4] # Start scores with 0 if the team is seen for the first time if team_a not in scores: scores[team_a] = 0 if team_b not in scores: scores[team_b] = 0 # Evaluate the result of the game if score_a > score_b: scores[team_a] += 3 elif score_a < score_b: scores[team_b] += 3 else: scores[team_a] += 1 scores[team_b] += 1 return scores"},{"question":"# Coding Question Scenario You are involved in developing an application that manipulates large datasets for scientific research. One common task is to perform transformations on matrices. You are required to implement a function that efficiently transposes a given matrix. The task is to ensure the function handles both regular and irregular datasets. Problem Statement Write a function `transpose_matrix` that takes a matrix (a list of lists) as input and returns its transpose. Ensure that your function can handle both rectangular (m x n) and square (n x n) matrices. Implementation - `transpose_matrix` should accept: - A matrix represented as a list of lists, where each inner list represents a row of the matrix. - The function should return a new matrix which is the transpose of the input matrix. Input - A matrix `matrix` represented as a list of lists with variable dimensions, where each inner list represents a row and has at least one element. Output - A new matrix which is the transpose of the input matrix. Constraints - The number of rows and columns of the matrix will be between 1 and 1000. - The elements of the matrix will be integers between -1000 and 1000. Example ```python def transpose_matrix(matrix): # implementation here # Example 1 matrix = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix)) # Output: [[1, 4], [2, 5], [3, 6]] # Example 2 matrix = [ [1, 2], [3, 4], [5, 6] ] print(transpose_matrix(matrix)) # Output: [[1, 3, 5], [2, 4, 6]] ``` Ensure your implementation is efficient, especially for larger matrices, and handles edge cases such as matrices with only one row or one column seamlessly.","solution":"def transpose_matrix(matrix): Returns the transpose of the given matrix. :param matrix: List of lists where each inner list represents a row of the matrix. :return: Transposed matrix as a list of lists. if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Coding Assessment Question **Context:** You are developing a module to process lists of integers and perform various operations to verify properties and compute metrics based on list elements. One common operation needed is to determine if a list can be rearranged to form a consecutive sequence of integers. This capability is crucial for validating datasets where ordered or sequential data is essential. **Task:** Implement a function `can_form_consecutive_sequence` that checks if a given list of integers can be rearranged to form a consecutive sequence. The function should return `True` if the list can be rearranged into a consecutive sequence, and `False` otherwise. Function Signature: ```python def can_form_consecutive_sequence(lst: List[int]) -> bool: pass ``` Input: * A list of integers `lst` where the list length `0 <= len(lst) <= 10^5`. Output: * A boolean value `True` if the integers can be rearranged to form a consecutive sequence, `False` otherwise. Constraints: 1. The function should handle edge cases, such as empty lists. 2. The integers in the list can be both positive and negative. 3. Optimize for time complexity to handle large inputs efficiently. Examples: ```python >>> can_form_consecutive_sequence([1, 2, 3, 4, 5]) True >>> can_form_consecutive_sequence([4, 2, 3, 1, 6]) False >>> can_form_consecutive_sequence([10, 13, 14, 11, 12]) True >>> can_form_consecutive_sequence([7, 7, 7]) False >>> can_form_consecutive_sequence([]) False ``` **Notes:** - A consecutive sequence has the property that its elements can be sorted in order such that each subsequent number is exactly one greater than the preceding number. - The function should return `False` for duplicates as they prevent forming a valid consecutive sequence. - Consider the use of sorting or mathematical properties to check for consecutive sequences efficiently. **Hints:** - Sorting the list and checking the differences between consecutive elements is a straightforward approach. - Alternatively, checking the range of elements and comparing the set size to the list length can offer an optimized solution.","solution":"from typing import List def can_form_consecutive_sequence(lst: List[int]) -> bool: if not lst: return False if len(lst) != len(set(lst)): return False return max(lst) - min(lst) + 1 == len(lst)"},{"question":"# Problem Statement You are designing a 2D game where characters need to move between different grid cells on a map. You need to implement a function that will calculate the shortest path for a character to travel between two given cells on a grid using the Manhattan distance. The character can only move vertically or horizontally between adjacent cells. # Function Signature ```python def manhattan_distance(start: tuple[int, int], end: tuple[int, int]) -> int: Calculate the Manhattan distance between the start and end points on a grid. Parameters: start (tuple[int, int]): A tuple representing the starting cell (x, y). end (tuple[int, int]): A tuple representing the ending cell (x, y). Returns: int: The Manhattan distance between the start and end points. pass ``` # Input - **start**: A tuple representing the starting grid cell, with two integers (x, y). - **end**: A tuple representing the ending grid cell, with two integers (x, y). # Output - An integer representing the Manhattan distance between the starting and ending grid cells. # Example ```python start = (1, 2) end = (4, 6) # moving from (1, 2) to (4, 6) distance = manhattan_distance(start, end) print(distance) # Expected output: 7 ``` # Constraints - The x and y coordinates for both the start and end points will always be non-negative integers. - The input tuples will always contain valid integers within a reasonable grid size (0 <= x, y <= 10^6). # Explanation The Manhattan distance between two points (x1, y1) and (x2, y2) is given by: [ |x2 - x1| + |y2 - y1| ] This distance metric is often used in grid-based movement, such as board games, where diagonal movement is not allowed.","solution":"def manhattan_distance(start, end): Calculate the Manhattan distance between the start and end points on a grid. Parameters: start (tuple[int, int]): A tuple representing the starting cell (x, y). end (tuple[int, int]): A tuple representing the ending cell (x, y). Returns: int: The Manhattan distance between the start and end points. return abs(end[0] - start[0]) + abs(end[1] - start[1])"},{"question":"# Coding Assessment Question Context: In mathematics, the Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so forth. Task: Write a function `odd_fibonacci_sum(n: int) -> int` that returns the sum of the odd Fibonacci numbers less than or equal to `n`. Input: - `n` (1 <= n <= 10^6) Output: - An integer representing the sum of all odd Fibonacci numbers less than or equal to `n`. Function Signature: ```python def odd_fibonacci_sum(n: int) -> int: pass ``` Example: ```python assert odd_fibonacci_sum(10) == 10 # (1 + 1 + 3 + 5) assert odd_fibonacci_sum(100) == 188 # (1 + 1 + 3 + 5 + 13 + 21 + 55 + 89) ``` Constraints: - Ensure efficient calculation with a time complexity of O(log n), where `n` is the limit. - Minimize space usage, aiming for a space complexity of O(1). Notes: - Since Fibonacci numbers can grow large, be mindful of efficient integer calculations. - Consider edge cases such as the smallest possible inputs and scenarios where the largest Fibonacci number just exceeds `n`.","solution":"def odd_fibonacci_sum(n: int) -> int: Returns the sum of odd Fibonacci numbers less than or equal to n. a, b = 0, 1 odd_sum = 0 while a <= n: if a % 2 != 0: odd_sum += a a, b = b, a + b return odd_sum"},{"question":"# Problem Description You are tasked with implementing a function that determines whether a given string is a valid URL and categorize its type (either \\"Website URL\\" or \\"IP Address URL\\"). The function should handle URLs with different protocols, subdomains, and query parameters reliably. # Function Signature ```python def validate_and_categorize_url(url: str) -> str: Validate a URL and categorize it as either \\"Website URL\\" or \\"IP Address URL\\". ``` # Input * `url` (str): A string representing the URL to validate (e.g., \\"https://www.example.com\\", \\"http://192.168.1.1:8080\\"). # Output * A string indicating the type of the URL (\\"Website URL\\" or \\"IP Address URL\\"). # Constraints * The `url` parameter must be a non-empty string. * The URL validation should adhere to standard formats for URLs. * Assume the validation does not need to check the existence of the URL, only its format. # Performance Requirements * Solutions should be efficient and handle various common URL formats effectively. # Errors and Edge Cases * Raise a `ValueError` if the input is an empty string. * Return \\"Invalid URL\\" if the URL format is incorrect. * Handle various protocols (`http`, `https`, `ftp`, etc.) and optional port numbers. * Consider edge cases like URLs with query parameters and fragments. # Example ```python validate_and_categorize_url(\\"https://www.example.com/page?query=123\\") # Returns \'Website URL\' validate_and_categorize_url(\\"http://192.168.1.1:8080\\") # Returns \'IP Address URL\' validate_and_categorize_url(\\"ftp://172.20.10.2/resource\\") # Returns \'IP Address URL\' validate_and_categorize_url(\\"https://sub.example.com/path#fragment\\") # Returns \'Website URL\' validate_and_categorize_url(\\"invalid_url\\") # Returns \'Invalid URL\' ``` # Scenario Suppose you are developing a network monitoring tool that logs and categorizes URLs it encounters. This function will determine if a given URL corresponds to a domain name or an IP address, helping the system to provide more meaningful metrics and logs for network administrators.","solution":"import re def validate_and_categorize_url(url: str) -> str: Validate a URL and categorize it as either \\"Website URL\\" or \\"IP Address URL\\". if not url: raise ValueError(\\"Empty URL provided\\") url_pattern = re.compile( r\'^(https?|ftp)://\' # protocol r\'(([a-zA-Z0-9-]+.)+[a-zA-Z]{2,6}\' # domain name r\'|(d{1,3}.){3}d{1,3})\' # or IP address r\'(:d+)?\' # optional port r\'(/[^s]*)?\' # path r\'(?[^s]*)?\' # query r\'(#w*)?\' # fragment ) if re.match(url_pattern, url): domain_pattern = re.compile( r\'^(https?|ftp)://\' # protocol r\'([a-zA-Z0-9-]+.)+[a-zA-Z]{2,6}\' # domain ) ip_pattern = re.compile( r\'^(https?|ftp)://\' # protocol r\'(d{1,3}.){3}d{1,3}\' # IP address ) if re.match(domain_pattern, url): return \\"Website URL\\" elif re.match(ip_pattern, url): return \\"IP Address URL\\" else: return \\"Invalid URL\\""},{"question":"# Array Intersection Finder **Objective**: In this task, you will implement a function that reads a file containing multiple pairs of arrays and determines the intersection of each pair. # Problem Statement: You are given a text file with `n` lines, each containing two arrays of integers separated by a pipe (`|`). Your task is to determine the intersection of the two arrays for each line. An intersection of two arrays is a list of all unique elements that are present in both arrays. The result should also be sorted in ascending order. # Your Task: 1. Implement a function `array_intersection(arr1: List[int], arr2: List[int]) -> List[int]` that finds the intersection of the two given arrays and returns it as a sorted list. 2. Implement a function `find_all_intersections(filename: str = \\"arrays.txt\\") -> List[List[int]]` that reads the file `arrays.txt`, utilizes `array_intersection`, and returns a list of intersections for each pair of arrays. # Input: - `filename` (str): The name of the file containing array pairs. # Output: - Returns (List[List[int]]): A list of lists, where each sublist is the intersection of the two arrays from each line. # Constraints: - Arrays will contain integers in the range `-1000 ≤ x ≤ 1000`. - The file can have up to `10000` lines. - Each array can have up to `1000` integers. # Example: Given an example file \\"arrays_example.txt\\" with the following contents: ``` 1,2,3,4,5|4,5,6,7,8 10,9,8|8,7,6 12,14,16|18,19,20 ``` Running `find_all_intersections(\\"arrays_example.txt\\")` should return `[[4, 5], [8], []]`. # Specification: ```python from typing import List def array_intersection(arr1: List[int], arr2: List[int]) -> List[int]: Find the intersection of two arrays and return it as a sorted list. def find_all_intersections(filename: str = \\"arrays.txt\\") -> List[List[int]]: Read the file and return a list of intersections for each pair of arrays. ``` # Example: ``` # Content of arrays_example.txt 1,2,3,4,5|4,5,6,7,8 10,9,8|8,7,6 12,14,16|18,19,20 # Calling function print(find_all_intersections(\\"arrays_example.txt\\")) # Expected output [[4, 5], [8], []] ``` # Notes: * Ensure your solution handles edge cases, such as empty arrays or arrays with no intersection. * Make sure to sort each intersection result. # Testing: Provide unit tests to validate the correctness of both functions.","solution":"from typing import List def array_intersection(arr1: List[int], arr2: List[int]) -> List[int]: Find the intersection of two arrays and return it as a sorted list. # Convert both lists to sets to find the intersection set1 = set(arr1) set2 = set(arr2) # Find the intersection and convert back to a sorted list intersection = sorted(set1 & set2) return intersection def find_all_intersections(filename: str = \\"arrays.txt\\") -> List[List[int]]: Read the file and return a list of intersections for each pair of arrays. intersections = [] with open(filename, \'r\') as file: for line in file: arr1_str, arr2_str = line.strip().split(\'|\') arr1 = list(map(int, arr1_str.split(\',\'))) arr2 = list(map(int, arr2_str.split(\',\'))) intersections.append(array_intersection(arr1, arr2)) return intersections"},{"question":"# Coding Assessment Question Scenario You are assigned to create a function that can efficiently determine if a given non-negative integer is a power of two. This is important in various computer science applications, such as optimizing algorithms or managing memory allocation. Task Write a Python function named `is_power_of_two` that takes a non-negative integer and returns a boolean indicating if it is a power of two. This function should handle edge cases and incorrect input types gracefully. Function Signature ```python def is_power_of_two(number: int) -> bool: pass ``` Input - `number`: A non-negative integer to evaluate. Output - A boolean value: - `True` if the number is a power of two. - `False` otherwise. - For non-integer input types, raise a `TypeError` with an appropriate error message. Constraints - The input integer will be in the range of 0 to (10^{18}). Performance Requirements - The solution should be efficient with a time complexity of (O(1)). Examples ```python print(is_power_of_two(1)) # Should return True (2^0) print(is_power_of_two(2)) # Should return True (2^1) print(is_power_of_two(3)) # Should return False print(is_power_of_two(4)) # Should return True (2^2) print(is_power_of_two(18)) # Should return False ``` Constraints and Error Handling - If the input is not an integer or is negative, raise a `TypeError` stating \\"Input value must be a non-negative integer\\".","solution":"def is_power_of_two(number: int) -> bool: Determines if the given number is a power of two. Parameters: number (int): The number to check. Returns: bool: True if the number is a power of two, False otherwise. Raises: TypeError: If the input is not an integer or if it is negative. if not isinstance(number, int) or number < 0: raise TypeError(\\"Input value must be a non-negative integer\\") return number != 0 and (number & (number - 1)) == 0"},{"question":"# Question: Implement a Sparse Matrix Transposer Context: A sparse matrix is a matrix in which most of the elements are zero. This type of matrix is common in scientific computing when dealing with large datasets. Storing only the non-zero elements and their locations can greatly save memory. Implementing efficient operations on sparse matrices is crucial in these cases. Task: Create a function `transpose_sparse_matrix` that: 1. Takes a list of tuples as input where each tuple represents a non-zero element in the sparse matrix. Each tuple consists of four values: `(value, row_index, column_index, number_of_columns)`. 2. Returns a list of tuples representing the transposed sparse matrix, where the rows and columns of the elements have been swapped. Input: 1. A list of tuples. Each tuple is formatted as `(value, row_index, column_index, number_of_columns)` representing: - `value`: The non-zero element in the matrix. - `row_index`: The row index of the element. - `column_index`: The column index of the element. - `number_of_columns`: The number of columns in the original matrix. Output: A list of tuples where each tuple is formatted as `(value, column_index, row_index, number_of_rows)` representing the transposed element in the resulting sparse matrix. Constraints: - The input list will have at most `1000000` non-zero elements. - The values in the matrix are non-negative integers. - The number of rows and columns for the original matrix will not exceed `100000`. Example: ```python def transpose_sparse_matrix(sparse_matrix: list[tuple[int, int, int, int]]) -> list[tuple[int, int, int, int]]: # Your implementation here # Example usage: sparse_matrix = [(5, 0, 1, 3), (10, 2, 0, 3), (12, 1, 2, 3)] transposed_matrix = transpose_sparse_matrix(sparse_matrix) expected_output = [(5, 1, 0, 3), (10, 0, 2, 3), (12, 2, 1, 3)] assert transposed_matrix == expected_output ``` Performance Requirement: Ensure that your solution can handle the maximum constraints efficiently.","solution":"def transpose_sparse_matrix(sparse_matrix): Transposes a sparse matrix represented as a list of tuples. Args: sparse_matrix: list of tuples, where each tuple is (value, row_index, column_index, number_of_columns) Returns: list of tuples, where each tuple is (value, column_index, row_index, number_of_rows) transposed = [(value, col_idx, row_idx, number_of_columns) for value, row_idx, col_idx, number_of_columns in sparse_matrix] return transposed"},{"question":"# Scenario: You are building a system to track hospital patients undergoing various procedures. Each procedure has a specific priority level that dictates the order in which patients should be attended to. For efficiency, you need to manage a queue of patients where those with the highest priority are attended to first. # Task: Write a class `PatientQueue` that implements a priority queue for managing patient procedures. The class should support the following operations: - `add_patient(name: str, priority: int) -> None`: Adds a patient with the given name and priority to the queue. - `get_next_patient() -> str`: Removes and returns the name of the patient with the highest priority. # Expected Class: ```python class PatientQueue: def __init__(self): pass def add_patient(self, name: str, priority: int) -> None: pass def get_next_patient(self) -> str: pass ``` # Input Format: * `add_patient` will be called with a patient name as a string and a priority as an integer (higher numbers indicate higher priority). * `get_next_patient` will be called without any arguments. # Output Format: * `add_patient` does not return anything. * `get_next_patient` returns a string representing the name of the next patient to be attended to. # Constraints: * There will be at most 10^5 operations performed on the queue. * Priorities will be integers within the range [-10^9, 10^9]. # Example: ```python >>> pq = PatientQueue() >>> pq.add_patient(\\"Alice\\", 5) >>> pq.add_patient(\\"Bob\\", 9) >>> pq.add_patient(\\"Charlie\\", 1) >>> pq.get_next_patient() \'Bob\' >>> pq.get_next_patient() \'Alice\' >>> pq.add_patient(\\"David\\", 3) >>> pq.get_next_patient() \'David\' ``` # Notes: 1. Ensure that your queue handles patients with the same priority by attending to them in the order they were added. 2. Implement the priority queue such that it is efficient and can handle the maximum number of operations within a reasonable time.","solution":"import heapq class PatientQueue: def __init__(self): self.heap = [] self.counter = 0 # to maintain the order of insertion def add_patient(self, name: str, priority: int) -> None: # Using a min-heap, hence we use -priority to simulate a max-heap heapq.heappush(self.heap, (-priority, self.counter, name)) self.counter += 1 def get_next_patient(self) -> str: if not self.heap: return None return heapq.heappop(self.heap)[2]"},{"question":"**Scenario**: As a software developer, your next assignment is to create a utility that processes lists of integers to extract various statistics. Specifically, you\'re asked to implement a class that can compute the mean, median, and mode for a given list of integers. This will allow you to demonstrate your skills in algorithm design and handling of edge cases. **Task**: Write a class implementation named `StatisticsCalculator` with the following methods: 1. `calculate_mean(numbers: List[int]) -> float` 2. `calculate_median(numbers: List[int]) -> float` 3. `calculate_mode(numbers: List[int]) -> List[int]` Each method should: - Take a list of integers `numbers` as input. - Return the mean, median, or mode of the list. # Constraints 1. The input list `numbers` will have a length between 0 and 10,000. 2. Numbers in the list can be negative or positive integers, including zero. # Requirements 1. Ensure that the implementation handles edge cases, such as empty lists. 2. Handle multiple modes by returning them all in ascending order. 3. If the input list is empty, each method should return `None`. # Expected Input and Output Format * **calculate_mean(numbers: List[int]) -> float** - **Input**: `numbers = [1, 2, 3, 4, 5]` - **Output**: `3.0` * **calculate_median(numbers: List[int]) -> float** - **Input**: `numbers = [1, 3, 3, 6, 7, 8, 9]` - **Output**: `6.0` * **calculate_mode(numbers: List[int]) -> List[int]** - **Input**: `numbers = [1, 2, 2, 3, 4, 4, 4, 5, 5, 6, 6, 6]` - **Output**: `[4, 6]` # Performance 1. The solution should be efficient, maintaining a suitable time complexity given the input constraints.","solution":"from typing import List, Union from collections import Counter class StatisticsCalculator: @staticmethod def calculate_mean(numbers: List[int]) -> Union[float, None]: if not numbers: return None return sum(numbers) / len(numbers) @staticmethod def calculate_median(numbers: List[int]) -> Union[float, None]: if not numbers: return None n = len(numbers) sorted_numbers = sorted(numbers) mid = n // 2 if n % 2 == 0: # even number of elements return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2.0 else: # odd number of elements return float(sorted_numbers[mid]) @staticmethod def calculate_mode(numbers: List[int]) -> Union[List[int], None]: if not numbers: return None number_count = Counter(numbers) max_count = max(number_count.values()) modes = [number for number, count in number_count.items() if count == max_count] return sorted(modes)"},{"question":"# Shared File Locking System Implement a shared file-locking system that ensures multiple processes can read from a file simultaneously, but only one process can write to the file at any time. This question tests your understanding of concurrency control and file handling. Your task is to implement a class `FileLock` that manages the locking mechanism. Scenario Multiple processes need access to a shared file. Here are the rules regarding access: 1. Multiple processes can read the file at the same time. 2. Only one process can write to the file, and while writing, no other process is allowed to read or write. 3. A read operation should wait if a write operation is in progress. 4. A write operation should wait if there are any ongoing read or write operations. You need to: 1. Implement a thread-safe class `FileLock` that allows multiple processes to read and restricts writing to one process at a time. Requirements 1. `FileLock` should have methods: - `acquire_read_lock()` to acquire a read lock. - `release_read_lock()` to release a read lock. - `acquire_write_lock()` to acquire a write lock. - `release_write_lock()` to release a write lock. 2. `FileLock` should use appropriate synchronization primitives to ensure thread safety and prevent race conditions. 3. You may assume that lock operations (acquire and release) are always used in pairs correctly by the processes. Implementation ```python import threading class FileLock: def __init__(self): self.readers = 0 self.read_lock = threading.Lock() self.write_lock = threading.Lock() def acquire_read_lock(self): with self.read_lock: self.readers += 1 if self.readers == 1: self.write_lock.acquire() def release_read_lock(self): with self.read_lock: self.readers -= 1 if self.readers == 0: self.write_lock.release() def acquire_write_lock(self): self.write_lock.acquire() def release_write_lock(self): self.write_lock.release() ``` Example Usage ```python import threading import time file_lock = FileLock() def reader(id): print(f\'Reader {id} attempting to read\') file_lock.acquire_read_lock() print(f\'Reader {id} started reading\') time.sleep(2) print(f\'Reader {id} finished reading\') file_lock.release_read_lock() def writer(id): print(f\'Writer {id} attempting to write\') file_lock.acquire_write_lock() print(f\'Writer {id} started writing\') time.sleep(2) print(f\'Writer {id} finished writing\') file_lock.release_write_lock() threads = [] for i in range(3): t = threading.Thread(target=reader, args=(i,)) threads.append(t) t.start() time.sleep(0.5) w = threading.Thread(target=writer, args=(1,)) threads.append(w) w.start() for t in threads: t.join() ``` In this example: - Three readers attempt to read simultaneously. - Half a second later, a writer attempts to write. The writer waits until all readers have finished. - The `FileLock` implementation ensures that the writer only writes once all readers have finished and no other readers can read while the write operation is in progress. Your task is to ensure the `FileLock` class works correctly with the synchronization primitives used, such as locks, to manage concurrency control efficiently.","solution":"import threading class FileLock: def __init__(self): self.readers = 0 self.read_lock = threading.Lock() self.write_lock = threading.Lock() def acquire_read_lock(self): with self.read_lock: self.readers += 1 if self.readers == 1: self.write_lock.acquire() def release_read_lock(self): with self.read_lock: self.readers -= 1 if self.readers == 0: self.write_lock.release() def acquire_write_lock(self): self.write_lock.acquire() def release_write_lock(self): self.write_lock.release()"},{"question":"# Scenario A logistics company wants to optimize their route planning for frequent deliveries. They need to evaluate multiple routes and determine the shortest one based on distance. To achieve this, you\'ll need to implement a function to find the shortest path in a weighted graph. The graph is represented as an adjacency matrix where nodes represent delivery locations and edges represent direct routes between these locations, weighted by the distance between them. # Task Implement a function `find_shortest_path(graph: List[List[int]], start: int, end: int) -> List[int]` that uses Dijkstra\'s algorithm to find the shortest path between two locations in the graph. # Input * `graph` (List[List[int]]): A 2D adjacency matrix representing the weighted graph. `graph[i][j]` indicates the distance from node `i` to node `j`. A value of `float(\'inf\')` means there is no direct route between nodes. * `start` (int): The starting node for the path. * `end` (int): The destination node for the path. # Output * (List[int]): A list of node indices representing the shortest path from the `start` node to the `end` node. If no path exists, return an empty list. # Examples ```python graph = [ [0, 1, 4, float(\'inf\')], [1, 0, 2, 6], [4, 2, 0, 3], [float(\'inf\'), 6, 3, 0] ] find_shortest_path(graph, 0, 3) # Expected Output: [0, 1, 2, 3] graph = [ [0, float(\'inf\'), 1], [float(\'inf\'), 0, 2], [1, 2, 0] ] find_shortest_path(graph, 0, 1) # Expected Output: [0, 2, 1] find_shortest_path(graph, 0, 2) # Expected Output: [0, 2] find_shortest_path(graph, 1, 0) # Expected Output: [] ``` # Constraints * The graph is represented as a square matrix, so `graph` is `N x N` where `1 <= N <= 100`. * 0 <= `start`, `end` < N * All weights are non-negative integers and less than or equal to 1000. * The path should include both the starting node and the ending node. # Performance Requirements Ensure the implementation is efficient, particularly in terms of time complexity, as the matrix size can reach up to 100x100. # Additional Notes Feel free to use any standard library functions necessary, but ensure your implementation of Dijkstra\'s algorithm can effectively handle the constraints and performance requirements.","solution":"import heapq from typing import List, Tuple def find_shortest_path(graph: List[List[int]], start: int, end: int) -> List[int]: Uses Dijkstra\'s algorithm to find the shortest path in a weighted graph. N = len(graph) distances = [float(\'inf\')] * N distances[start] = 0 previous_nodes = [-1] * N priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: break if current_distance > distances[current_node]: continue for neighbor, weight in enumerate(graph[current_node]): if weight == float(\'inf\'): continue distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) path = [] current_node = end if distances[end] == float(\'inf\'): return [] while current_node != -1: path.append(current_node) current_node = previous_nodes[current_node] return path[::-1]"},{"question":"# Binary Search Tree Balancing Assessment Context You are tasked with implementing and enhancing a Binary Search Tree (BST) to ensure it stays balanced after insertions and deletions. This will help ensure comprehension of aspects related to tree operations, balancing techniques, and overall BST architecture. Task 1. **Implement AVL Tree**: - Convert an existing unbalanced Binary Search Tree (BST) class to an AVL Tree class, which is a self-balancing binary search tree. - Ensure the tree remains balanced after each insertion and deletion. 2. **Implement Rotations (Left, Right, Left-Right, Right-Left)**: - Implement tree rotations necessary to maintain AVL Tree properties after modifications (insertions or deletions). Expected Class and Methods Implementation 1. **AVL Tree Class and Rotations**: ```python class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: # Your code here def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: # Your code here def left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: # Your code here def right_rotate(self, z: AVLTreeNode) -> AVLTreeNode: # Your code here def left_right_rotate(self, z: AVLTreeNode) -> AVLTreeNode: # Your code here def right_left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: # Your code here def get_height(self, root: AVLTreeNode) -> int: # Your code here def get_balance(self, root: AVLTreeNode) -> int: # Your code here ``` Input and Output **Input**: - Operations (list of strings: \'insert\' or \'delete\') - Keys corresponding to the operations (list of integers) **Output**: - In-order traversal of the final AVL Tree\'s node values Constraints - Inputs must be valid operations and corresponding keys. - Keys for insertions and deletions should be integers. - Perform operations on a newly created AVL Tree starting from an empty tree for each run. Scenario Implement the required class and methods, then utilize them to insert and delete nodes in the tree based on provided operations. Ensure the tree remains balanced after each operation, performing the necessary rotations to maintain AVL properties. Validate your implementation to ensure correct insertions, deletions, and balance maintenance according to the AVL Tree structure.","solution":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def get_height(self, root: AVLTreeNode) -> int: return root.height if root else 0 def get_balance(self, root: AVLTreeNode) -> int: return self.get_height(root.left) - self.get_height(root.right) if root else 0 def left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = max(self.get_height(z.left), self.get_height(z.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def right_rotate(self, z: AVLTreeNode) -> AVLTreeNode: y = z.left T3 = y.right y.right = z z.left = T3 z.height = max(self.get_height(z.left), self.get_height(z.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return AVLTreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def min_value_node(self, node: AVLTreeNode) -> AVLTreeNode: if node is None or node.left is None: return node return self.min_value_node(node.left) def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return root elif key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def in_order_traversal(self, root: AVLTreeNode) -> list: res = [] if root: res = self.in_order_traversal(root.left) res.append(root.key) res = res + self.in_order_traversal(root.right) return res def process_operations(operations, keys): tree = AVLTree() root = None for op, key in zip(operations, keys): if op == \'insert\': root = tree.insert(root, key) elif op == \'delete\': root = tree.delete(root, key) return tree.in_order_traversal(root)"},{"question":"# Loops and Conditional Counters You are required to write a function that analyzes a list of integers and returns the count of even and odd integers. Your function should loop through the list and use conditional statements to determine if each integer is even or odd. Implement the function `count_even_odd(numbers: list[int]) -> dict[str, int]` with the following requirements: 1. **Inputs**: - `numbers` (list of int): A list containing integers. 2. **Output**: - A dictionary with two key-value pairs: - `\'even\'`: representing the count of even integers in the input list. - `\'odd\'`: representing the count of odd integers in the input list. 3. **Constraints**: - The list can contain a mixture of positive and negative integers, including zero. - The list can be empty, in which case both `\'even\'` and `\'odd\'` counts should be 0. 4. **Exceptions**: - Raise a `TypeError` if the input is not a list. - Raise a `ValueError` if any element in the list is not an integer. # Function Signature ```python def count_even_odd(numbers: list[int]) -> dict[str, int]: pass ``` # Examples ```python >>> count_even_odd([1, 2, 3, 4, 5]) {\'even\': 2, \'odd\': 3} >>> count_even_odd([0, -2, -4, 5, 9]) {\'even\': 3, \'odd\': 2} >>> count_even_odd([]) {\'even\': 0, \'odd\': 0} >>> count_even_odd([2, 4, 6, 8]) {\'even\': 4, \'odd\': 0} >>> count_even_odd([-1, -3, -5]) {\'even\': 0, \'odd\': 3} >>> count_even_odd(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input must be a list of integers >>> count_even_odd([1, 2, \'a\', 4]) Traceback (most recent call last): ... ValueError: All elements in the list must be integers ``` **Note**: Ensure that your function handles and raises appropriate exceptions as specified.","solution":"def count_even_odd(numbers: list[int]) -> dict[str, int]: Returns the count of even and odd integers in a given list. Parameters: numbers (list of int): A list containing integers. Returns: dict: A dictionary with keys \'even\' and \'odd\' representing the count of even and odd numbers respectively. Raises: TypeError: If the input is not a list. ValueError: If any element in the list is not an integer. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list of integers\\") even_count = 0 odd_count = 0 for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the list must be integers\\") if num % 2 == 0: even_count += 1 else: odd_count += 1 return {\'even\': even_count, \'odd\': odd_count}"},{"question":"# Database Schema Design: Bookstore Inventory Your task is to design a relational database schema for managing a bookstore\'s inventory. Similar to the provided example for managing a library system, you will define tables, fields, and relationships to effectively store and organize data about books, authors, and publishers. # Objectives - Design tables to store information about books, authors, and publishers. - Specify primary and foreign keys to establish relationships. - Ensure the schema supports efficient querying for common operations. # Specifications 1. **Tables**: - `books`: Stores details about books. - `authors`: Stores information about authors. - `publishers`: Stores information about publishers. - `book_authors`: Stores the many-to-many relationship between books and authors. 2. **Fields**: - `books`: - `book_id` (primary key) - `title` (not null) - `isbn` (unique, not null) - `publisher_id` (foreign key referencing `publishers.publisher_id`) - `publication_year` (integer) - `price` (float) - `authors`: - `author_id` (primary key) - `first_name` (not null) - `last_name` (not null) - `date_of_birth` (date) - `publishers`: - `publisher_id` (primary key) - `name` (not null) - `address` (nullable) - `phone` (nullable) - `email` (nullable) - `book_authors`: - `book_id` (foreign key referencing `books.book_id`) - `author_id` (foreign key referencing `authors.author_id`) 3. **Constraints**: - Ensure a book can have multiple authors. - Ensure an author can write multiple books. - Ensure a book can only have one publisher but a publisher can publish multiple books. - Define appropriate data types and lengths for each field. # Example Queries 1. Retrieve all books by a specific author. 2. List all publishers along with the number of books they have published. 3. Find books published in a specific year. 4. Get details of books along with their authors and publishers. # Example ```sql -- Create table for publishers CREATE TABLE publishers ( publisher_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, address VARCHAR(255), phone VARCHAR(15), email VARCHAR(100) ); -- Create table for authors CREATE TABLE authors ( author_id INT PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, date_of_birth DATE ); -- Create table for books CREATE TABLE books ( book_id INT PRIMARY KEY, title VARCHAR(255) NOT NULL, isbn VARCHAR(13) UNIQUE NOT NULL, publisher_id INT, publication_year INT, price FLOAT, FOREIGN KEY (publisher_id) REFERENCES publishers(publisher_id) ); -- Create table for book_authors CREATE TABLE book_authors ( book_id INT, author_id INT, PRIMARY KEY (book_id, author_id), FOREIGN KEY (book_id) REFERENCES books(book_id), FOREIGN KEY (author_id) REFERENCES authors(author_id) ); ``` # Hints - Use appropriate data types for fields, ensuring they match the type of data they will store. - Carefully design the relationships to avoid data redundancy and ensure data integrity. - Consider indexing frequently queried fields to enhance performance. # Sample Usage - Use the designed schema to store information about books, their authors, and publishers. - Query the database to retrieve information effectively and efficiently. # Expected Output - The SQL script should create tables with the specified fields and constraints. - The database should allow for efficient data storage and retrieval for a bookstore inventory management system.","solution":"def create_bookstore_schema(): schema_script = -- Create table for publishers CREATE TABLE publishers ( publisher_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, address VARCHAR(255), phone VARCHAR(15), email VARCHAR(100) ); -- Create table for authors CREATE TABLE authors ( author_id INT PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, date_of_birth DATE ); -- Create table for books CREATE TABLE books ( book_id INT PRIMARY KEY, title VARCHAR(255) NOT NULL, isbn VARCHAR(13) UNIQUE NOT NULL, publisher_id INT, publication_year INT, price FLOAT, FOREIGN KEY (publisher_id) REFERENCES publishers(publisher_id) ); -- Create table for book_authors CREATE TABLE book_authors ( book_id INT, author_id INT, PRIMARY KEY (book_id, author_id), FOREIGN KEY (book_id) REFERENCES books(book_id), FOREIGN KEY (author_id) REFERENCES authors(author_id) ); return schema_script"},{"question":"# Integer to Roman Numerals Conversion Context In this problem, you are required to implement a function that converts a given non-negative integer into its corresponding Roman numeral representation. Roman numerals are usually written from largest to smallest from left to right, allowing for a standardized way of forming numbers. Task Description You need to complete the function `int_to_roman` which takes a non-negative integer as input and returns a string representing the Roman numeral of the input integer. Input - An integer `num` where (0 leq text{num} leq 3999). Output - A string representing the Roman numeral of the given integer. Constraints - The Roman numeral for zero does not exist, so ensure the function returns an empty string for the input 0. Examples ```python >>> int_to_roman(58) \'LVIII\' >>> int_to_roman(1994) \'MCMXCIV\' >>> int_to_roman(0) \'\' >>> int_to_roman(3999) \'MMMCMXCIX\' ``` Notes Roman numerals are formed using the following characters and values: - \'I\': 1 - \'V\': 5 - \'X\': 10 - \'L\': 50 - \'C\': 100 - \'D\': 500 - \'M\': 1000 To generate the Roman numeral of a number, we need to handle specific repetitions and substractions according to the rules of Roman numeral formation, e.g., IV (4), IX (9), XL (40), XC (90), CD (400), and CM (900).","solution":"def int_to_roman(num): Converts a given non-negative integer into its corresponding Roman numeral representation. if num == 0: return \\"\\" # Mapping of integer values to their corresponding Roman numeral representations val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: roman_numeral += symbols[i] num -= val[i] return roman_numeral"},{"question":"# Coding Assessment Question: Scenario: As the lead developer, you are responsible for optimizing a text document processing pipeline where you\'re often required to handle large chunks of text. An important task in your pipeline is finding the longest substring in a given string that contains all unique characters. Task: Write a function `longest_unique_substring(s)` that finds the longest substring of the input string `s` which contains all unique characters. Function Specifications: 1. **Function**: longest_unique_substring - **Input**: - `s` (str): The input string in which to find the substring. - **Output**: - (str): The longest substring with all unique characters. - **Performance Considerations**: - Efficiency is key, especially for very long strings. Constraints: - `0 <= len(s) <= 10^6` - `s` only contains printable ASCII characters. # Example: ```python input_string = \\"abcabcbb\\" result = longest_unique_substring(input_string) print(result) # Expected output is \\"abc\\" input_string = \\"bbbbb\\" result = longest_unique_substring(input_string) print(result) # Expected output is \\"b\\" input_string = \\"pwwkew\\" result = longest_unique_substring(input_string) print(result) # Expected output is \\"wke\\" ``` **Hint**: Consider using a sliding window approach to efficiently solve the problem. Keep track of characters in the current window and adjust the window when a duplicate character is found to maintain the uniqueness constraint.","solution":"def longest_unique_substring(s): Finds the longest substring with all unique characters. char_index_map = {} left = 0 max_length = 0 start = 0 for right in range(len(s)): if s[right] in char_index_map and char_index_map[s[right]] >= left: left = char_index_map[s[right]] + 1 char_index_map[s[right]] = right if right - left + 1 > max_length: max_length = right - left + 1 start = left return s[start:start + max_length]"},{"question":"# Context You are tasked with writing a function that analyzes a list of student grades to provide summary statistics useful for understanding their performance. This function should be able to calculate the average grade, the highest grade, the lowest grade, and the median grade. # Task Implement a function `analyze_grades` that takes a list of grades and computes the following summary statistics: * **Average grade**: The mean of the grades. * **Highest grade**: The maximum grade. * **Lowest grade**: The minimum grade. * **Median grade**: The middle value when the grades are sorted. If the list contains an even number of grades, the median is the average of the two middle values. # Requirements * **Input**: * `grades` (list of floats): A list of numerical grades. * **Output**: * A dictionary with keys `{\\"average\\", \\"highest\\", \\"lowest\\", \\"median\\"}` and corresponding values representing the computed statistics. * **Constraints**: * The input list must contain at least one grade. * If the input list is empty, raise a `ValueError` with a message indicating that the list must not be empty. * **Performance**: The function should handle lists with up to 100,000 grades efficiently. # Example ```python def analyze_grades(grades: list) -> dict: Analyze a list of grades to provide summary statistics. Parameters: grades : list : A list of numerical grades. Returns: dict: A dictionary containing the average, highest, lowest, and median grades. Raises: ValueError: If the `grades` list is empty. Example: >>> analyze_grades([85, 92, 76, 88, 100, 69]) {\'average\': 85.0, \'highest\': 100.0, \'lowest\': 69.0, \'median\': 86.5} >>> analyze_grades([50]) {\'average\': 50.0, \'highest\': 50.0, \'lowest\': 50.0, \'median\': 50.0} >>> analyze_grades([]) ValueError: The list of grades must not be empty. # Your implementation here pass # Test cases print(analyze_grades([85, 92, 76, 88, 100, 69])) # Output: {\'average\': 85.0, \'highest\': 100.0, \'lowest\': 69.0, \'median\': 86.5} print(analyze_grades([50])) # Output: {\'average\': 50.0, \'highest\': 50.0, \'lowest\': 50.0, \'median\': 50.0} print(analyze_grades([70, 80, 90])) # Output: {\'average\': 80.0, \'highest\': 90.0, \'lowest\': 70.0, \'median\': 80.0} ```","solution":"def analyze_grades(grades): Analyze a list of grades to provide summary statistics. Parameters: grades : list : A list of numerical grades. Returns: dict: A dictionary containing the average, highest, lowest, and median grades. Raises: ValueError: If the `grades` list is empty. if not grades: raise ValueError(\\"The list of grades must not be empty.\\") n = len(grades) grades_sorted = sorted(grades) average = sum(grades) / n highest = max(grades) lowest = min(grades) if n % 2 == 1: median = grades_sorted[n // 2] else: median = (grades_sorted[n // 2 - 1] + grades_sorted[n // 2]) / 2 return { \\"average\\": average, \\"highest\\": highest, \\"lowest\\": lowest, \\"median\\": median }"},{"question":"# Coding Assessment Question E-commerce platforms frequently need to recommend products to users based on various criteria, including purchase history and product ratings. To streamline this, data structures can facilitate quick and efficient product lookups. # Problem Context: You are managing an e-commerce database that keeps track of user reviews for products. Each product can be reviewed by multiple users, and each review consists of a rating from 1 to 5. Your task is to design a function that returns products based on a specified minimum average rating. # Task: 1. **Function Definition**: Create a function `filter_products_by_rating` that takes a dictionary of products with their reviews and a float representing the minimum average rating, then returns a list of product IDs meeting or exceeding this minimum average rating. 2. **Input**: - `reviews (dict)`: A dictionary where keys are product IDs (strings) and values are lists of integers representing ratings. - `min_avg_rating (float)`: A float representing the minimum average rating threshold. 3. **Output**: - A list of strings representing product IDs that meet or exceed the specified minimum average rating. The list should be sorted in ascending order of product IDs. 4. **Constraints**: - Every product will have at least one rating. - Ratings will range from 1 to 5. - Product IDs are unique and consist of alphanumeric characters. - The dictionary `reviews` can have up to 10^5 product entries, and each product can have up to 10^3 ratings. # Example Scenarios: Example 1: ```python reviews = { \\"p1\\": [5, 4, 4, 5], \\"p2\\": [3, 2, 4], \\"p3\\": [5, 5, 5], \\"p4\\": [1, 1, 1, 1] } min_avg_rating = 4.0 filter_products_by_rating(reviews, min_avg_rating) -> [\\"p1\\", \\"p3\\"] ``` Explanation: Products \\"p1\\" and \\"p3\\" have average ratings of 4.5 and 5.0, respectively, which meet the minimum average rating of 4.0. Example 2: ```python reviews = { \\"a34\\": [2, 3, 4], \\"b56\\": [4, 4, 4], \\"c78\\": [3, 3], \\"d12\\": [5, 5, 5, 4] } min_avg_rating = 4.0 filter_products_by_rating(reviews, min_avg_rating) -> [\\"b56\\", \\"d12\\"] ``` Explanation: Products \\"b56\\" and \\"d12\\" both have average ratings equal to or above 4.0. # Performance Considerations: - Ensure the function can handle large datasets efficiently. - Make sure the calculation of average ratings and filtering operations are optimized. # Implementation Guide: 1. Initialize an empty list to store product IDs that meet or exceed the minimum average rating. 2. Iterate through the `reviews` dictionary, compute the average rating for each product, and compare it with `min_avg_rating`. 3. Append products with average ratings meeting the threshold to the result list. 4. Sort the resulting product IDs before returning them. # Constraints Simulation: Account for edge cases such as products with minimal ratings, varying numbers of reviews per product, and the maximum constraints for both the number of products and reviews. Ensure the function remains performant and accurate under these conditions. Implement and test the `filter_products_by_rating` function to verify correctness and performance.","solution":"def filter_products_by_rating(reviews, min_avg_rating): Returns a list of product IDs that meet or exceed the specified minimum average rating. :param reviews: dict where keys are product IDs and values are lists of integers representing ratings. :param min_avg_rating: float representing the minimum average rating threshold. :return: list of strings representing product IDs. result = [] for product_id, ratings in reviews.items(): avg_rating = sum(ratings) / len(ratings) if avg_rating >= min_avg_rating: result.append(product_id) return sorted(result)"},{"question":"# Question: Zigzag Conversion Context The zigzag conversion is a process used to rearrange characters of a string in a zigzag pattern on a number of rows. After writing out the rows, the characters are read from left to right to get the final converted string. Task You need to implement a function `convert_zigzag` that converts a given string into a zigzag pattern on a given number of rows. Requirements 1. **Function Name**: `convert_zigzag` 2. **Input**: - `s`: A string consisting of alphanumeric characters. - `num_rows`: An integer representing the number of rows. 3. **Output**: - Returns a string that represents the given string `s` after it has been written in a zigzag pattern on `num_rows` rows. Constraints * The string `s` will have at least one character and at most 1000 characters. * The `num_rows` will be a positive integer no larger than 1000. * If `num_rows` is 1, return the original string. Performance Requirements The implemented function should have an optimal time complexity relative to the constraints. Function Signature ```python def convert_zigzag(s, num_rows): pass ``` Example ```python # Example 1: s = \\"PAYPALISHIRING\\" num_rows = 3 # Output: \\"PAHNAPLSIIGYIR\\" # Explanation: # P A H N # A P L S I I G # Y I R # Example 2: s = \\"HELLO\\" num_rows = 2 # Output: \\"HLOEL\\" # Explanation: # H L O # E L # Example 3: s = \\"ABC\\" num_rows = 1 # Output: \\"ABC\\" # Explanation: # There is only one row, so the output is the original string. ``` # Notes * Implement the function efficiently, ensuring to consider edge cases such as when `num_rows` is one. * Assume the function will be tested with various inputs to ensure correctness and efficiency.","solution":"def convert_zigzag(s, num_rows): if num_rows == 1 or num_rows >= len(s): return s rows = [\'\'] * num_rows current_row = 0 going_down = False for c in s: rows[current_row] += c if current_row == 0 or current_row == num_rows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"# Matrix Chain Multiplication using Dynamic Programming **Context**: You need to solve the Matrix Chain Multiplication (MCM) problem using dynamic programming. The objective is to determine the most efficient way to multiply a given sequence of matrices. The problem is not to perform the multiplications, but to decide the order in which the multiplications should be performed. # Your Task: Implement the core components of the dynamic programming solution for the Matrix Chain Multiplication problem: 1. **Matrix Chain Order**: Write a function to determine the minimum number of scalar multiplications needed to multiply the sequence of matrices and find the optimal parenthesization using dynamic programming. 2. **Optimal Parenthesization**: Write a function to reconstruct the optimal parenthesization from the computed cost table and split table. # Function Signatures: ```python def matrix_chain_order(dims: list[int]) -> tuple[list[list[int]], list[list[int]]]: pass def optimal_parenthesization(s: list[list[int]], i: int, j: int) -> str: pass def main(dims: list[int]) -> tuple[int, str]: pass ``` # Constraints: 1. The length of `dims` will not exceed 100. 2. Each element of `dims` will be a positive integer in the range [1, 1000]. 3. The number of matrices, `n`, is `len(dims) - 1`. # Input/Output Format: - **Input**: - `dims`: A list of integers where `dims[i]` is the number of rows of the matrix `i`, and `dims[i+1]` is the number of columns of the matrix `i`. - **Output**: - A tuple containing: - `min_cost`: The minimum number of scalar multiplications needed to multiply the sequence of matrices. - `opt_parenthesis`: A string representing the optimal parenthesization of the matrices. # Example: ```python dims = [30, 35, 15, 5, 10, 20, 25] min_cost, opt_parenthesis = main(dims=dims) print(f\\"Minimum Cost: {min_cost}\\") print(f\\"Optimal Parenthesization: {opt_parenthesis}\\") ``` # Explanation: For the given example, the optimal parenthesization and minimum cost would be computed as follows: - `min_cost` would be the minimum number of scalar multiplications, for example, 15125. - `opt_parenthesis` would be the optimal way to parenthesize the sequence of matrices, such as \\"((A1(A2A3))((A4A5)A6))\\". # Guidelines: Use dynamic programming to compute the minimum cost and the optimal parenthesization. The main function should utilize the helper functions to return the desired output.","solution":"def matrix_chain_order(dims): Computes the minimum cost and splits for matrix chain multiplication. Args: dims (list[int]): List of dimensions where the i-th matrix has dimensions dims[i-1] x dims[i]. Returns: tuple: A tuple containing two lists: 1. m: A 2D list where m[i][j] is the minimum number of scalar multiplications needed to compute the product of matrices Ai through Aj. 2. s: A 2D list where s[i][j] is the index at which the optimal split occurs. n = len(dims) - 1 m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n + 1): # l is the chain length for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def optimal_parenthesization(s, i, j): Constructs the optimal parenthesization of matrices. Args: s (list[list[int]]): The split matrix to reconstruct the optimal parenthesization. i (int): Starting index. j (int): Ending index. Returns: str: The optimal parenthesization as a string. if i == j: return f\\"A{i+1}\\" else: left = optimal_parenthesization(s, i, s[i][j]) right = optimal_parenthesization(s, s[i][j] + 1, j) return f\\"({left}{right})\\" def main(dims): m, s = matrix_chain_order(dims) n = len(dims) - 1 min_cost = m[0][n - 1] opt_parenthesis = optimal_parenthesization(s, 0, n - 1) return min_cost, opt_parenthesis # Example usage: dims = [30, 35, 15, 5, 10, 20, 25] min_cost, opt_parenthesis = main(dims=dims) print(f\\"Minimum Cost: {min_cost}\\") print(f\\"Optimal Parenthesization: {opt_parenthesis}\\")"},{"question":"# Problem Description Implement a function that determines if a given word can be constructed from a series of consecutive cells in a grid. You can move horizontally or vertically to adjacent cells and each cell can only be used once. The word must be constructed by following adjacent cells without revisiting any cell. # Function Signature ```python def exist(board: list[list[str]], word: str) -> bool: Checks if the given word exists in the board by moving horizontally or vertically to adjacent cells. Parameters: board (list[list[str]]): 2D grid of characters word (str): The word to search for Returns: bool: True if the word exists in the grid by traversing adjacent cells, False otherwise ``` # Input * A 2D list of characters `board` representing the grid. * A string `word`. # Output * A boolean value indicating whether the word can be constructed by sequentially connecting adjacent cells. # Constraints * `1 <= len(board), len(board[i]) <= 200` * `1 <= len(word) <= 10^5` * The length of all words in the board and the word to search for will always be greater than one. # Requirements * Implement the function to efficiently search for the word in the grid. * Optimize the search to handle large grids and words within the constraints. # Example ```python # Example 1 board1 = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] word1 = \\"ABCCED\\" print(exist(board1, word1)) # Expected Output: True # Example 2 board2 = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] word2 = \\"SEE\\" print(exist(board2, word2)) # Expected Output: True # Example 3 board3 = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] word3 = \\"ABCB\\" print(exist(board3, word3)) # Expected Output: False ``` # Instructions 1. Implement the `exist` function which performs a search to determine if the word exists in the grid. 2. Ensure the function handles large inputs efficiently. 3. Make sure to consider edge cases where the word cannot be constructed or when all constraints are met.","solution":"def exist(board, word): def backtrack(x, y, word): if len(word) == 0: return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[0]: return False temp = board[x][y] board[x][y] = \\"#\\" res = (backtrack(x + 1, y, word[1:]) or backtrack(x - 1, y, word[1:]) or backtrack(x, y + 1, word[1:]) or backtrack(x, y - 1, word[1:])) board[x][y] = temp return res for i in range(len(board)): for j in range(len(board[0])): if backtrack(i, j, word): return True return False"},{"question":"# Array Left Rotation Description Given an array of integers and a number `d`, implement a function that performs a left rotation on the array `d` times. A single left rotation operation moves the first element of the array to the end of the array. Your function should handle various edge cases appropriately, including empty arrays and negative values for `d`. Function Signature ```python def left_rotate_array(arr: list, d: int) -> list: pass ``` Input * `arr` (list of int): The array to be rotated. * `d` (int): The number of left rotations to perform. Output * (list of int): The array after performing `d` left rotations. Constraints * 0 ≤ len(arr) ≤ 10^5 * −10^3 ≤ arr[i] ≤ 10^3 * −10^5 ≤ d ≤ 10^5 Examples ```python # Example 1 left_rotate_array([1, 2, 3, 4, 5], 2) # should return [3, 4, 5, 1, 2] # Example 2 left_rotate_array([1, 2, 3, 4, 5], 5) # should return [1, 2, 3, 4, 5] # Example 3 left_rotate_array([1, 2, 3, 4, 5], 7) # should return [3, 4, 5, 1, 2] # Example 4 left_rotate_array([], 3) # should return [] # Example 5 left_rotate_array([1, 2, 3, 4, 5], -2) # should return [4, 5, 1, 2, 3] ``` Notes 1. If `d` is negative, perform right rotations (equivalent to a left rotation with `len(arr) - d`). 2. Handle cases where `d` is larger than the length of the array by reducing `d` modulo the length of the array. 3. Consider edge cases such as an empty array or when `d` is zero, which should return the array unchanged.","solution":"def left_rotate_array(arr: list, d: int) -> list: Rotates the array \'arr\' to the left \'d\' times. For negative \'d\', it rotates the array to the right \'-d\' times. if not arr: # if the array is empty, return it unchanged return arr n = len(arr) # Normalize d to be within the bounds of the array length d = d % n # if d is positive d = d + n if d < 0 else d % n # if d is negative, making it positive return arr[d:] + arr[:d]"},{"question":"# Question: Rotten Oranges You are given a 2D grid where each cell can have one of three possible values: - `0` representing an empty cell, - `1` representing a fresh orange, or - `2` representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Write a function `orangesRotting(grid)` that returns the minimum number of minutes that must pass until no cell has a fresh orange. If it is impossible to rot all the fresh oranges, return `-1`. Input: * A 2D list `grid` where `grid[i][j]` is the state of the cell. The grid will have a number of rows and columns between 1 and 100. Output: * An integer representing the number of minutes required to rot all fresh oranges, or `-1` if it\'s impossible to rot all the fresh oranges. Example: ```python grid = [ [2, 1, 1], [1, 1, 0], [0, 1, 1] ] assert orangesRotting(grid) == 4 ``` Explanation: The process of rotting is as follows: - Minute 0: `[[2, 1, 1], [1, 1, 0], [0, 1, 1]]` - Minute 1: `[[2, 2, 1], [2, 1, 0], [0, 1, 1]]` - Minute 2: `[[2, 2, 2], [2, 2, 0], [0, 1, 1]]` - Minute 3: `[[2, 2, 2], [2, 2, 0], [0, 2, 1]]` - Minute 4: `[[2, 2, 2], [2, 2, 0], [0, 2, 2]]` Constraints: * There may be multiple rotten oranges at the start and adjacent to fresh oranges. * The grid can have only one row, one column, or multiple rows and columns. Hint: Consider using a breadth-first search (BFS) approach starting from all initially rotten oranges simultaneously.","solution":"from collections import deque def orangesRotting(grid): rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Initialize the queue with all rotten oranges # and count the fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # If there are no fresh oranges, return 0 if fresh_oranges == 0: return 0 # Directions for moving in the grid directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] minutes_passed = 0 # BFS to rot the adjacent fresh oranges while queue and fresh_oranges > 0: minutes_passed += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny)) # If there are still fresh oranges left, return -1 return -1 if fresh_oranges > 0 else minutes_passed"},{"question":"**Question: Create a Comprehensive Library Management System with Object-Oriented Principles** # Objective Develop a Library Management System (LMS) that handles the main operations of a library using object-oriented programming (OOP) concepts. Your implementation should focus on extendability, code clarity, and efficient management of library resources. # Requirements 1. **Book Management**: * Implement a `Book` class containing attributes such as title, author, ISBN, and availability status. * Provide methods to add, remove, update, and search for books. 2. **Member Management**: * Implement a `Member` class with attributes such as member ID, name, and the list of borrowed books. * Provide methods to add, remove, and update member information. 3. **Borrow and Return Operations**: * Implement methods to borrow and return books. Ensure the system checks book availability and updates the status accordingly. * Maintain a record of books currently borrowed by each member. 4. **Library Catalog**: * Implement a class `LibraryCatalog` that manages collections of books and members. * Provide methods to interact with and manipulate the library\'s catalog, including searching for books and members. 5. **Search Functionality**: * Implement search functions that allow searching books by title, author, and ISBN. * Implement search functions that allow searching members by member ID and name. # Input/Output Specification 1. **Input**: * `books`: A list of dictionaries, each describing a book (with keys like title, author, ISBN). * `members`: A list of dictionaries, each describing a member (with keys like member ID and name). 2. **Output**: * Methods for book and member management should print appropriate messages upon execution (like book added, member removed, etc.). * Borrow and return operations should print the status (e.g., book borrowed or book returned successfully). # Constraints * Ensure your implementation is extendable to include additional features in the future. * Follow OOP best practices, making the code modular and reusable. * Properly handle potential errors in borrow and return operations (e.g., trying to borrow a non-existent book). # Implementation Details 1. **Book Class**: * Attributes: title (string), author (string), ISBN (string), available (boolean). * Methods: `__init__()`, `update_availability()`. 2. **Member Class**: * Attributes: member_id (string), name (string), borrowed_books (list of Book objects). * Methods: `__init__()`, `borrow_book()`, `return_book()`. 3. **LibraryCatalog Class**: * Attributes: books (list of Book objects), members (list of Member objects). * Methods: `__init__()`, `add_book()`, `remove_book()`, `add_member()`, `remove_member()`, `search_book()`, `search_member()`, `borrow_book()`, `return_book()`. # Sample Code ```python class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.available = True def update_availability(self, availability): self.available = availability print(f\\"Book \'{self.title}\' availability updated to {\'available\' if self.available else \'unavailable\'}.\\") class Member: def __init__(self, member_id, name): self.member_id = member_id self.name = name self.borrowed_books = [] def borrow_book(self, book): if book.available: self.borrowed_books.append(book) book.update_availability(False) print(f\\"Book \'{book.title}\' borrowed by {self.name}.\\") else: print(f\\"Book \'{book.title}\' is not available.\\") def return_book(self, book): if book in self.borrowed_books: self.borrowed_books.remove(book) book.update_availability(True) print(f\\"Book \'{book.title}\' returned by {self.name}.\\") else: print(f\\"Book \'{book.title}\' not borrowed by {self.name}.\\") class LibraryCatalog: def __init__(self): self.books = [] self.members = [] def add_book(self, title, author, isbn): book = Book(title, author, isbn) self.books.append(book) print(f\\"Book \'{title}\' added to the catalog.\\") def remove_book(self, isbn): for book in self.books: if book.isbn == isbn: self.books.remove(book) print(f\\"Book \'{book.title}\' removed from the catalog.\\") return print(f\\"No book with ISBN \'{isbn}\' found in the catalog.\\") def add_member(self, member_id, name): member = Member(member_id, name) self.members.append(member) print(f\\"Member \'{name}\' added to the library.\\") def remove_member(self, member_id): for member in self.members: if member.member_id == member_id: self.members.remove(member) print(f\\"Member \'{member.name}\' removed from the library.\\") return print(f\\"No member with ID \'{member_id}\' found in the library.\\") def search_book(self, title=None, author=None, isbn=None): if title: books = [book for book in self.books if book.title == title] elif author: books = [book for book in self.books if book.author == author] elif isbn: books = [book for book in self.books if book.isbn == isbn] else: books = [] if books: for book in books: print(f\\"Found book: {book.title} by {book.author} (ISBN: {book.isbn}).\\") else: print(\\"No books found.\\") def search_member(self, member_id=None, name=None): if member_id: members = [member for member in self.members if member.member_id == member_id] elif name: members = [member for member in self.members if member.name == name] else: members = [] if members: for member in members: print(f\\"Found member: {member.name} (Member ID: {member.member_id}).\\") else: print(\\"No members found.\\") def borrow_book(self, member_id, isbn): member = next((m for m in self.members if m.member_id == member_id), None) book = next((b for b in self.books if b.isbn == isbn), None) if member and book: member.borrow_book(book) else: print(\\"Member or book not found.\\") def return_book(self, member_id, isbn): member = next((m for m in self.members if m.member_id == member_id), None) book = next((b for b in self.books if b.isbn == isbn), None) if member and book: member.return_book(book) else: print(\\"Member or book not found.\\") # Example Usage catalog = LibraryCatalog() catalog.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") catalog.add_member(\\"1\\", \\"John Doe\\") catalog.borrow_book(\\"1\\", \\"1234567890\\") catalog.return_book(\\"1\\", \\"1234567890\\") ``` # Submission * Provide complete and functional code for the `Book`, `Member`, and `LibraryCatalog` classes. * Ensure necessary methods are implemented and work as specified. * Include example usage and ensure your code is modular and well-documented.","solution":"class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.available = True def update_availability(self, availability): self.available = availability print(f\\"Book \'{self.title}\' availability updated to {\'available\' if self.available else \'unavailable\'}.\\") class Member: def __init__(self, member_id, name): self.member_id = member_id self.name = name self.borrowed_books = [] def borrow_book(self, book): if book.available: self.borrowed_books.append(book) book.update_availability(False) print(f\\"Book \'{book.title}\' borrowed by {self.name}.\\") else: print(f\\"Book \'{book.title}\' is not available.\\") def return_book(self, book): if book in self.borrowed_books: self.borrowed_books.remove(book) book.update_availability(True) print(f\\"Book \'{book.title}\' returned by {self.name}.\\") else: print(f\\"Book \'{book.title}\' not borrowed by {self.name}.\\") class LibraryCatalog: def __init__(self): self.books = [] self.members = [] def add_book(self, title, author, isbn): book = Book(title, author, isbn) self.books.append(book) print(f\\"Book \'{title}\' added to the catalog.\\") def remove_book(self, isbn): for book in self.books: if book.isbn == isbn: self.books.remove(book) print(f\\"Book \'{book.title}\' removed from the catalog.\\") return print(f\\"No book with ISBN \'{isbn}\' found in the catalog.\\") def add_member(self, member_id, name): member = Member(member_id, name) self.members.append(member) print(f\\"Member \'{name}\' added to the library.\\") def remove_member(self, member_id): for member in self.members: if member.member_id == member_id: self.members.remove(member) print(f\\"Member \'{member.name}\' removed from the library.\\") return print(f\\"No member with ID \'{member_id}\' found in the library.\\") def search_book(self, title=None, author=None, isbn=None): if title: books = [book for book in self.books if book.title.lower() == title.lower()] elif author: books = [book for book in self.books if book.author.lower() == author.lower()] elif isbn: books = [book for book in self.books if book.isbn == isbn] else: books = [] if books: for book in books: print(f\\"Found book: {book.title} by {book.author} (ISBN: {book.isbn}).\\") else: print(\\"No books found.\\") def search_member(self, member_id=None, name=None): if member_id: members = [member for member in self.members if member.member_id == member_id] elif name: members = [member for member in self.members if member.name.lower() == name.lower()] else: members = [] if members: for member in members: print(f\\"Found member: {member.name} (Member ID: {member.member_id}).\\") else: print(\\"No members found.\\") def borrow_book(self, member_id, isbn): member = next((m for m in self.members if m.member_id == member_id), None) book = next((b for b in self.books if b.isbn == isbn), None) if member and book: member.borrow_book(book) else: print(\\"Member or book not found.\\") def return_book(self, member_id, isbn): member = next((m for m in self.members if m.member_id == member_id), None) book = next((b for b in self.books if b.isbn == isbn), None) if member and book: member.return_book(book) else: print(\\"Member or book not found.\\")"},{"question":"You are required to implement a function that computes the Greatest Common Divisor (GCD) of an array of integers using the Euclidean algorithm. Specifically, implement a function that takes a list of integers and returns their GCD. # Function Signature: ```python def gcd_of_array(nums: List[int]) -> int: Calculate the GCD of an array of integers using the Euclidean algorithm. ``` # Inputs: - `nums`: A list of integers. The list will have at least one integer. # Output: - Returns the GCD of the list of integers. # Example: ```python >>> gcd_of_array([24, 36, 48]) 12 >>> gcd_of_array([5, 10, 15]) 5 >>> gcd_of_array([17, 19, 23]) 1 >>> gcd_of_array([27]) 27 ``` # Constraints: - The list `nums` will have at least one integer. - Each integer in the list will be a positive integer and will not exceed [10^6]. # Performance Requirements: - The function should be efficient, particularly for larger lists up to [10^4] elements. # Note: - Utilize the Euclidean algorithm for computing the GCD. - You may use a helper function to compute the GCD of two integers if needed. Here is a pythonic hint for the GCD algorithm: ```python def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a ```","solution":"from typing import List def gcd(a: int, b: int) -> int: Helper function to compute the GCD of two integers using the Euclidean algorithm. while b: a, b = b, a % b return a def gcd_of_array(nums: List[int]) -> int: Calculate the GCD of an array of integers using the Euclidean algorithm. if not nums: raise ValueError(\\"Empty list is not allowed\\") current_gcd = nums[0] for num in nums[1:]: current_gcd = gcd(current_gcd, num) return current_gcd"},{"question":"**Context**: Your task is to refactor a system that processes client transactions. The current method employs a single-threaded approach, processing one transaction at a time. This has led to significant processing delays. Your aim is to improve the performance and reduce latency by implementing a multithreaded solution that processes multiple transactions concurrently. **Objective**: Implement a multithreaded transaction processing system using the `ThreadPoolExecutor` from the `concurrent.futures` module. **Requirements**: 1. **Function Signature**: ```python import concurrent.futures def process_transactions(transaction_list: List[Tuple[int, str, float]], max_workers: int) -> List[str]: ... ``` 2. **Functionality**: * Process each transaction concurrently using multiple threads. * Each transaction is represented as a tuple `(transaction_id, transaction_type, amount)`. * Assume `transaction_type` is either \\"deposit\\" or \\"withdrawal\\". 3. **Implementation Details**: * Use `ThreadPoolExecutor` to manage thread pools for concurrent processing. * Implement a function that processes a single transaction and returns a result string. * Aggregate the results in the order corresponding to the input list. # Input and Output Formats * **Input**: * `transaction_list` (List[Tuple[int, str, float]]): A list where each item is a tuple representing a transaction with: - `transaction_id` (int): Unique identifier for the transaction. - `transaction_type` (str): Type of transaction (\\"deposit\\" or \\"withdrawal\\"). - `amount` (float): The amount to be processed in the transaction. * `max_workers` (int): Maximum number of worker threads to use for concurrent processing. * **Output**: * List of result strings corresponding to the processed transactions. # Constraints 1. `transaction_list` contains between 1 and 100 transactions. 2. `max_workers` is a positive integer not greater than 10. 3. `transaction_type` is always either \\"deposit\\" or \\"withdrawal\\". 4. `amount` is a positive float value. **You should focus on**: * Efficiently managing thread pools to process transactions concurrently. * Ensuring that the results are collected and returned in an appropriate manner. * Handling any potential issues arising from concurrent execution safely. # Example Given the transaction list: ```python transactions = [ (1, \\"deposit\\", 100.0), (2, \\"withdrawal\\", 50.0), (3, \\"deposit\\", 200.0), ] max_workers = 2 ``` Expected output: ``` [\\"Transaction 1: deposit 100.0 processed\\", \\"Transaction 2: withdrawal 50.0 processed\\", \\"Transaction 3: deposit 200.0 processed\\"] ```","solution":"from concurrent.futures import ThreadPoolExecutor from typing import List, Tuple def process_single_transaction(transaction: Tuple[int, str, float]) -> str: transaction_id, transaction_type, amount = transaction return f\\"Transaction {transaction_id}: {transaction_type} {amount} processed\\" def process_transactions(transaction_list: List[Tuple[int, str, float]], max_workers: int) -> List[str]: with ThreadPoolExecutor(max_workers=max_workers) as executor: results = list(executor.map(process_single_transaction, transaction_list)) return results"},{"question":"# Coding Assessment Question: Memory-Efficient Sudoku Solver **Context**: Sudoku is a popular logic-based combinatorial number-placement puzzle. The objective is to fill a 9x9 grid with numbers so that each column, each row, and each of the nine 3x3 subgrids contains all of the digits from 1 to 9, without repetition. Standard solving algorithms typically rely on backtracking methods that can be memory-intensive. **Objective**: Your task is to write a memory-efficient Sudoku solver. The solver must use optimized techniques to reduce memory usage while solving the puzzle. **Function Signature**: ```python def solve_sudoku(board: List[List[int]]) -> List[List[int]]: Solves the given 9x9 Sudoku puzzle in-place. Args: - board (List[List[int]]): A 2D list representing a 9x9 Sudoku board where empty cells are represented by 0. Returns: - List[List[int]]: The solved Sudoku board. pass ``` **Expected Input/Output**: * Input: `board` is a 9x9 list of lists containing integers from 0 to 9, where 0 represents an empty cell. * Output: A 9x9 list of lists representing the solved board. **Constraints**: 1. The board is guaranteed to have at least one valid solution. 2. The input board will always be a 9x9 grid. 3. You must solve the board in place, minimizing additional memory usage. **Requirements**: - **Edge Cases**: Ensure the solver finds solutions for boards with multiple empty cells in various positions. - **Performance**: Implement efficient logic to reduce backtracking where possible to conserve memory. **Challenge**: Optimize the backtracking algorithm to use as little memory as possible. Employ strategies to quickly rule out invalid number placements and minimize the number of recursive calls.","solution":"def solve_sudoku(board): Solves the given 9x9 Sudoku puzzle in-place. Args: - board (List[List[int]]): A 2D list representing a 9x9 Sudoku board where empty cells are represented by 0. Returns: - List[List[int]]: The solved Sudoku board. def is_valid(board, row, col, num): # Check the row for i in range(9): if board[row][i] == num: return False # Check the column for i in range(9): if board[i][col] == num: return False # Check the 3x3 subgrid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True solve(board) return board"},{"question":"# Problem Statement You are given a list of integers representing the heights of mountains in a range. Your task is to determine the maximum difference in height between two mountains that are separated by at least one other mountain in the range. Write a function `max_height_diff(nums: List[int]) -> int` which takes a list of integers `nums` representing the heights of the mountains and returns the maximum difference in height between two mountains that are separated by at least one other mountain in the list. # Function Signature ```python def max_height_diff(nums: List[int]) -> int: pass ``` # Input: - `nums` (List[int]): A list of integers representing the heights of the mountains. The list contains at least three integers. # Output: - An integer representing the maximum height difference. # Constraints: - 3 ≤ len(nums) ≤ 10^5 - 1 ≤ nums[i] ≤ 10^5 # Example Given the following list of mountain heights: ```python nums = [1, 5, 3, 19, 18, 25] ``` The result would be ```python max_height_diff(nums) -> 24 ``` # Notes: - Ensure the function handles a large number of elements efficiently. - Consider edge cases where the heights might be very close to each other. - Test cases will include various lengths and ranges of heights for robustness.","solution":"from typing import List def max_height_diff(nums: List[int]) -> int: Finds the maximum difference in height between two mountains that are separated by at least one other mountain in the list. if len(nums) < 3: raise ValueError(\\"The list must contain at least three mountains\\") max_diff = 0 for i in range(1, len(nums) - 1): for j in range(i + 1, len(nums)): diff = abs(nums[i - 1] - nums[j]) if diff > max_diff: max_diff = diff return max_diff"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},F={class:"card-container"},O={key:0,class:"empty-state"},R=["disabled"],D={key:0},P={key:1};function z(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",O,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",D,"See more"))],8,R)):u("",!0)])}const Y=c(N,[["render",z],["__scopeId","data-v-dafb1ceb"]]),j=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/17.md","filePath":"drive/17.md"}'),B={name:"drive/17.md"},U=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{j as __pageData,U as default};
